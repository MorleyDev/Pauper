/******/ (function(modules) { // webpackBootstrap
/******/ 	function hotDisposeChunk(chunkId) {
/******/ 		delete installedChunks[chunkId];
/******/ 	}
/******/ 	var parentHotUpdateCallback = window["webpackHotUpdate"];
/******/ 	window["webpackHotUpdate"] = 
/******/ 	function webpackHotUpdateCallback(chunkId, moreModules) { // eslint-disable-line no-unused-vars
/******/ 		hotAddUpdateChunk(chunkId, moreModules);
/******/ 		if(parentHotUpdateCallback) parentHotUpdateCallback(chunkId, moreModules);
/******/ 	} ;
/******/ 	
/******/ 	function hotDownloadUpdateChunk(chunkId) { // eslint-disable-line no-unused-vars
/******/ 		var head = document.getElementsByTagName("head")[0];
/******/ 		var script = document.createElement("script");
/******/ 		script.type = "text/javascript";
/******/ 		script.charset = "utf-8";
/******/ 		script.src = __webpack_require__.p + "" + chunkId + "." + hotCurrentHash + ".hot-update.js";
/******/ 		;
/******/ 		head.appendChild(script);
/******/ 	}
/******/ 	
/******/ 	function hotDownloadManifest(requestTimeout) { // eslint-disable-line no-unused-vars
/******/ 		requestTimeout = requestTimeout || 10000;
/******/ 		return new Promise(function(resolve, reject) {
/******/ 			if(typeof XMLHttpRequest === "undefined")
/******/ 				return reject(new Error("No browser support"));
/******/ 			try {
/******/ 				var request = new XMLHttpRequest();
/******/ 				var requestPath = __webpack_require__.p + "" + hotCurrentHash + ".hot-update.json";
/******/ 				request.open("GET", requestPath, true);
/******/ 				request.timeout = requestTimeout;
/******/ 				request.send(null);
/******/ 			} catch(err) {
/******/ 				return reject(err);
/******/ 			}
/******/ 			request.onreadystatechange = function() {
/******/ 				if(request.readyState !== 4) return;
/******/ 				if(request.status === 0) {
/******/ 					// timeout
/******/ 					reject(new Error("Manifest request to " + requestPath + " timed out."));
/******/ 				} else if(request.status === 404) {
/******/ 					// no update available
/******/ 					resolve();
/******/ 				} else if(request.status !== 200 && request.status !== 304) {
/******/ 					// other failure
/******/ 					reject(new Error("Manifest request to " + requestPath + " failed."));
/******/ 				} else {
/******/ 					// success
/******/ 					try {
/******/ 						var update = JSON.parse(request.responseText);
/******/ 					} catch(e) {
/******/ 						reject(e);
/******/ 						return;
/******/ 					}
/******/ 					resolve(update);
/******/ 				}
/******/ 			};
/******/ 		});
/******/ 	}
/******/
/******/ 	
/******/ 	
/******/ 	var hotApplyOnUpdate = true;
/******/ 	var hotCurrentHash = "92406b8b13016cc14f56"; // eslint-disable-line no-unused-vars
/******/ 	var hotRequestTimeout = 10000;
/******/ 	var hotCurrentModuleData = {};
/******/ 	var hotCurrentChildModule; // eslint-disable-line no-unused-vars
/******/ 	var hotCurrentParents = []; // eslint-disable-line no-unused-vars
/******/ 	var hotCurrentParentsTemp = []; // eslint-disable-line no-unused-vars
/******/ 	
/******/ 	function hotCreateRequire(moduleId) { // eslint-disable-line no-unused-vars
/******/ 		var me = installedModules[moduleId];
/******/ 		if(!me) return __webpack_require__;
/******/ 		var fn = function(request) {
/******/ 			if(me.hot.active) {
/******/ 				if(installedModules[request]) {
/******/ 					if(installedModules[request].parents.indexOf(moduleId) < 0)
/******/ 						installedModules[request].parents.push(moduleId);
/******/ 				} else {
/******/ 					hotCurrentParents = [moduleId];
/******/ 					hotCurrentChildModule = request;
/******/ 				}
/******/ 				if(me.children.indexOf(request) < 0)
/******/ 					me.children.push(request);
/******/ 			} else {
/******/ 				console.warn("[HMR] unexpected require(" + request + ") from disposed module " + moduleId);
/******/ 				hotCurrentParents = [];
/******/ 			}
/******/ 			return __webpack_require__(request);
/******/ 		};
/******/ 		var ObjectFactory = function ObjectFactory(name) {
/******/ 			return {
/******/ 				configurable: true,
/******/ 				enumerable: true,
/******/ 				get: function() {
/******/ 					return __webpack_require__[name];
/******/ 				},
/******/ 				set: function(value) {
/******/ 					__webpack_require__[name] = value;
/******/ 				}
/******/ 			};
/******/ 		};
/******/ 		for(var name in __webpack_require__) {
/******/ 			if(Object.prototype.hasOwnProperty.call(__webpack_require__, name) && name !== "e") {
/******/ 				Object.defineProperty(fn, name, ObjectFactory(name));
/******/ 			}
/******/ 		}
/******/ 		fn.e = function(chunkId) {
/******/ 			if(hotStatus === "ready")
/******/ 				hotSetStatus("prepare");
/******/ 			hotChunksLoading++;
/******/ 			return __webpack_require__.e(chunkId).then(finishChunkLoading, function(err) {
/******/ 				finishChunkLoading();
/******/ 				throw err;
/******/ 			});
/******/ 	
/******/ 			function finishChunkLoading() {
/******/ 				hotChunksLoading--;
/******/ 				if(hotStatus === "prepare") {
/******/ 					if(!hotWaitingFilesMap[chunkId]) {
/******/ 						hotEnsureUpdateChunk(chunkId);
/******/ 					}
/******/ 					if(hotChunksLoading === 0 && hotWaitingFiles === 0) {
/******/ 						hotUpdateDownloaded();
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 		return fn;
/******/ 	}
/******/ 	
/******/ 	function hotCreateModule(moduleId) { // eslint-disable-line no-unused-vars
/******/ 		var hot = {
/******/ 			// private stuff
/******/ 			_acceptedDependencies: {},
/******/ 			_declinedDependencies: {},
/******/ 			_selfAccepted: false,
/******/ 			_selfDeclined: false,
/******/ 			_disposeHandlers: [],
/******/ 			_main: hotCurrentChildModule !== moduleId,
/******/ 	
/******/ 			// Module API
/******/ 			active: true,
/******/ 			accept: function(dep, callback) {
/******/ 				if(typeof dep === "undefined")
/******/ 					hot._selfAccepted = true;
/******/ 				else if(typeof dep === "function")
/******/ 					hot._selfAccepted = dep;
/******/ 				else if(typeof dep === "object")
/******/ 					for(var i = 0; i < dep.length; i++)
/******/ 						hot._acceptedDependencies[dep[i]] = callback || function() {};
/******/ 				else
/******/ 					hot._acceptedDependencies[dep] = callback || function() {};
/******/ 			},
/******/ 			decline: function(dep) {
/******/ 				if(typeof dep === "undefined")
/******/ 					hot._selfDeclined = true;
/******/ 				else if(typeof dep === "object")
/******/ 					for(var i = 0; i < dep.length; i++)
/******/ 						hot._declinedDependencies[dep[i]] = true;
/******/ 				else
/******/ 					hot._declinedDependencies[dep] = true;
/******/ 			},
/******/ 			dispose: function(callback) {
/******/ 				hot._disposeHandlers.push(callback);
/******/ 			},
/******/ 			addDisposeHandler: function(callback) {
/******/ 				hot._disposeHandlers.push(callback);
/******/ 			},
/******/ 			removeDisposeHandler: function(callback) {
/******/ 				var idx = hot._disposeHandlers.indexOf(callback);
/******/ 				if(idx >= 0) hot._disposeHandlers.splice(idx, 1);
/******/ 			},
/******/ 	
/******/ 			// Management API
/******/ 			check: hotCheck,
/******/ 			apply: hotApply,
/******/ 			status: function(l) {
/******/ 				if(!l) return hotStatus;
/******/ 				hotStatusHandlers.push(l);
/******/ 			},
/******/ 			addStatusHandler: function(l) {
/******/ 				hotStatusHandlers.push(l);
/******/ 			},
/******/ 			removeStatusHandler: function(l) {
/******/ 				var idx = hotStatusHandlers.indexOf(l);
/******/ 				if(idx >= 0) hotStatusHandlers.splice(idx, 1);
/******/ 			},
/******/ 	
/******/ 			//inherit from previous dispose call
/******/ 			data: hotCurrentModuleData[moduleId]
/******/ 		};
/******/ 		hotCurrentChildModule = undefined;
/******/ 		return hot;
/******/ 	}
/******/ 	
/******/ 	var hotStatusHandlers = [];
/******/ 	var hotStatus = "idle";
/******/ 	
/******/ 	function hotSetStatus(newStatus) {
/******/ 		hotStatus = newStatus;
/******/ 		for(var i = 0; i < hotStatusHandlers.length; i++)
/******/ 			hotStatusHandlers[i].call(null, newStatus);
/******/ 	}
/******/ 	
/******/ 	// while downloading
/******/ 	var hotWaitingFiles = 0;
/******/ 	var hotChunksLoading = 0;
/******/ 	var hotWaitingFilesMap = {};
/******/ 	var hotRequestedFilesMap = {};
/******/ 	var hotAvailableFilesMap = {};
/******/ 	var hotDeferred;
/******/ 	
/******/ 	// The update info
/******/ 	var hotUpdate, hotUpdateNewHash;
/******/ 	
/******/ 	function toModuleId(id) {
/******/ 		var isNumber = (+id) + "" === id;
/******/ 		return isNumber ? +id : id;
/******/ 	}
/******/ 	
/******/ 	function hotCheck(apply) {
/******/ 		if(hotStatus !== "idle") throw new Error("check() is only allowed in idle status");
/******/ 		hotApplyOnUpdate = apply;
/******/ 		hotSetStatus("check");
/******/ 		return hotDownloadManifest(hotRequestTimeout).then(function(update) {
/******/ 			if(!update) {
/******/ 				hotSetStatus("idle");
/******/ 				return null;
/******/ 			}
/******/ 			hotRequestedFilesMap = {};
/******/ 			hotWaitingFilesMap = {};
/******/ 			hotAvailableFilesMap = update.c;
/******/ 			hotUpdateNewHash = update.h;
/******/ 	
/******/ 			hotSetStatus("prepare");
/******/ 			var promise = new Promise(function(resolve, reject) {
/******/ 				hotDeferred = {
/******/ 					resolve: resolve,
/******/ 					reject: reject
/******/ 				};
/******/ 			});
/******/ 			hotUpdate = {};
/******/ 			var chunkId = 2;
/******/ 			{ // eslint-disable-line no-lone-blocks
/******/ 				/*globals chunkId */
/******/ 				hotEnsureUpdateChunk(chunkId);
/******/ 			}
/******/ 			if(hotStatus === "prepare" && hotChunksLoading === 0 && hotWaitingFiles === 0) {
/******/ 				hotUpdateDownloaded();
/******/ 			}
/******/ 			return promise;
/******/ 		});
/******/ 	}
/******/ 	
/******/ 	function hotAddUpdateChunk(chunkId, moreModules) { // eslint-disable-line no-unused-vars
/******/ 		if(!hotAvailableFilesMap[chunkId] || !hotRequestedFilesMap[chunkId])
/******/ 			return;
/******/ 		hotRequestedFilesMap[chunkId] = false;
/******/ 		for(var moduleId in moreModules) {
/******/ 			if(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {
/******/ 				hotUpdate[moduleId] = moreModules[moduleId];
/******/ 			}
/******/ 		}
/******/ 		if(--hotWaitingFiles === 0 && hotChunksLoading === 0) {
/******/ 			hotUpdateDownloaded();
/******/ 		}
/******/ 	}
/******/ 	
/******/ 	function hotEnsureUpdateChunk(chunkId) {
/******/ 		if(!hotAvailableFilesMap[chunkId]) {
/******/ 			hotWaitingFilesMap[chunkId] = true;
/******/ 		} else {
/******/ 			hotRequestedFilesMap[chunkId] = true;
/******/ 			hotWaitingFiles++;
/******/ 			hotDownloadUpdateChunk(chunkId);
/******/ 		}
/******/ 	}
/******/ 	
/******/ 	function hotUpdateDownloaded() {
/******/ 		hotSetStatus("ready");
/******/ 		var deferred = hotDeferred;
/******/ 		hotDeferred = null;
/******/ 		if(!deferred) return;
/******/ 		if(hotApplyOnUpdate) {
/******/ 			// Wrap deferred object in Promise to mark it as a well-handled Promise to
/******/ 			// avoid triggering uncaught exception warning in Chrome.
/******/ 			// See https://bugs.chromium.org/p/chromium/issues/detail?id=465666
/******/ 			Promise.resolve().then(function() {
/******/ 				return hotApply(hotApplyOnUpdate);
/******/ 			}).then(
/******/ 				function(result) {
/******/ 					deferred.resolve(result);
/******/ 				},
/******/ 				function(err) {
/******/ 					deferred.reject(err);
/******/ 				}
/******/ 			);
/******/ 		} else {
/******/ 			var outdatedModules = [];
/******/ 			for(var id in hotUpdate) {
/******/ 				if(Object.prototype.hasOwnProperty.call(hotUpdate, id)) {
/******/ 					outdatedModules.push(toModuleId(id));
/******/ 				}
/******/ 			}
/******/ 			deferred.resolve(outdatedModules);
/******/ 		}
/******/ 	}
/******/ 	
/******/ 	function hotApply(options) {
/******/ 		if(hotStatus !== "ready") throw new Error("apply() is only allowed in ready status");
/******/ 		options = options || {};
/******/ 	
/******/ 		var cb;
/******/ 		var i;
/******/ 		var j;
/******/ 		var module;
/******/ 		var moduleId;
/******/ 	
/******/ 		function getAffectedStuff(updateModuleId) {
/******/ 			var outdatedModules = [updateModuleId];
/******/ 			var outdatedDependencies = {};
/******/ 	
/******/ 			var queue = outdatedModules.slice().map(function(id) {
/******/ 				return {
/******/ 					chain: [id],
/******/ 					id: id
/******/ 				};
/******/ 			});
/******/ 			while(queue.length > 0) {
/******/ 				var queueItem = queue.pop();
/******/ 				var moduleId = queueItem.id;
/******/ 				var chain = queueItem.chain;
/******/ 				module = installedModules[moduleId];
/******/ 				if(!module || module.hot._selfAccepted)
/******/ 					continue;
/******/ 				if(module.hot._selfDeclined) {
/******/ 					return {
/******/ 						type: "self-declined",
/******/ 						chain: chain,
/******/ 						moduleId: moduleId
/******/ 					};
/******/ 				}
/******/ 				if(module.hot._main) {
/******/ 					return {
/******/ 						type: "unaccepted",
/******/ 						chain: chain,
/******/ 						moduleId: moduleId
/******/ 					};
/******/ 				}
/******/ 				for(var i = 0; i < module.parents.length; i++) {
/******/ 					var parentId = module.parents[i];
/******/ 					var parent = installedModules[parentId];
/******/ 					if(!parent) continue;
/******/ 					if(parent.hot._declinedDependencies[moduleId]) {
/******/ 						return {
/******/ 							type: "declined",
/******/ 							chain: chain.concat([parentId]),
/******/ 							moduleId: moduleId,
/******/ 							parentId: parentId
/******/ 						};
/******/ 					}
/******/ 					if(outdatedModules.indexOf(parentId) >= 0) continue;
/******/ 					if(parent.hot._acceptedDependencies[moduleId]) {
/******/ 						if(!outdatedDependencies[parentId])
/******/ 							outdatedDependencies[parentId] = [];
/******/ 						addAllToSet(outdatedDependencies[parentId], [moduleId]);
/******/ 						continue;
/******/ 					}
/******/ 					delete outdatedDependencies[parentId];
/******/ 					outdatedModules.push(parentId);
/******/ 					queue.push({
/******/ 						chain: chain.concat([parentId]),
/******/ 						id: parentId
/******/ 					});
/******/ 				}
/******/ 			}
/******/ 	
/******/ 			return {
/******/ 				type: "accepted",
/******/ 				moduleId: updateModuleId,
/******/ 				outdatedModules: outdatedModules,
/******/ 				outdatedDependencies: outdatedDependencies
/******/ 			};
/******/ 		}
/******/ 	
/******/ 		function addAllToSet(a, b) {
/******/ 			for(var i = 0; i < b.length; i++) {
/******/ 				var item = b[i];
/******/ 				if(a.indexOf(item) < 0)
/******/ 					a.push(item);
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		// at begin all updates modules are outdated
/******/ 		// the "outdated" status can propagate to parents if they don't accept the children
/******/ 		var outdatedDependencies = {};
/******/ 		var outdatedModules = [];
/******/ 		var appliedUpdate = {};
/******/ 	
/******/ 		var warnUnexpectedRequire = function warnUnexpectedRequire() {
/******/ 			console.warn("[HMR] unexpected require(" + result.moduleId + ") to disposed module");
/******/ 		};
/******/ 	
/******/ 		for(var id in hotUpdate) {
/******/ 			if(Object.prototype.hasOwnProperty.call(hotUpdate, id)) {
/******/ 				moduleId = toModuleId(id);
/******/ 				var result;
/******/ 				if(hotUpdate[id]) {
/******/ 					result = getAffectedStuff(moduleId);
/******/ 				} else {
/******/ 					result = {
/******/ 						type: "disposed",
/******/ 						moduleId: id
/******/ 					};
/******/ 				}
/******/ 				var abortError = false;
/******/ 				var doApply = false;
/******/ 				var doDispose = false;
/******/ 				var chainInfo = "";
/******/ 				if(result.chain) {
/******/ 					chainInfo = "\nUpdate propagation: " + result.chain.join(" -> ");
/******/ 				}
/******/ 				switch(result.type) {
/******/ 					case "self-declined":
/******/ 						if(options.onDeclined)
/******/ 							options.onDeclined(result);
/******/ 						if(!options.ignoreDeclined)
/******/ 							abortError = new Error("Aborted because of self decline: " + result.moduleId + chainInfo);
/******/ 						break;
/******/ 					case "declined":
/******/ 						if(options.onDeclined)
/******/ 							options.onDeclined(result);
/******/ 						if(!options.ignoreDeclined)
/******/ 							abortError = new Error("Aborted because of declined dependency: " + result.moduleId + " in " + result.parentId + chainInfo);
/******/ 						break;
/******/ 					case "unaccepted":
/******/ 						if(options.onUnaccepted)
/******/ 							options.onUnaccepted(result);
/******/ 						if(!options.ignoreUnaccepted)
/******/ 							abortError = new Error("Aborted because " + moduleId + " is not accepted" + chainInfo);
/******/ 						break;
/******/ 					case "accepted":
/******/ 						if(options.onAccepted)
/******/ 							options.onAccepted(result);
/******/ 						doApply = true;
/******/ 						break;
/******/ 					case "disposed":
/******/ 						if(options.onDisposed)
/******/ 							options.onDisposed(result);
/******/ 						doDispose = true;
/******/ 						break;
/******/ 					default:
/******/ 						throw new Error("Unexception type " + result.type);
/******/ 				}
/******/ 				if(abortError) {
/******/ 					hotSetStatus("abort");
/******/ 					return Promise.reject(abortError);
/******/ 				}
/******/ 				if(doApply) {
/******/ 					appliedUpdate[moduleId] = hotUpdate[moduleId];
/******/ 					addAllToSet(outdatedModules, result.outdatedModules);
/******/ 					for(moduleId in result.outdatedDependencies) {
/******/ 						if(Object.prototype.hasOwnProperty.call(result.outdatedDependencies, moduleId)) {
/******/ 							if(!outdatedDependencies[moduleId])
/******/ 								outdatedDependencies[moduleId] = [];
/******/ 							addAllToSet(outdatedDependencies[moduleId], result.outdatedDependencies[moduleId]);
/******/ 						}
/******/ 					}
/******/ 				}
/******/ 				if(doDispose) {
/******/ 					addAllToSet(outdatedModules, [result.moduleId]);
/******/ 					appliedUpdate[moduleId] = warnUnexpectedRequire;
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		// Store self accepted outdated modules to require them later by the module system
/******/ 		var outdatedSelfAcceptedModules = [];
/******/ 		for(i = 0; i < outdatedModules.length; i++) {
/******/ 			moduleId = outdatedModules[i];
/******/ 			if(installedModules[moduleId] && installedModules[moduleId].hot._selfAccepted)
/******/ 				outdatedSelfAcceptedModules.push({
/******/ 					module: moduleId,
/******/ 					errorHandler: installedModules[moduleId].hot._selfAccepted
/******/ 				});
/******/ 		}
/******/ 	
/******/ 		// Now in "dispose" phase
/******/ 		hotSetStatus("dispose");
/******/ 		Object.keys(hotAvailableFilesMap).forEach(function(chunkId) {
/******/ 			if(hotAvailableFilesMap[chunkId] === false) {
/******/ 				hotDisposeChunk(chunkId);
/******/ 			}
/******/ 		});
/******/ 	
/******/ 		var idx;
/******/ 		var queue = outdatedModules.slice();
/******/ 		while(queue.length > 0) {
/******/ 			moduleId = queue.pop();
/******/ 			module = installedModules[moduleId];
/******/ 			if(!module) continue;
/******/ 	
/******/ 			var data = {};
/******/ 	
/******/ 			// Call dispose handlers
/******/ 			var disposeHandlers = module.hot._disposeHandlers;
/******/ 			for(j = 0; j < disposeHandlers.length; j++) {
/******/ 				cb = disposeHandlers[j];
/******/ 				cb(data);
/******/ 			}
/******/ 			hotCurrentModuleData[moduleId] = data;
/******/ 	
/******/ 			// disable module (this disables requires from this module)
/******/ 			module.hot.active = false;
/******/ 	
/******/ 			// remove module from cache
/******/ 			delete installedModules[moduleId];
/******/ 	
/******/ 			// when disposing there is no need to call dispose handler
/******/ 			delete outdatedDependencies[moduleId];
/******/ 	
/******/ 			// remove "parents" references from all children
/******/ 			for(j = 0; j < module.children.length; j++) {
/******/ 				var child = installedModules[module.children[j]];
/******/ 				if(!child) continue;
/******/ 				idx = child.parents.indexOf(moduleId);
/******/ 				if(idx >= 0) {
/******/ 					child.parents.splice(idx, 1);
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		// remove outdated dependency from module children
/******/ 		var dependency;
/******/ 		var moduleOutdatedDependencies;
/******/ 		for(moduleId in outdatedDependencies) {
/******/ 			if(Object.prototype.hasOwnProperty.call(outdatedDependencies, moduleId)) {
/******/ 				module = installedModules[moduleId];
/******/ 				if(module) {
/******/ 					moduleOutdatedDependencies = outdatedDependencies[moduleId];
/******/ 					for(j = 0; j < moduleOutdatedDependencies.length; j++) {
/******/ 						dependency = moduleOutdatedDependencies[j];
/******/ 						idx = module.children.indexOf(dependency);
/******/ 						if(idx >= 0) module.children.splice(idx, 1);
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		// Not in "apply" phase
/******/ 		hotSetStatus("apply");
/******/ 	
/******/ 		hotCurrentHash = hotUpdateNewHash;
/******/ 	
/******/ 		// insert new code
/******/ 		for(moduleId in appliedUpdate) {
/******/ 			if(Object.prototype.hasOwnProperty.call(appliedUpdate, moduleId)) {
/******/ 				modules[moduleId] = appliedUpdate[moduleId];
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		// call accept handlers
/******/ 		var error = null;
/******/ 		for(moduleId in outdatedDependencies) {
/******/ 			if(Object.prototype.hasOwnProperty.call(outdatedDependencies, moduleId)) {
/******/ 				module = installedModules[moduleId];
/******/ 				if(module) {
/******/ 					moduleOutdatedDependencies = outdatedDependencies[moduleId];
/******/ 					var callbacks = [];
/******/ 					for(i = 0; i < moduleOutdatedDependencies.length; i++) {
/******/ 						dependency = moduleOutdatedDependencies[i];
/******/ 						cb = module.hot._acceptedDependencies[dependency];
/******/ 						if(cb) {
/******/ 							if(callbacks.indexOf(cb) >= 0) continue;
/******/ 							callbacks.push(cb);
/******/ 						}
/******/ 					}
/******/ 					for(i = 0; i < callbacks.length; i++) {
/******/ 						cb = callbacks[i];
/******/ 						try {
/******/ 							cb(moduleOutdatedDependencies);
/******/ 						} catch(err) {
/******/ 							if(options.onErrored) {
/******/ 								options.onErrored({
/******/ 									type: "accept-errored",
/******/ 									moduleId: moduleId,
/******/ 									dependencyId: moduleOutdatedDependencies[i],
/******/ 									error: err
/******/ 								});
/******/ 							}
/******/ 							if(!options.ignoreErrored) {
/******/ 								if(!error)
/******/ 									error = err;
/******/ 							}
/******/ 						}
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		// Load self accepted modules
/******/ 		for(i = 0; i < outdatedSelfAcceptedModules.length; i++) {
/******/ 			var item = outdatedSelfAcceptedModules[i];
/******/ 			moduleId = item.module;
/******/ 			hotCurrentParents = [moduleId];
/******/ 			try {
/******/ 				__webpack_require__(moduleId);
/******/ 			} catch(err) {
/******/ 				if(typeof item.errorHandler === "function") {
/******/ 					try {
/******/ 						item.errorHandler(err);
/******/ 					} catch(err2) {
/******/ 						if(options.onErrored) {
/******/ 							options.onErrored({
/******/ 								type: "self-accept-error-handler-errored",
/******/ 								moduleId: moduleId,
/******/ 								error: err2,
/******/ 								orginalError: err, // TODO remove in webpack 4
/******/ 								originalError: err
/******/ 							});
/******/ 						}
/******/ 						if(!options.ignoreErrored) {
/******/ 							if(!error)
/******/ 								error = err2;
/******/ 						}
/******/ 						if(!error)
/******/ 							error = err;
/******/ 					}
/******/ 				} else {
/******/ 					if(options.onErrored) {
/******/ 						options.onErrored({
/******/ 							type: "self-accept-errored",
/******/ 							moduleId: moduleId,
/******/ 							error: err
/******/ 						});
/******/ 					}
/******/ 					if(!options.ignoreErrored) {
/******/ 						if(!error)
/******/ 							error = err;
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		// handle errors in accept handlers and self accepted module load
/******/ 		if(error) {
/******/ 			hotSetStatus("fail");
/******/ 			return Promise.reject(error);
/******/ 		}
/******/ 	
/******/ 		hotSetStatus("idle");
/******/ 		return new Promise(function(resolve) {
/******/ 			resolve(outdatedModules);
/******/ 		});
/******/ 	}
/******/
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {},
/******/ 			hot: hotCreateModule(moduleId),
/******/ 			parents: (hotCurrentParentsTemp = hotCurrentParents, hotCurrentParents = [], hotCurrentParentsTemp),
/******/ 			children: []
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, hotCreateRequire(moduleId));
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// __webpack_hash__
/******/ 	__webpack_require__.h = function() { return hotCurrentHash; };
/******/
/******/ 	// Load entry module and return exports
/******/ 	return hotCreateRequire("./src/index.ts")(__webpack_require__.s = "./src/index.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/@babel/polyfill/lib/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {

__webpack_require__("./node_modules/core-js/shim.js");

__webpack_require__("./node_modules/regenerator-runtime/runtime.js");

if (global._babelPolyfill) {
  throw new Error("only one instance of @babel/polyfill is allowed");
}

global._babelPolyfill = true;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__("./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/@morleydev/functional-pipe/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var Iterables = __webpack_require__("./node_modules/@morleydev/functional-pipe/iterable/operators.js");

exports.Iterables = Iterables;

var Generators = __webpack_require__("./node_modules/@morleydev/functional-pipe/iterable/generators.js");

exports.Generators = Generators;

var pipe_1 = __webpack_require__("./node_modules/@morleydev/functional-pipe/pipe.js");

exports.$$ = pipe_1.$$; //# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@morleydev/functional-pipe/iterable/generators.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _marked =
/*#__PURE__*/
regeneratorRuntime.mark(range),
    _marked2 =
/*#__PURE__*/
regeneratorRuntime.mark(infinite),
    _marked3 =
/*#__PURE__*/
regeneratorRuntime.mark(empty),
    _marked4 =
/*#__PURE__*/
regeneratorRuntime.mark(concat),
    _marked5 =
/*#__PURE__*/
regeneratorRuntime.mark(keys),
    _marked6 =
/*#__PURE__*/
regeneratorRuntime.mark(values);

Object.defineProperty(exports, "__esModule", {
  value: true
});

function range(start, count) {
  var i;
  return regeneratorRuntime.wrap(function range$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          i = 0;

        case 1:
          if (!(i < count)) {
            _context.next = 7;
            break;
          }

          _context.next = 4;
          return start + i;

        case 4:
          ++i;
          _context.next = 1;
          break;

        case 7:
        case "end":
          return _context.stop();
      }
    }
  }, _marked, this);
}

exports.range = range;

function infinite() {
  var i;
  return regeneratorRuntime.wrap(function infinite$(_context2) {
    while (1) {
      switch (_context2.prev = _context2.next) {
        case 0:
          i = 0;

        case 1:
          _context2.next = 3;
          return i;

        case 3:
          ++i;
          _context2.next = 1;
          break;

        case 6:
        case "end":
          return _context2.stop();
      }
    }
  }, _marked2, this);
}

exports.infinite = infinite;

function empty() {
  return regeneratorRuntime.wrap(function empty$(_context3) {
    while (1) {
      switch (_context3.prev = _context3.next) {
        case 0:
        case "end":
          return _context3.stop();
      }
    }
  }, _marked3, this);
}

exports.empty = empty;

function concat() {
  var _len,
      iterables,
      _key,
      _i,
      iterable,
      _args4 = arguments;

  return regeneratorRuntime.wrap(function concat$(_context4) {
    while (1) {
      switch (_context4.prev = _context4.next) {
        case 0:
          for (_len = _args4.length, iterables = new Array(_len), _key = 0; _key < _len; _key++) {
            iterables[_key] = _args4[_key];
          }

          _i = 0;

        case 2:
          if (!(_i < iterables.length)) {
            _context4.next = 8;
            break;
          }

          iterable = iterables[_i];
          return _context4.delegateYield(iterable, "t0", 5);

        case 5:
          _i++;
          _context4.next = 2;
          break;

        case 8:
        case "end":
          return _context4.stop();
      }
    }
  }, _marked4, this);
}

exports.concat = concat;

function keys(item) {
  var key;
  return regeneratorRuntime.wrap(function keys$(_context5) {
    while (1) {
      switch (_context5.prev = _context5.next) {
        case 0:
          _context5.t0 = regeneratorRuntime.keys(item);

        case 1:
          if ((_context5.t1 = _context5.t0()).done) {
            _context5.next = 7;
            break;
          }

          key = _context5.t1.value;
          _context5.next = 5;
          return key;

        case 5:
          _context5.next = 1;
          break;

        case 7:
        case "end":
          return _context5.stop();
      }
    }
  }, _marked5, this);
}

exports.keys = keys;

function values(item) {
  var key;
  return regeneratorRuntime.wrap(function values$(_context6) {
    while (1) {
      switch (_context6.prev = _context6.next) {
        case 0:
          _context6.t0 = regeneratorRuntime.keys(item);

        case 1:
          if ((_context6.t1 = _context6.t0()).done) {
            _context6.next = 7;
            break;
          }

          key = _context6.t1.value;
          _context6.next = 5;
          return item[key];

        case 5:
          _context6.next = 1;
          break;

        case 7:
        case "end":
          return _context6.stop();
      }
    }
  }, _marked6, this);
}

exports.values = values; //# sourceMappingURL=generators.js.map

/***/ }),

/***/ "./node_modules/@morleydev/functional-pipe/iterable/operators.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _marked =
/*#__PURE__*/
regeneratorRuntime.mark(unit),
    _marked2 =
/*#__PURE__*/
regeneratorRuntime.mark(distinct);

Object.defineProperty(exports, "__esModule", {
  value: true
});

function unit(iterable) {
  return regeneratorRuntime.wrap(function unit$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          return _context.delegateYield(iterable, "t0", 1);

        case 1:
          return _context.abrupt("return", _context.t0);

        case 2:
        case "end":
          return _context.stop();
      }
    }
  }, _marked, this);
}

exports.unit = unit;

function tap(tapper) {
  return (
    /*#__PURE__*/
    regeneratorRuntime.mark(function _callee(it) {
      var index, _iterator, _isArray, _i, _ref, _value;

      return regeneratorRuntime.wrap(function _callee$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              index = 0;
              _iterator = it, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();

            case 2:
              if (!_isArray) {
                _context2.next = 8;
                break;
              }

              if (!(_i >= _iterator.length)) {
                _context2.next = 5;
                break;
              }

              return _context2.abrupt("break", 19);

            case 5:
              _ref = _iterator[_i++];
              _context2.next = 12;
              break;

            case 8:
              _i = _iterator.next();

              if (!_i.done) {
                _context2.next = 11;
                break;
              }

              return _context2.abrupt("break", 19);

            case 11:
              _ref = _i.value;

            case 12:
              _value = _ref;
              tapper(_value, index);
              _context2.next = 16;
              return _value;

            case 16:
              index = index + 1;

            case 17:
              _context2.next = 2;
              break;

            case 19:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee, this);
    })
  );
}

exports.tap = tap;

function map(mapper) {
  return (
    /*#__PURE__*/
    regeneratorRuntime.mark(function _callee2(iterable) {
      var index, _iterator2, _isArray2, _i2, _ref2, _value2;

      return regeneratorRuntime.wrap(function _callee2$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              index = 0;
              _iterator2 = iterable, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();

            case 2:
              if (!_isArray2) {
                _context3.next = 8;
                break;
              }

              if (!(_i2 >= _iterator2.length)) {
                _context3.next = 5;
                break;
              }

              return _context3.abrupt("break", 18);

            case 5:
              _ref2 = _iterator2[_i2++];
              _context3.next = 12;
              break;

            case 8:
              _i2 = _iterator2.next();

              if (!_i2.done) {
                _context3.next = 11;
                break;
              }

              return _context3.abrupt("break", 18);

            case 11:
              _ref2 = _i2.value;

            case 12:
              _value2 = _ref2;
              _context3.next = 15;
              return mapper(_value2, index);

            case 15:
              index = index + 1;

            case 16:
              _context3.next = 2;
              break;

            case 18:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee2, this);
    })
  );
}

exports.map = map;

function flatMap(mapper) {
  return (
    /*#__PURE__*/
    regeneratorRuntime.mark(function _callee3(iterable) {
      var index, _iterator3, _isArray3, _i3, _ref3, _value3, innerIterable, _iterator4, _isArray4, _i4, _ref4, _inner;

      return regeneratorRuntime.wrap(function _callee3$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              index = 0;
              _iterator3 = iterable, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator]();

            case 2:
              if (!_isArray3) {
                _context4.next = 8;
                break;
              }

              if (!(_i3 >= _iterator3.length)) {
                _context4.next = 5;
                break;
              }

              return _context4.abrupt("break", 33);

            case 5:
              _ref3 = _iterator3[_i3++];
              _context4.next = 12;
              break;

            case 8:
              _i3 = _iterator3.next();

              if (!_i3.done) {
                _context4.next = 11;
                break;
              }

              return _context4.abrupt("break", 33);

            case 11:
              _ref3 = _i3.value;

            case 12:
              _value3 = _ref3;
              innerIterable = mapper(_value3, index);
              _iterator4 = innerIterable, _isArray4 = Array.isArray(_iterator4), _i4 = 0, _iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator]();

            case 15:
              if (!_isArray4) {
                _context4.next = 21;
                break;
              }

              if (!(_i4 >= _iterator4.length)) {
                _context4.next = 18;
                break;
              }

              return _context4.abrupt("break", 30);

            case 18:
              _ref4 = _iterator4[_i4++];
              _context4.next = 25;
              break;

            case 21:
              _i4 = _iterator4.next();

              if (!_i4.done) {
                _context4.next = 24;
                break;
              }

              return _context4.abrupt("break", 30);

            case 24:
              _ref4 = _i4.value;

            case 25:
              _inner = _ref4;
              _context4.next = 28;
              return _inner;

            case 28:
              _context4.next = 15;
              break;

            case 30:
              index = index + 1;

            case 31:
              _context4.next = 2;
              break;

            case 33:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee3, this);
    })
  );
}

exports.flatMap = flatMap;

function filter(predicate) {
  return (
    /*#__PURE__*/
    regeneratorRuntime.mark(function _callee4(iterable) {
      var index, _iterator5, _isArray5, _i5, _ref5, _value4;

      return regeneratorRuntime.wrap(function _callee4$(_context5) {
        while (1) {
          switch (_context5.prev = _context5.next) {
            case 0:
              index = 0;
              _iterator5 = iterable, _isArray5 = Array.isArray(_iterator5), _i5 = 0, _iterator5 = _isArray5 ? _iterator5 : _iterator5[Symbol.iterator]();

            case 2:
              if (!_isArray5) {
                _context5.next = 8;
                break;
              }

              if (!(_i5 >= _iterator5.length)) {
                _context5.next = 5;
                break;
              }

              return _context5.abrupt("break", 19);

            case 5:
              _ref5 = _iterator5[_i5++];
              _context5.next = 12;
              break;

            case 8:
              _i5 = _iterator5.next();

              if (!_i5.done) {
                _context5.next = 11;
                break;
              }

              return _context5.abrupt("break", 19);

            case 11:
              _ref5 = _i5.value;

            case 12:
              _value4 = _ref5;

              if (!predicate(_value4, index)) {
                _context5.next = 16;
                break;
              }

              _context5.next = 16;
              return _value4;

            case 16:
              index = index + 1;

            case 17:
              _context5.next = 2;
              break;

            case 19:
            case "end":
              return _context5.stop();
          }
        }
      }, _callee4, this);
    })
  );
}

exports.filter = filter;

function reduce(predicate, initial) {
  return function (iterable) {
    var index = 0;
    var prevState = initial;

    for (var _iterator6 = iterable, _isArray6 = Array.isArray(_iterator6), _i6 = 0, _iterator6 = _isArray6 ? _iterator6 : _iterator6[Symbol.iterator]();;) {
      var _ref6;

      if (_isArray6) {
        if (_i6 >= _iterator6.length) break;
        _ref6 = _iterator6[_i6++];
      } else {
        _i6 = _iterator6.next();
        if (_i6.done) break;
        _ref6 = _i6.value;
      }

      var _value5 = _ref6;
      prevState = predicate(prevState, _value5, index);
      index = index + 1;
    }

    return prevState;
  };
}

exports.reduce = reduce;

function scan(predicate, initial) {
  return (
    /*#__PURE__*/
    regeneratorRuntime.mark(function _callee5(iterable) {
      var index, prevState, _iterator7, _isArray7, _i7, _ref7, _value6;

      return regeneratorRuntime.wrap(function _callee5$(_context6) {
        while (1) {
          switch (_context6.prev = _context6.next) {
            case 0:
              index = 0;
              prevState = initial;
              _iterator7 = iterable, _isArray7 = Array.isArray(_iterator7), _i7 = 0, _iterator7 = _isArray7 ? _iterator7 : _iterator7[Symbol.iterator]();

            case 3:
              if (!_isArray7) {
                _context6.next = 9;
                break;
              }

              if (!(_i7 >= _iterator7.length)) {
                _context6.next = 6;
                break;
              }

              return _context6.abrupt("break", 20);

            case 6:
              _ref7 = _iterator7[_i7++];
              _context6.next = 13;
              break;

            case 9:
              _i7 = _iterator7.next();

              if (!_i7.done) {
                _context6.next = 12;
                break;
              }

              return _context6.abrupt("break", 20);

            case 12:
              _ref7 = _i7.value;

            case 13:
              _value6 = _ref7;
              prevState = predicate(prevState, _value6, index);
              _context6.next = 17;
              return prevState;

            case 17:
              index = index + 1;

            case 18:
              _context6.next = 3;
              break;

            case 20:
              return _context6.abrupt("return", prevState);

            case 21:
            case "end":
              return _context6.stop();
          }
        }
      }, _callee5, this);
    })
  );
}

exports.scan = scan;

function fold(predicate) {
  return function (iterable) {
    var _Array$from = Array.from(iterable),
        head = _Array$from[0],
        tail = _Array$from.slice(1);

    return reduce(predicate, head)(tail);
  };
}

exports.fold = fold;

function take(count) {
  return (
    /*#__PURE__*/
    regeneratorRuntime.mark(function _callee6(iterable) {
      var i, _iterator8, _isArray8, _i8, _ref8, _item;

      return regeneratorRuntime.wrap(function _callee6$(_context7) {
        while (1) {
          switch (_context7.prev = _context7.next) {
            case 0:
              i = 0;
              _iterator8 = iterable, _isArray8 = Array.isArray(_iterator8), _i8 = 0, _iterator8 = _isArray8 ? _iterator8 : _iterator8[Symbol.iterator]();

            case 2:
              if (!_isArray8) {
                _context7.next = 8;
                break;
              }

              if (!(_i8 >= _iterator8.length)) {
                _context7.next = 5;
                break;
              }

              return _context7.abrupt("break", 20);

            case 5:
              _ref8 = _iterator8[_i8++];
              _context7.next = 12;
              break;

            case 8:
              _i8 = _iterator8.next();

              if (!_i8.done) {
                _context7.next = 11;
                break;
              }

              return _context7.abrupt("break", 20);

            case 11:
              _ref8 = _i8.value;

            case 12:
              _item = _ref8;

              if (!(i >= count)) {
                _context7.next = 15;
                break;
              }

              return _context7.abrupt("return");

            case 15:
              _context7.next = 17;
              return _item;

            case 17:
              i = i + 1;

            case 18:
              _context7.next = 2;
              break;

            case 20:
            case "end":
              return _context7.stop();
          }
        }
      }, _callee6, this);
    })
  );
}

exports.take = take;

function last(iterable) {
  var last = undefined;

  for (var _iterator9 = iterable, _isArray9 = Array.isArray(_iterator9), _i9 = 0, _iterator9 = _isArray9 ? _iterator9 : _iterator9[Symbol.iterator]();;) {
    var _ref9;

    if (_isArray9) {
      if (_i9 >= _iterator9.length) break;
      _ref9 = _iterator9[_i9++];
    } else {
      _i9 = _iterator9.next();
      if (_i9.done) break;
      _ref9 = _i9.value;
    }

    var _item2 = _ref9;
    last = _item2;
  }

  return last;
}

exports.last = last;

function first(iterable) {
  for (var _iterator10 = iterable, _isArray10 = Array.isArray(_iterator10), _i10 = 0, _iterator10 = _isArray10 ? _iterator10 : _iterator10[Symbol.iterator]();;) {
    var _ref10;

    if (_isArray10) {
      if (_i10 >= _iterator10.length) break;
      _ref10 = _iterator10[_i10++];
    } else {
      _i10 = _iterator10.next();
      if (_i10.done) break;
      _ref10 = _i10.value;
    }

    var _item3 = _ref10;
    return _item3;
  }

  return undefined;
}

exports.first = first;

function skip(count) {
  return (
    /*#__PURE__*/
    regeneratorRuntime.mark(function _callee7(iterable) {
      var i, _iterator11, _isArray11, _i11, _ref11, _item4;

      return regeneratorRuntime.wrap(function _callee7$(_context8) {
        while (1) {
          switch (_context8.prev = _context8.next) {
            case 0:
              i = 0;
              _iterator11 = iterable, _isArray11 = Array.isArray(_iterator11), _i11 = 0, _iterator11 = _isArray11 ? _iterator11 : _iterator11[Symbol.iterator]();

            case 2:
              if (!_isArray11) {
                _context8.next = 8;
                break;
              }

              if (!(_i11 >= _iterator11.length)) {
                _context8.next = 5;
                break;
              }

              return _context8.abrupt("break", 19);

            case 5:
              _ref11 = _iterator11[_i11++];
              _context8.next = 12;
              break;

            case 8:
              _i11 = _iterator11.next();

              if (!_i11.done) {
                _context8.next = 11;
                break;
              }

              return _context8.abrupt("break", 19);

            case 11:
              _ref11 = _i11.value;

            case 12:
              _item4 = _ref11;

              if (!(i >= count)) {
                _context8.next = 16;
                break;
              }

              _context8.next = 16;
              return _item4;

            case 16:
              i = i + 1;

            case 17:
              _context8.next = 2;
              break;

            case 19:
            case "end":
              return _context8.stop();
          }
        }
      }, _callee7, this);
    })
  );
}

exports.skip = skip;

function takeWhile(predicate) {
  return (
    /*#__PURE__*/
    regeneratorRuntime.mark(function _callee8(iterable) {
      var i, _iterator12, _isArray12, _i12, _ref12, _item5;

      return regeneratorRuntime.wrap(function _callee8$(_context9) {
        while (1) {
          switch (_context9.prev = _context9.next) {
            case 0:
              i = 0;
              _iterator12 = iterable, _isArray12 = Array.isArray(_iterator12), _i12 = 0, _iterator12 = _isArray12 ? _iterator12 : _iterator12[Symbol.iterator]();

            case 2:
              if (!_isArray12) {
                _context9.next = 8;
                break;
              }

              if (!(_i12 >= _iterator12.length)) {
                _context9.next = 5;
                break;
              }

              return _context9.abrupt("break", 20);

            case 5:
              _ref12 = _iterator12[_i12++];
              _context9.next = 12;
              break;

            case 8:
              _i12 = _iterator12.next();

              if (!_i12.done) {
                _context9.next = 11;
                break;
              }

              return _context9.abrupt("break", 20);

            case 11:
              _ref12 = _i12.value;

            case 12:
              _item5 = _ref12;

              if (predicate(_item5, i)) {
                _context9.next = 15;
                break;
              }

              return _context9.abrupt("break", 20);

            case 15:
              _context9.next = 17;
              return _item5;

            case 17:
              i = i + 1;

            case 18:
              _context9.next = 2;
              break;

            case 20:
            case "end":
              return _context9.stop();
          }
        }
      }, _callee8, this);
    })
  );
}

exports.takeWhile = takeWhile;

function takeUntil(predicate) {
  return (
    /*#__PURE__*/
    regeneratorRuntime.mark(function _callee9(iterable) {
      var i, _iterator13, _isArray13, _i13, _ref13, _item6;

      return regeneratorRuntime.wrap(function _callee9$(_context10) {
        while (1) {
          switch (_context10.prev = _context10.next) {
            case 0:
              i = 0;
              _iterator13 = iterable, _isArray13 = Array.isArray(_iterator13), _i13 = 0, _iterator13 = _isArray13 ? _iterator13 : _iterator13[Symbol.iterator]();

            case 2:
              if (!_isArray13) {
                _context10.next = 8;
                break;
              }

              if (!(_i13 >= _iterator13.length)) {
                _context10.next = 5;
                break;
              }

              return _context10.abrupt("break", 20);

            case 5:
              _ref13 = _iterator13[_i13++];
              _context10.next = 12;
              break;

            case 8:
              _i13 = _iterator13.next();

              if (!_i13.done) {
                _context10.next = 11;
                break;
              }

              return _context10.abrupt("break", 20);

            case 11:
              _ref13 = _i13.value;

            case 12:
              _item6 = _ref13;

              if (!predicate(_item6, i)) {
                _context10.next = 15;
                break;
              }

              return _context10.abrupt("return");

            case 15:
              _context10.next = 17;
              return _item6;

            case 17:
              i = i + 1;

            case 18:
              _context10.next = 2;
              break;

            case 20:
            case "end":
              return _context10.stop();
          }
        }
      }, _callee9, this);
    })
  );
}

exports.takeUntil = takeUntil;

function skipWhile(predicate) {
  return (
    /*#__PURE__*/
    regeneratorRuntime.mark(function _callee10(iterable) {
      var i, canReturn, _iterator14, _isArray14, _i14, _ref14, _item7;

      return regeneratorRuntime.wrap(function _callee10$(_context11) {
        while (1) {
          switch (_context11.prev = _context11.next) {
            case 0:
              i = 0;
              canReturn = false;
              _iterator14 = iterable, _isArray14 = Array.isArray(_iterator14), _i14 = 0, _iterator14 = _isArray14 ? _iterator14 : _iterator14[Symbol.iterator]();

            case 3:
              if (!_isArray14) {
                _context11.next = 9;
                break;
              }

              if (!(_i14 >= _iterator14.length)) {
                _context11.next = 6;
                break;
              }

              return _context11.abrupt("break", 26);

            case 6:
              _ref14 = _iterator14[_i14++];
              _context11.next = 13;
              break;

            case 9:
              _i14 = _iterator14.next();

              if (!_i14.done) {
                _context11.next = 12;
                break;
              }

              return _context11.abrupt("break", 26);

            case 12:
              _ref14 = _i14.value;

            case 13:
              _item7 = _ref14;

              if (canReturn) {
                _context11.next = 22;
                break;
              }

              canReturn = !predicate(_item7, i);

              if (!canReturn) {
                _context11.next = 19;
                break;
              }

              _context11.next = 19;
              return _item7;

            case 19:
              i = i + 1;
              _context11.next = 24;
              break;

            case 22:
              _context11.next = 24;
              return _item7;

            case 24:
              _context11.next = 3;
              break;

            case 26:
            case "end":
              return _context11.stop();
          }
        }
      }, _callee10, this);
    })
  );
}

exports.skipWhile = skipWhile;

function skipUntil(predicate) {
  return (
    /*#__PURE__*/
    regeneratorRuntime.mark(function _callee11(iterable) {
      var i, canReturn, _iterator15, _isArray15, _i15, _ref15, _item8;

      return regeneratorRuntime.wrap(function _callee11$(_context12) {
        while (1) {
          switch (_context12.prev = _context12.next) {
            case 0:
              i = 0;
              canReturn = false;
              _iterator15 = iterable, _isArray15 = Array.isArray(_iterator15), _i15 = 0, _iterator15 = _isArray15 ? _iterator15 : _iterator15[Symbol.iterator]();

            case 3:
              if (!_isArray15) {
                _context12.next = 9;
                break;
              }

              if (!(_i15 >= _iterator15.length)) {
                _context12.next = 6;
                break;
              }

              return _context12.abrupt("break", 26);

            case 6:
              _ref15 = _iterator15[_i15++];
              _context12.next = 13;
              break;

            case 9:
              _i15 = _iterator15.next();

              if (!_i15.done) {
                _context12.next = 12;
                break;
              }

              return _context12.abrupt("break", 26);

            case 12:
              _ref15 = _i15.value;

            case 13:
              _item8 = _ref15;

              if (canReturn) {
                _context12.next = 22;
                break;
              }

              canReturn = predicate(_item8, i);

              if (!canReturn) {
                _context12.next = 19;
                break;
              }

              _context12.next = 19;
              return _item8;

            case 19:
              i = i + 1;
              _context12.next = 24;
              break;

            case 22:
              _context12.next = 24;
              return _item8;

            case 24:
              _context12.next = 3;
              break;

            case 26:
            case "end":
              return _context12.stop();
          }
        }
      }, _callee11, this);
    })
  );
}

exports.skipUntil = skipUntil;

function concat() {
  for (var _len = arguments.length, iterables = new Array(_len), _key = 0; _key < _len; _key++) {
    iterables[_key] = arguments[_key];
  }

  return (
    /*#__PURE__*/
    regeneratorRuntime.mark(function _callee12(it) {
      var _i16, iterable;

      return regeneratorRuntime.wrap(function _callee12$(_context13) {
        while (1) {
          switch (_context13.prev = _context13.next) {
            case 0:
              return _context13.delegateYield(it, "t0", 1);

            case 1:
              _i16 = 0;

            case 2:
              if (!(_i16 < iterables.length)) {
                _context13.next = 8;
                break;
              }

              iterable = iterables[_i16];
              return _context13.delegateYield(iterable, "t1", 5);

            case 5:
              _i16++;
              _context13.next = 2;
              break;

            case 8:
            case "end":
              return _context13.stop();
          }
        }
      }, _callee12, this);
    })
  );
}

exports.concat = concat;

function push() {
  for (var _len2 = arguments.length, next = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    next[_key2] = arguments[_key2];
  }

  return (
    /*#__PURE__*/
    regeneratorRuntime.mark(function _callee13(it) {
      var _i17, iterable;

      return regeneratorRuntime.wrap(function _callee13$(_context14) {
        while (1) {
          switch (_context14.prev = _context14.next) {
            case 0:
              return _context14.delegateYield(it, "t0", 1);

            case 1:
              _i17 = 0;

            case 2:
              if (!(_i17 < next.length)) {
                _context14.next = 9;
                break;
              }

              iterable = next[_i17];
              _context14.next = 6;
              return iterable;

            case 6:
              _i17++;
              _context14.next = 2;
              break;

            case 9:
            case "end":
              return _context14.stop();
          }
        }
      }, _callee13, this);
    })
  );
}

exports.push = push;

function unshift() {
  for (var _len3 = arguments.length, next = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
    next[_key3] = arguments[_key3];
  }

  return (
    /*#__PURE__*/
    regeneratorRuntime.mark(function _callee14(it) {
      var i;
      return regeneratorRuntime.wrap(function _callee14$(_context15) {
        while (1) {
          switch (_context15.prev = _context15.next) {
            case 0:
              i = 0;

            case 1:
              if (!(i < next.length)) {
                _context15.next = 7;
                break;
              }

              _context15.next = 4;
              return next[next.length - i - 1];

            case 4:
              ++i;
              _context15.next = 1;
              break;

            case 7:
              return _context15.delegateYield(it, "t0", 8);

            case 8:
            case "end":
              return _context15.stop();
          }
        }
      }, _callee14, this);
    })
  );
}

exports.unshift = unshift;

function some(predicate) {
  return function (it) {
    var i = 0;

    for (var _iterator16 = it, _isArray16 = Array.isArray(_iterator16), _i18 = 0, _iterator16 = _isArray16 ? _iterator16 : _iterator16[Symbol.iterator]();;) {
      var _ref16;

      if (_isArray16) {
        if (_i18 >= _iterator16.length) break;
        _ref16 = _iterator16[_i18++];
      } else {
        _i18 = _iterator16.next();
        if (_i18.done) break;
        _ref16 = _i18.value;
      }

      var _item9 = _ref16;

      if (predicate(_item9, i)) {
        return true;
      }

      i = i + 1;
    }

    return false;
  };
}

exports.some = some;

function every(predicate) {
  return function (it) {
    var i = 0;

    for (var _iterator17 = it, _isArray17 = Array.isArray(_iterator17), _i19 = 0, _iterator17 = _isArray17 ? _iterator17 : _iterator17[Symbol.iterator]();;) {
      var _ref17;

      if (_isArray17) {
        if (_i19 >= _iterator17.length) break;
        _ref17 = _iterator17[_i19++];
      } else {
        _i19 = _iterator17.next();
        if (_i19.done) break;
        _ref17 = _i19.value;
      }

      var _item10 = _ref17;

      if (!predicate(_item10, i)) {
        return false;
      }

      i = i + 1;
    }

    return true;
  };
}

exports.every = every;

function distinct(it) {
  var resultSet, _iterator18, _isArray18, _i20, _ref18, _item11;

  return regeneratorRuntime.wrap(function distinct$(_context16) {
    while (1) {
      switch (_context16.prev = _context16.next) {
        case 0:
          resultSet = new Set();
          _iterator18 = it, _isArray18 = Array.isArray(_iterator18), _i20 = 0, _iterator18 = _isArray18 ? _iterator18 : _iterator18[Symbol.iterator]();

        case 2:
          if (!_isArray18) {
            _context16.next = 8;
            break;
          }

          if (!(_i20 >= _iterator18.length)) {
            _context16.next = 5;
            break;
          }

          return _context16.abrupt("break", 19);

        case 5:
          _ref18 = _iterator18[_i20++];
          _context16.next = 12;
          break;

        case 8:
          _i20 = _iterator18.next();

          if (!_i20.done) {
            _context16.next = 11;
            break;
          }

          return _context16.abrupt("break", 19);

        case 11:
          _ref18 = _i20.value;

        case 12:
          _item11 = _ref18;

          if (resultSet.has(_item11)) {
            _context16.next = 17;
            break;
          }

          resultSet.add(_item11);
          _context16.next = 17;
          return _item11;

        case 17:
          _context16.next = 2;
          break;

        case 19:
        case "end":
          return _context16.stop();
      }
    }
  }, _marked2, this);
}

exports.distinct = distinct; //# sourceMappingURL=operators.js.map

/***/ }),

/***/ "./node_modules/@morleydev/functional-pipe/pipe.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.$$ = function (x) {
  return {
    $: function $(map) {
      return exports.$$(map(x));
    },
    $$: function $$(map) {
      return map(x);
    }
  };
}; //# sourceMappingURL=pipe.js.map

/***/ }),

/***/ "./node_modules/@morleydev/pauper/assets/web-asset-loader.service.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } } function _next(value) { step("next", value); } function _throw(err) { step("throw", err); } _next(); }); }; }

Object.defineProperty(exports, "__esModule", {
  value: true
});

var howler_1 = __webpack_require__("./node_modules/howler/dist/howler.js");

var WebAssetLoader =
/*#__PURE__*/
function () {
  function WebAssetLoader() {
    this.images = {};
    this.soundeffects = {};
    this.music = {};
    this.jsons = {};
  }

  var _proto = WebAssetLoader.prototype;

  _proto.loadFont = function loadFont(id, path) {
    return Promise.resolve();
  };

  _proto.getSoundEffect = function getSoundEffect(id, path) {
    var audio = this.soundeffects[id];

    if (audio) {
      return audio;
    } else {
      var howl = new howler_1.Howl({
        src: path || ["./assets/" + id + ".ogg", "./assets/" + id + ".flac", "./assets/" + id + ".mp3", "./assets/" + id + ".wav"]
      });
      return this.soundeffects[id] = {
        howl: howl,
        name: id
      };
    }
  };

  _proto.loadSoundEffect =
  /*#__PURE__*/
  function () {
    var _loadSoundEffect = _asyncToGenerator(
    /*#__PURE__*/
    regeneratorRuntime.mark(function _callee(id, path) {
      var audio, howl;
      return regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              audio = this.soundeffects[id];

              if (!audio) {
                _context.next = 5;
                break;
              }

              return _context.abrupt("return", audio);

            case 5:
              _context.next = 7;
              return loadAudioFromUrl(path);

            case 7:
              howl = _context.sent;
              return _context.abrupt("return", this.soundeffects[id] = {
                howl: howl,
                name: id
              });

            case 9:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, this);
    }));

    return function loadSoundEffect(_x, _x2) {
      return _loadSoundEffect.apply(this, arguments);
    };
  }();

  _proto.getImage = function getImage(id, path) {
    var image = this.images[id];

    if (image != null) {
      return image;
    } else {
      var img = new Image();
      img.src = path || "./assets/" + id + ".png";
      this.images[id] = img;
      return img;
    }
  };

  _proto.loadImage =
  /*#__PURE__*/
  function () {
    var _loadImage = _asyncToGenerator(
    /*#__PURE__*/
    regeneratorRuntime.mark(function _callee2(id, path) {
      var imageAlreadyLoaded, image;
      return regeneratorRuntime.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              imageAlreadyLoaded = this.images[id];

              if (!(imageAlreadyLoaded != null)) {
                _context2.next = 5;
                break;
              }

              return _context2.abrupt("return", imageAlreadyLoaded);

            case 5:
              _context2.next = 7;
              return loadImageFromUrl(path);

            case 7:
              image = _context2.sent;
              this.images[id] = image;
              return _context2.abrupt("return", image);

            case 10:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2, this);
    }));

    return function loadImage(_x3, _x4) {
      return _loadImage.apply(this, arguments);
    };
  }();

  _proto.getMusic = function getMusic(id, path) {
    var audio = this.music[id];

    if (audio) {
      return audio;
    } else {
      var howl = new howler_1.Howl({
        src: path || ["./assets/" + id + ".ogg", "./assets/" + id + ".flac", "./assets/" + id + ".mp3", "./assets/" + id + ".wav"]
      });
      return this.music[id] = {
        howl: howl,
        name: id
      };
    }
  };

  _proto.loadMusic =
  /*#__PURE__*/
  function () {
    var _loadMusic = _asyncToGenerator(
    /*#__PURE__*/
    regeneratorRuntime.mark(function _callee3(id, path) {
      var audio, howl;
      return regeneratorRuntime.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              audio = this.music[id];

              if (!audio) {
                _context3.next = 5;
                break;
              }

              return _context3.abrupt("return", audio);

            case 5:
              _context3.next = 7;
              return loadAudioFromUrl(path);

            case 7:
              howl = _context3.sent;
              return _context3.abrupt("return", this.music[id] = {
                howl: howl,
                name: id
              });

            case 9:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3, this);
    }));

    return function loadMusic(_x5, _x6) {
      return _loadMusic.apply(this, arguments);
    };
  }();

  _proto.getJson = function getJson(id, path, notFound) {
    var asset = this.jsons[id];

    if (asset != null) {
      return asset;
    } else {
      if (notFound != null) {
        this.jsons[id] = notFound;
      }

      return notFound;
    }
  };

  _proto.loadJson =
  /*#__PURE__*/
  function () {
    var _loadJson = _asyncToGenerator(
    /*#__PURE__*/
    regeneratorRuntime.mark(function _callee4(id, path, notFound) {
      var asset, result, body;
      return regeneratorRuntime.wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              asset = this.jsons[id];

              if (!(asset != null)) {
                _context4.next = 3;
                break;
              }

              return _context4.abrupt("return", asset);

            case 3:
              _context4.next = 5;
              return fetch(path);

            case 5:
              result = _context4.sent;

              if (!(result.status < 200 || result.status >= 300)) {
                _context4.next = 15;
                break;
              }

              if (!(notFound != null)) {
                _context4.next = 12;
                break;
              }

              this.jsons[id] = notFound;
              return _context4.abrupt("return", notFound);

            case 12:
              throw new Error("Could not find json object " + id + " (" + path + ")");

            case 13:
              _context4.next = 20;
              break;

            case 15:
              _context4.next = 17;
              return result.json();

            case 17:
              body = _context4.sent;
              this.jsons[id] = body;
              return _context4.abrupt("return", body);

            case 20:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4, this);
    }));

    return function loadJson(_x7, _x8, _x9) {
      return _loadJson.apply(this, arguments);
    };
  }();

  return WebAssetLoader;
}();

exports.WebAssetLoader = WebAssetLoader;

function loadImageFromUrl(path) {
  return new Promise(function (resolve, reject) {
    var img = new Image();

    img.onload = function () {
      return resolve(img);
    };

    img.onerror = function () {
      return reject();
    };

    img.src = path;
  });
}

function loadAudioFromUrl(path) {
  return new Promise(function (resolve, reject) {
    var howl = new howler_1.Howl({
      src: [path],
      html5: true
    });

    if (howl.state() === "loaded") {
      return howl;
    } else {
      howl.once("load", function () {
        return resolve(howl);
      });
      howl.once("loaderror", function (id, err) {
        return reject(err);
      });
      howl.load();
      return howl;
    }
  });
}

/***/ }),

/***/ "./node_modules/@morleydev/pauper/maths/interpolation.maths.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.linearInterpolation = function (start, end) {
  return function (percentage) {
    return start + (end - start) * percentage;
  };
};

exports.cosineInterpolation = function (start, end) {
  return function (percentage) {
    var mu2 = (1 - Math.cos(percentage * Math.PI)) / 2;
    return start * (1 - mu2) + end * mu2;
  };
};

exports.exponentialInterpolation = function (power) {
  return function (start, end) {
    return function (percentage) {
      return exports.linearInterpolation(start, end)(Math.pow(percentage, power));
    };
  };
};

/***/ }),

/***/ "./node_modules/@morleydev/pauper/maths/vector.maths.func.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var interpolation_maths_1 = __webpack_require__("./node_modules/@morleydev/pauper/maths/interpolation.maths.js");

function abs(_ref) {
  var x = _ref.x,
      y = _ref.y;
  return {
    x: Math.abs(x),
    y: Math.abs(y)
  };
}

exports.abs = abs;

function invert(_ref2) {
  var x = _ref2.x,
      y = _ref2.y;
  return {
    x: -x,
    y: -y
  };
}

exports.invert = invert;

function add(lhs, rhs) {
  return {
    x: lhs.x + rhs.x,
    y: lhs.y + rhs.y
  };
}

exports.add = add;

function subtract(lhs, rhs) {
  return {
    x: lhs.x - rhs.x,
    y: lhs.y - rhs.y
  };
}

exports.subtract = subtract;

function multiply(lhs, rhs) {
  return {
    x: lhs.x * rhs,
    y: lhs.y * rhs
  };
}

exports.multiply = multiply;

function dot(lhs, rhs) {
  return {
    x: lhs.x * rhs.x,
    y: lhs.y * rhs.y
  };
}

exports.dot = dot;

function divide(lhs, rhs) {
  return {
    x: lhs.x / rhs,
    y: lhs.y / rhs
  };
}

exports.divide = divide;

function magnitudeSquared(lhs) {
  return lhs.x * lhs.x + lhs.y * lhs.y;
}

exports.magnitudeSquared = magnitudeSquared;

function magnitude(lhs) {
  return Math.sqrt(magnitudeSquared(lhs));
}

exports.magnitude = magnitude;

function normalise(lhs) {
  return divide(lhs, magnitude(lhs));
}

exports.normalise = normalise;

function dotProduct(lhs, rhs) {
  return lhs.x * rhs.x + lhs.y * rhs.y;
}

exports.dotProduct = dotProduct;

function normal(lhs) {
  return {
    x: -lhs.y,
    y: lhs.x
  };
}

exports.normal = normal;

function constraint(topLeft, bottomRight) {
  return function (lhs) {
    return {
      x: Math.min(Math.max(topLeft.x, lhs.x), bottomRight.x),
      y: Math.min(Math.max(topLeft.y, lhs.y), bottomRight.y)
    };
  };
}

exports.constraint = constraint;

function crossProduct(lhs, rhs) {
  return lhs.x * rhs.y - lhs.y * rhs.x;
}

exports.crossProduct = crossProduct;

function linearInterpolation(lhs, rhs) {
  var interpolateX = interpolation_maths_1.linearInterpolation(lhs.x, rhs.x);
  var interpolateY = interpolation_maths_1.linearInterpolation(lhs.y, rhs.y);
  return function (percentage) {
    return {
      x: interpolateX(percentage),
      y: interpolateY(percentage)
    };
  };
}

exports.linearInterpolation = linearInterpolation;

function cosineInterpolation(lhs, rhs) {
  var interpolateX = interpolation_maths_1.cosineInterpolation(lhs.x, rhs.x);
  var interpolateY = interpolation_maths_1.cosineInterpolation(lhs.y, rhs.y);
  return function (percentage) {
    return {
      x: interpolateX(percentage),
      y: interpolateY(percentage)
    };
  };
}

exports.cosineInterpolation = cosineInterpolation;

function exponentialInterpolation(exponent) {
  var exponentialInterpolator = interpolation_maths_1.exponentialInterpolation(exponent);
  return function (lhs, rhs) {
    var interpolateX = exponentialInterpolator(lhs.x, rhs.x);
    var interpolateY = exponentialInterpolator(lhs.y, rhs.y);
    return function (percentage) {
      return {
        x: interpolateX(percentage),
        y: interpolateY(percentage)
      };
    };
  };
}

exports.exponentialInterpolation = exponentialInterpolation;

/***/ }),

/***/ "./node_modules/@morleydev/pauper/maths/vector.maths.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var func = __webpack_require__("./node_modules/@morleydev/pauper/maths/vector.maths.func.js");

var values = __webpack_require__("./node_modules/@morleydev/pauper/maths/vector.maths.values.js");

exports.Vector2 = Object.assign(function (x, y) {
  return {
    x: x,
    y: y
  };
}, Object.assign({}, func, values));

/***/ }),

/***/ "./node_modules/@morleydev/pauper/maths/vector.maths.values.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Zero = {
  x: 0,
  y: 0
};
exports.Unit = {
  x: Math.sqrt(0.5),
  y: Math.sqrt(0.5)
};

/***/ }),

/***/ "./node_modules/@morleydev/pauper/models/circle/circle.model.bounding.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

function boundingBox(circle) {
  return {
    x: circle.x - circle.radius,
    y: circle.y - circle.radius,
    width: circle.radius * 2,
    height: circle.radius * 2
  };
}

exports.boundingBox = boundingBox;

/***/ }),

/***/ "./node_modules/@morleydev/pauper/models/circle/circle.model.is.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

function is(possible) {
  return possible.radius != null && possible.x != null && possible.y != null;
}

exports.is = is;

/***/ }),

/***/ "./node_modules/@morleydev/pauper/models/circle/circle.model.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var bounding = __webpack_require__("./node_modules/@morleydev/pauper/models/circle/circle.model.bounding.js");

var is = __webpack_require__("./node_modules/@morleydev/pauper/models/circle/circle.model.is.js");

var lineTo = __webpack_require__("./node_modules/@morleydev/pauper/models/circle/circle.model.lineTo.js");

var overlap = __webpack_require__("./node_modules/@morleydev/pauper/models/circle/circle.model.overlap.js");

exports.Circle = Object.assign(function (x, y, radius) {
  return {
    x: x,
    y: y,
    radius: radius
  };
}, Object.assign({}, bounding, is, overlap, lineTo));

/***/ }),

/***/ "./node_modules/@morleydev/pauper/models/circle/circle.model.lineTo.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var vector_maths_func_1 = __webpack_require__("./node_modules/@morleydev/pauper/maths/vector.maths.func.js");

var line_model_is_1 = __webpack_require__("./node_modules/@morleydev/pauper/models/line/line.model.is.js");

var line_model_lineTo_1 = __webpack_require__("./node_modules/@morleydev/pauper/models/line/line.model.lineTo.js");

var rectangle_model_is_1 = __webpack_require__("./node_modules/@morleydev/pauper/models/rectangle/rectangle.model.is.js");

var rectangle_model_lineTo_1 = __webpack_require__("./node_modules/@morleydev/pauper/models/rectangle/rectangle.model.lineTo.js");

var triangle_model_is_1 = __webpack_require__("./node_modules/@morleydev/pauper/models/triangle/triangle.model.is.js");

var circle_model_is_1 = __webpack_require__("./node_modules/@morleydev/pauper/models/circle/circle.model.is.js");

function lineTo(lhs, rhs) {
  if (line_model_is_1.is(rhs)) {
    var _line_model_lineTo_1$ = line_model_lineTo_1.lineLine2ToCircle(rhs, lhs),
        b = _line_model_lineTo_1$[0],
        a = _line_model_lineTo_1$[1];

    return [a, b];
  } else if (triangle_model_is_1.is(rhs)) {
    return lineCircleToTriangle2(lhs, rhs);
  } else if (circle_model_is_1.is(rhs)) {
    return lineCircleToCircle(lhs, rhs);
  } else if (rectangle_model_is_1.is(rhs)) {
    var _rectangle_model_line = rectangle_model_lineTo_1.lineRectangleToCircle(rhs, lhs),
        _b = _rectangle_model_line[0],
        _a = _rectangle_model_line[1];

    return [_a, _b];
  } else {
    return lineCircleToPoint2(lhs, rhs);
  }
}

exports.lineTo = lineTo;

function lineCircleToPoint2(lhs, rhs) {
  var offset = vector_maths_func_1.subtract(rhs, lhs);
  var normalised = vector_maths_func_1.add(vector_maths_func_1.multiply(vector_maths_func_1.normalise(offset), lhs.radius), lhs);
  return [normalised, rhs];
}

exports.lineCircleToPoint2 = lineCircleToPoint2;

function lineCircleToTriangle2(lhs, rhs) {
  var a = line_model_lineTo_1.lineLine2ToCircle([rhs[0], rhs[1]], lhs);
  var b = line_model_lineTo_1.lineLine2ToCircle([rhs[1], rhs[0]], lhs);
  var c = line_model_lineTo_1.lineLine2ToCircle([rhs[2], rhs[0]], lhs);
  var magA = vector_maths_func_1.magnitudeSquared(vector_maths_func_1.subtract(a[0], lhs));
  var magB = vector_maths_func_1.magnitudeSquared(vector_maths_func_1.subtract(b[0], lhs));
  var magC = vector_maths_func_1.magnitudeSquared(vector_maths_func_1.subtract(c[0], lhs));

  if (magA < magB) {
    return magA < magC ? a : c;
  } else {
    return magB < magC ? b : c;
  }
}

exports.lineCircleToTriangle2 = lineCircleToTriangle2;

function lineCircleToCircle(lhs, rhs) {
  var offset = vector_maths_func_1.subtract(rhs, lhs);
  var n = vector_maths_func_1.normalise(offset);
  var l = vector_maths_func_1.add(vector_maths_func_1.multiply(n, lhs.radius), lhs);
  var r = vector_maths_func_1.subtract(rhs, vector_maths_func_1.multiply(n, rhs.radius));
  return [l, r];
}

exports.lineCircleToCircle = lineCircleToCircle;

/***/ }),

/***/ "./node_modules/@morleydev/pauper/models/circle/circle.model.overlap.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var vector_maths_func_1 = __webpack_require__("./node_modules/@morleydev/pauper/maths/vector.maths.func.js");

var line_model_intersect_1 = __webpack_require__("./node_modules/@morleydev/pauper/models/line/line.model.intersect.js");

var line_model_is_1 = __webpack_require__("./node_modules/@morleydev/pauper/models/line/line.model.is.js");

var line_model_length_1 = __webpack_require__("./node_modules/@morleydev/pauper/models/line/line.model.length.js");

var rectangle_model_is_1 = __webpack_require__("./node_modules/@morleydev/pauper/models/rectangle/rectangle.model.is.js");

var rectangle_model_lineTo_1 = __webpack_require__("./node_modules/@morleydev/pauper/models/rectangle/rectangle.model.lineTo.js");

var triangle_model_is_1 = __webpack_require__("./node_modules/@morleydev/pauper/models/triangle/triangle.model.is.js");

var triangle_model_overlap_1 = __webpack_require__("./node_modules/@morleydev/pauper/models/triangle/triangle.model.overlap.js");

var circle_model_is_1 = __webpack_require__("./node_modules/@morleydev/pauper/models/circle/circle.model.is.js");

function overlaps(lhs, rhs) {
  if (line_model_is_1.is(rhs)) {
    return circleOverlapsLine2(lhs, rhs);
  } else if (triangle_model_is_1.is(rhs)) {
    return circleOverlapsTriangle2(lhs, rhs);
  } else if (circle_model_is_1.is(rhs)) {
    return circleOverlapsCircle(lhs, rhs);
  } else if (rectangle_model_is_1.is(rhs)) {
    return circleOverlapsRectangle(lhs, rhs);
  } else {
    return circleOverlapsPoint2(lhs, rhs);
  }
}

exports.overlaps = overlaps;

function circleOverlapsLine2(lhs, rhs) {
  return line_model_intersect_1.line2IntersectsCircle(rhs, lhs);
}

exports.circleOverlapsLine2 = circleOverlapsLine2;

function circleOverlapsTriangle2(lhs, rhs) {
  return triangle_model_overlap_1.triangle2OverlapsCircle(rhs, lhs);
}

exports.circleOverlapsTriangle2 = circleOverlapsTriangle2;

function circleOverlapsCircle(a, b) {
  return vector_maths_func_1.magnitudeSquared(vector_maths_func_1.subtract(a, b)) <= (a.radius + b.radius) * (a.radius + b.radius);
}

exports.circleOverlapsCircle = circleOverlapsCircle;

function circleOverlapsPoint2(a, b) {
  return vector_maths_func_1.magnitudeSquared(vector_maths_func_1.subtract(a, b)) <= a.radius * a.radius;
}

exports.circleOverlapsPoint2 = circleOverlapsPoint2;

function circleOverlapsRectangle(lhs, rhs) {
  return circleOverlapsPoint2(lhs, rhs) || line_model_length_1.lengthOf(rectangle_model_lineTo_1.lineTo(rhs, {
    x: lhs.x,
    y: lhs.y
  })) <= lhs.radius;
}

exports.circleOverlapsRectangle = circleOverlapsRectangle;

/***/ }),

/***/ "./node_modules/@morleydev/pauper/models/colour.model.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.RGBA = function (r, g, b, a) {
  if (a === void 0) {
    a = 1;
  }

  return {
    r: r,
    g: g,
    b: b,
    a: a
  };
};

exports.RGB = function (r, g, b) {
  return {
    r: r,
    g: g,
    b: b
  };
};

/***/ }),

/***/ "./node_modules/@morleydev/pauper/models/line/line.model.intersect.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var circle_model_is_1 = __webpack_require__("./node_modules/@morleydev/pauper/models/circle/circle.model.is.js");

var point_model_bounding_1 = __webpack_require__("./node_modules/@morleydev/pauper/models/point/point.model.bounding.js");

var rectangle_model_is_1 = __webpack_require__("./node_modules/@morleydev/pauper/models/rectangle/rectangle.model.is.js");

var rectangle_model_lines_1 = __webpack_require__("./node_modules/@morleydev/pauper/models/rectangle/rectangle.model.lines.js");

var triangle_model_is_1 = __webpack_require__("./node_modules/@morleydev/pauper/models/triangle/triangle.model.is.js");

var line_model_is_1 = __webpack_require__("./node_modules/@morleydev/pauper/models/line/line.model.is.js");

function intersects(lhs, rhs, tolerance) {
  if (tolerance === void 0) {
    tolerance = 0.001;
  }

  if (line_model_is_1.is(rhs)) {
    return line2IntersectsLine2(lhs, rhs);
  } else if (triangle_model_is_1.is(rhs)) {
    return line2IntersectsTriangle2(lhs, rhs);
  } else if (circle_model_is_1.is(rhs)) {
    return line2IntersectsCircle(lhs, rhs);
  } else if (rectangle_model_is_1.is(rhs)) {
    return line2IntersectsRectangle(lhs, rhs);
  } else {
    return line2IntersectsPoint2(lhs, rhs, tolerance);
  }
}

exports.intersects = intersects;

function line2IntersectsTriangle2(_ref, _ref2) {
  var a1 = _ref[0],
      a2 = _ref[1];
  var v1 = _ref2[0],
      v2 = _ref2[1],
      v3 = _ref2[2];
  return line2IntersectsLine2([v1, v2], [a1, a2]) || line2IntersectsLine2([v2, v3], [a1, a2]) || line2IntersectsLine2([v3, v1], [a1, a2]);
}

exports.line2IntersectsTriangle2 = line2IntersectsTriangle2;

function line2IntersectsCircle(lhs, rhs) {
  return line2IntersectsPoint2(lhs, rhs, rhs.radius);
}

exports.line2IntersectsCircle = line2IntersectsCircle;

function line2IntersectsPoint2(_ref3, a0, tolerance) {
  var a1 = _ref3[0],
      a2 = _ref3[1];

  function distToSegmentSquared(a0, a1, a2) {
    function magnitudeBetweenPointsSquared(v, w) {
      return Math.pow(v.x - w.x, 2) + Math.pow(v.y - w.y, 2);
    }

    var lengthSquaredOfLine = magnitudeBetweenPointsSquared(a1, a2);

    if (lengthSquaredOfLine === 0) {
      return magnitudeBetweenPointsSquared(a0, a1);
    }

    var angleOfAttack = ((a0.x - a1.x) * (a2.x - a1.x) + (a0.y - a1.y) * (a2.y - a1.y)) / lengthSquaredOfLine;

    if (angleOfAttack < 0) {
      return magnitudeBetweenPointsSquared(a0, a1);
    } else if (angleOfAttack > 1) {
      return magnitudeBetweenPointsSquared(a0, a2);
    } else {
      var pointOnLine = {
        x: a1.x + angleOfAttack * (a2.x - a1.x),
        y: a1.y + angleOfAttack * (a2.y - a1.y)
      };
      return magnitudeBetweenPointsSquared(a0, pointOnLine);
    }
  }

  return distToSegmentSquared(a0, a1, a2) <= tolerance * tolerance;
}

exports.line2IntersectsPoint2 = line2IntersectsPoint2;

function line2IntersectsRectangle(lhs, rhs) {
  var _rectangle_model_line = rectangle_model_lines_1.lines(rhs),
      bottom = _rectangle_model_line.bottom,
      top = _rectangle_model_line.top,
      left = _rectangle_model_line.left,
      right = _rectangle_model_line.right;

  return line2IntersectsLine2(lhs, top) || line2IntersectsLine2(lhs, bottom) || line2IntersectsLine2(lhs, left) || line2IntersectsLine2(lhs, right);
}

exports.line2IntersectsRectangle = line2IntersectsRectangle;

function line2IntersectsLine2(_ref4, _ref5) {
  var a1 = _ref4[0],
      a2 = _ref4[1];
  var b1 = _ref5[0],
      b2 = _ref5[1];

  var sameSign = function sameSign(x, y) {
    return x >= 0 && y >= 0 || x <= 0 && y <= 0;
  };

  var x1 = a1.x;
  var y1 = a1.y;
  var x2 = a2.x;
  var y2 = a2.y;
  var x3 = b1.x;
  var y3 = b1.y;
  var x4 = b2.x;
  var y4 = b2.y;
  var s1 = y2 - y1;
  var t1 = x1 - x2;
  var u1 = x2 * y1 - x1 * y2;
  var r3 = s1 * x3 + t1 * y3 + u1;
  var r4 = s1 * x4 + t1 * y4 + u1;

  if (r3 !== 0 && r4 !== 0 && sameSign(r3, r4)) {
    return false;
  }

  var s2 = y4 - y3;
  var t2 = x3 - x4;
  var u2 = x4 * y3 - x3 * y4;
  var r1 = s2 * x1 + t2 * y1 + u2;
  var r2 = s2 * x2 + t2 * y2 + u2;

  if (r1 !== 0 && r2 !== 0 && sameSign(r1, r2)) {
    return false;
  }

  var a = point_model_bounding_1.boundingTLBR(a1, a2);
  var b = point_model_bounding_1.boundingTLBR(b1, b2);
  return !(a.topLeft.x > b.bottomRight.x || a.topLeft.y > b.bottomRight.y || a.bottomRight.x < b.topLeft.x || a.bottomRight.y < b.topLeft.y);
}

exports.line2IntersectsLine2 = line2IntersectsLine2;

/***/ }),

/***/ "./node_modules/@morleydev/pauper/models/line/line.model.is.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var point_model_is_1 = __webpack_require__("./node_modules/@morleydev/pauper/models/point/point.model.is.js");

function is(possibly) {
  return Array.isArray(possibly) && possibly.length === 2 && possibly.every(point_model_is_1.is);
}

exports.is = is;

/***/ }),

/***/ "./node_modules/@morleydev/pauper/models/line/line.model.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var intersect = __webpack_require__("./node_modules/@morleydev/pauper/models/line/line.model.intersect.js");

var is = __webpack_require__("./node_modules/@morleydev/pauper/models/line/line.model.is.js");

var length = __webpack_require__("./node_modules/@morleydev/pauper/models/line/line.model.length.js");

var lineTo = __webpack_require__("./node_modules/@morleydev/pauper/models/line/line.model.lineTo.js");

exports.Line2 = Object.assign(function (a, b) {
  return [a, b];
}, Object.assign({}, intersect, is, length, lineTo));

/***/ }),

/***/ "./node_modules/@morleydev/pauper/models/line/line.model.length.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var vector_maths_1 = __webpack_require__("./node_modules/@morleydev/pauper/maths/vector.maths.js");

function lengthOf(line) {
  return vector_maths_1.Vector2.magnitude(vector_maths_1.Vector2.subtract(line[1], line[0]));
}

exports.lengthOf = lengthOf;

/***/ }),

/***/ "./node_modules/@morleydev/pauper/models/line/line.model.lineTo.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var functional_pipe_1 = __webpack_require__("./node_modules/@morleydev/functional-pipe/index.js");

var operators_1 = __webpack_require__("./node_modules/@morleydev/functional-pipe/iterable/operators.js");

var vector_maths_func_1 = __webpack_require__("./node_modules/@morleydev/pauper/maths/vector.maths.func.js");

var circle_model_is_1 = __webpack_require__("./node_modules/@morleydev/pauper/models/circle/circle.model.is.js");

var rectangle_model_is_1 = __webpack_require__("./node_modules/@morleydev/pauper/models/rectangle/rectangle.model.is.js");

var rectangle_model_lines_1 = __webpack_require__("./node_modules/@morleydev/pauper/models/rectangle/rectangle.model.lines.js");

var triangle_model_is_1 = __webpack_require__("./node_modules/@morleydev/pauper/models/triangle/triangle.model.is.js");

var line_model_is_1 = __webpack_require__("./node_modules/@morleydev/pauper/models/line/line.model.is.js");

function lineTo(lhs, rhs) {
  if (line_model_is_1.is(rhs)) {
    return lineLine2ToLine2(lhs, rhs);
  } else if (triangle_model_is_1.is(rhs)) {
    return lineLine2ToTriangle2(lhs, rhs);
  } else if (circle_model_is_1.is(rhs)) {
    return lineLine2ToCircle(lhs, rhs);
  } else if (rectangle_model_is_1.is(rhs)) {
    return lineLine2ToRectangle(lhs, rhs);
  } else {
    return lineLine2ToPoint2(lhs, rhs);
  }
}

exports.lineTo = lineTo;

function lineLine2ToTriangle2(lhs, rhs) {
  return findShortestLine([lineLine2ToLine2(lhs, [rhs[0], rhs[1]]), lineLine2ToLine2(lhs, [rhs[1], rhs[0]]), lineLine2ToLine2(lhs, [rhs[2], rhs[0]])]);
}

exports.lineLine2ToTriangle2 = lineLine2ToTriangle2;

function findShortestLine(lines) {
  return functional_pipe_1.$$(lines).$(operators_1.map(function (line) {
    return {
      segment: line,
      length2: vector_maths_func_1.magnitudeSquared(vector_maths_func_1.subtract(line[1], line[0]))
    };
  })).$(operators_1.fold(function (prev, curr) {
    return prev.length2 < curr.length2 ? prev : curr;
  })).$$(function (line) {
    return line.segment;
  });
}

exports.findShortestLine = findShortestLine;

function lineLine2ToRectangle(lhs, rhs) {
  var lineSet = rectangle_model_lines_1.lines(rhs);
  return findShortestLine([lineLine2ToLine2(lhs, lineSet.top), lineLine2ToLine2(lhs, lineSet.bottom), lineLine2ToLine2(lhs, lineSet.left), lineLine2ToLine2(lhs, lineSet.right)]);
}

exports.lineLine2ToRectangle = lineLine2ToRectangle;

function lineLine2ToLine2(lhs, rhs) {
  // TODO: lineTo Line2 -> Line2 not properly implemented, produces sub-optimal results
  return [getCentreOfLine(lhs), getCentreOfLine(rhs)];
}

exports.lineLine2ToLine2 = lineLine2ToLine2;

function lineLine2ToCircle(lhs, rhs) {
  var _lineLine2ToPoint = lineLine2ToPoint2(lhs, rhs),
      l0 = _lineLine2ToPoint[0];

  var radius = rhs.radius;
  var lengthOfLine = vector_maths_func_1.subtract(rhs, l0);
  var angleOfLine = vector_maths_func_1.normalise(lengthOfLine);
  var radiusOfLine = vector_maths_func_1.multiply(angleOfLine, rhs.radius);
  var rhsPosition = vector_maths_func_1.add(rhs, radiusOfLine);
  return [l0, rhsPosition];
}

exports.lineLine2ToCircle = lineLine2ToCircle;

function lineLine2ToPoint2(lhs, rhs) {
  var a0 = rhs;
  var a1 = lhs[0],
      a2 = lhs[1];

  function magnitudeBetweenPointsSquared(v, w) {
    return Math.pow(v.x - w.x, 2) + Math.pow(v.y - w.y, 2);
  }

  var lengthSquaredOfLine = magnitudeBetweenPointsSquared(a1, a2);

  if (lengthSquaredOfLine === 0) {
    return [a1, a0];
  }

  var positionOnLine = ((a0.x - a1.x) * (a2.x - a1.x) + (a0.y - a1.y) * (a2.y - a1.y)) / lengthSquaredOfLine;

  if (positionOnLine < 0) {
    return [a1, a0];
  } else if (positionOnLine > 1) {
    return [a2, a0];
  } else {
    var pointOnLine = {
      x: a1.x + positionOnLine * (a2.x - a1.x),
      y: a1.y + positionOnLine * (a2.y - a1.y)
    };
    return [pointOnLine, a0];
  }
}

exports.lineLine2ToPoint2 = lineLine2ToPoint2;

function getCentreOfLine(lhs) {
  return vector_maths_func_1.add(lhs[0], vector_maths_func_1.divide(vector_maths_func_1.subtract(lhs[1], lhs[0]), 2));
}

/***/ }),

/***/ "./node_modules/@morleydev/pauper/models/point/point.model.bounding.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var point_model_tlbr_1 = __webpack_require__("./node_modules/@morleydev/pauper/models/point/point.model.tlbr.js");

function boundingTLBR() {
  return {
    topLeft: point_model_tlbr_1.getTopLeft.apply(point_model_tlbr_1, arguments),
    bottomRight: point_model_tlbr_1.getBottomRight.apply(point_model_tlbr_1, arguments)
  };
}

exports.boundingTLBR = boundingTLBR;

function bounding() {
  var _boundingTLBR = boundingTLBR.apply(void 0, arguments),
      topLeft = _boundingTLBR.topLeft,
      bottomRight = _boundingTLBR.bottomRight;

  return {
    x: topLeft.x,
    y: topLeft.y,
    width: bottomRight.x - topLeft.x,
    height: bottomRight.y - topLeft.y
  };
}

exports.bounding = bounding;

/***/ }),

/***/ "./node_modules/@morleydev/pauper/models/point/point.model.is.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

function is(possibly) {
  return possibly.x != null && possibly.y != null;
}

exports.is = is;

/***/ }),

/***/ "./node_modules/@morleydev/pauper/models/point/point.model.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var bounding = __webpack_require__("./node_modules/@morleydev/pauper/models/point/point.model.bounding.js");

var is = __webpack_require__("./node_modules/@morleydev/pauper/models/point/point.model.is.js");

var tlbr = __webpack_require__("./node_modules/@morleydev/pauper/models/point/point.model.tlbr.js");

exports.Point2 = Object.assign(function (x, y) {
  return {
    x: x,
    y: y
  };
}, Object.assign({}, tlbr, bounding, is));

/***/ }),

/***/ "./node_modules/@morleydev/pauper/models/point/point.model.tlbr.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var operators_1 = __webpack_require__("./node_modules/@morleydev/functional-pipe/iterable/operators.js");

function getTopLeft() {
  for (var _len = arguments.length, _points = new Array(_len), _key = 0; _key < _len; _key++) {
    _points[_key] = arguments[_key];
  }

  return {
    x: Math.min.apply(Math, operators_1.map(function (point) {
      return point.x;
    })(_points)),
    y: Math.min.apply(Math, operators_1.map(function (point) {
      return point.y;
    })(_points))
  };
}

exports.getTopLeft = getTopLeft;

function getTopRight() {
  for (var _len2 = arguments.length, _points = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    _points[_key2] = arguments[_key2];
  }

  return {
    x: Math.max.apply(Math, operators_1.map(function (point) {
      return point.x;
    })(_points)),
    y: Math.min.apply(Math, operators_1.map(function (point) {
      return point.y;
    })(_points))
  };
}

exports.getTopRight = getTopRight;

function getBottomLeft() {
  for (var _len3 = arguments.length, _points = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
    _points[_key3] = arguments[_key3];
  }

  return {
    x: Math.max.apply(Math, operators_1.map(function (point) {
      return point.x;
    })(_points)),
    y: Math.min.apply(Math, operators_1.map(function (point) {
      return point.y;
    })(_points))
  };
}

exports.getBottomLeft = getBottomLeft;

function getBottomRight() {
  for (var _len4 = arguments.length, _points = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
    _points[_key4] = arguments[_key4];
  }

  return {
    x: Math.max.apply(Math, operators_1.map(function (point) {
      return point.x;
    })(_points)),
    y: Math.max.apply(Math, operators_1.map(function (point) {
      return point.y;
    })(_points))
  };
}

exports.getBottomRight = getBottomRight;

function getCentre() {
  var tl = getTopLeft.apply(void 0, arguments);
  var br = getBottomRight.apply(void 0, arguments);
  return {
    x: tl.x + (br.x - tl.x) / 2,
    y: tl.y + (br.y - tl.y) / 2
  };
}

exports.getCentre = getCentre;

/***/ }),

/***/ "./node_modules/@morleydev/pauper/models/rectangle/rectangle.model.bounding.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var point_model_bounding_1 = __webpack_require__("./node_modules/@morleydev/pauper/models/point/point.model.bounding.js");

function boundingTLBR() {
  for (var _len = arguments.length, _rects = new Array(_len), _key = 0; _key < _len; _key++) {
    _rects[_key] = arguments[_key];
  }

  return point_model_bounding_1.boundingTLBR.apply(point_model_bounding_1, _rects.concat(_rects.map(function (rect) {
    return {
      x: rect.x + rect.width,
      y: rect.y + rect.height
    };
  })));
}

exports.boundingTLBR = boundingTLBR;

function bounding() {
  for (var _len2 = arguments.length, _rects = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    _rects[_key2] = arguments[_key2];
  }

  return point_model_bounding_1.bounding.apply(point_model_bounding_1, _rects.concat(_rects.map(function (rect) {
    return {
      x: rect.x + rect.width,
      y: rect.y + rect.height
    };
  })));
}

exports.bounding = bounding;

/***/ }),

/***/ "./node_modules/@morleydev/pauper/models/rectangle/rectangle.model.is.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

function is(possible) {
  return possible.x != null && possible.y != null && possible.width != null && possible.height != null;
}

exports.is = is;

/***/ }),

/***/ "./node_modules/@morleydev/pauper/models/rectangle/rectangle.model.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var bounding = __webpack_require__("./node_modules/@morleydev/pauper/models/rectangle/rectangle.model.bounding.js");

var is = __webpack_require__("./node_modules/@morleydev/pauper/models/rectangle/rectangle.model.is.js");

var lines = __webpack_require__("./node_modules/@morleydev/pauper/models/rectangle/rectangle.model.lines.js");

var lineTo = __webpack_require__("./node_modules/@morleydev/pauper/models/rectangle/rectangle.model.lineTo.js");

var overlaps = __webpack_require__("./node_modules/@morleydev/pauper/models/rectangle/rectangle.model.overlap.js");

var tlbr = __webpack_require__("./node_modules/@morleydev/pauper/models/rectangle/rectangle.model.tlbr.js");

exports.Rectangle = Object.assign(function (x, y, width, height) {
  return {
    x: x,
    y: y,
    width: width,
    height: height
  };
}, Object.assign({}, bounding, tlbr, is, overlaps, lineTo, lines));

/***/ }),

/***/ "./node_modules/@morleydev/pauper/models/rectangle/rectangle.model.lineTo.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var vector_maths_func_1 = __webpack_require__("./node_modules/@morleydev/pauper/maths/vector.maths.func.js");

var circle_model_is_1 = __webpack_require__("./node_modules/@morleydev/pauper/models/circle/circle.model.is.js");

var line_model_is_1 = __webpack_require__("./node_modules/@morleydev/pauper/models/line/line.model.is.js");

var line_model_lineTo_1 = __webpack_require__("./node_modules/@morleydev/pauper/models/line/line.model.lineTo.js");

var triangle_model_is_1 = __webpack_require__("./node_modules/@morleydev/pauper/models/triangle/triangle.model.is.js");

var rectangle_model_is_1 = __webpack_require__("./node_modules/@morleydev/pauper/models/rectangle/rectangle.model.is.js");

var rectangle_model_lines_1 = __webpack_require__("./node_modules/@morleydev/pauper/models/rectangle/rectangle.model.lines.js");

var rectangle_model_tlbr_1 = __webpack_require__("./node_modules/@morleydev/pauper/models/rectangle/rectangle.model.tlbr.js");

function lineTo(lhs, rhs) {
  if (line_model_is_1.is(rhs)) {
    var _line_model_lineTo_1$ = line_model_lineTo_1.lineLine2ToRectangle(rhs, lhs),
        b = _line_model_lineTo_1$[0],
        a = _line_model_lineTo_1$[1];

    return [a, b];
  } else if (triangle_model_is_1.is(rhs)) {
    return lineRectangleToTriangle(lhs, rhs);
  } else if (circle_model_is_1.is(rhs)) {
    return lineRectangleToCircle(lhs, rhs);
  } else if (rectangle_model_is_1.is(rhs)) {
    return lineRectangleToRectangle(lhs, rhs);
  } else {
    return lineRectangleToPoint2(lhs, rhs);
  }
}

exports.lineTo = lineTo;

function lineRectangleToTriangle(lhs, rhs) {
  var _rectangle_model_line = rectangle_model_lines_1.lines(lhs),
      left = _rectangle_model_line.left,
      right = _rectangle_model_line.right,
      top = _rectangle_model_line.top,
      bottom = _rectangle_model_line.bottom;

  return line_model_lineTo_1.findShortestLine([line_model_lineTo_1.lineLine2ToTriangle2(left, rhs), line_model_lineTo_1.lineLine2ToTriangle2(right, rhs), line_model_lineTo_1.lineLine2ToTriangle2(top, rhs), line_model_lineTo_1.lineLine2ToTriangle2(bottom, rhs)]);
}

exports.lineRectangleToTriangle = lineRectangleToTriangle;

function lineRectangleToRectangle(lhs, rhs) {
  // WARNING: Does not produce the optimal solution
  var lhsCentre = rectangle_model_tlbr_1.getCentre(lhs);
  var rhsCentre = rectangle_model_tlbr_1.getCentre(rhs);

  var _lineTo = lineTo(lhs, rhsCentre),
      lhsEdge = _lineTo[0];

  var _lineTo2 = lineTo(rhs, lhsCentre),
      rhsEdge = _lineTo2[0];

  return [lhsEdge, rhsEdge];
}

exports.lineRectangleToRectangle = lineRectangleToRectangle;

function lineRectangleToCircle(lhs, rhs) {
  var _lineRectangleToPoint = lineRectangleToPoint2(lhs, rhs),
      pointOnRectangle = _lineRectangleToPoint[0],
      centreOfCircle = _lineRectangleToPoint[1];

  var vectorOfLine = vector_maths_func_1.subtract(pointOnRectangle, centreOfCircle);
  var normalisedLine = vector_maths_func_1.normalise(vectorOfLine);
  var lineOfRadiusLength = vector_maths_func_1.multiply(normalisedLine, rhs.radius);
  var pointOnCircle = vector_maths_func_1.add(lineOfRadiusLength, centreOfCircle);
  return [pointOnRectangle, pointOnCircle];
}

exports.lineRectangleToCircle = lineRectangleToCircle;

function lineRectangleToPoint2(lhs, rhs) {
  if (rhs.x <= lhs.x) {
    if (rhs.y <= lhs.y) {
      return [lhs, rhs];
    } else if (rhs.y > lhs.y + lhs.height) {
      return [rectangle_model_tlbr_1.getBottomLeft(lhs), rhs];
    } else {
      return [{
        x: lhs.x,
        y: rhs.y
      }, rhs];
    }
  } else if (rhs.x >= lhs.x + lhs.width) {
    if (rhs.y < lhs.y) {
      return [rectangle_model_tlbr_1.getTopRight(lhs), rhs];
    } else if (rhs.y > lhs.y + lhs.height) {
      return [rectangle_model_tlbr_1.getBottomRight(lhs), rhs];
    } else {
      return [{
        x: lhs.x + lhs.width,
        y: rhs.y
      }, rhs];
    }
  } else if (rhs.y <= lhs.y) {
    return [{
      x: rhs.x,
      y: lhs.y
    }, rhs];
  } else if (rhs.y >= lhs.y + lhs.height) {
    return [{
      x: rhs.x,
      y: lhs.y + lhs.height
    }, rhs];
  } else {
    return [rectangle_model_tlbr_1.getCentre(lhs), rhs];
  }
}

exports.lineRectangleToPoint2 = lineRectangleToPoint2;

/***/ }),

/***/ "./node_modules/@morleydev/pauper/models/rectangle/rectangle.model.lines.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var rectangle_model_bounding_1 = __webpack_require__("./node_modules/@morleydev/pauper/models/rectangle/rectangle.model.bounding.js");

function lines(rectangle) {
  var bounding = rectangle_model_bounding_1.boundingTLBR(rectangle);
  return {
    top: [bounding.topLeft, {
      x: bounding.bottomRight.x,
      y: bounding.topLeft.y
    }],
    left: [bounding.topLeft, {
      x: bounding.topLeft.x,
      y: bounding.bottomRight.y
    }],
    bottom: [{
      x: bounding.topLeft.x,
      y: bounding.bottomRight.y
    }, bounding.bottomRight],
    right: [{
      x: bounding.bottomRight.x,
      y: bounding.topLeft.y
    }, bounding.bottomRight]
  };
}

exports.lines = lines;

/***/ }),

/***/ "./node_modules/@morleydev/pauper/models/rectangle/rectangle.model.overlap.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var circle_model_is_1 = __webpack_require__("./node_modules/@morleydev/pauper/models/circle/circle.model.is.js");

var line_model_intersect_1 = __webpack_require__("./node_modules/@morleydev/pauper/models/line/line.model.intersect.js");

var line_model_is_1 = __webpack_require__("./node_modules/@morleydev/pauper/models/line/line.model.is.js");

var line_model_length_1 = __webpack_require__("./node_modules/@morleydev/pauper/models/line/line.model.length.js");

var triangle_model_is_1 = __webpack_require__("./node_modules/@morleydev/pauper/models/triangle/triangle.model.is.js");

var triangle_model_overlap_1 = __webpack_require__("./node_modules/@morleydev/pauper/models/triangle/triangle.model.overlap.js");

var rectangle_model_is_1 = __webpack_require__("./node_modules/@morleydev/pauper/models/rectangle/rectangle.model.is.js");

var rectangle_model_lineTo_1 = __webpack_require__("./node_modules/@morleydev/pauper/models/rectangle/rectangle.model.lineTo.js");

function overlaps(lhs, rhs) {
  if (line_model_is_1.is(rhs)) {
    return rectangleOverlapsLine2(lhs, rhs);
  } else if (triangle_model_is_1.is(rhs)) {
    return rectangleOverlapsTriangle2(lhs, rhs);
  } else if (rectangle_model_is_1.is(rhs)) {
    return rectangleOverlapsRectangle(lhs, rhs);
  } else if (circle_model_is_1.is(rhs)) {
    return rectangleOverlapsCircle(lhs, rhs);
  } else {
    return rectangleOverlapsPoint2(lhs, rhs);
  }
}

exports.overlaps = overlaps;

function rectangleOverlapsLine2(lhs, rhs) {
  if (rectangleOverlapsPoint2(lhs, rhs[0]) || rectangleOverlapsPoint2(lhs, rhs[1])) {
    return true;
  }

  return line_model_intersect_1.line2IntersectsRectangle(rhs, lhs);
}

exports.rectangleOverlapsLine2 = rectangleOverlapsLine2;

function rectangleOverlapsTriangle2(lhs, rhs) {
  return triangle_model_overlap_1.triangle2OverlapsRectangle(rhs, lhs);
}

exports.rectangleOverlapsTriangle2 = rectangleOverlapsTriangle2;

function rectangleOverlapsRectangle(lhs, rhs) {
  return !(lhs.x > rhs.x + rhs.width || lhs.y > rhs.y + rhs.height || lhs.x + lhs.width < rhs.x || lhs.y + lhs.height < rhs.y);
}

exports.rectangleOverlapsRectangle = rectangleOverlapsRectangle;

function rectangleOverlapsCircle(lhs, rhs) {
  return rectangleOverlapsPoint2(lhs, rhs) || line_model_length_1.lengthOf(rectangle_model_lineTo_1.lineTo(lhs, {
    x: rhs.x,
    y: rhs.y
  })) <= rhs.radius;
}

exports.rectangleOverlapsCircle = rectangleOverlapsCircle;

function rectangleOverlapsPoint2(lhs, rhs) {
  return rhs.x >= lhs.x && rhs.x <= lhs.x + lhs.width && rhs.y >= lhs.y && rhs.y <= lhs.y + lhs.height;
}

exports.rectangleOverlapsPoint2 = rectangleOverlapsPoint2;

/***/ }),

/***/ "./node_modules/@morleydev/pauper/models/rectangle/rectangle.model.tlbr.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

function getCentre(rectangle) {
  return {
    x: rectangle.x + rectangle.width / 2,
    y: rectangle.y + rectangle.height / 2
  };
}

exports.getCentre = getCentre;

function getTopLeft(rectangle) {
  return {
    x: rectangle.x,
    y: rectangle.y
  };
}

exports.getTopLeft = getTopLeft;

function getTopRight(rectangle) {
  return {
    x: rectangle.x + rectangle.width,
    y: rectangle.y
  };
}

exports.getTopRight = getTopRight;

function getBottomLeft(rectangle) {
  return {
    x: rectangle.x,
    y: rectangle.y + rectangle.height
  };
}

exports.getBottomLeft = getBottomLeft;

function getBottomRight(rectangle) {
  return {
    x: rectangle.x + rectangle.width,
    y: rectangle.y + rectangle.height
  };
}

exports.getBottomRight = getBottomRight;

function fromTopLeftBottomRight(tl, br) {
  return {
    x: tl.x,
    y: tl.y,
    width: br.x - tl.x,
    height: br.y - tl.y
  };
}

exports.fromTopLeftBottomRight = fromTopLeftBottomRight;

/***/ }),

/***/ "./node_modules/@morleydev/pauper/models/shapes.model.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var vector_maths_1 = __webpack_require__("./node_modules/@morleydev/pauper/maths/vector.maths.js");

var circle_model_1 = __webpack_require__("./node_modules/@morleydev/pauper/models/circle/circle.model.js");

var line_model_1 = __webpack_require__("./node_modules/@morleydev/pauper/models/line/line.model.js");

var point_model_1 = __webpack_require__("./node_modules/@morleydev/pauper/models/point/point.model.js");

var rectangle_model_1 = __webpack_require__("./node_modules/@morleydev/pauper/models/rectangle/rectangle.model.js");

var rectangle_model_tlbr_1 = __webpack_require__("./node_modules/@morleydev/pauper/models/rectangle/rectangle.model.tlbr.js");

var triangle_model_1 = __webpack_require__("./node_modules/@morleydev/pauper/models/triangle/triangle.model.js");

var circle_model_2 = __webpack_require__("./node_modules/@morleydev/pauper/models/circle/circle.model.js");

exports.Circle = circle_model_2.Circle;

var point_model_2 = __webpack_require__("./node_modules/@morleydev/pauper/models/point/point.model.js");

exports.Point2 = point_model_2.Point2;

var line_model_2 = __webpack_require__("./node_modules/@morleydev/pauper/models/line/line.model.js");

exports.Line2 = line_model_2.Line2;

var rectangle_model_2 = __webpack_require__("./node_modules/@morleydev/pauper/models/rectangle/rectangle.model.js");

exports.Rectangle = rectangle_model_2.Rectangle;

var text_model_1 = __webpack_require__("./node_modules/@morleydev/pauper/models/text/text.model.js");

exports.Text2 = text_model_1.Text2;

var triangle_model_2 = __webpack_require__("./node_modules/@morleydev/pauper/models/triangle/triangle.model.js");

exports.Triangle2 = triangle_model_2.Triangle2;
exports.Shape2 = {
  collision: function collision(lhs, rhs) {
    if (line_model_1.Line2.is(lhs)) {
      return line_model_1.Line2.intersects(lhs, rhs);
    } else if (triangle_model_1.Triangle2.is(lhs)) {
      return triangle_model_1.Triangle2.overlaps(lhs, rhs);
    } else if (circle_model_1.Circle.is(lhs)) {
      return circle_model_1.Circle.overlaps(lhs, rhs);
    } else if (rectangle_model_1.Rectangle.is(lhs)) {
      return rectangle_model_1.Rectangle.overlaps(lhs, rhs);
    } else {
      return false;
    }
  },
  add: function add(lhs, rhs) {
    if (Array.isArray(lhs)) {
      return lhs.map(function (vert) {
        return vector_maths_1.Vector2.add(vert, rhs);
      });
    } else {
      return Object.assign({}, lhs, vector_maths_1.Vector2.add(lhs, rhs));
    }
  },
  getCentre: function getCentre(shape) {
    if (Array.isArray(shape)) {
      return {
        x: shape.map(function (a) {
          return a.x;
        }).reduce(function (sum, curr) {
          return sum + curr;
        }) / shape.length,
        y: shape.map(function (a) {
          return a.y;
        }).reduce(function (sum, curr) {
          return sum + curr;
        }) / shape.length
      };
    } else if (rectangle_model_1.Rectangle.is(shape)) {
      return rectangle_model_tlbr_1.getCentre(shape);
    } else {
      return {
        x: shape.x,
        y: shape.y
      };
    }
  },
  bounding: function bounding(lhs) {
    if (line_model_1.Line2.is(lhs)) {
      var topLeft = {
        x: Math.min(lhs[0].x, lhs[1].x),
        y: Math.min(lhs[0].y, lhs[1].y)
      };
      var bottomRight = {
        x: Math.max(lhs[0].x, lhs[1].x),
        y: Math.max(lhs[0].y, lhs[1].y)
      };
      return rectangle_model_1.Rectangle.fromTopLeftBottomRight(topLeft, bottomRight);
    } else if (triangle_model_1.Triangle2.is(lhs)) {
      var _topLeft = {
        x: Math.min(lhs[0].x, lhs[1].x, lhs[2].x),
        y: Math.min(lhs[0].y, lhs[1].y, lhs[1].y)
      };
      var _bottomRight = {
        x: Math.max(lhs[0].x, lhs[1].x, lhs[2].x),
        y: Math.max(lhs[0].y, lhs[1].y, lhs[2].y)
      };
      return rectangle_model_1.Rectangle.fromTopLeftBottomRight(_topLeft, _bottomRight);
    } else if (circle_model_1.Circle.is(lhs)) {
      return rectangle_model_1.Rectangle(lhs.x - lhs.radius, lhs.y - lhs.radius, lhs.radius * 2, lhs.radius * 2);
    } else if (rectangle_model_1.Rectangle.is(lhs)) {
      return lhs;
    } else if (point_model_1.Point2.is(lhs)) {
      return rectangle_model_1.Rectangle(lhs.x, lhs.y, 0, 0);
    } else {
      return rectangle_model_1.Rectangle(0, 0, 0, 0);
    }
  },
  lineTo: function lineTo(lhs, rhs) {
    if (line_model_1.Line2.is(lhs)) {
      return line_model_1.Line2.lineTo(lhs, rhs);
    } else if (triangle_model_1.Triangle2.is(lhs)) {
      return triangle_model_1.Triangle2.lineTo(lhs, rhs);
    } else if (circle_model_1.Circle.is(lhs)) {
      return circle_model_1.Circle.lineTo(lhs, rhs);
    } else if (rectangle_model_1.Rectangle.is(lhs)) {
      return rectangle_model_1.Rectangle.lineTo(lhs, rhs);
    } else if (point_model_1.Point2.is(lhs)) {
      var flip = function flip(_ref) {
        var a = _ref[0],
            b = _ref[1];
        return [b, a];
      };

      if (line_model_1.Line2.is(rhs)) {
        return flip(exports.Shape2.lineTo(rhs, lhs));
      } else if (triangle_model_1.Triangle2.is(rhs)) {
        return flip(triangle_model_1.Triangle2.lineTo(rhs, lhs));
      } else if (circle_model_1.Circle.is(rhs)) {
        return flip(circle_model_1.Circle.lineTo(rhs, lhs));
      } else if (rectangle_model_1.Rectangle.is(rhs)) {
        return flip(rectangle_model_1.Rectangle.lineTo(rhs, lhs));
      } else if (point_model_1.Point2.is(rhs)) {
        return [lhs, rhs];
      } else {
        return [point_model_1.Point2(0, 0), point_model_1.Point2(0, 0)];
      }
    } else {
      return [point_model_1.Point2(0, 0), point_model_1.Point2(0, 0)];
    }
  }
};

/***/ }),

/***/ "./node_modules/@morleydev/pauper/models/text/text.model.is.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

function is(possible) {
  return possible.text != null && possible.x != null && possible.y != null;
}

exports.is = is;

/***/ }),

/***/ "./node_modules/@morleydev/pauper/models/text/text.model.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var is = __webpack_require__("./node_modules/@morleydev/pauper/models/text/text.model.is.js");

exports.Text2 = Object.assign(function (text, x, y, fontSize, fontFamily) {
  return {
    text: text,
    x: x,
    y: y,
    fontSize: fontSize,
    fontFamily: fontFamily
  };
}, Object.assign({}, is));

/***/ }),

/***/ "./node_modules/@morleydev/pauper/models/triangle/triangle.model.is.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

function is(possible) {
  return Array.isArray(possible) && possible.length === 3;
}

exports.is = is;

/***/ }),

/***/ "./node_modules/@morleydev/pauper/models/triangle/triangle.model.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var is = __webpack_require__("./node_modules/@morleydev/pauper/models/triangle/triangle.model.is.js");

var lines = __webpack_require__("./node_modules/@morleydev/pauper/models/triangle/triangle.model.lines.js");

var overlaps = __webpack_require__("./node_modules/@morleydev/pauper/models/triangle/triangle.model.overlap.js");

var lineTo = __webpack_require__("./node_modules/@morleydev/pauper/models/triangle/triangle.model.lineTo.js");

exports.Triangle2 = Object.assign(function (a, b, c) {
  return [a, b, c];
}, Object.assign({}, is, overlaps, lines, lineTo));

/***/ }),

/***/ "./node_modules/@morleydev/pauper/models/triangle/triangle.model.lineTo.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var functional_pipe_1 = __webpack_require__("./node_modules/@morleydev/functional-pipe/index.js");

var operators_1 = __webpack_require__("./node_modules/@morleydev/functional-pipe/iterable/operators.js");

var circle_model_is_1 = __webpack_require__("./node_modules/@morleydev/pauper/models/circle/circle.model.is.js");

var circle_model_lineTo_1 = __webpack_require__("./node_modules/@morleydev/pauper/models/circle/circle.model.lineTo.js");

var line_model_is_1 = __webpack_require__("./node_modules/@morleydev/pauper/models/line/line.model.is.js");

var line_model_lineTo_1 = __webpack_require__("./node_modules/@morleydev/pauper/models/line/line.model.lineTo.js");

var rectangle_model_is_1 = __webpack_require__("./node_modules/@morleydev/pauper/models/rectangle/rectangle.model.is.js");

var rectangle_model_lineTo_1 = __webpack_require__("./node_modules/@morleydev/pauper/models/rectangle/rectangle.model.lineTo.js");

var triangle_model_is_1 = __webpack_require__("./node_modules/@morleydev/pauper/models/triangle/triangle.model.is.js");

var triangle_model_lines_1 = __webpack_require__("./node_modules/@morleydev/pauper/models/triangle/triangle.model.lines.js");

function lineTo(lhs, rhs) {
  if (line_model_is_1.is(rhs)) {
    return flip(line_model_lineTo_1.lineLine2ToTriangle2(rhs, lhs));
  } else if (triangle_model_is_1.is(rhs)) {
    return lineTriangle2ToTriangle2(lhs, rhs);
  } else if (circle_model_is_1.is(rhs)) {
    return flip(circle_model_lineTo_1.lineCircleToTriangle2(rhs, lhs));
  } else if (rectangle_model_is_1.is(rhs)) {
    return flip(rectangle_model_lineTo_1.lineRectangleToTriangle(rhs, lhs));
  } else {
    return lineTriangleToPoint2(lhs, rhs);
  }
}

exports.lineTo = lineTo;

var flip = function flip(_ref) {
  var a = _ref[0],
      b = _ref[1];
  return [b, a];
};

function lineTriangle2ToTriangle2(lhs, rhs) {
  var leftLines = triangle_model_lines_1.lines(lhs);
  var rightLines = triangle_model_lines_1.lines(rhs);
  return functional_pipe_1.$$(leftLines).$(operators_1.flatMap(function (lline) {
    return operators_1.map(function (rline) {
      return line_model_lineTo_1.lineLine2ToLine2(lline, rline);
    })(rightLines);
  })).$$(line_model_lineTo_1.findShortestLine);
}

exports.lineTriangle2ToTriangle2 = lineTriangle2ToTriangle2;

function lineTriangleToPoint2(lhs, rhs) {
  return functional_pipe_1.$$(lhs).$(triangle_model_lines_1.lines).$(operators_1.map(function (line) {
    return line_model_lineTo_1.lineLine2ToPoint2(line, rhs);
  })).$$(line_model_lineTo_1.findShortestLine);
}

exports.lineTriangleToPoint2 = lineTriangleToPoint2;

/***/ }),

/***/ "./node_modules/@morleydev/pauper/models/triangle/triangle.model.lines.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

function lines(lhs) {
  return [[lhs[0], lhs[1]], [lhs[1], lhs[2]], [lhs[2], lhs[0]]];
}

exports.lines = lines;

/***/ }),

/***/ "./node_modules/@morleydev/pauper/models/triangle/triangle.model.overlap.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var circle_model_is_1 = __webpack_require__("./node_modules/@morleydev/pauper/models/circle/circle.model.is.js");

var line_model_intersect_1 = __webpack_require__("./node_modules/@morleydev/pauper/models/line/line.model.intersect.js");

var line_model_is_1 = __webpack_require__("./node_modules/@morleydev/pauper/models/line/line.model.is.js");

var rectangle_model_is_1 = __webpack_require__("./node_modules/@morleydev/pauper/models/rectangle/rectangle.model.is.js");

var rectangle_model_lines_1 = __webpack_require__("./node_modules/@morleydev/pauper/models/rectangle/rectangle.model.lines.js");

var triangle_model_is_1 = __webpack_require__("./node_modules/@morleydev/pauper/models/triangle/triangle.model.is.js");

var triangle_model_lines_1 = __webpack_require__("./node_modules/@morleydev/pauper/models/triangle/triangle.model.lines.js");

function overlaps(lhs, rhs) {
  if (triangle_model_is_1.is(rhs)) {
    return triangle2OverlapsTriangle2(lhs, rhs);
  } else if (line_model_is_1.is(rhs)) {
    return triangle2OverlapsLine2(lhs, rhs);
  } else if (rectangle_model_is_1.is(rhs)) {
    return triangle2OverlapsRectangle(lhs, rhs);
  } else if (circle_model_is_1.is(rhs)) {
    return triangle2OverlapsCircle(lhs, rhs);
  } else {
    return triangle2OverlapsPoint2(lhs, rhs);
  }
}

exports.overlaps = overlaps;

function triangle2OverlapsCircle(lhs, rhs) {
  if (triangle2OverlapsPoint2(lhs, rhs)) {
    return true;
  }

  return triangle_model_lines_1.lines(lhs).some(function (line) {
    return line_model_intersect_1.line2IntersectsCircle(line, rhs);
  });
}

exports.triangle2OverlapsCircle = triangle2OverlapsCircle;

function triangle2OverlapsRectangle(lhs, rhs) {
  var _rectangle_model_line = rectangle_model_lines_1.lines(rhs),
      bottom = _rectangle_model_line.bottom,
      top = _rectangle_model_line.top,
      left = _rectangle_model_line.left,
      right = _rectangle_model_line.right;

  var rectLineSet = [bottom, top, left, right];
  return rectLineSet.some(function (line) {
    return triangle2OverlapsLine2(lhs, line);
  });
}

exports.triangle2OverlapsRectangle = triangle2OverlapsRectangle;

function triangle2OverlapsTriangle2(lhs, rhs) {
  if (triangle2OverlapsPoint2(lhs, rhs[0]) || triangle2OverlapsPoint2(lhs, rhs[1]) || triangle2OverlapsPoint2(lhs, rhs[2])) {
    return true;
  }

  var lhsLines = triangle_model_lines_1.lines(lhs);
  return triangle_model_lines_1.lines(rhs).some(function (rhsLine) {
    return triangle2OverlapsLine2(lhs, rhsLine);
  });
}

exports.triangle2OverlapsTriangle2 = triangle2OverlapsTriangle2;

function triangle2OverlapsLine2(_ref, _ref2) {
  var v1 = _ref[0],
      v2 = _ref[1],
      v3 = _ref[2];
  var a = _ref2[0],
      b = _ref2[1];

  if (triangle2OverlapsPoint2([v1, v2, v3], a) || triangle2OverlapsPoint2([v1, v2, v3], b)) {
    return false;
  }

  return line_model_intersect_1.line2IntersectsTriangle2([a, b], [v1, v2, v3]);
}

exports.triangle2OverlapsLine2 = triangle2OverlapsLine2;

function triangle2OverlapsPoint2(_ref3, rhs) {
  var v1 = _ref3[0],
      v2 = _ref3[1],
      v3 = _ref3[2];

  var sign = function sign(p1, p2, p3) {
    return (p1.x - p3.x) * (p2.y - p3.y) - (p2.x - p3.x) * (p1.y - p3.y);
  };

  var b1 = sign(rhs, v1, v2) < 0.0;
  var b2 = sign(rhs, v2, v3) < 0.0;
  var b3 = sign(rhs, v3, v1) < 0.0;
  return b1 === b2 && b2 === b3;
}

exports.triangle2OverlapsPoint2 = triangle2OverlapsPoint2;

/***/ }),

/***/ "./node_modules/@morleydev/pauper/render/jsx/render.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var render_frame_model_1 = __webpack_require__("./node_modules/@morleydev/pauper/render/render-frame.model.js");

var colour_model_1 = __webpack_require__("./node_modules/@morleydev/pauper/models/colour.model.js");

var react_test_renderer_1 = __webpack_require__("./node_modules/react-test-renderer/index.js");

var ReactRenderer =
/*#__PURE__*/
function () {
  function ReactRenderer(element) {
    this.renderer = react_test_renderer_1.create(element);
  }

  var _proto = ReactRenderer.prototype;

  _proto.frame = function frame() {
    var json = this.renderer.toJSON();
    return json != null ? jsonToFrame(json) : [];
  };

  return ReactRenderer;
}();

exports.ReactRenderer = ReactRenderer;

function jsonToFrame(json) {
  switch (json.type) {
    case "clear":
      return [render_frame_model_1.Clear(json.props["colour"] || colour_model_1.RGB(0, 0, 0)), (json.children || []).map(jsonToFrame)];

    case "origin":
      return render_frame_model_1.Origin(json.props["coords"], (json.children || []).map(jsonToFrame));

    case "rotate":
      return render_frame_model_1.Rotate(json.props["radians"], (json.children || []).map(jsonToFrame));

    case "scale":
      return render_frame_model_1.Scale(json.props["by"], (json.children || []).map(jsonToFrame));

    case "fill":
      return render_frame_model_1.Fill(json.props["shape"], json.props["colour"]);

    case "stroke":
      return render_frame_model_1.Stroke(json.props["shape"], json.props["colour"]);

    case "blit":
      return render_frame_model_1.Blit(json.props["image"], json.props["dst"], json.props["src"]);

    case "renderTarget":
      return render_frame_model_1.RenderTarget(json.props["dst"], (json.children || []).map(jsonToFrame), json.props["size"]);

    default:
      return (json.children || []).map(jsonToFrame);
  }
}

/***/ }),

/***/ "./node_modules/@morleydev/pauper/render/render-frame.model.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.Frame = function () {
  for (var _len = arguments.length, _commands = new Array(_len), _key = 0; _key < _len; _key++) {
    _commands[_key] = arguments[_key];
  }

  return _commands;
};

var FrameCommandType;

(function (FrameCommandType) {
  FrameCommandType[FrameCommandType["Clear"] = 0] = "Clear";
  FrameCommandType[FrameCommandType["Origin"] = 1] = "Origin";
  FrameCommandType[FrameCommandType["Rotate"] = 2] = "Rotate";
  FrameCommandType[FrameCommandType["Scale"] = 3] = "Scale";
  FrameCommandType[FrameCommandType["Fill"] = 4] = "Fill";
  FrameCommandType[FrameCommandType["Stroke"] = 5] = "Stroke";
  FrameCommandType[FrameCommandType["Blit"] = 6] = "Blit";
  FrameCommandType[FrameCommandType["RenderTarget"] = 7] = "RenderTarget";
})(FrameCommandType = exports.FrameCommandType || (exports.FrameCommandType = {}));

exports.Clear = function (colour) {
  return colour != null ? [FrameCommandType.Clear, colour] : [FrameCommandType.Clear];
};

exports.Origin = function (origin, child) {
  return [FrameCommandType.Origin, origin, child];
};

exports.Rotate = function (radian, child) {
  return [FrameCommandType.Rotate, radian, child];
};

exports.Scale = function (scale, child) {
  return [FrameCommandType.Scale, scale, child];
};

exports.Fill = function (dst, colour) {
  return [FrameCommandType.Fill, dst, colour];
};

exports.Stroke = function (dst, colour) {
  return [FrameCommandType.Stroke, dst, colour];
};

exports.Blit = function (image, dst, src) {
  return src != null ? [FrameCommandType.Blit, image, dst, src] : [FrameCommandType.Blit, image, dst];
};

exports.RenderTarget = function (dst, frame, size) {
  return [FrameCommandType.RenderTarget, dst, frame, size];
};

/***/ }),

/***/ "./node_modules/@morleydev/pauper/render/render-to-canvas.func.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var shapes_model_1 = __webpack_require__("./node_modules/@morleydev/pauper/models/shapes.model.js");

var render_frame_model_1 = __webpack_require__("./node_modules/@morleydev/pauper/render/render-frame.model.js");

function renderToCanvas(target, frame) {
  return frame.forEach(function (command) {
    return RenderCommand(target, command);
  });
}

exports.renderToCanvas = renderToCanvas;

function RenderCommand(target, command) {
  var commandType = command[0];

  if (!Array.isArray(commandType)) {
    switch (commandType) {
      case render_frame_model_1.FrameCommandType.Clear:
        return renderClear(target, command);

      case render_frame_model_1.FrameCommandType.Origin:
        return renderOrigin(target, command);

      case render_frame_model_1.FrameCommandType.RenderTarget:
        return renderRenderTarget(target, command);

      case render_frame_model_1.FrameCommandType.Rotate:
        return renderRotate(target, command);

      case render_frame_model_1.FrameCommandType.Scale:
        return renderScale(target, command);

      case render_frame_model_1.FrameCommandType.Fill:
        return renderFill(target, command);

      case render_frame_model_1.FrameCommandType.Stroke:
        return renderStroke(target, command);

      case render_frame_model_1.FrameCommandType.Blit:
        return renderBlit(target, command);
    }
  } else {
    return command.forEach(function (c) {
      return RenderCommand(target, c);
    });
  }
}

function renderOrigin(_ref, command) {
  var canvas = _ref.canvas,
      context = _ref.context,
      assets = _ref.assets;
  var origin = command[1];
  context.translate(origin.x | 0, origin.y | 0);
  renderToCanvas({
    canvas: canvas,
    context: context,
    assets: assets
  }, command[2]);
  context.translate(-origin.x | 0, -origin.y | 0);
}

function renderRotate(_ref2, command) {
  var canvas = _ref2.canvas,
      context = _ref2.context,
      assets = _ref2.assets;
  var rotation = command[1];
  context.rotate(rotation);
  renderToCanvas({
    canvas: canvas,
    context: context,
    assets: assets
  }, command[2]);
  context.rotate(-rotation);
}

function renderScale(_ref3, command) {
  var canvas = _ref3.canvas,
      context = _ref3.context,
      assets = _ref3.assets;
  var scale = command[1];
  context.scale(scale.x, scale.y);
  renderToCanvas({
    canvas: canvas,
    context: context,
    assets: assets
  }, command[2]);
  context.scale(1 / scale.x, 1 / scale.y);
}

function renderBlit(_ref4, command) {
  var canvas = _ref4.canvas,
      context = _ref4.context,
      assets = _ref4.assets;
  var image = command[1];
  var dst = command[2];
  var src = command[3];
  var imgAsset = assets.getImage(image);

  if (shapes_model_1.Rectangle.is(dst)) {
    if (src != null) {
      context.drawImage(imgAsset, src.x | 0, src.y | 0, src.width | 0, src.height | 0, dst.x | 0, dst.y | 0, dst.width | 0, dst.height | 0);
    } else {
      context.drawImage(imgAsset, dst.x | 0, dst.y | 0, dst.width | 0, dst.height | 0);
    }
  } else {
    context.drawImage(imgAsset, dst.x | 0, dst.y | 0);
  }
}

function renderFill(_ref5, fill) {
  var canvas = _ref5.canvas,
      context = _ref5.context,
      assets = _ref5.assets;
  var shape = fill[1];
  var colour = fill[2];
  context.beginPath();
  context.fillStyle = getRGBA(colour);

  if (Array.isArray(shape)) {
    context.moveTo(shape[0].x | 0, shape[0].y | 0);

    for (var i = 1; i < shape.length; ++i) {
      context.lineTo(shape[i].x | 0, shape[i].y | 0);
    }

    context.fill();
  } else if (shapes_model_1.Text2.is(shape)) {
    var size = shape.fontSize || 10;
    context.font = size + "px " + (shape.fontFamily || "serif");
    context.fillText(shape.text, shape.x | 0, shape.y + size | 0);
  } else if (shapes_model_1.Rectangle.is(shape)) {
    context.fillRect(shape.x | 0, shape.y | 0, shape.width | 0, shape.height | 0);
  } else if (shapes_model_1.Circle.is(shape)) {
    context.arc(shape.x | 0, shape.y | 0, shape.radius | 0, 0, 2 * Math.PI);
    context.fill();
  }
}

function renderStroke(_ref6, fill) {
  var canvas = _ref6.canvas,
      context = _ref6.context,
      assets = _ref6.assets;
  var shape = fill[1];
  var colour = fill[2];
  context.beginPath();
  context.strokeStyle = getRGBA(colour);

  if (Array.isArray(shape)) {
    context.moveTo(shape[0].x | 0, shape[0].y | 0);

    for (var i = 1; i < shape.length; ++i) {
      context.lineTo(shape[i].x | 0, shape[i].y | 0);
    }

    context.stroke();
  } else if (shapes_model_1.Text2.is(shape)) {
    var size = shape.fontSize || 10;
    context.font = size + "px " + (shape.fontFamily || "serif");
    context.strokeText(shape.text, shape.x | 0, shape.y + size / 2 | 0);
  } else if (shapes_model_1.Rectangle.is(shape)) {
    context.strokeRect(shape.x | 0, shape.y | 0, shape.width | 0, shape.height | 0);
  } else if (shapes_model_1.Circle.is(shape)) {
    context.arc(shape.x | 0, shape.y | 0, shape.radius | 0, 0, 2 * Math.PI);
    context.stroke();
  }

  context.closePath();
}

function renderClear(_ref7, clear) {
  var canvas = _ref7.canvas,
      context = _ref7.context,
      assets = _ref7.assets;
  context.setTransform(1, 0, 0, 1, 0, 0);
  context.clearRect(0, 0, canvas.width | 0, canvas.height | 0);
  var colour = clear[1];
  context.fillStyle = colour ? getRGB(colour) : "black";
  context.fillRect(0, 0, canvas.width | 0, canvas.height | 0);
} // tslint:disable-next-line:readonly-keyword


var canvasCache = {};

function renderRenderTarget(_ref8, _ref9) {
  var canvas = _ref8.canvas,
      context = _ref8.context,
      assets = _ref8.assets;
  var _ = _ref9[0],
      dst = _ref9[1],
      frames = _ref9[2],
      size = _ref9[3];
  var width = (size == null ? dst.width : size.x) | 0;
  var height = (size == null ? dst.height : size.y) | 0;
  var key = "" + width + height;
  var targetCanvas = canvasCache[key];
  canvasCache[key] = null;

  if (targetCanvas == null) {
    var newCanvas = document.createElement("canvas");
    newCanvas.width = (size == null ? dst.width : size.x) | 0;
    newCanvas.height = (size == null ? dst.height : size.y) | 0;
    targetCanvas = {
      canvas: newCanvas,
      context: newCanvas.getContext("2d"),
      assets: assets
    };
  }

  renderToCanvas(targetCanvas, frames);
  context.drawImage(targetCanvas.canvas, dst.x | 0, dst.y | 0, dst.width | 0, dst.height | 0);
  canvasCache[key] = targetCanvas;
}

function getRGBA(colour) {
  return colour.a != null ? "rgba(" + (colour.r | 0) + ", " + (colour.g | 0) + ", " + (colour.b | 0) + ", " + colour.a + ")" : getRGB(colour);
}

function getRGB(colour) {
  return "rgb(" + (colour.r | 0) + ", " + (colour.g | 0) + ", " + (colour.b | 0) + ")";
}

/***/ }),

/***/ "./node_modules/@morleydev/pauper/utility/is-browser.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isBrowser = typeof window !== "undefined";

/***/ }),

/***/ "./node_modules/@morleydev/pauper/utility/is-production.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isProduction = process && process.env && process.env["NODE_ENV"] === "Production";
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__("./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/core-js/modules/_a-function.js":
/***/ (function(module, exports) {

module.exports = function (it) {
  if (typeof it != 'function') throw TypeError(it + ' is not a function!');
  return it;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_a-number-value.js":
/***/ (function(module, exports, __webpack_require__) {

var cof = __webpack_require__("./node_modules/core-js/modules/_cof.js");

module.exports = function (it, msg) {
  if (typeof it != 'number' && cof(it) != 'Number') throw TypeError(msg);
  return +it;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_add-to-unscopables.js":
/***/ (function(module, exports, __webpack_require__) {

// 22.1.3.31 Array.prototype[@@unscopables]
var UNSCOPABLES = __webpack_require__("./node_modules/core-js/modules/_wks.js")('unscopables');

var ArrayProto = Array.prototype;
if (ArrayProto[UNSCOPABLES] == undefined) __webpack_require__("./node_modules/core-js/modules/_hide.js")(ArrayProto, UNSCOPABLES, {});

module.exports = function (key) {
  ArrayProto[UNSCOPABLES][key] = true;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_an-instance.js":
/***/ (function(module, exports) {

module.exports = function (it, Constructor, name, forbiddenField) {
  if (!(it instanceof Constructor) || forbiddenField !== undefined && forbiddenField in it) {
    throw TypeError(name + ': incorrect invocation!');
  }

  return it;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_an-object.js":
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__("./node_modules/core-js/modules/_is-object.js");

module.exports = function (it) {
  if (!isObject(it)) throw TypeError(it + ' is not an object!');
  return it;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_array-copy-within.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)


var toObject = __webpack_require__("./node_modules/core-js/modules/_to-object.js");

var toAbsoluteIndex = __webpack_require__("./node_modules/core-js/modules/_to-absolute-index.js");

var toLength = __webpack_require__("./node_modules/core-js/modules/_to-length.js");

module.exports = [].copyWithin || function copyWithin(target
/* = 0 */
, start
/* = 0, end = @length */
) {
  var O = toObject(this);
  var len = toLength(O.length);
  var to = toAbsoluteIndex(target, len);
  var from = toAbsoluteIndex(start, len);
  var end = arguments.length > 2 ? arguments[2] : undefined;
  var count = Math.min((end === undefined ? len : toAbsoluteIndex(end, len)) - from, len - to);
  var inc = 1;

  if (from < to && to < from + count) {
    inc = -1;
    from += count - 1;
    to += count - 1;
  }

  while (count-- > 0) {
    if (from in O) O[to] = O[from];else delete O[to];
    to += inc;
    from += inc;
  }

  return O;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_array-fill.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)


var toObject = __webpack_require__("./node_modules/core-js/modules/_to-object.js");

var toAbsoluteIndex = __webpack_require__("./node_modules/core-js/modules/_to-absolute-index.js");

var toLength = __webpack_require__("./node_modules/core-js/modules/_to-length.js");

module.exports = function fill(value
/* , start = 0, end = @length */
) {
  var O = toObject(this);
  var length = toLength(O.length);
  var aLen = arguments.length;
  var index = toAbsoluteIndex(aLen > 1 ? arguments[1] : undefined, length);
  var end = aLen > 2 ? arguments[2] : undefined;
  var endPos = end === undefined ? length : toAbsoluteIndex(end, length);

  while (endPos > index) {
    O[index++] = value;
  }

  return O;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_array-from-iterable.js":
/***/ (function(module, exports, __webpack_require__) {

var forOf = __webpack_require__("./node_modules/core-js/modules/_for-of.js");

module.exports = function (iter, ITERATOR) {
  var result = [];
  forOf(iter, false, result.push, result, ITERATOR);
  return result;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_array-includes.js":
/***/ (function(module, exports, __webpack_require__) {

// false -> Array#indexOf
// true  -> Array#includes
var toIObject = __webpack_require__("./node_modules/core-js/modules/_to-iobject.js");

var toLength = __webpack_require__("./node_modules/core-js/modules/_to-length.js");

var toAbsoluteIndex = __webpack_require__("./node_modules/core-js/modules/_to-absolute-index.js");

module.exports = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIObject($this);
    var length = toLength(O.length);
    var index = toAbsoluteIndex(fromIndex, length);
    var value; // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare

    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++]; // eslint-disable-next-line no-self-compare

      if (value != value) return true; // Array#indexOf ignores holes, Array#includes - not
    } else for (; length > index; index++) {
      if (IS_INCLUDES || index in O) {
        if (O[index] === el) return IS_INCLUDES || index || 0;
      }
    }
    return !IS_INCLUDES && -1;
  };
};

/***/ }),

/***/ "./node_modules/core-js/modules/_array-methods.js":
/***/ (function(module, exports, __webpack_require__) {

// 0 -> Array#forEach
// 1 -> Array#map
// 2 -> Array#filter
// 3 -> Array#some
// 4 -> Array#every
// 5 -> Array#find
// 6 -> Array#findIndex
var ctx = __webpack_require__("./node_modules/core-js/modules/_ctx.js");

var IObject = __webpack_require__("./node_modules/core-js/modules/_iobject.js");

var toObject = __webpack_require__("./node_modules/core-js/modules/_to-object.js");

var toLength = __webpack_require__("./node_modules/core-js/modules/_to-length.js");

var asc = __webpack_require__("./node_modules/core-js/modules/_array-species-create.js");

module.exports = function (TYPE, $create) {
  var IS_MAP = TYPE == 1;
  var IS_FILTER = TYPE == 2;
  var IS_SOME = TYPE == 3;
  var IS_EVERY = TYPE == 4;
  var IS_FIND_INDEX = TYPE == 6;
  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
  var create = $create || asc;
  return function ($this, callbackfn, that) {
    var O = toObject($this);
    var self = IObject(O);
    var f = ctx(callbackfn, that, 3);
    var length = toLength(self.length);
    var index = 0;
    var result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined;
    var val, res;

    for (; length > index; index++) {
      if (NO_HOLES || index in self) {
        val = self[index];
        res = f(val, index, O);

        if (TYPE) {
          if (IS_MAP) result[index] = res; // map
          else if (res) switch (TYPE) {
              case 3:
                return true;
              // some

              case 5:
                return val;
              // find

              case 6:
                return index;
              // findIndex

              case 2:
                result.push(val);
              // filter
            } else if (IS_EVERY) return false; // every
        }
      }
    }

    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
  };
};

/***/ }),

/***/ "./node_modules/core-js/modules/_array-reduce.js":
/***/ (function(module, exports, __webpack_require__) {

var aFunction = __webpack_require__("./node_modules/core-js/modules/_a-function.js");

var toObject = __webpack_require__("./node_modules/core-js/modules/_to-object.js");

var IObject = __webpack_require__("./node_modules/core-js/modules/_iobject.js");

var toLength = __webpack_require__("./node_modules/core-js/modules/_to-length.js");

module.exports = function (that, callbackfn, aLen, memo, isRight) {
  aFunction(callbackfn);
  var O = toObject(that);
  var self = IObject(O);
  var length = toLength(O.length);
  var index = isRight ? length - 1 : 0;
  var i = isRight ? -1 : 1;
  if (aLen < 2) for (;;) {
    if (index in self) {
      memo = self[index];
      index += i;
      break;
    }

    index += i;

    if (isRight ? index < 0 : length <= index) {
      throw TypeError('Reduce of empty array with no initial value');
    }
  }

  for (; isRight ? index >= 0 : length > index; index += i) {
    if (index in self) {
      memo = callbackfn(memo, self[index], index, O);
    }
  }

  return memo;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_array-species-constructor.js":
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__("./node_modules/core-js/modules/_is-object.js");

var isArray = __webpack_require__("./node_modules/core-js/modules/_is-array.js");

var SPECIES = __webpack_require__("./node_modules/core-js/modules/_wks.js")('species');

module.exports = function (original) {
  var C;

  if (isArray(original)) {
    C = original.constructor; // cross-realm fallback

    if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined;

    if (isObject(C)) {
      C = C[SPECIES];
      if (C === null) C = undefined;
    }
  }

  return C === undefined ? Array : C;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_array-species-create.js":
/***/ (function(module, exports, __webpack_require__) {

// 9.4.2.3 ArraySpeciesCreate(originalArray, length)
var speciesConstructor = __webpack_require__("./node_modules/core-js/modules/_array-species-constructor.js");

module.exports = function (original, length) {
  return new (speciesConstructor(original))(length);
};

/***/ }),

/***/ "./node_modules/core-js/modules/_bind.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var aFunction = __webpack_require__("./node_modules/core-js/modules/_a-function.js");

var isObject = __webpack_require__("./node_modules/core-js/modules/_is-object.js");

var invoke = __webpack_require__("./node_modules/core-js/modules/_invoke.js");

var arraySlice = [].slice;
var factories = {};

var construct = function construct(F, len, args) {
  if (!(len in factories)) {
    for (var n = [], i = 0; i < len; i++) {
      n[i] = 'a[' + i + ']';
    } // eslint-disable-next-line no-new-func


    factories[len] = Function('F,a', 'return new F(' + n.join(',') + ')');
  }

  return factories[len](F, args);
};

module.exports = Function.bind || function bind(that
/* , ...args */
) {
  var fn = aFunction(this);
  var partArgs = arraySlice.call(arguments, 1);

  var bound = function bound()
  /* args... */
  {
    var args = partArgs.concat(arraySlice.call(arguments));
    return this instanceof bound ? construct(fn, args.length, args) : invoke(fn, args, that);
  };

  if (isObject(fn.prototype)) bound.prototype = fn.prototype;
  return bound;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_classof.js":
/***/ (function(module, exports, __webpack_require__) {

// getting tag from 19.1.3.6 Object.prototype.toString()
var cof = __webpack_require__("./node_modules/core-js/modules/_cof.js");

var TAG = __webpack_require__("./node_modules/core-js/modules/_wks.js")('toStringTag'); // ES3 wrong here


var ARG = cof(function () {
  return arguments;
}()) == 'Arguments'; // fallback for IE11 Script Access Denied error

var tryGet = function tryGet(it, key) {
  try {
    return it[key];
  } catch (e) {
    /* empty */
  }
};

module.exports = function (it) {
  var O, T, B;
  return it === undefined ? 'Undefined' : it === null ? 'Null' // @@toStringTag case
  : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T // builtinTag case
  : ARG ? cof(O) // ES3 arguments fallback
  : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_cof.js":
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = function (it) {
  return toString.call(it).slice(8, -1);
};

/***/ }),

/***/ "./node_modules/core-js/modules/_collection-strong.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var dP = __webpack_require__("./node_modules/core-js/modules/_object-dp.js").f;

var create = __webpack_require__("./node_modules/core-js/modules/_object-create.js");

var redefineAll = __webpack_require__("./node_modules/core-js/modules/_redefine-all.js");

var ctx = __webpack_require__("./node_modules/core-js/modules/_ctx.js");

var anInstance = __webpack_require__("./node_modules/core-js/modules/_an-instance.js");

var forOf = __webpack_require__("./node_modules/core-js/modules/_for-of.js");

var $iterDefine = __webpack_require__("./node_modules/core-js/modules/_iter-define.js");

var step = __webpack_require__("./node_modules/core-js/modules/_iter-step.js");

var setSpecies = __webpack_require__("./node_modules/core-js/modules/_set-species.js");

var DESCRIPTORS = __webpack_require__("./node_modules/core-js/modules/_descriptors.js");

var fastKey = __webpack_require__("./node_modules/core-js/modules/_meta.js").fastKey;

var validate = __webpack_require__("./node_modules/core-js/modules/_validate-collection.js");

var SIZE = DESCRIPTORS ? '_s' : 'size';

var getEntry = function getEntry(that, key) {
  // fast case
  var index = fastKey(key);
  var entry;
  if (index !== 'F') return that._i[index]; // frozen object case

  for (entry = that._f; entry; entry = entry.n) {
    if (entry.k == key) return entry;
  }
};

module.exports = {
  getConstructor: function getConstructor(wrapper, NAME, IS_MAP, ADDER) {
    var C = wrapper(function (that, iterable) {
      anInstance(that, C, NAME, '_i');
      that._t = NAME; // collection type

      that._i = create(null); // index

      that._f = undefined; // first entry

      that._l = undefined; // last entry

      that[SIZE] = 0; // size

      if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
    });
    redefineAll(C.prototype, {
      // 23.1.3.1 Map.prototype.clear()
      // 23.2.3.2 Set.prototype.clear()
      clear: function clear() {
        for (var that = validate(this, NAME), data = that._i, entry = that._f; entry; entry = entry.n) {
          entry.r = true;
          if (entry.p) entry.p = entry.p.n = undefined;
          delete data[entry.i];
        }

        that._f = that._l = undefined;
        that[SIZE] = 0;
      },
      // 23.1.3.3 Map.prototype.delete(key)
      // 23.2.3.4 Set.prototype.delete(value)
      'delete': function _delete(key) {
        var that = validate(this, NAME);
        var entry = getEntry(that, key);

        if (entry) {
          var next = entry.n;
          var prev = entry.p;
          delete that._i[entry.i];
          entry.r = true;
          if (prev) prev.n = next;
          if (next) next.p = prev;
          if (that._f == entry) that._f = next;
          if (that._l == entry) that._l = prev;
          that[SIZE]--;
        }

        return !!entry;
      },
      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
      forEach: function forEach(callbackfn
      /* , that = undefined */
      ) {
        validate(this, NAME);
        var f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);
        var entry;

        while (entry = entry ? entry.n : this._f) {
          f(entry.v, entry.k, this); // revert to the last existing entry

          while (entry && entry.r) {
            entry = entry.p;
          }
        }
      },
      // 23.1.3.7 Map.prototype.has(key)
      // 23.2.3.7 Set.prototype.has(value)
      has: function has(key) {
        return !!getEntry(validate(this, NAME), key);
      }
    });
    if (DESCRIPTORS) dP(C.prototype, 'size', {
      get: function get() {
        return validate(this, NAME)[SIZE];
      }
    });
    return C;
  },
  def: function def(that, key, value) {
    var entry = getEntry(that, key);
    var prev, index; // change existing entry

    if (entry) {
      entry.v = value; // create new entry
    } else {
      that._l = entry = {
        i: index = fastKey(key, true),
        // <- index
        k: key,
        // <- key
        v: value,
        // <- value
        p: prev = that._l,
        // <- previous entry
        n: undefined,
        // <- next entry
        r: false // <- removed

      };
      if (!that._f) that._f = entry;
      if (prev) prev.n = entry;
      that[SIZE]++; // add to index

      if (index !== 'F') that._i[index] = entry;
    }

    return that;
  },
  getEntry: getEntry,
  setStrong: function setStrong(C, NAME, IS_MAP) {
    // add .keys, .values, .entries, [@@iterator]
    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
    $iterDefine(C, NAME, function (iterated, kind) {
      this._t = validate(iterated, NAME); // target

      this._k = kind; // kind

      this._l = undefined; // previous
    }, function () {
      var that = this;
      var kind = that._k;
      var entry = that._l; // revert to the last existing entry

      while (entry && entry.r) {
        entry = entry.p;
      } // get next entry


      if (!that._t || !(that._l = entry = entry ? entry.n : that._t._f)) {
        // or finish the iteration
        that._t = undefined;
        return step(1);
      } // return step by kind


      if (kind == 'keys') return step(0, entry.k);
      if (kind == 'values') return step(0, entry.v);
      return step(0, [entry.k, entry.v]);
    }, IS_MAP ? 'entries' : 'values', !IS_MAP, true); // add [@@species], 23.1.2.2, 23.2.2.2

    setSpecies(NAME);
  }
};

/***/ }),

/***/ "./node_modules/core-js/modules/_collection-to-json.js":
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var classof = __webpack_require__("./node_modules/core-js/modules/_classof.js");

var from = __webpack_require__("./node_modules/core-js/modules/_array-from-iterable.js");

module.exports = function (NAME) {
  return function toJSON() {
    if (classof(this) != NAME) throw TypeError(NAME + "#toJSON isn't generic");
    return from(this);
  };
};

/***/ }),

/***/ "./node_modules/core-js/modules/_collection-weak.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var redefineAll = __webpack_require__("./node_modules/core-js/modules/_redefine-all.js");

var getWeak = __webpack_require__("./node_modules/core-js/modules/_meta.js").getWeak;

var anObject = __webpack_require__("./node_modules/core-js/modules/_an-object.js");

var isObject = __webpack_require__("./node_modules/core-js/modules/_is-object.js");

var anInstance = __webpack_require__("./node_modules/core-js/modules/_an-instance.js");

var forOf = __webpack_require__("./node_modules/core-js/modules/_for-of.js");

var createArrayMethod = __webpack_require__("./node_modules/core-js/modules/_array-methods.js");

var $has = __webpack_require__("./node_modules/core-js/modules/_has.js");

var validate = __webpack_require__("./node_modules/core-js/modules/_validate-collection.js");

var arrayFind = createArrayMethod(5);
var arrayFindIndex = createArrayMethod(6);
var id = 0; // fallback for uncaught frozen keys

var uncaughtFrozenStore = function uncaughtFrozenStore(that) {
  return that._l || (that._l = new UncaughtFrozenStore());
};

var UncaughtFrozenStore = function UncaughtFrozenStore() {
  this.a = [];
};

var findUncaughtFrozen = function findUncaughtFrozen(store, key) {
  return arrayFind(store.a, function (it) {
    return it[0] === key;
  });
};

UncaughtFrozenStore.prototype = {
  get: function get(key) {
    var entry = findUncaughtFrozen(this, key);
    if (entry) return entry[1];
  },
  has: function has(key) {
    return !!findUncaughtFrozen(this, key);
  },
  set: function set(key, value) {
    var entry = findUncaughtFrozen(this, key);
    if (entry) entry[1] = value;else this.a.push([key, value]);
  },
  'delete': function _delete(key) {
    var index = arrayFindIndex(this.a, function (it) {
      return it[0] === key;
    });
    if (~index) this.a.splice(index, 1);
    return !!~index;
  }
};
module.exports = {
  getConstructor: function getConstructor(wrapper, NAME, IS_MAP, ADDER) {
    var C = wrapper(function (that, iterable) {
      anInstance(that, C, NAME, '_i');
      that._t = NAME; // collection type

      that._i = id++; // collection id

      that._l = undefined; // leak store for uncaught frozen objects

      if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
    });
    redefineAll(C.prototype, {
      // 23.3.3.2 WeakMap.prototype.delete(key)
      // 23.4.3.3 WeakSet.prototype.delete(value)
      'delete': function _delete(key) {
        if (!isObject(key)) return false;
        var data = getWeak(key);
        if (data === true) return uncaughtFrozenStore(validate(this, NAME))['delete'](key);
        return data && $has(data, this._i) && delete data[this._i];
      },
      // 23.3.3.4 WeakMap.prototype.has(key)
      // 23.4.3.4 WeakSet.prototype.has(value)
      has: function has(key) {
        if (!isObject(key)) return false;
        var data = getWeak(key);
        if (data === true) return uncaughtFrozenStore(validate(this, NAME)).has(key);
        return data && $has(data, this._i);
      }
    });
    return C;
  },
  def: function def(that, key, value) {
    var data = getWeak(anObject(key), true);
    if (data === true) uncaughtFrozenStore(that).set(key, value);else data[that._i] = value;
    return that;
  },
  ufstore: uncaughtFrozenStore
};

/***/ }),

/***/ "./node_modules/core-js/modules/_collection.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var global = __webpack_require__("./node_modules/core-js/modules/_global.js");

var $export = __webpack_require__("./node_modules/core-js/modules/_export.js");

var redefine = __webpack_require__("./node_modules/core-js/modules/_redefine.js");

var redefineAll = __webpack_require__("./node_modules/core-js/modules/_redefine-all.js");

var meta = __webpack_require__("./node_modules/core-js/modules/_meta.js");

var forOf = __webpack_require__("./node_modules/core-js/modules/_for-of.js");

var anInstance = __webpack_require__("./node_modules/core-js/modules/_an-instance.js");

var isObject = __webpack_require__("./node_modules/core-js/modules/_is-object.js");

var fails = __webpack_require__("./node_modules/core-js/modules/_fails.js");

var $iterDetect = __webpack_require__("./node_modules/core-js/modules/_iter-detect.js");

var setToStringTag = __webpack_require__("./node_modules/core-js/modules/_set-to-string-tag.js");

var inheritIfRequired = __webpack_require__("./node_modules/core-js/modules/_inherit-if-required.js");

module.exports = function (NAME, wrapper, methods, common, IS_MAP, IS_WEAK) {
  var Base = global[NAME];
  var C = Base;
  var ADDER = IS_MAP ? 'set' : 'add';
  var proto = C && C.prototype;
  var O = {};

  var fixMethod = function fixMethod(KEY) {
    var fn = proto[KEY];
    redefine(proto, KEY, KEY == 'delete' ? function (a) {
      return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
    } : KEY == 'has' ? function has(a) {
      return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
    } : KEY == 'get' ? function get(a) {
      return IS_WEAK && !isObject(a) ? undefined : fn.call(this, a === 0 ? 0 : a);
    } : KEY == 'add' ? function add(a) {
      fn.call(this, a === 0 ? 0 : a);
      return this;
    } : function set(a, b) {
      fn.call(this, a === 0 ? 0 : a, b);
      return this;
    });
  };

  if (typeof C != 'function' || !(IS_WEAK || proto.forEach && !fails(function () {
    new C().entries().next();
  }))) {
    // create collection constructor
    C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
    redefineAll(C.prototype, methods);
    meta.NEED = true;
  } else {
    var instance = new C(); // early implementations not supports chaining

    var HASNT_CHAINING = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance; // V8 ~  Chromium 40- weak-collections throws on primitives, but should return false

    var THROWS_ON_PRIMITIVES = fails(function () {
      instance.has(1);
    }); // most early implementations doesn't supports iterables, most modern - not close it correctly

    var ACCEPT_ITERABLES = $iterDetect(function (iter) {
      new C(iter);
    }); // eslint-disable-line no-new
    // for early implementations -0 and +0 not the same

    var BUGGY_ZERO = !IS_WEAK && fails(function () {
      // V8 ~ Chromium 42- fails only with 5+ elements
      var $instance = new C();
      var index = 5;

      while (index--) {
        $instance[ADDER](index, index);
      }

      return !$instance.has(-0);
    });

    if (!ACCEPT_ITERABLES) {
      C = wrapper(function (target, iterable) {
        anInstance(target, C, NAME);
        var that = inheritIfRequired(new Base(), target, C);
        if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
        return that;
      });
      C.prototype = proto;
      proto.constructor = C;
    }

    if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {
      fixMethod('delete');
      fixMethod('has');
      IS_MAP && fixMethod('get');
    }

    if (BUGGY_ZERO || HASNT_CHAINING) fixMethod(ADDER); // weak collections should not contains .clear method

    if (IS_WEAK && proto.clear) delete proto.clear;
  }

  setToStringTag(C, NAME);
  O[NAME] = C;
  $export($export.G + $export.W + $export.F * (C != Base), O);
  if (!IS_WEAK) common.setStrong(C, NAME, IS_MAP);
  return C;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_core.js":
/***/ (function(module, exports) {

var core = module.exports = {
  version: '2.5.1'
};
if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef

/***/ }),

/***/ "./node_modules/core-js/modules/_create-property.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $defineProperty = __webpack_require__("./node_modules/core-js/modules/_object-dp.js");

var createDesc = __webpack_require__("./node_modules/core-js/modules/_property-desc.js");

module.exports = function (object, index, value) {
  if (index in object) $defineProperty.f(object, index, createDesc(0, value));else object[index] = value;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_ctx.js":
/***/ (function(module, exports, __webpack_require__) {

// optional / simple context binding
var aFunction = __webpack_require__("./node_modules/core-js/modules/_a-function.js");

module.exports = function (fn, that, length) {
  aFunction(fn);
  if (that === undefined) return fn;

  switch (length) {
    case 1:
      return function (a) {
        return fn.call(that, a);
      };

    case 2:
      return function (a, b) {
        return fn.call(that, a, b);
      };

    case 3:
      return function (a, b, c) {
        return fn.call(that, a, b, c);
      };
  }

  return function ()
  /* ...args */
  {
    return fn.apply(that, arguments);
  };
};

/***/ }),

/***/ "./node_modules/core-js/modules/_date-to-iso-string.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // 20.3.4.36 / 15.9.5.43 Date.prototype.toISOString()

var fails = __webpack_require__("./node_modules/core-js/modules/_fails.js");

var getTime = Date.prototype.getTime;
var $toISOString = Date.prototype.toISOString;

var lz = function lz(num) {
  return num > 9 ? num : '0' + num;
}; // PhantomJS / old WebKit has a broken implementations


module.exports = fails(function () {
  return $toISOString.call(new Date(-5e13 - 1)) != '0385-07-25T07:06:39.999Z';
}) || !fails(function () {
  $toISOString.call(new Date(NaN));
}) ? function toISOString() {
  if (!isFinite(getTime.call(this))) throw RangeError('Invalid time value');
  var d = this;
  var y = d.getUTCFullYear();
  var m = d.getUTCMilliseconds();
  var s = y < 0 ? '-' : y > 9999 ? '+' : '';
  return s + ('00000' + Math.abs(y)).slice(s ? -6 : -4) + '-' + lz(d.getUTCMonth() + 1) + '-' + lz(d.getUTCDate()) + 'T' + lz(d.getUTCHours()) + ':' + lz(d.getUTCMinutes()) + ':' + lz(d.getUTCSeconds()) + '.' + (m > 99 ? m : '0' + lz(m)) + 'Z';
} : $toISOString;

/***/ }),

/***/ "./node_modules/core-js/modules/_date-to-primitive.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var anObject = __webpack_require__("./node_modules/core-js/modules/_an-object.js");

var toPrimitive = __webpack_require__("./node_modules/core-js/modules/_to-primitive.js");

var NUMBER = 'number';

module.exports = function (hint) {
  if (hint !== 'string' && hint !== NUMBER && hint !== 'default') throw TypeError('Incorrect hint');
  return toPrimitive(anObject(this), hint != NUMBER);
};

/***/ }),

/***/ "./node_modules/core-js/modules/_defined.js":
/***/ (function(module, exports) {

// 7.2.1 RequireObjectCoercible(argument)
module.exports = function (it) {
  if (it == undefined) throw TypeError("Can't call method on  " + it);
  return it;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_descriptors.js":
/***/ (function(module, exports, __webpack_require__) {

// Thank's IE8 for his funny defineProperty
module.exports = !__webpack_require__("./node_modules/core-js/modules/_fails.js")(function () {
  return Object.defineProperty({}, 'a', {
    get: function get() {
      return 7;
    }
  }).a != 7;
});

/***/ }),

/***/ "./node_modules/core-js/modules/_dom-create.js":
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__("./node_modules/core-js/modules/_is-object.js");

var document = __webpack_require__("./node_modules/core-js/modules/_global.js").document; // typeof document.createElement is 'object' in old IE


var is = isObject(document) && isObject(document.createElement);

module.exports = function (it) {
  return is ? document.createElement(it) : {};
};

/***/ }),

/***/ "./node_modules/core-js/modules/_enum-bug-keys.js":
/***/ (function(module, exports) {

// IE 8- don't enum bug keys
module.exports = 'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'.split(',');

/***/ }),

/***/ "./node_modules/core-js/modules/_enum-keys.js":
/***/ (function(module, exports, __webpack_require__) {

// all enumerable object keys, includes symbols
var getKeys = __webpack_require__("./node_modules/core-js/modules/_object-keys.js");

var gOPS = __webpack_require__("./node_modules/core-js/modules/_object-gops.js");

var pIE = __webpack_require__("./node_modules/core-js/modules/_object-pie.js");

module.exports = function (it) {
  var result = getKeys(it);
  var getSymbols = gOPS.f;

  if (getSymbols) {
    var symbols = getSymbols(it);
    var isEnum = pIE.f;
    var i = 0;
    var key;

    while (symbols.length > i) {
      if (isEnum.call(it, key = symbols[i++])) result.push(key);
    }
  }

  return result;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_export.js":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("./node_modules/core-js/modules/_global.js");

var core = __webpack_require__("./node_modules/core-js/modules/_core.js");

var hide = __webpack_require__("./node_modules/core-js/modules/_hide.js");

var redefine = __webpack_require__("./node_modules/core-js/modules/_redefine.js");

var ctx = __webpack_require__("./node_modules/core-js/modules/_ctx.js");

var PROTOTYPE = 'prototype';

var $export = function $export(type, name, source) {
  var IS_FORCED = type & $export.F;
  var IS_GLOBAL = type & $export.G;
  var IS_STATIC = type & $export.S;
  var IS_PROTO = type & $export.P;
  var IS_BIND = type & $export.B;
  var target = IS_GLOBAL ? global : IS_STATIC ? global[name] || (global[name] = {}) : (global[name] || {})[PROTOTYPE];
  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});
  var expProto = exports[PROTOTYPE] || (exports[PROTOTYPE] = {});
  var key, own, out, exp;
  if (IS_GLOBAL) source = name;

  for (key in source) {
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined; // export native or passed

    out = (own ? target : source)[key]; // bind timers to global for call from export context

    exp = IS_BIND && own ? ctx(out, global) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out; // extend global

    if (target) redefine(target, key, out, type & $export.U); // export

    if (exports[key] != out) hide(exports, key, exp);
    if (IS_PROTO && expProto[key] != out) expProto[key] = out;
  }
};

global.core = core; // type bitmap

$export.F = 1; // forced

$export.G = 2; // global

$export.S = 4; // static

$export.P = 8; // proto

$export.B = 16; // bind

$export.W = 32; // wrap

$export.U = 64; // safe

$export.R = 128; // real proto method for `library`

module.exports = $export;

/***/ }),

/***/ "./node_modules/core-js/modules/_fails-is-regexp.js":
/***/ (function(module, exports, __webpack_require__) {

var MATCH = __webpack_require__("./node_modules/core-js/modules/_wks.js")('match');

module.exports = function (KEY) {
  var re = /./;

  try {
    '/./'[KEY](re);
  } catch (e) {
    try {
      re[MATCH] = false;
      return !'/./'[KEY](re);
    } catch (f) {
      /* empty */
    }
  }

  return true;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_fails.js":
/***/ (function(module, exports) {

module.exports = function (exec) {
  try {
    return !!exec();
  } catch (e) {
    return true;
  }
};

/***/ }),

/***/ "./node_modules/core-js/modules/_fix-re-wks.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var hide = __webpack_require__("./node_modules/core-js/modules/_hide.js");

var redefine = __webpack_require__("./node_modules/core-js/modules/_redefine.js");

var fails = __webpack_require__("./node_modules/core-js/modules/_fails.js");

var defined = __webpack_require__("./node_modules/core-js/modules/_defined.js");

var wks = __webpack_require__("./node_modules/core-js/modules/_wks.js");

module.exports = function (KEY, length, exec) {
  var SYMBOL = wks(KEY);
  var fns = exec(defined, SYMBOL, ''[KEY]);
  var strfn = fns[0];
  var rxfn = fns[1];

  if (fails(function () {
    var O = {};

    O[SYMBOL] = function () {
      return 7;
    };

    return ''[KEY](O) != 7;
  })) {
    redefine(String.prototype, KEY, strfn);
    hide(RegExp.prototype, SYMBOL, length == 2 // 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue)
    // 21.2.5.11 RegExp.prototype[@@split](string, limit)
    ? function (string, arg) {
      return rxfn.call(string, this, arg);
    } // 21.2.5.6 RegExp.prototype[@@match](string)
    // 21.2.5.9 RegExp.prototype[@@search](string)
    : function (string) {
      return rxfn.call(string, this);
    });
  }
};

/***/ }),

/***/ "./node_modules/core-js/modules/_flags.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // 21.2.5.3 get RegExp.prototype.flags

var anObject = __webpack_require__("./node_modules/core-js/modules/_an-object.js");

module.exports = function () {
  var that = anObject(this);
  var result = '';
  if (that.global) result += 'g';
  if (that.ignoreCase) result += 'i';
  if (that.multiline) result += 'm';
  if (that.unicode) result += 'u';
  if (that.sticky) result += 'y';
  return result;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_flatten-into-array.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // https://tc39.github.io/proposal-flatMap/#sec-FlattenIntoArray

var isArray = __webpack_require__("./node_modules/core-js/modules/_is-array.js");

var isObject = __webpack_require__("./node_modules/core-js/modules/_is-object.js");

var toLength = __webpack_require__("./node_modules/core-js/modules/_to-length.js");

var ctx = __webpack_require__("./node_modules/core-js/modules/_ctx.js");

var IS_CONCAT_SPREADABLE = __webpack_require__("./node_modules/core-js/modules/_wks.js")('isConcatSpreadable');

function flattenIntoArray(target, original, source, sourceLen, start, depth, mapper, thisArg) {
  var targetIndex = start;
  var sourceIndex = 0;
  var mapFn = mapper ? ctx(mapper, thisArg, 3) : false;
  var element, spreadable;

  while (sourceIndex < sourceLen) {
    if (sourceIndex in source) {
      element = mapFn ? mapFn(source[sourceIndex], sourceIndex, original) : source[sourceIndex];
      spreadable = false;

      if (isObject(element)) {
        spreadable = element[IS_CONCAT_SPREADABLE];
        spreadable = spreadable !== undefined ? !!spreadable : isArray(element);
      }

      if (spreadable && depth > 0) {
        targetIndex = flattenIntoArray(target, original, element, toLength(element.length), targetIndex, depth - 1) - 1;
      } else {
        if (targetIndex >= 0x1fffffffffffff) throw TypeError();
        target[targetIndex] = element;
      }

      targetIndex++;
    }

    sourceIndex++;
  }

  return targetIndex;
}

module.exports = flattenIntoArray;

/***/ }),

/***/ "./node_modules/core-js/modules/_for-of.js":
/***/ (function(module, exports, __webpack_require__) {

var ctx = __webpack_require__("./node_modules/core-js/modules/_ctx.js");

var call = __webpack_require__("./node_modules/core-js/modules/_iter-call.js");

var isArrayIter = __webpack_require__("./node_modules/core-js/modules/_is-array-iter.js");

var anObject = __webpack_require__("./node_modules/core-js/modules/_an-object.js");

var toLength = __webpack_require__("./node_modules/core-js/modules/_to-length.js");

var getIterFn = __webpack_require__("./node_modules/core-js/modules/core.get-iterator-method.js");

var BREAK = {};
var RETURN = {};

var exports = module.exports = function (iterable, entries, fn, that, ITERATOR) {
  var iterFn = ITERATOR ? function () {
    return iterable;
  } : getIterFn(iterable);
  var f = ctx(fn, that, entries ? 2 : 1);
  var index = 0;
  var length, step, iterator, result;
  if (typeof iterFn != 'function') throw TypeError(iterable + ' is not iterable!'); // fast case for arrays with default iterator

  if (isArrayIter(iterFn)) for (length = toLength(iterable.length); length > index; index++) {
    result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
    if (result === BREAK || result === RETURN) return result;
  } else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {
    result = call(iterator, f, step.value, entries);
    if (result === BREAK || result === RETURN) return result;
  }
};

exports.BREAK = BREAK;
exports.RETURN = RETURN;

/***/ }),

/***/ "./node_modules/core-js/modules/_global.js":
/***/ (function(module, exports) {

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math ? window : typeof self != 'undefined' && self.Math == Math ? self // eslint-disable-next-line no-new-func
: Function('return this')();
if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef

/***/ }),

/***/ "./node_modules/core-js/modules/_has.js":
/***/ (function(module, exports) {

var hasOwnProperty = {}.hasOwnProperty;

module.exports = function (it, key) {
  return hasOwnProperty.call(it, key);
};

/***/ }),

/***/ "./node_modules/core-js/modules/_hide.js":
/***/ (function(module, exports, __webpack_require__) {

var dP = __webpack_require__("./node_modules/core-js/modules/_object-dp.js");

var createDesc = __webpack_require__("./node_modules/core-js/modules/_property-desc.js");

module.exports = __webpack_require__("./node_modules/core-js/modules/_descriptors.js") ? function (object, key, value) {
  return dP.f(object, key, createDesc(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_html.js":
/***/ (function(module, exports, __webpack_require__) {

var document = __webpack_require__("./node_modules/core-js/modules/_global.js").document;

module.exports = document && document.documentElement;

/***/ }),

/***/ "./node_modules/core-js/modules/_ie8-dom-define.js":
/***/ (function(module, exports, __webpack_require__) {

module.exports = !__webpack_require__("./node_modules/core-js/modules/_descriptors.js") && !__webpack_require__("./node_modules/core-js/modules/_fails.js")(function () {
  return Object.defineProperty(__webpack_require__("./node_modules/core-js/modules/_dom-create.js")('div'), 'a', {
    get: function get() {
      return 7;
    }
  }).a != 7;
});

/***/ }),

/***/ "./node_modules/core-js/modules/_inherit-if-required.js":
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__("./node_modules/core-js/modules/_is-object.js");

var setPrototypeOf = __webpack_require__("./node_modules/core-js/modules/_set-proto.js").set;

module.exports = function (that, target, C) {
  var S = target.constructor;
  var P;

  if (S !== C && typeof S == 'function' && (P = S.prototype) !== C.prototype && isObject(P) && setPrototypeOf) {
    setPrototypeOf(that, P);
  }

  return that;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_invoke.js":
/***/ (function(module, exports) {

// fast apply, http://jsperf.lnkit.com/fast-apply/5
module.exports = function (fn, args, that) {
  var un = that === undefined;

  switch (args.length) {
    case 0:
      return un ? fn() : fn.call(that);

    case 1:
      return un ? fn(args[0]) : fn.call(that, args[0]);

    case 2:
      return un ? fn(args[0], args[1]) : fn.call(that, args[0], args[1]);

    case 3:
      return un ? fn(args[0], args[1], args[2]) : fn.call(that, args[0], args[1], args[2]);

    case 4:
      return un ? fn(args[0], args[1], args[2], args[3]) : fn.call(that, args[0], args[1], args[2], args[3]);
  }

  return fn.apply(that, args);
};

/***/ }),

/***/ "./node_modules/core-js/modules/_iobject.js":
/***/ (function(module, exports, __webpack_require__) {

// fallback for non-array-like ES3 and non-enumerable old V8 strings
var cof = __webpack_require__("./node_modules/core-js/modules/_cof.js"); // eslint-disable-next-line no-prototype-builtins


module.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
  return cof(it) == 'String' ? it.split('') : Object(it);
};

/***/ }),

/***/ "./node_modules/core-js/modules/_is-array-iter.js":
/***/ (function(module, exports, __webpack_require__) {

// check on default Array iterator
var Iterators = __webpack_require__("./node_modules/core-js/modules/_iterators.js");

var ITERATOR = __webpack_require__("./node_modules/core-js/modules/_wks.js")('iterator');

var ArrayProto = Array.prototype;

module.exports = function (it) {
  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
};

/***/ }),

/***/ "./node_modules/core-js/modules/_is-array.js":
/***/ (function(module, exports, __webpack_require__) {

// 7.2.2 IsArray(argument)
var cof = __webpack_require__("./node_modules/core-js/modules/_cof.js");

module.exports = Array.isArray || function isArray(arg) {
  return cof(arg) == 'Array';
};

/***/ }),

/***/ "./node_modules/core-js/modules/_is-integer.js":
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.3 Number.isInteger(number)
var isObject = __webpack_require__("./node_modules/core-js/modules/_is-object.js");

var floor = Math.floor;

module.exports = function isInteger(it) {
  return !isObject(it) && isFinite(it) && floor(it) === it;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_is-object.js":
/***/ (function(module, exports) {

module.exports = function (it) {
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};

/***/ }),

/***/ "./node_modules/core-js/modules/_is-regexp.js":
/***/ (function(module, exports, __webpack_require__) {

// 7.2.8 IsRegExp(argument)
var isObject = __webpack_require__("./node_modules/core-js/modules/_is-object.js");

var cof = __webpack_require__("./node_modules/core-js/modules/_cof.js");

var MATCH = __webpack_require__("./node_modules/core-js/modules/_wks.js")('match');

module.exports = function (it) {
  var isRegExp;
  return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : cof(it) == 'RegExp');
};

/***/ }),

/***/ "./node_modules/core-js/modules/_iter-call.js":
/***/ (function(module, exports, __webpack_require__) {

// call something on iterator step with safe closing on error
var anObject = __webpack_require__("./node_modules/core-js/modules/_an-object.js");

module.exports = function (iterator, fn, value, entries) {
  try {
    return entries ? fn(anObject(value)[0], value[1]) : fn(value); // 7.4.6 IteratorClose(iterator, completion)
  } catch (e) {
    var ret = iterator['return'];
    if (ret !== undefined) anObject(ret.call(iterator));
    throw e;
  }
};

/***/ }),

/***/ "./node_modules/core-js/modules/_iter-create.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var create = __webpack_require__("./node_modules/core-js/modules/_object-create.js");

var descriptor = __webpack_require__("./node_modules/core-js/modules/_property-desc.js");

var setToStringTag = __webpack_require__("./node_modules/core-js/modules/_set-to-string-tag.js");

var IteratorPrototype = {}; // 25.1.2.1.1 %IteratorPrototype%[@@iterator]()

__webpack_require__("./node_modules/core-js/modules/_hide.js")(IteratorPrototype, __webpack_require__("./node_modules/core-js/modules/_wks.js")('iterator'), function () {
  return this;
});

module.exports = function (Constructor, NAME, next) {
  Constructor.prototype = create(IteratorPrototype, {
    next: descriptor(1, next)
  });
  setToStringTag(Constructor, NAME + ' Iterator');
};

/***/ }),

/***/ "./node_modules/core-js/modules/_iter-define.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var LIBRARY = __webpack_require__("./node_modules/core-js/modules/_library.js");

var $export = __webpack_require__("./node_modules/core-js/modules/_export.js");

var redefine = __webpack_require__("./node_modules/core-js/modules/_redefine.js");

var hide = __webpack_require__("./node_modules/core-js/modules/_hide.js");

var has = __webpack_require__("./node_modules/core-js/modules/_has.js");

var Iterators = __webpack_require__("./node_modules/core-js/modules/_iterators.js");

var $iterCreate = __webpack_require__("./node_modules/core-js/modules/_iter-create.js");

var setToStringTag = __webpack_require__("./node_modules/core-js/modules/_set-to-string-tag.js");

var getPrototypeOf = __webpack_require__("./node_modules/core-js/modules/_object-gpo.js");

var ITERATOR = __webpack_require__("./node_modules/core-js/modules/_wks.js")('iterator');

var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`

var FF_ITERATOR = '@@iterator';
var KEYS = 'keys';
var VALUES = 'values';

var returnThis = function returnThis() {
  return this;
};

module.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
  $iterCreate(Constructor, NAME, next);

  var getMethod = function getMethod(kind) {
    if (!BUGGY && kind in proto) return proto[kind];

    switch (kind) {
      case KEYS:
        return function keys() {
          return new Constructor(this, kind);
        };

      case VALUES:
        return function values() {
          return new Constructor(this, kind);
        };
    }

    return function entries() {
      return new Constructor(this, kind);
    };
  };

  var TAG = NAME + ' Iterator';
  var DEF_VALUES = DEFAULT == VALUES;
  var VALUES_BUG = false;
  var proto = Base.prototype;
  var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
  var $default = $native || getMethod(DEFAULT);
  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
  var methods, key, IteratorPrototype; // Fix native

  if ($anyNative) {
    IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));

    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
      // Set @@toStringTag to native iterators
      setToStringTag(IteratorPrototype, TAG, true); // fix for some old engines

      if (!LIBRARY && !has(IteratorPrototype, ITERATOR)) hide(IteratorPrototype, ITERATOR, returnThis);
    }
  } // fix Array#{values, @@iterator}.name in V8 / FF


  if (DEF_VALUES && $native && $native.name !== VALUES) {
    VALUES_BUG = true;

    $default = function values() {
      return $native.call(this);
    };
  } // Define iterator


  if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
    hide(proto, ITERATOR, $default);
  } // Plug for library


  Iterators[NAME] = $default;
  Iterators[TAG] = returnThis;

  if (DEFAULT) {
    methods = {
      values: DEF_VALUES ? $default : getMethod(VALUES),
      keys: IS_SET ? $default : getMethod(KEYS),
      entries: $entries
    };
    if (FORCED) for (key in methods) {
      if (!(key in proto)) redefine(proto, key, methods[key]);
    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
  }

  return methods;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_iter-detect.js":
/***/ (function(module, exports, __webpack_require__) {

var ITERATOR = __webpack_require__("./node_modules/core-js/modules/_wks.js")('iterator');

var SAFE_CLOSING = false;

try {
  var riter = [7][ITERATOR]();

  riter['return'] = function () {
    SAFE_CLOSING = true;
  }; // eslint-disable-next-line no-throw-literal


  Array.from(riter, function () {
    throw 2;
  });
} catch (e) {
  /* empty */
}

module.exports = function (exec, skipClosing) {
  if (!skipClosing && !SAFE_CLOSING) return false;
  var safe = false;

  try {
    var arr = [7];
    var iter = arr[ITERATOR]();

    iter.next = function () {
      return {
        done: safe = true
      };
    };

    arr[ITERATOR] = function () {
      return iter;
    };

    exec(arr);
  } catch (e) {
    /* empty */
  }

  return safe;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_iter-step.js":
/***/ (function(module, exports) {

module.exports = function (done, value) {
  return {
    value: value,
    done: !!done
  };
};

/***/ }),

/***/ "./node_modules/core-js/modules/_iterators.js":
/***/ (function(module, exports) {

module.exports = {};

/***/ }),

/***/ "./node_modules/core-js/modules/_library.js":
/***/ (function(module, exports) {

module.exports = false;

/***/ }),

/***/ "./node_modules/core-js/modules/_math-expm1.js":
/***/ (function(module, exports) {

// 20.2.2.14 Math.expm1(x)
var $expm1 = Math.expm1;
module.exports = !$expm1 // Old FF bug
|| $expm1(10) > 22025.465794806719 || $expm1(10) < 22025.4657948067165168 // Tor Browser bug
|| $expm1(-2e-17) != -2e-17 ? function expm1(x) {
  return (x = +x) == 0 ? x : x > -1e-6 && x < 1e-6 ? x + x * x / 2 : Math.exp(x) - 1;
} : $expm1;

/***/ }),

/***/ "./node_modules/core-js/modules/_math-fround.js":
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.16 Math.fround(x)
var sign = __webpack_require__("./node_modules/core-js/modules/_math-sign.js");

var pow = Math.pow;
var EPSILON = pow(2, -52);
var EPSILON32 = pow(2, -23);
var MAX32 = pow(2, 127) * (2 - EPSILON32);
var MIN32 = pow(2, -126);

var roundTiesToEven = function roundTiesToEven(n) {
  return n + 1 / EPSILON - 1 / EPSILON;
};

module.exports = Math.fround || function fround(x) {
  var $abs = Math.abs(x);
  var $sign = sign(x);
  var a, result;
  if ($abs < MIN32) return $sign * roundTiesToEven($abs / MIN32 / EPSILON32) * MIN32 * EPSILON32;
  a = (1 + EPSILON32 / EPSILON) * $abs;
  result = a - (a - $abs); // eslint-disable-next-line no-self-compare

  if (result > MAX32 || result != result) return $sign * Infinity;
  return $sign * result;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_math-log1p.js":
/***/ (function(module, exports) {

// 20.2.2.20 Math.log1p(x)
module.exports = Math.log1p || function log1p(x) {
  return (x = +x) > -1e-8 && x < 1e-8 ? x - x * x / 2 : Math.log(1 + x);
};

/***/ }),

/***/ "./node_modules/core-js/modules/_math-scale.js":
/***/ (function(module, exports) {

// https://rwaldron.github.io/proposal-math-extensions/
module.exports = Math.scale || function scale(x, inLow, inHigh, outLow, outHigh) {
  if (arguments.length === 0 // eslint-disable-next-line no-self-compare
  || x != x // eslint-disable-next-line no-self-compare
  || inLow != inLow // eslint-disable-next-line no-self-compare
  || inHigh != inHigh // eslint-disable-next-line no-self-compare
  || outLow != outLow // eslint-disable-next-line no-self-compare
  || outHigh != outHigh) return NaN;
  if (x === Infinity || x === -Infinity) return x;
  return (x - inLow) * (outHigh - outLow) / (inHigh - inLow) + outLow;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_math-sign.js":
/***/ (function(module, exports) {

// 20.2.2.28 Math.sign(x)
module.exports = Math.sign || function sign(x) {
  // eslint-disable-next-line no-self-compare
  return (x = +x) == 0 || x != x ? x : x < 0 ? -1 : 1;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_meta.js":
/***/ (function(module, exports, __webpack_require__) {

var META = __webpack_require__("./node_modules/core-js/modules/_uid.js")('meta');

var isObject = __webpack_require__("./node_modules/core-js/modules/_is-object.js");

var has = __webpack_require__("./node_modules/core-js/modules/_has.js");

var setDesc = __webpack_require__("./node_modules/core-js/modules/_object-dp.js").f;

var id = 0;

var isExtensible = Object.isExtensible || function () {
  return true;
};

var FREEZE = !__webpack_require__("./node_modules/core-js/modules/_fails.js")(function () {
  return isExtensible(Object.preventExtensions({}));
});

var setMeta = function setMeta(it) {
  setDesc(it, META, {
    value: {
      i: 'O' + ++id,
      // object ID
      w: {} // weak collections IDs

    }
  });
};

var fastKey = function fastKey(it, create) {
  // return primitive with prefix
  if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;

  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return 'F'; // not necessary to add metadata

    if (!create) return 'E'; // add missing metadata

    setMeta(it); // return object ID
  }

  return it[META].i;
};

var getWeak = function getWeak(it, create) {
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return true; // not necessary to add metadata

    if (!create) return false; // add missing metadata

    setMeta(it); // return hash weak collections IDs
  }

  return it[META].w;
}; // add metadata on freeze-family methods calling


var onFreeze = function onFreeze(it) {
  if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META)) setMeta(it);
  return it;
};

var meta = module.exports = {
  KEY: META,
  NEED: false,
  fastKey: fastKey,
  getWeak: getWeak,
  onFreeze: onFreeze
};

/***/ }),

/***/ "./node_modules/core-js/modules/_metadata.js":
/***/ (function(module, exports, __webpack_require__) {

var Map = __webpack_require__("./node_modules/core-js/modules/es6.map.js");

var $export = __webpack_require__("./node_modules/core-js/modules/_export.js");

var shared = __webpack_require__("./node_modules/core-js/modules/_shared.js")('metadata');

var store = shared.store || (shared.store = new (__webpack_require__("./node_modules/core-js/modules/es6.weak-map.js"))());

var getOrCreateMetadataMap = function getOrCreateMetadataMap(target, targetKey, create) {
  var targetMetadata = store.get(target);

  if (!targetMetadata) {
    if (!create) return undefined;
    store.set(target, targetMetadata = new Map());
  }

  var keyMetadata = targetMetadata.get(targetKey);

  if (!keyMetadata) {
    if (!create) return undefined;
    targetMetadata.set(targetKey, keyMetadata = new Map());
  }

  return keyMetadata;
};

var ordinaryHasOwnMetadata = function ordinaryHasOwnMetadata(MetadataKey, O, P) {
  var metadataMap = getOrCreateMetadataMap(O, P, false);
  return metadataMap === undefined ? false : metadataMap.has(MetadataKey);
};

var ordinaryGetOwnMetadata = function ordinaryGetOwnMetadata(MetadataKey, O, P) {
  var metadataMap = getOrCreateMetadataMap(O, P, false);
  return metadataMap === undefined ? undefined : metadataMap.get(MetadataKey);
};

var ordinaryDefineOwnMetadata = function ordinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P) {
  getOrCreateMetadataMap(O, P, true).set(MetadataKey, MetadataValue);
};

var ordinaryOwnMetadataKeys = function ordinaryOwnMetadataKeys(target, targetKey) {
  var metadataMap = getOrCreateMetadataMap(target, targetKey, false);
  var keys = [];
  if (metadataMap) metadataMap.forEach(function (_, key) {
    keys.push(key);
  });
  return keys;
};

var toMetaKey = function toMetaKey(it) {
  return it === undefined || typeof it == 'symbol' ? it : String(it);
};

var exp = function exp(O) {
  $export($export.S, 'Reflect', O);
};

module.exports = {
  store: store,
  map: getOrCreateMetadataMap,
  has: ordinaryHasOwnMetadata,
  get: ordinaryGetOwnMetadata,
  set: ordinaryDefineOwnMetadata,
  keys: ordinaryOwnMetadataKeys,
  key: toMetaKey,
  exp: exp
};

/***/ }),

/***/ "./node_modules/core-js/modules/_microtask.js":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("./node_modules/core-js/modules/_global.js");

var macrotask = __webpack_require__("./node_modules/core-js/modules/_task.js").set;

var Observer = global.MutationObserver || global.WebKitMutationObserver;
var process = global.process;
var Promise = global.Promise;
var isNode = __webpack_require__("./node_modules/core-js/modules/_cof.js")(process) == 'process';

module.exports = function () {
  var head, last, notify;

  var flush = function flush() {
    var parent, fn;
    if (isNode && (parent = process.domain)) parent.exit();

    while (head) {
      fn = head.fn;
      head = head.next;

      try {
        fn();
      } catch (e) {
        if (head) notify();else last = undefined;
        throw e;
      }
    }

    last = undefined;
    if (parent) parent.enter();
  }; // Node.js


  if (isNode) {
    notify = function notify() {
      process.nextTick(flush);
    }; // browsers with MutationObserver

  } else if (Observer) {
    var toggle = true;
    var node = document.createTextNode('');
    new Observer(flush).observe(node, {
      characterData: true
    }); // eslint-disable-line no-new

    notify = function notify() {
      node.data = toggle = !toggle;
    }; // environments with maybe non-completely correct, but existent Promise

  } else if (Promise && Promise.resolve) {
    var promise = Promise.resolve();

    notify = function notify() {
      promise.then(flush);
    }; // for other environments - macrotask based on:
    // - setImmediate
    // - MessageChannel
    // - window.postMessag
    // - onreadystatechange
    // - setTimeout

  } else {
    notify = function notify() {
      // strange IE + webpack dev server bug - use .call(global)
      macrotask.call(global, flush);
    };
  }

  return function (fn) {
    var task = {
      fn: fn,
      next: undefined
    };
    if (last) last.next = task;

    if (!head) {
      head = task;
      notify();
    }

    last = task;
  };
};

/***/ }),

/***/ "./node_modules/core-js/modules/_new-promise-capability.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // 25.4.1.5 NewPromiseCapability(C)

var aFunction = __webpack_require__("./node_modules/core-js/modules/_a-function.js");

function PromiseCapability(C) {
  var resolve, reject;
  this.promise = new C(function ($$resolve, $$reject) {
    if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');
    resolve = $$resolve;
    reject = $$reject;
  });
  this.resolve = aFunction(resolve);
  this.reject = aFunction(reject);
}

module.exports.f = function (C) {
  return new PromiseCapability(C);
};

/***/ }),

/***/ "./node_modules/core-js/modules/_object-assign.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // 19.1.2.1 Object.assign(target, source, ...)

var getKeys = __webpack_require__("./node_modules/core-js/modules/_object-keys.js");

var gOPS = __webpack_require__("./node_modules/core-js/modules/_object-gops.js");

var pIE = __webpack_require__("./node_modules/core-js/modules/_object-pie.js");

var toObject = __webpack_require__("./node_modules/core-js/modules/_to-object.js");

var IObject = __webpack_require__("./node_modules/core-js/modules/_iobject.js");

var $assign = Object.assign; // should work with symbols and should have deterministic property order (V8 bug)

module.exports = !$assign || __webpack_require__("./node_modules/core-js/modules/_fails.js")(function () {
  var A = {};
  var B = {}; // eslint-disable-next-line no-undef

  var S = Symbol();
  var K = 'abcdefghijklmnopqrst';
  A[S] = 7;
  K.split('').forEach(function (k) {
    B[k] = k;
  });
  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
}) ? function assign(target, source) {
  // eslint-disable-line no-unused-vars
  var T = toObject(target);
  var aLen = arguments.length;
  var index = 1;
  var getSymbols = gOPS.f;
  var isEnum = pIE.f;

  while (aLen > index) {
    var S = IObject(arguments[index++]);
    var keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S);
    var length = keys.length;
    var j = 0;
    var key;

    while (length > j) {
      if (isEnum.call(S, key = keys[j++])) T[key] = S[key];
    }
  }

  return T;
} : $assign;

/***/ }),

/***/ "./node_modules/core-js/modules/_object-create.js":
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
var anObject = __webpack_require__("./node_modules/core-js/modules/_an-object.js");

var dPs = __webpack_require__("./node_modules/core-js/modules/_object-dps.js");

var enumBugKeys = __webpack_require__("./node_modules/core-js/modules/_enum-bug-keys.js");

var IE_PROTO = __webpack_require__("./node_modules/core-js/modules/_shared-key.js")('IE_PROTO');

var Empty = function Empty() {
  /* empty */
};

var PROTOTYPE = 'prototype'; // Create object with fake `null` prototype: use iframe Object with cleared prototype

var _createDict = function createDict() {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = __webpack_require__("./node_modules/core-js/modules/_dom-create.js")('iframe');

  var i = enumBugKeys.length;
  var lt = '<';
  var gt = '>';
  var iframeDocument;
  iframe.style.display = 'none';

  __webpack_require__("./node_modules/core-js/modules/_html.js").appendChild(iframe);

  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
  // createDict = iframe.contentWindow.Object;
  // html.removeChild(iframe);

  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
  iframeDocument.close();
  _createDict = iframeDocument.F;

  while (i--) {
    delete _createDict[PROTOTYPE][enumBugKeys[i]];
  }

  return _createDict();
};

module.exports = Object.create || function create(O, Properties) {
  var result;

  if (O !== null) {
    Empty[PROTOTYPE] = anObject(O);
    result = new Empty();
    Empty[PROTOTYPE] = null; // add "__proto__" for Object.getPrototypeOf polyfill

    result[IE_PROTO] = O;
  } else result = _createDict();

  return Properties === undefined ? result : dPs(result, Properties);
};

/***/ }),

/***/ "./node_modules/core-js/modules/_object-dp.js":
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__("./node_modules/core-js/modules/_an-object.js");

var IE8_DOM_DEFINE = __webpack_require__("./node_modules/core-js/modules/_ie8-dom-define.js");

var toPrimitive = __webpack_require__("./node_modules/core-js/modules/_to-primitive.js");

var dP = Object.defineProperty;
exports.f = __webpack_require__("./node_modules/core-js/modules/_descriptors.js") ? Object.defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return dP(O, P, Attributes);
  } catch (e) {
    /* empty */
  }
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_object-dps.js":
/***/ (function(module, exports, __webpack_require__) {

var dP = __webpack_require__("./node_modules/core-js/modules/_object-dp.js");

var anObject = __webpack_require__("./node_modules/core-js/modules/_an-object.js");

var getKeys = __webpack_require__("./node_modules/core-js/modules/_object-keys.js");

module.exports = __webpack_require__("./node_modules/core-js/modules/_descriptors.js") ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject(O);
  var keys = getKeys(Properties);
  var length = keys.length;
  var i = 0;
  var P;

  while (length > i) {
    dP.f(O, P = keys[i++], Properties[P]);
  }

  return O;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_object-forced-pam.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // Forced replacement prototype accessors methods

module.exports = __webpack_require__("./node_modules/core-js/modules/_library.js") || !__webpack_require__("./node_modules/core-js/modules/_fails.js")(function () {
  var K = Math.random(); // In FF throws only define methods
  // eslint-disable-next-line no-undef, no-useless-call

  __defineSetter__.call(null, K, function () {
    /* empty */
  });

  delete __webpack_require__("./node_modules/core-js/modules/_global.js")[K];
});

/***/ }),

/***/ "./node_modules/core-js/modules/_object-gopd.js":
/***/ (function(module, exports, __webpack_require__) {

var pIE = __webpack_require__("./node_modules/core-js/modules/_object-pie.js");

var createDesc = __webpack_require__("./node_modules/core-js/modules/_property-desc.js");

var toIObject = __webpack_require__("./node_modules/core-js/modules/_to-iobject.js");

var toPrimitive = __webpack_require__("./node_modules/core-js/modules/_to-primitive.js");

var has = __webpack_require__("./node_modules/core-js/modules/_has.js");

var IE8_DOM_DEFINE = __webpack_require__("./node_modules/core-js/modules/_ie8-dom-define.js");

var gOPD = Object.getOwnPropertyDescriptor;
exports.f = __webpack_require__("./node_modules/core-js/modules/_descriptors.js") ? gOPD : function getOwnPropertyDescriptor(O, P) {
  O = toIObject(O);
  P = toPrimitive(P, true);
  if (IE8_DOM_DEFINE) try {
    return gOPD(O, P);
  } catch (e) {
    /* empty */
  }
  if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P]);
};

/***/ }),

/***/ "./node_modules/core-js/modules/_object-gopn-ext.js":
/***/ (function(module, exports, __webpack_require__) {

// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
var toIObject = __webpack_require__("./node_modules/core-js/modules/_to-iobject.js");

var gOPN = __webpack_require__("./node_modules/core-js/modules/_object-gopn.js").f;

var toString = {}.toString;
var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];

var getWindowNames = function getWindowNames(it) {
  try {
    return gOPN(it);
  } catch (e) {
    return windowNames.slice();
  }
};

module.exports.f = function getOwnPropertyNames(it) {
  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));
};

/***/ }),

/***/ "./node_modules/core-js/modules/_object-gopn.js":
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
var $keys = __webpack_require__("./node_modules/core-js/modules/_object-keys-internal.js");

var hiddenKeys = __webpack_require__("./node_modules/core-js/modules/_enum-bug-keys.js").concat('length', 'prototype');

exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return $keys(O, hiddenKeys);
};

/***/ }),

/***/ "./node_modules/core-js/modules/_object-gops.js":
/***/ (function(module, exports) {

exports.f = Object.getOwnPropertySymbols;

/***/ }),

/***/ "./node_modules/core-js/modules/_object-gpo.js":
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
var has = __webpack_require__("./node_modules/core-js/modules/_has.js");

var toObject = __webpack_require__("./node_modules/core-js/modules/_to-object.js");

var IE_PROTO = __webpack_require__("./node_modules/core-js/modules/_shared-key.js")('IE_PROTO');

var ObjectProto = Object.prototype;

module.exports = Object.getPrototypeOf || function (O) {
  O = toObject(O);
  if (has(O, IE_PROTO)) return O[IE_PROTO];

  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
    return O.constructor.prototype;
  }

  return O instanceof Object ? ObjectProto : null;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_object-keys-internal.js":
/***/ (function(module, exports, __webpack_require__) {

var has = __webpack_require__("./node_modules/core-js/modules/_has.js");

var toIObject = __webpack_require__("./node_modules/core-js/modules/_to-iobject.js");

var arrayIndexOf = __webpack_require__("./node_modules/core-js/modules/_array-includes.js")(false);

var IE_PROTO = __webpack_require__("./node_modules/core-js/modules/_shared-key.js")('IE_PROTO');

module.exports = function (object, names) {
  var O = toIObject(object);
  var i = 0;
  var result = [];
  var key;

  for (key in O) {
    if (key != IE_PROTO) has(O, key) && result.push(key);
  } // Don't enum bug & hidden keys


  while (names.length > i) {
    if (has(O, key = names[i++])) {
      ~arrayIndexOf(result, key) || result.push(key);
    }
  }

  return result;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_object-keys.js":
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.14 / 15.2.3.14 Object.keys(O)
var $keys = __webpack_require__("./node_modules/core-js/modules/_object-keys-internal.js");

var enumBugKeys = __webpack_require__("./node_modules/core-js/modules/_enum-bug-keys.js");

module.exports = Object.keys || function keys(O) {
  return $keys(O, enumBugKeys);
};

/***/ }),

/***/ "./node_modules/core-js/modules/_object-pie.js":
/***/ (function(module, exports) {

exports.f = {}.propertyIsEnumerable;

/***/ }),

/***/ "./node_modules/core-js/modules/_object-sap.js":
/***/ (function(module, exports, __webpack_require__) {

// most Object methods by ES6 should accept primitives
var $export = __webpack_require__("./node_modules/core-js/modules/_export.js");

var core = __webpack_require__("./node_modules/core-js/modules/_core.js");

var fails = __webpack_require__("./node_modules/core-js/modules/_fails.js");

module.exports = function (KEY, exec) {
  var fn = (core.Object || {})[KEY] || Object[KEY];
  var exp = {};
  exp[KEY] = exec(fn);
  $export($export.S + $export.F * fails(function () {
    fn(1);
  }), 'Object', exp);
};

/***/ }),

/***/ "./node_modules/core-js/modules/_object-to-array.js":
/***/ (function(module, exports, __webpack_require__) {

var getKeys = __webpack_require__("./node_modules/core-js/modules/_object-keys.js");

var toIObject = __webpack_require__("./node_modules/core-js/modules/_to-iobject.js");

var isEnum = __webpack_require__("./node_modules/core-js/modules/_object-pie.js").f;

module.exports = function (isEntries) {
  return function (it) {
    var O = toIObject(it);
    var keys = getKeys(O);
    var length = keys.length;
    var i = 0;
    var result = [];
    var key;

    while (length > i) {
      if (isEnum.call(O, key = keys[i++])) {
        result.push(isEntries ? [key, O[key]] : O[key]);
      }
    }

    return result;
  };
};

/***/ }),

/***/ "./node_modules/core-js/modules/_own-keys.js":
/***/ (function(module, exports, __webpack_require__) {

// all object keys, includes non-enumerable and symbols
var gOPN = __webpack_require__("./node_modules/core-js/modules/_object-gopn.js");

var gOPS = __webpack_require__("./node_modules/core-js/modules/_object-gops.js");

var anObject = __webpack_require__("./node_modules/core-js/modules/_an-object.js");

var Reflect = __webpack_require__("./node_modules/core-js/modules/_global.js").Reflect;

module.exports = Reflect && Reflect.ownKeys || function ownKeys(it) {
  var keys = gOPN.f(anObject(it));
  var getSymbols = gOPS.f;
  return getSymbols ? keys.concat(getSymbols(it)) : keys;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_parse-float.js":
/***/ (function(module, exports, __webpack_require__) {

var $parseFloat = __webpack_require__("./node_modules/core-js/modules/_global.js").parseFloat;

var $trim = __webpack_require__("./node_modules/core-js/modules/_string-trim.js").trim;

module.exports = 1 / $parseFloat(__webpack_require__("./node_modules/core-js/modules/_string-ws.js") + '-0') !== -Infinity ? function parseFloat(str) {
  var string = $trim(String(str), 3);
  var result = $parseFloat(string);
  return result === 0 && string.charAt(0) == '-' ? -0 : result;
} : $parseFloat;

/***/ }),

/***/ "./node_modules/core-js/modules/_parse-int.js":
/***/ (function(module, exports, __webpack_require__) {

var $parseInt = __webpack_require__("./node_modules/core-js/modules/_global.js").parseInt;

var $trim = __webpack_require__("./node_modules/core-js/modules/_string-trim.js").trim;

var ws = __webpack_require__("./node_modules/core-js/modules/_string-ws.js");

var hex = /^[-+]?0[xX]/;
module.exports = $parseInt(ws + '08') !== 8 || $parseInt(ws + '0x16') !== 22 ? function parseInt(str, radix) {
  var string = $trim(String(str), 3);
  return $parseInt(string, radix >>> 0 || (hex.test(string) ? 16 : 10));
} : $parseInt;

/***/ }),

/***/ "./node_modules/core-js/modules/_perform.js":
/***/ (function(module, exports) {

module.exports = function (exec) {
  try {
    return {
      e: false,
      v: exec()
    };
  } catch (e) {
    return {
      e: true,
      v: e
    };
  }
};

/***/ }),

/***/ "./node_modules/core-js/modules/_promise-resolve.js":
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__("./node_modules/core-js/modules/_an-object.js");

var isObject = __webpack_require__("./node_modules/core-js/modules/_is-object.js");

var newPromiseCapability = __webpack_require__("./node_modules/core-js/modules/_new-promise-capability.js");

module.exports = function (C, x) {
  anObject(C);
  if (isObject(x) && x.constructor === C) return x;
  var promiseCapability = newPromiseCapability.f(C);
  var resolve = promiseCapability.resolve;
  resolve(x);
  return promiseCapability.promise;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_property-desc.js":
/***/ (function(module, exports) {

module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};

/***/ }),

/***/ "./node_modules/core-js/modules/_redefine-all.js":
/***/ (function(module, exports, __webpack_require__) {

var redefine = __webpack_require__("./node_modules/core-js/modules/_redefine.js");

module.exports = function (target, src, safe) {
  for (var key in src) {
    redefine(target, key, src[key], safe);
  }

  return target;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_redefine.js":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("./node_modules/core-js/modules/_global.js");

var hide = __webpack_require__("./node_modules/core-js/modules/_hide.js");

var has = __webpack_require__("./node_modules/core-js/modules/_has.js");

var SRC = __webpack_require__("./node_modules/core-js/modules/_uid.js")('src');

var TO_STRING = 'toString';
var $toString = Function[TO_STRING];
var TPL = ('' + $toString).split(TO_STRING);

__webpack_require__("./node_modules/core-js/modules/_core.js").inspectSource = function (it) {
  return $toString.call(it);
};

(module.exports = function (O, key, val, safe) {
  var isFunction = typeof val == 'function';
  if (isFunction) has(val, 'name') || hide(val, 'name', key);
  if (O[key] === val) return;
  if (isFunction) has(val, SRC) || hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));

  if (O === global) {
    O[key] = val;
  } else if (!safe) {
    delete O[key];
    hide(O, key, val);
  } else if (O[key]) {
    O[key] = val;
  } else {
    hide(O, key, val);
  } // add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative

})(Function.prototype, TO_STRING, function toString() {
  return typeof this == 'function' && this[SRC] || $toString.call(this);
});

/***/ }),

/***/ "./node_modules/core-js/modules/_same-value.js":
/***/ (function(module, exports) {

// 7.2.9 SameValue(x, y)
module.exports = Object.is || function is(x, y) {
  // eslint-disable-next-line no-self-compare
  return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_set-collection-from.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // https://tc39.github.io/proposal-setmap-offrom/

var $export = __webpack_require__("./node_modules/core-js/modules/_export.js");

var aFunction = __webpack_require__("./node_modules/core-js/modules/_a-function.js");

var ctx = __webpack_require__("./node_modules/core-js/modules/_ctx.js");

var forOf = __webpack_require__("./node_modules/core-js/modules/_for-of.js");

module.exports = function (COLLECTION) {
  $export($export.S, COLLECTION, {
    from: function from(source
    /* , mapFn, thisArg */
    ) {
      var mapFn = arguments[1];
      var mapping, A, n, cb;
      aFunction(this);
      mapping = mapFn !== undefined;
      if (mapping) aFunction(mapFn);
      if (source == undefined) return new this();
      A = [];

      if (mapping) {
        n = 0;
        cb = ctx(mapFn, arguments[2], 2);
        forOf(source, false, function (nextItem) {
          A.push(cb(nextItem, n++));
        });
      } else {
        forOf(source, false, A.push, A);
      }

      return new this(A);
    }
  });
};

/***/ }),

/***/ "./node_modules/core-js/modules/_set-collection-of.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // https://tc39.github.io/proposal-setmap-offrom/

var $export = __webpack_require__("./node_modules/core-js/modules/_export.js");

module.exports = function (COLLECTION) {
  $export($export.S, COLLECTION, {
    of: function of() {
      var length = arguments.length;
      var A = Array(length);

      while (length--) {
        A[length] = arguments[length];
      }

      return new this(A);
    }
  });
};

/***/ }),

/***/ "./node_modules/core-js/modules/_set-proto.js":
/***/ (function(module, exports, __webpack_require__) {

// Works with __proto__ only. Old v8 can't work with null proto objects.

/* eslint-disable no-proto */
var isObject = __webpack_require__("./node_modules/core-js/modules/_is-object.js");

var anObject = __webpack_require__("./node_modules/core-js/modules/_an-object.js");

var check = function check(O, proto) {
  anObject(O);
  if (!isObject(proto) && proto !== null) throw TypeError(proto + ": can't set as prototype!");
};

module.exports = {
  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
  function (test, buggy, set) {
    try {
      set = __webpack_require__("./node_modules/core-js/modules/_ctx.js")(Function.call, __webpack_require__("./node_modules/core-js/modules/_object-gopd.js").f(Object.prototype, '__proto__').set, 2);
      set(test, []);
      buggy = !(test instanceof Array);
    } catch (e) {
      buggy = true;
    }

    return function setPrototypeOf(O, proto) {
      check(O, proto);
      if (buggy) O.__proto__ = proto;else set(O, proto);
      return O;
    };
  }({}, false) : undefined),
  check: check
};

/***/ }),

/***/ "./node_modules/core-js/modules/_set-species.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var global = __webpack_require__("./node_modules/core-js/modules/_global.js");

var dP = __webpack_require__("./node_modules/core-js/modules/_object-dp.js");

var DESCRIPTORS = __webpack_require__("./node_modules/core-js/modules/_descriptors.js");

var SPECIES = __webpack_require__("./node_modules/core-js/modules/_wks.js")('species');

module.exports = function (KEY) {
  var C = global[KEY];
  if (DESCRIPTORS && C && !C[SPECIES]) dP.f(C, SPECIES, {
    configurable: true,
    get: function get() {
      return this;
    }
  });
};

/***/ }),

/***/ "./node_modules/core-js/modules/_set-to-string-tag.js":
/***/ (function(module, exports, __webpack_require__) {

var def = __webpack_require__("./node_modules/core-js/modules/_object-dp.js").f;

var has = __webpack_require__("./node_modules/core-js/modules/_has.js");

var TAG = __webpack_require__("./node_modules/core-js/modules/_wks.js")('toStringTag');

module.exports = function (it, tag, stat) {
  if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, {
    configurable: true,
    value: tag
  });
};

/***/ }),

/***/ "./node_modules/core-js/modules/_shared-key.js":
/***/ (function(module, exports, __webpack_require__) {

var shared = __webpack_require__("./node_modules/core-js/modules/_shared.js")('keys');

var uid = __webpack_require__("./node_modules/core-js/modules/_uid.js");

module.exports = function (key) {
  return shared[key] || (shared[key] = uid(key));
};

/***/ }),

/***/ "./node_modules/core-js/modules/_shared.js":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("./node_modules/core-js/modules/_global.js");

var SHARED = '__core-js_shared__';
var store = global[SHARED] || (global[SHARED] = {});

module.exports = function (key) {
  return store[key] || (store[key] = {});
};

/***/ }),

/***/ "./node_modules/core-js/modules/_species-constructor.js":
/***/ (function(module, exports, __webpack_require__) {

// 7.3.20 SpeciesConstructor(O, defaultConstructor)
var anObject = __webpack_require__("./node_modules/core-js/modules/_an-object.js");

var aFunction = __webpack_require__("./node_modules/core-js/modules/_a-function.js");

var SPECIES = __webpack_require__("./node_modules/core-js/modules/_wks.js")('species');

module.exports = function (O, D) {
  var C = anObject(O).constructor;
  var S;
  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);
};

/***/ }),

/***/ "./node_modules/core-js/modules/_strict-method.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var fails = __webpack_require__("./node_modules/core-js/modules/_fails.js");

module.exports = function (method, arg) {
  return !!method && fails(function () {
    // eslint-disable-next-line no-useless-call
    arg ? method.call(null, function () {
      /* empty */
    }, 1) : method.call(null);
  });
};

/***/ }),

/***/ "./node_modules/core-js/modules/_string-at.js":
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__("./node_modules/core-js/modules/_to-integer.js");

var defined = __webpack_require__("./node_modules/core-js/modules/_defined.js"); // true  -> String#at
// false -> String#codePointAt


module.exports = function (TO_STRING) {
  return function (that, pos) {
    var s = String(defined(that));
    var i = toInteger(pos);
    var l = s.length;
    var a, b;
    if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
    a = s.charCodeAt(i);
    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff ? TO_STRING ? s.charAt(i) : a : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
  };
};

/***/ }),

/***/ "./node_modules/core-js/modules/_string-context.js":
/***/ (function(module, exports, __webpack_require__) {

// helper for String#{startsWith, endsWith, includes}
var isRegExp = __webpack_require__("./node_modules/core-js/modules/_is-regexp.js");

var defined = __webpack_require__("./node_modules/core-js/modules/_defined.js");

module.exports = function (that, searchString, NAME) {
  if (isRegExp(searchString)) throw TypeError('String#' + NAME + " doesn't accept regex!");
  return String(defined(that));
};

/***/ }),

/***/ "./node_modules/core-js/modules/_string-html.js":
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__("./node_modules/core-js/modules/_export.js");

var fails = __webpack_require__("./node_modules/core-js/modules/_fails.js");

var defined = __webpack_require__("./node_modules/core-js/modules/_defined.js");

var quot = /"/g; // B.2.3.2.1 CreateHTML(string, tag, attribute, value)

var createHTML = function createHTML(string, tag, attribute, value) {
  var S = String(defined(string));
  var p1 = '<' + tag;
  if (attribute !== '') p1 += ' ' + attribute + '="' + String(value).replace(quot, '&quot;') + '"';
  return p1 + '>' + S + '</' + tag + '>';
};

module.exports = function (NAME, exec) {
  var O = {};
  O[NAME] = exec(createHTML);
  $export($export.P + $export.F * fails(function () {
    var test = ''[NAME]('"');
    return test !== test.toLowerCase() || test.split('"').length > 3;
  }), 'String', O);
};

/***/ }),

/***/ "./node_modules/core-js/modules/_string-pad.js":
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/tc39/proposal-string-pad-start-end
var toLength = __webpack_require__("./node_modules/core-js/modules/_to-length.js");

var repeat = __webpack_require__("./node_modules/core-js/modules/_string-repeat.js");

var defined = __webpack_require__("./node_modules/core-js/modules/_defined.js");

module.exports = function (that, maxLength, fillString, left) {
  var S = String(defined(that));
  var stringLength = S.length;
  var fillStr = fillString === undefined ? ' ' : String(fillString);
  var intMaxLength = toLength(maxLength);
  if (intMaxLength <= stringLength || fillStr == '') return S;
  var fillLen = intMaxLength - stringLength;
  var stringFiller = repeat.call(fillStr, Math.ceil(fillLen / fillStr.length));
  if (stringFiller.length > fillLen) stringFiller = stringFiller.slice(0, fillLen);
  return left ? stringFiller + S : S + stringFiller;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_string-repeat.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var toInteger = __webpack_require__("./node_modules/core-js/modules/_to-integer.js");

var defined = __webpack_require__("./node_modules/core-js/modules/_defined.js");

module.exports = function repeat(count) {
  var str = String(defined(this));
  var res = '';
  var n = toInteger(count);
  if (n < 0 || n == Infinity) throw RangeError("Count can't be negative");

  for (; n > 0; (n >>>= 1) && (str += str)) {
    if (n & 1) res += str;
  }

  return res;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_string-trim.js":
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__("./node_modules/core-js/modules/_export.js");

var defined = __webpack_require__("./node_modules/core-js/modules/_defined.js");

var fails = __webpack_require__("./node_modules/core-js/modules/_fails.js");

var spaces = __webpack_require__("./node_modules/core-js/modules/_string-ws.js");

var space = '[' + spaces + ']';
var non = "\u200B\x85";
var ltrim = RegExp('^' + space + space + '*');
var rtrim = RegExp(space + space + '*$');

var exporter = function exporter(KEY, exec, ALIAS) {
  var exp = {};
  var FORCE = fails(function () {
    return !!spaces[KEY]() || non[KEY]() != non;
  });
  var fn = exp[KEY] = FORCE ? exec(trim) : spaces[KEY];
  if (ALIAS) exp[ALIAS] = fn;
  $export($export.P + $export.F * FORCE, 'String', exp);
}; // 1 -> String#trimLeft
// 2 -> String#trimRight
// 3 -> String#trim


var trim = exporter.trim = function (string, TYPE) {
  string = String(defined(string));
  if (TYPE & 1) string = string.replace(ltrim, '');
  if (TYPE & 2) string = string.replace(rtrim, '');
  return string;
};

module.exports = exporter;

/***/ }),

/***/ "./node_modules/core-js/modules/_string-ws.js":
/***/ (function(module, exports) {

module.exports = "\t\n\x0B\f\r \xA0\u1680\u180E\u2000\u2001\u2002\u2003" + "\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF";

/***/ }),

/***/ "./node_modules/core-js/modules/_task.js":
/***/ (function(module, exports, __webpack_require__) {

var ctx = __webpack_require__("./node_modules/core-js/modules/_ctx.js");

var invoke = __webpack_require__("./node_modules/core-js/modules/_invoke.js");

var html = __webpack_require__("./node_modules/core-js/modules/_html.js");

var cel = __webpack_require__("./node_modules/core-js/modules/_dom-create.js");

var global = __webpack_require__("./node_modules/core-js/modules/_global.js");

var process = global.process;
var setTask = global.setImmediate;
var clearTask = global.clearImmediate;
var MessageChannel = global.MessageChannel;
var Dispatch = global.Dispatch;
var counter = 0;
var queue = {};
var ONREADYSTATECHANGE = 'onreadystatechange';
var defer, channel, port;

var run = function run() {
  var id = +this; // eslint-disable-next-line no-prototype-builtins

  if (queue.hasOwnProperty(id)) {
    var fn = queue[id];
    delete queue[id];
    fn();
  }
};

var listener = function listener(event) {
  run.call(event.data);
}; // Node.js 0.9+ & IE10+ has setImmediate, otherwise:


if (!setTask || !clearTask) {
  setTask = function setImmediate(fn) {
    var args = [];
    var i = 1;

    while (arguments.length > i) {
      args.push(arguments[i++]);
    }

    queue[++counter] = function () {
      // eslint-disable-next-line no-new-func
      invoke(typeof fn == 'function' ? fn : Function(fn), args);
    };

    defer(counter);
    return counter;
  };

  clearTask = function clearImmediate(id) {
    delete queue[id];
  }; // Node.js 0.8-


  if (__webpack_require__("./node_modules/core-js/modules/_cof.js")(process) == 'process') {
    defer = function defer(id) {
      process.nextTick(ctx(run, id, 1));
    }; // Sphere (JS game engine) Dispatch API

  } else if (Dispatch && Dispatch.now) {
    defer = function defer(id) {
      Dispatch.now(ctx(run, id, 1));
    }; // Browsers with MessageChannel, includes WebWorkers

  } else if (MessageChannel) {
    channel = new MessageChannel();
    port = channel.port2;
    channel.port1.onmessage = listener;
    defer = ctx(port.postMessage, port, 1); // Browsers with postMessage, skip WebWorkers
    // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
  } else if (global.addEventListener && typeof postMessage == 'function' && !global.importScripts) {
    defer = function defer(id) {
      global.postMessage(id + '', '*');
    };

    global.addEventListener('message', listener, false); // IE8-
  } else if (ONREADYSTATECHANGE in cel('script')) {
    defer = function defer(id) {
      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function () {
        html.removeChild(this);
        run.call(id);
      };
    }; // Rest old browsers

  } else {
    defer = function defer(id) {
      setTimeout(ctx(run, id, 1), 0);
    };
  }
}

module.exports = {
  set: setTask,
  clear: clearTask
};

/***/ }),

/***/ "./node_modules/core-js/modules/_to-absolute-index.js":
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__("./node_modules/core-js/modules/_to-integer.js");

var max = Math.max;
var min = Math.min;

module.exports = function (index, length) {
  index = toInteger(index);
  return index < 0 ? max(index + length, 0) : min(index, length);
};

/***/ }),

/***/ "./node_modules/core-js/modules/_to-index.js":
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/ecma262/#sec-toindex
var toInteger = __webpack_require__("./node_modules/core-js/modules/_to-integer.js");

var toLength = __webpack_require__("./node_modules/core-js/modules/_to-length.js");

module.exports = function (it) {
  if (it === undefined) return 0;
  var number = toInteger(it);
  var length = toLength(number);
  if (number !== length) throw RangeError('Wrong length!');
  return length;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_to-integer.js":
/***/ (function(module, exports) {

// 7.1.4 ToInteger
var ceil = Math.ceil;
var floor = Math.floor;

module.exports = function (it) {
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};

/***/ }),

/***/ "./node_modules/core-js/modules/_to-iobject.js":
/***/ (function(module, exports, __webpack_require__) {

// to indexed object, toObject with fallback for non-array-like ES3 strings
var IObject = __webpack_require__("./node_modules/core-js/modules/_iobject.js");

var defined = __webpack_require__("./node_modules/core-js/modules/_defined.js");

module.exports = function (it) {
  return IObject(defined(it));
};

/***/ }),

/***/ "./node_modules/core-js/modules/_to-length.js":
/***/ (function(module, exports, __webpack_require__) {

// 7.1.15 ToLength
var toInteger = __webpack_require__("./node_modules/core-js/modules/_to-integer.js");

var min = Math.min;

module.exports = function (it) {
  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};

/***/ }),

/***/ "./node_modules/core-js/modules/_to-object.js":
/***/ (function(module, exports, __webpack_require__) {

// 7.1.13 ToObject(argument)
var defined = __webpack_require__("./node_modules/core-js/modules/_defined.js");

module.exports = function (it) {
  return Object(defined(it));
};

/***/ }),

/***/ "./node_modules/core-js/modules/_to-primitive.js":
/***/ (function(module, exports, __webpack_require__) {

// 7.1.1 ToPrimitive(input [, PreferredType])
var isObject = __webpack_require__("./node_modules/core-js/modules/_is-object.js"); // instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string


module.exports = function (it, S) {
  if (!isObject(it)) return it;
  var fn, val;
  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  throw TypeError("Can't convert object to primitive value");
};

/***/ }),

/***/ "./node_modules/core-js/modules/_typed-array.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


if (__webpack_require__("./node_modules/core-js/modules/_descriptors.js")) {
  var LIBRARY = __webpack_require__("./node_modules/core-js/modules/_library.js");

  var global = __webpack_require__("./node_modules/core-js/modules/_global.js");

  var fails = __webpack_require__("./node_modules/core-js/modules/_fails.js");

  var $export = __webpack_require__("./node_modules/core-js/modules/_export.js");

  var $typed = __webpack_require__("./node_modules/core-js/modules/_typed.js");

  var $buffer = __webpack_require__("./node_modules/core-js/modules/_typed-buffer.js");

  var ctx = __webpack_require__("./node_modules/core-js/modules/_ctx.js");

  var anInstance = __webpack_require__("./node_modules/core-js/modules/_an-instance.js");

  var propertyDesc = __webpack_require__("./node_modules/core-js/modules/_property-desc.js");

  var hide = __webpack_require__("./node_modules/core-js/modules/_hide.js");

  var redefineAll = __webpack_require__("./node_modules/core-js/modules/_redefine-all.js");

  var toInteger = __webpack_require__("./node_modules/core-js/modules/_to-integer.js");

  var toLength = __webpack_require__("./node_modules/core-js/modules/_to-length.js");

  var toIndex = __webpack_require__("./node_modules/core-js/modules/_to-index.js");

  var toAbsoluteIndex = __webpack_require__("./node_modules/core-js/modules/_to-absolute-index.js");

  var toPrimitive = __webpack_require__("./node_modules/core-js/modules/_to-primitive.js");

  var has = __webpack_require__("./node_modules/core-js/modules/_has.js");

  var classof = __webpack_require__("./node_modules/core-js/modules/_classof.js");

  var isObject = __webpack_require__("./node_modules/core-js/modules/_is-object.js");

  var toObject = __webpack_require__("./node_modules/core-js/modules/_to-object.js");

  var isArrayIter = __webpack_require__("./node_modules/core-js/modules/_is-array-iter.js");

  var create = __webpack_require__("./node_modules/core-js/modules/_object-create.js");

  var getPrototypeOf = __webpack_require__("./node_modules/core-js/modules/_object-gpo.js");

  var gOPN = __webpack_require__("./node_modules/core-js/modules/_object-gopn.js").f;

  var getIterFn = __webpack_require__("./node_modules/core-js/modules/core.get-iterator-method.js");

  var uid = __webpack_require__("./node_modules/core-js/modules/_uid.js");

  var wks = __webpack_require__("./node_modules/core-js/modules/_wks.js");

  var createArrayMethod = __webpack_require__("./node_modules/core-js/modules/_array-methods.js");

  var createArrayIncludes = __webpack_require__("./node_modules/core-js/modules/_array-includes.js");

  var speciesConstructor = __webpack_require__("./node_modules/core-js/modules/_species-constructor.js");

  var ArrayIterators = __webpack_require__("./node_modules/core-js/modules/es6.array.iterator.js");

  var Iterators = __webpack_require__("./node_modules/core-js/modules/_iterators.js");

  var $iterDetect = __webpack_require__("./node_modules/core-js/modules/_iter-detect.js");

  var setSpecies = __webpack_require__("./node_modules/core-js/modules/_set-species.js");

  var arrayFill = __webpack_require__("./node_modules/core-js/modules/_array-fill.js");

  var arrayCopyWithin = __webpack_require__("./node_modules/core-js/modules/_array-copy-within.js");

  var $DP = __webpack_require__("./node_modules/core-js/modules/_object-dp.js");

  var $GOPD = __webpack_require__("./node_modules/core-js/modules/_object-gopd.js");

  var dP = $DP.f;
  var gOPD = $GOPD.f;
  var RangeError = global.RangeError;
  var TypeError = global.TypeError;
  var Uint8Array = global.Uint8Array;
  var ARRAY_BUFFER = 'ArrayBuffer';
  var SHARED_BUFFER = 'Shared' + ARRAY_BUFFER;
  var BYTES_PER_ELEMENT = 'BYTES_PER_ELEMENT';
  var PROTOTYPE = 'prototype';
  var ArrayProto = Array[PROTOTYPE];
  var $ArrayBuffer = $buffer.ArrayBuffer;
  var $DataView = $buffer.DataView;
  var arrayForEach = createArrayMethod(0);
  var arrayFilter = createArrayMethod(2);
  var arraySome = createArrayMethod(3);
  var arrayEvery = createArrayMethod(4);
  var arrayFind = createArrayMethod(5);
  var arrayFindIndex = createArrayMethod(6);
  var arrayIncludes = createArrayIncludes(true);
  var arrayIndexOf = createArrayIncludes(false);
  var arrayValues = ArrayIterators.values;
  var arrayKeys = ArrayIterators.keys;
  var arrayEntries = ArrayIterators.entries;
  var arrayLastIndexOf = ArrayProto.lastIndexOf;
  var arrayReduce = ArrayProto.reduce;
  var arrayReduceRight = ArrayProto.reduceRight;
  var arrayJoin = ArrayProto.join;
  var arraySort = ArrayProto.sort;
  var arraySlice = ArrayProto.slice;
  var arrayToString = ArrayProto.toString;
  var arrayToLocaleString = ArrayProto.toLocaleString;
  var ITERATOR = wks('iterator');
  var TAG = wks('toStringTag');
  var TYPED_CONSTRUCTOR = uid('typed_constructor');
  var DEF_CONSTRUCTOR = uid('def_constructor');
  var ALL_CONSTRUCTORS = $typed.CONSTR;
  var TYPED_ARRAY = $typed.TYPED;
  var VIEW = $typed.VIEW;
  var WRONG_LENGTH = 'Wrong length!';
  var $map = createArrayMethod(1, function (O, length) {
    return allocate(speciesConstructor(O, O[DEF_CONSTRUCTOR]), length);
  });
  var LITTLE_ENDIAN = fails(function () {
    // eslint-disable-next-line no-undef
    return new Uint8Array(new Uint16Array([1]).buffer)[0] === 1;
  });
  var FORCED_SET = !!Uint8Array && !!Uint8Array[PROTOTYPE].set && fails(function () {
    new Uint8Array(1).set({});
  });

  var toOffset = function toOffset(it, BYTES) {
    var offset = toInteger(it);
    if (offset < 0 || offset % BYTES) throw RangeError('Wrong offset!');
    return offset;
  };

  var validate = function validate(it) {
    if (isObject(it) && TYPED_ARRAY in it) return it;
    throw TypeError(it + ' is not a typed array!');
  };

  var allocate = function allocate(C, length) {
    if (!(isObject(C) && TYPED_CONSTRUCTOR in C)) {
      throw TypeError('It is not a typed array constructor!');
    }

    return new C(length);
  };

  var speciesFromList = function speciesFromList(O, list) {
    return fromList(speciesConstructor(O, O[DEF_CONSTRUCTOR]), list);
  };

  var fromList = function fromList(C, list) {
    var index = 0;
    var length = list.length;
    var result = allocate(C, length);

    while (length > index) {
      result[index] = list[index++];
    }

    return result;
  };

  var addGetter = function addGetter(it, key, internal) {
    dP(it, key, {
      get: function get() {
        return this._d[internal];
      }
    });
  };

  var $from = function from(source
  /* , mapfn, thisArg */
  ) {
    var O = toObject(source);
    var aLen = arguments.length;
    var mapfn = aLen > 1 ? arguments[1] : undefined;
    var mapping = mapfn !== undefined;
    var iterFn = getIterFn(O);
    var i, length, values, result, step, iterator;

    if (iterFn != undefined && !isArrayIter(iterFn)) {
      for (iterator = iterFn.call(O), values = [], i = 0; !(step = iterator.next()).done; i++) {
        values.push(step.value);
      }

      O = values;
    }

    if (mapping && aLen > 2) mapfn = ctx(mapfn, arguments[2], 2);

    for (i = 0, length = toLength(O.length), result = allocate(this, length); length > i; i++) {
      result[i] = mapping ? mapfn(O[i], i) : O[i];
    }

    return result;
  };

  var $of = function of()
  /* ...items */
  {
    var index = 0;
    var length = arguments.length;
    var result = allocate(this, length);

    while (length > index) {
      result[index] = arguments[index++];
    }

    return result;
  }; // iOS Safari 6.x fails here


  var TO_LOCALE_BUG = !!Uint8Array && fails(function () {
    arrayToLocaleString.call(new Uint8Array(1));
  });

  var $toLocaleString = function toLocaleString() {
    return arrayToLocaleString.apply(TO_LOCALE_BUG ? arraySlice.call(validate(this)) : validate(this), arguments);
  };

  var proto = {
    copyWithin: function copyWithin(target, start
    /* , end */
    ) {
      return arrayCopyWithin.call(validate(this), target, start, arguments.length > 2 ? arguments[2] : undefined);
    },
    every: function every(callbackfn
    /* , thisArg */
    ) {
      return arrayEvery(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    fill: function fill(value
    /* , start, end */
    ) {
      // eslint-disable-line no-unused-vars
      return arrayFill.apply(validate(this), arguments);
    },
    filter: function filter(callbackfn
    /* , thisArg */
    ) {
      return speciesFromList(this, arrayFilter(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined));
    },
    find: function find(predicate
    /* , thisArg */
    ) {
      return arrayFind(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
    },
    findIndex: function findIndex(predicate
    /* , thisArg */
    ) {
      return arrayFindIndex(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
    },
    forEach: function forEach(callbackfn
    /* , thisArg */
    ) {
      arrayForEach(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    indexOf: function indexOf(searchElement
    /* , fromIndex */
    ) {
      return arrayIndexOf(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
    },
    includes: function includes(searchElement
    /* , fromIndex */
    ) {
      return arrayIncludes(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
    },
    join: function join(separator) {
      // eslint-disable-line no-unused-vars
      return arrayJoin.apply(validate(this), arguments);
    },
    lastIndexOf: function lastIndexOf(searchElement
    /* , fromIndex */
    ) {
      // eslint-disable-line no-unused-vars
      return arrayLastIndexOf.apply(validate(this), arguments);
    },
    map: function map(mapfn
    /* , thisArg */
    ) {
      return $map(validate(this), mapfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    reduce: function reduce(callbackfn
    /* , initialValue */
    ) {
      // eslint-disable-line no-unused-vars
      return arrayReduce.apply(validate(this), arguments);
    },
    reduceRight: function reduceRight(callbackfn
    /* , initialValue */
    ) {
      // eslint-disable-line no-unused-vars
      return arrayReduceRight.apply(validate(this), arguments);
    },
    reverse: function reverse() {
      var that = this;
      var length = validate(that).length;
      var middle = Math.floor(length / 2);
      var index = 0;
      var value;

      while (index < middle) {
        value = that[index];
        that[index++] = that[--length];
        that[length] = value;
      }

      return that;
    },
    some: function some(callbackfn
    /* , thisArg */
    ) {
      return arraySome(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    sort: function sort(comparefn) {
      return arraySort.call(validate(this), comparefn);
    },
    subarray: function subarray(begin, end) {
      var O = validate(this);
      var length = O.length;
      var $begin = toAbsoluteIndex(begin, length);
      return new (speciesConstructor(O, O[DEF_CONSTRUCTOR]))(O.buffer, O.byteOffset + $begin * O.BYTES_PER_ELEMENT, toLength((end === undefined ? length : toAbsoluteIndex(end, length)) - $begin));
    }
  };

  var $slice = function slice(start, end) {
    return speciesFromList(this, arraySlice.call(validate(this), start, end));
  };

  var $set = function set(arrayLike
  /* , offset */
  ) {
    validate(this);
    var offset = toOffset(arguments[1], 1);
    var length = this.length;
    var src = toObject(arrayLike);
    var len = toLength(src.length);
    var index = 0;
    if (len + offset > length) throw RangeError(WRONG_LENGTH);

    while (index < len) {
      this[offset + index] = src[index++];
    }
  };

  var $iterators = {
    entries: function entries() {
      return arrayEntries.call(validate(this));
    },
    keys: function keys() {
      return arrayKeys.call(validate(this));
    },
    values: function values() {
      return arrayValues.call(validate(this));
    }
  };

  var isTAIndex = function isTAIndex(target, key) {
    return isObject(target) && target[TYPED_ARRAY] && typeof key != 'symbol' && key in target && String(+key) == String(key);
  };

  var $getDesc = function getOwnPropertyDescriptor(target, key) {
    return isTAIndex(target, key = toPrimitive(key, true)) ? propertyDesc(2, target[key]) : gOPD(target, key);
  };

  var $setDesc = function defineProperty(target, key, desc) {
    if (isTAIndex(target, key = toPrimitive(key, true)) && isObject(desc) && has(desc, 'value') && !has(desc, 'get') && !has(desc, 'set') // TODO: add validation descriptor w/o calling accessors
    && !desc.configurable && (!has(desc, 'writable') || desc.writable) && (!has(desc, 'enumerable') || desc.enumerable)) {
      target[key] = desc.value;
      return target;
    }

    return dP(target, key, desc);
  };

  if (!ALL_CONSTRUCTORS) {
    $GOPD.f = $getDesc;
    $DP.f = $setDesc;
  }

  $export($export.S + $export.F * !ALL_CONSTRUCTORS, 'Object', {
    getOwnPropertyDescriptor: $getDesc,
    defineProperty: $setDesc
  });

  if (fails(function () {
    arrayToString.call({});
  })) {
    arrayToString = arrayToLocaleString = function toString() {
      return arrayJoin.call(this);
    };
  }

  var $TypedArrayPrototype$ = redefineAll({}, proto);
  redefineAll($TypedArrayPrototype$, $iterators);
  hide($TypedArrayPrototype$, ITERATOR, $iterators.values);
  redefineAll($TypedArrayPrototype$, {
    slice: $slice,
    set: $set,
    constructor: function constructor() {
      /* noop */
    },
    toString: arrayToString,
    toLocaleString: $toLocaleString
  });
  addGetter($TypedArrayPrototype$, 'buffer', 'b');
  addGetter($TypedArrayPrototype$, 'byteOffset', 'o');
  addGetter($TypedArrayPrototype$, 'byteLength', 'l');
  addGetter($TypedArrayPrototype$, 'length', 'e');
  dP($TypedArrayPrototype$, TAG, {
    get: function get() {
      return this[TYPED_ARRAY];
    }
  }); // eslint-disable-next-line max-statements

  module.exports = function (KEY, BYTES, wrapper, CLAMPED) {
    CLAMPED = !!CLAMPED;
    var NAME = KEY + (CLAMPED ? 'Clamped' : '') + 'Array';
    var GETTER = 'get' + KEY;
    var SETTER = 'set' + KEY;
    var TypedArray = global[NAME];
    var Base = TypedArray || {};
    var TAC = TypedArray && getPrototypeOf(TypedArray);
    var FORCED = !TypedArray || !$typed.ABV;
    var O = {};
    var TypedArrayPrototype = TypedArray && TypedArray[PROTOTYPE];

    var getter = function getter(that, index) {
      var data = that._d;
      return data.v[GETTER](index * BYTES + data.o, LITTLE_ENDIAN);
    };

    var setter = function setter(that, index, value) {
      var data = that._d;
      if (CLAMPED) value = (value = Math.round(value)) < 0 ? 0 : value > 0xff ? 0xff : value & 0xff;
      data.v[SETTER](index * BYTES + data.o, value, LITTLE_ENDIAN);
    };

    var addElement = function addElement(that, index) {
      dP(that, index, {
        get: function get() {
          return getter(this, index);
        },
        set: function set(value) {
          return setter(this, index, value);
        },
        enumerable: true
      });
    };

    if (FORCED) {
      TypedArray = wrapper(function (that, data, $offset, $length) {
        anInstance(that, TypedArray, NAME, '_d');
        var index = 0;
        var offset = 0;
        var buffer, byteLength, length, klass;

        if (!isObject(data)) {
          length = toIndex(data);
          byteLength = length * BYTES;
          buffer = new $ArrayBuffer(byteLength);
        } else if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) {
          buffer = data;
          offset = toOffset($offset, BYTES);
          var $len = data.byteLength;

          if ($length === undefined) {
            if ($len % BYTES) throw RangeError(WRONG_LENGTH);
            byteLength = $len - offset;
            if (byteLength < 0) throw RangeError(WRONG_LENGTH);
          } else {
            byteLength = toLength($length) * BYTES;
            if (byteLength + offset > $len) throw RangeError(WRONG_LENGTH);
          }

          length = byteLength / BYTES;
        } else if (TYPED_ARRAY in data) {
          return fromList(TypedArray, data);
        } else {
          return $from.call(TypedArray, data);
        }

        hide(that, '_d', {
          b: buffer,
          o: offset,
          l: byteLength,
          e: length,
          v: new $DataView(buffer)
        });

        while (index < length) {
          addElement(that, index++);
        }
      });
      TypedArrayPrototype = TypedArray[PROTOTYPE] = create($TypedArrayPrototype$);
      hide(TypedArrayPrototype, 'constructor', TypedArray);
    } else if (!fails(function () {
      TypedArray(1);
    }) || !fails(function () {
      new TypedArray(-1); // eslint-disable-line no-new
    }) || !$iterDetect(function (iter) {
      new TypedArray(); // eslint-disable-line no-new

      new TypedArray(null); // eslint-disable-line no-new

      new TypedArray(1.5); // eslint-disable-line no-new

      new TypedArray(iter); // eslint-disable-line no-new
    }, true)) {
      TypedArray = wrapper(function (that, data, $offset, $length) {
        anInstance(that, TypedArray, NAME);
        var klass; // `ws` module bug, temporarily remove validation length for Uint8Array
        // https://github.com/websockets/ws/pull/645

        if (!isObject(data)) return new Base(toIndex(data));

        if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) {
          return $length !== undefined ? new Base(data, toOffset($offset, BYTES), $length) : $offset !== undefined ? new Base(data, toOffset($offset, BYTES)) : new Base(data);
        }

        if (TYPED_ARRAY in data) return fromList(TypedArray, data);
        return $from.call(TypedArray, data);
      });
      arrayForEach(TAC !== Function.prototype ? gOPN(Base).concat(gOPN(TAC)) : gOPN(Base), function (key) {
        if (!(key in TypedArray)) hide(TypedArray, key, Base[key]);
      });
      TypedArray[PROTOTYPE] = TypedArrayPrototype;
      if (!LIBRARY) TypedArrayPrototype.constructor = TypedArray;
    }

    var $nativeIterator = TypedArrayPrototype[ITERATOR];
    var CORRECT_ITER_NAME = !!$nativeIterator && ($nativeIterator.name == 'values' || $nativeIterator.name == undefined);
    var $iterator = $iterators.values;
    hide(TypedArray, TYPED_CONSTRUCTOR, true);
    hide(TypedArrayPrototype, TYPED_ARRAY, NAME);
    hide(TypedArrayPrototype, VIEW, true);
    hide(TypedArrayPrototype, DEF_CONSTRUCTOR, TypedArray);

    if (CLAMPED ? new TypedArray(1)[TAG] != NAME : !(TAG in TypedArrayPrototype)) {
      dP(TypedArrayPrototype, TAG, {
        get: function get() {
          return NAME;
        }
      });
    }

    O[NAME] = TypedArray;
    $export($export.G + $export.W + $export.F * (TypedArray != Base), O);
    $export($export.S, NAME, {
      BYTES_PER_ELEMENT: BYTES
    });
    $export($export.S + $export.F * fails(function () {
      Base.of.call(TypedArray, 1);
    }), NAME, {
      from: $from,
      of: $of
    });
    if (!(BYTES_PER_ELEMENT in TypedArrayPrototype)) hide(TypedArrayPrototype, BYTES_PER_ELEMENT, BYTES);
    $export($export.P, NAME, proto);
    setSpecies(NAME);
    $export($export.P + $export.F * FORCED_SET, NAME, {
      set: $set
    });
    $export($export.P + $export.F * !CORRECT_ITER_NAME, NAME, $iterators);
    if (!LIBRARY && TypedArrayPrototype.toString != arrayToString) TypedArrayPrototype.toString = arrayToString;
    $export($export.P + $export.F * fails(function () {
      new TypedArray(1).slice();
    }), NAME, {
      slice: $slice
    });
    $export($export.P + $export.F * (fails(function () {
      return [1, 2].toLocaleString() != new TypedArray([1, 2]).toLocaleString();
    }) || !fails(function () {
      TypedArrayPrototype.toLocaleString.call([1, 2]);
    })), NAME, {
      toLocaleString: $toLocaleString
    });
    Iterators[NAME] = CORRECT_ITER_NAME ? $nativeIterator : $iterator;
    if (!LIBRARY && !CORRECT_ITER_NAME) hide(TypedArrayPrototype, ITERATOR, $iterator);
  };
} else module.exports = function () {
  /* empty */
};

/***/ }),

/***/ "./node_modules/core-js/modules/_typed-buffer.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var global = __webpack_require__("./node_modules/core-js/modules/_global.js");

var DESCRIPTORS = __webpack_require__("./node_modules/core-js/modules/_descriptors.js");

var LIBRARY = __webpack_require__("./node_modules/core-js/modules/_library.js");

var $typed = __webpack_require__("./node_modules/core-js/modules/_typed.js");

var hide = __webpack_require__("./node_modules/core-js/modules/_hide.js");

var redefineAll = __webpack_require__("./node_modules/core-js/modules/_redefine-all.js");

var fails = __webpack_require__("./node_modules/core-js/modules/_fails.js");

var anInstance = __webpack_require__("./node_modules/core-js/modules/_an-instance.js");

var toInteger = __webpack_require__("./node_modules/core-js/modules/_to-integer.js");

var toLength = __webpack_require__("./node_modules/core-js/modules/_to-length.js");

var toIndex = __webpack_require__("./node_modules/core-js/modules/_to-index.js");

var gOPN = __webpack_require__("./node_modules/core-js/modules/_object-gopn.js").f;

var dP = __webpack_require__("./node_modules/core-js/modules/_object-dp.js").f;

var arrayFill = __webpack_require__("./node_modules/core-js/modules/_array-fill.js");

var setToStringTag = __webpack_require__("./node_modules/core-js/modules/_set-to-string-tag.js");

var ARRAY_BUFFER = 'ArrayBuffer';
var DATA_VIEW = 'DataView';
var PROTOTYPE = 'prototype';
var WRONG_LENGTH = 'Wrong length!';
var WRONG_INDEX = 'Wrong index!';
var $ArrayBuffer = global[ARRAY_BUFFER];
var $DataView = global[DATA_VIEW];
var Math = global.Math;
var RangeError = global.RangeError; // eslint-disable-next-line no-shadow-restricted-names

var Infinity = global.Infinity;
var BaseBuffer = $ArrayBuffer;
var abs = Math.abs;
var pow = Math.pow;
var floor = Math.floor;
var log = Math.log;
var LN2 = Math.LN2;
var BUFFER = 'buffer';
var BYTE_LENGTH = 'byteLength';
var BYTE_OFFSET = 'byteOffset';
var $BUFFER = DESCRIPTORS ? '_b' : BUFFER;
var $LENGTH = DESCRIPTORS ? '_l' : BYTE_LENGTH;
var $OFFSET = DESCRIPTORS ? '_o' : BYTE_OFFSET; // IEEE754 conversions based on https://github.com/feross/ieee754

function packIEEE754(value, mLen, nBytes) {
  var buffer = Array(nBytes);
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? pow(2, -24) - pow(2, -77) : 0;
  var i = 0;
  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  var e, m, c;
  value = abs(value); // eslint-disable-next-line no-self-compare

  if (value != value || value === Infinity) {
    // eslint-disable-next-line no-self-compare
    m = value != value ? 1 : 0;
    e = eMax;
  } else {
    e = floor(log(value) / LN2);

    if (value * (c = pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }

    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * pow(2, 1 - eBias);
    }

    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * pow(2, eBias - 1) * pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[i++] = m & 255, m /= 256, mLen -= 8) {
    ;
  }

  e = e << mLen | m;
  eLen += mLen;

  for (; eLen > 0; buffer[i++] = e & 255, e /= 256, eLen -= 8) {
    ;
  }

  buffer[--i] |= s * 128;
  return buffer;
}

function unpackIEEE754(buffer, mLen, nBytes) {
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = eLen - 7;
  var i = nBytes - 1;
  var s = buffer[i--];
  var e = s & 127;
  var m;
  s >>= 7;

  for (; nBits > 0; e = e * 256 + buffer[i], i--, nBits -= 8) {
    ;
  }

  m = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;

  for (; nBits > 0; m = m * 256 + buffer[i], i--, nBits -= 8) {
    ;
  }

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : s ? -Infinity : Infinity;
  } else {
    m = m + pow(2, mLen);
    e = e - eBias;
  }

  return (s ? -1 : 1) * m * pow(2, e - mLen);
}

function unpackI32(bytes) {
  return bytes[3] << 24 | bytes[2] << 16 | bytes[1] << 8 | bytes[0];
}

function packI8(it) {
  return [it & 0xff];
}

function packI16(it) {
  return [it & 0xff, it >> 8 & 0xff];
}

function packI32(it) {
  return [it & 0xff, it >> 8 & 0xff, it >> 16 & 0xff, it >> 24 & 0xff];
}

function packF64(it) {
  return packIEEE754(it, 52, 8);
}

function packF32(it) {
  return packIEEE754(it, 23, 4);
}

function addGetter(C, key, internal) {
  dP(C[PROTOTYPE], key, {
    get: function get() {
      return this[internal];
    }
  });
}

function get(view, bytes, index, isLittleEndian) {
  var numIndex = +index;
  var intIndex = toIndex(numIndex);
  if (intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX);
  var store = view[$BUFFER]._b;
  var start = intIndex + view[$OFFSET];
  var pack = store.slice(start, start + bytes);
  return isLittleEndian ? pack : pack.reverse();
}

function set(view, bytes, index, conversion, value, isLittleEndian) {
  var numIndex = +index;
  var intIndex = toIndex(numIndex);
  if (intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX);
  var store = view[$BUFFER]._b;
  var start = intIndex + view[$OFFSET];
  var pack = conversion(+value);

  for (var i = 0; i < bytes; i++) {
    store[start + i] = pack[isLittleEndian ? i : bytes - i - 1];
  }
}

if (!$typed.ABV) {
  $ArrayBuffer = function ArrayBuffer(length) {
    anInstance(this, $ArrayBuffer, ARRAY_BUFFER);
    var byteLength = toIndex(length);
    this._b = arrayFill.call(Array(byteLength), 0);
    this[$LENGTH] = byteLength;
  };

  $DataView = function DataView(buffer, byteOffset, byteLength) {
    anInstance(this, $DataView, DATA_VIEW);
    anInstance(buffer, $ArrayBuffer, DATA_VIEW);
    var bufferLength = buffer[$LENGTH];
    var offset = toInteger(byteOffset);
    if (offset < 0 || offset > bufferLength) throw RangeError('Wrong offset!');
    byteLength = byteLength === undefined ? bufferLength - offset : toLength(byteLength);
    if (offset + byteLength > bufferLength) throw RangeError(WRONG_LENGTH);
    this[$BUFFER] = buffer;
    this[$OFFSET] = offset;
    this[$LENGTH] = byteLength;
  };

  if (DESCRIPTORS) {
    addGetter($ArrayBuffer, BYTE_LENGTH, '_l');
    addGetter($DataView, BUFFER, '_b');
    addGetter($DataView, BYTE_LENGTH, '_l');
    addGetter($DataView, BYTE_OFFSET, '_o');
  }

  redefineAll($DataView[PROTOTYPE], {
    getInt8: function getInt8(byteOffset) {
      return get(this, 1, byteOffset)[0] << 24 >> 24;
    },
    getUint8: function getUint8(byteOffset) {
      return get(this, 1, byteOffset)[0];
    },
    getInt16: function getInt16(byteOffset
    /* , littleEndian */
    ) {
      var bytes = get(this, 2, byteOffset, arguments[1]);
      return (bytes[1] << 8 | bytes[0]) << 16 >> 16;
    },
    getUint16: function getUint16(byteOffset
    /* , littleEndian */
    ) {
      var bytes = get(this, 2, byteOffset, arguments[1]);
      return bytes[1] << 8 | bytes[0];
    },
    getInt32: function getInt32(byteOffset
    /* , littleEndian */
    ) {
      return unpackI32(get(this, 4, byteOffset, arguments[1]));
    },
    getUint32: function getUint32(byteOffset
    /* , littleEndian */
    ) {
      return unpackI32(get(this, 4, byteOffset, arguments[1])) >>> 0;
    },
    getFloat32: function getFloat32(byteOffset
    /* , littleEndian */
    ) {
      return unpackIEEE754(get(this, 4, byteOffset, arguments[1]), 23, 4);
    },
    getFloat64: function getFloat64(byteOffset
    /* , littleEndian */
    ) {
      return unpackIEEE754(get(this, 8, byteOffset, arguments[1]), 52, 8);
    },
    setInt8: function setInt8(byteOffset, value) {
      set(this, 1, byteOffset, packI8, value);
    },
    setUint8: function setUint8(byteOffset, value) {
      set(this, 1, byteOffset, packI8, value);
    },
    setInt16: function setInt16(byteOffset, value
    /* , littleEndian */
    ) {
      set(this, 2, byteOffset, packI16, value, arguments[2]);
    },
    setUint16: function setUint16(byteOffset, value
    /* , littleEndian */
    ) {
      set(this, 2, byteOffset, packI16, value, arguments[2]);
    },
    setInt32: function setInt32(byteOffset, value
    /* , littleEndian */
    ) {
      set(this, 4, byteOffset, packI32, value, arguments[2]);
    },
    setUint32: function setUint32(byteOffset, value
    /* , littleEndian */
    ) {
      set(this, 4, byteOffset, packI32, value, arguments[2]);
    },
    setFloat32: function setFloat32(byteOffset, value
    /* , littleEndian */
    ) {
      set(this, 4, byteOffset, packF32, value, arguments[2]);
    },
    setFloat64: function setFloat64(byteOffset, value
    /* , littleEndian */
    ) {
      set(this, 8, byteOffset, packF64, value, arguments[2]);
    }
  });
} else {
  if (!fails(function () {
    $ArrayBuffer(1);
  }) || !fails(function () {
    new $ArrayBuffer(-1); // eslint-disable-line no-new
  }) || fails(function () {
    new $ArrayBuffer(); // eslint-disable-line no-new

    new $ArrayBuffer(1.5); // eslint-disable-line no-new

    new $ArrayBuffer(NaN); // eslint-disable-line no-new

    return $ArrayBuffer.name != ARRAY_BUFFER;
  })) {
    $ArrayBuffer = function ArrayBuffer(length) {
      anInstance(this, $ArrayBuffer);
      return new BaseBuffer(toIndex(length));
    };

    var ArrayBufferProto = $ArrayBuffer[PROTOTYPE] = BaseBuffer[PROTOTYPE];

    for (var keys = gOPN(BaseBuffer), j = 0, key; keys.length > j;) {
      if (!((key = keys[j++]) in $ArrayBuffer)) hide($ArrayBuffer, key, BaseBuffer[key]);
    }

    if (!LIBRARY) ArrayBufferProto.constructor = $ArrayBuffer;
  } // iOS Safari 7.x bug


  var view = new $DataView(new $ArrayBuffer(2));
  var $setInt8 = $DataView[PROTOTYPE].setInt8;
  view.setInt8(0, 2147483648);
  view.setInt8(1, 2147483649);
  if (view.getInt8(0) || !view.getInt8(1)) redefineAll($DataView[PROTOTYPE], {
    setInt8: function setInt8(byteOffset, value) {
      $setInt8.call(this, byteOffset, value << 24 >> 24);
    },
    setUint8: function setUint8(byteOffset, value) {
      $setInt8.call(this, byteOffset, value << 24 >> 24);
    }
  }, true);
}

setToStringTag($ArrayBuffer, ARRAY_BUFFER);
setToStringTag($DataView, DATA_VIEW);
hide($DataView[PROTOTYPE], $typed.VIEW, true);
exports[ARRAY_BUFFER] = $ArrayBuffer;
exports[DATA_VIEW] = $DataView;

/***/ }),

/***/ "./node_modules/core-js/modules/_typed.js":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("./node_modules/core-js/modules/_global.js");

var hide = __webpack_require__("./node_modules/core-js/modules/_hide.js");

var uid = __webpack_require__("./node_modules/core-js/modules/_uid.js");

var TYPED = uid('typed_array');
var VIEW = uid('view');
var ABV = !!(global.ArrayBuffer && global.DataView);
var CONSTR = ABV;
var i = 0;
var l = 9;
var Typed;
var TypedArrayConstructors = 'Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array'.split(',');

while (i < l) {
  if (Typed = global[TypedArrayConstructors[i++]]) {
    hide(Typed.prototype, TYPED, true);
    hide(Typed.prototype, VIEW, true);
  } else CONSTR = false;
}

module.exports = {
  ABV: ABV,
  CONSTR: CONSTR,
  TYPED: TYPED,
  VIEW: VIEW
};

/***/ }),

/***/ "./node_modules/core-js/modules/_uid.js":
/***/ (function(module, exports) {

var id = 0;
var px = Math.random();

module.exports = function (key) {
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};

/***/ }),

/***/ "./node_modules/core-js/modules/_validate-collection.js":
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__("./node_modules/core-js/modules/_is-object.js");

module.exports = function (it, TYPE) {
  if (!isObject(it) || it._t !== TYPE) throw TypeError('Incompatible receiver, ' + TYPE + ' required!');
  return it;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_wks-define.js":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("./node_modules/core-js/modules/_global.js");

var core = __webpack_require__("./node_modules/core-js/modules/_core.js");

var LIBRARY = __webpack_require__("./node_modules/core-js/modules/_library.js");

var wksExt = __webpack_require__("./node_modules/core-js/modules/_wks-ext.js");

var defineProperty = __webpack_require__("./node_modules/core-js/modules/_object-dp.js").f;

module.exports = function (name) {
  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
  if (name.charAt(0) != '_' && !(name in $Symbol)) defineProperty($Symbol, name, {
    value: wksExt.f(name)
  });
};

/***/ }),

/***/ "./node_modules/core-js/modules/_wks-ext.js":
/***/ (function(module, exports, __webpack_require__) {

exports.f = __webpack_require__("./node_modules/core-js/modules/_wks.js");

/***/ }),

/***/ "./node_modules/core-js/modules/_wks.js":
/***/ (function(module, exports, __webpack_require__) {

var store = __webpack_require__("./node_modules/core-js/modules/_shared.js")('wks');

var uid = __webpack_require__("./node_modules/core-js/modules/_uid.js");

var Symbol = __webpack_require__("./node_modules/core-js/modules/_global.js").Symbol;

var USE_SYMBOL = typeof Symbol == 'function';

var $exports = module.exports = function (name) {
  return store[name] || (store[name] = USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
};

$exports.store = store;

/***/ }),

/***/ "./node_modules/core-js/modules/core.get-iterator-method.js":
/***/ (function(module, exports, __webpack_require__) {

var classof = __webpack_require__("./node_modules/core-js/modules/_classof.js");

var ITERATOR = __webpack_require__("./node_modules/core-js/modules/_wks.js")('iterator');

var Iterators = __webpack_require__("./node_modules/core-js/modules/_iterators.js");

module.exports = __webpack_require__("./node_modules/core-js/modules/_core.js").getIteratorMethod = function (it) {
  if (it != undefined) return it[ITERATOR] || it['@@iterator'] || Iterators[classof(it)];
};

/***/ }),

/***/ "./node_modules/core-js/modules/es6.array.copy-within.js":
/***/ (function(module, exports, __webpack_require__) {

// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)
var $export = __webpack_require__("./node_modules/core-js/modules/_export.js");

$export($export.P, 'Array', {
  copyWithin: __webpack_require__("./node_modules/core-js/modules/_array-copy-within.js")
});

__webpack_require__("./node_modules/core-js/modules/_add-to-unscopables.js")('copyWithin');

/***/ }),

/***/ "./node_modules/core-js/modules/es6.array.every.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__("./node_modules/core-js/modules/_export.js");

var $every = __webpack_require__("./node_modules/core-js/modules/_array-methods.js")(4);

$export($export.P + $export.F * !__webpack_require__("./node_modules/core-js/modules/_strict-method.js")([].every, true), 'Array', {
  // 22.1.3.5 / 15.4.4.16 Array.prototype.every(callbackfn [, thisArg])
  every: function every(callbackfn
  /* , thisArg */
  ) {
    return $every(this, callbackfn, arguments[1]);
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.array.fill.js":
/***/ (function(module, exports, __webpack_require__) {

// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)
var $export = __webpack_require__("./node_modules/core-js/modules/_export.js");

$export($export.P, 'Array', {
  fill: __webpack_require__("./node_modules/core-js/modules/_array-fill.js")
});

__webpack_require__("./node_modules/core-js/modules/_add-to-unscopables.js")('fill');

/***/ }),

/***/ "./node_modules/core-js/modules/es6.array.filter.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__("./node_modules/core-js/modules/_export.js");

var $filter = __webpack_require__("./node_modules/core-js/modules/_array-methods.js")(2);

$export($export.P + $export.F * !__webpack_require__("./node_modules/core-js/modules/_strict-method.js")([].filter, true), 'Array', {
  // 22.1.3.7 / 15.4.4.20 Array.prototype.filter(callbackfn [, thisArg])
  filter: function filter(callbackfn
  /* , thisArg */
  ) {
    return $filter(this, callbackfn, arguments[1]);
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.array.find-index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // 22.1.3.9 Array.prototype.findIndex(predicate, thisArg = undefined)

var $export = __webpack_require__("./node_modules/core-js/modules/_export.js");

var $find = __webpack_require__("./node_modules/core-js/modules/_array-methods.js")(6);

var KEY = 'findIndex';
var forced = true; // Shouldn't skip holes

if (KEY in []) Array(1)[KEY](function () {
  forced = false;
});
$export($export.P + $export.F * forced, 'Array', {
  findIndex: function findIndex(callbackfn
  /* , that = undefined */
  ) {
    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});

__webpack_require__("./node_modules/core-js/modules/_add-to-unscopables.js")(KEY);

/***/ }),

/***/ "./node_modules/core-js/modules/es6.array.find.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // 22.1.3.8 Array.prototype.find(predicate, thisArg = undefined)

var $export = __webpack_require__("./node_modules/core-js/modules/_export.js");

var $find = __webpack_require__("./node_modules/core-js/modules/_array-methods.js")(5);

var KEY = 'find';
var forced = true; // Shouldn't skip holes

if (KEY in []) Array(1)[KEY](function () {
  forced = false;
});
$export($export.P + $export.F * forced, 'Array', {
  find: function find(callbackfn
  /* , that = undefined */
  ) {
    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});

__webpack_require__("./node_modules/core-js/modules/_add-to-unscopables.js")(KEY);

/***/ }),

/***/ "./node_modules/core-js/modules/es6.array.for-each.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__("./node_modules/core-js/modules/_export.js");

var $forEach = __webpack_require__("./node_modules/core-js/modules/_array-methods.js")(0);

var STRICT = __webpack_require__("./node_modules/core-js/modules/_strict-method.js")([].forEach, true);

$export($export.P + $export.F * !STRICT, 'Array', {
  // 22.1.3.10 / 15.4.4.18 Array.prototype.forEach(callbackfn [, thisArg])
  forEach: function forEach(callbackfn
  /* , thisArg */
  ) {
    return $forEach(this, callbackfn, arguments[1]);
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.array.from.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var ctx = __webpack_require__("./node_modules/core-js/modules/_ctx.js");

var $export = __webpack_require__("./node_modules/core-js/modules/_export.js");

var toObject = __webpack_require__("./node_modules/core-js/modules/_to-object.js");

var call = __webpack_require__("./node_modules/core-js/modules/_iter-call.js");

var isArrayIter = __webpack_require__("./node_modules/core-js/modules/_is-array-iter.js");

var toLength = __webpack_require__("./node_modules/core-js/modules/_to-length.js");

var createProperty = __webpack_require__("./node_modules/core-js/modules/_create-property.js");

var getIterFn = __webpack_require__("./node_modules/core-js/modules/core.get-iterator-method.js");

$export($export.S + $export.F * !__webpack_require__("./node_modules/core-js/modules/_iter-detect.js")(function (iter) {
  Array.from(iter);
}), 'Array', {
  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
  from: function from(arrayLike
  /* , mapfn = undefined, thisArg = undefined */
  ) {
    var O = toObject(arrayLike);
    var C = typeof this == 'function' ? this : Array;
    var aLen = arguments.length;
    var mapfn = aLen > 1 ? arguments[1] : undefined;
    var mapping = mapfn !== undefined;
    var index = 0;
    var iterFn = getIterFn(O);
    var length, result, step, iterator;
    if (mapping) mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2); // if object isn't iterable or it's array with default iterator - use simple case

    if (iterFn != undefined && !(C == Array && isArrayIter(iterFn))) {
      for (iterator = iterFn.call(O), result = new C(); !(step = iterator.next()).done; index++) {
        createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], true) : step.value);
      }
    } else {
      length = toLength(O.length);

      for (result = new C(length); length > index; index++) {
        createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
      }
    }

    result.length = index;
    return result;
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.array.index-of.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__("./node_modules/core-js/modules/_export.js");

var $indexOf = __webpack_require__("./node_modules/core-js/modules/_array-includes.js")(false);

var $native = [].indexOf;
var NEGATIVE_ZERO = !!$native && 1 / [1].indexOf(1, -0) < 0;
$export($export.P + $export.F * (NEGATIVE_ZERO || !__webpack_require__("./node_modules/core-js/modules/_strict-method.js")($native)), 'Array', {
  // 22.1.3.11 / 15.4.4.14 Array.prototype.indexOf(searchElement [, fromIndex])
  indexOf: function indexOf(searchElement
  /* , fromIndex = 0 */
  ) {
    return NEGATIVE_ZERO // convert -0 to +0
    ? $native.apply(this, arguments) || 0 : $indexOf(this, searchElement, arguments[1]);
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.array.is-array.js":
/***/ (function(module, exports, __webpack_require__) {

// 22.1.2.2 / 15.4.3.2 Array.isArray(arg)
var $export = __webpack_require__("./node_modules/core-js/modules/_export.js");

$export($export.S, 'Array', {
  isArray: __webpack_require__("./node_modules/core-js/modules/_is-array.js")
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.array.iterator.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var addToUnscopables = __webpack_require__("./node_modules/core-js/modules/_add-to-unscopables.js");

var step = __webpack_require__("./node_modules/core-js/modules/_iter-step.js");

var Iterators = __webpack_require__("./node_modules/core-js/modules/_iterators.js");

var toIObject = __webpack_require__("./node_modules/core-js/modules/_to-iobject.js"); // 22.1.3.4 Array.prototype.entries()
// 22.1.3.13 Array.prototype.keys()
// 22.1.3.29 Array.prototype.values()
// 22.1.3.30 Array.prototype[@@iterator]()


module.exports = __webpack_require__("./node_modules/core-js/modules/_iter-define.js")(Array, 'Array', function (iterated, kind) {
  this._t = toIObject(iterated); // target

  this._i = 0; // next index

  this._k = kind; // kind
  // 22.1.5.2.1 %ArrayIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var kind = this._k;
  var index = this._i++;

  if (!O || index >= O.length) {
    this._t = undefined;
    return step(1);
  }

  if (kind == 'keys') return step(0, index);
  if (kind == 'values') return step(0, O[index]);
  return step(0, [index, O[index]]);
}, 'values'); // argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)

Iterators.Arguments = Iterators.Array;
addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');

/***/ }),

/***/ "./node_modules/core-js/modules/es6.array.join.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // 22.1.3.13 Array.prototype.join(separator)

var $export = __webpack_require__("./node_modules/core-js/modules/_export.js");

var toIObject = __webpack_require__("./node_modules/core-js/modules/_to-iobject.js");

var arrayJoin = [].join; // fallback for not array-like strings

$export($export.P + $export.F * (__webpack_require__("./node_modules/core-js/modules/_iobject.js") != Object || !__webpack_require__("./node_modules/core-js/modules/_strict-method.js")(arrayJoin)), 'Array', {
  join: function join(separator) {
    return arrayJoin.call(toIObject(this), separator === undefined ? ',' : separator);
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.array.last-index-of.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__("./node_modules/core-js/modules/_export.js");

var toIObject = __webpack_require__("./node_modules/core-js/modules/_to-iobject.js");

var toInteger = __webpack_require__("./node_modules/core-js/modules/_to-integer.js");

var toLength = __webpack_require__("./node_modules/core-js/modules/_to-length.js");

var $native = [].lastIndexOf;
var NEGATIVE_ZERO = !!$native && 1 / [1].lastIndexOf(1, -0) < 0;
$export($export.P + $export.F * (NEGATIVE_ZERO || !__webpack_require__("./node_modules/core-js/modules/_strict-method.js")($native)), 'Array', {
  // 22.1.3.14 / 15.4.4.15 Array.prototype.lastIndexOf(searchElement [, fromIndex])
  lastIndexOf: function lastIndexOf(searchElement
  /* , fromIndex = @[*-1] */
  ) {
    // convert -0 to +0
    if (NEGATIVE_ZERO) return $native.apply(this, arguments) || 0;
    var O = toIObject(this);
    var length = toLength(O.length);
    var index = length - 1;
    if (arguments.length > 1) index = Math.min(index, toInteger(arguments[1]));
    if (index < 0) index = length + index;

    for (; index >= 0; index--) {
      if (index in O) if (O[index] === searchElement) return index || 0;
    }

    return -1;
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.array.map.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__("./node_modules/core-js/modules/_export.js");

var $map = __webpack_require__("./node_modules/core-js/modules/_array-methods.js")(1);

$export($export.P + $export.F * !__webpack_require__("./node_modules/core-js/modules/_strict-method.js")([].map, true), 'Array', {
  // 22.1.3.15 / 15.4.4.19 Array.prototype.map(callbackfn [, thisArg])
  map: function map(callbackfn
  /* , thisArg */
  ) {
    return $map(this, callbackfn, arguments[1]);
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.array.of.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__("./node_modules/core-js/modules/_export.js");

var createProperty = __webpack_require__("./node_modules/core-js/modules/_create-property.js"); // WebKit Array.of isn't generic


$export($export.S + $export.F * __webpack_require__("./node_modules/core-js/modules/_fails.js")(function () {
  function F() {
    /* empty */
  }

  return !(Array.of.call(F) instanceof F);
}), 'Array', {
  // 22.1.2.3 Array.of( ...items)
  of: function of()
  /* ...args */
  {
    var index = 0;
    var aLen = arguments.length;
    var result = new (typeof this == 'function' ? this : Array)(aLen);

    while (aLen > index) {
      createProperty(result, index, arguments[index++]);
    }

    result.length = aLen;
    return result;
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.array.reduce-right.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__("./node_modules/core-js/modules/_export.js");

var $reduce = __webpack_require__("./node_modules/core-js/modules/_array-reduce.js");

$export($export.P + $export.F * !__webpack_require__("./node_modules/core-js/modules/_strict-method.js")([].reduceRight, true), 'Array', {
  // 22.1.3.19 / 15.4.4.22 Array.prototype.reduceRight(callbackfn [, initialValue])
  reduceRight: function reduceRight(callbackfn
  /* , initialValue */
  ) {
    return $reduce(this, callbackfn, arguments.length, arguments[1], true);
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.array.reduce.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__("./node_modules/core-js/modules/_export.js");

var $reduce = __webpack_require__("./node_modules/core-js/modules/_array-reduce.js");

$export($export.P + $export.F * !__webpack_require__("./node_modules/core-js/modules/_strict-method.js")([].reduce, true), 'Array', {
  // 22.1.3.18 / 15.4.4.21 Array.prototype.reduce(callbackfn [, initialValue])
  reduce: function reduce(callbackfn
  /* , initialValue */
  ) {
    return $reduce(this, callbackfn, arguments.length, arguments[1], false);
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.array.slice.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__("./node_modules/core-js/modules/_export.js");

var html = __webpack_require__("./node_modules/core-js/modules/_html.js");

var cof = __webpack_require__("./node_modules/core-js/modules/_cof.js");

var toAbsoluteIndex = __webpack_require__("./node_modules/core-js/modules/_to-absolute-index.js");

var toLength = __webpack_require__("./node_modules/core-js/modules/_to-length.js");

var arraySlice = [].slice; // fallback for not array-like ES3 strings and DOM objects

$export($export.P + $export.F * __webpack_require__("./node_modules/core-js/modules/_fails.js")(function () {
  if (html) arraySlice.call(html);
}), 'Array', {
  slice: function slice(begin, end) {
    var len = toLength(this.length);
    var klass = cof(this);
    end = end === undefined ? len : end;
    if (klass == 'Array') return arraySlice.call(this, begin, end);
    var start = toAbsoluteIndex(begin, len);
    var upTo = toAbsoluteIndex(end, len);
    var size = toLength(upTo - start);
    var cloned = Array(size);
    var i = 0;

    for (; i < size; i++) {
      cloned[i] = klass == 'String' ? this.charAt(start + i) : this[start + i];
    }

    return cloned;
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.array.some.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__("./node_modules/core-js/modules/_export.js");

var $some = __webpack_require__("./node_modules/core-js/modules/_array-methods.js")(3);

$export($export.P + $export.F * !__webpack_require__("./node_modules/core-js/modules/_strict-method.js")([].some, true), 'Array', {
  // 22.1.3.23 / 15.4.4.17 Array.prototype.some(callbackfn [, thisArg])
  some: function some(callbackfn
  /* , thisArg */
  ) {
    return $some(this, callbackfn, arguments[1]);
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.array.sort.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__("./node_modules/core-js/modules/_export.js");

var aFunction = __webpack_require__("./node_modules/core-js/modules/_a-function.js");

var toObject = __webpack_require__("./node_modules/core-js/modules/_to-object.js");

var fails = __webpack_require__("./node_modules/core-js/modules/_fails.js");

var $sort = [].sort;
var test = [1, 2, 3];
$export($export.P + $export.F * (fails(function () {
  // IE8-
  test.sort(undefined);
}) || !fails(function () {
  // V8 bug
  test.sort(null); // Old WebKit
}) || !__webpack_require__("./node_modules/core-js/modules/_strict-method.js")($sort)), 'Array', {
  // 22.1.3.25 Array.prototype.sort(comparefn)
  sort: function sort(comparefn) {
    return comparefn === undefined ? $sort.call(toObject(this)) : $sort.call(toObject(this), aFunction(comparefn));
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.array.species.js":
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("./node_modules/core-js/modules/_set-species.js")('Array');

/***/ }),

/***/ "./node_modules/core-js/modules/es6.date.now.js":
/***/ (function(module, exports, __webpack_require__) {

// 20.3.3.1 / 15.9.4.4 Date.now()
var $export = __webpack_require__("./node_modules/core-js/modules/_export.js");

$export($export.S, 'Date', {
  now: function now() {
    return new Date().getTime();
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.date.to-iso-string.js":
/***/ (function(module, exports, __webpack_require__) {

// 20.3.4.36 / 15.9.5.43 Date.prototype.toISOString()
var $export = __webpack_require__("./node_modules/core-js/modules/_export.js");

var toISOString = __webpack_require__("./node_modules/core-js/modules/_date-to-iso-string.js"); // PhantomJS / old WebKit has a broken implementations


$export($export.P + $export.F * (Date.prototype.toISOString !== toISOString), 'Date', {
  toISOString: toISOString
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.date.to-json.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__("./node_modules/core-js/modules/_export.js");

var toObject = __webpack_require__("./node_modules/core-js/modules/_to-object.js");

var toPrimitive = __webpack_require__("./node_modules/core-js/modules/_to-primitive.js");

$export($export.P + $export.F * __webpack_require__("./node_modules/core-js/modules/_fails.js")(function () {
  return new Date(NaN).toJSON() !== null || Date.prototype.toJSON.call({
    toISOString: function toISOString() {
      return 1;
    }
  }) !== 1;
}), 'Date', {
  // eslint-disable-next-line no-unused-vars
  toJSON: function toJSON(key) {
    var O = toObject(this);
    var pv = toPrimitive(O);
    return typeof pv == 'number' && !isFinite(pv) ? null : O.toISOString();
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.date.to-primitive.js":
/***/ (function(module, exports, __webpack_require__) {

var TO_PRIMITIVE = __webpack_require__("./node_modules/core-js/modules/_wks.js")('toPrimitive');

var proto = Date.prototype;
if (!(TO_PRIMITIVE in proto)) __webpack_require__("./node_modules/core-js/modules/_hide.js")(proto, TO_PRIMITIVE, __webpack_require__("./node_modules/core-js/modules/_date-to-primitive.js"));

/***/ }),

/***/ "./node_modules/core-js/modules/es6.date.to-string.js":
/***/ (function(module, exports, __webpack_require__) {

var DateProto = Date.prototype;
var INVALID_DATE = 'Invalid Date';
var TO_STRING = 'toString';
var $toString = DateProto[TO_STRING];
var getTime = DateProto.getTime;

if (new Date(NaN) + '' != INVALID_DATE) {
  __webpack_require__("./node_modules/core-js/modules/_redefine.js")(DateProto, TO_STRING, function toString() {
    var value = getTime.call(this); // eslint-disable-next-line no-self-compare

    return value === value ? $toString.call(this) : INVALID_DATE;
  });
}

/***/ }),

/***/ "./node_modules/core-js/modules/es6.function.bind.js":
/***/ (function(module, exports, __webpack_require__) {

// 19.2.3.2 / 15.3.4.5 Function.prototype.bind(thisArg, args...)
var $export = __webpack_require__("./node_modules/core-js/modules/_export.js");

$export($export.P, 'Function', {
  bind: __webpack_require__("./node_modules/core-js/modules/_bind.js")
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.function.has-instance.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isObject = __webpack_require__("./node_modules/core-js/modules/_is-object.js");

var getPrototypeOf = __webpack_require__("./node_modules/core-js/modules/_object-gpo.js");

var HAS_INSTANCE = __webpack_require__("./node_modules/core-js/modules/_wks.js")('hasInstance');

var FunctionProto = Function.prototype; // 19.2.3.6 Function.prototype[@@hasInstance](V)

if (!(HAS_INSTANCE in FunctionProto)) __webpack_require__("./node_modules/core-js/modules/_object-dp.js").f(FunctionProto, HAS_INSTANCE, {
  value: function value(O) {
    if (typeof this != 'function' || !isObject(O)) return false;
    if (!isObject(this.prototype)) return O instanceof this; // for environment w/o native `@@hasInstance` logic enough `instanceof`, but add this:

    while (O = getPrototypeOf(O)) {
      if (this.prototype === O) return true;
    }

    return false;
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.function.name.js":
/***/ (function(module, exports, __webpack_require__) {

var dP = __webpack_require__("./node_modules/core-js/modules/_object-dp.js").f;

var FProto = Function.prototype;
var nameRE = /^\s*function ([^ (]*)/;
var NAME = 'name'; // 19.2.4.2 name

NAME in FProto || __webpack_require__("./node_modules/core-js/modules/_descriptors.js") && dP(FProto, NAME, {
  configurable: true,
  get: function get() {
    try {
      return ('' + this).match(nameRE)[1];
    } catch (e) {
      return '';
    }
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.map.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var strong = __webpack_require__("./node_modules/core-js/modules/_collection-strong.js");

var validate = __webpack_require__("./node_modules/core-js/modules/_validate-collection.js");

var MAP = 'Map'; // 23.1 Map Objects

module.exports = __webpack_require__("./node_modules/core-js/modules/_collection.js")(MAP, function (get) {
  return function Map() {
    return get(this, arguments.length > 0 ? arguments[0] : undefined);
  };
}, {
  // 23.1.3.6 Map.prototype.get(key)
  get: function get(key) {
    var entry = strong.getEntry(validate(this, MAP), key);
    return entry && entry.v;
  },
  // 23.1.3.9 Map.prototype.set(key, value)
  set: function set(key, value) {
    return strong.def(validate(this, MAP), key === 0 ? 0 : key, value);
  }
}, strong, true);

/***/ }),

/***/ "./node_modules/core-js/modules/es6.math.acosh.js":
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.3 Math.acosh(x)
var $export = __webpack_require__("./node_modules/core-js/modules/_export.js");

var log1p = __webpack_require__("./node_modules/core-js/modules/_math-log1p.js");

var sqrt = Math.sqrt;
var $acosh = Math.acosh;
$export($export.S + $export.F * !($acosh // V8 bug: https://code.google.com/p/v8/issues/detail?id=3509
&& Math.floor($acosh(Number.MAX_VALUE)) == 710 // Tor Browser bug: Math.acosh(Infinity) -> NaN
&& $acosh(Infinity) == Infinity), 'Math', {
  acosh: function acosh(x) {
    return (x = +x) < 1 ? NaN : x > 94906265.62425156 ? Math.log(x) + Math.LN2 : log1p(x - 1 + sqrt(x - 1) * sqrt(x + 1));
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.math.asinh.js":
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.5 Math.asinh(x)
var $export = __webpack_require__("./node_modules/core-js/modules/_export.js");

var $asinh = Math.asinh;

function asinh(x) {
  return !isFinite(x = +x) || x == 0 ? x : x < 0 ? -asinh(-x) : Math.log(x + Math.sqrt(x * x + 1));
} // Tor Browser bug: Math.asinh(0) -> -0


$export($export.S + $export.F * !($asinh && 1 / $asinh(0) > 0), 'Math', {
  asinh: asinh
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.math.atanh.js":
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.7 Math.atanh(x)
var $export = __webpack_require__("./node_modules/core-js/modules/_export.js");

var $atanh = Math.atanh; // Tor Browser bug: Math.atanh(-0) -> 0

$export($export.S + $export.F * !($atanh && 1 / $atanh(-0) < 0), 'Math', {
  atanh: function atanh(x) {
    return (x = +x) == 0 ? x : Math.log((1 + x) / (1 - x)) / 2;
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.math.cbrt.js":
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.9 Math.cbrt(x)
var $export = __webpack_require__("./node_modules/core-js/modules/_export.js");

var sign = __webpack_require__("./node_modules/core-js/modules/_math-sign.js");

$export($export.S, 'Math', {
  cbrt: function cbrt(x) {
    return sign(x = +x) * Math.pow(Math.abs(x), 1 / 3);
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.math.clz32.js":
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.11 Math.clz32(x)
var $export = __webpack_require__("./node_modules/core-js/modules/_export.js");

$export($export.S, 'Math', {
  clz32: function clz32(x) {
    return (x >>>= 0) ? 31 - Math.floor(Math.log(x + 0.5) * Math.LOG2E) : 32;
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.math.cosh.js":
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.12 Math.cosh(x)
var $export = __webpack_require__("./node_modules/core-js/modules/_export.js");

var exp = Math.exp;
$export($export.S, 'Math', {
  cosh: function cosh(x) {
    return (exp(x = +x) + exp(-x)) / 2;
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.math.expm1.js":
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.14 Math.expm1(x)
var $export = __webpack_require__("./node_modules/core-js/modules/_export.js");

var $expm1 = __webpack_require__("./node_modules/core-js/modules/_math-expm1.js");

$export($export.S + $export.F * ($expm1 != Math.expm1), 'Math', {
  expm1: $expm1
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.math.fround.js":
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.16 Math.fround(x)
var $export = __webpack_require__("./node_modules/core-js/modules/_export.js");

$export($export.S, 'Math', {
  fround: __webpack_require__("./node_modules/core-js/modules/_math-fround.js")
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.math.hypot.js":
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.17 Math.hypot([value1[, value2[,  ]]])
var $export = __webpack_require__("./node_modules/core-js/modules/_export.js");

var abs = Math.abs;
$export($export.S, 'Math', {
  hypot: function hypot(value1, value2) {
    // eslint-disable-line no-unused-vars
    var sum = 0;
    var i = 0;
    var aLen = arguments.length;
    var larg = 0;
    var arg, div;

    while (i < aLen) {
      arg = abs(arguments[i++]);

      if (larg < arg) {
        div = larg / arg;
        sum = sum * div * div + 1;
        larg = arg;
      } else if (arg > 0) {
        div = arg / larg;
        sum += div * div;
      } else sum += arg;
    }

    return larg === Infinity ? Infinity : larg * Math.sqrt(sum);
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.math.imul.js":
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.18 Math.imul(x, y)
var $export = __webpack_require__("./node_modules/core-js/modules/_export.js");

var $imul = Math.imul; // some WebKit versions fails with big numbers, some has wrong arity

$export($export.S + $export.F * __webpack_require__("./node_modules/core-js/modules/_fails.js")(function () {
  return $imul(0xffffffff, 5) != -5 || $imul.length != 2;
}), 'Math', {
  imul: function imul(x, y) {
    var UINT16 = 0xffff;
    var xn = +x;
    var yn = +y;
    var xl = UINT16 & xn;
    var yl = UINT16 & yn;
    return 0 | xl * yl + ((UINT16 & xn >>> 16) * yl + xl * (UINT16 & yn >>> 16) << 16 >>> 0);
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.math.log10.js":
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.21 Math.log10(x)
var $export = __webpack_require__("./node_modules/core-js/modules/_export.js");

$export($export.S, 'Math', {
  log10: function log10(x) {
    return Math.log(x) * Math.LOG10E;
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.math.log1p.js":
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.20 Math.log1p(x)
var $export = __webpack_require__("./node_modules/core-js/modules/_export.js");

$export($export.S, 'Math', {
  log1p: __webpack_require__("./node_modules/core-js/modules/_math-log1p.js")
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.math.log2.js":
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.22 Math.log2(x)
var $export = __webpack_require__("./node_modules/core-js/modules/_export.js");

$export($export.S, 'Math', {
  log2: function log2(x) {
    return Math.log(x) / Math.LN2;
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.math.sign.js":
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.28 Math.sign(x)
var $export = __webpack_require__("./node_modules/core-js/modules/_export.js");

$export($export.S, 'Math', {
  sign: __webpack_require__("./node_modules/core-js/modules/_math-sign.js")
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.math.sinh.js":
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.30 Math.sinh(x)
var $export = __webpack_require__("./node_modules/core-js/modules/_export.js");

var expm1 = __webpack_require__("./node_modules/core-js/modules/_math-expm1.js");

var exp = Math.exp; // V8 near Chromium 38 has a problem with very small numbers

$export($export.S + $export.F * __webpack_require__("./node_modules/core-js/modules/_fails.js")(function () {
  return !Math.sinh(-2e-17) != -2e-17;
}), 'Math', {
  sinh: function sinh(x) {
    return Math.abs(x = +x) < 1 ? (expm1(x) - expm1(-x)) / 2 : (exp(x - 1) - exp(-x - 1)) * (Math.E / 2);
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.math.tanh.js":
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.33 Math.tanh(x)
var $export = __webpack_require__("./node_modules/core-js/modules/_export.js");

var expm1 = __webpack_require__("./node_modules/core-js/modules/_math-expm1.js");

var exp = Math.exp;
$export($export.S, 'Math', {
  tanh: function tanh(x) {
    var a = expm1(x = +x);
    var b = expm1(-x);
    return a == Infinity ? 1 : b == Infinity ? -1 : (a - b) / (exp(x) + exp(-x));
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.math.trunc.js":
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.34 Math.trunc(x)
var $export = __webpack_require__("./node_modules/core-js/modules/_export.js");

$export($export.S, 'Math', {
  trunc: function trunc(it) {
    return (it > 0 ? Math.floor : Math.ceil)(it);
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.number.constructor.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var global = __webpack_require__("./node_modules/core-js/modules/_global.js");

var has = __webpack_require__("./node_modules/core-js/modules/_has.js");

var cof = __webpack_require__("./node_modules/core-js/modules/_cof.js");

var inheritIfRequired = __webpack_require__("./node_modules/core-js/modules/_inherit-if-required.js");

var toPrimitive = __webpack_require__("./node_modules/core-js/modules/_to-primitive.js");

var fails = __webpack_require__("./node_modules/core-js/modules/_fails.js");

var gOPN = __webpack_require__("./node_modules/core-js/modules/_object-gopn.js").f;

var gOPD = __webpack_require__("./node_modules/core-js/modules/_object-gopd.js").f;

var dP = __webpack_require__("./node_modules/core-js/modules/_object-dp.js").f;

var $trim = __webpack_require__("./node_modules/core-js/modules/_string-trim.js").trim;

var NUMBER = 'Number';
var $Number = global[NUMBER];
var Base = $Number;
var proto = $Number.prototype; // Opera ~12 has broken Object#toString

var BROKEN_COF = cof(__webpack_require__("./node_modules/core-js/modules/_object-create.js")(proto)) == NUMBER;
var TRIM = 'trim' in String.prototype; // 7.1.3 ToNumber(argument)

var toNumber = function toNumber(argument) {
  var it = toPrimitive(argument, false);

  if (typeof it == 'string' && it.length > 2) {
    it = TRIM ? it.trim() : $trim(it, 3);
    var first = it.charCodeAt(0);
    var third, radix, maxCode;

    if (first === 43 || first === 45) {
      third = it.charCodeAt(2);
      if (third === 88 || third === 120) return NaN; // Number('+0x1') should be NaN, old V8 fix
    } else if (first === 48) {
      switch (it.charCodeAt(1)) {
        case 66:
        case 98:
          radix = 2;
          maxCode = 49;
          break;
        // fast equal /^0b[01]+$/i

        case 79:
        case 111:
          radix = 8;
          maxCode = 55;
          break;
        // fast equal /^0o[0-7]+$/i

        default:
          return +it;
      }

      for (var digits = it.slice(2), i = 0, l = digits.length, code; i < l; i++) {
        code = digits.charCodeAt(i); // parseInt parses a string to a first unavailable symbol
        // but ToNumber should return NaN if a string contains unavailable symbols

        if (code < 48 || code > maxCode) return NaN;
      }

      return parseInt(digits, radix);
    }
  }

  return +it;
};

if (!$Number(' 0o1') || !$Number('0b1') || $Number('+0x1')) {
  $Number = function Number(value) {
    var it = arguments.length < 1 ? 0 : value;
    var that = this;
    return that instanceof $Number // check on 1..constructor(foo) case
    && (BROKEN_COF ? fails(function () {
      proto.valueOf.call(that);
    }) : cof(that) != NUMBER) ? inheritIfRequired(new Base(toNumber(it)), that, $Number) : toNumber(it);
  };

  for (var keys = __webpack_require__("./node_modules/core-js/modules/_descriptors.js") ? gOPN(Base) : ( // ES3:
  'MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,' + // ES6 (in case, if modules with ES6 Number statics required before):
  'EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,' + 'MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger').split(','), j = 0, key; keys.length > j; j++) {
    if (has(Base, key = keys[j]) && !has($Number, key)) {
      dP($Number, key, gOPD(Base, key));
    }
  }

  $Number.prototype = proto;
  proto.constructor = $Number;

  __webpack_require__("./node_modules/core-js/modules/_redefine.js")(global, NUMBER, $Number);
}

/***/ }),

/***/ "./node_modules/core-js/modules/es6.number.epsilon.js":
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.1 Number.EPSILON
var $export = __webpack_require__("./node_modules/core-js/modules/_export.js");

$export($export.S, 'Number', {
  EPSILON: Math.pow(2, -52)
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.number.is-finite.js":
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.2 Number.isFinite(number)
var $export = __webpack_require__("./node_modules/core-js/modules/_export.js");

var _isFinite = __webpack_require__("./node_modules/core-js/modules/_global.js").isFinite;

$export($export.S, 'Number', {
  isFinite: function isFinite(it) {
    return typeof it == 'number' && _isFinite(it);
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.number.is-integer.js":
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.3 Number.isInteger(number)
var $export = __webpack_require__("./node_modules/core-js/modules/_export.js");

$export($export.S, 'Number', {
  isInteger: __webpack_require__("./node_modules/core-js/modules/_is-integer.js")
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.number.is-nan.js":
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.4 Number.isNaN(number)
var $export = __webpack_require__("./node_modules/core-js/modules/_export.js");

$export($export.S, 'Number', {
  isNaN: function isNaN(number) {
    // eslint-disable-next-line no-self-compare
    return number != number;
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.number.is-safe-integer.js":
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.5 Number.isSafeInteger(number)
var $export = __webpack_require__("./node_modules/core-js/modules/_export.js");

var isInteger = __webpack_require__("./node_modules/core-js/modules/_is-integer.js");

var abs = Math.abs;
$export($export.S, 'Number', {
  isSafeInteger: function isSafeInteger(number) {
    return isInteger(number) && abs(number) <= 0x1fffffffffffff;
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.number.max-safe-integer.js":
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.6 Number.MAX_SAFE_INTEGER
var $export = __webpack_require__("./node_modules/core-js/modules/_export.js");

$export($export.S, 'Number', {
  MAX_SAFE_INTEGER: 0x1fffffffffffff
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.number.min-safe-integer.js":
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.10 Number.MIN_SAFE_INTEGER
var $export = __webpack_require__("./node_modules/core-js/modules/_export.js");

$export($export.S, 'Number', {
  MIN_SAFE_INTEGER: -0x1fffffffffffff
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.number.parse-float.js":
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__("./node_modules/core-js/modules/_export.js");

var $parseFloat = __webpack_require__("./node_modules/core-js/modules/_parse-float.js"); // 20.1.2.12 Number.parseFloat(string)


$export($export.S + $export.F * (Number.parseFloat != $parseFloat), 'Number', {
  parseFloat: $parseFloat
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.number.parse-int.js":
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__("./node_modules/core-js/modules/_export.js");

var $parseInt = __webpack_require__("./node_modules/core-js/modules/_parse-int.js"); // 20.1.2.13 Number.parseInt(string, radix)


$export($export.S + $export.F * (Number.parseInt != $parseInt), 'Number', {
  parseInt: $parseInt
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.number.to-fixed.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__("./node_modules/core-js/modules/_export.js");

var toInteger = __webpack_require__("./node_modules/core-js/modules/_to-integer.js");

var aNumberValue = __webpack_require__("./node_modules/core-js/modules/_a-number-value.js");

var repeat = __webpack_require__("./node_modules/core-js/modules/_string-repeat.js");

var $toFixed = 1.0.toFixed;
var floor = Math.floor;
var data = [0, 0, 0, 0, 0, 0];
var ERROR = 'Number.toFixed: incorrect invocation!';
var ZERO = '0';

var multiply = function multiply(n, c) {
  var i = -1;
  var c2 = c;

  while (++i < 6) {
    c2 += n * data[i];
    data[i] = c2 % 1e7;
    c2 = floor(c2 / 1e7);
  }
};

var divide = function divide(n) {
  var i = 6;
  var c = 0;

  while (--i >= 0) {
    c += data[i];
    data[i] = floor(c / n);
    c = c % n * 1e7;
  }
};

var numToString = function numToString() {
  var i = 6;
  var s = '';

  while (--i >= 0) {
    if (s !== '' || i === 0 || data[i] !== 0) {
      var t = String(data[i]);
      s = s === '' ? t : s + repeat.call(ZERO, 7 - t.length) + t;
    }
  }

  return s;
};

var pow = function pow(x, n, acc) {
  return n === 0 ? acc : n % 2 === 1 ? pow(x, n - 1, acc * x) : pow(x * x, n / 2, acc);
};

var log = function log(x) {
  var n = 0;
  var x2 = x;

  while (x2 >= 4096) {
    n += 12;
    x2 /= 4096;
  }

  while (x2 >= 2) {
    n += 1;
    x2 /= 2;
  }

  return n;
};

$export($export.P + $export.F * (!!$toFixed && (0.00008.toFixed(3) !== '0.000' || 0.9.toFixed(0) !== '1' || 1.255.toFixed(2) !== '1.25' || 1000000000000000128.0.toFixed(0) !== '1000000000000000128') || !__webpack_require__("./node_modules/core-js/modules/_fails.js")(function () {
  // V8 ~ Android 4.3-
  $toFixed.call({});
})), 'Number', {
  toFixed: function toFixed(fractionDigits) {
    var x = aNumberValue(this, ERROR);
    var f = toInteger(fractionDigits);
    var s = '';
    var m = ZERO;
    var e, z, j, k;
    if (f < 0 || f > 20) throw RangeError(ERROR); // eslint-disable-next-line no-self-compare

    if (x != x) return 'NaN';
    if (x <= -1e21 || x >= 1e21) return String(x);

    if (x < 0) {
      s = '-';
      x = -x;
    }

    if (x > 1e-21) {
      e = log(x * pow(2, 69, 1)) - 69;
      z = e < 0 ? x * pow(2, -e, 1) : x / pow(2, e, 1);
      z *= 0x10000000000000;
      e = 52 - e;

      if (e > 0) {
        multiply(0, z);
        j = f;

        while (j >= 7) {
          multiply(1e7, 0);
          j -= 7;
        }

        multiply(pow(10, j, 1), 0);
        j = e - 1;

        while (j >= 23) {
          divide(1 << 23);
          j -= 23;
        }

        divide(1 << j);
        multiply(1, 1);
        divide(2);
        m = numToString();
      } else {
        multiply(0, z);
        multiply(1 << -e, 0);
        m = numToString() + repeat.call(ZERO, f);
      }
    }

    if (f > 0) {
      k = m.length;
      m = s + (k <= f ? '0.' + repeat.call(ZERO, f - k) + m : m.slice(0, k - f) + '.' + m.slice(k - f));
    } else {
      m = s + m;
    }

    return m;
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.number.to-precision.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__("./node_modules/core-js/modules/_export.js");

var $fails = __webpack_require__("./node_modules/core-js/modules/_fails.js");

var aNumberValue = __webpack_require__("./node_modules/core-js/modules/_a-number-value.js");

var $toPrecision = 1.0.toPrecision;
$export($export.P + $export.F * ($fails(function () {
  // IE7-
  return $toPrecision.call(1, undefined) !== '1';
}) || !$fails(function () {
  // V8 ~ Android 4.3-
  $toPrecision.call({});
})), 'Number', {
  toPrecision: function toPrecision(precision) {
    var that = aNumberValue(this, 'Number#toPrecision: incorrect invocation!');
    return precision === undefined ? $toPrecision.call(that) : $toPrecision.call(that, precision);
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.object.assign.js":
/***/ (function(module, exports, __webpack_require__) {

// 19.1.3.1 Object.assign(target, source)
var $export = __webpack_require__("./node_modules/core-js/modules/_export.js");

$export($export.S + $export.F, 'Object', {
  assign: __webpack_require__("./node_modules/core-js/modules/_object-assign.js")
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.object.create.js":
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__("./node_modules/core-js/modules/_export.js"); // 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])


$export($export.S, 'Object', {
  create: __webpack_require__("./node_modules/core-js/modules/_object-create.js")
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.object.define-properties.js":
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__("./node_modules/core-js/modules/_export.js"); // 19.1.2.3 / 15.2.3.7 Object.defineProperties(O, Properties)


$export($export.S + $export.F * !__webpack_require__("./node_modules/core-js/modules/_descriptors.js"), 'Object', {
  defineProperties: __webpack_require__("./node_modules/core-js/modules/_object-dps.js")
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.object.define-property.js":
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__("./node_modules/core-js/modules/_export.js"); // 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)


$export($export.S + $export.F * !__webpack_require__("./node_modules/core-js/modules/_descriptors.js"), 'Object', {
  defineProperty: __webpack_require__("./node_modules/core-js/modules/_object-dp.js").f
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.object.freeze.js":
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.5 Object.freeze(O)
var isObject = __webpack_require__("./node_modules/core-js/modules/_is-object.js");

var meta = __webpack_require__("./node_modules/core-js/modules/_meta.js").onFreeze;

__webpack_require__("./node_modules/core-js/modules/_object-sap.js")('freeze', function ($freeze) {
  return function freeze(it) {
    return $freeze && isObject(it) ? $freeze(meta(it)) : it;
  };
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.object.get-own-property-descriptor.js":
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
var toIObject = __webpack_require__("./node_modules/core-js/modules/_to-iobject.js");

var $getOwnPropertyDescriptor = __webpack_require__("./node_modules/core-js/modules/_object-gopd.js").f;

__webpack_require__("./node_modules/core-js/modules/_object-sap.js")('getOwnPropertyDescriptor', function () {
  return function getOwnPropertyDescriptor(it, key) {
    return $getOwnPropertyDescriptor(toIObject(it), key);
  };
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.object.get-own-property-names.js":
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.7 Object.getOwnPropertyNames(O)
__webpack_require__("./node_modules/core-js/modules/_object-sap.js")('getOwnPropertyNames', function () {
  return __webpack_require__("./node_modules/core-js/modules/_object-gopn-ext.js").f;
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.object.get-prototype-of.js":
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.9 Object.getPrototypeOf(O)
var toObject = __webpack_require__("./node_modules/core-js/modules/_to-object.js");

var $getPrototypeOf = __webpack_require__("./node_modules/core-js/modules/_object-gpo.js");

__webpack_require__("./node_modules/core-js/modules/_object-sap.js")('getPrototypeOf', function () {
  return function getPrototypeOf(it) {
    return $getPrototypeOf(toObject(it));
  };
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.object.is-extensible.js":
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.11 Object.isExtensible(O)
var isObject = __webpack_require__("./node_modules/core-js/modules/_is-object.js");

__webpack_require__("./node_modules/core-js/modules/_object-sap.js")('isExtensible', function ($isExtensible) {
  return function isExtensible(it) {
    return isObject(it) ? $isExtensible ? $isExtensible(it) : true : false;
  };
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.object.is-frozen.js":
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.12 Object.isFrozen(O)
var isObject = __webpack_require__("./node_modules/core-js/modules/_is-object.js");

__webpack_require__("./node_modules/core-js/modules/_object-sap.js")('isFrozen', function ($isFrozen) {
  return function isFrozen(it) {
    return isObject(it) ? $isFrozen ? $isFrozen(it) : false : true;
  };
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.object.is-sealed.js":
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.13 Object.isSealed(O)
var isObject = __webpack_require__("./node_modules/core-js/modules/_is-object.js");

__webpack_require__("./node_modules/core-js/modules/_object-sap.js")('isSealed', function ($isSealed) {
  return function isSealed(it) {
    return isObject(it) ? $isSealed ? $isSealed(it) : false : true;
  };
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.object.is.js":
/***/ (function(module, exports, __webpack_require__) {

// 19.1.3.10 Object.is(value1, value2)
var $export = __webpack_require__("./node_modules/core-js/modules/_export.js");

$export($export.S, 'Object', {
  is: __webpack_require__("./node_modules/core-js/modules/_same-value.js")
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.object.keys.js":
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.14 Object.keys(O)
var toObject = __webpack_require__("./node_modules/core-js/modules/_to-object.js");

var $keys = __webpack_require__("./node_modules/core-js/modules/_object-keys.js");

__webpack_require__("./node_modules/core-js/modules/_object-sap.js")('keys', function () {
  return function keys(it) {
    return $keys(toObject(it));
  };
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.object.prevent-extensions.js":
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.15 Object.preventExtensions(O)
var isObject = __webpack_require__("./node_modules/core-js/modules/_is-object.js");

var meta = __webpack_require__("./node_modules/core-js/modules/_meta.js").onFreeze;

__webpack_require__("./node_modules/core-js/modules/_object-sap.js")('preventExtensions', function ($preventExtensions) {
  return function preventExtensions(it) {
    return $preventExtensions && isObject(it) ? $preventExtensions(meta(it)) : it;
  };
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.object.seal.js":
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.17 Object.seal(O)
var isObject = __webpack_require__("./node_modules/core-js/modules/_is-object.js");

var meta = __webpack_require__("./node_modules/core-js/modules/_meta.js").onFreeze;

__webpack_require__("./node_modules/core-js/modules/_object-sap.js")('seal', function ($seal) {
  return function seal(it) {
    return $seal && isObject(it) ? $seal(meta(it)) : it;
  };
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.object.set-prototype-of.js":
/***/ (function(module, exports, __webpack_require__) {

// 19.1.3.19 Object.setPrototypeOf(O, proto)
var $export = __webpack_require__("./node_modules/core-js/modules/_export.js");

$export($export.S, 'Object', {
  setPrototypeOf: __webpack_require__("./node_modules/core-js/modules/_set-proto.js").set
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.object.to-string.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // 19.1.3.6 Object.prototype.toString()

var classof = __webpack_require__("./node_modules/core-js/modules/_classof.js");

var test = {};
test[__webpack_require__("./node_modules/core-js/modules/_wks.js")('toStringTag')] = 'z';

if (test + '' != '[object z]') {
  __webpack_require__("./node_modules/core-js/modules/_redefine.js")(Object.prototype, 'toString', function toString() {
    return '[object ' + classof(this) + ']';
  }, true);
}

/***/ }),

/***/ "./node_modules/core-js/modules/es6.parse-float.js":
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__("./node_modules/core-js/modules/_export.js");

var $parseFloat = __webpack_require__("./node_modules/core-js/modules/_parse-float.js"); // 18.2.4 parseFloat(string)


$export($export.G + $export.F * (parseFloat != $parseFloat), {
  parseFloat: $parseFloat
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.parse-int.js":
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__("./node_modules/core-js/modules/_export.js");

var $parseInt = __webpack_require__("./node_modules/core-js/modules/_parse-int.js"); // 18.2.5 parseInt(string, radix)


$export($export.G + $export.F * (parseInt != $parseInt), {
  parseInt: $parseInt
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.promise.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var LIBRARY = __webpack_require__("./node_modules/core-js/modules/_library.js");

var global = __webpack_require__("./node_modules/core-js/modules/_global.js");

var ctx = __webpack_require__("./node_modules/core-js/modules/_ctx.js");

var classof = __webpack_require__("./node_modules/core-js/modules/_classof.js");

var $export = __webpack_require__("./node_modules/core-js/modules/_export.js");

var isObject = __webpack_require__("./node_modules/core-js/modules/_is-object.js");

var aFunction = __webpack_require__("./node_modules/core-js/modules/_a-function.js");

var anInstance = __webpack_require__("./node_modules/core-js/modules/_an-instance.js");

var forOf = __webpack_require__("./node_modules/core-js/modules/_for-of.js");

var speciesConstructor = __webpack_require__("./node_modules/core-js/modules/_species-constructor.js");

var task = __webpack_require__("./node_modules/core-js/modules/_task.js").set;

var microtask = __webpack_require__("./node_modules/core-js/modules/_microtask.js")();

var newPromiseCapabilityModule = __webpack_require__("./node_modules/core-js/modules/_new-promise-capability.js");

var perform = __webpack_require__("./node_modules/core-js/modules/_perform.js");

var promiseResolve = __webpack_require__("./node_modules/core-js/modules/_promise-resolve.js");

var PROMISE = 'Promise';
var TypeError = global.TypeError;
var process = global.process;
var $Promise = global[PROMISE];
var isNode = classof(process) == 'process';

var empty = function empty() {
  /* empty */
};

var Internal, newGenericPromiseCapability, OwnPromiseCapability, Wrapper;
var newPromiseCapability = newGenericPromiseCapability = newPromiseCapabilityModule.f;
var USE_NATIVE = !!function () {
  try {
    // correct subclassing with @@species support
    var promise = $Promise.resolve(1);

    var FakePromise = (promise.constructor = {})[__webpack_require__("./node_modules/core-js/modules/_wks.js")('species')] = function (exec) {
      exec(empty, empty);
    }; // unhandled rejections tracking support, NodeJS Promise without it fails @@species test


    return (isNode || typeof PromiseRejectionEvent == 'function') && promise.then(empty) instanceof FakePromise;
  } catch (e) {
    /* empty */
  }
}(); // helpers

var isThenable = function isThenable(it) {
  var then;
  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
};

var notify = function notify(promise, isReject) {
  if (promise._n) return;
  promise._n = true;
  var chain = promise._c;
  microtask(function () {
    var value = promise._v;
    var ok = promise._s == 1;
    var i = 0;

    var run = function run(reaction) {
      var handler = ok ? reaction.ok : reaction.fail;
      var resolve = reaction.resolve;
      var reject = reaction.reject;
      var domain = reaction.domain;
      var result, then;

      try {
        if (handler) {
          if (!ok) {
            if (promise._h == 2) onHandleUnhandled(promise);
            promise._h = 1;
          }

          if (handler === true) result = value;else {
            if (domain) domain.enter();
            result = handler(value);
            if (domain) domain.exit();
          }

          if (result === reaction.promise) {
            reject(TypeError('Promise-chain cycle'));
          } else if (then = isThenable(result)) {
            then.call(result, resolve, reject);
          } else resolve(result);
        } else reject(value);
      } catch (e) {
        reject(e);
      }
    };

    while (chain.length > i) {
      run(chain[i++]);
    } // variable length - can't use forEach


    promise._c = [];
    promise._n = false;
    if (isReject && !promise._h) onUnhandled(promise);
  });
};

var onUnhandled = function onUnhandled(promise) {
  task.call(global, function () {
    var value = promise._v;
    var unhandled = isUnhandled(promise);
    var result, handler, console;

    if (unhandled) {
      result = perform(function () {
        if (isNode) {
          process.emit('unhandledRejection', value, promise);
        } else if (handler = global.onunhandledrejection) {
          handler({
            promise: promise,
            reason: value
          });
        } else if ((console = global.console) && console.error) {
          console.error('Unhandled promise rejection', value);
        }
      }); // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should

      promise._h = isNode || isUnhandled(promise) ? 2 : 1;
    }

    promise._a = undefined;
    if (unhandled && result.e) throw result.v;
  });
};

var isUnhandled = function isUnhandled(promise) {
  if (promise._h == 1) return false;
  var chain = promise._a || promise._c;
  var i = 0;
  var reaction;

  while (chain.length > i) {
    reaction = chain[i++];
    if (reaction.fail || !isUnhandled(reaction.promise)) return false;
  }

  return true;
};

var onHandleUnhandled = function onHandleUnhandled(promise) {
  task.call(global, function () {
    var handler;

    if (isNode) {
      process.emit('rejectionHandled', promise);
    } else if (handler = global.onrejectionhandled) {
      handler({
        promise: promise,
        reason: promise._v
      });
    }
  });
};

var $reject = function $reject(value) {
  var promise = this;
  if (promise._d) return;
  promise._d = true;
  promise = promise._w || promise; // unwrap

  promise._v = value;
  promise._s = 2;
  if (!promise._a) promise._a = promise._c.slice();
  notify(promise, true);
};

var $resolve = function $resolve(value) {
  var promise = this;
  var then;
  if (promise._d) return;
  promise._d = true;
  promise = promise._w || promise; // unwrap

  try {
    if (promise === value) throw TypeError("Promise can't be resolved itself");

    if (then = isThenable(value)) {
      microtask(function () {
        var wrapper = {
          _w: promise,
          _d: false
        }; // wrap

        try {
          then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
        } catch (e) {
          $reject.call(wrapper, e);
        }
      });
    } else {
      promise._v = value;
      promise._s = 1;
      notify(promise, false);
    }
  } catch (e) {
    $reject.call({
      _w: promise,
      _d: false
    }, e); // wrap
  }
}; // constructor polyfill


if (!USE_NATIVE) {
  // 25.4.3.1 Promise(executor)
  $Promise = function Promise(executor) {
    anInstance(this, $Promise, PROMISE, '_h');
    aFunction(executor);
    Internal.call(this);

    try {
      executor(ctx($resolve, this, 1), ctx($reject, this, 1));
    } catch (err) {
      $reject.call(this, err);
    }
  }; // eslint-disable-next-line no-unused-vars


  Internal = function Promise(executor) {
    this._c = []; // <- awaiting reactions

    this._a = undefined; // <- checked in isUnhandled reactions

    this._s = 0; // <- state

    this._d = false; // <- done

    this._v = undefined; // <- value

    this._h = 0; // <- rejection state, 0 - default, 1 - handled, 2 - unhandled

    this._n = false; // <- notify
  };

  Internal.prototype = __webpack_require__("./node_modules/core-js/modules/_redefine-all.js")($Promise.prototype, {
    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
    then: function then(onFulfilled, onRejected) {
      var reaction = newPromiseCapability(speciesConstructor(this, $Promise));
      reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;
      reaction.fail = typeof onRejected == 'function' && onRejected;
      reaction.domain = isNode ? process.domain : undefined;

      this._c.push(reaction);

      if (this._a) this._a.push(reaction);
      if (this._s) notify(this, false);
      return reaction.promise;
    },
    // 25.4.5.1 Promise.prototype.catch(onRejected)
    'catch': function _catch(onRejected) {
      return this.then(undefined, onRejected);
    }
  });

  OwnPromiseCapability = function OwnPromiseCapability() {
    var promise = new Internal();
    this.promise = promise;
    this.resolve = ctx($resolve, promise, 1);
    this.reject = ctx($reject, promise, 1);
  };

  newPromiseCapabilityModule.f = newPromiseCapability = function newPromiseCapability(C) {
    return C === $Promise || C === Wrapper ? new OwnPromiseCapability(C) : newGenericPromiseCapability(C);
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, {
  Promise: $Promise
});

__webpack_require__("./node_modules/core-js/modules/_set-to-string-tag.js")($Promise, PROMISE);

__webpack_require__("./node_modules/core-js/modules/_set-species.js")(PROMISE);

Wrapper = __webpack_require__("./node_modules/core-js/modules/_core.js")[PROMISE]; // statics

$export($export.S + $export.F * !USE_NATIVE, PROMISE, {
  // 25.4.4.5 Promise.reject(r)
  reject: function reject(r) {
    var capability = newPromiseCapability(this);
    var $$reject = capability.reject;
    $$reject(r);
    return capability.promise;
  }
});
$export($export.S + $export.F * (LIBRARY || !USE_NATIVE), PROMISE, {
  // 25.4.4.6 Promise.resolve(x)
  resolve: function resolve(x) {
    return promiseResolve(LIBRARY && this === Wrapper ? $Promise : this, x);
  }
});
$export($export.S + $export.F * !(USE_NATIVE && __webpack_require__("./node_modules/core-js/modules/_iter-detect.js")(function (iter) {
  $Promise.all(iter)['catch'](empty);
})), PROMISE, {
  // 25.4.4.1 Promise.all(iterable)
  all: function all(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var resolve = capability.resolve;
    var reject = capability.reject;
    var result = perform(function () {
      var values = [];
      var index = 0;
      var remaining = 1;
      forOf(iterable, false, function (promise) {
        var $index = index++;
        var alreadyCalled = false;
        values.push(undefined);
        remaining++;
        C.resolve(promise).then(function (value) {
          if (alreadyCalled) return;
          alreadyCalled = true;
          values[$index] = value;
          --remaining || resolve(values);
        }, reject);
      });
      --remaining || resolve(values);
    });
    if (result.e) reject(result.v);
    return capability.promise;
  },
  // 25.4.4.4 Promise.race(iterable)
  race: function race(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var reject = capability.reject;
    var result = perform(function () {
      forOf(iterable, false, function (promise) {
        C.resolve(promise).then(capability.resolve, reject);
      });
    });
    if (result.e) reject(result.v);
    return capability.promise;
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.reflect.apply.js":
/***/ (function(module, exports, __webpack_require__) {

// 26.1.1 Reflect.apply(target, thisArgument, argumentsList)
var $export = __webpack_require__("./node_modules/core-js/modules/_export.js");

var aFunction = __webpack_require__("./node_modules/core-js/modules/_a-function.js");

var anObject = __webpack_require__("./node_modules/core-js/modules/_an-object.js");

var rApply = (__webpack_require__("./node_modules/core-js/modules/_global.js").Reflect || {}).apply;
var fApply = Function.apply; // MS Edge argumentsList argument is optional

$export($export.S + $export.F * !__webpack_require__("./node_modules/core-js/modules/_fails.js")(function () {
  rApply(function () {
    /* empty */
  });
}), 'Reflect', {
  apply: function apply(target, thisArgument, argumentsList) {
    var T = aFunction(target);
    var L = anObject(argumentsList);
    return rApply ? rApply(T, thisArgument, L) : fApply.call(T, thisArgument, L);
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.reflect.construct.js":
/***/ (function(module, exports, __webpack_require__) {

// 26.1.2 Reflect.construct(target, argumentsList [, newTarget])
var $export = __webpack_require__("./node_modules/core-js/modules/_export.js");

var create = __webpack_require__("./node_modules/core-js/modules/_object-create.js");

var aFunction = __webpack_require__("./node_modules/core-js/modules/_a-function.js");

var anObject = __webpack_require__("./node_modules/core-js/modules/_an-object.js");

var isObject = __webpack_require__("./node_modules/core-js/modules/_is-object.js");

var fails = __webpack_require__("./node_modules/core-js/modules/_fails.js");

var bind = __webpack_require__("./node_modules/core-js/modules/_bind.js");

var rConstruct = (__webpack_require__("./node_modules/core-js/modules/_global.js").Reflect || {}).construct; // MS Edge supports only 2 arguments and argumentsList argument is optional
// FF Nightly sets third argument as `new.target`, but does not create `this` from it

var NEW_TARGET_BUG = fails(function () {
  function F() {
    /* empty */
  }

  return !(rConstruct(function () {
    /* empty */
  }, [], F) instanceof F);
});
var ARGS_BUG = !fails(function () {
  rConstruct(function () {
    /* empty */
  });
});
$export($export.S + $export.F * (NEW_TARGET_BUG || ARGS_BUG), 'Reflect', {
  construct: function construct(Target, args
  /* , newTarget */
  ) {
    aFunction(Target);
    anObject(args);
    var newTarget = arguments.length < 3 ? Target : aFunction(arguments[2]);
    if (ARGS_BUG && !NEW_TARGET_BUG) return rConstruct(Target, args, newTarget);

    if (Target == newTarget) {
      // w/o altered newTarget, optimization for 0-4 arguments
      switch (args.length) {
        case 0:
          return new Target();

        case 1:
          return new Target(args[0]);

        case 2:
          return new Target(args[0], args[1]);

        case 3:
          return new Target(args[0], args[1], args[2]);

        case 4:
          return new Target(args[0], args[1], args[2], args[3]);
      } // w/o altered newTarget, lot of arguments case


      var $args = [null];
      $args.push.apply($args, args);
      return new (bind.apply(Target, $args))();
    } // with altered newTarget, not support built-in constructors


    var proto = newTarget.prototype;
    var instance = create(isObject(proto) ? proto : Object.prototype);
    var result = Function.apply.call(Target, instance, args);
    return isObject(result) ? result : instance;
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.reflect.define-property.js":
/***/ (function(module, exports, __webpack_require__) {

// 26.1.3 Reflect.defineProperty(target, propertyKey, attributes)
var dP = __webpack_require__("./node_modules/core-js/modules/_object-dp.js");

var $export = __webpack_require__("./node_modules/core-js/modules/_export.js");

var anObject = __webpack_require__("./node_modules/core-js/modules/_an-object.js");

var toPrimitive = __webpack_require__("./node_modules/core-js/modules/_to-primitive.js"); // MS Edge has broken Reflect.defineProperty - throwing instead of returning false


$export($export.S + $export.F * __webpack_require__("./node_modules/core-js/modules/_fails.js")(function () {
  // eslint-disable-next-line no-undef
  Reflect.defineProperty(dP.f({}, 1, {
    value: 1
  }), 1, {
    value: 2
  });
}), 'Reflect', {
  defineProperty: function defineProperty(target, propertyKey, attributes) {
    anObject(target);
    propertyKey = toPrimitive(propertyKey, true);
    anObject(attributes);

    try {
      dP.f(target, propertyKey, attributes);
      return true;
    } catch (e) {
      return false;
    }
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.reflect.delete-property.js":
/***/ (function(module, exports, __webpack_require__) {

// 26.1.4 Reflect.deleteProperty(target, propertyKey)
var $export = __webpack_require__("./node_modules/core-js/modules/_export.js");

var gOPD = __webpack_require__("./node_modules/core-js/modules/_object-gopd.js").f;

var anObject = __webpack_require__("./node_modules/core-js/modules/_an-object.js");

$export($export.S, 'Reflect', {
  deleteProperty: function deleteProperty(target, propertyKey) {
    var desc = gOPD(anObject(target), propertyKey);
    return desc && !desc.configurable ? false : delete target[propertyKey];
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.reflect.enumerate.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // 26.1.5 Reflect.enumerate(target)

var $export = __webpack_require__("./node_modules/core-js/modules/_export.js");

var anObject = __webpack_require__("./node_modules/core-js/modules/_an-object.js");

var Enumerate = function Enumerate(iterated) {
  this._t = anObject(iterated); // target

  this._i = 0; // next index

  var keys = this._k = []; // keys

  var key;

  for (key in iterated) {
    keys.push(key);
  }
};

__webpack_require__("./node_modules/core-js/modules/_iter-create.js")(Enumerate, 'Object', function () {
  var that = this;
  var keys = that._k;
  var key;

  do {
    if (that._i >= keys.length) return {
      value: undefined,
      done: true
    };
  } while (!((key = keys[that._i++]) in that._t));

  return {
    value: key,
    done: false
  };
});

$export($export.S, 'Reflect', {
  enumerate: function enumerate(target) {
    return new Enumerate(target);
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.reflect.get-own-property-descriptor.js":
/***/ (function(module, exports, __webpack_require__) {

// 26.1.7 Reflect.getOwnPropertyDescriptor(target, propertyKey)
var gOPD = __webpack_require__("./node_modules/core-js/modules/_object-gopd.js");

var $export = __webpack_require__("./node_modules/core-js/modules/_export.js");

var anObject = __webpack_require__("./node_modules/core-js/modules/_an-object.js");

$export($export.S, 'Reflect', {
  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(target, propertyKey) {
    return gOPD.f(anObject(target), propertyKey);
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.reflect.get-prototype-of.js":
/***/ (function(module, exports, __webpack_require__) {

// 26.1.8 Reflect.getPrototypeOf(target)
var $export = __webpack_require__("./node_modules/core-js/modules/_export.js");

var getProto = __webpack_require__("./node_modules/core-js/modules/_object-gpo.js");

var anObject = __webpack_require__("./node_modules/core-js/modules/_an-object.js");

$export($export.S, 'Reflect', {
  getPrototypeOf: function getPrototypeOf(target) {
    return getProto(anObject(target));
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.reflect.get.js":
/***/ (function(module, exports, __webpack_require__) {

// 26.1.6 Reflect.get(target, propertyKey [, receiver])
var gOPD = __webpack_require__("./node_modules/core-js/modules/_object-gopd.js");

var getPrototypeOf = __webpack_require__("./node_modules/core-js/modules/_object-gpo.js");

var has = __webpack_require__("./node_modules/core-js/modules/_has.js");

var $export = __webpack_require__("./node_modules/core-js/modules/_export.js");

var isObject = __webpack_require__("./node_modules/core-js/modules/_is-object.js");

var anObject = __webpack_require__("./node_modules/core-js/modules/_an-object.js");

function get(target, propertyKey
/* , receiver */
) {
  var receiver = arguments.length < 3 ? target : arguments[2];
  var desc, proto;
  if (anObject(target) === receiver) return target[propertyKey];
  if (desc = gOPD.f(target, propertyKey)) return has(desc, 'value') ? desc.value : desc.get !== undefined ? desc.get.call(receiver) : undefined;
  if (isObject(proto = getPrototypeOf(target))) return get(proto, propertyKey, receiver);
}

$export($export.S, 'Reflect', {
  get: get
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.reflect.has.js":
/***/ (function(module, exports, __webpack_require__) {

// 26.1.9 Reflect.has(target, propertyKey)
var $export = __webpack_require__("./node_modules/core-js/modules/_export.js");

$export($export.S, 'Reflect', {
  has: function has(target, propertyKey) {
    return propertyKey in target;
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.reflect.is-extensible.js":
/***/ (function(module, exports, __webpack_require__) {

// 26.1.10 Reflect.isExtensible(target)
var $export = __webpack_require__("./node_modules/core-js/modules/_export.js");

var anObject = __webpack_require__("./node_modules/core-js/modules/_an-object.js");

var $isExtensible = Object.isExtensible;
$export($export.S, 'Reflect', {
  isExtensible: function isExtensible(target) {
    anObject(target);
    return $isExtensible ? $isExtensible(target) : true;
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.reflect.own-keys.js":
/***/ (function(module, exports, __webpack_require__) {

// 26.1.11 Reflect.ownKeys(target)
var $export = __webpack_require__("./node_modules/core-js/modules/_export.js");

$export($export.S, 'Reflect', {
  ownKeys: __webpack_require__("./node_modules/core-js/modules/_own-keys.js")
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.reflect.prevent-extensions.js":
/***/ (function(module, exports, __webpack_require__) {

// 26.1.12 Reflect.preventExtensions(target)
var $export = __webpack_require__("./node_modules/core-js/modules/_export.js");

var anObject = __webpack_require__("./node_modules/core-js/modules/_an-object.js");

var $preventExtensions = Object.preventExtensions;
$export($export.S, 'Reflect', {
  preventExtensions: function preventExtensions(target) {
    anObject(target);

    try {
      if ($preventExtensions) $preventExtensions(target);
      return true;
    } catch (e) {
      return false;
    }
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.reflect.set-prototype-of.js":
/***/ (function(module, exports, __webpack_require__) {

// 26.1.14 Reflect.setPrototypeOf(target, proto)
var $export = __webpack_require__("./node_modules/core-js/modules/_export.js");

var setProto = __webpack_require__("./node_modules/core-js/modules/_set-proto.js");

if (setProto) $export($export.S, 'Reflect', {
  setPrototypeOf: function setPrototypeOf(target, proto) {
    setProto.check(target, proto);

    try {
      setProto.set(target, proto);
      return true;
    } catch (e) {
      return false;
    }
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.reflect.set.js":
/***/ (function(module, exports, __webpack_require__) {

// 26.1.13 Reflect.set(target, propertyKey, V [, receiver])
var dP = __webpack_require__("./node_modules/core-js/modules/_object-dp.js");

var gOPD = __webpack_require__("./node_modules/core-js/modules/_object-gopd.js");

var getPrototypeOf = __webpack_require__("./node_modules/core-js/modules/_object-gpo.js");

var has = __webpack_require__("./node_modules/core-js/modules/_has.js");

var $export = __webpack_require__("./node_modules/core-js/modules/_export.js");

var createDesc = __webpack_require__("./node_modules/core-js/modules/_property-desc.js");

var anObject = __webpack_require__("./node_modules/core-js/modules/_an-object.js");

var isObject = __webpack_require__("./node_modules/core-js/modules/_is-object.js");

function set(target, propertyKey, V
/* , receiver */
) {
  var receiver = arguments.length < 4 ? target : arguments[3];
  var ownDesc = gOPD.f(anObject(target), propertyKey);
  var existingDescriptor, proto;

  if (!ownDesc) {
    if (isObject(proto = getPrototypeOf(target))) {
      return set(proto, propertyKey, V, receiver);
    }

    ownDesc = createDesc(0);
  }

  if (has(ownDesc, 'value')) {
    if (ownDesc.writable === false || !isObject(receiver)) return false;
    existingDescriptor = gOPD.f(receiver, propertyKey) || createDesc(0);
    existingDescriptor.value = V;
    dP.f(receiver, propertyKey, existingDescriptor);
    return true;
  }

  return ownDesc.set === undefined ? false : (ownDesc.set.call(receiver, V), true);
}

$export($export.S, 'Reflect', {
  set: set
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.regexp.constructor.js":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("./node_modules/core-js/modules/_global.js");

var inheritIfRequired = __webpack_require__("./node_modules/core-js/modules/_inherit-if-required.js");

var dP = __webpack_require__("./node_modules/core-js/modules/_object-dp.js").f;

var gOPN = __webpack_require__("./node_modules/core-js/modules/_object-gopn.js").f;

var isRegExp = __webpack_require__("./node_modules/core-js/modules/_is-regexp.js");

var $flags = __webpack_require__("./node_modules/core-js/modules/_flags.js");

var $RegExp = global.RegExp;
var Base = $RegExp;
var proto = $RegExp.prototype;
var re1 = /a/g;
var re2 = /a/g; // "new" creates a new object, old webkit buggy here

var CORRECT_NEW = new $RegExp(re1) !== re1;

if (__webpack_require__("./node_modules/core-js/modules/_descriptors.js") && (!CORRECT_NEW || __webpack_require__("./node_modules/core-js/modules/_fails.js")(function () {
  re2[__webpack_require__("./node_modules/core-js/modules/_wks.js")('match')] = false; // RegExp constructor can alter flags and IsRegExp works correct with @@match

  return $RegExp(re1) != re1 || $RegExp(re2) == re2 || $RegExp(re1, 'i') != '/a/i';
}))) {
  $RegExp = function RegExp(p, f) {
    var tiRE = this instanceof $RegExp;
    var piRE = isRegExp(p);
    var fiU = f === undefined;
    return !tiRE && piRE && p.constructor === $RegExp && fiU ? p : inheritIfRequired(CORRECT_NEW ? new Base(piRE && !fiU ? p.source : p, f) : Base((piRE = p instanceof $RegExp) ? p.source : p, piRE && fiU ? $flags.call(p) : f), tiRE ? this : proto, $RegExp);
  };

  var proxy = function proxy(key) {
    key in $RegExp || dP($RegExp, key, {
      configurable: true,
      get: function get() {
        return Base[key];
      },
      set: function set(it) {
        Base[key] = it;
      }
    });
  };

  for (var keys = gOPN(Base), i = 0; keys.length > i;) {
    proxy(keys[i++]);
  }

  proto.constructor = $RegExp;
  $RegExp.prototype = proto;

  __webpack_require__("./node_modules/core-js/modules/_redefine.js")(global, 'RegExp', $RegExp);
}

__webpack_require__("./node_modules/core-js/modules/_set-species.js")('RegExp');

/***/ }),

/***/ "./node_modules/core-js/modules/es6.regexp.flags.js":
/***/ (function(module, exports, __webpack_require__) {

// 21.2.5.3 get RegExp.prototype.flags()
if (__webpack_require__("./node_modules/core-js/modules/_descriptors.js") && /./g.flags != 'g') __webpack_require__("./node_modules/core-js/modules/_object-dp.js").f(RegExp.prototype, 'flags', {
  configurable: true,
  get: __webpack_require__("./node_modules/core-js/modules/_flags.js")
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.regexp.match.js":
/***/ (function(module, exports, __webpack_require__) {

// @@match logic
__webpack_require__("./node_modules/core-js/modules/_fix-re-wks.js")('match', 1, function (defined, MATCH, $match) {
  // 21.1.3.11 String.prototype.match(regexp)
  return [function match(regexp) {
    'use strict';

    var O = defined(this);
    var fn = regexp == undefined ? undefined : regexp[MATCH];
    return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[MATCH](String(O));
  }, $match];
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.regexp.replace.js":
/***/ (function(module, exports, __webpack_require__) {

// @@replace logic
__webpack_require__("./node_modules/core-js/modules/_fix-re-wks.js")('replace', 2, function (defined, REPLACE, $replace) {
  // 21.1.3.14 String.prototype.replace(searchValue, replaceValue)
  return [function replace(searchValue, replaceValue) {
    'use strict';

    var O = defined(this);
    var fn = searchValue == undefined ? undefined : searchValue[REPLACE];
    return fn !== undefined ? fn.call(searchValue, O, replaceValue) : $replace.call(String(O), searchValue, replaceValue);
  }, $replace];
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.regexp.search.js":
/***/ (function(module, exports, __webpack_require__) {

// @@search logic
__webpack_require__("./node_modules/core-js/modules/_fix-re-wks.js")('search', 1, function (defined, SEARCH, $search) {
  // 21.1.3.15 String.prototype.search(regexp)
  return [function search(regexp) {
    'use strict';

    var O = defined(this);
    var fn = regexp == undefined ? undefined : regexp[SEARCH];
    return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[SEARCH](String(O));
  }, $search];
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.regexp.split.js":
/***/ (function(module, exports, __webpack_require__) {

// @@split logic
__webpack_require__("./node_modules/core-js/modules/_fix-re-wks.js")('split', 2, function (defined, SPLIT, $split) {
  'use strict';

  var isRegExp = __webpack_require__("./node_modules/core-js/modules/_is-regexp.js");

  var _split = $split;
  var $push = [].push;
  var $SPLIT = 'split';
  var LENGTH = 'length';
  var LAST_INDEX = 'lastIndex';

  if ('abbc'[$SPLIT](/(b)*/)[1] == 'c' || 'test'[$SPLIT](/(?:)/, -1)[LENGTH] != 4 || 'ab'[$SPLIT](/(?:ab)*/)[LENGTH] != 2 || '.'[$SPLIT](/(.?)(.?)/)[LENGTH] != 4 || '.'[$SPLIT](/()()/)[LENGTH] > 1 || ''[$SPLIT](/.?/)[LENGTH]) {
    var NPCG = /()??/.exec('')[1] === undefined; // nonparticipating capturing group
    // based on es5-shim implementation, need to rework it

    $split = function $split(separator, limit) {
      var string = String(this);
      if (separator === undefined && limit === 0) return []; // If `separator` is not a regex, use native split

      if (!isRegExp(separator)) return _split.call(string, separator, limit);
      var output = [];
      var flags = (separator.ignoreCase ? 'i' : '') + (separator.multiline ? 'm' : '') + (separator.unicode ? 'u' : '') + (separator.sticky ? 'y' : '');
      var lastLastIndex = 0;
      var splitLimit = limit === undefined ? 4294967295 : limit >>> 0; // Make `global` and avoid `lastIndex` issues by working with a copy

      var separatorCopy = new RegExp(separator.source, flags + 'g');
      var separator2, match, lastIndex, lastLength, i; // Doesn't need flags gy, but they don't hurt

      if (!NPCG) separator2 = new RegExp('^' + separatorCopy.source + '$(?!\\s)', flags);

      while (match = separatorCopy.exec(string)) {
        // `separatorCopy.lastIndex` is not reliable cross-browser
        lastIndex = match.index + match[0][LENGTH];

        if (lastIndex > lastLastIndex) {
          output.push(string.slice(lastLastIndex, match.index)); // Fix browsers whose `exec` methods don't consistently return `undefined` for NPCG
          // eslint-disable-next-line no-loop-func

          if (!NPCG && match[LENGTH] > 1) match[0].replace(separator2, function () {
            for (i = 1; i < arguments[LENGTH] - 2; i++) {
              if (arguments[i] === undefined) match[i] = undefined;
            }
          });
          if (match[LENGTH] > 1 && match.index < string[LENGTH]) $push.apply(output, match.slice(1));
          lastLength = match[0][LENGTH];
          lastLastIndex = lastIndex;
          if (output[LENGTH] >= splitLimit) break;
        }

        if (separatorCopy[LAST_INDEX] === match.index) separatorCopy[LAST_INDEX]++; // Avoid an infinite loop
      }

      if (lastLastIndex === string[LENGTH]) {
        if (lastLength || !separatorCopy.test('')) output.push('');
      } else output.push(string.slice(lastLastIndex));

      return output[LENGTH] > splitLimit ? output.slice(0, splitLimit) : output;
    }; // Chakra, V8

  } else if ('0'[$SPLIT](undefined, 0)[LENGTH]) {
    $split = function $split(separator, limit) {
      return separator === undefined && limit === 0 ? [] : _split.call(this, separator, limit);
    };
  } // 21.1.3.17 String.prototype.split(separator, limit)


  return [function split(separator, limit) {
    var O = defined(this);
    var fn = separator == undefined ? undefined : separator[SPLIT];
    return fn !== undefined ? fn.call(separator, O, limit) : $split.call(String(O), separator, limit);
  }, $split];
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.regexp.to-string.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__("./node_modules/core-js/modules/es6.regexp.flags.js");

var anObject = __webpack_require__("./node_modules/core-js/modules/_an-object.js");

var $flags = __webpack_require__("./node_modules/core-js/modules/_flags.js");

var DESCRIPTORS = __webpack_require__("./node_modules/core-js/modules/_descriptors.js");

var TO_STRING = 'toString';
var $toString = /./[TO_STRING];

var define = function define(fn) {
  __webpack_require__("./node_modules/core-js/modules/_redefine.js")(RegExp.prototype, TO_STRING, fn, true);
}; // 21.2.5.14 RegExp.prototype.toString()


if (__webpack_require__("./node_modules/core-js/modules/_fails.js")(function () {
  return $toString.call({
    source: 'a',
    flags: 'b'
  }) != '/a/b';
})) {
  define(function toString() {
    var R = anObject(this);
    return '/'.concat(R.source, '/', 'flags' in R ? R.flags : !DESCRIPTORS && R instanceof RegExp ? $flags.call(R) : undefined);
  }); // FF44- RegExp#toString has a wrong name
} else if ($toString.name != TO_STRING) {
  define(function toString() {
    return $toString.call(this);
  });
}

/***/ }),

/***/ "./node_modules/core-js/modules/es6.set.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var strong = __webpack_require__("./node_modules/core-js/modules/_collection-strong.js");

var validate = __webpack_require__("./node_modules/core-js/modules/_validate-collection.js");

var SET = 'Set'; // 23.2 Set Objects

module.exports = __webpack_require__("./node_modules/core-js/modules/_collection.js")(SET, function (get) {
  return function Set() {
    return get(this, arguments.length > 0 ? arguments[0] : undefined);
  };
}, {
  // 23.2.3.1 Set.prototype.add(value)
  add: function add(value) {
    return strong.def(validate(this, SET), value = value === 0 ? 0 : value, value);
  }
}, strong);

/***/ }),

/***/ "./node_modules/core-js/modules/es6.string.anchor.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // B.2.3.2 String.prototype.anchor(name)

__webpack_require__("./node_modules/core-js/modules/_string-html.js")('anchor', function (createHTML) {
  return function anchor(name) {
    return createHTML(this, 'a', 'name', name);
  };
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.string.big.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // B.2.3.3 String.prototype.big()

__webpack_require__("./node_modules/core-js/modules/_string-html.js")('big', function (createHTML) {
  return function big() {
    return createHTML(this, 'big', '', '');
  };
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.string.blink.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // B.2.3.4 String.prototype.blink()

__webpack_require__("./node_modules/core-js/modules/_string-html.js")('blink', function (createHTML) {
  return function blink() {
    return createHTML(this, 'blink', '', '');
  };
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.string.bold.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // B.2.3.5 String.prototype.bold()

__webpack_require__("./node_modules/core-js/modules/_string-html.js")('bold', function (createHTML) {
  return function bold() {
    return createHTML(this, 'b', '', '');
  };
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.string.code-point-at.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__("./node_modules/core-js/modules/_export.js");

var $at = __webpack_require__("./node_modules/core-js/modules/_string-at.js")(false);

$export($export.P, 'String', {
  // 21.1.3.3 String.prototype.codePointAt(pos)
  codePointAt: function codePointAt(pos) {
    return $at(this, pos);
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.string.ends-with.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// 21.1.3.6 String.prototype.endsWith(searchString [, endPosition])


var $export = __webpack_require__("./node_modules/core-js/modules/_export.js");

var toLength = __webpack_require__("./node_modules/core-js/modules/_to-length.js");

var context = __webpack_require__("./node_modules/core-js/modules/_string-context.js");

var ENDS_WITH = 'endsWith';
var $endsWith = ''[ENDS_WITH];
$export($export.P + $export.F * __webpack_require__("./node_modules/core-js/modules/_fails-is-regexp.js")(ENDS_WITH), 'String', {
  endsWith: function endsWith(searchString
  /* , endPosition = @length */
  ) {
    var that = context(this, searchString, ENDS_WITH);
    var endPosition = arguments.length > 1 ? arguments[1] : undefined;
    var len = toLength(that.length);
    var end = endPosition === undefined ? len : Math.min(toLength(endPosition), len);
    var search = String(searchString);
    return $endsWith ? $endsWith.call(that, search, end) : that.slice(end - search.length, end) === search;
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.string.fixed.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // B.2.3.6 String.prototype.fixed()

__webpack_require__("./node_modules/core-js/modules/_string-html.js")('fixed', function (createHTML) {
  return function fixed() {
    return createHTML(this, 'tt', '', '');
  };
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.string.fontcolor.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // B.2.3.7 String.prototype.fontcolor(color)

__webpack_require__("./node_modules/core-js/modules/_string-html.js")('fontcolor', function (createHTML) {
  return function fontcolor(color) {
    return createHTML(this, 'font', 'color', color);
  };
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.string.fontsize.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // B.2.3.8 String.prototype.fontsize(size)

__webpack_require__("./node_modules/core-js/modules/_string-html.js")('fontsize', function (createHTML) {
  return function fontsize(size) {
    return createHTML(this, 'font', 'size', size);
  };
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.string.from-code-point.js":
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__("./node_modules/core-js/modules/_export.js");

var toAbsoluteIndex = __webpack_require__("./node_modules/core-js/modules/_to-absolute-index.js");

var fromCharCode = String.fromCharCode;
var $fromCodePoint = String.fromCodePoint; // length should be 1, old FF problem

$export($export.S + $export.F * (!!$fromCodePoint && $fromCodePoint.length != 1), 'String', {
  // 21.1.2.2 String.fromCodePoint(...codePoints)
  fromCodePoint: function fromCodePoint(x) {
    // eslint-disable-line no-unused-vars
    var res = [];
    var aLen = arguments.length;
    var i = 0;
    var code;

    while (aLen > i) {
      code = +arguments[i++];
      if (toAbsoluteIndex(code, 0x10ffff) !== code) throw RangeError(code + ' is not a valid code point');
      res.push(code < 0x10000 ? fromCharCode(code) : fromCharCode(((code -= 0x10000) >> 10) + 0xd800, code % 0x400 + 0xdc00));
    }

    return res.join('');
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.string.includes.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// 21.1.3.7 String.prototype.includes(searchString, position = 0)


var $export = __webpack_require__("./node_modules/core-js/modules/_export.js");

var context = __webpack_require__("./node_modules/core-js/modules/_string-context.js");

var INCLUDES = 'includes';
$export($export.P + $export.F * __webpack_require__("./node_modules/core-js/modules/_fails-is-regexp.js")(INCLUDES), 'String', {
  includes: function includes(searchString
  /* , position = 0 */
  ) {
    return !!~context(this, searchString, INCLUDES).indexOf(searchString, arguments.length > 1 ? arguments[1] : undefined);
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.string.italics.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // B.2.3.9 String.prototype.italics()

__webpack_require__("./node_modules/core-js/modules/_string-html.js")('italics', function (createHTML) {
  return function italics() {
    return createHTML(this, 'i', '', '');
  };
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.string.iterator.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $at = __webpack_require__("./node_modules/core-js/modules/_string-at.js")(true); // 21.1.3.27 String.prototype[@@iterator]()


__webpack_require__("./node_modules/core-js/modules/_iter-define.js")(String, 'String', function (iterated) {
  this._t = String(iterated); // target

  this._i = 0; // next index
  // 21.1.5.2.1 %StringIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var index = this._i;
  var point;
  if (index >= O.length) return {
    value: undefined,
    done: true
  };
  point = $at(O, index);
  this._i += point.length;
  return {
    value: point,
    done: false
  };
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.string.link.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // B.2.3.10 String.prototype.link(url)

__webpack_require__("./node_modules/core-js/modules/_string-html.js")('link', function (createHTML) {
  return function link(url) {
    return createHTML(this, 'a', 'href', url);
  };
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.string.raw.js":
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__("./node_modules/core-js/modules/_export.js");

var toIObject = __webpack_require__("./node_modules/core-js/modules/_to-iobject.js");

var toLength = __webpack_require__("./node_modules/core-js/modules/_to-length.js");

$export($export.S, 'String', {
  // 21.1.2.4 String.raw(callSite, ...substitutions)
  raw: function raw(callSite) {
    var tpl = toIObject(callSite.raw);
    var len = toLength(tpl.length);
    var aLen = arguments.length;
    var res = [];
    var i = 0;

    while (len > i) {
      res.push(String(tpl[i++]));
      if (i < aLen) res.push(String(arguments[i]));
    }

    return res.join('');
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.string.repeat.js":
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__("./node_modules/core-js/modules/_export.js");

$export($export.P, 'String', {
  // 21.1.3.13 String.prototype.repeat(count)
  repeat: __webpack_require__("./node_modules/core-js/modules/_string-repeat.js")
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.string.small.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // B.2.3.11 String.prototype.small()

__webpack_require__("./node_modules/core-js/modules/_string-html.js")('small', function (createHTML) {
  return function small() {
    return createHTML(this, 'small', '', '');
  };
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.string.starts-with.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// 21.1.3.18 String.prototype.startsWith(searchString [, position ])


var $export = __webpack_require__("./node_modules/core-js/modules/_export.js");

var toLength = __webpack_require__("./node_modules/core-js/modules/_to-length.js");

var context = __webpack_require__("./node_modules/core-js/modules/_string-context.js");

var STARTS_WITH = 'startsWith';
var $startsWith = ''[STARTS_WITH];
$export($export.P + $export.F * __webpack_require__("./node_modules/core-js/modules/_fails-is-regexp.js")(STARTS_WITH), 'String', {
  startsWith: function startsWith(searchString
  /* , position = 0 */
  ) {
    var that = context(this, searchString, STARTS_WITH);
    var index = toLength(Math.min(arguments.length > 1 ? arguments[1] : undefined, that.length));
    var search = String(searchString);
    return $startsWith ? $startsWith.call(that, search, index) : that.slice(index, index + search.length) === search;
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.string.strike.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // B.2.3.12 String.prototype.strike()

__webpack_require__("./node_modules/core-js/modules/_string-html.js")('strike', function (createHTML) {
  return function strike() {
    return createHTML(this, 'strike', '', '');
  };
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.string.sub.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // B.2.3.13 String.prototype.sub()

__webpack_require__("./node_modules/core-js/modules/_string-html.js")('sub', function (createHTML) {
  return function sub() {
    return createHTML(this, 'sub', '', '');
  };
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.string.sup.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // B.2.3.14 String.prototype.sup()

__webpack_require__("./node_modules/core-js/modules/_string-html.js")('sup', function (createHTML) {
  return function sup() {
    return createHTML(this, 'sup', '', '');
  };
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.string.trim.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // 21.1.3.25 String.prototype.trim()

__webpack_require__("./node_modules/core-js/modules/_string-trim.js")('trim', function ($trim) {
  return function trim() {
    return $trim(this, 3);
  };
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.symbol.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // ECMAScript 6 symbols shim

var global = __webpack_require__("./node_modules/core-js/modules/_global.js");

var has = __webpack_require__("./node_modules/core-js/modules/_has.js");

var DESCRIPTORS = __webpack_require__("./node_modules/core-js/modules/_descriptors.js");

var $export = __webpack_require__("./node_modules/core-js/modules/_export.js");

var redefine = __webpack_require__("./node_modules/core-js/modules/_redefine.js");

var META = __webpack_require__("./node_modules/core-js/modules/_meta.js").KEY;

var $fails = __webpack_require__("./node_modules/core-js/modules/_fails.js");

var shared = __webpack_require__("./node_modules/core-js/modules/_shared.js");

var setToStringTag = __webpack_require__("./node_modules/core-js/modules/_set-to-string-tag.js");

var uid = __webpack_require__("./node_modules/core-js/modules/_uid.js");

var wks = __webpack_require__("./node_modules/core-js/modules/_wks.js");

var wksExt = __webpack_require__("./node_modules/core-js/modules/_wks-ext.js");

var wksDefine = __webpack_require__("./node_modules/core-js/modules/_wks-define.js");

var enumKeys = __webpack_require__("./node_modules/core-js/modules/_enum-keys.js");

var isArray = __webpack_require__("./node_modules/core-js/modules/_is-array.js");

var anObject = __webpack_require__("./node_modules/core-js/modules/_an-object.js");

var toIObject = __webpack_require__("./node_modules/core-js/modules/_to-iobject.js");

var toPrimitive = __webpack_require__("./node_modules/core-js/modules/_to-primitive.js");

var createDesc = __webpack_require__("./node_modules/core-js/modules/_property-desc.js");

var _create = __webpack_require__("./node_modules/core-js/modules/_object-create.js");

var gOPNExt = __webpack_require__("./node_modules/core-js/modules/_object-gopn-ext.js");

var $GOPD = __webpack_require__("./node_modules/core-js/modules/_object-gopd.js");

var $DP = __webpack_require__("./node_modules/core-js/modules/_object-dp.js");

var $keys = __webpack_require__("./node_modules/core-js/modules/_object-keys.js");

var gOPD = $GOPD.f;
var dP = $DP.f;
var gOPN = gOPNExt.f;
var $Symbol = global.Symbol;
var $JSON = global.JSON;

var _stringify = $JSON && $JSON.stringify;

var PROTOTYPE = 'prototype';
var HIDDEN = wks('_hidden');
var TO_PRIMITIVE = wks('toPrimitive');
var isEnum = {}.propertyIsEnumerable;
var SymbolRegistry = shared('symbol-registry');
var AllSymbols = shared('symbols');
var OPSymbols = shared('op-symbols');
var ObjectProto = Object[PROTOTYPE];
var USE_NATIVE = typeof $Symbol == 'function';
var QObject = global.QObject; // Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173

var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild; // fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687

var setSymbolDesc = DESCRIPTORS && $fails(function () {
  return _create(dP({}, 'a', {
    get: function get() {
      return dP(this, 'a', {
        value: 7
      }).a;
    }
  })).a != 7;
}) ? function (it, key, D) {
  var protoDesc = gOPD(ObjectProto, key);
  if (protoDesc) delete ObjectProto[key];
  dP(it, key, D);
  if (protoDesc && it !== ObjectProto) dP(ObjectProto, key, protoDesc);
} : dP;

var wrap = function wrap(tag) {
  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);

  sym._k = tag;
  return sym;
};

var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function (it) {
  return typeof it == 'symbol';
} : function (it) {
  return it instanceof $Symbol;
};

var $defineProperty = function defineProperty(it, key, D) {
  if (it === ObjectProto) $defineProperty(OPSymbols, key, D);
  anObject(it);
  key = toPrimitive(key, true);
  anObject(D);

  if (has(AllSymbols, key)) {
    if (!D.enumerable) {
      if (!has(it, HIDDEN)) dP(it, HIDDEN, createDesc(1, {}));
      it[HIDDEN][key] = true;
    } else {
      if (has(it, HIDDEN) && it[HIDDEN][key]) it[HIDDEN][key] = false;
      D = _create(D, {
        enumerable: createDesc(0, false)
      });
    }

    return setSymbolDesc(it, key, D);
  }

  return dP(it, key, D);
};

var $defineProperties = function defineProperties(it, P) {
  anObject(it);
  var keys = enumKeys(P = toIObject(P));
  var i = 0;
  var l = keys.length;
  var key;

  while (l > i) {
    $defineProperty(it, key = keys[i++], P[key]);
  }

  return it;
};

var $create = function create(it, P) {
  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
};

var $propertyIsEnumerable = function propertyIsEnumerable(key) {
  var E = isEnum.call(this, key = toPrimitive(key, true));
  if (this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return false;
  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
};

var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {
  it = toIObject(it);
  key = toPrimitive(key, true);
  if (it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return;
  var D = gOPD(it, key);
  if (D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) D.enumerable = true;
  return D;
};

var $getOwnPropertyNames = function getOwnPropertyNames(it) {
  var names = gOPN(toIObject(it));
  var result = [];
  var i = 0;
  var key;

  while (names.length > i) {
    if (!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META) result.push(key);
  }

  return result;
};

var $getOwnPropertySymbols = function getOwnPropertySymbols(it) {
  var IS_OP = it === ObjectProto;
  var names = gOPN(IS_OP ? OPSymbols : toIObject(it));
  var result = [];
  var i = 0;
  var key;

  while (names.length > i) {
    if (has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true)) result.push(AllSymbols[key]);
  }

  return result;
}; // 19.4.1.1 Symbol([description])


if (!USE_NATIVE) {
  $Symbol = function Symbol() {
    if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor!');
    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);

    var $set = function $set(value) {
      if (this === ObjectProto) $set.call(OPSymbols, value);
      if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
      setSymbolDesc(this, tag, createDesc(1, value));
    };

    if (DESCRIPTORS && setter) setSymbolDesc(ObjectProto, tag, {
      configurable: true,
      set: $set
    });
    return wrap(tag);
  };

  redefine($Symbol[PROTOTYPE], 'toString', function toString() {
    return this._k;
  });
  $GOPD.f = $getOwnPropertyDescriptor;
  $DP.f = $defineProperty;
  __webpack_require__("./node_modules/core-js/modules/_object-gopn.js").f = gOPNExt.f = $getOwnPropertyNames;
  __webpack_require__("./node_modules/core-js/modules/_object-pie.js").f = $propertyIsEnumerable;
  __webpack_require__("./node_modules/core-js/modules/_object-gops.js").f = $getOwnPropertySymbols;

  if (DESCRIPTORS && !__webpack_require__("./node_modules/core-js/modules/_library.js")) {
    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
  }

  wksExt.f = function (name) {
    return wrap(wks(name));
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, {
  Symbol: $Symbol
});

for (var es6Symbols = // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'.split(','), j = 0; es6Symbols.length > j;) {
  wks(es6Symbols[j++]);
}

for (var wellKnownSymbols = $keys(wks.store), k = 0; wellKnownSymbols.length > k;) {
  wksDefine(wellKnownSymbols[k++]);
}

$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {
  // 19.4.2.1 Symbol.for(key)
  'for': function _for(key) {
    return has(SymbolRegistry, key += '') ? SymbolRegistry[key] : SymbolRegistry[key] = $Symbol(key);
  },
  // 19.4.2.5 Symbol.keyFor(sym)
  keyFor: function keyFor(sym) {
    if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol!');

    for (var key in SymbolRegistry) {
      if (SymbolRegistry[key] === sym) return key;
    }
  },
  useSetter: function useSetter() {
    setter = true;
  },
  useSimple: function useSimple() {
    setter = false;
  }
});
$export($export.S + $export.F * !USE_NATIVE, 'Object', {
  // 19.1.2.2 Object.create(O [, Properties])
  create: $create,
  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
  defineProperty: $defineProperty,
  // 19.1.2.3 Object.defineProperties(O, Properties)
  defineProperties: $defineProperties,
  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
  // 19.1.2.7 Object.getOwnPropertyNames(O)
  getOwnPropertyNames: $getOwnPropertyNames,
  // 19.1.2.8 Object.getOwnPropertySymbols(O)
  getOwnPropertySymbols: $getOwnPropertySymbols
}); // 24.3.2 JSON.stringify(value [, replacer [, space]])

$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function () {
  var S = $Symbol(); // MS Edge converts symbol values to JSON as {}
  // WebKit converts symbol values to JSON as null
  // V8 throws on boxed symbols

  return _stringify([S]) != '[null]' || _stringify({
    a: S
  }) != '{}' || _stringify(Object(S)) != '{}';
})), 'JSON', {
  stringify: function stringify(it) {
    if (it === undefined || isSymbol(it)) return; // IE8 returns string on undefined

    var args = [it];
    var i = 1;
    var replacer, $replacer;

    while (arguments.length > i) {
      args.push(arguments[i++]);
    }

    replacer = args[1];
    if (typeof replacer == 'function') $replacer = replacer;
    if ($replacer || !isArray(replacer)) replacer = function replacer(key, value) {
      if ($replacer) value = $replacer.call(this, key, value);
      if (!isSymbol(value)) return value;
    };
    args[1] = replacer;
    return _stringify.apply($JSON, args);
  }
}); // 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)

$Symbol[PROTOTYPE][TO_PRIMITIVE] || __webpack_require__("./node_modules/core-js/modules/_hide.js")($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf); // 19.4.3.5 Symbol.prototype[@@toStringTag]

setToStringTag($Symbol, 'Symbol'); // 20.2.1.9 Math[@@toStringTag]

setToStringTag(Math, 'Math', true); // 24.3.3 JSON[@@toStringTag]

setToStringTag(global.JSON, 'JSON', true);

/***/ }),

/***/ "./node_modules/core-js/modules/es6.typed.array-buffer.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__("./node_modules/core-js/modules/_export.js");

var $typed = __webpack_require__("./node_modules/core-js/modules/_typed.js");

var buffer = __webpack_require__("./node_modules/core-js/modules/_typed-buffer.js");

var anObject = __webpack_require__("./node_modules/core-js/modules/_an-object.js");

var toAbsoluteIndex = __webpack_require__("./node_modules/core-js/modules/_to-absolute-index.js");

var toLength = __webpack_require__("./node_modules/core-js/modules/_to-length.js");

var isObject = __webpack_require__("./node_modules/core-js/modules/_is-object.js");

var ArrayBuffer = __webpack_require__("./node_modules/core-js/modules/_global.js").ArrayBuffer;

var speciesConstructor = __webpack_require__("./node_modules/core-js/modules/_species-constructor.js");

var $ArrayBuffer = buffer.ArrayBuffer;
var $DataView = buffer.DataView;
var $isView = $typed.ABV && ArrayBuffer.isView;
var $slice = $ArrayBuffer.prototype.slice;
var VIEW = $typed.VIEW;
var ARRAY_BUFFER = 'ArrayBuffer';
$export($export.G + $export.W + $export.F * (ArrayBuffer !== $ArrayBuffer), {
  ArrayBuffer: $ArrayBuffer
});
$export($export.S + $export.F * !$typed.CONSTR, ARRAY_BUFFER, {
  // 24.1.3.1 ArrayBuffer.isView(arg)
  isView: function isView(it) {
    return $isView && $isView(it) || isObject(it) && VIEW in it;
  }
});
$export($export.P + $export.U + $export.F * __webpack_require__("./node_modules/core-js/modules/_fails.js")(function () {
  return !new $ArrayBuffer(2).slice(1, undefined).byteLength;
}), ARRAY_BUFFER, {
  // 24.1.4.3 ArrayBuffer.prototype.slice(start, end)
  slice: function slice(start, end) {
    if ($slice !== undefined && end === undefined) return $slice.call(anObject(this), start); // FF fix

    var len = anObject(this).byteLength;
    var first = toAbsoluteIndex(start, len);
    var final = toAbsoluteIndex(end === undefined ? len : end, len);
    var result = new (speciesConstructor(this, $ArrayBuffer))(toLength(final - first));
    var viewS = new $DataView(this);
    var viewT = new $DataView(result);
    var index = 0;

    while (first < final) {
      viewT.setUint8(index++, viewS.getUint8(first++));
    }

    return result;
  }
});

__webpack_require__("./node_modules/core-js/modules/_set-species.js")(ARRAY_BUFFER);

/***/ }),

/***/ "./node_modules/core-js/modules/es6.typed.data-view.js":
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__("./node_modules/core-js/modules/_export.js");

$export($export.G + $export.W + $export.F * !__webpack_require__("./node_modules/core-js/modules/_typed.js").ABV, {
  DataView: __webpack_require__("./node_modules/core-js/modules/_typed-buffer.js").DataView
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.typed.float32-array.js":
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("./node_modules/core-js/modules/_typed-array.js")('Float32', 4, function (init) {
  return function Float32Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.typed.float64-array.js":
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("./node_modules/core-js/modules/_typed-array.js")('Float64', 8, function (init) {
  return function Float64Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.typed.int16-array.js":
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("./node_modules/core-js/modules/_typed-array.js")('Int16', 2, function (init) {
  return function Int16Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.typed.int32-array.js":
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("./node_modules/core-js/modules/_typed-array.js")('Int32', 4, function (init) {
  return function Int32Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.typed.int8-array.js":
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("./node_modules/core-js/modules/_typed-array.js")('Int8', 1, function (init) {
  return function Int8Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.typed.uint16-array.js":
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("./node_modules/core-js/modules/_typed-array.js")('Uint16', 2, function (init) {
  return function Uint16Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.typed.uint32-array.js":
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("./node_modules/core-js/modules/_typed-array.js")('Uint32', 4, function (init) {
  return function Uint32Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.typed.uint8-array.js":
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("./node_modules/core-js/modules/_typed-array.js")('Uint8', 1, function (init) {
  return function Uint8Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.typed.uint8-clamped-array.js":
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("./node_modules/core-js/modules/_typed-array.js")('Uint8', 1, function (init) {
  return function Uint8ClampedArray(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
}, true);

/***/ }),

/***/ "./node_modules/core-js/modules/es6.weak-map.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var each = __webpack_require__("./node_modules/core-js/modules/_array-methods.js")(0);

var redefine = __webpack_require__("./node_modules/core-js/modules/_redefine.js");

var meta = __webpack_require__("./node_modules/core-js/modules/_meta.js");

var assign = __webpack_require__("./node_modules/core-js/modules/_object-assign.js");

var weak = __webpack_require__("./node_modules/core-js/modules/_collection-weak.js");

var isObject = __webpack_require__("./node_modules/core-js/modules/_is-object.js");

var fails = __webpack_require__("./node_modules/core-js/modules/_fails.js");

var validate = __webpack_require__("./node_modules/core-js/modules/_validate-collection.js");

var WEAK_MAP = 'WeakMap';
var getWeak = meta.getWeak;
var isExtensible = Object.isExtensible;
var uncaughtFrozenStore = weak.ufstore;
var tmp = {};
var InternalMap;

var wrapper = function wrapper(get) {
  return function WeakMap() {
    return get(this, arguments.length > 0 ? arguments[0] : undefined);
  };
};

var methods = {
  // 23.3.3.3 WeakMap.prototype.get(key)
  get: function get(key) {
    if (isObject(key)) {
      var data = getWeak(key);
      if (data === true) return uncaughtFrozenStore(validate(this, WEAK_MAP)).get(key);
      return data ? data[this._i] : undefined;
    }
  },
  // 23.3.3.5 WeakMap.prototype.set(key, value)
  set: function set(key, value) {
    return weak.def(validate(this, WEAK_MAP), key, value);
  }
}; // 23.3 WeakMap Objects

var $WeakMap = module.exports = __webpack_require__("./node_modules/core-js/modules/_collection.js")(WEAK_MAP, wrapper, methods, weak, true, true); // IE11 WeakMap frozen keys fix


if (fails(function () {
  return new $WeakMap().set((Object.freeze || Object)(tmp), 7).get(tmp) != 7;
})) {
  InternalMap = weak.getConstructor(wrapper, WEAK_MAP);
  assign(InternalMap.prototype, methods);
  meta.NEED = true;
  each(['delete', 'has', 'get', 'set'], function (key) {
    var proto = $WeakMap.prototype;
    var method = proto[key];
    redefine(proto, key, function (a, b) {
      // store frozen objects on internal weakmap shim
      if (isObject(a) && !isExtensible(a)) {
        if (!this._f) this._f = new InternalMap();

        var result = this._f[key](a, b);

        return key == 'set' ? this : result; // store all the rest on native weakmap
      }

      return method.call(this, a, b);
    });
  });
}

/***/ }),

/***/ "./node_modules/core-js/modules/es6.weak-set.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var weak = __webpack_require__("./node_modules/core-js/modules/_collection-weak.js");

var validate = __webpack_require__("./node_modules/core-js/modules/_validate-collection.js");

var WEAK_SET = 'WeakSet'; // 23.4 WeakSet Objects

__webpack_require__("./node_modules/core-js/modules/_collection.js")(WEAK_SET, function (get) {
  return function WeakSet() {
    return get(this, arguments.length > 0 ? arguments[0] : undefined);
  };
}, {
  // 23.4.3.1 WeakSet.prototype.add(value)
  add: function add(value) {
    return weak.def(validate(this, WEAK_SET), value, true);
  }
}, weak, false, true);

/***/ }),

/***/ "./node_modules/core-js/modules/es7.array.flat-map.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // https://tc39.github.io/proposal-flatMap/#sec-Array.prototype.flatMap

var $export = __webpack_require__("./node_modules/core-js/modules/_export.js");

var flattenIntoArray = __webpack_require__("./node_modules/core-js/modules/_flatten-into-array.js");

var toObject = __webpack_require__("./node_modules/core-js/modules/_to-object.js");

var toLength = __webpack_require__("./node_modules/core-js/modules/_to-length.js");

var aFunction = __webpack_require__("./node_modules/core-js/modules/_a-function.js");

var arraySpeciesCreate = __webpack_require__("./node_modules/core-js/modules/_array-species-create.js");

$export($export.P, 'Array', {
  flatMap: function flatMap(callbackfn
  /* , thisArg */
  ) {
    var O = toObject(this);
    var sourceLen, A;
    aFunction(callbackfn);
    sourceLen = toLength(O.length);
    A = arraySpeciesCreate(O, 0);
    flattenIntoArray(A, O, O, sourceLen, 0, 1, callbackfn, arguments[1]);
    return A;
  }
});

__webpack_require__("./node_modules/core-js/modules/_add-to-unscopables.js")('flatMap');

/***/ }),

/***/ "./node_modules/core-js/modules/es7.array.flatten.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // https://tc39.github.io/proposal-flatMap/#sec-Array.prototype.flatten

var $export = __webpack_require__("./node_modules/core-js/modules/_export.js");

var flattenIntoArray = __webpack_require__("./node_modules/core-js/modules/_flatten-into-array.js");

var toObject = __webpack_require__("./node_modules/core-js/modules/_to-object.js");

var toLength = __webpack_require__("./node_modules/core-js/modules/_to-length.js");

var toInteger = __webpack_require__("./node_modules/core-js/modules/_to-integer.js");

var arraySpeciesCreate = __webpack_require__("./node_modules/core-js/modules/_array-species-create.js");

$export($export.P, 'Array', {
  flatten: function flatten()
  /* depthArg = 1 */
  {
    var depthArg = arguments[0];
    var O = toObject(this);
    var sourceLen = toLength(O.length);
    var A = arraySpeciesCreate(O, 0);
    flattenIntoArray(A, O, O, sourceLen, 0, depthArg === undefined ? 1 : toInteger(depthArg));
    return A;
  }
});

__webpack_require__("./node_modules/core-js/modules/_add-to-unscopables.js")('flatten');

/***/ }),

/***/ "./node_modules/core-js/modules/es7.array.includes.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // https://github.com/tc39/Array.prototype.includes

var $export = __webpack_require__("./node_modules/core-js/modules/_export.js");

var $includes = __webpack_require__("./node_modules/core-js/modules/_array-includes.js")(true);

$export($export.P, 'Array', {
  includes: function includes(el
  /* , fromIndex = 0 */
  ) {
    return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);
  }
});

__webpack_require__("./node_modules/core-js/modules/_add-to-unscopables.js")('includes');

/***/ }),

/***/ "./node_modules/core-js/modules/es7.asap.js":
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/rwaldron/tc39-notes/blob/master/es6/2014-09/sept-25.md#510-globalasap-for-enqueuing-a-microtask
var $export = __webpack_require__("./node_modules/core-js/modules/_export.js");

var microtask = __webpack_require__("./node_modules/core-js/modules/_microtask.js")();

var process = __webpack_require__("./node_modules/core-js/modules/_global.js").process;

var isNode = __webpack_require__("./node_modules/core-js/modules/_cof.js")(process) == 'process';
$export($export.G, {
  asap: function asap(fn) {
    var domain = isNode && process.domain;
    microtask(domain ? domain.bind(fn) : fn);
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es7.error.is-error.js":
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/ljharb/proposal-is-error
var $export = __webpack_require__("./node_modules/core-js/modules/_export.js");

var cof = __webpack_require__("./node_modules/core-js/modules/_cof.js");

$export($export.S, 'Error', {
  isError: function isError(it) {
    return cof(it) === 'Error';
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es7.global.js":
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/tc39/proposal-global
var $export = __webpack_require__("./node_modules/core-js/modules/_export.js");

$export($export.G, {
  global: __webpack_require__("./node_modules/core-js/modules/_global.js")
});

/***/ }),

/***/ "./node_modules/core-js/modules/es7.map.from.js":
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/proposal-setmap-offrom/#sec-map.from
__webpack_require__("./node_modules/core-js/modules/_set-collection-from.js")('Map');

/***/ }),

/***/ "./node_modules/core-js/modules/es7.map.of.js":
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/proposal-setmap-offrom/#sec-map.of
__webpack_require__("./node_modules/core-js/modules/_set-collection-of.js")('Map');

/***/ }),

/***/ "./node_modules/core-js/modules/es7.map.to-json.js":
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var $export = __webpack_require__("./node_modules/core-js/modules/_export.js");

$export($export.P + $export.R, 'Map', {
  toJSON: __webpack_require__("./node_modules/core-js/modules/_collection-to-json.js")('Map')
});

/***/ }),

/***/ "./node_modules/core-js/modules/es7.math.clamp.js":
/***/ (function(module, exports, __webpack_require__) {

// https://rwaldron.github.io/proposal-math-extensions/
var $export = __webpack_require__("./node_modules/core-js/modules/_export.js");

$export($export.S, 'Math', {
  clamp: function clamp(x, lower, upper) {
    return Math.min(upper, Math.max(lower, x));
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es7.math.deg-per-rad.js":
/***/ (function(module, exports, __webpack_require__) {

// https://rwaldron.github.io/proposal-math-extensions/
var $export = __webpack_require__("./node_modules/core-js/modules/_export.js");

$export($export.S, 'Math', {
  DEG_PER_RAD: Math.PI / 180
});

/***/ }),

/***/ "./node_modules/core-js/modules/es7.math.degrees.js":
/***/ (function(module, exports, __webpack_require__) {

// https://rwaldron.github.io/proposal-math-extensions/
var $export = __webpack_require__("./node_modules/core-js/modules/_export.js");

var RAD_PER_DEG = 180 / Math.PI;
$export($export.S, 'Math', {
  degrees: function degrees(radians) {
    return radians * RAD_PER_DEG;
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es7.math.fscale.js":
/***/ (function(module, exports, __webpack_require__) {

// https://rwaldron.github.io/proposal-math-extensions/
var $export = __webpack_require__("./node_modules/core-js/modules/_export.js");

var scale = __webpack_require__("./node_modules/core-js/modules/_math-scale.js");

var fround = __webpack_require__("./node_modules/core-js/modules/_math-fround.js");

$export($export.S, 'Math', {
  fscale: function fscale(x, inLow, inHigh, outLow, outHigh) {
    return fround(scale(x, inLow, inHigh, outLow, outHigh));
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es7.math.iaddh.js":
/***/ (function(module, exports, __webpack_require__) {

// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
var $export = __webpack_require__("./node_modules/core-js/modules/_export.js");

$export($export.S, 'Math', {
  iaddh: function iaddh(x0, x1, y0, y1) {
    var $x0 = x0 >>> 0;
    var $x1 = x1 >>> 0;
    var $y0 = y0 >>> 0;
    return $x1 + (y1 >>> 0) + (($x0 & $y0 | ($x0 | $y0) & ~($x0 + $y0 >>> 0)) >>> 31) | 0;
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es7.math.imulh.js":
/***/ (function(module, exports, __webpack_require__) {

// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
var $export = __webpack_require__("./node_modules/core-js/modules/_export.js");

$export($export.S, 'Math', {
  imulh: function imulh(u, v) {
    var UINT16 = 0xffff;
    var $u = +u;
    var $v = +v;
    var u0 = $u & UINT16;
    var v0 = $v & UINT16;
    var u1 = $u >> 16;
    var v1 = $v >> 16;
    var t = (u1 * v0 >>> 0) + (u0 * v0 >>> 16);
    return u1 * v1 + (t >> 16) + ((u0 * v1 >>> 0) + (t & UINT16) >> 16);
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es7.math.isubh.js":
/***/ (function(module, exports, __webpack_require__) {

// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
var $export = __webpack_require__("./node_modules/core-js/modules/_export.js");

$export($export.S, 'Math', {
  isubh: function isubh(x0, x1, y0, y1) {
    var $x0 = x0 >>> 0;
    var $x1 = x1 >>> 0;
    var $y0 = y0 >>> 0;
    return $x1 - (y1 >>> 0) - ((~$x0 & $y0 | ~($x0 ^ $y0) & $x0 - $y0 >>> 0) >>> 31) | 0;
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es7.math.rad-per-deg.js":
/***/ (function(module, exports, __webpack_require__) {

// https://rwaldron.github.io/proposal-math-extensions/
var $export = __webpack_require__("./node_modules/core-js/modules/_export.js");

$export($export.S, 'Math', {
  RAD_PER_DEG: 180 / Math.PI
});

/***/ }),

/***/ "./node_modules/core-js/modules/es7.math.radians.js":
/***/ (function(module, exports, __webpack_require__) {

// https://rwaldron.github.io/proposal-math-extensions/
var $export = __webpack_require__("./node_modules/core-js/modules/_export.js");

var DEG_PER_RAD = Math.PI / 180;
$export($export.S, 'Math', {
  radians: function radians(degrees) {
    return degrees * DEG_PER_RAD;
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es7.math.scale.js":
/***/ (function(module, exports, __webpack_require__) {

// https://rwaldron.github.io/proposal-math-extensions/
var $export = __webpack_require__("./node_modules/core-js/modules/_export.js");

$export($export.S, 'Math', {
  scale: __webpack_require__("./node_modules/core-js/modules/_math-scale.js")
});

/***/ }),

/***/ "./node_modules/core-js/modules/es7.math.signbit.js":
/***/ (function(module, exports, __webpack_require__) {

// http://jfbastien.github.io/papers/Math.signbit.html
var $export = __webpack_require__("./node_modules/core-js/modules/_export.js");

$export($export.S, 'Math', {
  signbit: function signbit(x) {
    // eslint-disable-next-line no-self-compare
    return (x = +x) != x ? x : x == 0 ? 1 / x == Infinity : x > 0;
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es7.math.umulh.js":
/***/ (function(module, exports, __webpack_require__) {

// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
var $export = __webpack_require__("./node_modules/core-js/modules/_export.js");

$export($export.S, 'Math', {
  umulh: function umulh(u, v) {
    var UINT16 = 0xffff;
    var $u = +u;
    var $v = +v;
    var u0 = $u & UINT16;
    var v0 = $v & UINT16;
    var u1 = $u >>> 16;
    var v1 = $v >>> 16;
    var t = (u1 * v0 >>> 0) + (u0 * v0 >>> 16);
    return u1 * v1 + (t >>> 16) + ((u0 * v1 >>> 0) + (t & UINT16) >>> 16);
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es7.object.define-getter.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__("./node_modules/core-js/modules/_export.js");

var toObject = __webpack_require__("./node_modules/core-js/modules/_to-object.js");

var aFunction = __webpack_require__("./node_modules/core-js/modules/_a-function.js");

var $defineProperty = __webpack_require__("./node_modules/core-js/modules/_object-dp.js"); // B.2.2.2 Object.prototype.__defineGetter__(P, getter)


__webpack_require__("./node_modules/core-js/modules/_descriptors.js") && $export($export.P + __webpack_require__("./node_modules/core-js/modules/_object-forced-pam.js"), 'Object', {
  __defineGetter__: function __defineGetter__(P, getter) {
    $defineProperty.f(toObject(this), P, {
      get: aFunction(getter),
      enumerable: true,
      configurable: true
    });
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es7.object.define-setter.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__("./node_modules/core-js/modules/_export.js");

var toObject = __webpack_require__("./node_modules/core-js/modules/_to-object.js");

var aFunction = __webpack_require__("./node_modules/core-js/modules/_a-function.js");

var $defineProperty = __webpack_require__("./node_modules/core-js/modules/_object-dp.js"); // B.2.2.3 Object.prototype.__defineSetter__(P, setter)


__webpack_require__("./node_modules/core-js/modules/_descriptors.js") && $export($export.P + __webpack_require__("./node_modules/core-js/modules/_object-forced-pam.js"), 'Object', {
  __defineSetter__: function __defineSetter__(P, setter) {
    $defineProperty.f(toObject(this), P, {
      set: aFunction(setter),
      enumerable: true,
      configurable: true
    });
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es7.object.entries.js":
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/tc39/proposal-object-values-entries
var $export = __webpack_require__("./node_modules/core-js/modules/_export.js");

var $entries = __webpack_require__("./node_modules/core-js/modules/_object-to-array.js")(true);

$export($export.S, 'Object', {
  entries: function entries(it) {
    return $entries(it);
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es7.object.get-own-property-descriptors.js":
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/tc39/proposal-object-getownpropertydescriptors
var $export = __webpack_require__("./node_modules/core-js/modules/_export.js");

var ownKeys = __webpack_require__("./node_modules/core-js/modules/_own-keys.js");

var toIObject = __webpack_require__("./node_modules/core-js/modules/_to-iobject.js");

var gOPD = __webpack_require__("./node_modules/core-js/modules/_object-gopd.js");

var createProperty = __webpack_require__("./node_modules/core-js/modules/_create-property.js");

$export($export.S, 'Object', {
  getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object) {
    var O = toIObject(object);
    var getDesc = gOPD.f;
    var keys = ownKeys(O);
    var result = {};
    var i = 0;
    var key, desc;

    while (keys.length > i) {
      desc = getDesc(O, key = keys[i++]);
      if (desc !== undefined) createProperty(result, key, desc);
    }

    return result;
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es7.object.lookup-getter.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__("./node_modules/core-js/modules/_export.js");

var toObject = __webpack_require__("./node_modules/core-js/modules/_to-object.js");

var toPrimitive = __webpack_require__("./node_modules/core-js/modules/_to-primitive.js");

var getPrototypeOf = __webpack_require__("./node_modules/core-js/modules/_object-gpo.js");

var getOwnPropertyDescriptor = __webpack_require__("./node_modules/core-js/modules/_object-gopd.js").f; // B.2.2.4 Object.prototype.__lookupGetter__(P)


__webpack_require__("./node_modules/core-js/modules/_descriptors.js") && $export($export.P + __webpack_require__("./node_modules/core-js/modules/_object-forced-pam.js"), 'Object', {
  __lookupGetter__: function __lookupGetter__(P) {
    var O = toObject(this);
    var K = toPrimitive(P, true);
    var D;

    do {
      if (D = getOwnPropertyDescriptor(O, K)) return D.get;
    } while (O = getPrototypeOf(O));
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es7.object.lookup-setter.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__("./node_modules/core-js/modules/_export.js");

var toObject = __webpack_require__("./node_modules/core-js/modules/_to-object.js");

var toPrimitive = __webpack_require__("./node_modules/core-js/modules/_to-primitive.js");

var getPrototypeOf = __webpack_require__("./node_modules/core-js/modules/_object-gpo.js");

var getOwnPropertyDescriptor = __webpack_require__("./node_modules/core-js/modules/_object-gopd.js").f; // B.2.2.5 Object.prototype.__lookupSetter__(P)


__webpack_require__("./node_modules/core-js/modules/_descriptors.js") && $export($export.P + __webpack_require__("./node_modules/core-js/modules/_object-forced-pam.js"), 'Object', {
  __lookupSetter__: function __lookupSetter__(P) {
    var O = toObject(this);
    var K = toPrimitive(P, true);
    var D;

    do {
      if (D = getOwnPropertyDescriptor(O, K)) return D.set;
    } while (O = getPrototypeOf(O));
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es7.object.values.js":
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/tc39/proposal-object-values-entries
var $export = __webpack_require__("./node_modules/core-js/modules/_export.js");

var $values = __webpack_require__("./node_modules/core-js/modules/_object-to-array.js")(false);

$export($export.S, 'Object', {
  values: function values(it) {
    return $values(it);
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es7.observable.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // https://github.com/zenparsing/es-observable

var $export = __webpack_require__("./node_modules/core-js/modules/_export.js");

var global = __webpack_require__("./node_modules/core-js/modules/_global.js");

var core = __webpack_require__("./node_modules/core-js/modules/_core.js");

var microtask = __webpack_require__("./node_modules/core-js/modules/_microtask.js")();

var OBSERVABLE = __webpack_require__("./node_modules/core-js/modules/_wks.js")('observable');

var aFunction = __webpack_require__("./node_modules/core-js/modules/_a-function.js");

var anObject = __webpack_require__("./node_modules/core-js/modules/_an-object.js");

var anInstance = __webpack_require__("./node_modules/core-js/modules/_an-instance.js");

var redefineAll = __webpack_require__("./node_modules/core-js/modules/_redefine-all.js");

var hide = __webpack_require__("./node_modules/core-js/modules/_hide.js");

var forOf = __webpack_require__("./node_modules/core-js/modules/_for-of.js");

var RETURN = forOf.RETURN;

var getMethod = function getMethod(fn) {
  return fn == null ? undefined : aFunction(fn);
};

var cleanupSubscription = function cleanupSubscription(subscription) {
  var cleanup = subscription._c;

  if (cleanup) {
    subscription._c = undefined;
    cleanup();
  }
};

var subscriptionClosed = function subscriptionClosed(subscription) {
  return subscription._o === undefined;
};

var closeSubscription = function closeSubscription(subscription) {
  if (!subscriptionClosed(subscription)) {
    subscription._o = undefined;
    cleanupSubscription(subscription);
  }
};

var Subscription = function Subscription(observer, subscriber) {
  anObject(observer);
  this._c = undefined;
  this._o = observer;
  observer = new SubscriptionObserver(this);

  try {
    var cleanup = subscriber(observer);
    var subscription = cleanup;

    if (cleanup != null) {
      if (typeof cleanup.unsubscribe === 'function') cleanup = function cleanup() {
        subscription.unsubscribe();
      };else aFunction(cleanup);
      this._c = cleanup;
    }
  } catch (e) {
    observer.error(e);
    return;
  }

  if (subscriptionClosed(this)) cleanupSubscription(this);
};

Subscription.prototype = redefineAll({}, {
  unsubscribe: function unsubscribe() {
    closeSubscription(this);
  }
});

var SubscriptionObserver = function SubscriptionObserver(subscription) {
  this._s = subscription;
};

SubscriptionObserver.prototype = redefineAll({}, {
  next: function next(value) {
    var subscription = this._s;

    if (!subscriptionClosed(subscription)) {
      var observer = subscription._o;

      try {
        var m = getMethod(observer.next);
        if (m) return m.call(observer, value);
      } catch (e) {
        try {
          closeSubscription(subscription);
        } finally {
          throw e;
        }
      }
    }
  },
  error: function error(value) {
    var subscription = this._s;
    if (subscriptionClosed(subscription)) throw value;
    var observer = subscription._o;
    subscription._o = undefined;

    try {
      var m = getMethod(observer.error);
      if (!m) throw value;
      value = m.call(observer, value);
    } catch (e) {
      try {
        cleanupSubscription(subscription);
      } finally {
        throw e;
      }
    }

    cleanupSubscription(subscription);
    return value;
  },
  complete: function complete(value) {
    var subscription = this._s;

    if (!subscriptionClosed(subscription)) {
      var observer = subscription._o;
      subscription._o = undefined;

      try {
        var m = getMethod(observer.complete);
        value = m ? m.call(observer, value) : undefined;
      } catch (e) {
        try {
          cleanupSubscription(subscription);
        } finally {
          throw e;
        }
      }

      cleanupSubscription(subscription);
      return value;
    }
  }
});

var $Observable = function Observable(subscriber) {
  anInstance(this, $Observable, 'Observable', '_f')._f = aFunction(subscriber);
};

redefineAll($Observable.prototype, {
  subscribe: function subscribe(observer) {
    return new Subscription(observer, this._f);
  },
  forEach: function forEach(fn) {
    var that = this;
    return new (core.Promise || global.Promise)(function (resolve, reject) {
      aFunction(fn);
      var subscription = that.subscribe({
        next: function next(value) {
          try {
            return fn(value);
          } catch (e) {
            reject(e);
            subscription.unsubscribe();
          }
        },
        error: reject,
        complete: resolve
      });
    });
  }
});
redefineAll($Observable, {
  from: function from(x) {
    var C = typeof this === 'function' ? this : $Observable;
    var method = getMethod(anObject(x)[OBSERVABLE]);

    if (method) {
      var observable = anObject(method.call(x));
      return observable.constructor === C ? observable : new C(function (observer) {
        return observable.subscribe(observer);
      });
    }

    return new C(function (observer) {
      var done = false;
      microtask(function () {
        if (!done) {
          try {
            if (forOf(x, false, function (it) {
              observer.next(it);
              if (done) return RETURN;
            }) === RETURN) return;
          } catch (e) {
            if (done) throw e;
            observer.error(e);
            return;
          }

          observer.complete();
        }
      });
      return function () {
        done = true;
      };
    });
  },
  of: function of() {
    for (var i = 0, l = arguments.length, items = Array(l); i < l;) {
      items[i] = arguments[i++];
    }

    return new (typeof this === 'function' ? this : $Observable)(function (observer) {
      var done = false;
      microtask(function () {
        if (!done) {
          for (var j = 0; j < items.length; ++j) {
            observer.next(items[j]);
            if (done) return;
          }

          observer.complete();
        }
      });
      return function () {
        done = true;
      };
    });
  }
});
hide($Observable.prototype, OBSERVABLE, function () {
  return this;
});
$export($export.G, {
  Observable: $Observable
});

__webpack_require__("./node_modules/core-js/modules/_set-species.js")('Observable');

/***/ }),

/***/ "./node_modules/core-js/modules/es7.promise.finally.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// https://github.com/tc39/proposal-promise-finally


var $export = __webpack_require__("./node_modules/core-js/modules/_export.js");

var core = __webpack_require__("./node_modules/core-js/modules/_core.js");

var global = __webpack_require__("./node_modules/core-js/modules/_global.js");

var speciesConstructor = __webpack_require__("./node_modules/core-js/modules/_species-constructor.js");

var promiseResolve = __webpack_require__("./node_modules/core-js/modules/_promise-resolve.js");

$export($export.P + $export.R, 'Promise', {
  'finally': function _finally(onFinally) {
    var C = speciesConstructor(this, core.Promise || global.Promise);
    var isFunction = typeof onFinally == 'function';
    return this.then(isFunction ? function (x) {
      return promiseResolve(C, onFinally()).then(function () {
        return x;
      });
    } : onFinally, isFunction ? function (e) {
      return promiseResolve(C, onFinally()).then(function () {
        throw e;
      });
    } : onFinally);
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es7.promise.try.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // https://github.com/tc39/proposal-promise-try

var $export = __webpack_require__("./node_modules/core-js/modules/_export.js");

var newPromiseCapability = __webpack_require__("./node_modules/core-js/modules/_new-promise-capability.js");

var perform = __webpack_require__("./node_modules/core-js/modules/_perform.js");

$export($export.S, 'Promise', {
  'try': function _try(callbackfn) {
    var promiseCapability = newPromiseCapability.f(this);
    var result = perform(callbackfn);
    (result.e ? promiseCapability.reject : promiseCapability.resolve)(result.v);
    return promiseCapability.promise;
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es7.reflect.define-metadata.js":
/***/ (function(module, exports, __webpack_require__) {

var metadata = __webpack_require__("./node_modules/core-js/modules/_metadata.js");

var anObject = __webpack_require__("./node_modules/core-js/modules/_an-object.js");

var toMetaKey = metadata.key;
var ordinaryDefineOwnMetadata = metadata.set;
metadata.exp({
  defineMetadata: function defineMetadata(metadataKey, metadataValue, target, targetKey) {
    ordinaryDefineOwnMetadata(metadataKey, metadataValue, anObject(target), toMetaKey(targetKey));
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es7.reflect.delete-metadata.js":
/***/ (function(module, exports, __webpack_require__) {

var metadata = __webpack_require__("./node_modules/core-js/modules/_metadata.js");

var anObject = __webpack_require__("./node_modules/core-js/modules/_an-object.js");

var toMetaKey = metadata.key;
var getOrCreateMetadataMap = metadata.map;
var store = metadata.store;
metadata.exp({
  deleteMetadata: function deleteMetadata(metadataKey, target
  /* , targetKey */
  ) {
    var targetKey = arguments.length < 3 ? undefined : toMetaKey(arguments[2]);
    var metadataMap = getOrCreateMetadataMap(anObject(target), targetKey, false);
    if (metadataMap === undefined || !metadataMap['delete'](metadataKey)) return false;
    if (metadataMap.size) return true;
    var targetMetadata = store.get(target);
    targetMetadata['delete'](targetKey);
    return !!targetMetadata.size || store['delete'](target);
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es7.reflect.get-metadata-keys.js":
/***/ (function(module, exports, __webpack_require__) {

var Set = __webpack_require__("./node_modules/core-js/modules/es6.set.js");

var from = __webpack_require__("./node_modules/core-js/modules/_array-from-iterable.js");

var metadata = __webpack_require__("./node_modules/core-js/modules/_metadata.js");

var anObject = __webpack_require__("./node_modules/core-js/modules/_an-object.js");

var getPrototypeOf = __webpack_require__("./node_modules/core-js/modules/_object-gpo.js");

var ordinaryOwnMetadataKeys = metadata.keys;
var toMetaKey = metadata.key;

var ordinaryMetadataKeys = function ordinaryMetadataKeys(O, P) {
  var oKeys = ordinaryOwnMetadataKeys(O, P);
  var parent = getPrototypeOf(O);
  if (parent === null) return oKeys;
  var pKeys = ordinaryMetadataKeys(parent, P);
  return pKeys.length ? oKeys.length ? from(new Set(oKeys.concat(pKeys))) : pKeys : oKeys;
};

metadata.exp({
  getMetadataKeys: function getMetadataKeys(target
  /* , targetKey */
  ) {
    return ordinaryMetadataKeys(anObject(target), arguments.length < 2 ? undefined : toMetaKey(arguments[1]));
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es7.reflect.get-metadata.js":
/***/ (function(module, exports, __webpack_require__) {

var metadata = __webpack_require__("./node_modules/core-js/modules/_metadata.js");

var anObject = __webpack_require__("./node_modules/core-js/modules/_an-object.js");

var getPrototypeOf = __webpack_require__("./node_modules/core-js/modules/_object-gpo.js");

var ordinaryHasOwnMetadata = metadata.has;
var ordinaryGetOwnMetadata = metadata.get;
var toMetaKey = metadata.key;

var ordinaryGetMetadata = function ordinaryGetMetadata(MetadataKey, O, P) {
  var hasOwn = ordinaryHasOwnMetadata(MetadataKey, O, P);
  if (hasOwn) return ordinaryGetOwnMetadata(MetadataKey, O, P);
  var parent = getPrototypeOf(O);
  return parent !== null ? ordinaryGetMetadata(MetadataKey, parent, P) : undefined;
};

metadata.exp({
  getMetadata: function getMetadata(metadataKey, target
  /* , targetKey */
  ) {
    return ordinaryGetMetadata(metadataKey, anObject(target), arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es7.reflect.get-own-metadata-keys.js":
/***/ (function(module, exports, __webpack_require__) {

var metadata = __webpack_require__("./node_modules/core-js/modules/_metadata.js");

var anObject = __webpack_require__("./node_modules/core-js/modules/_an-object.js");

var ordinaryOwnMetadataKeys = metadata.keys;
var toMetaKey = metadata.key;
metadata.exp({
  getOwnMetadataKeys: function getOwnMetadataKeys(target
  /* , targetKey */
  ) {
    return ordinaryOwnMetadataKeys(anObject(target), arguments.length < 2 ? undefined : toMetaKey(arguments[1]));
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es7.reflect.get-own-metadata.js":
/***/ (function(module, exports, __webpack_require__) {

var metadata = __webpack_require__("./node_modules/core-js/modules/_metadata.js");

var anObject = __webpack_require__("./node_modules/core-js/modules/_an-object.js");

var ordinaryGetOwnMetadata = metadata.get;
var toMetaKey = metadata.key;
metadata.exp({
  getOwnMetadata: function getOwnMetadata(metadataKey, target
  /* , targetKey */
  ) {
    return ordinaryGetOwnMetadata(metadataKey, anObject(target), arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es7.reflect.has-metadata.js":
/***/ (function(module, exports, __webpack_require__) {

var metadata = __webpack_require__("./node_modules/core-js/modules/_metadata.js");

var anObject = __webpack_require__("./node_modules/core-js/modules/_an-object.js");

var getPrototypeOf = __webpack_require__("./node_modules/core-js/modules/_object-gpo.js");

var ordinaryHasOwnMetadata = metadata.has;
var toMetaKey = metadata.key;

var ordinaryHasMetadata = function ordinaryHasMetadata(MetadataKey, O, P) {
  var hasOwn = ordinaryHasOwnMetadata(MetadataKey, O, P);
  if (hasOwn) return true;
  var parent = getPrototypeOf(O);
  return parent !== null ? ordinaryHasMetadata(MetadataKey, parent, P) : false;
};

metadata.exp({
  hasMetadata: function hasMetadata(metadataKey, target
  /* , targetKey */
  ) {
    return ordinaryHasMetadata(metadataKey, anObject(target), arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es7.reflect.has-own-metadata.js":
/***/ (function(module, exports, __webpack_require__) {

var metadata = __webpack_require__("./node_modules/core-js/modules/_metadata.js");

var anObject = __webpack_require__("./node_modules/core-js/modules/_an-object.js");

var ordinaryHasOwnMetadata = metadata.has;
var toMetaKey = metadata.key;
metadata.exp({
  hasOwnMetadata: function hasOwnMetadata(metadataKey, target
  /* , targetKey */
  ) {
    return ordinaryHasOwnMetadata(metadataKey, anObject(target), arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es7.reflect.metadata.js":
/***/ (function(module, exports, __webpack_require__) {

var $metadata = __webpack_require__("./node_modules/core-js/modules/_metadata.js");

var anObject = __webpack_require__("./node_modules/core-js/modules/_an-object.js");

var aFunction = __webpack_require__("./node_modules/core-js/modules/_a-function.js");

var toMetaKey = $metadata.key;
var ordinaryDefineOwnMetadata = $metadata.set;
$metadata.exp({
  metadata: function metadata(metadataKey, metadataValue) {
    return function decorator(target, targetKey) {
      ordinaryDefineOwnMetadata(metadataKey, metadataValue, (targetKey !== undefined ? anObject : aFunction)(target), toMetaKey(targetKey));
    };
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es7.set.from.js":
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/proposal-setmap-offrom/#sec-set.from
__webpack_require__("./node_modules/core-js/modules/_set-collection-from.js")('Set');

/***/ }),

/***/ "./node_modules/core-js/modules/es7.set.of.js":
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/proposal-setmap-offrom/#sec-set.of
__webpack_require__("./node_modules/core-js/modules/_set-collection-of.js")('Set');

/***/ }),

/***/ "./node_modules/core-js/modules/es7.set.to-json.js":
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var $export = __webpack_require__("./node_modules/core-js/modules/_export.js");

$export($export.P + $export.R, 'Set', {
  toJSON: __webpack_require__("./node_modules/core-js/modules/_collection-to-json.js")('Set')
});

/***/ }),

/***/ "./node_modules/core-js/modules/es7.string.at.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // https://github.com/mathiasbynens/String.prototype.at

var $export = __webpack_require__("./node_modules/core-js/modules/_export.js");

var $at = __webpack_require__("./node_modules/core-js/modules/_string-at.js")(true);

$export($export.P, 'String', {
  at: function at(pos) {
    return $at(this, pos);
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es7.string.match-all.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // https://tc39.github.io/String.prototype.matchAll/

var $export = __webpack_require__("./node_modules/core-js/modules/_export.js");

var defined = __webpack_require__("./node_modules/core-js/modules/_defined.js");

var toLength = __webpack_require__("./node_modules/core-js/modules/_to-length.js");

var isRegExp = __webpack_require__("./node_modules/core-js/modules/_is-regexp.js");

var getFlags = __webpack_require__("./node_modules/core-js/modules/_flags.js");

var RegExpProto = RegExp.prototype;

var $RegExpStringIterator = function $RegExpStringIterator(regexp, string) {
  this._r = regexp;
  this._s = string;
};

__webpack_require__("./node_modules/core-js/modules/_iter-create.js")($RegExpStringIterator, 'RegExp String', function next() {
  var match = this._r.exec(this._s);

  return {
    value: match,
    done: match === null
  };
});

$export($export.P, 'String', {
  matchAll: function matchAll(regexp) {
    defined(this);
    if (!isRegExp(regexp)) throw TypeError(regexp + ' is not a regexp!');
    var S = String(this);
    var flags = 'flags' in RegExpProto ? String(regexp.flags) : getFlags.call(regexp);
    var rx = new RegExp(regexp.source, ~flags.indexOf('g') ? flags : 'g' + flags);
    rx.lastIndex = toLength(regexp.lastIndex);
    return new $RegExpStringIterator(rx, S);
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es7.string.pad-end.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // https://github.com/tc39/proposal-string-pad-start-end

var $export = __webpack_require__("./node_modules/core-js/modules/_export.js");

var $pad = __webpack_require__("./node_modules/core-js/modules/_string-pad.js");

$export($export.P, 'String', {
  padEnd: function padEnd(maxLength
  /* , fillString = ' ' */
  ) {
    return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, false);
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es7.string.pad-start.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // https://github.com/tc39/proposal-string-pad-start-end

var $export = __webpack_require__("./node_modules/core-js/modules/_export.js");

var $pad = __webpack_require__("./node_modules/core-js/modules/_string-pad.js");

$export($export.P, 'String', {
  padStart: function padStart(maxLength
  /* , fillString = ' ' */
  ) {
    return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, true);
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es7.string.trim-left.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // https://github.com/sebmarkbage/ecmascript-string-left-right-trim

__webpack_require__("./node_modules/core-js/modules/_string-trim.js")('trimLeft', function ($trim) {
  return function trimLeft() {
    return $trim(this, 1);
  };
}, 'trimStart');

/***/ }),

/***/ "./node_modules/core-js/modules/es7.string.trim-right.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // https://github.com/sebmarkbage/ecmascript-string-left-right-trim

__webpack_require__("./node_modules/core-js/modules/_string-trim.js")('trimRight', function ($trim) {
  return function trimRight() {
    return $trim(this, 2);
  };
}, 'trimEnd');

/***/ }),

/***/ "./node_modules/core-js/modules/es7.symbol.async-iterator.js":
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("./node_modules/core-js/modules/_wks-define.js")('asyncIterator');

/***/ }),

/***/ "./node_modules/core-js/modules/es7.symbol.observable.js":
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("./node_modules/core-js/modules/_wks-define.js")('observable');

/***/ }),

/***/ "./node_modules/core-js/modules/es7.system.global.js":
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/tc39/proposal-global
var $export = __webpack_require__("./node_modules/core-js/modules/_export.js");

$export($export.S, 'System', {
  global: __webpack_require__("./node_modules/core-js/modules/_global.js")
});

/***/ }),

/***/ "./node_modules/core-js/modules/es7.weak-map.from.js":
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/proposal-setmap-offrom/#sec-weakmap.from
__webpack_require__("./node_modules/core-js/modules/_set-collection-from.js")('WeakMap');

/***/ }),

/***/ "./node_modules/core-js/modules/es7.weak-map.of.js":
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/proposal-setmap-offrom/#sec-weakmap.of
__webpack_require__("./node_modules/core-js/modules/_set-collection-of.js")('WeakMap');

/***/ }),

/***/ "./node_modules/core-js/modules/es7.weak-set.from.js":
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/proposal-setmap-offrom/#sec-weakset.from
__webpack_require__("./node_modules/core-js/modules/_set-collection-from.js")('WeakSet');

/***/ }),

/***/ "./node_modules/core-js/modules/es7.weak-set.of.js":
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/proposal-setmap-offrom/#sec-weakset.of
__webpack_require__("./node_modules/core-js/modules/_set-collection-of.js")('WeakSet');

/***/ }),

/***/ "./node_modules/core-js/modules/web.dom.iterable.js":
/***/ (function(module, exports, __webpack_require__) {

var $iterators = __webpack_require__("./node_modules/core-js/modules/es6.array.iterator.js");

var getKeys = __webpack_require__("./node_modules/core-js/modules/_object-keys.js");

var redefine = __webpack_require__("./node_modules/core-js/modules/_redefine.js");

var global = __webpack_require__("./node_modules/core-js/modules/_global.js");

var hide = __webpack_require__("./node_modules/core-js/modules/_hide.js");

var Iterators = __webpack_require__("./node_modules/core-js/modules/_iterators.js");

var wks = __webpack_require__("./node_modules/core-js/modules/_wks.js");

var ITERATOR = wks('iterator');
var TO_STRING_TAG = wks('toStringTag');
var ArrayValues = Iterators.Array;
var DOMIterables = {
  CSSRuleList: true,
  // TODO: Not spec compliant, should be false.
  CSSStyleDeclaration: false,
  CSSValueList: false,
  ClientRectList: false,
  DOMRectList: false,
  DOMStringList: false,
  DOMTokenList: true,
  DataTransferItemList: false,
  FileList: false,
  HTMLAllCollection: false,
  HTMLCollection: false,
  HTMLFormElement: false,
  HTMLSelectElement: false,
  MediaList: true,
  // TODO: Not spec compliant, should be false.
  MimeTypeArray: false,
  NamedNodeMap: false,
  NodeList: true,
  PaintRequestList: false,
  Plugin: false,
  PluginArray: false,
  SVGLengthList: false,
  SVGNumberList: false,
  SVGPathSegList: false,
  SVGPointList: false,
  SVGStringList: false,
  SVGTransformList: false,
  SourceBufferList: false,
  StyleSheetList: true,
  // TODO: Not spec compliant, should be false.
  TextTrackCueList: false,
  TextTrackList: false,
  TouchList: false
};

for (var collections = getKeys(DOMIterables), i = 0; i < collections.length; i++) {
  var NAME = collections[i];
  var explicit = DOMIterables[NAME];
  var Collection = global[NAME];
  var proto = Collection && Collection.prototype;
  var key;

  if (proto) {
    if (!proto[ITERATOR]) hide(proto, ITERATOR, ArrayValues);
    if (!proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);
    Iterators[NAME] = ArrayValues;
    if (explicit) for (key in $iterators) {
      if (!proto[key]) redefine(proto, key, $iterators[key], true);
    }
  }
}

/***/ }),

/***/ "./node_modules/core-js/modules/web.immediate.js":
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__("./node_modules/core-js/modules/_export.js");

var $task = __webpack_require__("./node_modules/core-js/modules/_task.js");

$export($export.G + $export.B, {
  setImmediate: $task.set,
  clearImmediate: $task.clear
});

/***/ }),

/***/ "./node_modules/core-js/modules/web.timers.js":
/***/ (function(module, exports, __webpack_require__) {

// ie9- setTimeout & setInterval additional parameters fix
var global = __webpack_require__("./node_modules/core-js/modules/_global.js");

var $export = __webpack_require__("./node_modules/core-js/modules/_export.js");

var navigator = global.navigator;
var slice = [].slice;
var MSIE = !!navigator && /MSIE .\./.test(navigator.userAgent); // <- dirty ie9- check

var wrap = function wrap(set) {
  return function (fn, time
  /* , ...args */
  ) {
    var boundArgs = arguments.length > 2;
    var args = boundArgs ? slice.call(arguments, 2) : false;
    return set(boundArgs ? function () {
      // eslint-disable-next-line no-new-func
      (typeof fn == 'function' ? fn : Function(fn)).apply(this, args);
    } : fn, time);
  };
};

$export($export.G + $export.B + $export.F * MSIE, {
  setTimeout: wrap(global.setTimeout),
  setInterval: wrap(global.setInterval)
});

/***/ }),

/***/ "./node_modules/core-js/shim.js":
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("./node_modules/core-js/modules/es6.symbol.js");

__webpack_require__("./node_modules/core-js/modules/es6.object.create.js");

__webpack_require__("./node_modules/core-js/modules/es6.object.define-property.js");

__webpack_require__("./node_modules/core-js/modules/es6.object.define-properties.js");

__webpack_require__("./node_modules/core-js/modules/es6.object.get-own-property-descriptor.js");

__webpack_require__("./node_modules/core-js/modules/es6.object.get-prototype-of.js");

__webpack_require__("./node_modules/core-js/modules/es6.object.keys.js");

__webpack_require__("./node_modules/core-js/modules/es6.object.get-own-property-names.js");

__webpack_require__("./node_modules/core-js/modules/es6.object.freeze.js");

__webpack_require__("./node_modules/core-js/modules/es6.object.seal.js");

__webpack_require__("./node_modules/core-js/modules/es6.object.prevent-extensions.js");

__webpack_require__("./node_modules/core-js/modules/es6.object.is-frozen.js");

__webpack_require__("./node_modules/core-js/modules/es6.object.is-sealed.js");

__webpack_require__("./node_modules/core-js/modules/es6.object.is-extensible.js");

__webpack_require__("./node_modules/core-js/modules/es6.object.assign.js");

__webpack_require__("./node_modules/core-js/modules/es6.object.is.js");

__webpack_require__("./node_modules/core-js/modules/es6.object.set-prototype-of.js");

__webpack_require__("./node_modules/core-js/modules/es6.object.to-string.js");

__webpack_require__("./node_modules/core-js/modules/es6.function.bind.js");

__webpack_require__("./node_modules/core-js/modules/es6.function.name.js");

__webpack_require__("./node_modules/core-js/modules/es6.function.has-instance.js");

__webpack_require__("./node_modules/core-js/modules/es6.parse-int.js");

__webpack_require__("./node_modules/core-js/modules/es6.parse-float.js");

__webpack_require__("./node_modules/core-js/modules/es6.number.constructor.js");

__webpack_require__("./node_modules/core-js/modules/es6.number.to-fixed.js");

__webpack_require__("./node_modules/core-js/modules/es6.number.to-precision.js");

__webpack_require__("./node_modules/core-js/modules/es6.number.epsilon.js");

__webpack_require__("./node_modules/core-js/modules/es6.number.is-finite.js");

__webpack_require__("./node_modules/core-js/modules/es6.number.is-integer.js");

__webpack_require__("./node_modules/core-js/modules/es6.number.is-nan.js");

__webpack_require__("./node_modules/core-js/modules/es6.number.is-safe-integer.js");

__webpack_require__("./node_modules/core-js/modules/es6.number.max-safe-integer.js");

__webpack_require__("./node_modules/core-js/modules/es6.number.min-safe-integer.js");

__webpack_require__("./node_modules/core-js/modules/es6.number.parse-float.js");

__webpack_require__("./node_modules/core-js/modules/es6.number.parse-int.js");

__webpack_require__("./node_modules/core-js/modules/es6.math.acosh.js");

__webpack_require__("./node_modules/core-js/modules/es6.math.asinh.js");

__webpack_require__("./node_modules/core-js/modules/es6.math.atanh.js");

__webpack_require__("./node_modules/core-js/modules/es6.math.cbrt.js");

__webpack_require__("./node_modules/core-js/modules/es6.math.clz32.js");

__webpack_require__("./node_modules/core-js/modules/es6.math.cosh.js");

__webpack_require__("./node_modules/core-js/modules/es6.math.expm1.js");

__webpack_require__("./node_modules/core-js/modules/es6.math.fround.js");

__webpack_require__("./node_modules/core-js/modules/es6.math.hypot.js");

__webpack_require__("./node_modules/core-js/modules/es6.math.imul.js");

__webpack_require__("./node_modules/core-js/modules/es6.math.log10.js");

__webpack_require__("./node_modules/core-js/modules/es6.math.log1p.js");

__webpack_require__("./node_modules/core-js/modules/es6.math.log2.js");

__webpack_require__("./node_modules/core-js/modules/es6.math.sign.js");

__webpack_require__("./node_modules/core-js/modules/es6.math.sinh.js");

__webpack_require__("./node_modules/core-js/modules/es6.math.tanh.js");

__webpack_require__("./node_modules/core-js/modules/es6.math.trunc.js");

__webpack_require__("./node_modules/core-js/modules/es6.string.from-code-point.js");

__webpack_require__("./node_modules/core-js/modules/es6.string.raw.js");

__webpack_require__("./node_modules/core-js/modules/es6.string.trim.js");

__webpack_require__("./node_modules/core-js/modules/es6.string.iterator.js");

__webpack_require__("./node_modules/core-js/modules/es6.string.code-point-at.js");

__webpack_require__("./node_modules/core-js/modules/es6.string.ends-with.js");

__webpack_require__("./node_modules/core-js/modules/es6.string.includes.js");

__webpack_require__("./node_modules/core-js/modules/es6.string.repeat.js");

__webpack_require__("./node_modules/core-js/modules/es6.string.starts-with.js");

__webpack_require__("./node_modules/core-js/modules/es6.string.anchor.js");

__webpack_require__("./node_modules/core-js/modules/es6.string.big.js");

__webpack_require__("./node_modules/core-js/modules/es6.string.blink.js");

__webpack_require__("./node_modules/core-js/modules/es6.string.bold.js");

__webpack_require__("./node_modules/core-js/modules/es6.string.fixed.js");

__webpack_require__("./node_modules/core-js/modules/es6.string.fontcolor.js");

__webpack_require__("./node_modules/core-js/modules/es6.string.fontsize.js");

__webpack_require__("./node_modules/core-js/modules/es6.string.italics.js");

__webpack_require__("./node_modules/core-js/modules/es6.string.link.js");

__webpack_require__("./node_modules/core-js/modules/es6.string.small.js");

__webpack_require__("./node_modules/core-js/modules/es6.string.strike.js");

__webpack_require__("./node_modules/core-js/modules/es6.string.sub.js");

__webpack_require__("./node_modules/core-js/modules/es6.string.sup.js");

__webpack_require__("./node_modules/core-js/modules/es6.date.now.js");

__webpack_require__("./node_modules/core-js/modules/es6.date.to-json.js");

__webpack_require__("./node_modules/core-js/modules/es6.date.to-iso-string.js");

__webpack_require__("./node_modules/core-js/modules/es6.date.to-string.js");

__webpack_require__("./node_modules/core-js/modules/es6.date.to-primitive.js");

__webpack_require__("./node_modules/core-js/modules/es6.array.is-array.js");

__webpack_require__("./node_modules/core-js/modules/es6.array.from.js");

__webpack_require__("./node_modules/core-js/modules/es6.array.of.js");

__webpack_require__("./node_modules/core-js/modules/es6.array.join.js");

__webpack_require__("./node_modules/core-js/modules/es6.array.slice.js");

__webpack_require__("./node_modules/core-js/modules/es6.array.sort.js");

__webpack_require__("./node_modules/core-js/modules/es6.array.for-each.js");

__webpack_require__("./node_modules/core-js/modules/es6.array.map.js");

__webpack_require__("./node_modules/core-js/modules/es6.array.filter.js");

__webpack_require__("./node_modules/core-js/modules/es6.array.some.js");

__webpack_require__("./node_modules/core-js/modules/es6.array.every.js");

__webpack_require__("./node_modules/core-js/modules/es6.array.reduce.js");

__webpack_require__("./node_modules/core-js/modules/es6.array.reduce-right.js");

__webpack_require__("./node_modules/core-js/modules/es6.array.index-of.js");

__webpack_require__("./node_modules/core-js/modules/es6.array.last-index-of.js");

__webpack_require__("./node_modules/core-js/modules/es6.array.copy-within.js");

__webpack_require__("./node_modules/core-js/modules/es6.array.fill.js");

__webpack_require__("./node_modules/core-js/modules/es6.array.find.js");

__webpack_require__("./node_modules/core-js/modules/es6.array.find-index.js");

__webpack_require__("./node_modules/core-js/modules/es6.array.species.js");

__webpack_require__("./node_modules/core-js/modules/es6.array.iterator.js");

__webpack_require__("./node_modules/core-js/modules/es6.regexp.constructor.js");

__webpack_require__("./node_modules/core-js/modules/es6.regexp.to-string.js");

__webpack_require__("./node_modules/core-js/modules/es6.regexp.flags.js");

__webpack_require__("./node_modules/core-js/modules/es6.regexp.match.js");

__webpack_require__("./node_modules/core-js/modules/es6.regexp.replace.js");

__webpack_require__("./node_modules/core-js/modules/es6.regexp.search.js");

__webpack_require__("./node_modules/core-js/modules/es6.regexp.split.js");

__webpack_require__("./node_modules/core-js/modules/es6.promise.js");

__webpack_require__("./node_modules/core-js/modules/es6.map.js");

__webpack_require__("./node_modules/core-js/modules/es6.set.js");

__webpack_require__("./node_modules/core-js/modules/es6.weak-map.js");

__webpack_require__("./node_modules/core-js/modules/es6.weak-set.js");

__webpack_require__("./node_modules/core-js/modules/es6.typed.array-buffer.js");

__webpack_require__("./node_modules/core-js/modules/es6.typed.data-view.js");

__webpack_require__("./node_modules/core-js/modules/es6.typed.int8-array.js");

__webpack_require__("./node_modules/core-js/modules/es6.typed.uint8-array.js");

__webpack_require__("./node_modules/core-js/modules/es6.typed.uint8-clamped-array.js");

__webpack_require__("./node_modules/core-js/modules/es6.typed.int16-array.js");

__webpack_require__("./node_modules/core-js/modules/es6.typed.uint16-array.js");

__webpack_require__("./node_modules/core-js/modules/es6.typed.int32-array.js");

__webpack_require__("./node_modules/core-js/modules/es6.typed.uint32-array.js");

__webpack_require__("./node_modules/core-js/modules/es6.typed.float32-array.js");

__webpack_require__("./node_modules/core-js/modules/es6.typed.float64-array.js");

__webpack_require__("./node_modules/core-js/modules/es6.reflect.apply.js");

__webpack_require__("./node_modules/core-js/modules/es6.reflect.construct.js");

__webpack_require__("./node_modules/core-js/modules/es6.reflect.define-property.js");

__webpack_require__("./node_modules/core-js/modules/es6.reflect.delete-property.js");

__webpack_require__("./node_modules/core-js/modules/es6.reflect.enumerate.js");

__webpack_require__("./node_modules/core-js/modules/es6.reflect.get.js");

__webpack_require__("./node_modules/core-js/modules/es6.reflect.get-own-property-descriptor.js");

__webpack_require__("./node_modules/core-js/modules/es6.reflect.get-prototype-of.js");

__webpack_require__("./node_modules/core-js/modules/es6.reflect.has.js");

__webpack_require__("./node_modules/core-js/modules/es6.reflect.is-extensible.js");

__webpack_require__("./node_modules/core-js/modules/es6.reflect.own-keys.js");

__webpack_require__("./node_modules/core-js/modules/es6.reflect.prevent-extensions.js");

__webpack_require__("./node_modules/core-js/modules/es6.reflect.set.js");

__webpack_require__("./node_modules/core-js/modules/es6.reflect.set-prototype-of.js");

__webpack_require__("./node_modules/core-js/modules/es7.array.includes.js");

__webpack_require__("./node_modules/core-js/modules/es7.array.flat-map.js");

__webpack_require__("./node_modules/core-js/modules/es7.array.flatten.js");

__webpack_require__("./node_modules/core-js/modules/es7.string.at.js");

__webpack_require__("./node_modules/core-js/modules/es7.string.pad-start.js");

__webpack_require__("./node_modules/core-js/modules/es7.string.pad-end.js");

__webpack_require__("./node_modules/core-js/modules/es7.string.trim-left.js");

__webpack_require__("./node_modules/core-js/modules/es7.string.trim-right.js");

__webpack_require__("./node_modules/core-js/modules/es7.string.match-all.js");

__webpack_require__("./node_modules/core-js/modules/es7.symbol.async-iterator.js");

__webpack_require__("./node_modules/core-js/modules/es7.symbol.observable.js");

__webpack_require__("./node_modules/core-js/modules/es7.object.get-own-property-descriptors.js");

__webpack_require__("./node_modules/core-js/modules/es7.object.values.js");

__webpack_require__("./node_modules/core-js/modules/es7.object.entries.js");

__webpack_require__("./node_modules/core-js/modules/es7.object.define-getter.js");

__webpack_require__("./node_modules/core-js/modules/es7.object.define-setter.js");

__webpack_require__("./node_modules/core-js/modules/es7.object.lookup-getter.js");

__webpack_require__("./node_modules/core-js/modules/es7.object.lookup-setter.js");

__webpack_require__("./node_modules/core-js/modules/es7.map.to-json.js");

__webpack_require__("./node_modules/core-js/modules/es7.set.to-json.js");

__webpack_require__("./node_modules/core-js/modules/es7.map.of.js");

__webpack_require__("./node_modules/core-js/modules/es7.set.of.js");

__webpack_require__("./node_modules/core-js/modules/es7.weak-map.of.js");

__webpack_require__("./node_modules/core-js/modules/es7.weak-set.of.js");

__webpack_require__("./node_modules/core-js/modules/es7.map.from.js");

__webpack_require__("./node_modules/core-js/modules/es7.set.from.js");

__webpack_require__("./node_modules/core-js/modules/es7.weak-map.from.js");

__webpack_require__("./node_modules/core-js/modules/es7.weak-set.from.js");

__webpack_require__("./node_modules/core-js/modules/es7.global.js");

__webpack_require__("./node_modules/core-js/modules/es7.system.global.js");

__webpack_require__("./node_modules/core-js/modules/es7.error.is-error.js");

__webpack_require__("./node_modules/core-js/modules/es7.math.clamp.js");

__webpack_require__("./node_modules/core-js/modules/es7.math.deg-per-rad.js");

__webpack_require__("./node_modules/core-js/modules/es7.math.degrees.js");

__webpack_require__("./node_modules/core-js/modules/es7.math.fscale.js");

__webpack_require__("./node_modules/core-js/modules/es7.math.iaddh.js");

__webpack_require__("./node_modules/core-js/modules/es7.math.isubh.js");

__webpack_require__("./node_modules/core-js/modules/es7.math.imulh.js");

__webpack_require__("./node_modules/core-js/modules/es7.math.rad-per-deg.js");

__webpack_require__("./node_modules/core-js/modules/es7.math.radians.js");

__webpack_require__("./node_modules/core-js/modules/es7.math.scale.js");

__webpack_require__("./node_modules/core-js/modules/es7.math.umulh.js");

__webpack_require__("./node_modules/core-js/modules/es7.math.signbit.js");

__webpack_require__("./node_modules/core-js/modules/es7.promise.finally.js");

__webpack_require__("./node_modules/core-js/modules/es7.promise.try.js");

__webpack_require__("./node_modules/core-js/modules/es7.reflect.define-metadata.js");

__webpack_require__("./node_modules/core-js/modules/es7.reflect.delete-metadata.js");

__webpack_require__("./node_modules/core-js/modules/es7.reflect.get-metadata.js");

__webpack_require__("./node_modules/core-js/modules/es7.reflect.get-metadata-keys.js");

__webpack_require__("./node_modules/core-js/modules/es7.reflect.get-own-metadata.js");

__webpack_require__("./node_modules/core-js/modules/es7.reflect.get-own-metadata-keys.js");

__webpack_require__("./node_modules/core-js/modules/es7.reflect.has-metadata.js");

__webpack_require__("./node_modules/core-js/modules/es7.reflect.has-own-metadata.js");

__webpack_require__("./node_modules/core-js/modules/es7.reflect.metadata.js");

__webpack_require__("./node_modules/core-js/modules/es7.asap.js");

__webpack_require__("./node_modules/core-js/modules/es7.observable.js");

__webpack_require__("./node_modules/core-js/modules/web.timers.js");

__webpack_require__("./node_modules/core-js/modules/web.immediate.js");

__webpack_require__("./node_modules/core-js/modules/web.dom.iterable.js");

module.exports = __webpack_require__("./node_modules/core-js/modules/_core.js");

/***/ }),

/***/ "./node_modules/fbjs/lib/emptyFunction.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

function makeEmptyFunction(arg) {
  return function () {
    return arg;
  };
}
/**
 * This function accepts and discards inputs; it has no side effects. This is
 * primarily useful idiomatically for overridable function endpoints which
 * always need to be callable, since JS lacks a null-call idiom ala Cocoa.
 */


var emptyFunction = function emptyFunction() {};

emptyFunction.thatReturns = makeEmptyFunction;
emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
emptyFunction.thatReturnsNull = makeEmptyFunction(null);

emptyFunction.thatReturnsThis = function () {
  return this;
};

emptyFunction.thatReturnsArgument = function (arg) {
  return arg;
};

module.exports = emptyFunction;

/***/ }),

/***/ "./node_modules/fbjs/lib/emptyObject.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */


var emptyObject = {};

if (process.env.NODE_ENV !== 'production') {
  Object.freeze(emptyObject);
}

module.exports = emptyObject;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__("./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/fbjs/lib/invariant.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

/**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */

var validateFormat = function validateFormat(format) {};

if (process.env.NODE_ENV !== 'production') {
  validateFormat = function validateFormat(format) {
    if (format === undefined) {
      throw new Error('invariant requires an error message argument');
    }
  };
}

function invariant(condition, format, a, b, c, d, e, f) {
  validateFormat(format);

  if (!condition) {
    var error;

    if (format === undefined) {
      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
    } else {
      var args = [a, b, c, d, e, f];
      var argIndex = 0;
      error = new Error(format.replace(/%s/g, function () {
        return args[argIndex++];
      }));
      error.name = 'Invariant Violation';
    }

    error.framesToPop = 1; // we don't care about invariant's own frame

    throw error;
  }
}

module.exports = invariant;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__("./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/fbjs/lib/shallowEqual.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 * 
 */

/*eslint-disable no-self-compare */


var hasOwnProperty = Object.prototype.hasOwnProperty;
/**
 * inlined Object.is polyfill to avoid requiring consumers ship their own
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
 */

function is(x, y) {
  // SameValue algorithm
  if (x === y) {
    // Steps 1-5, 7-10
    // Steps 6.b-6.e: +0 != -0
    // Added the nonzero y check to make Flow happy, but it is redundant
    return x !== 0 || y !== 0 || 1 / x === 1 / y;
  } else {
    // Step 6.a: NaN == NaN
    return x !== x && y !== y;
  }
}
/**
 * Performs equality by iterating through keys on an object and returning false
 * when any key has values which are not strictly equal between the arguments.
 * Returns true when the values of all keys are strictly equal.
 */


function shallowEqual(objA, objB) {
  if (is(objA, objB)) {
    return true;
  }

  if (typeof objA !== 'object' || objA === null || typeof objB !== 'object' || objB === null) {
    return false;
  }

  var keysA = Object.keys(objA);
  var keysB = Object.keys(objB);

  if (keysA.length !== keysB.length) {
    return false;
  } // Test for A's keys different from B.


  for (var i = 0; i < keysA.length; i++) {
    if (!hasOwnProperty.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {
      return false;
    }
  }

  return true;
}

module.exports = shallowEqual;

/***/ }),

/***/ "./node_modules/fbjs/lib/warning.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */


var emptyFunction = __webpack_require__("./node_modules/fbjs/lib/emptyFunction.js");
/**
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */


var warning = emptyFunction;

if (process.env.NODE_ENV !== 'production') {
  var printWarning = function printWarning(format) {
    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    var argIndex = 0;
    var message = 'Warning: ' + format.replace(/%s/g, function () {
      return args[argIndex++];
    });

    if (typeof console !== 'undefined') {
      console.error(message);
    }

    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  };

  warning = function warning(condition, format) {
    if (format === undefined) {
      throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
    }

    if (format.indexOf('Failed Composite propType: ') === 0) {
      return; // Ignore CompositeComponent proptype check.
    }

    if (!condition) {
      for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
        args[_key2 - 2] = arguments[_key2];
      }

      printWarning.apply(undefined, [format].concat(args));
    }
  };
}

module.exports = warning;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__("./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/howler/dist/howler.js":
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
 *  howler.js v2.0.5
 *  howlerjs.com
 *
 *  (c) 2013-2017, James Simpson of GoldFire Studios
 *  goldfirestudios.com
 *
 *  MIT License
 */
(function () {
  'use strict';
  /** Global Methods **/

  /***************************************************************************/

  /**
   * Create the global controller. All contained methods and properties apply
   * to all sounds that are currently playing or will be in the future.
   */

  var HowlerGlobal = function HowlerGlobal() {
    this.init();
  };

  HowlerGlobal.prototype = {
    /**
     * Initialize the global Howler object.
     * @return {Howler}
     */
    init: function init() {
      var self = this || Howler; // Create a global ID counter.

      self._counter = 1000; // Internal properties.

      self._codecs = {};
      self._howls = [];
      self._muted = false;
      self._volume = 1;
      self._canPlayEvent = 'canplaythrough';
      self._navigator = typeof window !== 'undefined' && window.navigator ? window.navigator : null; // Public properties.

      self.masterGain = null;
      self.noAudio = false;
      self.usingWebAudio = true;
      self.autoSuspend = true;
      self.ctx = null; // Set to false to disable the auto iOS enabler.

      self.mobileAutoEnable = true; // Setup the various state values for global tracking.

      self._setup();

      return self;
    },

    /**
     * Get/set the global volume for all sounds.
     * @param  {Float} vol Volume from 0.0 to 1.0.
     * @return {Howler/Float}     Returns self or current volume.
     */
    volume: function volume(vol) {
      var self = this || Howler;
      vol = parseFloat(vol); // If we don't have an AudioContext created yet, run the setup.

      if (!self.ctx) {
        setupAudioContext();
      }

      if (typeof vol !== 'undefined' && vol >= 0 && vol <= 1) {
        self._volume = vol; // Don't update any of the nodes if we are muted.

        if (self._muted) {
          return self;
        } // When using Web Audio, we just need to adjust the master gain.


        if (self.usingWebAudio) {
          self.masterGain.gain.value = vol;
        } // Loop through and change volume for all HTML5 audio nodes.


        for (var i = 0; i < self._howls.length; i++) {
          if (!self._howls[i]._webAudio) {
            // Get all of the sounds in this Howl group.
            var ids = self._howls[i]._getSoundIds(); // Loop through all sounds and change the volumes.


            for (var j = 0; j < ids.length; j++) {
              var sound = self._howls[i]._soundById(ids[j]);

              if (sound && sound._node) {
                sound._node.volume = sound._volume * vol;
              }
            }
          }
        }

        return self;
      }

      return self._volume;
    },

    /**
     * Handle muting and unmuting globally.
     * @param  {Boolean} muted Is muted or not.
     */
    mute: function mute(muted) {
      var self = this || Howler; // If we don't have an AudioContext created yet, run the setup.

      if (!self.ctx) {
        setupAudioContext();
      }

      self._muted = muted; // With Web Audio, we just need to mute the master gain.

      if (self.usingWebAudio) {
        self.masterGain.gain.value = muted ? 0 : self._volume;
      } // Loop through and mute all HTML5 Audio nodes.


      for (var i = 0; i < self._howls.length; i++) {
        if (!self._howls[i]._webAudio) {
          // Get all of the sounds in this Howl group.
          var ids = self._howls[i]._getSoundIds(); // Loop through all sounds and mark the audio node as muted.


          for (var j = 0; j < ids.length; j++) {
            var sound = self._howls[i]._soundById(ids[j]);

            if (sound && sound._node) {
              sound._node.muted = muted ? true : sound._muted;
            }
          }
        }
      }

      return self;
    },

    /**
     * Unload and destroy all currently loaded Howl objects.
     * @return {Howler}
     */
    unload: function unload() {
      var self = this || Howler;

      for (var i = self._howls.length - 1; i >= 0; i--) {
        self._howls[i].unload();
      } // Create a new AudioContext to make sure it is fully reset.


      if (self.usingWebAudio && self.ctx && typeof self.ctx.close !== 'undefined') {
        self.ctx.close();
        self.ctx = null;
        setupAudioContext();
      }

      return self;
    },

    /**
     * Check for codec support of specific extension.
     * @param  {String} ext Audio file extention.
     * @return {Boolean}
     */
    codecs: function codecs(ext) {
      return (this || Howler)._codecs[ext.replace(/^x-/, '')];
    },

    /**
     * Setup various state values for global tracking.
     * @return {Howler}
     */
    _setup: function _setup() {
      var self = this || Howler; // Keeps track of the suspend/resume state of the AudioContext.

      self.state = self.ctx ? self.ctx.state || 'running' : 'running'; // Automatically begin the 30-second suspend process

      self._autoSuspend(); // Check if audio is available.


      if (!self.usingWebAudio) {
        // No audio is available on this system if noAudio is set to true.
        if (typeof Audio !== 'undefined') {
          try {
            var test = new Audio(); // Check if the canplaythrough event is available.

            if (typeof test.oncanplaythrough === 'undefined') {
              self._canPlayEvent = 'canplay';
            }
          } catch (e) {
            self.noAudio = true;
          }
        } else {
          self.noAudio = true;
        }
      } // Test to make sure audio isn't disabled in Internet Explorer.


      try {
        var test = new Audio();

        if (test.muted) {
          self.noAudio = true;
        }
      } catch (e) {} // Check for supported codecs.


      if (!self.noAudio) {
        self._setupCodecs();
      }

      return self;
    },

    /**
     * Check for browser support for various codecs and cache the results.
     * @return {Howler}
     */
    _setupCodecs: function _setupCodecs() {
      var self = this || Howler;
      var audioTest = null; // Must wrap in a try/catch because IE11 in server mode throws an error.

      try {
        audioTest = typeof Audio !== 'undefined' ? new Audio() : null;
      } catch (err) {
        return self;
      }

      if (!audioTest || typeof audioTest.canPlayType !== 'function') {
        return self;
      }

      var mpegTest = audioTest.canPlayType('audio/mpeg;').replace(/^no$/, ''); // Opera version <33 has mixed MP3 support, so we need to check for and block it.

      var checkOpera = self._navigator && self._navigator.userAgent.match(/OPR\/([0-6].)/g);

      var isOldOpera = checkOpera && parseInt(checkOpera[0].split('/')[1], 10) < 33;
      self._codecs = {
        mp3: !!(!isOldOpera && (mpegTest || audioTest.canPlayType('audio/mp3;').replace(/^no$/, ''))),
        mpeg: !!mpegTest,
        opus: !!audioTest.canPlayType('audio/ogg; codecs="opus"').replace(/^no$/, ''),
        ogg: !!audioTest.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ''),
        oga: !!audioTest.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ''),
        wav: !!audioTest.canPlayType('audio/wav; codecs="1"').replace(/^no$/, ''),
        aac: !!audioTest.canPlayType('audio/aac;').replace(/^no$/, ''),
        caf: !!audioTest.canPlayType('audio/x-caf;').replace(/^no$/, ''),
        m4a: !!(audioTest.canPlayType('audio/x-m4a;') || audioTest.canPlayType('audio/m4a;') || audioTest.canPlayType('audio/aac;')).replace(/^no$/, ''),
        mp4: !!(audioTest.canPlayType('audio/x-mp4;') || audioTest.canPlayType('audio/mp4;') || audioTest.canPlayType('audio/aac;')).replace(/^no$/, ''),
        weba: !!audioTest.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, ''),
        webm: !!audioTest.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, ''),
        dolby: !!audioTest.canPlayType('audio/mp4; codecs="ec-3"').replace(/^no$/, ''),
        flac: !!(audioTest.canPlayType('audio/x-flac;') || audioTest.canPlayType('audio/flac;')).replace(/^no$/, '')
      };
      return self;
    },

    /**
     * Mobile browsers will only allow audio to be played after a user interaction.
     * Attempt to automatically unlock audio on the first user interaction.
     * Concept from: http://paulbakaus.com/tutorials/html5/web-audio-on-ios/
     * @return {Howler}
     */
    _enableMobileAudio: function _enableMobileAudio() {
      var self = this || Howler; // Only run this on mobile devices if audio isn't already eanbled.

      var isMobile = /iPhone|iPad|iPod|Android|BlackBerry|BB10|Silk|Mobi/i.test(self._navigator && self._navigator.userAgent);
      var isTouch = !!('ontouchend' in window || self._navigator && self._navigator.maxTouchPoints > 0 || self._navigator && self._navigator.msMaxTouchPoints > 0);

      if (self._mobileEnabled || !self.ctx || !isMobile && !isTouch) {
        return;
      }

      self._mobileEnabled = false; // Some mobile devices/platforms have distortion issues when opening/closing tabs and/or web views.
      // Bugs in the browser (especially Mobile Safari) can cause the sampleRate to change from 44100 to 48000.
      // By calling Howler.unload(), we create a new AudioContext with the correct sampleRate.

      if (!self._mobileUnloaded && self.ctx.sampleRate !== 44100) {
        self._mobileUnloaded = true;
        self.unload();
      } // Scratch buffer for enabling iOS to dispose of web audio buffers correctly, as per:
      // http://stackoverflow.com/questions/24119684


      self._scratchBuffer = self.ctx.createBuffer(1, 1, 22050); // Call this method on touch start to create and play a buffer,
      // then check if the audio actually played to determine if
      // audio has now been unlocked on iOS, Android, etc.

      var unlock = function unlock() {
        // Fix Android can not play in suspend state.
        Howler._autoResume(); // Create an empty buffer.


        var source = self.ctx.createBufferSource();
        source.buffer = self._scratchBuffer;
        source.connect(self.ctx.destination); // Play the empty buffer.

        if (typeof source.start === 'undefined') {
          source.noteOn(0);
        } else {
          source.start(0);
        } // Calling resume() on a stack initiated by user gesture is what actually unlocks the audio on Android Chrome >= 55.


        if (typeof self.ctx.resume === 'function') {
          self.ctx.resume();
        } // Setup a timeout to check that we are unlocked on the next event loop.


        source.onended = function () {
          source.disconnect(0); // Update the unlocked state and prevent this check from happening again.

          self._mobileEnabled = true;
          self.mobileAutoEnable = false; // Remove the touch start listener.

          document.removeEventListener('touchstart', unlock, true);
          document.removeEventListener('touchend', unlock, true);
        };
      }; // Setup a touch start listener to attempt an unlock in.


      document.addEventListener('touchstart', unlock, true);
      document.addEventListener('touchend', unlock, true);
      return self;
    },

    /**
     * Automatically suspend the Web Audio AudioContext after no sound has played for 30 seconds.
     * This saves processing/energy and fixes various browser-specific bugs with audio getting stuck.
     * @return {Howler}
     */
    _autoSuspend: function _autoSuspend() {
      var self = this;

      if (!self.autoSuspend || !self.ctx || typeof self.ctx.suspend === 'undefined' || !Howler.usingWebAudio) {
        return;
      } // Check if any sounds are playing.


      for (var i = 0; i < self._howls.length; i++) {
        if (self._howls[i]._webAudio) {
          for (var j = 0; j < self._howls[i]._sounds.length; j++) {
            if (!self._howls[i]._sounds[j]._paused) {
              return self;
            }
          }
        }
      }

      if (self._suspendTimer) {
        clearTimeout(self._suspendTimer);
      } // If no sound has played after 30 seconds, suspend the context.


      self._suspendTimer = setTimeout(function () {
        if (!self.autoSuspend) {
          return;
        }

        self._suspendTimer = null;
        self.state = 'suspending';
        self.ctx.suspend().then(function () {
          self.state = 'suspended';

          if (self._resumeAfterSuspend) {
            delete self._resumeAfterSuspend;

            self._autoResume();
          }
        });
      }, 30000);
      return self;
    },

    /**
     * Automatically resume the Web Audio AudioContext when a new sound is played.
     * @return {Howler}
     */
    _autoResume: function _autoResume() {
      var self = this;

      if (!self.ctx || typeof self.ctx.resume === 'undefined' || !Howler.usingWebAudio) {
        return;
      }

      if (self.state === 'running' && self._suspendTimer) {
        clearTimeout(self._suspendTimer);
        self._suspendTimer = null;
      } else if (self.state === 'suspended') {
        self.ctx.resume().then(function () {
          self.state = 'running'; // Emit to all Howls that the audio has resumed.

          for (var i = 0; i < self._howls.length; i++) {
            self._howls[i]._emit('resume');
          }
        });

        if (self._suspendTimer) {
          clearTimeout(self._suspendTimer);
          self._suspendTimer = null;
        }
      } else if (self.state === 'suspending') {
        self._resumeAfterSuspend = true;
      }

      return self;
    }
  }; // Setup the global audio controller.

  var Howler = new HowlerGlobal();
  /** Group Methods **/

  /***************************************************************************/

  /**
   * Create an audio group controller.
   * @param {Object} o Passed in properties for this group.
   */

  var Howl = function Howl(o) {
    var self = this; // Throw an error if no source is provided.

    if (!o.src || o.src.length === 0) {
      console.error('An array of source files must be passed with any new Howl.');
      return;
    }

    self.init(o);
  };

  Howl.prototype = {
    /**
     * Initialize a new Howl group object.
     * @param  {Object} o Passed in properties for this group.
     * @return {Howl}
     */
    init: function init(o) {
      var self = this; // If we don't have an AudioContext created yet, run the setup.

      if (!Howler.ctx) {
        setupAudioContext();
      } // Setup user-defined default properties.


      self._autoplay = o.autoplay || false;
      self._format = typeof o.format !== 'string' ? o.format : [o.format];
      self._html5 = o.html5 || false;
      self._muted = o.mute || false;
      self._loop = o.loop || false;
      self._pool = o.pool || 5;
      self._preload = typeof o.preload === 'boolean' ? o.preload : true;
      self._rate = o.rate || 1;
      self._sprite = o.sprite || {};
      self._src = typeof o.src !== 'string' ? o.src : [o.src];
      self._volume = o.volume !== undefined ? o.volume : 1;
      self._xhrWithCredentials = o.xhrWithCredentials || false; // Setup all other default properties.

      self._duration = 0;
      self._state = 'unloaded';
      self._sounds = [];
      self._endTimers = {};
      self._queue = []; // Setup event listeners.

      self._onend = o.onend ? [{
        fn: o.onend
      }] : [];
      self._onfade = o.onfade ? [{
        fn: o.onfade
      }] : [];
      self._onload = o.onload ? [{
        fn: o.onload
      }] : [];
      self._onloaderror = o.onloaderror ? [{
        fn: o.onloaderror
      }] : [];
      self._onplayerror = o.onplayerror ? [{
        fn: o.onplayerror
      }] : [];
      self._onpause = o.onpause ? [{
        fn: o.onpause
      }] : [];
      self._onplay = o.onplay ? [{
        fn: o.onplay
      }] : [];
      self._onstop = o.onstop ? [{
        fn: o.onstop
      }] : [];
      self._onmute = o.onmute ? [{
        fn: o.onmute
      }] : [];
      self._onvolume = o.onvolume ? [{
        fn: o.onvolume
      }] : [];
      self._onrate = o.onrate ? [{
        fn: o.onrate
      }] : [];
      self._onseek = o.onseek ? [{
        fn: o.onseek
      }] : [];
      self._onresume = []; // Web Audio or HTML5 Audio?

      self._webAudio = Howler.usingWebAudio && !self._html5; // Automatically try to enable audio on iOS.

      if (typeof Howler.ctx !== 'undefined' && Howler.ctx && Howler.mobileAutoEnable) {
        Howler._enableMobileAudio();
      } // Keep track of this Howl group in the global controller.


      Howler._howls.push(self); // If they selected autoplay, add a play event to the load queue.


      if (self._autoplay) {
        self._queue.push({
          event: 'play',
          action: function action() {
            self.play();
          }
        });
      } // Load the source file unless otherwise specified.


      if (self._preload) {
        self.load();
      }

      return self;
    },

    /**
     * Load the audio file.
     * @return {Howler}
     */
    load: function load() {
      var self = this;
      var url = null; // If no audio is available, quit immediately.

      if (Howler.noAudio) {
        self._emit('loaderror', null, 'No audio support.');

        return;
      } // Make sure our source is in an array.


      if (typeof self._src === 'string') {
        self._src = [self._src];
      } // Loop through the sources and pick the first one that is compatible.


      for (var i = 0; i < self._src.length; i++) {
        var ext, str;

        if (self._format && self._format[i]) {
          // If an extension was specified, use that instead.
          ext = self._format[i];
        } else {
          // Make sure the source is a string.
          str = self._src[i];

          if (typeof str !== 'string') {
            self._emit('loaderror', null, 'Non-string found in selected audio sources - ignoring.');

            continue;
          } // Extract the file extension from the URL or base64 data URI.


          ext = /^data:audio\/([^;,]+);/i.exec(str);

          if (!ext) {
            ext = /\.([^.]+)$/.exec(str.split('?', 1)[0]);
          }

          if (ext) {
            ext = ext[1].toLowerCase();
          }
        } // Log a warning if no extension was found.


        if (!ext) {
          console.warn('No file extension was found. Consider using the "format" property or specify an extension.');
        } // Check if this extension is available.


        if (ext && Howler.codecs(ext)) {
          url = self._src[i];
          break;
        }
      }

      if (!url) {
        self._emit('loaderror', null, 'No codec support for selected audio sources.');

        return;
      }

      self._src = url;
      self._state = 'loading'; // If the hosting page is HTTPS and the source isn't,
      // drop down to HTML5 Audio to avoid Mixed Content errors.

      if (window.location.protocol === 'https:' && url.slice(0, 5) === 'http:') {
        self._html5 = true;
        self._webAudio = false;
      } // Create a new sound object and add it to the pool.


      new Sound(self); // Load and decode the audio data for playback.

      if (self._webAudio) {
        loadBuffer(self);
      }

      return self;
    },

    /**
     * Play a sound or resume previous playback.
     * @param  {String/Number} sprite   Sprite name for sprite playback or sound id to continue previous.
     * @param  {Boolean} internal Internal Use: true prevents event firing.
     * @return {Number}          Sound ID.
     */
    play: function play(sprite, internal) {
      var self = this;
      var id = null; // Determine if a sprite, sound id or nothing was passed

      if (typeof sprite === 'number') {
        id = sprite;
        sprite = null;
      } else if (typeof sprite === 'string' && self._state === 'loaded' && !self._sprite[sprite]) {
        // If the passed sprite doesn't exist, do nothing.
        return null;
      } else if (typeof sprite === 'undefined') {
        // Use the default sound sprite (plays the full audio length).
        sprite = '__default'; // Check if there is a single paused sound that isn't ended.
        // If there is, play that sound. If not, continue as usual.

        var num = 0;

        for (var i = 0; i < self._sounds.length; i++) {
          if (self._sounds[i]._paused && !self._sounds[i]._ended) {
            num++;
            id = self._sounds[i]._id;
          }
        }

        if (num === 1) {
          sprite = null;
        } else {
          id = null;
        }
      } // Get the selected node, or get one from the pool.


      var sound = id ? self._soundById(id) : self._inactiveSound(); // If the sound doesn't exist, do nothing.

      if (!sound) {
        return null;
      } // Select the sprite definition.


      if (id && !sprite) {
        sprite = sound._sprite || '__default';
      } // If the sound hasn't loaded, we must wait to get the audio's duration.
      // We also need to wait to make sure we don't run into race conditions with
      // the order of function calls.


      if (self._state !== 'loaded') {
        // Set the sprite value on this sound.
        sound._sprite = sprite; // Makr this sounded as not ended in case another sound is played before this one loads.

        sound._ended = false; // Add the sound to the queue to be played on load.

        var soundId = sound._id;

        self._queue.push({
          event: 'play',
          action: function action() {
            self.play(soundId);
          }
        });

        return soundId;
      } // Don't play the sound if an id was passed and it is already playing.


      if (id && !sound._paused) {
        // Trigger the play event, in order to keep iterating through queue.
        if (!internal) {
          setTimeout(function () {
            self._emit('play', sound._id);
          }, 0);
        }

        return sound._id;
      } // Make sure the AudioContext isn't suspended, and resume it if it is.


      if (self._webAudio) {
        Howler._autoResume();
      } // Determine how long to play for and where to start playing.


      var seek = Math.max(0, sound._seek > 0 ? sound._seek : self._sprite[sprite][0] / 1000);
      var duration = Math.max(0, (self._sprite[sprite][0] + self._sprite[sprite][1]) / 1000 - seek);
      var timeout = duration * 1000 / Math.abs(sound._rate); // Update the parameters of the sound

      sound._paused = false;
      sound._ended = false;
      sound._sprite = sprite;
      sound._seek = seek;
      sound._start = self._sprite[sprite][0] / 1000;
      sound._stop = (self._sprite[sprite][0] + self._sprite[sprite][1]) / 1000;
      sound._loop = !!(sound._loop || self._sprite[sprite][2]); // Begin the actual playback.

      var node = sound._node;

      if (self._webAudio) {
        // Fire this when the sound is ready to play to begin Web Audio playback.
        var playWebAudio = function playWebAudio() {
          self._refreshBuffer(sound); // Setup the playback params.


          var vol = sound._muted || self._muted ? 0 : sound._volume;
          node.gain.setValueAtTime(vol, Howler.ctx.currentTime);
          sound._playStart = Howler.ctx.currentTime; // Play the sound using the supported method.

          if (typeof node.bufferSource.start === 'undefined') {
            sound._loop ? node.bufferSource.noteGrainOn(0, seek, 86400) : node.bufferSource.noteGrainOn(0, seek, duration);
          } else {
            sound._loop ? node.bufferSource.start(0, seek, 86400) : node.bufferSource.start(0, seek, duration);
          } // Start a new timer if none is present.


          if (timeout !== Infinity) {
            self._endTimers[sound._id] = setTimeout(self._ended.bind(self, sound), timeout);
          }

          if (!internal) {
            setTimeout(function () {
              self._emit('play', sound._id);
            }, 0);
          }
        };

        if (Howler.state === 'running') {
          playWebAudio();
        } else {
          self.once('resume', playWebAudio); // Cancel the end timer.

          self._clearTimer(sound._id);
        }
      } else {
        // Fire this when the sound is ready to play to begin HTML5 Audio playback.
        var playHtml5 = function playHtml5() {
          node.currentTime = seek;
          node.muted = sound._muted || self._muted || Howler._muted || node.muted;
          node.volume = sound._volume * Howler.volume();
          node.playbackRate = sound._rate; // Mobile browsers will throw an error if this is called without user interaction.

          try {
            node.play(); // If the node is still paused, then we can assume there was a playback issue.

            if (node.paused) {
              self._emit('playerror', sound._id, 'Playback was unable to start. This is most commonly an issue ' + 'on mobile devices where playback was not within a user interaction.');

              return;
            } // Setup the new end timer.


            if (timeout !== Infinity) {
              self._endTimers[sound._id] = setTimeout(self._ended.bind(self, sound), timeout);
            }

            if (!internal) {
              self._emit('play', sound._id);
            }
          } catch (err) {
            self._emit('playerror', sound._id, err);
          }
        }; // Play immediately if ready, or wait for the 'canplaythrough'e vent.


        var loadedNoReadyState = window && window.ejecta || !node.readyState && Howler._navigator.isCocoonJS;

        if (node.readyState === 4 || loadedNoReadyState) {
          playHtml5();
        } else {
          var listener = function listener() {
            // Begin playback.
            playHtml5(); // Clear this listener.

            node.removeEventListener(Howler._canPlayEvent, listener, false);
          };

          node.addEventListener(Howler._canPlayEvent, listener, false); // Cancel the end timer.

          self._clearTimer(sound._id);
        }
      }

      return sound._id;
    },

    /**
     * Pause playback and save current position.
     * @param  {Number} id The sound ID (empty to pause all in group).
     * @return {Howl}
     */
    pause: function pause(id) {
      var self = this; // If the sound hasn't loaded, add it to the load queue to pause when capable.

      if (self._state !== 'loaded') {
        self._queue.push({
          event: 'pause',
          action: function action() {
            self.pause(id);
          }
        });

        return self;
      } // If no id is passed, get all ID's to be paused.


      var ids = self._getSoundIds(id);

      for (var i = 0; i < ids.length; i++) {
        // Clear the end timer.
        self._clearTimer(ids[i]); // Get the sound.


        var sound = self._soundById(ids[i]);

        if (sound && !sound._paused) {
          // Reset the seek position.
          sound._seek = self.seek(ids[i]);
          sound._rateSeek = 0;
          sound._paused = true; // Stop currently running fades.

          self._stopFade(ids[i]);

          if (sound._node) {
            if (self._webAudio) {
              // Make sure the sound has been created.
              if (!sound._node.bufferSource) {
                continue;
              }

              if (typeof sound._node.bufferSource.stop === 'undefined') {
                sound._node.bufferSource.noteOff(0);
              } else {
                sound._node.bufferSource.stop(0);
              } // Clean up the buffer source.


              self._cleanBuffer(sound._node);
            } else if (!isNaN(sound._node.duration) || sound._node.duration === Infinity) {
              sound._node.pause();
            }
          }
        } // Fire the pause event, unless `true` is passed as the 2nd argument.


        if (!arguments[1]) {
          self._emit('pause', sound ? sound._id : null);
        }
      }

      return self;
    },

    /**
     * Stop playback and reset to start.
     * @param  {Number} id The sound ID (empty to stop all in group).
     * @param  {Boolean} internal Internal Use: true prevents event firing.
     * @return {Howl}
     */
    stop: function stop(id, internal) {
      var self = this; // If the sound hasn't loaded, add it to the load queue to stop when capable.

      if (self._state !== 'loaded') {
        self._queue.push({
          event: 'stop',
          action: function action() {
            self.stop(id);
          }
        });

        return self;
      } // If no id is passed, get all ID's to be stopped.


      var ids = self._getSoundIds(id);

      for (var i = 0; i < ids.length; i++) {
        // Clear the end timer.
        self._clearTimer(ids[i]); // Get the sound.


        var sound = self._soundById(ids[i]);

        if (sound) {
          // Reset the seek position.
          sound._seek = sound._start || 0;
          sound._rateSeek = 0;
          sound._paused = true;
          sound._ended = true; // Stop currently running fades.

          self._stopFade(ids[i]);

          if (sound._node) {
            if (self._webAudio) {
              // Make sure the sound's AudioBufferSourceNode has been created.
              if (sound._node.bufferSource) {
                if (typeof sound._node.bufferSource.stop === 'undefined') {
                  sound._node.bufferSource.noteOff(0);
                } else {
                  sound._node.bufferSource.stop(0);
                } // Clean up the buffer source.


                self._cleanBuffer(sound._node);
              }
            } else if (!isNaN(sound._node.duration) || sound._node.duration === Infinity) {
              sound._node.currentTime = sound._start || 0;

              sound._node.pause();
            }
          }

          if (!internal) {
            self._emit('stop', sound._id);
          }
        }
      }

      return self;
    },

    /**
     * Mute/unmute a single sound or all sounds in this Howl group.
     * @param  {Boolean} muted Set to true to mute and false to unmute.
     * @param  {Number} id    The sound ID to update (omit to mute/unmute all).
     * @return {Howl}
     */
    mute: function mute(muted, id) {
      var self = this; // If the sound hasn't loaded, add it to the load queue to mute when capable.

      if (self._state !== 'loaded') {
        self._queue.push({
          event: 'mute',
          action: function action() {
            self.mute(muted, id);
          }
        });

        return self;
      } // If applying mute/unmute to all sounds, update the group's value.


      if (typeof id === 'undefined') {
        if (typeof muted === 'boolean') {
          self._muted = muted;
        } else {
          return self._muted;
        }
      } // If no id is passed, get all ID's to be muted.


      var ids = self._getSoundIds(id);

      for (var i = 0; i < ids.length; i++) {
        // Get the sound.
        var sound = self._soundById(ids[i]);

        if (sound) {
          sound._muted = muted;

          if (self._webAudio && sound._node) {
            sound._node.gain.setValueAtTime(muted ? 0 : sound._volume, Howler.ctx.currentTime);
          } else if (sound._node) {
            sound._node.muted = Howler._muted ? true : muted;
          }

          self._emit('mute', sound._id);
        }
      }

      return self;
    },

    /**
     * Get/set the volume of this sound or of the Howl group. This method can optionally take 0, 1 or 2 arguments.
     *   volume() -> Returns the group's volume value.
     *   volume(id) -> Returns the sound id's current volume.
     *   volume(vol) -> Sets the volume of all sounds in this Howl group.
     *   volume(vol, id) -> Sets the volume of passed sound id.
     * @return {Howl/Number} Returns self or current volume.
     */
    volume: function volume() {
      var self = this;
      var args = arguments;
      var vol, id; // Determine the values based on arguments.

      if (args.length === 0) {
        // Return the value of the groups' volume.
        return self._volume;
      } else if (args.length === 1 || args.length === 2 && typeof args[1] === 'undefined') {
        // First check if this is an ID, and if not, assume it is a new volume.
        var ids = self._getSoundIds();

        var index = ids.indexOf(args[0]);

        if (index >= 0) {
          id = parseInt(args[0], 10);
        } else {
          vol = parseFloat(args[0]);
        }
      } else if (args.length >= 2) {
        vol = parseFloat(args[0]);
        id = parseInt(args[1], 10);
      } // Update the volume or return the current volume.


      var sound;

      if (typeof vol !== 'undefined' && vol >= 0 && vol <= 1) {
        // If the sound hasn't loaded, add it to the load queue to change volume when capable.
        if (self._state !== 'loaded') {
          self._queue.push({
            event: 'volume',
            action: function action() {
              self.volume.apply(self, args);
            }
          });

          return self;
        } // Set the group volume.


        if (typeof id === 'undefined') {
          self._volume = vol;
        } // Update one or all volumes.


        id = self._getSoundIds(id);

        for (var i = 0; i < id.length; i++) {
          // Get the sound.
          sound = self._soundById(id[i]);

          if (sound) {
            sound._volume = vol; // Stop currently running fades.

            if (!args[2]) {
              self._stopFade(id[i]);
            }

            if (self._webAudio && sound._node && !sound._muted) {
              sound._node.gain.setValueAtTime(vol, Howler.ctx.currentTime);
            } else if (sound._node && !sound._muted) {
              sound._node.volume = vol * Howler.volume();
            }

            self._emit('volume', sound._id);
          }
        }
      } else {
        sound = id ? self._soundById(id) : self._sounds[0];
        return sound ? sound._volume : 0;
      }

      return self;
    },

    /**
     * Fade a currently playing sound between two volumes (if no id is passsed, all sounds will fade).
     * @param  {Number} from The value to fade from (0.0 to 1.0).
     * @param  {Number} to   The volume to fade to (0.0 to 1.0).
     * @param  {Number} len  Time in milliseconds to fade.
     * @param  {Number} id   The sound id (omit to fade all sounds).
     * @return {Howl}
     */
    fade: function fade(from, to, len, id) {
      var self = this; // If the sound hasn't loaded, add it to the load queue to fade when capable.

      if (self._state !== 'loaded') {
        self._queue.push({
          event: 'fade',
          action: function action() {
            self.fade(from, to, len, id);
          }
        });

        return self;
      } // Set the volume to the start position.


      self.volume(from, id); // Fade the volume of one or all sounds.

      var ids = self._getSoundIds(id);

      for (var i = 0; i < ids.length; i++) {
        // Get the sound.
        var sound = self._soundById(ids[i]); // Create a linear fade or fall back to timeouts with HTML5 Audio.


        if (sound) {
          // Stop the previous fade if no sprite is being used (otherwise, volume handles this).
          if (!id) {
            self._stopFade(ids[i]);
          } // If we are using Web Audio, let the native methods do the actual fade.


          if (self._webAudio && !sound._muted) {
            var currentTime = Howler.ctx.currentTime;
            var end = currentTime + len / 1000;
            sound._volume = from;

            sound._node.gain.setValueAtTime(from, currentTime);

            sound._node.gain.linearRampToValueAtTime(to, end);
          }

          self._startFadeInterval(sound, from, to, len, ids[i]);
        }
      }

      return self;
    },

    /**
     * Starts the internal interval to fade a sound.
     * @param  {Object} sound Reference to sound to fade.
     * @param  {Number} from The value to fade from (0.0 to 1.0).
     * @param  {Number} to   The volume to fade to (0.0 to 1.0).
     * @param  {Number} len  Time in milliseconds to fade.
     * @param  {Number} id   The sound id to fade.
     */
    _startFadeInterval: function _startFadeInterval(sound, from, to, len, id) {
      var self = this;
      var vol = from;
      var dir = from > to ? 'out' : 'in';
      var diff = Math.abs(from - to);
      var steps = diff / 0.01;
      var stepLen = steps > 0 ? len / steps : len; // Since browsers clamp timeouts to 4ms, we need to clamp our steps to that too.

      if (stepLen < 4) {
        steps = Math.ceil(steps / (4 / stepLen));
        stepLen = 4;
      }

      sound._interval = setInterval(function () {
        // Update the volume amount, but only if the volume should change.
        if (steps > 0) {
          vol += dir === 'in' ? 0.01 : -0.01;
        } // Make sure the volume is in the right bounds.


        vol = Math.max(0, vol);
        vol = Math.min(1, vol); // Round to within 2 decimal points.

        vol = Math.round(vol * 100) / 100; // Change the volume.

        if (self._webAudio) {
          if (typeof id === 'undefined') {
            self._volume = vol;
          }

          sound._volume = vol;
        } else {
          self.volume(vol, sound._id, true);
        } // When the fade is complete, stop it and fire event.


        if (to < from && vol <= to || to > from && vol >= to) {
          clearInterval(sound._interval);
          sound._interval = null;
          self.volume(to, sound._id);

          self._emit('fade', sound._id);
        }
      }, stepLen);
    },

    /**
     * Internal method that stops the currently playing fade when
     * a new fade starts, volume is changed or the sound is stopped.
     * @param  {Number} id The sound id.
     * @return {Howl}
     */
    _stopFade: function _stopFade(id) {
      var self = this;

      var sound = self._soundById(id);

      if (sound && sound._interval) {
        if (self._webAudio) {
          sound._node.gain.cancelScheduledValues(Howler.ctx.currentTime);
        }

        clearInterval(sound._interval);
        sound._interval = null;

        self._emit('fade', id);
      }

      return self;
    },

    /**
     * Get/set the loop parameter on a sound. This method can optionally take 0, 1 or 2 arguments.
     *   loop() -> Returns the group's loop value.
     *   loop(id) -> Returns the sound id's loop value.
     *   loop(loop) -> Sets the loop value for all sounds in this Howl group.
     *   loop(loop, id) -> Sets the loop value of passed sound id.
     * @return {Howl/Boolean} Returns self or current loop value.
     */
    loop: function loop() {
      var self = this;
      var args = arguments;
      var loop, id, sound; // Determine the values for loop and id.

      if (args.length === 0) {
        // Return the grou's loop value.
        return self._loop;
      } else if (args.length === 1) {
        if (typeof args[0] === 'boolean') {
          loop = args[0];
          self._loop = loop;
        } else {
          // Return this sound's loop value.
          sound = self._soundById(parseInt(args[0], 10));
          return sound ? sound._loop : false;
        }
      } else if (args.length === 2) {
        loop = args[0];
        id = parseInt(args[1], 10);
      } // If no id is passed, get all ID's to be looped.


      var ids = self._getSoundIds(id);

      for (var i = 0; i < ids.length; i++) {
        sound = self._soundById(ids[i]);

        if (sound) {
          sound._loop = loop;

          if (self._webAudio && sound._node && sound._node.bufferSource) {
            sound._node.bufferSource.loop = loop;

            if (loop) {
              sound._node.bufferSource.loopStart = sound._start || 0;
              sound._node.bufferSource.loopEnd = sound._stop;
            }
          }
        }
      }

      return self;
    },

    /**
     * Get/set the playback rate of a sound. This method can optionally take 0, 1 or 2 arguments.
     *   rate() -> Returns the first sound node's current playback rate.
     *   rate(id) -> Returns the sound id's current playback rate.
     *   rate(rate) -> Sets the playback rate of all sounds in this Howl group.
     *   rate(rate, id) -> Sets the playback rate of passed sound id.
     * @return {Howl/Number} Returns self or the current playback rate.
     */
    rate: function rate() {
      var self = this;
      var args = arguments;
      var rate, id; // Determine the values based on arguments.

      if (args.length === 0) {
        // We will simply return the current rate of the first node.
        id = self._sounds[0]._id;
      } else if (args.length === 1) {
        // First check if this is an ID, and if not, assume it is a new rate value.
        var ids = self._getSoundIds();

        var index = ids.indexOf(args[0]);

        if (index >= 0) {
          id = parseInt(args[0], 10);
        } else {
          rate = parseFloat(args[0]);
        }
      } else if (args.length === 2) {
        rate = parseFloat(args[0]);
        id = parseInt(args[1], 10);
      } // Update the playback rate or return the current value.


      var sound;

      if (typeof rate === 'number') {
        // If the sound hasn't loaded, add it to the load queue to change playback rate when capable.
        if (self._state !== 'loaded') {
          self._queue.push({
            event: 'rate',
            action: function action() {
              self.rate.apply(self, args);
            }
          });

          return self;
        } // Set the group rate.


        if (typeof id === 'undefined') {
          self._rate = rate;
        } // Update one or all volumes.


        id = self._getSoundIds(id);

        for (var i = 0; i < id.length; i++) {
          // Get the sound.
          sound = self._soundById(id[i]);

          if (sound) {
            // Keep track of our position when the rate changed and update the playback
            // start position so we can properly adjust the seek position for time elapsed.
            sound._rateSeek = self.seek(id[i]);
            sound._playStart = self._webAudio ? Howler.ctx.currentTime : sound._playStart;
            sound._rate = rate; // Change the playback rate.

            if (self._webAudio && sound._node && sound._node.bufferSource) {
              sound._node.bufferSource.playbackRate.value = rate;
            } else if (sound._node) {
              sound._node.playbackRate = rate;
            } // Reset the timers.


            var seek = self.seek(id[i]);
            var duration = (self._sprite[sound._sprite][0] + self._sprite[sound._sprite][1]) / 1000 - seek;
            var timeout = duration * 1000 / Math.abs(sound._rate); // Start a new end timer if sound is already playing.

            if (self._endTimers[id[i]] || !sound._paused) {
              self._clearTimer(id[i]);

              self._endTimers[id[i]] = setTimeout(self._ended.bind(self, sound), timeout);
            }

            self._emit('rate', sound._id);
          }
        }
      } else {
        sound = self._soundById(id);
        return sound ? sound._rate : self._rate;
      }

      return self;
    },

    /**
     * Get/set the seek position of a sound. This method can optionally take 0, 1 or 2 arguments.
     *   seek() -> Returns the first sound node's current seek position.
     *   seek(id) -> Returns the sound id's current seek position.
     *   seek(seek) -> Sets the seek position of the first sound node.
     *   seek(seek, id) -> Sets the seek position of passed sound id.
     * @return {Howl/Number} Returns self or the current seek position.
     */
    seek: function seek() {
      var self = this;
      var args = arguments;
      var seek, id; // Determine the values based on arguments.

      if (args.length === 0) {
        // We will simply return the current position of the first node.
        id = self._sounds[0]._id;
      } else if (args.length === 1) {
        // First check if this is an ID, and if not, assume it is a new seek position.
        var ids = self._getSoundIds();

        var index = ids.indexOf(args[0]);

        if (index >= 0) {
          id = parseInt(args[0], 10);
        } else if (self._sounds.length) {
          id = self._sounds[0]._id;
          seek = parseFloat(args[0]);
        }
      } else if (args.length === 2) {
        seek = parseFloat(args[0]);
        id = parseInt(args[1], 10);
      } // If there is no ID, bail out.


      if (typeof id === 'undefined') {
        return self;
      } // If the sound hasn't loaded, add it to the load queue to seek when capable.


      if (self._state !== 'loaded') {
        self._queue.push({
          event: 'seek',
          action: function action() {
            self.seek.apply(self, args);
          }
        });

        return self;
      } // Get the sound.


      var sound = self._soundById(id);

      if (sound) {
        if (typeof seek === 'number' && seek >= 0) {
          // Pause the sound and update position for restarting playback.
          var playing = self.playing(id);

          if (playing) {
            self.pause(id, true);
          } // Move the position of the track and cancel timer.


          sound._seek = seek;
          sound._ended = false;

          self._clearTimer(id); // Restart the playback if the sound was playing.


          if (playing) {
            self.play(id, true);
          } // Update the seek position for HTML5 Audio.


          if (!self._webAudio && sound._node) {
            sound._node.currentTime = seek;
          }

          self._emit('seek', id);
        } else {
          if (self._webAudio) {
            var realTime = self.playing(id) ? Howler.ctx.currentTime - sound._playStart : 0;
            var rateSeek = sound._rateSeek ? sound._rateSeek - sound._seek : 0;
            return sound._seek + (rateSeek + realTime * Math.abs(sound._rate));
          } else {
            return sound._node.currentTime;
          }
        }
      }

      return self;
    },

    /**
     * Check if a specific sound is currently playing or not (if id is provided), or check if at least one of the sounds in the group is playing or not.
     * @param  {Number}  id The sound id to check. If none is passed, the whole sound group is checked.
     * @return {Boolean} True if playing and false if not.
     */
    playing: function playing(id) {
      var self = this; // Check the passed sound ID (if any).

      if (typeof id === 'number') {
        var sound = self._soundById(id);

        return sound ? !sound._paused : false;
      } // Otherwise, loop through all sounds and check if any are playing.


      for (var i = 0; i < self._sounds.length; i++) {
        if (!self._sounds[i]._paused) {
          return true;
        }
      }

      return false;
    },

    /**
     * Get the duration of this sound. Passing a sound id will return the sprite duration.
     * @param  {Number} id The sound id to check. If none is passed, return full source duration.
     * @return {Number} Audio duration in seconds.
     */
    duration: function duration(id) {
      var self = this;
      var duration = self._duration; // If we pass an ID, get the sound and return the sprite length.

      var sound = self._soundById(id);

      if (sound) {
        duration = self._sprite[sound._sprite][1] / 1000;
      }

      return duration;
    },

    /**
     * Returns the current loaded state of this Howl.
     * @return {String} 'unloaded', 'loading', 'loaded'
     */
    state: function state() {
      return this._state;
    },

    /**
     * Unload and destroy the current Howl object.
     * This will immediately stop all sound instances attached to this group.
     */
    unload: function unload() {
      var self = this; // Stop playing any active sounds.

      var sounds = self._sounds;

      for (var i = 0; i < sounds.length; i++) {
        // Stop the sound if it is currently playing.
        if (!sounds[i]._paused) {
          self.stop(sounds[i]._id);
        } // Remove the source or disconnect.


        if (!self._webAudio) {
          // Set the source to 0-second silence to stop any downloading (except in IE).
          var checkIE = /MSIE |Trident\//.test(Howler._navigator && Howler._navigator.userAgent);

          if (!checkIE) {
            sounds[i]._node.src = 'data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA';
          } // Remove any event listeners.


          sounds[i]._node.removeEventListener('error', sounds[i]._errorFn, false);

          sounds[i]._node.removeEventListener(Howler._canPlayEvent, sounds[i]._loadFn, false);
        } // Empty out all of the nodes.


        delete sounds[i]._node; // Make sure all timers are cleared out.

        self._clearTimer(sounds[i]._id); // Remove the references in the global Howler object.


        var index = Howler._howls.indexOf(self);

        if (index >= 0) {
          Howler._howls.splice(index, 1);
        }
      } // Delete this sound from the cache (if no other Howl is using it).


      var remCache = true;

      for (i = 0; i < Howler._howls.length; i++) {
        if (Howler._howls[i]._src === self._src) {
          remCache = false;
          break;
        }
      }

      if (cache && remCache) {
        delete cache[self._src];
      } // Clear global errors.


      Howler.noAudio = false; // Clear out `self`.

      self._state = 'unloaded';
      self._sounds = [];
      self = null;
      return null;
    },

    /**
     * Listen to a custom event.
     * @param  {String}   event Event name.
     * @param  {Function} fn    Listener to call.
     * @param  {Number}   id    (optional) Only listen to events for this sound.
     * @param  {Number}   once  (INTERNAL) Marks event to fire only once.
     * @return {Howl}
     */
    on: function on(event, fn, id, once) {
      var self = this;
      var events = self['_on' + event];

      if (typeof fn === 'function') {
        events.push(once ? {
          id: id,
          fn: fn,
          once: once
        } : {
          id: id,
          fn: fn
        });
      }

      return self;
    },

    /**
     * Remove a custom event. Call without parameters to remove all events.
     * @param  {String}   event Event name.
     * @param  {Function} fn    Listener to remove. Leave empty to remove all.
     * @param  {Number}   id    (optional) Only remove events for this sound.
     * @return {Howl}
     */
    off: function off(event, fn, id) {
      var self = this;
      var events = self['_on' + event];
      var i = 0; // Allow passing just an event and ID.

      if (typeof fn === 'number') {
        id = fn;
        fn = null;
      }

      if (fn || id) {
        // Loop through event store and remove the passed function.
        for (i = 0; i < events.length; i++) {
          var isId = id === events[i].id;

          if (fn === events[i].fn && isId || !fn && isId) {
            events.splice(i, 1);
            break;
          }
        }
      } else if (event) {
        // Clear out all events of this type.
        self['_on' + event] = [];
      } else {
        // Clear out all events of every type.
        var keys = Object.keys(self);

        for (i = 0; i < keys.length; i++) {
          if (keys[i].indexOf('_on') === 0 && Array.isArray(self[keys[i]])) {
            self[keys[i]] = [];
          }
        }
      }

      return self;
    },

    /**
     * Listen to a custom event and remove it once fired.
     * @param  {String}   event Event name.
     * @param  {Function} fn    Listener to call.
     * @param  {Number}   id    (optional) Only listen to events for this sound.
     * @return {Howl}
     */
    once: function once(event, fn, id) {
      var self = this; // Setup the event listener.

      self.on(event, fn, id, 1);
      return self;
    },

    /**
     * Emit all events of a specific type and pass the sound id.
     * @param  {String} event Event name.
     * @param  {Number} id    Sound ID.
     * @param  {Number} msg   Message to go with event.
     * @return {Howl}
     */
    _emit: function _emit(event, id, msg) {
      var self = this;
      var events = self['_on' + event]; // Loop through event store and fire all functions.

      for (var i = events.length - 1; i >= 0; i--) {
        if (!events[i].id || events[i].id === id || event === 'load') {
          setTimeout(function (fn) {
            fn.call(this, id, msg);
          }.bind(self, events[i].fn), 0); // If this event was setup with `once`, remove it.

          if (events[i].once) {
            self.off(event, events[i].fn, events[i].id);
          }
        }
      }

      return self;
    },

    /**
     * Queue of actions initiated before the sound has loaded.
     * These will be called in sequence, with the next only firing
     * after the previous has finished executing (even if async like play).
     * @return {Howl}
     */
    _loadQueue: function _loadQueue() {
      var self = this;

      if (self._queue.length > 0) {
        var task = self._queue[0]; // don't move onto the next task until this one is done

        self.once(task.event, function () {
          self._queue.shift();

          self._loadQueue();
        });
        task.action();
      }

      return self;
    },

    /**
     * Fired when playback ends at the end of the duration.
     * @param  {Sound} sound The sound object to work with.
     * @return {Howl}
     */
    _ended: function _ended(sound) {
      var self = this;
      var sprite = sound._sprite; // If we are using IE and there was network latency we may be clipping
      // audio before it completes playing. Lets check the node to make sure it
      // believes it has completed, before ending the playback.

      if (!self._webAudio && sound._node && !sound._node.paused) {
        setTimeout(self._ended.bind(self, sound), 100);
        return self;
      } // Should this sound loop?


      var loop = !!(sound._loop || self._sprite[sprite][2]); // Fire the ended event.

      self._emit('end', sound._id); // Restart the playback for HTML5 Audio loop.


      if (!self._webAudio && loop) {
        self.stop(sound._id, true).play(sound._id);
      } // Restart this timer if on a Web Audio loop.


      if (self._webAudio && loop) {
        self._emit('play', sound._id);

        sound._seek = sound._start || 0;
        sound._rateSeek = 0;
        sound._playStart = Howler.ctx.currentTime;
        var timeout = (sound._stop - sound._start) * 1000 / Math.abs(sound._rate);
        self._endTimers[sound._id] = setTimeout(self._ended.bind(self, sound), timeout);
      } // Mark the node as paused.


      if (self._webAudio && !loop) {
        sound._paused = true;
        sound._ended = true;
        sound._seek = sound._start || 0;
        sound._rateSeek = 0;

        self._clearTimer(sound._id); // Clean up the buffer source.


        self._cleanBuffer(sound._node); // Attempt to auto-suspend AudioContext if no sounds are still playing.


        Howler._autoSuspend();
      } // When using a sprite, end the track.


      if (!self._webAudio && !loop) {
        self.stop(sound._id);
      }

      return self;
    },

    /**
     * Clear the end timer for a sound playback.
     * @param  {Number} id The sound ID.
     * @return {Howl}
     */
    _clearTimer: function _clearTimer(id) {
      var self = this;

      if (self._endTimers[id]) {
        clearTimeout(self._endTimers[id]);
        delete self._endTimers[id];
      }

      return self;
    },

    /**
     * Return the sound identified by this ID, or return null.
     * @param  {Number} id Sound ID
     * @return {Object}    Sound object or null.
     */
    _soundById: function _soundById(id) {
      var self = this; // Loop through all sounds and find the one with this ID.

      for (var i = 0; i < self._sounds.length; i++) {
        if (id === self._sounds[i]._id) {
          return self._sounds[i];
        }
      }

      return null;
    },

    /**
     * Return an inactive sound from the pool or create a new one.
     * @return {Sound} Sound playback object.
     */
    _inactiveSound: function _inactiveSound() {
      var self = this;

      self._drain(); // Find the first inactive node to recycle.


      for (var i = 0; i < self._sounds.length; i++) {
        if (self._sounds[i]._ended) {
          return self._sounds[i].reset();
        }
      } // If no inactive node was found, create a new one.


      return new Sound(self);
    },

    /**
     * Drain excess inactive sounds from the pool.
     */
    _drain: function _drain() {
      var self = this;
      var limit = self._pool;
      var cnt = 0;
      var i = 0; // If there are less sounds than the max pool size, we are done.

      if (self._sounds.length < limit) {
        return;
      } // Count the number of inactive sounds.


      for (i = 0; i < self._sounds.length; i++) {
        if (self._sounds[i]._ended) {
          cnt++;
        }
      } // Remove excess inactive sounds, going in reverse order.


      for (i = self._sounds.length - 1; i >= 0; i--) {
        if (cnt <= limit) {
          return;
        }

        if (self._sounds[i]._ended) {
          // Disconnect the audio source when using Web Audio.
          if (self._webAudio && self._sounds[i]._node) {
            self._sounds[i]._node.disconnect(0);
          } // Remove sounds until we have the pool size.


          self._sounds.splice(i, 1);

          cnt--;
        }
      }
    },

    /**
     * Get all ID's from the sounds pool.
     * @param  {Number} id Only return one ID if one is passed.
     * @return {Array}    Array of IDs.
     */
    _getSoundIds: function _getSoundIds(id) {
      var self = this;

      if (typeof id === 'undefined') {
        var ids = [];

        for (var i = 0; i < self._sounds.length; i++) {
          ids.push(self._sounds[i]._id);
        }

        return ids;
      } else {
        return [id];
      }
    },

    /**
     * Load the sound back into the buffer source.
     * @param  {Sound} sound The sound object to work with.
     * @return {Howl}
     */
    _refreshBuffer: function _refreshBuffer(sound) {
      var self = this; // Setup the buffer source for playback.

      sound._node.bufferSource = Howler.ctx.createBufferSource();
      sound._node.bufferSource.buffer = cache[self._src]; // Connect to the correct node.

      if (sound._panner) {
        sound._node.bufferSource.connect(sound._panner);
      } else {
        sound._node.bufferSource.connect(sound._node);
      } // Setup looping and playback rate.


      sound._node.bufferSource.loop = sound._loop;

      if (sound._loop) {
        sound._node.bufferSource.loopStart = sound._start || 0;
        sound._node.bufferSource.loopEnd = sound._stop;
      }

      sound._node.bufferSource.playbackRate.value = sound._rate;
      return self;
    },

    /**
     * Prevent memory leaks by cleaning up the buffer source after playback.
     * @param  {Object} node Sound's audio node containing the buffer source.
     * @return {Howl}
     */
    _cleanBuffer: function _cleanBuffer(node) {
      var self = this;

      if (self._scratchBuffer) {
        node.bufferSource.onended = null;
        node.bufferSource.disconnect(0);

        try {
          node.bufferSource.buffer = self._scratchBuffer;
        } catch (e) {}
      }

      node.bufferSource = null;
      return self;
    }
  };
  /** Single Sound Methods **/

  /***************************************************************************/

  /**
   * Setup the sound object, which each node attached to a Howl group is contained in.
   * @param {Object} howl The Howl parent group.
   */

  var Sound = function Sound(howl) {
    this._parent = howl;
    this.init();
  };

  Sound.prototype = {
    /**
     * Initialize a new Sound object.
     * @return {Sound}
     */
    init: function init() {
      var self = this;
      var parent = self._parent; // Setup the default parameters.

      self._muted = parent._muted;
      self._loop = parent._loop;
      self._volume = parent._volume;
      self._rate = parent._rate;
      self._seek = 0;
      self._paused = true;
      self._ended = true;
      self._sprite = '__default'; // Generate a unique ID for this sound.

      self._id = ++Howler._counter; // Add itself to the parent's pool.

      parent._sounds.push(self); // Create the new node.


      self.create();
      return self;
    },

    /**
     * Create and setup a new sound object, whether HTML5 Audio or Web Audio.
     * @return {Sound}
     */
    create: function create() {
      var self = this;
      var parent = self._parent;
      var volume = Howler._muted || self._muted || self._parent._muted ? 0 : self._volume;

      if (parent._webAudio) {
        // Create the gain node for controlling volume (the source will connect to this).
        self._node = typeof Howler.ctx.createGain === 'undefined' ? Howler.ctx.createGainNode() : Howler.ctx.createGain();

        self._node.gain.setValueAtTime(volume, Howler.ctx.currentTime);

        self._node.paused = true;

        self._node.connect(Howler.masterGain);
      } else {
        self._node = new Audio(); // Listen for errors (http://dev.w3.org/html5/spec-author-view/spec.html#mediaerror).

        self._errorFn = self._errorListener.bind(self);

        self._node.addEventListener('error', self._errorFn, false); // Listen for 'canplaythrough' event to let us know the sound is ready.


        self._loadFn = self._loadListener.bind(self);

        self._node.addEventListener(Howler._canPlayEvent, self._loadFn, false); // Setup the new audio node.


        self._node.src = parent._src;
        self._node.preload = 'auto';
        self._node.volume = volume * Howler.volume(); // Begin loading the source.

        self._node.load();
      }

      return self;
    },

    /**
     * Reset the parameters of this sound to the original state (for recycle).
     * @return {Sound}
     */
    reset: function reset() {
      var self = this;
      var parent = self._parent; // Reset all of the parameters of this sound.

      self._muted = parent._muted;
      self._loop = parent._loop;
      self._volume = parent._volume;
      self._rate = parent._rate;
      self._seek = 0;
      self._rateSeek = 0;
      self._paused = true;
      self._ended = true;
      self._sprite = '__default'; // Generate a new ID so that it isn't confused with the previous sound.

      self._id = ++Howler._counter;
      return self;
    },

    /**
     * HTML5 Audio error listener callback.
     */
    _errorListener: function _errorListener() {
      var self = this; // Fire an error event and pass back the code.

      self._parent._emit('loaderror', self._id, self._node.error ? self._node.error.code : 0); // Clear the event listener.


      self._node.removeEventListener('error', self._errorFn, false);
    },

    /**
     * HTML5 Audio canplaythrough listener callback.
     */
    _loadListener: function _loadListener() {
      var self = this;
      var parent = self._parent; // Round up the duration to account for the lower precision in HTML5 Audio.

      parent._duration = Math.ceil(self._node.duration * 10) / 10; // Setup a sprite if none is defined.

      if (Object.keys(parent._sprite).length === 0) {
        parent._sprite = {
          __default: [0, parent._duration * 1000]
        };
      }

      if (parent._state !== 'loaded') {
        parent._state = 'loaded';

        parent._emit('load');

        parent._loadQueue();
      } // Clear the event listener.


      self._node.removeEventListener(Howler._canPlayEvent, self._loadFn, false);
    }
  };
  /** Helper Methods **/

  /***************************************************************************/

  var cache = {};
  /**
   * Buffer a sound from URL, Data URI or cache and decode to audio source (Web Audio API).
   * @param  {Howl} self
   */

  var loadBuffer = function loadBuffer(self) {
    var url = self._src; // Check if the buffer has already been cached and use it instead.

    if (cache[url]) {
      // Set the duration from the cache.
      self._duration = cache[url].duration; // Load the sound into this Howl.

      loadSound(self);
      return;
    }

    if (/^data:[^;]+;base64,/.test(url)) {
      // Decode the base64 data URI without XHR, since some browsers don't support it.
      var data = atob(url.split(',')[1]);
      var dataView = new Uint8Array(data.length);

      for (var i = 0; i < data.length; ++i) {
        dataView[i] = data.charCodeAt(i);
      }

      decodeAudioData(dataView.buffer, self);
    } else {
      // Load the buffer from the URL.
      var xhr = new XMLHttpRequest();
      xhr.open('GET', url, true);
      xhr.withCredentials = self._xhrWithCredentials;
      xhr.responseType = 'arraybuffer';

      xhr.onload = function () {
        // Make sure we get a successful response back.
        var code = (xhr.status + '')[0];

        if (code !== '0' && code !== '2' && code !== '3') {
          self._emit('loaderror', null, 'Failed loading audio file with status: ' + xhr.status + '.');

          return;
        }

        decodeAudioData(xhr.response, self);
      };

      xhr.onerror = function () {
        // If there is an error, switch to HTML5 Audio.
        if (self._webAudio) {
          self._html5 = true;
          self._webAudio = false;
          self._sounds = [];
          delete cache[url];
          self.load();
        }
      };

      safeXhrSend(xhr);
    }
  };
  /**
   * Send the XHR request wrapped in a try/catch.
   * @param  {Object} xhr XHR to send.
   */


  var safeXhrSend = function safeXhrSend(xhr) {
    try {
      xhr.send();
    } catch (e) {
      xhr.onerror();
    }
  };
  /**
   * Decode audio data from an array buffer.
   * @param  {ArrayBuffer} arraybuffer The audio data.
   * @param  {Howl}        self
   */


  var decodeAudioData = function decodeAudioData(arraybuffer, self) {
    // Decode the buffer into an audio source.
    Howler.ctx.decodeAudioData(arraybuffer, function (buffer) {
      if (buffer && self._sounds.length > 0) {
        cache[self._src] = buffer;
        loadSound(self, buffer);
      }
    }, function () {
      self._emit('loaderror', null, 'Decoding audio data failed.');
    });
  };
  /**
   * Sound is now loaded, so finish setting everything up and fire the loaded event.
   * @param  {Howl} self
   * @param  {Object} buffer The decoded buffer sound source.
   */


  var loadSound = function loadSound(self, buffer) {
    // Set the duration.
    if (buffer && !self._duration) {
      self._duration = buffer.duration;
    } // Setup a sprite if none is defined.


    if (Object.keys(self._sprite).length === 0) {
      self._sprite = {
        __default: [0, self._duration * 1000]
      };
    } // Fire the loaded event.


    if (self._state !== 'loaded') {
      self._state = 'loaded';

      self._emit('load');

      self._loadQueue();
    }
  };
  /**
   * Setup the audio context when available, or switch to HTML5 Audio mode.
   */


  var setupAudioContext = function setupAudioContext() {
    // Check if we are using Web Audio and setup the AudioContext if we are.
    try {
      if (typeof AudioContext !== 'undefined') {
        Howler.ctx = new AudioContext();
      } else if (typeof webkitAudioContext !== 'undefined') {
        Howler.ctx = new webkitAudioContext();
      } else {
        Howler.usingWebAudio = false;
      }
    } catch (e) {
      Howler.usingWebAudio = false;
    } // Check if a webview is being used on iOS8 or earlier (rather than the browser).
    // If it is, disable Web Audio as it causes crashing.


    var iOS = /iP(hone|od|ad)/.test(Howler._navigator && Howler._navigator.platform);

    var appVersion = Howler._navigator && Howler._navigator.appVersion.match(/OS (\d+)_(\d+)_?(\d+)?/);

    var version = appVersion ? parseInt(appVersion[1], 10) : null;

    if (iOS && version && version < 9) {
      var safari = /safari/.test(Howler._navigator && Howler._navigator.userAgent.toLowerCase());

      if (Howler._navigator && Howler._navigator.standalone && !safari || Howler._navigator && !Howler._navigator.standalone && !safari) {
        Howler.usingWebAudio = false;
      }
    } // Create and expose the master GainNode when using Web Audio (useful for plugins or advanced usage).


    if (Howler.usingWebAudio) {
      Howler.masterGain = typeof Howler.ctx.createGain === 'undefined' ? Howler.ctx.createGainNode() : Howler.ctx.createGain();
      Howler.masterGain.gain.value = Howler._muted ? 0 : 1;
      Howler.masterGain.connect(Howler.ctx.destination);
    } // Re-run the setup on Howler.


    Howler._setup();
  }; // Add support for AMD (Asynchronous Module Definition) libraries such as require.js.


  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {
      return {
        Howler: Howler,
        Howl: Howl
      };
    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } // Add support for CommonJS libraries such as browserify.


  if (true) {
    exports.Howler = Howler;
    exports.Howl = Howl;
  } // Define globally in case AMD is not available or unused.


  if (typeof window !== 'undefined') {
    window.HowlerGlobal = HowlerGlobal;
    window.Howler = Howler;
    window.Howl = Howl;
    window.Sound = Sound;
  } else if (typeof global !== 'undefined') {
    // Add to global in Node.js (for testing, etc).
    global.HowlerGlobal = HowlerGlobal;
    global.Howler = Howler;
    global.Howl = Howl;
    global.Sound = Sound;
  }
})();
/*!
 *  Spatial Plugin - Adds support for stereo and 3D audio where Web Audio is supported.
 *  
 *  howler.js v2.0.5
 *  howlerjs.com
 *
 *  (c) 2013-2017, James Simpson of GoldFire Studios
 *  goldfirestudios.com
 *
 *  MIT License
 */


(function () {
  'use strict'; // Setup default properties.

  HowlerGlobal.prototype._pos = [0, 0, 0];
  HowlerGlobal.prototype._orientation = [0, 0, -1, 0, 1, 0];
  /** Global Methods **/

  /***************************************************************************/

  /**
   * Helper method to update the stereo panning position of all current Howls.
   * Future Howls will not use this value unless explicitly set.
   * @param  {Number} pan A value of -1.0 is all the way left and 1.0 is all the way right.
   * @return {Howler/Number}     Self or current stereo panning value.
   */

  HowlerGlobal.prototype.stereo = function (pan) {
    var self = this; // Stop right here if not using Web Audio.

    if (!self.ctx || !self.ctx.listener) {
      return self;
    } // Loop through all Howls and update their stereo panning.


    for (var i = self._howls.length - 1; i >= 0; i--) {
      self._howls[i].stereo(pan);
    }

    return self;
  };
  /**
   * Get/set the position of the listener in 3D cartesian space. Sounds using
   * 3D position will be relative to the listener's position.
   * @param  {Number} x The x-position of the listener.
   * @param  {Number} y The y-position of the listener.
   * @param  {Number} z The z-position of the listener.
   * @return {Howler/Array}   Self or current listener position.
   */


  HowlerGlobal.prototype.pos = function (x, y, z) {
    var self = this; // Stop right here if not using Web Audio.

    if (!self.ctx || !self.ctx.listener) {
      return self;
    } // Set the defaults for optional 'y' & 'z'.


    y = typeof y !== 'number' ? self._pos[1] : y;
    z = typeof z !== 'number' ? self._pos[2] : z;

    if (typeof x === 'number') {
      self._pos = [x, y, z];
      self.ctx.listener.setPosition(self._pos[0], self._pos[1], self._pos[2]);
    } else {
      return self._pos;
    }

    return self;
  };
  /**
   * Get/set the direction the listener is pointing in the 3D cartesian space.
   * A front and up vector must be provided. The front is the direction the
   * face of the listener is pointing, and up is the direction the top of the
   * listener is pointing. Thus, these values are expected to be at right angles
   * from each other.
   * @param  {Number} x   The x-orientation of the listener.
   * @param  {Number} y   The y-orientation of the listener.
   * @param  {Number} z   The z-orientation of the listener.
   * @param  {Number} xUp The x-orientation of the top of the listener.
   * @param  {Number} yUp The y-orientation of the top of the listener.
   * @param  {Number} zUp The z-orientation of the top of the listener.
   * @return {Howler/Array}     Returns self or the current orientation vectors.
   */


  HowlerGlobal.prototype.orientation = function (x, y, z, xUp, yUp, zUp) {
    var self = this; // Stop right here if not using Web Audio.

    if (!self.ctx || !self.ctx.listener) {
      return self;
    } // Set the defaults for optional 'y' & 'z'.


    var or = self._orientation;
    y = typeof y !== 'number' ? or[1] : y;
    z = typeof z !== 'number' ? or[2] : z;
    xUp = typeof xUp !== 'number' ? or[3] : xUp;
    yUp = typeof yUp !== 'number' ? or[4] : yUp;
    zUp = typeof zUp !== 'number' ? or[5] : zUp;

    if (typeof x === 'number') {
      self._orientation = [x, y, z, xUp, yUp, zUp];
      self.ctx.listener.setOrientation(x, y, z, xUp, yUp, zUp);
    } else {
      return or;
    }

    return self;
  };
  /** Group Methods **/

  /***************************************************************************/

  /**
   * Add new properties to the core init.
   * @param  {Function} _super Core init method.
   * @return {Howl}
   */


  Howl.prototype.init = function (_super) {
    return function (o) {
      var self = this; // Setup user-defined default properties.

      self._orientation = o.orientation || [1, 0, 0];
      self._stereo = o.stereo || null;
      self._pos = o.pos || null;
      self._pannerAttr = {
        coneInnerAngle: typeof o.coneInnerAngle !== 'undefined' ? o.coneInnerAngle : 360,
        coneOuterAngle: typeof o.coneOuterAngle !== 'undefined' ? o.coneOuterAngle : 360,
        coneOuterGain: typeof o.coneOuterGain !== 'undefined' ? o.coneOuterGain : 0,
        distanceModel: typeof o.distanceModel !== 'undefined' ? o.distanceModel : 'inverse',
        maxDistance: typeof o.maxDistance !== 'undefined' ? o.maxDistance : 10000,
        panningModel: typeof o.panningModel !== 'undefined' ? o.panningModel : 'HRTF',
        refDistance: typeof o.refDistance !== 'undefined' ? o.refDistance : 1,
        rolloffFactor: typeof o.rolloffFactor !== 'undefined' ? o.rolloffFactor : 1
      }; // Setup event listeners.

      self._onstereo = o.onstereo ? [{
        fn: o.onstereo
      }] : [];
      self._onpos = o.onpos ? [{
        fn: o.onpos
      }] : [];
      self._onorientation = o.onorientation ? [{
        fn: o.onorientation
      }] : []; // Complete initilization with howler.js core's init function.

      return _super.call(this, o);
    };
  }(Howl.prototype.init);
  /**
   * Get/set the stereo panning of the audio source for this sound or all in the group.
   * @param  {Number} pan  A value of -1.0 is all the way left and 1.0 is all the way right.
   * @param  {Number} id (optional) The sound ID. If none is passed, all in group will be updated.
   * @return {Howl/Number}    Returns self or the current stereo panning value.
   */


  Howl.prototype.stereo = function (pan, id) {
    var self = this; // Stop right here if not using Web Audio.

    if (!self._webAudio) {
      return self;
    } // If the sound hasn't loaded, add it to the load queue to change stereo pan when capable.


    if (self._state !== 'loaded') {
      self._queue.push({
        event: 'stereo',
        action: function action() {
          self.stereo(pan, id);
        }
      });

      return self;
    } // Check for PannerStereoNode support and fallback to PannerNode if it doesn't exist.


    var pannerType = typeof Howler.ctx.createStereoPanner === 'undefined' ? 'spatial' : 'stereo'; // Setup the group's stereo panning if no ID is passed.

    if (typeof id === 'undefined') {
      // Return the group's stereo panning if no parameters are passed.
      if (typeof pan === 'number') {
        self._stereo = pan;
        self._pos = [pan, 0, 0];
      } else {
        return self._stereo;
      }
    } // Change the streo panning of one or all sounds in group.


    var ids = self._getSoundIds(id);

    for (var i = 0; i < ids.length; i++) {
      // Get the sound.
      var sound = self._soundById(ids[i]);

      if (sound) {
        if (typeof pan === 'number') {
          sound._stereo = pan;
          sound._pos = [pan, 0, 0];

          if (sound._node) {
            // If we are falling back, make sure the panningModel is equalpower.
            sound._pannerAttr.panningModel = 'equalpower'; // Check if there is a panner setup and create a new one if not.

            if (!sound._panner || !sound._panner.pan) {
              setupPanner(sound, pannerType);
            }

            if (pannerType === 'spatial') {
              sound._panner.setPosition(pan, 0, 0);
            } else {
              sound._panner.pan.value = pan;
            }
          }

          self._emit('stereo', sound._id);
        } else {
          return sound._stereo;
        }
      }
    }

    return self;
  };
  /**
   * Get/set the 3D spatial position of the audio source for this sound or group relative to the global listener.
   * @param  {Number} x  The x-position of the audio source.
   * @param  {Number} y  The y-position of the audio source.
   * @param  {Number} z  The z-position of the audio source.
   * @param  {Number} id (optional) The sound ID. If none is passed, all in group will be updated.
   * @return {Howl/Array}    Returns self or the current 3D spatial position: [x, y, z].
   */


  Howl.prototype.pos = function (x, y, z, id) {
    var self = this; // Stop right here if not using Web Audio.

    if (!self._webAudio) {
      return self;
    } // If the sound hasn't loaded, add it to the load queue to change position when capable.


    if (self._state !== 'loaded') {
      self._queue.push({
        event: 'pos',
        action: function action() {
          self.pos(x, y, z, id);
        }
      });

      return self;
    } // Set the defaults for optional 'y' & 'z'.


    y = typeof y !== 'number' ? 0 : y;
    z = typeof z !== 'number' ? -0.5 : z; // Setup the group's spatial position if no ID is passed.

    if (typeof id === 'undefined') {
      // Return the group's spatial position if no parameters are passed.
      if (typeof x === 'number') {
        self._pos = [x, y, z];
      } else {
        return self._pos;
      }
    } // Change the spatial position of one or all sounds in group.


    var ids = self._getSoundIds(id);

    for (var i = 0; i < ids.length; i++) {
      // Get the sound.
      var sound = self._soundById(ids[i]);

      if (sound) {
        if (typeof x === 'number') {
          sound._pos = [x, y, z];

          if (sound._node) {
            // Check if there is a panner setup and create a new one if not.
            if (!sound._panner || sound._panner.pan) {
              setupPanner(sound, 'spatial');
            }

            sound._panner.setPosition(x, y, z);
          }

          self._emit('pos', sound._id);
        } else {
          return sound._pos;
        }
      }
    }

    return self;
  };
  /**
   * Get/set the direction the audio source is pointing in the 3D cartesian coordinate
   * space. Depending on how direction the sound is, based on the `cone` attributes,
   * a sound pointing away from the listener can be quiet or silent.
   * @param  {Number} x  The x-orientation of the source.
   * @param  {Number} y  The y-orientation of the source.
   * @param  {Number} z  The z-orientation of the source.
   * @param  {Number} id (optional) The sound ID. If none is passed, all in group will be updated.
   * @return {Howl/Array}    Returns self or the current 3D spatial orientation: [x, y, z].
   */


  Howl.prototype.orientation = function (x, y, z, id) {
    var self = this; // Stop right here if not using Web Audio.

    if (!self._webAudio) {
      return self;
    } // If the sound hasn't loaded, add it to the load queue to change orientation when capable.


    if (self._state !== 'loaded') {
      self._queue.push({
        event: 'orientation',
        action: function action() {
          self.orientation(x, y, z, id);
        }
      });

      return self;
    } // Set the defaults for optional 'y' & 'z'.


    y = typeof y !== 'number' ? self._orientation[1] : y;
    z = typeof z !== 'number' ? self._orientation[2] : z; // Setup the group's spatial orientation if no ID is passed.

    if (typeof id === 'undefined') {
      // Return the group's spatial orientation if no parameters are passed.
      if (typeof x === 'number') {
        self._orientation = [x, y, z];
      } else {
        return self._orientation;
      }
    } // Change the spatial orientation of one or all sounds in group.


    var ids = self._getSoundIds(id);

    for (var i = 0; i < ids.length; i++) {
      // Get the sound.
      var sound = self._soundById(ids[i]);

      if (sound) {
        if (typeof x === 'number') {
          sound._orientation = [x, y, z];

          if (sound._node) {
            // Check if there is a panner setup and create a new one if not.
            if (!sound._panner) {
              // Make sure we have a position to setup the node with.
              if (!sound._pos) {
                sound._pos = self._pos || [0, 0, -0.5];
              }

              setupPanner(sound, 'spatial');
            }

            sound._panner.setOrientation(x, y, z);
          }

          self._emit('orientation', sound._id);
        } else {
          return sound._orientation;
        }
      }
    }

    return self;
  };
  /**
   * Get/set the panner node's attributes for a sound or group of sounds.
   * This method can optionall take 0, 1 or 2 arguments.
   *   pannerAttr() -> Returns the group's values.
   *   pannerAttr(id) -> Returns the sound id's values.
   *   pannerAttr(o) -> Set's the values of all sounds in this Howl group.
   *   pannerAttr(o, id) -> Set's the values of passed sound id.
   *
   *   Attributes:
   *     coneInnerAngle - (360 by default) A parameter for directional audio sources, this is an angle, in degrees,
   *                      inside of which there will be no volume reduction.
   *     coneOuterAngle - (360 by default) A parameter for directional audio sources, this is an angle, in degrees,
   *                      outside of which the volume will be reduced to a constant value of `coneOuterGain`.
   *     coneOuterGain - (0 by default) A parameter for directional audio sources, this is the gain outside of the
   *                     `coneOuterAngle`. It is a linear value in the range `[0, 1]`.
   *     distanceModel - ('inverse' by default) Determines algorithm used to reduce volume as audio moves away from
   *                     listener. Can be `linear`, `inverse` or `exponential.
   *     maxDistance - (10000 by default) The maximum distance between source and listener, after which the volume
   *                   will not be reduced any further.
   *     refDistance - (1 by default) A reference distance for reducing volume as source moves further from the listener.
   *                   This is simply a variable of the distance model and has a different effect depending on which model
   *                   is used and the scale of your coordinates. Generally, volume will be equal to 1 at this distance.
   *     rolloffFactor - (1 by default) How quickly the volume reduces as source moves from listener. This is simply a
   *                     variable of the distance model and can be in the range of `[0, 1]` with `linear` and `[0, ]`
   *                     with `inverse` and `exponential`.
   *     panningModel - ('HRTF' by default) Determines which spatialization algorithm is used to position audio.
   *                     Can be `HRTF` or `equalpower`.
   * 
   * @return {Howl/Object} Returns self or current panner attributes.
   */


  Howl.prototype.pannerAttr = function () {
    var self = this;
    var args = arguments;
    var o, id, sound; // Stop right here if not using Web Audio.

    if (!self._webAudio) {
      return self;
    } // Determine the values based on arguments.


    if (args.length === 0) {
      // Return the group's panner attribute values.
      return self._pannerAttr;
    } else if (args.length === 1) {
      if (typeof args[0] === 'object') {
        o = args[0]; // Set the grou's panner attribute values.

        if (typeof id === 'undefined') {
          if (!o.pannerAttr) {
            o.pannerAttr = {
              coneInnerAngle: o.coneInnerAngle,
              coneOuterAngle: o.coneOuterAngle,
              coneOuterGain: o.coneOuterGain,
              distanceModel: o.distanceModel,
              maxDistance: o.maxDistance,
              refDistance: o.refDistance,
              rolloffFactor: o.rolloffFactor,
              panningModel: o.panningModel
            };
          }

          self._pannerAttr = {
            coneInnerAngle: typeof o.pannerAttr.coneInnerAngle !== 'undefined' ? o.pannerAttr.coneInnerAngle : self._coneInnerAngle,
            coneOuterAngle: typeof o.pannerAttr.coneOuterAngle !== 'undefined' ? o.pannerAttr.coneOuterAngle : self._coneOuterAngle,
            coneOuterGain: typeof o.pannerAttr.coneOuterGain !== 'undefined' ? o.pannerAttr.coneOuterGain : self._coneOuterGain,
            distanceModel: typeof o.pannerAttr.distanceModel !== 'undefined' ? o.pannerAttr.distanceModel : self._distanceModel,
            maxDistance: typeof o.pannerAttr.maxDistance !== 'undefined' ? o.pannerAttr.maxDistance : self._maxDistance,
            refDistance: typeof o.pannerAttr.refDistance !== 'undefined' ? o.pannerAttr.refDistance : self._refDistance,
            rolloffFactor: typeof o.pannerAttr.rolloffFactor !== 'undefined' ? o.pannerAttr.rolloffFactor : self._rolloffFactor,
            panningModel: typeof o.pannerAttr.panningModel !== 'undefined' ? o.pannerAttr.panningModel : self._panningModel
          };
        }
      } else {
        // Return this sound's panner attribute values.
        sound = self._soundById(parseInt(args[0], 10));
        return sound ? sound._pannerAttr : self._pannerAttr;
      }
    } else if (args.length === 2) {
      o = args[0];
      id = parseInt(args[1], 10);
    } // Update the values of the specified sounds.


    var ids = self._getSoundIds(id);

    for (var i = 0; i < ids.length; i++) {
      sound = self._soundById(ids[i]);

      if (sound) {
        // Merge the new values into the sound.
        var pa = sound._pannerAttr;
        pa = {
          coneInnerAngle: typeof o.coneInnerAngle !== 'undefined' ? o.coneInnerAngle : pa.coneInnerAngle,
          coneOuterAngle: typeof o.coneOuterAngle !== 'undefined' ? o.coneOuterAngle : pa.coneOuterAngle,
          coneOuterGain: typeof o.coneOuterGain !== 'undefined' ? o.coneOuterGain : pa.coneOuterGain,
          distanceModel: typeof o.distanceModel !== 'undefined' ? o.distanceModel : pa.distanceModel,
          maxDistance: typeof o.maxDistance !== 'undefined' ? o.maxDistance : pa.maxDistance,
          refDistance: typeof o.refDistance !== 'undefined' ? o.refDistance : pa.refDistance,
          rolloffFactor: typeof o.rolloffFactor !== 'undefined' ? o.rolloffFactor : pa.rolloffFactor,
          panningModel: typeof o.panningModel !== 'undefined' ? o.panningModel : pa.panningModel
        }; // Update the panner values or create a new panner if none exists.

        var panner = sound._panner;

        if (panner) {
          panner.coneInnerAngle = pa.coneInnerAngle;
          panner.coneOuterAngle = pa.coneOuterAngle;
          panner.coneOuterGain = pa.coneOuterGain;
          panner.distanceModel = pa.distanceModel;
          panner.maxDistance = pa.maxDistance;
          panner.refDistance = pa.refDistance;
          panner.rolloffFactor = pa.rolloffFactor;
          panner.panningModel = pa.panningModel;
        } else {
          // Make sure we have a position to setup the node with.
          if (!sound._pos) {
            sound._pos = self._pos || [0, 0, -0.5];
          } // Create a new panner node.


          setupPanner(sound, 'spatial');
        }
      }
    }

    return self;
  };
  /** Single Sound Methods **/

  /***************************************************************************/

  /**
   * Add new properties to the core Sound init.
   * @param  {Function} _super Core Sound init method.
   * @return {Sound}
   */


  Sound.prototype.init = function (_super) {
    return function () {
      var self = this;
      var parent = self._parent; // Setup user-defined default properties.

      self._orientation = parent._orientation;
      self._stereo = parent._stereo;
      self._pos = parent._pos;
      self._pannerAttr = parent._pannerAttr; // Complete initilization with howler.js core Sound's init function.

      _super.call(this); // If a stereo or position was specified, set it up.


      if (self._stereo) {
        parent.stereo(self._stereo);
      } else if (self._pos) {
        parent.pos(self._pos[0], self._pos[1], self._pos[2], self._id);
      }
    };
  }(Sound.prototype.init);
  /**
   * Override the Sound.reset method to clean up properties from the spatial plugin.
   * @param  {Function} _super Sound reset method.
   * @return {Sound}
   */


  Sound.prototype.reset = function (_super) {
    return function () {
      var self = this;
      var parent = self._parent; // Reset all spatial plugin properties on this sound.

      self._orientation = parent._orientation;
      self._pos = parent._pos;
      self._pannerAttr = parent._pannerAttr; // Complete resetting of the sound.

      return _super.call(this);
    };
  }(Sound.prototype.reset);
  /** Helper Methods **/

  /***************************************************************************/

  /**
   * Create a new panner node and save it on the sound.
   * @param  {Sound} sound Specific sound to setup panning on.
   * @param {String} type Type of panner to create: 'stereo' or 'spatial'.
   */


  var setupPanner = function setupPanner(sound, type) {
    type = type || 'spatial'; // Create the new panner node.

    if (type === 'spatial') {
      sound._panner = Howler.ctx.createPanner();
      sound._panner.coneInnerAngle = sound._pannerAttr.coneInnerAngle;
      sound._panner.coneOuterAngle = sound._pannerAttr.coneOuterAngle;
      sound._panner.coneOuterGain = sound._pannerAttr.coneOuterGain;
      sound._panner.distanceModel = sound._pannerAttr.distanceModel;
      sound._panner.maxDistance = sound._pannerAttr.maxDistance;
      sound._panner.refDistance = sound._pannerAttr.refDistance;
      sound._panner.rolloffFactor = sound._pannerAttr.rolloffFactor;
      sound._panner.panningModel = sound._pannerAttr.panningModel;

      sound._panner.setPosition(sound._pos[0], sound._pos[1], sound._pos[2]);

      sound._panner.setOrientation(sound._orientation[0], sound._orientation[1], sound._orientation[2]);
    } else {
      sound._panner = Howler.ctx.createStereoPanner();
      sound._panner.pan.value = sound._stereo;
    }

    sound._panner.connect(sound._node); // Update the connections.


    if (!sound._paused) {
      sound._parent.pause(sound._id, true).play(sound._id);
    }
  };
})();
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__("./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/object-assign/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/

/* eslint-disable no-unused-vars */

var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
  if (val === null || val === undefined) {
    throw new TypeError('Object.assign cannot be called with null or undefined');
  }

  return Object(val);
}

function shouldUseNative() {
  try {
    if (!Object.assign) {
      return false;
    } // Detect buggy property enumeration order in older V8 versions.
    // https://bugs.chromium.org/p/v8/issues/detail?id=4118


    var test1 = new String('abc'); // eslint-disable-line no-new-wrappers

    test1[5] = 'de';

    if (Object.getOwnPropertyNames(test1)[0] === '5') {
      return false;
    } // https://bugs.chromium.org/p/v8/issues/detail?id=3056


    var test2 = {};

    for (var i = 0; i < 10; i++) {
      test2['_' + String.fromCharCode(i)] = i;
    }

    var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
      return test2[n];
    });

    if (order2.join('') !== '0123456789') {
      return false;
    } // https://bugs.chromium.org/p/v8/issues/detail?id=3056


    var test3 = {};
    'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
      test3[letter] = letter;
    });

    if (Object.keys(Object.assign({}, test3)).join('') !== 'abcdefghijklmnopqrst') {
      return false;
    }

    return true;
  } catch (err) {
    // We don't expect any of the above to throw, but better to be safe.
    return false;
  }
}

module.exports = shouldUseNative() ? Object.assign : function (target, source) {
  var from;
  var to = toObject(target);
  var symbols;

  for (var s = 1; s < arguments.length; s++) {
    from = Object(arguments[s]);

    for (var key in from) {
      if (hasOwnProperty.call(from, key)) {
        to[key] = from[key];
      }
    }

    if (getOwnPropertySymbols) {
      symbols = getOwnPropertySymbols(from);

      for (var i = 0; i < symbols.length; i++) {
        if (propIsEnumerable.call(from, symbols[i])) {
          to[symbols[i]] = from[symbols[i]];
        }
      }
    }
  }

  return to;
};

/***/ }),

/***/ "./node_modules/process/browser.js":
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {}; // cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
  throw new Error('setTimeout has not been defined');
}

function defaultClearTimeout() {
  throw new Error('clearTimeout has not been defined');
}

(function () {
  try {
    if (typeof setTimeout === 'function') {
      cachedSetTimeout = setTimeout;
    } else {
      cachedSetTimeout = defaultSetTimout;
    }
  } catch (e) {
    cachedSetTimeout = defaultSetTimout;
  }

  try {
    if (typeof clearTimeout === 'function') {
      cachedClearTimeout = clearTimeout;
    } else {
      cachedClearTimeout = defaultClearTimeout;
    }
  } catch (e) {
    cachedClearTimeout = defaultClearTimeout;
  }
})();

function runTimeout(fun) {
  if (cachedSetTimeout === setTimeout) {
    //normal enviroments in sane situations
    return setTimeout(fun, 0);
  } // if setTimeout wasn't available but was latter defined


  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
    cachedSetTimeout = setTimeout;
    return setTimeout(fun, 0);
  }

  try {
    // when when somebody has screwed with setTimeout but no I.E. maddness
    return cachedSetTimeout(fun, 0);
  } catch (e) {
    try {
      // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
      return cachedSetTimeout.call(null, fun, 0);
    } catch (e) {
      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
      return cachedSetTimeout.call(this, fun, 0);
    }
  }
}

function runClearTimeout(marker) {
  if (cachedClearTimeout === clearTimeout) {
    //normal enviroments in sane situations
    return clearTimeout(marker);
  } // if clearTimeout wasn't available but was latter defined


  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
    cachedClearTimeout = clearTimeout;
    return clearTimeout(marker);
  }

  try {
    // when when somebody has screwed with setTimeout but no I.E. maddness
    return cachedClearTimeout(marker);
  } catch (e) {
    try {
      // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
      return cachedClearTimeout.call(null, marker);
    } catch (e) {
      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
      // Some versions of I.E. have different rules for clearTimeout vs setTimeout
      return cachedClearTimeout.call(this, marker);
    }
  }
}

var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
  if (!draining || !currentQueue) {
    return;
  }

  draining = false;

  if (currentQueue.length) {
    queue = currentQueue.concat(queue);
  } else {
    queueIndex = -1;
  }

  if (queue.length) {
    drainQueue();
  }
}

function drainQueue() {
  if (draining) {
    return;
  }

  var timeout = runTimeout(cleanUpNextTick);
  draining = true;
  var len = queue.length;

  while (len) {
    currentQueue = queue;
    queue = [];

    while (++queueIndex < len) {
      if (currentQueue) {
        currentQueue[queueIndex].run();
      }
    }

    queueIndex = -1;
    len = queue.length;
  }

  currentQueue = null;
  draining = false;
  runClearTimeout(timeout);
}

process.nextTick = function (fun) {
  var args = new Array(arguments.length - 1);

  if (arguments.length > 1) {
    for (var i = 1; i < arguments.length; i++) {
      args[i - 1] = arguments[i];
    }
  }

  queue.push(new Item(fun, args));

  if (queue.length === 1 && !draining) {
    runTimeout(drainQueue);
  }
}; // v8 likes predictible objects


function Item(fun, array) {
  this.fun = fun;
  this.array = array;
}

Item.prototype.run = function () {
  this.fun.apply(null, this.array);
};

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues

process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) {
  return [];
};

process.binding = function (name) {
  throw new Error('process.binding is not supported');
};

process.cwd = function () {
  return '/';
};

process.chdir = function (dir) {
  throw new Error('process.chdir is not supported');
};

process.umask = function () {
  return 0;
};

/***/ }),

/***/ "./node_modules/prop-types/checkPropTypes.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */


if (process.env.NODE_ENV !== 'production') {
  var invariant = __webpack_require__("./node_modules/fbjs/lib/invariant.js");

  var warning = __webpack_require__("./node_modules/fbjs/lib/warning.js");

  var ReactPropTypesSecret = __webpack_require__("./node_modules/prop-types/lib/ReactPropTypesSecret.js");

  var loggedTypeFailures = {};
}
/**
 * Assert that the values match with the type specs.
 * Error messages are memorized and will only be shown once.
 *
 * @param {object} typeSpecs Map of name to a ReactPropType
 * @param {object} values Runtime values that need to be type-checked
 * @param {string} location e.g. "prop", "context", "child context"
 * @param {string} componentName Name of the component for error messages.
 * @param {?Function} getStack Returns the component stack.
 * @private
 */


function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
  if (process.env.NODE_ENV !== 'production') {
    for (var typeSpecName in typeSpecs) {
      if (typeSpecs.hasOwnProperty(typeSpecName)) {
        var error; // Prop type validation may throw. In case they do, we don't want to
        // fail the render phase where it didn't fail before. So we log it.
        // After these have been cleaned up, we'll let them throw.

        try {
          // This is intentionally an invariant that gets caught. It's the same
          // behavior as without this statement except with a better message.
          invariant(typeof typeSpecs[typeSpecName] === 'function', '%s: %s type `%s` is invalid; it must be a function, usually from ' + 'the `prop-types` package, but received `%s`.', componentName || 'React class', location, typeSpecName, typeof typeSpecs[typeSpecName]);
          error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
        } catch (ex) {
          error = ex;
        }

        warning(!error || error instanceof Error, '%s: type specification of %s `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error);

        if (error instanceof Error && !(error.message in loggedTypeFailures)) {
          // Only monitor this failure once because there tends to be a lot of the
          // same error.
          loggedTypeFailures[error.message] = true;
          var stack = getStack ? getStack() : '';
          warning(false, 'Failed %s type: %s%s', location, error.message, stack != null ? stack : '');
        }
      }
    }
  }
}

module.exports = checkPropTypes;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__("./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/prop-types/lib/ReactPropTypesSecret.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */


var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';
module.exports = ReactPropTypesSecret;

/***/ }),

/***/ "./node_modules/react-test-renderer/cjs/react-test-renderer.development.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/** @license React v16.2.0
 * react-test-renderer.development.js
 *
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */


if (process.env.NODE_ENV !== "production") {
  (function () {
    'use strict';

    var _assign = __webpack_require__("./node_modules/object-assign/index.js");

    var invariant = __webpack_require__("./node_modules/fbjs/lib/invariant.js");

    var warning = __webpack_require__("./node_modules/fbjs/lib/warning.js");

    var React = __webpack_require__("./node_modules/react/index.js");

    var emptyObject = __webpack_require__("./node_modules/fbjs/lib/emptyObject.js");

    var checkPropTypes = __webpack_require__("./node_modules/prop-types/checkPropTypes.js");

    var shallowEqual = __webpack_require__("./node_modules/fbjs/lib/shallowEqual.js");
    /**
     * WARNING: DO NOT manually require this module.
     * This is a replacement for `invariant(...)` used by the error code system
     * and will _only_ be required by the corresponding babel pass.
     * It always throws.
     */


    var enableAsyncSubtreeAPI = true; // Exports ReactDOM.createRoot

    var enableUserTimingAPI = true; // Mutating mode (React DOM, React ART, React Native):

    var enableMutatingReconciler = true; // Experimental noop mode (currently unused):

    var enableNoopReconciler = false; // Experimental persistent mode (CS):

    var enablePersistentReconciler = false; // Helps identify side effects in begin-phase lifecycle hooks and setState reducers:

    var debugRenderPhaseSideEffects = false; // Only used in www builds.

    /**
     * `ReactInstanceMap` maintains a mapping from a public facing stateful
     * instance (key) and the internal representation (value). This allows public
     * methods to accept the user facing instance as an argument and map them back
     * to internal methods.
     *
     * Note that this module is currently shared and assumed to be stateless.
     * If this becomes an actual Map, that will break.
     */

    /**
     * This API should be called `delete` but we'd have to make sure to always
     * transform these to strings for IE support. When this transform is fully
     * supported we can rename it.
     */

    function get(key) {
      return key._reactInternalFiber;
    }

    function set(key, value) {
      key._reactInternalFiber = value;
    }

    var ReactInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    var ReactCurrentOwner = ReactInternals.ReactCurrentOwner;
    var ReactDebugCurrentFrame = ReactInternals.ReactDebugCurrentFrame;

    function getComponentName(fiber) {
      var type = fiber.type;

      if (typeof type === 'string') {
        return type;
      }

      if (typeof type === 'function') {
        return type.displayName || type.name;
      }

      return null;
    }

    var IndeterminateComponent = 0; // Before we know whether it is functional or class

    var FunctionalComponent = 1;
    var ClassComponent = 2;
    var HostRoot = 3; // Root of a host tree. Could be nested inside another node.

    var HostPortal = 4; // A subtree. Could be an entry point to a different renderer.

    var HostComponent = 5;
    var HostText = 6;
    var CallComponent = 7;
    var CallHandlerPhase = 8;
    var ReturnComponent = 9;
    var Fragment = 10; // Don't change these two values:

    var NoEffect = 0; //           0b00000000

    var PerformedWork = 1; //      0b00000001
    // You can change the rest (and add more).

    var Placement = 2; //          0b00000010

    var Update = 4; //             0b00000100

    var PlacementAndUpdate = 6; // 0b00000110

    var Deletion = 8; //           0b00001000

    var ContentReset = 16; //      0b00010000

    var Callback = 32; //          0b00100000

    var Err = 64; //               0b01000000

    var Ref = 128; //              0b10000000

    var MOUNTING = 1;
    var MOUNTED = 2;
    var UNMOUNTED = 3;

    function isFiberMountedImpl(fiber) {
      var node = fiber;

      if (!fiber.alternate) {
        // If there is no alternate, this might be a new tree that isn't inserted
        // yet. If it is, then it will have a pending insertion effect on it.
        if ((node.effectTag & Placement) !== NoEffect) {
          return MOUNTING;
        }

        while (node['return']) {
          node = node['return'];

          if ((node.effectTag & Placement) !== NoEffect) {
            return MOUNTING;
          }
        }
      } else {
        while (node['return']) {
          node = node['return'];
        }
      }

      if (node.tag === HostRoot) {
        // TODO: Check if this was a nested HostRoot when used with
        // renderContainerIntoSubtree.
        return MOUNTED;
      } // If we didn't hit the root, that means that we're in an disconnected tree
      // that has been unmounted.


      return UNMOUNTED;
    }

    function isFiberMounted(fiber) {
      return isFiberMountedImpl(fiber) === MOUNTED;
    }

    function isMounted(component) {
      {
        var owner = ReactCurrentOwner.current;

        if (owner !== null && owner.tag === ClassComponent) {
          var ownerFiber = owner;
          var instance = ownerFiber.stateNode;
          warning(instance._warnedAboutRefsInRender, '%s is accessing isMounted inside its render() function. ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', getComponentName(ownerFiber) || 'A component');
          instance._warnedAboutRefsInRender = true;
        }
      }
      var fiber = get(component);

      if (!fiber) {
        return false;
      }

      return isFiberMountedImpl(fiber) === MOUNTED;
    }

    function assertIsMounted(fiber) {
      !(isFiberMountedImpl(fiber) === MOUNTED) ? invariant(false, 'Unable to find node on an unmounted component.') : void 0;
    }

    function findCurrentFiberUsingSlowPath(fiber) {
      var alternate = fiber.alternate;

      if (!alternate) {
        // If there is no alternate, then we only need to check if it is mounted.
        var state = isFiberMountedImpl(fiber);
        !(state !== UNMOUNTED) ? invariant(false, 'Unable to find node on an unmounted component.') : void 0;

        if (state === MOUNTING) {
          return null;
        }

        return fiber;
      } // If we have two possible branches, we'll walk backwards up to the root
      // to see what path the root points to. On the way we may hit one of the
      // special cases and we'll deal with them.


      var a = fiber;
      var b = alternate;

      while (true) {
        var parentA = a['return'];
        var parentB = parentA ? parentA.alternate : null;

        if (!parentA || !parentB) {
          // We're at the root.
          break;
        } // If both copies of the parent fiber point to the same child, we can
        // assume that the child is current. This happens when we bailout on low
        // priority: the bailed out fiber's child reuses the current child.


        if (parentA.child === parentB.child) {
          var child = parentA.child;

          while (child) {
            if (child === a) {
              // We've determined that A is the current branch.
              assertIsMounted(parentA);
              return fiber;
            }

            if (child === b) {
              // We've determined that B is the current branch.
              assertIsMounted(parentA);
              return alternate;
            }

            child = child.sibling;
          } // We should never have an alternate for any mounting node. So the only
          // way this could possibly happen is if this was unmounted, if at all.


          invariant(false, 'Unable to find node on an unmounted component.');
        }

        if (a['return'] !== b['return']) {
          // The return pointer of A and the return pointer of B point to different
          // fibers. We assume that return pointers never criss-cross, so A must
          // belong to the child set of A.return, and B must belong to the child
          // set of B.return.
          a = parentA;
          b = parentB;
        } else {
          // The return pointers point to the same fiber. We'll have to use the
          // default, slow path: scan the child sets of each parent alternate to see
          // which child belongs to which set.
          //
          // Search parent A's child set
          var didFindChild = false;
          var _child = parentA.child;

          while (_child) {
            if (_child === a) {
              didFindChild = true;
              a = parentA;
              b = parentB;
              break;
            }

            if (_child === b) {
              didFindChild = true;
              b = parentA;
              a = parentB;
              break;
            }

            _child = _child.sibling;
          }

          if (!didFindChild) {
            // Search parent B's child set
            _child = parentB.child;

            while (_child) {
              if (_child === a) {
                didFindChild = true;
                a = parentB;
                b = parentA;
                break;
              }

              if (_child === b) {
                didFindChild = true;
                b = parentB;
                a = parentA;
                break;
              }

              _child = _child.sibling;
            }

            !didFindChild ? invariant(false, 'Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue.') : void 0;
          }
        }

        !(a.alternate === b) ? invariant(false, 'Return fibers should always be each others\' alternates. This error is likely caused by a bug in React. Please file an issue.') : void 0;
      } // If the root is not a host container, we're in a disconnected tree. I.e.
      // unmounted.


      !(a.tag === HostRoot) ? invariant(false, 'Unable to find node on an unmounted component.') : void 0;

      if (a.stateNode.current === a) {
        // We've determined that A is the current branch.
        return fiber;
      } // Otherwise B has to be current branch.


      return alternate;
    }

    function findCurrentHostFiber(parent) {
      var currentParent = findCurrentFiberUsingSlowPath(parent);

      if (!currentParent) {
        return null;
      } // Next we'll drill down this component to find the first HostComponent/Text.


      var node = currentParent;

      while (true) {
        if (node.tag === HostComponent || node.tag === HostText) {
          return node;
        } else if (node.child) {
          node.child['return'] = node;
          node = node.child;
          continue;
        }

        if (node === currentParent) {
          return null;
        }

        while (!node.sibling) {
          if (!node['return'] || node['return'] === currentParent) {
            return null;
          }

          node = node['return'];
        }

        node.sibling['return'] = node['return'];
        node = node.sibling;
      } // Flow needs the return null here, but ESLint complains about it.
      // eslint-disable-next-line no-unreachable


      return null;
    }

    function findCurrentHostFiberWithNoPortals(parent) {
      var currentParent = findCurrentFiberUsingSlowPath(parent);

      if (!currentParent) {
        return null;
      } // Next we'll drill down this component to find the first HostComponent/Text.


      var node = currentParent;

      while (true) {
        if (node.tag === HostComponent || node.tag === HostText) {
          return node;
        } else if (node.child && node.tag !== HostPortal) {
          node.child['return'] = node;
          node = node.child;
          continue;
        }

        if (node === currentParent) {
          return null;
        }

        while (!node.sibling) {
          if (!node['return'] || node['return'] === currentParent) {
            return null;
          }

          node = node['return'];
        }

        node.sibling['return'] = node['return'];
        node = node.sibling;
      } // Flow needs the return null here, but ESLint complains about it.
      // eslint-disable-next-line no-unreachable


      return null;
    }

    var valueStack = [];
    {
      var fiberStack = [];
    }
    var index = -1;

    function createCursor(defaultValue) {
      return {
        current: defaultValue
      };
    }

    function pop(cursor, fiber) {
      if (index < 0) {
        {
          warning(false, 'Unexpected pop.');
        }
        return;
      }

      {
        if (fiber !== fiberStack[index]) {
          warning(false, 'Unexpected Fiber popped.');
        }
      }
      cursor.current = valueStack[index];
      valueStack[index] = null;
      {
        fiberStack[index] = null;
      }
      index--;
    }

    function push(cursor, value, fiber) {
      index++;
      valueStack[index] = cursor.current;
      {
        fiberStack[index] = fiber;
      }
      cursor.current = value;
    }

    function reset() {
      while (index > -1) {
        valueStack[index] = null;
        {
          fiberStack[index] = null;
        }
        index--;
      }
    }

    var describeComponentFrame = function describeComponentFrame(name, source, ownerName) {
      return '\n    in ' + (name || 'Unknown') + (source ? ' (at ' + source.fileName.replace(/^.*[\\\/]/, '') + ':' + source.lineNumber + ')' : ownerName ? ' (created by ' + ownerName + ')' : '');
    };

    function describeFiber(fiber) {
      switch (fiber.tag) {
        case IndeterminateComponent:
        case FunctionalComponent:
        case ClassComponent:
        case HostComponent:
          var owner = fiber._debugOwner;
          var source = fiber._debugSource;
          var name = getComponentName(fiber);
          var ownerName = null;

          if (owner) {
            ownerName = getComponentName(owner);
          }

          return describeComponentFrame(name, source, ownerName);

        default:
          return '';
      }
    } // This function can only be called with a work-in-progress fiber and
    // only during begin or complete phase. Do not call it under any other
    // circumstances.


    function getStackAddendumByWorkInProgressFiber(workInProgress) {
      var info = '';
      var node = workInProgress;

      do {
        info += describeFiber(node); // Otherwise this return pointer might point to the wrong tree:

        node = node['return'];
      } while (node);

      return info;
    }

    function getCurrentFiberOwnerName() {
      {
        var fiber = ReactDebugCurrentFiber.current;

        if (fiber === null) {
          return null;
        }

        var owner = fiber._debugOwner;

        if (owner !== null && typeof owner !== 'undefined') {
          return getComponentName(owner);
        }
      }
      return null;
    }

    function getCurrentFiberStackAddendum() {
      {
        var fiber = ReactDebugCurrentFiber.current;

        if (fiber === null) {
          return null;
        } // Safe because if current fiber exists, we are reconciling,
        // and it is guaranteed to be the work-in-progress version.


        return getStackAddendumByWorkInProgressFiber(fiber);
      }
      return null;
    }

    function resetCurrentFiber() {
      ReactDebugCurrentFrame.getCurrentStack = null;
      ReactDebugCurrentFiber.current = null;
      ReactDebugCurrentFiber.phase = null;
    }

    function setCurrentFiber(fiber) {
      ReactDebugCurrentFrame.getCurrentStack = getCurrentFiberStackAddendum;
      ReactDebugCurrentFiber.current = fiber;
      ReactDebugCurrentFiber.phase = null;
    }

    function setCurrentPhase(phase) {
      ReactDebugCurrentFiber.phase = phase;
    }

    var ReactDebugCurrentFiber = {
      current: null,
      phase: null,
      resetCurrentFiber: resetCurrentFiber,
      setCurrentFiber: setCurrentFiber,
      setCurrentPhase: setCurrentPhase,
      getCurrentFiberOwnerName: getCurrentFiberOwnerName,
      getCurrentFiberStackAddendum: getCurrentFiberStackAddendum
    }; // Prefix measurements so that it's possible to filter them.
    // Longer prefixes are hard to read in DevTools.

    var reactEmoji = "\u269B";
    var warningEmoji = "\u26D4";
    var supportsUserTiming = typeof performance !== 'undefined' && typeof performance.mark === 'function' && typeof performance.clearMarks === 'function' && typeof performance.measure === 'function' && typeof performance.clearMeasures === 'function'; // Keep track of current fiber so that we know the path to unwind on pause.
    // TODO: this looks the same as nextUnitOfWork in scheduler. Can we unify them?

    var currentFiber = null; // If we're in the middle of user code, which fiber and method is it?
    // Reusing `currentFiber` would be confusing for this because user code fiber
    // can change during commit phase too, but we don't need to unwind it (since
    // lifecycles in the commit phase don't resemble a tree).

    var currentPhase = null;
    var currentPhaseFiber = null; // Did lifecycle hook schedule an update? This is often a performance problem,
    // so we will keep track of it, and include it in the report.
    // Track commits caused by cascading updates.

    var isCommitting = false;
    var hasScheduledUpdateInCurrentCommit = false;
    var hasScheduledUpdateInCurrentPhase = false;
    var commitCountInCurrentWorkLoop = 0;
    var effectCountInCurrentCommit = 0;
    var isWaitingForCallback = false; // During commits, we only show a measurement once per method name
    // to avoid stretch the commit phase with measurement overhead.

    var labelsInCurrentCommit = new Set();

    var formatMarkName = function formatMarkName(markName) {
      return reactEmoji + ' ' + markName;
    };

    var formatLabel = function formatLabel(label, warning$$1) {
      var prefix = warning$$1 ? warningEmoji + ' ' : reactEmoji + ' ';
      var suffix = warning$$1 ? ' Warning: ' + warning$$1 : '';
      return '' + prefix + label + suffix;
    };

    var beginMark = function beginMark(markName) {
      performance.mark(formatMarkName(markName));
    };

    var clearMark = function clearMark(markName) {
      performance.clearMarks(formatMarkName(markName));
    };

    var endMark = function endMark(label, markName, warning$$1) {
      var formattedMarkName = formatMarkName(markName);
      var formattedLabel = formatLabel(label, warning$$1);

      try {
        performance.measure(formattedLabel, formattedMarkName);
      } catch (err) {} // If previous mark was missing for some reason, this will throw.
      // This could only happen if React crashed in an unexpected place earlier.
      // Don't pile on with more errors.
      // Clear marks immediately to avoid growing buffer.


      performance.clearMarks(formattedMarkName);
      performance.clearMeasures(formattedLabel);
    };

    var getFiberMarkName = function getFiberMarkName(label, debugID) {
      return label + ' (#' + debugID + ')';
    };

    var getFiberLabel = function getFiberLabel(componentName, isMounted, phase) {
      if (phase === null) {
        // These are composite component total time measurements.
        return componentName + ' [' + (isMounted ? 'update' : 'mount') + ']';
      } else {
        // Composite component methods.
        return componentName + '.' + phase;
      }
    };

    var beginFiberMark = function beginFiberMark(fiber, phase) {
      var componentName = getComponentName(fiber) || 'Unknown';
      var debugID = fiber._debugID;
      var isMounted = fiber.alternate !== null;
      var label = getFiberLabel(componentName, isMounted, phase);

      if (isCommitting && labelsInCurrentCommit.has(label)) {
        // During the commit phase, we don't show duplicate labels because
        // there is a fixed overhead for every measurement, and we don't
        // want to stretch the commit phase beyond necessary.
        return false;
      }

      labelsInCurrentCommit.add(label);
      var markName = getFiberMarkName(label, debugID);
      beginMark(markName);
      return true;
    };

    var clearFiberMark = function clearFiberMark(fiber, phase) {
      var componentName = getComponentName(fiber) || 'Unknown';
      var debugID = fiber._debugID;
      var isMounted = fiber.alternate !== null;
      var label = getFiberLabel(componentName, isMounted, phase);
      var markName = getFiberMarkName(label, debugID);
      clearMark(markName);
    };

    var endFiberMark = function endFiberMark(fiber, phase, warning$$1) {
      var componentName = getComponentName(fiber) || 'Unknown';
      var debugID = fiber._debugID;
      var isMounted = fiber.alternate !== null;
      var label = getFiberLabel(componentName, isMounted, phase);
      var markName = getFiberMarkName(label, debugID);
      endMark(label, markName, warning$$1);
    };

    var shouldIgnoreFiber = function shouldIgnoreFiber(fiber) {
      // Host components should be skipped in the timeline.
      // We could check typeof fiber.type, but does this work with RN?
      switch (fiber.tag) {
        case HostRoot:
        case HostComponent:
        case HostText:
        case HostPortal:
        case ReturnComponent:
        case Fragment:
          return true;

        default:
          return false;
      }
    };

    var clearPendingPhaseMeasurement = function clearPendingPhaseMeasurement() {
      if (currentPhase !== null && currentPhaseFiber !== null) {
        clearFiberMark(currentPhaseFiber, currentPhase);
      }

      currentPhaseFiber = null;
      currentPhase = null;
      hasScheduledUpdateInCurrentPhase = false;
    };

    var pauseTimers = function pauseTimers() {
      // Stops all currently active measurements so that they can be resumed
      // if we continue in a later deferred loop from the same unit of work.
      var fiber = currentFiber;

      while (fiber) {
        if (fiber._debugIsCurrentlyTiming) {
          endFiberMark(fiber, null, null);
        }

        fiber = fiber['return'];
      }
    };

    var resumeTimersRecursively = function resumeTimersRecursively(fiber) {
      if (fiber['return'] !== null) {
        resumeTimersRecursively(fiber['return']);
      }

      if (fiber._debugIsCurrentlyTiming) {
        beginFiberMark(fiber, null);
      }
    };

    var resumeTimers = function resumeTimers() {
      // Resumes all measurements that were active during the last deferred loop.
      if (currentFiber !== null) {
        resumeTimersRecursively(currentFiber);
      }
    };

    function recordEffect() {
      if (enableUserTimingAPI) {
        effectCountInCurrentCommit++;
      }
    }

    function recordScheduleUpdate() {
      if (enableUserTimingAPI) {
        if (isCommitting) {
          hasScheduledUpdateInCurrentCommit = true;
        }

        if (currentPhase !== null && currentPhase !== 'componentWillMount' && currentPhase !== 'componentWillReceiveProps') {
          hasScheduledUpdateInCurrentPhase = true;
        }
      }
    }

    function startRequestCallbackTimer() {
      if (enableUserTimingAPI) {
        if (supportsUserTiming && !isWaitingForCallback) {
          isWaitingForCallback = true;
          beginMark('(Waiting for async callback...)');
        }
      }
    }

    function stopRequestCallbackTimer(didExpire) {
      if (enableUserTimingAPI) {
        if (supportsUserTiming) {
          isWaitingForCallback = false;
          var warning$$1 = didExpire ? 'React was blocked by main thread' : null;
          endMark('(Waiting for async callback...)', '(Waiting for async callback...)', warning$$1);
        }
      }
    }

    function startWorkTimer(fiber) {
      if (enableUserTimingAPI) {
        if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {
          return;
        } // If we pause, this is the fiber to unwind from.


        currentFiber = fiber;

        if (!beginFiberMark(fiber, null)) {
          return;
        }

        fiber._debugIsCurrentlyTiming = true;
      }
    }

    function cancelWorkTimer(fiber) {
      if (enableUserTimingAPI) {
        if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {
          return;
        } // Remember we shouldn't complete measurement for this fiber.
        // Otherwise flamechart will be deep even for small updates.


        fiber._debugIsCurrentlyTiming = false;
        clearFiberMark(fiber, null);
      }
    }

    function stopWorkTimer(fiber) {
      if (enableUserTimingAPI) {
        if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {
          return;
        } // If we pause, its parent is the fiber to unwind from.


        currentFiber = fiber['return'];

        if (!fiber._debugIsCurrentlyTiming) {
          return;
        }

        fiber._debugIsCurrentlyTiming = false;
        endFiberMark(fiber, null, null);
      }
    }

    function stopFailedWorkTimer(fiber) {
      if (enableUserTimingAPI) {
        if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {
          return;
        } // If we pause, its parent is the fiber to unwind from.


        currentFiber = fiber['return'];

        if (!fiber._debugIsCurrentlyTiming) {
          return;
        }

        fiber._debugIsCurrentlyTiming = false;
        var warning$$1 = 'An error was thrown inside this error boundary';
        endFiberMark(fiber, null, warning$$1);
      }
    }

    function startPhaseTimer(fiber, phase) {
      if (enableUserTimingAPI) {
        if (!supportsUserTiming) {
          return;
        }

        clearPendingPhaseMeasurement();

        if (!beginFiberMark(fiber, phase)) {
          return;
        }

        currentPhaseFiber = fiber;
        currentPhase = phase;
      }
    }

    function stopPhaseTimer() {
      if (enableUserTimingAPI) {
        if (!supportsUserTiming) {
          return;
        }

        if (currentPhase !== null && currentPhaseFiber !== null) {
          var warning$$1 = hasScheduledUpdateInCurrentPhase ? 'Scheduled a cascading update' : null;
          endFiberMark(currentPhaseFiber, currentPhase, warning$$1);
        }

        currentPhase = null;
        currentPhaseFiber = null;
      }
    }

    function startWorkLoopTimer(nextUnitOfWork) {
      if (enableUserTimingAPI) {
        currentFiber = nextUnitOfWork;

        if (!supportsUserTiming) {
          return;
        }

        commitCountInCurrentWorkLoop = 0; // This is top level call.
        // Any other measurements are performed within.

        beginMark('(React Tree Reconciliation)'); // Resume any measurements that were in progress during the last loop.

        resumeTimers();
      }
    }

    function stopWorkLoopTimer(interruptedBy) {
      if (enableUserTimingAPI) {
        if (!supportsUserTiming) {
          return;
        }

        var warning$$1 = null;

        if (interruptedBy !== null) {
          if (interruptedBy.tag === HostRoot) {
            warning$$1 = 'A top-level update interrupted the previous render';
          } else {
            var componentName = getComponentName(interruptedBy) || 'Unknown';
            warning$$1 = 'An update to ' + componentName + ' interrupted the previous render';
          }
        } else if (commitCountInCurrentWorkLoop > 1) {
          warning$$1 = 'There were cascading updates';
        }

        commitCountInCurrentWorkLoop = 0; // Pause any measurements until the next loop.

        pauseTimers();
        endMark('(React Tree Reconciliation)', '(React Tree Reconciliation)', warning$$1);
      }
    }

    function startCommitTimer() {
      if (enableUserTimingAPI) {
        if (!supportsUserTiming) {
          return;
        }

        isCommitting = true;
        hasScheduledUpdateInCurrentCommit = false;
        labelsInCurrentCommit.clear();
        beginMark('(Committing Changes)');
      }
    }

    function stopCommitTimer() {
      if (enableUserTimingAPI) {
        if (!supportsUserTiming) {
          return;
        }

        var warning$$1 = null;

        if (hasScheduledUpdateInCurrentCommit) {
          warning$$1 = 'Lifecycle hook scheduled a cascading update';
        } else if (commitCountInCurrentWorkLoop > 0) {
          warning$$1 = 'Caused by a cascading update in earlier commit';
        }

        hasScheduledUpdateInCurrentCommit = false;
        commitCountInCurrentWorkLoop++;
        isCommitting = false;
        labelsInCurrentCommit.clear();
        endMark('(Committing Changes)', '(Committing Changes)', warning$$1);
      }
    }

    function startCommitHostEffectsTimer() {
      if (enableUserTimingAPI) {
        if (!supportsUserTiming) {
          return;
        }

        effectCountInCurrentCommit = 0;
        beginMark('(Committing Host Effects)');
      }
    }

    function stopCommitHostEffectsTimer() {
      if (enableUserTimingAPI) {
        if (!supportsUserTiming) {
          return;
        }

        var count = effectCountInCurrentCommit;
        effectCountInCurrentCommit = 0;
        endMark('(Committing Host Effects: ' + count + ' Total)', '(Committing Host Effects)', null);
      }
    }

    function startCommitLifeCyclesTimer() {
      if (enableUserTimingAPI) {
        if (!supportsUserTiming) {
          return;
        }

        effectCountInCurrentCommit = 0;
        beginMark('(Calling Lifecycle Methods)');
      }
    }

    function stopCommitLifeCyclesTimer() {
      if (enableUserTimingAPI) {
        if (!supportsUserTiming) {
          return;
        }

        var count = effectCountInCurrentCommit;
        effectCountInCurrentCommit = 0;
        endMark('(Calling Lifecycle Methods: ' + count + ' Total)', '(Calling Lifecycle Methods)', null);
      }
    }

    {
      var warnedAboutMissingGetChildContext = {};
    } // A cursor to the current merged context object on the stack.

    var contextStackCursor = createCursor(emptyObject); // A cursor to a boolean indicating whether the context has changed.

    var didPerformWorkStackCursor = createCursor(false); // Keep track of the previous context object that was on the stack.
    // We use this to get access to the parent context after we have already
    // pushed the next context provider, and now need to merge their contexts.

    var previousContext = emptyObject;

    function getUnmaskedContext(workInProgress) {
      var hasOwnContext = isContextProvider(workInProgress);

      if (hasOwnContext) {
        // If the fiber is a context provider itself, when we read its context
        // we have already pushed its own child context on the stack. A context
        // provider should not "see" its own child context. Therefore we read the
        // previous (parent) context instead for a context provider.
        return previousContext;
      }

      return contextStackCursor.current;
    }

    function cacheContext(workInProgress, unmaskedContext, maskedContext) {
      var instance = workInProgress.stateNode;
      instance.__reactInternalMemoizedUnmaskedChildContext = unmaskedContext;
      instance.__reactInternalMemoizedMaskedChildContext = maskedContext;
    }

    function getMaskedContext(workInProgress, unmaskedContext) {
      var type = workInProgress.type;
      var contextTypes = type.contextTypes;

      if (!contextTypes) {
        return emptyObject;
      } // Avoid recreating masked context unless unmasked context has changed.
      // Failing to do this will result in unnecessary calls to componentWillReceiveProps.
      // This may trigger infinite loops if componentWillReceiveProps calls setState.


      var instance = workInProgress.stateNode;

      if (instance && instance.__reactInternalMemoizedUnmaskedChildContext === unmaskedContext) {
        return instance.__reactInternalMemoizedMaskedChildContext;
      }

      var context = {};

      for (var key in contextTypes) {
        context[key] = unmaskedContext[key];
      }

      {
        var name = getComponentName(workInProgress) || 'Unknown';
        checkPropTypes(contextTypes, context, 'context', name, ReactDebugCurrentFiber.getCurrentFiberStackAddendum);
      } // Cache unmasked context so we can avoid recreating masked context unless necessary.
      // Context is created before the class component is instantiated so check for instance.

      if (instance) {
        cacheContext(workInProgress, unmaskedContext, context);
      }

      return context;
    }

    function hasContextChanged() {
      return didPerformWorkStackCursor.current;
    }

    function isContextConsumer(fiber) {
      return fiber.tag === ClassComponent && fiber.type.contextTypes != null;
    }

    function isContextProvider(fiber) {
      return fiber.tag === ClassComponent && fiber.type.childContextTypes != null;
    }

    function popContextProvider(fiber) {
      if (!isContextProvider(fiber)) {
        return;
      }

      pop(didPerformWorkStackCursor, fiber);
      pop(contextStackCursor, fiber);
    }

    function popTopLevelContextObject(fiber) {
      pop(didPerformWorkStackCursor, fiber);
      pop(contextStackCursor, fiber);
    }

    function pushTopLevelContextObject(fiber, context, didChange) {
      !(contextStackCursor.cursor == null) ? invariant(false, 'Unexpected context found on stack. This error is likely caused by a bug in React. Please file an issue.') : void 0;
      push(contextStackCursor, context, fiber);
      push(didPerformWorkStackCursor, didChange, fiber);
    }

    function processChildContext(fiber, parentContext) {
      var instance = fiber.stateNode;
      var childContextTypes = fiber.type.childContextTypes; // TODO (bvaughn) Replace this behavior with an invariant() in the future.
      // It has only been added in Fiber to match the (unintentional) behavior in Stack.

      if (typeof instance.getChildContext !== 'function') {
        {
          var componentName = getComponentName(fiber) || 'Unknown';

          if (!warnedAboutMissingGetChildContext[componentName]) {
            warnedAboutMissingGetChildContext[componentName] = true;
            warning(false, '%s.childContextTypes is specified but there is no getChildContext() method ' + 'on the instance. You can either define getChildContext() on %s or remove ' + 'childContextTypes from it.', componentName, componentName);
          }
        }
        return parentContext;
      }

      var childContext = void 0;
      {
        ReactDebugCurrentFiber.setCurrentPhase('getChildContext');
      }
      startPhaseTimer(fiber, 'getChildContext');
      childContext = instance.getChildContext();
      stopPhaseTimer();
      {
        ReactDebugCurrentFiber.setCurrentPhase(null);
      }

      for (var contextKey in childContext) {
        !(contextKey in childContextTypes) ? invariant(false, '%s.getChildContext(): key "%s" is not defined in childContextTypes.', getComponentName(fiber) || 'Unknown', contextKey) : void 0;
      }

      {
        var name = getComponentName(fiber) || 'Unknown';
        checkPropTypes(childContextTypes, childContext, 'child context', name, // In practice, there is one case in which we won't get a stack. It's when
        // somebody calls unstable_renderSubtreeIntoContainer() and we process
        // context from the parent component instance. The stack will be missing
        // because it's outside of the reconciliation, and so the pointer has not
        // been set. This is rare and doesn't matter. We'll also remove that API.
        ReactDebugCurrentFiber.getCurrentFiberStackAddendum);
      }
      return _assign({}, parentContext, childContext);
    }

    function pushContextProvider(workInProgress) {
      if (!isContextProvider(workInProgress)) {
        return false;
      }

      var instance = workInProgress.stateNode; // We push the context as early as possible to ensure stack integrity.
      // If the instance does not exist yet, we will push null at first,
      // and replace it on the stack later when invalidating the context.

      var memoizedMergedChildContext = instance && instance.__reactInternalMemoizedMergedChildContext || emptyObject; // Remember the parent context so we can merge with it later.
      // Inherit the parent's did-perform-work value to avoid inadvertently blocking updates.

      previousContext = contextStackCursor.current;
      push(contextStackCursor, memoizedMergedChildContext, workInProgress);
      push(didPerformWorkStackCursor, didPerformWorkStackCursor.current, workInProgress);
      return true;
    }

    function invalidateContextProvider(workInProgress, didChange) {
      var instance = workInProgress.stateNode;
      !instance ? invariant(false, 'Expected to have an instance by this point. This error is likely caused by a bug in React. Please file an issue.') : void 0;

      if (didChange) {
        // Merge parent and own context.
        // Skip this if we're not updating due to sCU.
        // This avoids unnecessarily recomputing memoized values.
        var mergedContext = processChildContext(workInProgress, previousContext);
        instance.__reactInternalMemoizedMergedChildContext = mergedContext; // Replace the old (or empty) context with the new one.
        // It is important to unwind the context in the reverse order.

        pop(didPerformWorkStackCursor, workInProgress);
        pop(contextStackCursor, workInProgress); // Now push the new context and mark that it has changed.

        push(contextStackCursor, mergedContext, workInProgress);
        push(didPerformWorkStackCursor, didChange, workInProgress);
      } else {
        pop(didPerformWorkStackCursor, workInProgress);
        push(didPerformWorkStackCursor, didChange, workInProgress);
      }
    }

    function resetContext() {
      previousContext = emptyObject;
      contextStackCursor.current = emptyObject;
      didPerformWorkStackCursor.current = false;
    }

    function findCurrentUnmaskedContext(fiber) {
      // Currently this is only used with renderSubtreeIntoContainer; not sure if it
      // makes sense elsewhere
      !(isFiberMounted(fiber) && fiber.tag === ClassComponent) ? invariant(false, 'Expected subtree parent to be a mounted class component. This error is likely caused by a bug in React. Please file an issue.') : void 0;
      var node = fiber;

      while (node.tag !== HostRoot) {
        if (isContextProvider(node)) {
          return node.stateNode.__reactInternalMemoizedMergedChildContext;
        }

        var parent = node['return'];
        !parent ? invariant(false, 'Found unexpected detached subtree parent. This error is likely caused by a bug in React. Please file an issue.') : void 0;
        node = parent;
      }

      return node.stateNode.context;
    }

    var NoWork = 0; // TODO: Use an opaque type once ESLint et al support the syntax

    var Sync = 1;
    var Never = 2147483647; // Max int32: Math.pow(2, 31) - 1

    var UNIT_SIZE = 10;
    var MAGIC_NUMBER_OFFSET = 2; // 1 unit of expiration time represents 10ms.

    function msToExpirationTime(ms) {
      // Always add an offset so that we don't clash with the magic number for NoWork.
      return (ms / UNIT_SIZE | 0) + MAGIC_NUMBER_OFFSET;
    }

    function expirationTimeToMs(expirationTime) {
      return (expirationTime - MAGIC_NUMBER_OFFSET) * UNIT_SIZE;
    }

    function ceiling(num, precision) {
      return ((num / precision | 0) + 1) * precision;
    }

    function computeExpirationBucket(currentTime, expirationInMs, bucketSizeMs) {
      return ceiling(currentTime + expirationInMs / UNIT_SIZE, bucketSizeMs / UNIT_SIZE);
    }

    var NoContext = 0;
    var AsyncUpdates = 1;
    {
      var hasBadMapPolyfill = false;

      try {
        var nonExtensibleObject = Object.preventExtensions({});
        /* eslint-disable no-new */

        /* eslint-enable no-new */
      } catch (e) {
        // TODO: Consider warning about bad polyfills
        hasBadMapPolyfill = true;
      }
    } // A Fiber is work on a Component that needs to be done or was done. There can
    // be more than one per component.

    {
      var debugCounter = 1;
    }

    function FiberNode(tag, key, internalContextTag) {
      // Instance
      this.tag = tag;
      this.key = key;
      this.type = null;
      this.stateNode = null; // Fiber

      this['return'] = null;
      this.child = null;
      this.sibling = null;
      this.index = 0;
      this.ref = null;
      this.pendingProps = null;
      this.memoizedProps = null;
      this.updateQueue = null;
      this.memoizedState = null;
      this.internalContextTag = internalContextTag; // Effects

      this.effectTag = NoEffect;
      this.nextEffect = null;
      this.firstEffect = null;
      this.lastEffect = null;
      this.expirationTime = NoWork;
      this.alternate = null;
      {
        this._debugID = debugCounter++;
        this._debugSource = null;
        this._debugOwner = null;
        this._debugIsCurrentlyTiming = false;

        if (!hasBadMapPolyfill && typeof Object.preventExtensions === 'function') {
          Object.preventExtensions(this);
        }
      }
    } // This is a constructor function, rather than a POJO constructor, still
    // please ensure we do the following:
    // 1) Nobody should add any instance methods on this. Instance methods can be
    //    more difficult to predict when they get optimized and they are almost
    //    never inlined properly in static compilers.
    // 2) Nobody should rely on `instanceof Fiber` for type testing. We should
    //    always know when it is a fiber.
    // 3) We might want to experiment with using numeric keys since they are easier
    //    to optimize in a non-JIT environment.
    // 4) We can easily go from a constructor to a createFiber object literal if that
    //    is faster.
    // 5) It should be easy to port this to a C struct and keep a C implementation
    //    compatible.


    var createFiber = function createFiber(tag, key, internalContextTag) {
      // $FlowFixMe: the shapes are exact here but Flow doesn't like constructors
      return new FiberNode(tag, key, internalContextTag);
    };

    function shouldConstruct(Component) {
      return !!(Component.prototype && Component.prototype.isReactComponent);
    } // This is used to create an alternate fiber to do work on.


    function createWorkInProgress(current, pendingProps, expirationTime) {
      var workInProgress = current.alternate;

      if (workInProgress === null) {
        // We use a double buffering pooling technique because we know that we'll
        // only ever need at most two versions of a tree. We pool the "other" unused
        // node that we're free to reuse. This is lazily created to avoid allocating
        // extra objects for things that are never updated. It also allow us to
        // reclaim the extra memory if needed.
        workInProgress = createFiber(current.tag, current.key, current.internalContextTag);
        workInProgress.type = current.type;
        workInProgress.stateNode = current.stateNode;
        {
          // DEV-only fields
          workInProgress._debugID = current._debugID;
          workInProgress._debugSource = current._debugSource;
          workInProgress._debugOwner = current._debugOwner;
        }
        workInProgress.alternate = current;
        current.alternate = workInProgress;
      } else {
        // We already have an alternate.
        // Reset the effect tag.
        workInProgress.effectTag = NoEffect; // The effect list is no longer valid.

        workInProgress.nextEffect = null;
        workInProgress.firstEffect = null;
        workInProgress.lastEffect = null;
      }

      workInProgress.expirationTime = expirationTime;
      workInProgress.pendingProps = pendingProps;
      workInProgress.child = current.child;
      workInProgress.memoizedProps = current.memoizedProps;
      workInProgress.memoizedState = current.memoizedState;
      workInProgress.updateQueue = current.updateQueue; // These will be overridden during the parent's reconciliation

      workInProgress.sibling = current.sibling;
      workInProgress.index = current.index;
      workInProgress.ref = current.ref;
      return workInProgress;
    }

    function createHostRootFiber() {
      var fiber = createFiber(HostRoot, null, NoContext);
      return fiber;
    }

    function createFiberFromElement(element, internalContextTag, expirationTime) {
      var owner = null;
      {
        owner = element._owner;
      }
      var fiber = void 0;
      var type = element.type,
          key = element.key;

      if (typeof type === 'function') {
        fiber = shouldConstruct(type) ? createFiber(ClassComponent, key, internalContextTag) : createFiber(IndeterminateComponent, key, internalContextTag);
        fiber.type = type;
        fiber.pendingProps = element.props;
      } else if (typeof type === 'string') {
        fiber = createFiber(HostComponent, key, internalContextTag);
        fiber.type = type;
        fiber.pendingProps = element.props;
      } else if (typeof type === 'object' && type !== null && typeof type.tag === 'number') {
        // Currently assumed to be a continuation and therefore is a fiber already.
        // TODO: The yield system is currently broken for updates in some cases.
        // The reified yield stores a fiber, but we don't know which fiber that is;
        // the current or a workInProgress? When the continuation gets rendered here
        // we don't know if we can reuse that fiber or if we need to clone it.
        // There is probably a clever way to restructure this.
        fiber = type;
        fiber.pendingProps = element.props;
      } else {
        var info = '';
        {
          if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {
            info += ' You likely forgot to export your component from the file ' + "it's defined in, or you might have mixed up default and named imports.";
          }

          var ownerName = owner ? getComponentName(owner) : null;

          if (ownerName) {
            info += '\n\nCheck the render method of `' + ownerName + '`.';
          }
        }
        invariant(false, 'Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s', type == null ? type : typeof type, info);
      }

      {
        fiber._debugSource = element._source;
        fiber._debugOwner = element._owner;
      }
      fiber.expirationTime = expirationTime;
      return fiber;
    }

    function createFiberFromFragment(elements, internalContextTag, expirationTime, key) {
      var fiber = createFiber(Fragment, key, internalContextTag);
      fiber.pendingProps = elements;
      fiber.expirationTime = expirationTime;
      return fiber;
    }

    function createFiberFromText(content, internalContextTag, expirationTime) {
      var fiber = createFiber(HostText, null, internalContextTag);
      fiber.pendingProps = content;
      fiber.expirationTime = expirationTime;
      return fiber;
    }

    function createFiberFromHostInstanceForDeletion() {
      var fiber = createFiber(HostComponent, null, NoContext);
      fiber.type = 'DELETED';
      return fiber;
    }

    function createFiberFromCall(call, internalContextTag, expirationTime) {
      var fiber = createFiber(CallComponent, call.key, internalContextTag);
      fiber.type = call.handler;
      fiber.pendingProps = call;
      fiber.expirationTime = expirationTime;
      return fiber;
    }

    function createFiberFromReturn(returnNode, internalContextTag, expirationTime) {
      var fiber = createFiber(ReturnComponent, null, internalContextTag);
      fiber.expirationTime = expirationTime;
      return fiber;
    }

    function createFiberFromPortal(portal, internalContextTag, expirationTime) {
      var fiber = createFiber(HostPortal, portal.key, internalContextTag);
      fiber.pendingProps = portal.children || [];
      fiber.expirationTime = expirationTime;
      fiber.stateNode = {
        containerInfo: portal.containerInfo,
        pendingChildren: null,
        // Used by persistent updates
        implementation: portal.implementation
      };
      return fiber;
    }

    function createFiberRoot(containerInfo, hydrate) {
      // Cyclic construction. This cheats the type system right now because
      // stateNode is any.
      var uninitializedFiber = createHostRootFiber();
      var root = {
        current: uninitializedFiber,
        containerInfo: containerInfo,
        pendingChildren: null,
        remainingExpirationTime: NoWork,
        isReadyForCommit: false,
        finishedWork: null,
        context: null,
        pendingContext: null,
        hydrate: hydrate,
        nextScheduledRoot: null
      };
      uninitializedFiber.stateNode = root;
      return root;
    }

    var onCommitFiberRoot = null;
    var onCommitFiberUnmount = null;
    var hasLoggedError = false;

    function catchErrors(fn) {
      return function (arg) {
        try {
          return fn(arg);
        } catch (err) {
          if (true && !hasLoggedError) {
            hasLoggedError = true;
            warning(false, 'React DevTools encountered an error: %s', err);
          }
        }
      };
    }

    function injectInternals(internals) {
      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined') {
        // No DevTools
        return false;
      }

      var hook = __REACT_DEVTOOLS_GLOBAL_HOOK__;

      if (hook.isDisabled) {
        // This isn't a real property on the hook, but it can be set to opt out
        // of DevTools integration and associated warnings and logs.
        // https://github.com/facebook/react/issues/3877
        return true;
      }

      if (!hook.supportsFiber) {
        {
          warning(false, 'The installed version of React DevTools is too old and will not work ' + 'with the current version of React. Please update React DevTools. ' + 'https://fb.me/react-devtools');
        } // DevTools exists, even though it doesn't support Fiber.

        return true;
      }

      try {
        var rendererID = hook.inject(internals); // We have successfully injected, so now it is safe to set up hooks.

        onCommitFiberRoot = catchErrors(function (root) {
          return hook.onCommitFiberRoot(rendererID, root);
        });
        onCommitFiberUnmount = catchErrors(function (fiber) {
          return hook.onCommitFiberUnmount(rendererID, fiber);
        });
      } catch (err) {
        // Catch all errors because it is unsafe to throw during initialization.
        {
          warning(false, 'React DevTools encountered an error: %s.', err);
        }
      } // DevTools exists


      return true;
    }

    function onCommitRoot(root) {
      if (typeof onCommitFiberRoot === 'function') {
        onCommitFiberRoot(root);
      }
    }

    function onCommitUnmount(fiber) {
      if (typeof onCommitFiberUnmount === 'function') {
        onCommitFiberUnmount(fiber);
      }
    }

    var ReactErrorUtils = {
      // Used by Fiber to simulate a try-catch.
      _caughtError: null,
      _hasCaughtError: false,
      // Used by event system to capture/rethrow the first error.
      _rethrowError: null,
      _hasRethrowError: false,
      injection: {
        injectErrorUtils: function injectErrorUtils(injectedErrorUtils) {
          !(typeof injectedErrorUtils.invokeGuardedCallback === 'function') ? invariant(false, 'Injected invokeGuardedCallback() must be a function.') : void 0;
          invokeGuardedCallback$1 = injectedErrorUtils.invokeGuardedCallback;
        }
      },

      /**
       * Call a function while guarding against errors that happens within it.
       * Returns an error if it throws, otherwise null.
       *
       * In production, this is implemented using a try-catch. The reason we don't
       * use a try-catch directly is so that we can swap out a different
       * implementation in DEV mode.
       *
       * @param {String} name of the guard to use for logging or debugging
       * @param {Function} func The function to invoke
       * @param {*} context The context to use when calling the function
       * @param {...*} args Arguments for function
       */
      invokeGuardedCallback: function invokeGuardedCallback(name, func, context, a, b, c, d, e, f) {
        invokeGuardedCallback$1.apply(ReactErrorUtils, arguments);
      },

      /**
       * Same as invokeGuardedCallback, but instead of returning an error, it stores
       * it in a global so it can be rethrown by `rethrowCaughtError` later.
       * TODO: See if _caughtError and _rethrowError can be unified.
       *
       * @param {String} name of the guard to use for logging or debugging
       * @param {Function} func The function to invoke
       * @param {*} context The context to use when calling the function
       * @param {...*} args Arguments for function
       */
      invokeGuardedCallbackAndCatchFirstError: function invokeGuardedCallbackAndCatchFirstError(name, func, context, a, b, c, d, e, f) {
        ReactErrorUtils.invokeGuardedCallback.apply(this, arguments);

        if (ReactErrorUtils.hasCaughtError()) {
          var error = ReactErrorUtils.clearCaughtError();

          if (!ReactErrorUtils._hasRethrowError) {
            ReactErrorUtils._hasRethrowError = true;
            ReactErrorUtils._rethrowError = error;
          }
        }
      },

      /**
       * During execution of guarded functions we will capture the first error which
       * we will rethrow to be handled by the top level error handler.
       */
      rethrowCaughtError: function rethrowCaughtError() {
        return _rethrowCaughtError.apply(ReactErrorUtils, arguments);
      },
      hasCaughtError: function hasCaughtError() {
        return ReactErrorUtils._hasCaughtError;
      },
      clearCaughtError: function clearCaughtError() {
        if (ReactErrorUtils._hasCaughtError) {
          var error = ReactErrorUtils._caughtError;
          ReactErrorUtils._caughtError = null;
          ReactErrorUtils._hasCaughtError = false;
          return error;
        } else {
          invariant(false, 'clearCaughtError was called but no error was captured. This error is likely caused by a bug in React. Please file an issue.');
        }
      }
    };

    var invokeGuardedCallback$1 = function invokeGuardedCallback$1(name, func, context, a, b, c, d, e, f) {
      ReactErrorUtils._hasCaughtError = false;
      ReactErrorUtils._caughtError = null;
      var funcArgs = Array.prototype.slice.call(arguments, 3);

      try {
        func.apply(context, funcArgs);
      } catch (error) {
        ReactErrorUtils._caughtError = error;
        ReactErrorUtils._hasCaughtError = true;
      }
    };

    {
      // In DEV mode, we swap out invokeGuardedCallback for a special version
      // that plays more nicely with the browser's DevTools. The idea is to preserve
      // "Pause on exceptions" behavior. Because React wraps all user-provided
      // functions in invokeGuardedCallback, and the production version of
      // invokeGuardedCallback uses a try-catch, all user exceptions are treated
      // like caught exceptions, and the DevTools won't pause unless the developer
      // takes the extra step of enabling pause on caught exceptions. This is
      // untintuitive, though, because even though React has caught the error, from
      // the developer's perspective, the error is uncaught.
      //
      // To preserve the expected "Pause on exceptions" behavior, we don't use a
      // try-catch in DEV. Instead, we synchronously dispatch a fake event to a fake
      // DOM node, and call the user-provided callback from inside an event handler
      // for that fake event. If the callback throws, the error is "captured" using
      // a global event handler. But because the error happens in a different
      // event loop context, it does not interrupt the normal program flow.
      // Effectively, this gives us try-catch behavior without actually using
      // try-catch. Neat!
      // Check that the browser supports the APIs we need to implement our special
      // DEV version of invokeGuardedCallback
      if (typeof window !== 'undefined' && typeof window.dispatchEvent === 'function' && typeof document !== 'undefined' && typeof document.createEvent === 'function') {
        var fakeNode = document.createElement('react');

        var invokeGuardedCallbackDev = function invokeGuardedCallbackDev(name, func, context, a, b, c, d, e, f) {
          // Keeps track of whether the user-provided callback threw an error. We
          // set this to true at the beginning, then set it to false right after
          // calling the function. If the function errors, `didError` will never be
          // set to false. This strategy works even if the browser is flaky and
          // fails to call our global error handler, because it doesn't rely on
          // the error event at all.
          var didError = true; // Create an event handler for our fake event. We will synchronously
          // dispatch our fake event using `dispatchEvent`. Inside the handler, we
          // call the user-provided callback.

          var funcArgs = Array.prototype.slice.call(arguments, 3);

          function callCallback() {
            // We immediately remove the callback from event listeners so that
            // nested `invokeGuardedCallback` calls do not clash. Otherwise, a
            // nested call would trigger the fake event handlers of any call higher
            // in the stack.
            fakeNode.removeEventListener(evtType, callCallback, false);
            func.apply(context, funcArgs);
            didError = false;
          } // Create a global error event handler. We use this to capture the value
          // that was thrown. It's possible that this error handler will fire more
          // than once; for example, if non-React code also calls `dispatchEvent`
          // and a handler for that event throws. We should be resilient to most of
          // those cases. Even if our error event handler fires more than once, the
          // last error event is always used. If the callback actually does error,
          // we know that the last error event is the correct one, because it's not
          // possible for anything else to have happened in between our callback
          // erroring and the code that follows the `dispatchEvent` call below. If
          // the callback doesn't error, but the error event was fired, we know to
          // ignore it because `didError` will be false, as described above.


          var error = void 0; // Use this to track whether the error event is ever called.

          var didSetError = false;
          var isCrossOriginError = false;

          function onError(event) {
            error = event.error;
            didSetError = true;

            if (error === null && event.colno === 0 && event.lineno === 0) {
              isCrossOriginError = true;
            }
          } // Create a fake event type.


          var evtType = 'react-' + (name ? name : 'invokeguardedcallback'); // Attach our event handlers

          window.addEventListener('error', onError);
          fakeNode.addEventListener(evtType, callCallback, false); // Synchronously dispatch our fake event. If the user-provided function
          // errors, it will trigger our global error handler.

          var evt = document.createEvent('Event');
          evt.initEvent(evtType, false, false);
          fakeNode.dispatchEvent(evt);

          if (didError) {
            if (!didSetError) {
              // The callback errored, but the error event never fired.
              error = new Error('An error was thrown inside one of your components, but React ' + "doesn't know what it was. This is likely due to browser " + 'flakiness. React does its best to preserve the "Pause on ' + 'exceptions" behavior of the DevTools, which requires some ' + "DEV-mode only tricks. It's possible that these don't work in " + 'your browser. Try triggering the error in production mode, ' + 'or switching to a modern browser. If you suspect that this is ' + 'actually an issue with React, please file an issue.');
            } else if (isCrossOriginError) {
              error = new Error("A cross-origin error was thrown. React doesn't have access to " + 'the actual error object in development. ' + 'See https://fb.me/react-crossorigin-error for more information.');
            }

            ReactErrorUtils._hasCaughtError = true;
            ReactErrorUtils._caughtError = error;
          } else {
            ReactErrorUtils._hasCaughtError = false;
            ReactErrorUtils._caughtError = null;
          } // Remove our event listeners


          window.removeEventListener('error', onError);
        };

        invokeGuardedCallback$1 = invokeGuardedCallbackDev;
      }
    }

    var _rethrowCaughtError = function _rethrowCaughtError() {
      if (ReactErrorUtils._hasRethrowError) {
        var error = ReactErrorUtils._rethrowError;
        ReactErrorUtils._rethrowError = null;
        ReactErrorUtils._hasRethrowError = false;
        throw error;
      }
    };

    {
      var didWarnUpdateInsideUpdate = false;
    } // Callbacks are not validated until invocation
    // Singly linked-list of updates. When an update is scheduled, it is added to
    // the queue of the current fiber and the work-in-progress fiber. The two queues
    // are separate but they share a persistent structure.
    //
    // During reconciliation, updates are removed from the work-in-progress fiber,
    // but they remain on the current fiber. That ensures that if a work-in-progress
    // is aborted, the aborted updates are recovered by cloning from current.
    //
    // The work-in-progress queue is always a subset of the current queue.
    //
    // When the tree is committed, the work-in-progress becomes the current.

    function createUpdateQueue(baseState) {
      var queue = {
        baseState: baseState,
        expirationTime: NoWork,
        first: null,
        last: null,
        callbackList: null,
        hasForceUpdate: false,
        isInitialized: false
      };
      {
        queue.isProcessing = false;
      }
      return queue;
    }

    function insertUpdateIntoQueue(queue, update) {
      // Append the update to the end of the list.
      if (queue.last === null) {
        // Queue is empty
        queue.first = queue.last = update;
      } else {
        queue.last.next = update;
        queue.last = update;
      }

      if (queue.expirationTime === NoWork || queue.expirationTime > update.expirationTime) {
        queue.expirationTime = update.expirationTime;
      }
    }

    function insertUpdateIntoFiber(fiber, update) {
      // We'll have at least one and at most two distinct update queues.
      var alternateFiber = fiber.alternate;
      var queue1 = fiber.updateQueue;

      if (queue1 === null) {
        // TODO: We don't know what the base state will be until we begin work.
        // It depends on which fiber is the next current. Initialize with an empty
        // base state, then set to the memoizedState when rendering. Not super
        // happy with this approach.
        queue1 = fiber.updateQueue = createUpdateQueue(null);
      }

      var queue2 = void 0;

      if (alternateFiber !== null) {
        queue2 = alternateFiber.updateQueue;

        if (queue2 === null) {
          queue2 = alternateFiber.updateQueue = createUpdateQueue(null);
        }
      } else {
        queue2 = null;
      }

      queue2 = queue2 !== queue1 ? queue2 : null; // Warn if an update is scheduled from inside an updater function.

      {
        if ((queue1.isProcessing || queue2 !== null && queue2.isProcessing) && !didWarnUpdateInsideUpdate) {
          warning(false, 'An update (setState, replaceState, or forceUpdate) was scheduled ' + 'from inside an update function. Update functions should be pure, ' + 'with zero side-effects. Consider using componentDidUpdate or a ' + 'callback.');
          didWarnUpdateInsideUpdate = true;
        }
      } // If there's only one queue, add the update to that queue and exit.

      if (queue2 === null) {
        insertUpdateIntoQueue(queue1, update);
        return;
      } // If either queue is empty, we need to add to both queues.


      if (queue1.last === null || queue2.last === null) {
        insertUpdateIntoQueue(queue1, update);
        insertUpdateIntoQueue(queue2, update);
        return;
      } // If both lists are not empty, the last update is the same for both lists
      // because of structural sharing. So, we should only append to one of
      // the lists.


      insertUpdateIntoQueue(queue1, update); // But we still need to update the `last` pointer of queue2.

      queue2.last = update;
    }

    function getUpdateExpirationTime(fiber) {
      if (fiber.tag !== ClassComponent && fiber.tag !== HostRoot) {
        return NoWork;
      }

      var updateQueue = fiber.updateQueue;

      if (updateQueue === null) {
        return NoWork;
      }

      return updateQueue.expirationTime;
    }

    function getStateFromUpdate(update, instance, prevState, props) {
      var partialState = update.partialState;

      if (typeof partialState === 'function') {
        var updateFn = partialState; // Invoke setState callback an extra time to help detect side-effects.

        if (debugRenderPhaseSideEffects) {
          updateFn.call(instance, prevState, props);
        }

        return updateFn.call(instance, prevState, props);
      } else {
        return partialState;
      }
    }

    function processUpdateQueue(current, workInProgress, queue, instance, props, renderExpirationTime) {
      if (current !== null && current.updateQueue === queue) {
        // We need to create a work-in-progress queue, by cloning the current queue.
        var currentQueue = queue;
        queue = workInProgress.updateQueue = {
          baseState: currentQueue.baseState,
          expirationTime: currentQueue.expirationTime,
          first: currentQueue.first,
          last: currentQueue.last,
          isInitialized: currentQueue.isInitialized,
          // These fields are no longer valid because they were already committed.
          // Reset them.
          callbackList: null,
          hasForceUpdate: false
        };
      }

      {
        // Set this flag so we can warn if setState is called inside the update
        // function of another setState.
        queue.isProcessing = true;
      } // Reset the remaining expiration time. If we skip over any updates, we'll
      // increase this accordingly.

      queue.expirationTime = NoWork; // TODO: We don't know what the base state will be until we begin work.
      // It depends on which fiber is the next current. Initialize with an empty
      // base state, then set to the memoizedState when rendering. Not super
      // happy with this approach.

      var state = void 0;

      if (queue.isInitialized) {
        state = queue.baseState;
      } else {
        state = queue.baseState = workInProgress.memoizedState;
        queue.isInitialized = true;
      }

      var dontMutatePrevState = true;
      var update = queue.first;
      var didSkip = false;

      while (update !== null) {
        var updateExpirationTime = update.expirationTime;

        if (updateExpirationTime > renderExpirationTime) {
          // This update does not have sufficient priority. Skip it.
          var remainingExpirationTime = queue.expirationTime;

          if (remainingExpirationTime === NoWork || remainingExpirationTime > updateExpirationTime) {
            // Update the remaining expiration time.
            queue.expirationTime = updateExpirationTime;
          }

          if (!didSkip) {
            didSkip = true;
            queue.baseState = state;
          } // Continue to the next update.


          update = update.next;
          continue;
        } // This update does have sufficient priority.
        // If no previous updates were skipped, drop this update from the queue by
        // advancing the head of the list.


        if (!didSkip) {
          queue.first = update.next;

          if (queue.first === null) {
            queue.last = null;
          }
        } // Process the update


        var _partialState = void 0;

        if (update.isReplace) {
          state = getStateFromUpdate(update, instance, state, props);
          dontMutatePrevState = true;
        } else {
          _partialState = getStateFromUpdate(update, instance, state, props);

          if (_partialState) {
            if (dontMutatePrevState) {
              // $FlowFixMe: Idk how to type this properly.
              state = _assign({}, state, _partialState);
            } else {
              state = _assign(state, _partialState);
            }

            dontMutatePrevState = false;
          }
        }

        if (update.isForced) {
          queue.hasForceUpdate = true;
        }

        if (update.callback !== null) {
          // Append to list of callbacks.
          var _callbackList = queue.callbackList;

          if (_callbackList === null) {
            _callbackList = queue.callbackList = [];
          }

          _callbackList.push(update);
        }

        update = update.next;
      }

      if (queue.callbackList !== null) {
        workInProgress.effectTag |= Callback;
      } else if (queue.first === null && !queue.hasForceUpdate) {
        // The queue is empty. We can reset it.
        workInProgress.updateQueue = null;
      }

      if (!didSkip) {
        didSkip = true;
        queue.baseState = state;
      }

      {
        // No longer processing.
        queue.isProcessing = false;
      }
      return state;
    }

    function commitCallbacks(queue, context) {
      var callbackList = queue.callbackList;

      if (callbackList === null) {
        return;
      } // Set the list to null to make sure they don't get called more than once.


      queue.callbackList = null;

      for (var i = 0; i < callbackList.length; i++) {
        var update = callbackList[i];
        var _callback = update.callback; // This update might be processed again. Clear the callback so it's only
        // called once.

        update.callback = null;
        !(typeof _callback === 'function') ? invariant(false, 'Invalid argument passed as callback. Expected a function. Instead received: %s', _callback) : void 0;

        _callback.call(context);
      }
    }

    var fakeInternalInstance = {};
    var isArray = Array.isArray;
    {
      var didWarnAboutStateAssignmentForComponent = {};

      var warnOnInvalidCallback = function warnOnInvalidCallback(callback, callerName) {
        warning(callback === null || typeof callback === 'function', '%s(...): Expected the last optional `callback` argument to be a ' + 'function. Instead received: %s.', callerName, callback);
      }; // This is so gross but it's at least non-critical and can be removed if
      // it causes problems. This is meant to give a nicer error message for
      // ReactDOM15.unstable_renderSubtreeIntoContainer(reactDOM16Component,
      // ...)) which otherwise throws a "_processChildContext is not a function"
      // exception.


      Object.defineProperty(fakeInternalInstance, '_processChildContext', {
        enumerable: false,
        value: function value() {
          invariant(false, '_processChildContext is not available in React 16+. This likely means you have multiple copies of React and are attempting to nest a React 15 tree inside a React 16 tree using unstable_renderSubtreeIntoContainer, which isn\'t supported. Try to make sure you have only one copy of React (and ideally, switch to ReactDOM.createPortal).');
        }
      });
      Object.freeze(fakeInternalInstance);
    }

    var ReactFiberClassComponent = function ReactFiberClassComponent(scheduleWork, computeExpirationForFiber, memoizeProps, memoizeState) {
      // Class component state updater
      var updater = {
        isMounted: isMounted,
        enqueueSetState: function enqueueSetState(instance, partialState, callback) {
          var fiber = get(instance);
          callback = callback === undefined ? null : callback;
          {
            warnOnInvalidCallback(callback, 'setState');
          }
          var expirationTime = computeExpirationForFiber(fiber);
          var update = {
            expirationTime: expirationTime,
            partialState: partialState,
            callback: callback,
            isReplace: false,
            isForced: false,
            nextCallback: null,
            next: null
          };
          insertUpdateIntoFiber(fiber, update);
          scheduleWork(fiber, expirationTime);
        },
        enqueueReplaceState: function enqueueReplaceState(instance, state, callback) {
          var fiber = get(instance);
          callback = callback === undefined ? null : callback;
          {
            warnOnInvalidCallback(callback, 'replaceState');
          }
          var expirationTime = computeExpirationForFiber(fiber);
          var update = {
            expirationTime: expirationTime,
            partialState: state,
            callback: callback,
            isReplace: true,
            isForced: false,
            nextCallback: null,
            next: null
          };
          insertUpdateIntoFiber(fiber, update);
          scheduleWork(fiber, expirationTime);
        },
        enqueueForceUpdate: function enqueueForceUpdate(instance, callback) {
          var fiber = get(instance);
          callback = callback === undefined ? null : callback;
          {
            warnOnInvalidCallback(callback, 'forceUpdate');
          }
          var expirationTime = computeExpirationForFiber(fiber);
          var update = {
            expirationTime: expirationTime,
            partialState: null,
            callback: callback,
            isReplace: false,
            isForced: true,
            nextCallback: null,
            next: null
          };
          insertUpdateIntoFiber(fiber, update);
          scheduleWork(fiber, expirationTime);
        }
      };

      function checkShouldComponentUpdate(workInProgress, oldProps, newProps, oldState, newState, newContext) {
        if (oldProps === null || workInProgress.updateQueue !== null && workInProgress.updateQueue.hasForceUpdate) {
          // If the workInProgress already has an Update effect, return true
          return true;
        }

        var instance = workInProgress.stateNode;
        var type = workInProgress.type;

        if (typeof instance.shouldComponentUpdate === 'function') {
          startPhaseTimer(workInProgress, 'shouldComponentUpdate');
          var shouldUpdate = instance.shouldComponentUpdate(newProps, newState, newContext);
          stopPhaseTimer(); // Simulate an async bailout/interruption by invoking lifecycle twice.

          if (debugRenderPhaseSideEffects) {
            instance.shouldComponentUpdate(newProps, newState, newContext);
          }

          {
            warning(shouldUpdate !== undefined, '%s.shouldComponentUpdate(): Returned undefined instead of a ' + 'boolean value. Make sure to return true or false.', getComponentName(workInProgress) || 'Unknown');
          }
          return shouldUpdate;
        }

        if (type.prototype && type.prototype.isPureReactComponent) {
          return !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState);
        }

        return true;
      }

      function checkClassInstance(workInProgress) {
        var instance = workInProgress.stateNode;
        var type = workInProgress.type;
        {
          var name = getComponentName(workInProgress);
          var renderPresent = instance.render;

          if (!renderPresent) {
            if (type.prototype && typeof type.prototype.render === 'function') {
              warning(false, '%s(...): No `render` method found on the returned component ' + 'instance: did you accidentally return an object from the constructor?', name);
            } else {
              warning(false, '%s(...): No `render` method found on the returned component ' + 'instance: you may have forgotten to define `render`.', name);
            }
          }

          var noGetInitialStateOnES6 = !instance.getInitialState || instance.getInitialState.isReactClassApproved || instance.state;
          warning(noGetInitialStateOnES6, 'getInitialState was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Did you mean to define a state property instead?', name);
          var noGetDefaultPropsOnES6 = !instance.getDefaultProps || instance.getDefaultProps.isReactClassApproved;
          warning(noGetDefaultPropsOnES6, 'getDefaultProps was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Use a static property to define defaultProps instead.', name);
          var noInstancePropTypes = !instance.propTypes;
          warning(noInstancePropTypes, 'propTypes was defined as an instance property on %s. Use a static ' + 'property to define propTypes instead.', name);
          var noInstanceContextTypes = !instance.contextTypes;
          warning(noInstanceContextTypes, 'contextTypes was defined as an instance property on %s. Use a static ' + 'property to define contextTypes instead.', name);
          var noComponentShouldUpdate = typeof instance.componentShouldUpdate !== 'function';
          warning(noComponentShouldUpdate, '%s has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.', name);

          if (type.prototype && type.prototype.isPureReactComponent && typeof instance.shouldComponentUpdate !== 'undefined') {
            warning(false, '%s has a method called shouldComponentUpdate(). ' + 'shouldComponentUpdate should not be used when extending React.PureComponent. ' + 'Please extend React.Component if shouldComponentUpdate is used.', getComponentName(workInProgress) || 'A pure component');
          }

          var noComponentDidUnmount = typeof instance.componentDidUnmount !== 'function';
          warning(noComponentDidUnmount, '%s has a method called ' + 'componentDidUnmount(). But there is no such lifecycle method. ' + 'Did you mean componentWillUnmount()?', name);
          var noComponentDidReceiveProps = typeof instance.componentDidReceiveProps !== 'function';
          warning(noComponentDidReceiveProps, '%s has a method called ' + 'componentDidReceiveProps(). But there is no such lifecycle method. ' + 'If you meant to update the state in response to changing props, ' + 'use componentWillReceiveProps(). If you meant to fetch data or ' + 'run side-effects or mutations after React has updated the UI, use componentDidUpdate().', name);
          var noComponentWillRecieveProps = typeof instance.componentWillRecieveProps !== 'function';
          warning(noComponentWillRecieveProps, '%s has a method called ' + 'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?', name);
          var hasMutatedProps = instance.props !== workInProgress.pendingProps;
          warning(instance.props === undefined || !hasMutatedProps, '%s(...): When calling super() in `%s`, make sure to pass ' + "up the same props that your component's constructor was passed.", name, name);
          var noInstanceDefaultProps = !instance.defaultProps;
          warning(noInstanceDefaultProps, 'Setting defaultProps as an instance property on %s is not supported and will be ignored.' + ' Instead, define defaultProps as a static property on %s.', name, name);
        }
        var state = instance.state;

        if (state && (typeof state !== 'object' || isArray(state))) {
          warning(false, '%s.state: must be set to an object or null', getComponentName(workInProgress));
        }

        if (typeof instance.getChildContext === 'function') {
          warning(typeof workInProgress.type.childContextTypes === 'object', '%s.getChildContext(): childContextTypes must be defined in order to ' + 'use getChildContext().', getComponentName(workInProgress));
        }
      }

      function resetInputPointers(workInProgress, instance) {
        instance.props = workInProgress.memoizedProps;
        instance.state = workInProgress.memoizedState;
      }

      function adoptClassInstance(workInProgress, instance) {
        instance.updater = updater;
        workInProgress.stateNode = instance; // The instance needs access to the fiber so that it can schedule updates

        set(instance, workInProgress);
        {
          instance._reactInternalInstance = fakeInternalInstance;
        }
      }

      function constructClassInstance(workInProgress, props) {
        var ctor = workInProgress.type;
        var unmaskedContext = getUnmaskedContext(workInProgress);
        var needsContext = isContextConsumer(workInProgress);
        var context = needsContext ? getMaskedContext(workInProgress, unmaskedContext) : emptyObject;
        var instance = new ctor(props, context);
        adoptClassInstance(workInProgress, instance); // Cache unmasked context so we can avoid recreating masked context unless necessary.
        // ReactFiberContext usually updates this cache but can't for newly-created instances.

        if (needsContext) {
          cacheContext(workInProgress, unmaskedContext, context);
        }

        return instance;
      }

      function callComponentWillMount(workInProgress, instance) {
        startPhaseTimer(workInProgress, 'componentWillMount');
        var oldState = instance.state;
        instance.componentWillMount();
        stopPhaseTimer(); // Simulate an async bailout/interruption by invoking lifecycle twice.

        if (debugRenderPhaseSideEffects) {
          instance.componentWillMount();
        }

        if (oldState !== instance.state) {
          {
            warning(false, '%s.componentWillMount(): Assigning directly to this.state is ' + "deprecated (except inside a component's " + 'constructor). Use setState instead.', getComponentName(workInProgress));
          }
          updater.enqueueReplaceState(instance, instance.state, null);
        }
      }

      function callComponentWillReceiveProps(workInProgress, instance, newProps, newContext) {
        startPhaseTimer(workInProgress, 'componentWillReceiveProps');
        var oldState = instance.state;
        instance.componentWillReceiveProps(newProps, newContext);
        stopPhaseTimer(); // Simulate an async bailout/interruption by invoking lifecycle twice.

        if (debugRenderPhaseSideEffects) {
          instance.componentWillReceiveProps(newProps, newContext);
        }

        if (instance.state !== oldState) {
          {
            var componentName = getComponentName(workInProgress) || 'Component';

            if (!didWarnAboutStateAssignmentForComponent[componentName]) {
              warning(false, '%s.componentWillReceiveProps(): Assigning directly to ' + "this.state is deprecated (except inside a component's " + 'constructor). Use setState instead.', componentName);
              didWarnAboutStateAssignmentForComponent[componentName] = true;
            }
          }
          updater.enqueueReplaceState(instance, instance.state, null);
        }
      } // Invokes the mount life-cycles on a previously never rendered instance.


      function mountClassInstance(workInProgress, renderExpirationTime) {
        var current = workInProgress.alternate;
        {
          checkClassInstance(workInProgress);
        }
        var instance = workInProgress.stateNode;
        var state = instance.state || null;
        var props = workInProgress.pendingProps;
        !props ? invariant(false, 'There must be pending props for an initial mount. This error is likely caused by a bug in React. Please file an issue.') : void 0;
        var unmaskedContext = getUnmaskedContext(workInProgress);
        instance.props = props;
        instance.state = workInProgress.memoizedState = state;
        instance.refs = emptyObject;
        instance.context = getMaskedContext(workInProgress, unmaskedContext);

        if (enableAsyncSubtreeAPI && workInProgress.type != null && workInProgress.type.prototype != null && workInProgress.type.prototype.unstable_isAsyncReactComponent === true) {
          workInProgress.internalContextTag |= AsyncUpdates;
        }

        if (typeof instance.componentWillMount === 'function') {
          callComponentWillMount(workInProgress, instance); // If we had additional state updates during this life-cycle, let's
          // process them now.

          var updateQueue = workInProgress.updateQueue;

          if (updateQueue !== null) {
            instance.state = processUpdateQueue(current, workInProgress, updateQueue, instance, props, renderExpirationTime);
          }
        }

        if (typeof instance.componentDidMount === 'function') {
          workInProgress.effectTag |= Update;
        }
      } // Called on a preexisting class instance. Returns false if a resumed render
      // could be reused.
      // function resumeMountClassInstance(
      //   workInProgress: Fiber,
      //   priorityLevel: PriorityLevel,
      // ): boolean {
      //   const instance = workInProgress.stateNode;
      //   resetInputPointers(workInProgress, instance);
      //   let newState = workInProgress.memoizedState;
      //   let newProps = workInProgress.pendingProps;
      //   if (!newProps) {
      //     // If there isn't any new props, then we'll reuse the memoized props.
      //     // This could be from already completed work.
      //     newProps = workInProgress.memoizedProps;
      //     invariant(
      //       newProps != null,
      //       'There should always be pending or memoized props. This error is ' +
      //         'likely caused by a bug in React. Please file an issue.',
      //     );
      //   }
      //   const newUnmaskedContext = getUnmaskedContext(workInProgress);
      //   const newContext = getMaskedContext(workInProgress, newUnmaskedContext);
      //   const oldContext = instance.context;
      //   const oldProps = workInProgress.memoizedProps;
      //   if (
      //     typeof instance.componentWillReceiveProps === 'function' &&
      //     (oldProps !== newProps || oldContext !== newContext)
      //   ) {
      //     callComponentWillReceiveProps(
      //       workInProgress,
      //       instance,
      //       newProps,
      //       newContext,
      //     );
      //   }
      //   // Process the update queue before calling shouldComponentUpdate
      //   const updateQueue = workInProgress.updateQueue;
      //   if (updateQueue !== null) {
      //     newState = processUpdateQueue(
      //       workInProgress,
      //       updateQueue,
      //       instance,
      //       newState,
      //       newProps,
      //       priorityLevel,
      //     );
      //   }
      //   // TODO: Should we deal with a setState that happened after the last
      //   // componentWillMount and before this componentWillMount? Probably
      //   // unsupported anyway.
      //   if (
      //     !checkShouldComponentUpdate(
      //       workInProgress,
      //       workInProgress.memoizedProps,
      //       newProps,
      //       workInProgress.memoizedState,
      //       newState,
      //       newContext,
      //     )
      //   ) {
      //     // Update the existing instance's state, props, and context pointers even
      //     // though we're bailing out.
      //     instance.props = newProps;
      //     instance.state = newState;
      //     instance.context = newContext;
      //     return false;
      //   }
      //   // Update the input pointers now so that they are correct when we call
      //   // componentWillMount
      //   instance.props = newProps;
      //   instance.state = newState;
      //   instance.context = newContext;
      //   if (typeof instance.componentWillMount === 'function') {
      //     callComponentWillMount(workInProgress, instance);
      //     // componentWillMount may have called setState. Process the update queue.
      //     const newUpdateQueue = workInProgress.updateQueue;
      //     if (newUpdateQueue !== null) {
      //       newState = processUpdateQueue(
      //         workInProgress,
      //         newUpdateQueue,
      //         instance,
      //         newState,
      //         newProps,
      //         priorityLevel,
      //       );
      //     }
      //   }
      //   if (typeof instance.componentDidMount === 'function') {
      //     workInProgress.effectTag |= Update;
      //   }
      //   instance.state = newState;
      //   return true;
      // }
      // Invokes the update life-cycles and returns false if it shouldn't rerender.


      function updateClassInstance(current, workInProgress, renderExpirationTime) {
        var instance = workInProgress.stateNode;
        resetInputPointers(workInProgress, instance);
        var oldProps = workInProgress.memoizedProps;
        var newProps = workInProgress.pendingProps;

        if (!newProps) {
          // If there aren't any new props, then we'll reuse the memoized props.
          // This could be from already completed work.
          newProps = oldProps;
          !(newProps != null) ? invariant(false, 'There should always be pending or memoized props. This error is likely caused by a bug in React. Please file an issue.') : void 0;
        }

        var oldContext = instance.context;
        var newUnmaskedContext = getUnmaskedContext(workInProgress);
        var newContext = getMaskedContext(workInProgress, newUnmaskedContext); // Note: During these life-cycles, instance.props/instance.state are what
        // ever the previously attempted to render - not the "current". However,
        // during componentDidUpdate we pass the "current" props.

        if (typeof instance.componentWillReceiveProps === 'function' && (oldProps !== newProps || oldContext !== newContext)) {
          callComponentWillReceiveProps(workInProgress, instance, newProps, newContext);
        } // Compute the next state using the memoized state and the update queue.


        var oldState = workInProgress.memoizedState; // TODO: Previous state can be null.

        var newState = void 0;

        if (workInProgress.updateQueue !== null) {
          newState = processUpdateQueue(current, workInProgress, workInProgress.updateQueue, instance, newProps, renderExpirationTime);
        } else {
          newState = oldState;
        }

        if (oldProps === newProps && oldState === newState && !hasContextChanged() && !(workInProgress.updateQueue !== null && workInProgress.updateQueue.hasForceUpdate)) {
          // If an update was already in progress, we should schedule an Update
          // effect even though we're bailing out, so that cWU/cDU are called.
          if (typeof instance.componentDidUpdate === 'function') {
            if (oldProps !== current.memoizedProps || oldState !== current.memoizedState) {
              workInProgress.effectTag |= Update;
            }
          }

          return false;
        }

        var shouldUpdate = checkShouldComponentUpdate(workInProgress, oldProps, newProps, oldState, newState, newContext);

        if (shouldUpdate) {
          if (typeof instance.componentWillUpdate === 'function') {
            startPhaseTimer(workInProgress, 'componentWillUpdate');
            instance.componentWillUpdate(newProps, newState, newContext);
            stopPhaseTimer(); // Simulate an async bailout/interruption by invoking lifecycle twice.

            if (debugRenderPhaseSideEffects) {
              instance.componentWillUpdate(newProps, newState, newContext);
            }
          }

          if (typeof instance.componentDidUpdate === 'function') {
            workInProgress.effectTag |= Update;
          }
        } else {
          // If an update was already in progress, we should schedule an Update
          // effect even though we're bailing out, so that cWU/cDU are called.
          if (typeof instance.componentDidUpdate === 'function') {
            if (oldProps !== current.memoizedProps || oldState !== current.memoizedState) {
              workInProgress.effectTag |= Update;
            }
          } // If shouldComponentUpdate returned false, we should still update the
          // memoized props/state to indicate that this work can be reused.


          memoizeProps(workInProgress, newProps);
          memoizeState(workInProgress, newState);
        } // Update the existing instance's state, props, and context pointers even
        // if shouldComponentUpdate returns false.


        instance.props = newProps;
        instance.state = newState;
        instance.context = newContext;
        return shouldUpdate;
      }

      return {
        adoptClassInstance: adoptClassInstance,
        constructClassInstance: constructClassInstance,
        mountClassInstance: mountClassInstance,
        // resumeMountClassInstance,
        updateClassInstance: updateClassInstance
      };
    }; // The Symbol used to tag the ReactElement-like types. If there is no native Symbol
    // nor polyfill, then a plain number is used for performance.


    var hasSymbol = typeof Symbol === 'function' && Symbol['for'];
    var REACT_ELEMENT_TYPE = hasSymbol ? Symbol['for']('react.element') : 0xeac7;
    var REACT_CALL_TYPE = hasSymbol ? Symbol['for']('react.call') : 0xeac8;
    var REACT_RETURN_TYPE = hasSymbol ? Symbol['for']('react.return') : 0xeac9;
    var REACT_PORTAL_TYPE = hasSymbol ? Symbol['for']('react.portal') : 0xeaca;
    var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol['for']('react.fragment') : 0xeacb;
    var MAYBE_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
    var FAUX_ITERATOR_SYMBOL = '@@iterator';

    function getIteratorFn(maybeIterable) {
      if (maybeIterable === null || typeof maybeIterable === 'undefined') {
        return null;
      }

      var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];

      if (typeof maybeIterator === 'function') {
        return maybeIterator;
      }

      return null;
    }

    var getCurrentFiberStackAddendum$1 = ReactDebugCurrentFiber.getCurrentFiberStackAddendum;
    {
      var didWarnAboutMaps = false;
      /**
       * Warn if there's no key explicitly set on dynamic arrays of children or
       * object keys are not valid. This allows us to keep track of children between
       * updates.
       */

      var ownerHasKeyUseWarning = {};
      var ownerHasFunctionTypeWarning = {};

      var warnForMissingKey = function warnForMissingKey(child) {
        if (child === null || typeof child !== 'object') {
          return;
        }

        if (!child._store || child._store.validated || child.key != null) {
          return;
        }

        !(typeof child._store === 'object') ? invariant(false, 'React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue.') : void 0;
        child._store.validated = true;
        var currentComponentErrorInfo = 'Each child in an array or iterator should have a unique ' + '"key" prop. See https://fb.me/react-warning-keys for ' + 'more information.' + (getCurrentFiberStackAddendum$1() || '');

        if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
          return;
        }

        ownerHasKeyUseWarning[currentComponentErrorInfo] = true;
        warning(false, 'Each child in an array or iterator should have a unique ' + '"key" prop. See https://fb.me/react-warning-keys for ' + 'more information.%s', getCurrentFiberStackAddendum$1());
      };
    }
    var isArray$1 = Array.isArray;

    function coerceRef(current, element) {
      var mixedRef = element.ref;

      if (mixedRef !== null && typeof mixedRef !== 'function') {
        if (element._owner) {
          var owner = element._owner;
          var inst = void 0;

          if (owner) {
            var ownerFiber = owner;
            !(ownerFiber.tag === ClassComponent) ? invariant(false, 'Stateless function components cannot have refs.') : void 0;
            inst = ownerFiber.stateNode;
          }

          !inst ? invariant(false, 'Missing owner for string ref %s. This error is likely caused by a bug in React. Please file an issue.', mixedRef) : void 0;
          var stringRef = '' + mixedRef; // Check if previous string ref matches new string ref

          if (current !== null && current.ref !== null && current.ref._stringRef === stringRef) {
            return current.ref;
          }

          var ref = function ref(value) {
            var refs = inst.refs === emptyObject ? inst.refs = {} : inst.refs;

            if (value === null) {
              delete refs[stringRef];
            } else {
              refs[stringRef] = value;
            }
          };

          ref._stringRef = stringRef;
          return ref;
        } else {
          !(typeof mixedRef === 'string') ? invariant(false, 'Expected ref to be a function or a string.') : void 0;
          !element._owner ? invariant(false, 'Element ref was specified as a string (%s) but no owner was set. You may have multiple copies of React loaded. (details: https://fb.me/react-refs-must-have-owner).', mixedRef) : void 0;
        }
      }

      return mixedRef;
    }

    function throwOnInvalidObjectType(returnFiber, newChild) {
      if (returnFiber.type !== 'textarea') {
        var addendum = '';
        {
          addendum = ' If you meant to render a collection of children, use an array ' + 'instead.' + (getCurrentFiberStackAddendum$1() || '');
        }
        invariant(false, 'Objects are not valid as a React child (found: %s).%s', Object.prototype.toString.call(newChild) === '[object Object]' ? 'object with keys {' + Object.keys(newChild).join(', ') + '}' : newChild, addendum);
      }
    }

    function warnOnFunctionType() {
      var currentComponentErrorInfo = 'Functions are not valid as a React child. This may happen if ' + 'you return a Component instead of <Component /> from render. ' + 'Or maybe you meant to call this function rather than return it.' + (getCurrentFiberStackAddendum$1() || '');

      if (ownerHasFunctionTypeWarning[currentComponentErrorInfo]) {
        return;
      }

      ownerHasFunctionTypeWarning[currentComponentErrorInfo] = true;
      warning(false, 'Functions are not valid as a React child. This may happen if ' + 'you return a Component instead of <Component /> from render. ' + 'Or maybe you meant to call this function rather than return it.%s', getCurrentFiberStackAddendum$1() || '');
    } // This wrapper function exists because I expect to clone the code in each path
    // to be able to optimize each path individually by branching early. This needs
    // a compiler or we can do it manually. Helpers that don't need this branching
    // live outside of this function.


    function ChildReconciler(shouldTrackSideEffects) {
      function deleteChild(returnFiber, childToDelete) {
        if (!shouldTrackSideEffects) {
          // Noop.
          return;
        } // Deletions are added in reversed order so we add it to the front.
        // At this point, the return fiber's effect list is empty except for
        // deletions, so we can just append the deletion to the list. The remaining
        // effects aren't added until the complete phase. Once we implement
        // resuming, this may not be true.


        var last = returnFiber.lastEffect;

        if (last !== null) {
          last.nextEffect = childToDelete;
          returnFiber.lastEffect = childToDelete;
        } else {
          returnFiber.firstEffect = returnFiber.lastEffect = childToDelete;
        }

        childToDelete.nextEffect = null;
        childToDelete.effectTag = Deletion;
      }

      function deleteRemainingChildren(returnFiber, currentFirstChild) {
        if (!shouldTrackSideEffects) {
          // Noop.
          return null;
        } // TODO: For the shouldClone case, this could be micro-optimized a bit by
        // assuming that after the first child we've already added everything.


        var childToDelete = currentFirstChild;

        while (childToDelete !== null) {
          deleteChild(returnFiber, childToDelete);
          childToDelete = childToDelete.sibling;
        }

        return null;
      }

      function mapRemainingChildren(returnFiber, currentFirstChild) {
        // Add the remaining children to a temporary map so that we can find them by
        // keys quickly. Implicit (null) keys get added to this set with their index
        var existingChildren = new Map();
        var existingChild = currentFirstChild;

        while (existingChild !== null) {
          if (existingChild.key !== null) {
            existingChildren.set(existingChild.key, existingChild);
          } else {
            existingChildren.set(existingChild.index, existingChild);
          }

          existingChild = existingChild.sibling;
        }

        return existingChildren;
      }

      function useFiber(fiber, pendingProps, expirationTime) {
        // We currently set sibling to null and index to 0 here because it is easy
        // to forget to do before returning it. E.g. for the single child case.
        var clone = createWorkInProgress(fiber, pendingProps, expirationTime);
        clone.index = 0;
        clone.sibling = null;
        return clone;
      }

      function placeChild(newFiber, lastPlacedIndex, newIndex) {
        newFiber.index = newIndex;

        if (!shouldTrackSideEffects) {
          // Noop.
          return lastPlacedIndex;
        }

        var current = newFiber.alternate;

        if (current !== null) {
          var oldIndex = current.index;

          if (oldIndex < lastPlacedIndex) {
            // This is a move.
            newFiber.effectTag = Placement;
            return lastPlacedIndex;
          } else {
            // This item can stay in place.
            return oldIndex;
          }
        } else {
          // This is an insertion.
          newFiber.effectTag = Placement;
          return lastPlacedIndex;
        }
      }

      function placeSingleChild(newFiber) {
        // This is simpler for the single child case. We only need to do a
        // placement for inserting new children.
        if (shouldTrackSideEffects && newFiber.alternate === null) {
          newFiber.effectTag = Placement;
        }

        return newFiber;
      }

      function updateTextNode(returnFiber, current, textContent, expirationTime) {
        if (current === null || current.tag !== HostText) {
          // Insert
          var created = createFiberFromText(textContent, returnFiber.internalContextTag, expirationTime);
          created['return'] = returnFiber;
          return created;
        } else {
          // Update
          var existing = useFiber(current, textContent, expirationTime);
          existing['return'] = returnFiber;
          return existing;
        }
      }

      function updateElement(returnFiber, current, element, expirationTime) {
        if (current !== null && current.type === element.type) {
          // Move based on index
          var existing = useFiber(current, element.props, expirationTime);
          existing.ref = coerceRef(current, element);
          existing['return'] = returnFiber;
          {
            existing._debugSource = element._source;
            existing._debugOwner = element._owner;
          }
          return existing;
        } else {
          // Insert
          var created = createFiberFromElement(element, returnFiber.internalContextTag, expirationTime);
          created.ref = coerceRef(current, element);
          created['return'] = returnFiber;
          return created;
        }
      }

      function updateCall(returnFiber, current, call, expirationTime) {
        // TODO: Should this also compare handler to determine whether to reuse?
        if (current === null || current.tag !== CallComponent) {
          // Insert
          var created = createFiberFromCall(call, returnFiber.internalContextTag, expirationTime);
          created['return'] = returnFiber;
          return created;
        } else {
          // Move based on index
          var existing = useFiber(current, call, expirationTime);
          existing['return'] = returnFiber;
          return existing;
        }
      }

      function updateReturn(returnFiber, current, returnNode, expirationTime) {
        if (current === null || current.tag !== ReturnComponent) {
          // Insert
          var created = createFiberFromReturn(returnNode, returnFiber.internalContextTag, expirationTime);
          created.type = returnNode.value;
          created['return'] = returnFiber;
          return created;
        } else {
          // Move based on index
          var existing = useFiber(current, null, expirationTime);
          existing.type = returnNode.value;
          existing['return'] = returnFiber;
          return existing;
        }
      }

      function updatePortal(returnFiber, current, portal, expirationTime) {
        if (current === null || current.tag !== HostPortal || current.stateNode.containerInfo !== portal.containerInfo || current.stateNode.implementation !== portal.implementation) {
          // Insert
          var created = createFiberFromPortal(portal, returnFiber.internalContextTag, expirationTime);
          created['return'] = returnFiber;
          return created;
        } else {
          // Update
          var existing = useFiber(current, portal.children || [], expirationTime);
          existing['return'] = returnFiber;
          return existing;
        }
      }

      function updateFragment(returnFiber, current, fragment, expirationTime, key) {
        if (current === null || current.tag !== Fragment) {
          // Insert
          var created = createFiberFromFragment(fragment, returnFiber.internalContextTag, expirationTime, key);
          created['return'] = returnFiber;
          return created;
        } else {
          // Update
          var existing = useFiber(current, fragment, expirationTime);
          existing['return'] = returnFiber;
          return existing;
        }
      }

      function createChild(returnFiber, newChild, expirationTime) {
        if (typeof newChild === 'string' || typeof newChild === 'number') {
          // Text nodes don't have keys. If the previous node is implicitly keyed
          // we can continue to replace it without aborting even if it is not a text
          // node.
          var created = createFiberFromText('' + newChild, returnFiber.internalContextTag, expirationTime);
          created['return'] = returnFiber;
          return created;
        }

        if (typeof newChild === 'object' && newChild !== null) {
          switch (newChild.$$typeof) {
            case REACT_ELEMENT_TYPE:
              {
                if (newChild.type === REACT_FRAGMENT_TYPE) {
                  var _created = createFiberFromFragment(newChild.props.children, returnFiber.internalContextTag, expirationTime, newChild.key);

                  _created['return'] = returnFiber;
                  return _created;
                } else {
                  var _created2 = createFiberFromElement(newChild, returnFiber.internalContextTag, expirationTime);

                  _created2.ref = coerceRef(null, newChild);
                  _created2['return'] = returnFiber;
                  return _created2;
                }
              }

            case REACT_CALL_TYPE:
              {
                var _created3 = createFiberFromCall(newChild, returnFiber.internalContextTag, expirationTime);

                _created3['return'] = returnFiber;
                return _created3;
              }

            case REACT_RETURN_TYPE:
              {
                var _created4 = createFiberFromReturn(newChild, returnFiber.internalContextTag, expirationTime);

                _created4.type = newChild.value;
                _created4['return'] = returnFiber;
                return _created4;
              }

            case REACT_PORTAL_TYPE:
              {
                var _created5 = createFiberFromPortal(newChild, returnFiber.internalContextTag, expirationTime);

                _created5['return'] = returnFiber;
                return _created5;
              }
          }

          if (isArray$1(newChild) || getIteratorFn(newChild)) {
            var _created6 = createFiberFromFragment(newChild, returnFiber.internalContextTag, expirationTime, null);

            _created6['return'] = returnFiber;
            return _created6;
          }

          throwOnInvalidObjectType(returnFiber, newChild);
        }

        {
          if (typeof newChild === 'function') {
            warnOnFunctionType();
          }
        }
        return null;
      }

      function updateSlot(returnFiber, oldFiber, newChild, expirationTime) {
        // Update the fiber if the keys match, otherwise return null.
        var key = oldFiber !== null ? oldFiber.key : null;

        if (typeof newChild === 'string' || typeof newChild === 'number') {
          // Text nodes don't have keys. If the previous node is implicitly keyed
          // we can continue to replace it without aborting even if it is not a text
          // node.
          if (key !== null) {
            return null;
          }

          return updateTextNode(returnFiber, oldFiber, '' + newChild, expirationTime);
        }

        if (typeof newChild === 'object' && newChild !== null) {
          switch (newChild.$$typeof) {
            case REACT_ELEMENT_TYPE:
              {
                if (newChild.key === key) {
                  if (newChild.type === REACT_FRAGMENT_TYPE) {
                    return updateFragment(returnFiber, oldFiber, newChild.props.children, expirationTime, key);
                  }

                  return updateElement(returnFiber, oldFiber, newChild, expirationTime);
                } else {
                  return null;
                }
              }

            case REACT_CALL_TYPE:
              {
                if (newChild.key === key) {
                  return updateCall(returnFiber, oldFiber, newChild, expirationTime);
                } else {
                  return null;
                }
              }

            case REACT_RETURN_TYPE:
              {
                // Returns don't have keys. If the previous node is implicitly keyed
                // we can continue to replace it without aborting even if it is not a
                // yield.
                if (key === null) {
                  return updateReturn(returnFiber, oldFiber, newChild, expirationTime);
                } else {
                  return null;
                }
              }

            case REACT_PORTAL_TYPE:
              {
                if (newChild.key === key) {
                  return updatePortal(returnFiber, oldFiber, newChild, expirationTime);
                } else {
                  return null;
                }
              }
          }

          if (isArray$1(newChild) || getIteratorFn(newChild)) {
            if (key !== null) {
              return null;
            }

            return updateFragment(returnFiber, oldFiber, newChild, expirationTime, null);
          }

          throwOnInvalidObjectType(returnFiber, newChild);
        }

        {
          if (typeof newChild === 'function') {
            warnOnFunctionType();
          }
        }
        return null;
      }

      function updateFromMap(existingChildren, returnFiber, newIdx, newChild, expirationTime) {
        if (typeof newChild === 'string' || typeof newChild === 'number') {
          // Text nodes don't have keys, so we neither have to check the old nor
          // new node for the key. If both are text nodes, they match.
          var matchedFiber = existingChildren.get(newIdx) || null;
          return updateTextNode(returnFiber, matchedFiber, '' + newChild, expirationTime);
        }

        if (typeof newChild === 'object' && newChild !== null) {
          switch (newChild.$$typeof) {
            case REACT_ELEMENT_TYPE:
              {
                var _matchedFiber = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;

                if (newChild.type === REACT_FRAGMENT_TYPE) {
                  return updateFragment(returnFiber, _matchedFiber, newChild.props.children, expirationTime, newChild.key);
                }

                return updateElement(returnFiber, _matchedFiber, newChild, expirationTime);
              }

            case REACT_CALL_TYPE:
              {
                var _matchedFiber2 = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;

                return updateCall(returnFiber, _matchedFiber2, newChild, expirationTime);
              }

            case REACT_RETURN_TYPE:
              {
                // Returns don't have keys, so we neither have to check the old nor
                // new node for the key. If both are returns, they match.
                var _matchedFiber3 = existingChildren.get(newIdx) || null;

                return updateReturn(returnFiber, _matchedFiber3, newChild, expirationTime);
              }

            case REACT_PORTAL_TYPE:
              {
                var _matchedFiber4 = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;

                return updatePortal(returnFiber, _matchedFiber4, newChild, expirationTime);
              }
          }

          if (isArray$1(newChild) || getIteratorFn(newChild)) {
            var _matchedFiber5 = existingChildren.get(newIdx) || null;

            return updateFragment(returnFiber, _matchedFiber5, newChild, expirationTime, null);
          }

          throwOnInvalidObjectType(returnFiber, newChild);
        }

        {
          if (typeof newChild === 'function') {
            warnOnFunctionType();
          }
        }
        return null;
      }
      /**
       * Warns if there is a duplicate or missing key
       */


      function warnOnInvalidKey(child, knownKeys) {
        {
          if (typeof child !== 'object' || child === null) {
            return knownKeys;
          }

          switch (child.$$typeof) {
            case REACT_ELEMENT_TYPE:
            case REACT_CALL_TYPE:
            case REACT_PORTAL_TYPE:
              warnForMissingKey(child);
              var key = child.key;

              if (typeof key !== 'string') {
                break;
              }

              if (knownKeys === null) {
                knownKeys = new Set();
                knownKeys.add(key);
                break;
              }

              if (!knownKeys.has(key)) {
                knownKeys.add(key);
                break;
              }

              warning(false, 'Encountered two children with the same key, `%s`. ' + 'Keys should be unique so that components maintain their identity ' + 'across updates. Non-unique keys may cause children to be ' + 'duplicated and/or omitted  the behavior is unsupported and ' + 'could change in a future version.%s', key, getCurrentFiberStackAddendum$1());
              break;

            default:
              break;
          }
        }
        return knownKeys;
      }

      function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, expirationTime) {
        // This algorithm can't optimize by searching from boths ends since we
        // don't have backpointers on fibers. I'm trying to see how far we can get
        // with that model. If it ends up not being worth the tradeoffs, we can
        // add it later.
        // Even with a two ended optimization, we'd want to optimize for the case
        // where there are few changes and brute force the comparison instead of
        // going for the Map. It'd like to explore hitting that path first in
        // forward-only mode and only go for the Map once we notice that we need
        // lots of look ahead. This doesn't handle reversal as well as two ended
        // search but that's unusual. Besides, for the two ended optimization to
        // work on Iterables, we'd need to copy the whole set.
        // In this first iteration, we'll just live with hitting the bad case
        // (adding everything to a Map) in for every insert/move.
        // If you change this code, also update reconcileChildrenIterator() which
        // uses the same algorithm.
        {
          // First, validate keys.
          var knownKeys = null;

          for (var i = 0; i < newChildren.length; i++) {
            var child = newChildren[i];
            knownKeys = warnOnInvalidKey(child, knownKeys);
          }
        }
        var resultingFirstChild = null;
        var previousNewFiber = null;
        var oldFiber = currentFirstChild;
        var lastPlacedIndex = 0;
        var newIdx = 0;
        var nextOldFiber = null;

        for (; oldFiber !== null && newIdx < newChildren.length; newIdx++) {
          if (oldFiber.index > newIdx) {
            nextOldFiber = oldFiber;
            oldFiber = null;
          } else {
            nextOldFiber = oldFiber.sibling;
          }

          var newFiber = updateSlot(returnFiber, oldFiber, newChildren[newIdx], expirationTime);

          if (newFiber === null) {
            // TODO: This breaks on empty slots like null children. That's
            // unfortunate because it triggers the slow path all the time. We need
            // a better way to communicate whether this was a miss or null,
            // boolean, undefined, etc.
            if (oldFiber === null) {
              oldFiber = nextOldFiber;
            }

            break;
          }

          if (shouldTrackSideEffects) {
            if (oldFiber && newFiber.alternate === null) {
              // We matched the slot, but we didn't reuse the existing fiber, so we
              // need to delete the existing child.
              deleteChild(returnFiber, oldFiber);
            }
          }

          lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);

          if (previousNewFiber === null) {
            // TODO: Move out of the loop. This only happens for the first run.
            resultingFirstChild = newFiber;
          } else {
            // TODO: Defer siblings if we're not at the right index for this slot.
            // I.e. if we had null values before, then we want to defer this
            // for each null value. However, we also don't want to call updateSlot
            // with the previous one.
            previousNewFiber.sibling = newFiber;
          }

          previousNewFiber = newFiber;
          oldFiber = nextOldFiber;
        }

        if (newIdx === newChildren.length) {
          // We've reached the end of the new children. We can delete the rest.
          deleteRemainingChildren(returnFiber, oldFiber);
          return resultingFirstChild;
        }

        if (oldFiber === null) {
          // If we don't have any more existing children we can choose a fast path
          // since the rest will all be insertions.
          for (; newIdx < newChildren.length; newIdx++) {
            var _newFiber = createChild(returnFiber, newChildren[newIdx], expirationTime);

            if (!_newFiber) {
              continue;
            }

            lastPlacedIndex = placeChild(_newFiber, lastPlacedIndex, newIdx);

            if (previousNewFiber === null) {
              // TODO: Move out of the loop. This only happens for the first run.
              resultingFirstChild = _newFiber;
            } else {
              previousNewFiber.sibling = _newFiber;
            }

            previousNewFiber = _newFiber;
          }

          return resultingFirstChild;
        } // Add all children to a key map for quick lookups.


        var existingChildren = mapRemainingChildren(returnFiber, oldFiber); // Keep scanning and use the map to restore deleted items as moves.

        for (; newIdx < newChildren.length; newIdx++) {
          var _newFiber2 = updateFromMap(existingChildren, returnFiber, newIdx, newChildren[newIdx], expirationTime);

          if (_newFiber2) {
            if (shouldTrackSideEffects) {
              if (_newFiber2.alternate !== null) {
                // The new fiber is a work in progress, but if there exists a
                // current, that means that we reused the fiber. We need to delete
                // it from the child list so that we don't add it to the deletion
                // list.
                existingChildren['delete'](_newFiber2.key === null ? newIdx : _newFiber2.key);
              }
            }

            lastPlacedIndex = placeChild(_newFiber2, lastPlacedIndex, newIdx);

            if (previousNewFiber === null) {
              resultingFirstChild = _newFiber2;
            } else {
              previousNewFiber.sibling = _newFiber2;
            }

            previousNewFiber = _newFiber2;
          }
        }

        if (shouldTrackSideEffects) {
          // Any existing children that weren't consumed above were deleted. We need
          // to add them to the deletion list.
          existingChildren.forEach(function (child) {
            return deleteChild(returnFiber, child);
          });
        }

        return resultingFirstChild;
      }

      function reconcileChildrenIterator(returnFiber, currentFirstChild, newChildrenIterable, expirationTime) {
        // This is the same implementation as reconcileChildrenArray(),
        // but using the iterator instead.
        var iteratorFn = getIteratorFn(newChildrenIterable);
        !(typeof iteratorFn === 'function') ? invariant(false, 'An object is not an iterable. This error is likely caused by a bug in React. Please file an issue.') : void 0;
        {
          // Warn about using Maps as children
          if (typeof newChildrenIterable.entries === 'function') {
            var possibleMap = newChildrenIterable;

            if (possibleMap.entries === iteratorFn) {
              warning(didWarnAboutMaps, 'Using Maps as children is unsupported and will likely yield ' + 'unexpected results. Convert it to a sequence/iterable of keyed ' + 'ReactElements instead.%s', getCurrentFiberStackAddendum$1());
              didWarnAboutMaps = true;
            }
          } // First, validate keys.
          // We'll get a different iterator later for the main pass.


          var _newChildren = iteratorFn.call(newChildrenIterable);

          if (_newChildren) {
            var knownKeys = null;

            var _step = _newChildren.next();

            for (; !_step.done; _step = _newChildren.next()) {
              var child = _step.value;
              knownKeys = warnOnInvalidKey(child, knownKeys);
            }
          }
        }
        var newChildren = iteratorFn.call(newChildrenIterable);
        !(newChildren != null) ? invariant(false, 'An iterable object provided no iterator.') : void 0;
        var resultingFirstChild = null;
        var previousNewFiber = null;
        var oldFiber = currentFirstChild;
        var lastPlacedIndex = 0;
        var newIdx = 0;
        var nextOldFiber = null;
        var step = newChildren.next();

        for (; oldFiber !== null && !step.done; newIdx++, step = newChildren.next()) {
          if (oldFiber.index > newIdx) {
            nextOldFiber = oldFiber;
            oldFiber = null;
          } else {
            nextOldFiber = oldFiber.sibling;
          }

          var newFiber = updateSlot(returnFiber, oldFiber, step.value, expirationTime);

          if (newFiber === null) {
            // TODO: This breaks on empty slots like null children. That's
            // unfortunate because it triggers the slow path all the time. We need
            // a better way to communicate whether this was a miss or null,
            // boolean, undefined, etc.
            if (!oldFiber) {
              oldFiber = nextOldFiber;
            }

            break;
          }

          if (shouldTrackSideEffects) {
            if (oldFiber && newFiber.alternate === null) {
              // We matched the slot, but we didn't reuse the existing fiber, so we
              // need to delete the existing child.
              deleteChild(returnFiber, oldFiber);
            }
          }

          lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);

          if (previousNewFiber === null) {
            // TODO: Move out of the loop. This only happens for the first run.
            resultingFirstChild = newFiber;
          } else {
            // TODO: Defer siblings if we're not at the right index for this slot.
            // I.e. if we had null values before, then we want to defer this
            // for each null value. However, we also don't want to call updateSlot
            // with the previous one.
            previousNewFiber.sibling = newFiber;
          }

          previousNewFiber = newFiber;
          oldFiber = nextOldFiber;
        }

        if (step.done) {
          // We've reached the end of the new children. We can delete the rest.
          deleteRemainingChildren(returnFiber, oldFiber);
          return resultingFirstChild;
        }

        if (oldFiber === null) {
          // If we don't have any more existing children we can choose a fast path
          // since the rest will all be insertions.
          for (; !step.done; newIdx++, step = newChildren.next()) {
            var _newFiber3 = createChild(returnFiber, step.value, expirationTime);

            if (_newFiber3 === null) {
              continue;
            }

            lastPlacedIndex = placeChild(_newFiber3, lastPlacedIndex, newIdx);

            if (previousNewFiber === null) {
              // TODO: Move out of the loop. This only happens for the first run.
              resultingFirstChild = _newFiber3;
            } else {
              previousNewFiber.sibling = _newFiber3;
            }

            previousNewFiber = _newFiber3;
          }

          return resultingFirstChild;
        } // Add all children to a key map for quick lookups.


        var existingChildren = mapRemainingChildren(returnFiber, oldFiber); // Keep scanning and use the map to restore deleted items as moves.

        for (; !step.done; newIdx++, step = newChildren.next()) {
          var _newFiber4 = updateFromMap(existingChildren, returnFiber, newIdx, step.value, expirationTime);

          if (_newFiber4 !== null) {
            if (shouldTrackSideEffects) {
              if (_newFiber4.alternate !== null) {
                // The new fiber is a work in progress, but if there exists a
                // current, that means that we reused the fiber. We need to delete
                // it from the child list so that we don't add it to the deletion
                // list.
                existingChildren['delete'](_newFiber4.key === null ? newIdx : _newFiber4.key);
              }
            }

            lastPlacedIndex = placeChild(_newFiber4, lastPlacedIndex, newIdx);

            if (previousNewFiber === null) {
              resultingFirstChild = _newFiber4;
            } else {
              previousNewFiber.sibling = _newFiber4;
            }

            previousNewFiber = _newFiber4;
          }
        }

        if (shouldTrackSideEffects) {
          // Any existing children that weren't consumed above were deleted. We need
          // to add them to the deletion list.
          existingChildren.forEach(function (child) {
            return deleteChild(returnFiber, child);
          });
        }

        return resultingFirstChild;
      }

      function reconcileSingleTextNode(returnFiber, currentFirstChild, textContent, expirationTime) {
        // There's no need to check for keys on text nodes since we don't have a
        // way to define them.
        if (currentFirstChild !== null && currentFirstChild.tag === HostText) {
          // We already have an existing node so let's just update it and delete
          // the rest.
          deleteRemainingChildren(returnFiber, currentFirstChild.sibling);
          var existing = useFiber(currentFirstChild, textContent, expirationTime);
          existing['return'] = returnFiber;
          return existing;
        } // The existing first child is not a text node so we need to create one
        // and delete the existing ones.


        deleteRemainingChildren(returnFiber, currentFirstChild);
        var created = createFiberFromText(textContent, returnFiber.internalContextTag, expirationTime);
        created['return'] = returnFiber;
        return created;
      }

      function reconcileSingleElement(returnFiber, currentFirstChild, element, expirationTime) {
        var key = element.key;
        var child = currentFirstChild;

        while (child !== null) {
          // TODO: If key === null and child.key === null, then this only applies to
          // the first item in the list.
          if (child.key === key) {
            if (child.tag === Fragment ? element.type === REACT_FRAGMENT_TYPE : child.type === element.type) {
              deleteRemainingChildren(returnFiber, child.sibling);
              var existing = useFiber(child, element.type === REACT_FRAGMENT_TYPE ? element.props.children : element.props, expirationTime);
              existing.ref = coerceRef(child, element);
              existing['return'] = returnFiber;
              {
                existing._debugSource = element._source;
                existing._debugOwner = element._owner;
              }
              return existing;
            } else {
              deleteRemainingChildren(returnFiber, child);
              break;
            }
          } else {
            deleteChild(returnFiber, child);
          }

          child = child.sibling;
        }

        if (element.type === REACT_FRAGMENT_TYPE) {
          var created = createFiberFromFragment(element.props.children, returnFiber.internalContextTag, expirationTime, element.key);
          created['return'] = returnFiber;
          return created;
        } else {
          var _created7 = createFiberFromElement(element, returnFiber.internalContextTag, expirationTime);

          _created7.ref = coerceRef(currentFirstChild, element);
          _created7['return'] = returnFiber;
          return _created7;
        }
      }

      function reconcileSingleCall(returnFiber, currentFirstChild, call, expirationTime) {
        var key = call.key;
        var child = currentFirstChild;

        while (child !== null) {
          // TODO: If key === null and child.key === null, then this only applies to
          // the first item in the list.
          if (child.key === key) {
            if (child.tag === CallComponent) {
              deleteRemainingChildren(returnFiber, child.sibling);
              var existing = useFiber(child, call, expirationTime);
              existing['return'] = returnFiber;
              return existing;
            } else {
              deleteRemainingChildren(returnFiber, child);
              break;
            }
          } else {
            deleteChild(returnFiber, child);
          }

          child = child.sibling;
        }

        var created = createFiberFromCall(call, returnFiber.internalContextTag, expirationTime);
        created['return'] = returnFiber;
        return created;
      }

      function reconcileSingleReturn(returnFiber, currentFirstChild, returnNode, expirationTime) {
        // There's no need to check for keys on yields since they're stateless.
        var child = currentFirstChild;

        if (child !== null) {
          if (child.tag === ReturnComponent) {
            deleteRemainingChildren(returnFiber, child.sibling);
            var existing = useFiber(child, null, expirationTime);
            existing.type = returnNode.value;
            existing['return'] = returnFiber;
            return existing;
          } else {
            deleteRemainingChildren(returnFiber, child);
          }
        }

        var created = createFiberFromReturn(returnNode, returnFiber.internalContextTag, expirationTime);
        created.type = returnNode.value;
        created['return'] = returnFiber;
        return created;
      }

      function reconcileSinglePortal(returnFiber, currentFirstChild, portal, expirationTime) {
        var key = portal.key;
        var child = currentFirstChild;

        while (child !== null) {
          // TODO: If key === null and child.key === null, then this only applies to
          // the first item in the list.
          if (child.key === key) {
            if (child.tag === HostPortal && child.stateNode.containerInfo === portal.containerInfo && child.stateNode.implementation === portal.implementation) {
              deleteRemainingChildren(returnFiber, child.sibling);
              var existing = useFiber(child, portal.children || [], expirationTime);
              existing['return'] = returnFiber;
              return existing;
            } else {
              deleteRemainingChildren(returnFiber, child);
              break;
            }
          } else {
            deleteChild(returnFiber, child);
          }

          child = child.sibling;
        }

        var created = createFiberFromPortal(portal, returnFiber.internalContextTag, expirationTime);
        created['return'] = returnFiber;
        return created;
      } // This API will tag the children with the side-effect of the reconciliation
      // itself. They will be added to the side-effect list as we pass through the
      // children and the parent.


      function reconcileChildFibers(returnFiber, currentFirstChild, newChild, expirationTime) {
        // This function is not recursive.
        // If the top level item is an array, we treat it as a set of children,
        // not as a fragment. Nested arrays on the other hand will be treated as
        // fragment nodes. Recursion happens at the normal flow.
        // Handle top level unkeyed fragments as if they were arrays.
        // This leads to an ambiguity between <>{[...]}</> and <>...</>.
        // We treat the ambiguous cases above the same.
        if (typeof newChild === 'object' && newChild !== null && newChild.type === REACT_FRAGMENT_TYPE && newChild.key === null) {
          newChild = newChild.props.children;
        } // Handle object types


        var isObject = typeof newChild === 'object' && newChild !== null;

        if (isObject) {
          switch (newChild.$$typeof) {
            case REACT_ELEMENT_TYPE:
              return placeSingleChild(reconcileSingleElement(returnFiber, currentFirstChild, newChild, expirationTime));

            case REACT_CALL_TYPE:
              return placeSingleChild(reconcileSingleCall(returnFiber, currentFirstChild, newChild, expirationTime));

            case REACT_RETURN_TYPE:
              return placeSingleChild(reconcileSingleReturn(returnFiber, currentFirstChild, newChild, expirationTime));

            case REACT_PORTAL_TYPE:
              return placeSingleChild(reconcileSinglePortal(returnFiber, currentFirstChild, newChild, expirationTime));
          }
        }

        if (typeof newChild === 'string' || typeof newChild === 'number') {
          return placeSingleChild(reconcileSingleTextNode(returnFiber, currentFirstChild, '' + newChild, expirationTime));
        }

        if (isArray$1(newChild)) {
          return reconcileChildrenArray(returnFiber, currentFirstChild, newChild, expirationTime);
        }

        if (getIteratorFn(newChild)) {
          return reconcileChildrenIterator(returnFiber, currentFirstChild, newChild, expirationTime);
        }

        if (isObject) {
          throwOnInvalidObjectType(returnFiber, newChild);
        }

        {
          if (typeof newChild === 'function') {
            warnOnFunctionType();
          }
        }

        if (typeof newChild === 'undefined') {
          // If the new child is undefined, and the return fiber is a composite
          // component, throw an error. If Fiber return types are disabled,
          // we already threw above.
          switch (returnFiber.tag) {
            case ClassComponent:
              {
                {
                  var instance = returnFiber.stateNode;

                  if (instance.render._isMockFunction) {
                    // We allow auto-mocks to proceed as if they're returning null.
                    break;
                  }
                }
              }
            // Intentionally fall through to the next case, which handles both
            // functions and classes
            // eslint-disable-next-lined no-fallthrough

            case FunctionalComponent:
              {
                var Component = returnFiber.type;
                invariant(false, '%s(...): Nothing was returned from render. This usually means a return statement is missing. Or, to render nothing, return null.', Component.displayName || Component.name || 'Component');
              }
          }
        } // Remaining cases are all treated as empty.


        return deleteRemainingChildren(returnFiber, currentFirstChild);
      }

      return reconcileChildFibers;
    }

    var reconcileChildFibers = ChildReconciler(true);
    var mountChildFibers = ChildReconciler(false);

    function cloneChildFibers(current, workInProgress) {
      !(current === null || workInProgress.child === current.child) ? invariant(false, 'Resuming work not yet implemented.') : void 0;

      if (workInProgress.child === null) {
        return;
      }

      var currentChild = workInProgress.child;
      var newChild = createWorkInProgress(currentChild, currentChild.pendingProps, currentChild.expirationTime);
      workInProgress.child = newChild;
      newChild['return'] = workInProgress;

      while (currentChild.sibling !== null) {
        currentChild = currentChild.sibling;
        newChild = newChild.sibling = createWorkInProgress(currentChild, currentChild.pendingProps, currentChild.expirationTime);
        newChild['return'] = workInProgress;
      }

      newChild.sibling = null;
    }

    {
      var warnedAboutStatelessRefs = {};
    }

    var ReactFiberBeginWork = function ReactFiberBeginWork(config, hostContext, hydrationContext, scheduleWork, computeExpirationForFiber) {
      var shouldSetTextContent = config.shouldSetTextContent,
          useSyncScheduling = config.useSyncScheduling,
          shouldDeprioritizeSubtree = config.shouldDeprioritizeSubtree;
      var pushHostContext = hostContext.pushHostContext,
          pushHostContainer = hostContext.pushHostContainer;
      var enterHydrationState = hydrationContext.enterHydrationState,
          resetHydrationState = hydrationContext.resetHydrationState,
          tryToClaimNextHydratableInstance = hydrationContext.tryToClaimNextHydratableInstance;

      var _ReactFiberClassCompo = ReactFiberClassComponent(scheduleWork, computeExpirationForFiber, memoizeProps, memoizeState),
          adoptClassInstance = _ReactFiberClassCompo.adoptClassInstance,
          constructClassInstance = _ReactFiberClassCompo.constructClassInstance,
          mountClassInstance = _ReactFiberClassCompo.mountClassInstance,
          updateClassInstance = _ReactFiberClassCompo.updateClassInstance; // TODO: Remove this and use reconcileChildrenAtExpirationTime directly.


      function reconcileChildren(current, workInProgress, nextChildren) {
        reconcileChildrenAtExpirationTime(current, workInProgress, nextChildren, workInProgress.expirationTime);
      }

      function reconcileChildrenAtExpirationTime(current, workInProgress, nextChildren, renderExpirationTime) {
        if (current === null) {
          // If this is a fresh new component that hasn't been rendered yet, we
          // won't update its child set by applying minimal side-effects. Instead,
          // we will add them all to the child before it gets rendered. That means
          // we can optimize this reconciliation pass by not tracking side-effects.
          workInProgress.child = mountChildFibers(workInProgress, null, nextChildren, renderExpirationTime);
        } else {
          // If the current child is the same as the work in progress, it means that
          // we haven't yet started any work on these children. Therefore, we use
          // the clone algorithm to create a copy of all the current children.
          // If we had any progressed work already, that is invalid at this point so
          // let's throw it out.
          workInProgress.child = reconcileChildFibers(workInProgress, current.child, nextChildren, renderExpirationTime);
        }
      }

      function updateFragment(current, workInProgress) {
        var nextChildren = workInProgress.pendingProps;

        if (hasContextChanged()) {
          // Normally we can bail out on props equality but if context has changed
          // we don't do the bailout and we have to reuse existing props instead.
          if (nextChildren === null) {
            nextChildren = workInProgress.memoizedProps;
          }
        } else if (nextChildren === null || workInProgress.memoizedProps === nextChildren) {
          return bailoutOnAlreadyFinishedWork(current, workInProgress);
        }

        reconcileChildren(current, workInProgress, nextChildren);
        memoizeProps(workInProgress, nextChildren);
        return workInProgress.child;
      }

      function markRef(current, workInProgress) {
        var ref = workInProgress.ref;

        if (ref !== null && (!current || current.ref !== ref)) {
          // Schedule a Ref effect
          workInProgress.effectTag |= Ref;
        }
      }

      function updateFunctionalComponent(current, workInProgress) {
        var fn = workInProgress.type;
        var nextProps = workInProgress.pendingProps;
        var memoizedProps = workInProgress.memoizedProps;

        if (hasContextChanged()) {
          // Normally we can bail out on props equality but if context has changed
          // we don't do the bailout and we have to reuse existing props instead.
          if (nextProps === null) {
            nextProps = memoizedProps;
          }
        } else {
          if (nextProps === null || memoizedProps === nextProps) {
            return bailoutOnAlreadyFinishedWork(current, workInProgress);
          } // TODO: consider bringing fn.shouldComponentUpdate() back.
          // It used to be here.

        }

        var unmaskedContext = getUnmaskedContext(workInProgress);
        var context = getMaskedContext(workInProgress, unmaskedContext);
        var nextChildren;
        {
          ReactCurrentOwner.current = workInProgress;
          ReactDebugCurrentFiber.setCurrentPhase('render');
          nextChildren = fn(nextProps, context);
          ReactDebugCurrentFiber.setCurrentPhase(null);
        } // React DevTools reads this flag.

        workInProgress.effectTag |= PerformedWork;
        reconcileChildren(current, workInProgress, nextChildren);
        memoizeProps(workInProgress, nextProps);
        return workInProgress.child;
      }

      function updateClassComponent(current, workInProgress, renderExpirationTime) {
        // Push context providers early to prevent context stack mismatches.
        // During mounting we don't know the child context yet as the instance doesn't exist.
        // We will invalidate the child context in finishClassComponent() right after rendering.
        var hasContext = pushContextProvider(workInProgress);
        var shouldUpdate = void 0;

        if (current === null) {
          if (!workInProgress.stateNode) {
            // In the initial pass we might need to construct the instance.
            constructClassInstance(workInProgress, workInProgress.pendingProps);
            mountClassInstance(workInProgress, renderExpirationTime);
            shouldUpdate = true;
          } else {
            invariant(false, 'Resuming work not yet implemented.'); // In a resume, we'll already have an instance we can reuse.
            // shouldUpdate = resumeMountClassInstance(workInProgress, renderExpirationTime);
          }
        } else {
          shouldUpdate = updateClassInstance(current, workInProgress, renderExpirationTime);
        }

        return finishClassComponent(current, workInProgress, shouldUpdate, hasContext);
      }

      function finishClassComponent(current, workInProgress, shouldUpdate, hasContext) {
        // Refs should update even if shouldComponentUpdate returns false
        markRef(current, workInProgress);

        if (!shouldUpdate) {
          // Context providers should defer to sCU for rendering
          if (hasContext) {
            invalidateContextProvider(workInProgress, false);
          }

          return bailoutOnAlreadyFinishedWork(current, workInProgress);
        }

        var instance = workInProgress.stateNode; // Rerender

        ReactCurrentOwner.current = workInProgress;
        var nextChildren = void 0;
        {
          ReactDebugCurrentFiber.setCurrentPhase('render');
          nextChildren = instance.render();

          if (debugRenderPhaseSideEffects) {
            instance.render();
          }

          ReactDebugCurrentFiber.setCurrentPhase(null);
        } // React DevTools reads this flag.

        workInProgress.effectTag |= PerformedWork;
        reconcileChildren(current, workInProgress, nextChildren); // Memoize props and state using the values we just used to render.
        // TODO: Restructure so we never read values from the instance.

        memoizeState(workInProgress, instance.state);
        memoizeProps(workInProgress, instance.props); // The context might have changed so we need to recalculate it.

        if (hasContext) {
          invalidateContextProvider(workInProgress, true);
        }

        return workInProgress.child;
      }

      function pushHostRootContext(workInProgress) {
        var root = workInProgress.stateNode;

        if (root.pendingContext) {
          pushTopLevelContextObject(workInProgress, root.pendingContext, root.pendingContext !== root.context);
        } else if (root.context) {
          // Should always be set
          pushTopLevelContextObject(workInProgress, root.context, false);
        }

        pushHostContainer(workInProgress, root.containerInfo);
      }

      function updateHostRoot(current, workInProgress, renderExpirationTime) {
        pushHostRootContext(workInProgress);
        var updateQueue = workInProgress.updateQueue;

        if (updateQueue !== null) {
          var prevState = workInProgress.memoizedState;
          var state = processUpdateQueue(current, workInProgress, updateQueue, null, null, renderExpirationTime);

          if (prevState === state) {
            // If the state is the same as before, that's a bailout because we had
            // no work that expires at this time.
            resetHydrationState();
            return bailoutOnAlreadyFinishedWork(current, workInProgress);
          }

          var element = state.element;
          var root = workInProgress.stateNode;

          if ((current === null || current.child === null) && root.hydrate && enterHydrationState(workInProgress)) {
            // If we don't have any current children this might be the first pass.
            // We always try to hydrate. If this isn't a hydration pass there won't
            // be any children to hydrate which is effectively the same thing as
            // not hydrating.
            // This is a bit of a hack. We track the host root as a placement to
            // know that we're currently in a mounting state. That way isMounted
            // works as expected. We must reset this before committing.
            // TODO: Delete this when we delete isMounted and findDOMNode.
            workInProgress.effectTag |= Placement; // Ensure that children mount into this root without tracking
            // side-effects. This ensures that we don't store Placement effects on
            // nodes that will be hydrated.

            workInProgress.child = mountChildFibers(workInProgress, null, element, renderExpirationTime);
          } else {
            // Otherwise reset hydration state in case we aborted and resumed another
            // root.
            resetHydrationState();
            reconcileChildren(current, workInProgress, element);
          }

          memoizeState(workInProgress, state);
          return workInProgress.child;
        }

        resetHydrationState(); // If there is no update queue, that's a bailout because the root has no props.

        return bailoutOnAlreadyFinishedWork(current, workInProgress);
      }

      function updateHostComponent(current, workInProgress, renderExpirationTime) {
        pushHostContext(workInProgress);

        if (current === null) {
          tryToClaimNextHydratableInstance(workInProgress);
        }

        var type = workInProgress.type;
        var memoizedProps = workInProgress.memoizedProps;
        var nextProps = workInProgress.pendingProps;

        if (nextProps === null) {
          nextProps = memoizedProps;
          !(nextProps !== null) ? invariant(false, 'We should always have pending or current props. This error is likely caused by a bug in React. Please file an issue.') : void 0;
        }

        var prevProps = current !== null ? current.memoizedProps : null;

        if (hasContextChanged()) {// Normally we can bail out on props equality but if context has changed
          // we don't do the bailout and we have to reuse existing props instead.
        } else if (nextProps === null || memoizedProps === nextProps) {
          return bailoutOnAlreadyFinishedWork(current, workInProgress);
        }

        var nextChildren = nextProps.children;
        var isDirectTextChild = shouldSetTextContent(type, nextProps);

        if (isDirectTextChild) {
          // We special case a direct text child of a host node. This is a common
          // case. We won't handle it as a reified child. We will instead handle
          // this in the host environment that also have access to this prop. That
          // avoids allocating another HostText fiber and traversing it.
          nextChildren = null;
        } else if (prevProps && shouldSetTextContent(type, prevProps)) {
          // If we're switching from a direct text child to a normal child, or to
          // empty, we need to schedule the text content to be reset.
          workInProgress.effectTag |= ContentReset;
        }

        markRef(current, workInProgress); // Check the host config to see if the children are offscreen/hidden.

        if (renderExpirationTime !== Never && !useSyncScheduling && shouldDeprioritizeSubtree(type, nextProps)) {
          // Down-prioritize the children.
          workInProgress.expirationTime = Never; // Bailout and come back to this fiber later.

          return null;
        }

        reconcileChildren(current, workInProgress, nextChildren);
        memoizeProps(workInProgress, nextProps);
        return workInProgress.child;
      }

      function updateHostText(current, workInProgress) {
        if (current === null) {
          tryToClaimNextHydratableInstance(workInProgress);
        }

        var nextProps = workInProgress.pendingProps;

        if (nextProps === null) {
          nextProps = workInProgress.memoizedProps;
        }

        memoizeProps(workInProgress, nextProps); // Nothing to do here. This is terminal. We'll do the completion step
        // immediately after.

        return null;
      }

      function mountIndeterminateComponent(current, workInProgress, renderExpirationTime) {
        !(current === null) ? invariant(false, 'An indeterminate component should never have mounted. This error is likely caused by a bug in React. Please file an issue.') : void 0;
        var fn = workInProgress.type;
        var props = workInProgress.pendingProps;
        var unmaskedContext = getUnmaskedContext(workInProgress);
        var context = getMaskedContext(workInProgress, unmaskedContext);
        var value;
        {
          if (fn.prototype && typeof fn.prototype.render === 'function') {
            var componentName = getComponentName(workInProgress);
            warning(false, "The <%s /> component appears to have a render method, but doesn't extend React.Component. " + 'This is likely to cause errors. Change %s to extend React.Component instead.', componentName, componentName);
          }

          ReactCurrentOwner.current = workInProgress;
          value = fn(props, context);
        } // React DevTools reads this flag.

        workInProgress.effectTag |= PerformedWork;

        if (typeof value === 'object' && value !== null && typeof value.render === 'function') {
          // Proceed under the assumption that this is a class instance
          workInProgress.tag = ClassComponent; // Push context providers early to prevent context stack mismatches.
          // During mounting we don't know the child context yet as the instance doesn't exist.
          // We will invalidate the child context in finishClassComponent() right after rendering.

          var hasContext = pushContextProvider(workInProgress);
          adoptClassInstance(workInProgress, value);
          mountClassInstance(workInProgress, renderExpirationTime);
          return finishClassComponent(current, workInProgress, true, hasContext);
        } else {
          // Proceed under the assumption that this is a functional component
          workInProgress.tag = FunctionalComponent;
          {
            var Component = workInProgress.type;

            if (Component) {
              warning(!Component.childContextTypes, '%s(...): childContextTypes cannot be defined on a functional component.', Component.displayName || Component.name || 'Component');
            }

            if (workInProgress.ref !== null) {
              var info = '';
              var ownerName = ReactDebugCurrentFiber.getCurrentFiberOwnerName();

              if (ownerName) {
                info += '\n\nCheck the render method of `' + ownerName + '`.';
              }

              var warningKey = ownerName || workInProgress._debugID || '';
              var debugSource = workInProgress._debugSource;

              if (debugSource) {
                warningKey = debugSource.fileName + ':' + debugSource.lineNumber;
              }

              if (!warnedAboutStatelessRefs[warningKey]) {
                warnedAboutStatelessRefs[warningKey] = true;
                warning(false, 'Stateless function components cannot be given refs. ' + 'Attempts to access this ref will fail.%s%s', info, ReactDebugCurrentFiber.getCurrentFiberStackAddendum());
              }
            }
          }
          reconcileChildren(current, workInProgress, value);
          memoizeProps(workInProgress, props);
          return workInProgress.child;
        }
      }

      function updateCallComponent(current, workInProgress, renderExpirationTime) {
        var nextCall = workInProgress.pendingProps;

        if (hasContextChanged()) {
          // Normally we can bail out on props equality but if context has changed
          // we don't do the bailout and we have to reuse existing props instead.
          if (nextCall === null) {
            nextCall = current && current.memoizedProps;
            !(nextCall !== null) ? invariant(false, 'We should always have pending or current props. This error is likely caused by a bug in React. Please file an issue.') : void 0;
          }
        } else if (nextCall === null || workInProgress.memoizedProps === nextCall) {
          nextCall = workInProgress.memoizedProps; // TODO: When bailing out, we might need to return the stateNode instead
          // of the child. To check it for work.
          // return bailoutOnAlreadyFinishedWork(current, workInProgress);
        }

        var nextChildren = nextCall.children; // The following is a fork of reconcileChildrenAtExpirationTime but using
        // stateNode to store the child.

        if (current === null) {
          workInProgress.stateNode = mountChildFibers(workInProgress, workInProgress.stateNode, nextChildren, renderExpirationTime);
        } else {
          workInProgress.stateNode = reconcileChildFibers(workInProgress, workInProgress.stateNode, nextChildren, renderExpirationTime);
        }

        memoizeProps(workInProgress, nextCall); // This doesn't take arbitrary time so we could synchronously just begin
        // eagerly do the work of workInProgress.child as an optimization.

        return workInProgress.stateNode;
      }

      function updatePortalComponent(current, workInProgress, renderExpirationTime) {
        pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);
        var nextChildren = workInProgress.pendingProps;

        if (hasContextChanged()) {
          // Normally we can bail out on props equality but if context has changed
          // we don't do the bailout and we have to reuse existing props instead.
          if (nextChildren === null) {
            nextChildren = current && current.memoizedProps;
            !(nextChildren != null) ? invariant(false, 'We should always have pending or current props. This error is likely caused by a bug in React. Please file an issue.') : void 0;
          }
        } else if (nextChildren === null || workInProgress.memoizedProps === nextChildren) {
          return bailoutOnAlreadyFinishedWork(current, workInProgress);
        }

        if (current === null) {
          // Portals are special because we don't append the children during mount
          // but at commit. Therefore we need to track insertions which the normal
          // flow doesn't do during mount. This doesn't happen at the root because
          // the root always starts with a "current" with a null child.
          // TODO: Consider unifying this with how the root works.
          workInProgress.child = reconcileChildFibers(workInProgress, null, nextChildren, renderExpirationTime);
          memoizeProps(workInProgress, nextChildren);
        } else {
          reconcileChildren(current, workInProgress, nextChildren);
          memoizeProps(workInProgress, nextChildren);
        }

        return workInProgress.child;
      }
      /*
      function reuseChildrenEffects(returnFiber : Fiber, firstChild : Fiber) {
        let child = firstChild;
        do {
          // Ensure that the first and last effect of the parent corresponds
          // to the children's first and last effect.
          if (!returnFiber.firstEffect) {
            returnFiber.firstEffect = child.firstEffect;
          }
          if (child.lastEffect) {
            if (returnFiber.lastEffect) {
              returnFiber.lastEffect.nextEffect = child.firstEffect;
            }
            returnFiber.lastEffect = child.lastEffect;
          }
        } while (child = child.sibling);
      }
      */


      function bailoutOnAlreadyFinishedWork(current, workInProgress) {
        cancelWorkTimer(workInProgress); // TODO: We should ideally be able to bail out early if the children have no
        // more work to do. However, since we don't have a separation of this
        // Fiber's priority and its children yet - we don't know without doing lots
        // of the same work we do anyway. Once we have that separation we can just
        // bail out here if the children has no more work at this priority level.
        // if (workInProgress.priorityOfChildren <= priorityLevel) {
        //   // If there are side-effects in these children that have not yet been
        //   // committed we need to ensure that they get properly transferred up.
        //   if (current && current.child !== workInProgress.child) {
        //     reuseChildrenEffects(workInProgress, child);
        //   }
        //   return null;
        // }

        cloneChildFibers(current, workInProgress);
        return workInProgress.child;
      }

      function bailoutOnLowPriority(current, workInProgress) {
        cancelWorkTimer(workInProgress); // TODO: Handle HostComponent tags here as well and call pushHostContext()?
        // See PR 8590 discussion for context

        switch (workInProgress.tag) {
          case HostRoot:
            pushHostRootContext(workInProgress);
            break;

          case ClassComponent:
            pushContextProvider(workInProgress);
            break;

          case HostPortal:
            pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);
            break;
        } // TODO: What if this is currently in progress?
        // How can that happen? How is this not being cloned?


        return null;
      } // TODO: Delete memoizeProps/State and move to reconcile/bailout instead


      function memoizeProps(workInProgress, nextProps) {
        workInProgress.memoizedProps = nextProps;
      }

      function memoizeState(workInProgress, nextState) {
        workInProgress.memoizedState = nextState; // Don't reset the updateQueue, in case there are pending updates. Resetting
        // is handled by processUpdateQueue.
      }

      function beginWork(current, workInProgress, renderExpirationTime) {
        if (workInProgress.expirationTime === NoWork || workInProgress.expirationTime > renderExpirationTime) {
          return bailoutOnLowPriority(current, workInProgress);
        }

        switch (workInProgress.tag) {
          case IndeterminateComponent:
            return mountIndeterminateComponent(current, workInProgress, renderExpirationTime);

          case FunctionalComponent:
            return updateFunctionalComponent(current, workInProgress);

          case ClassComponent:
            return updateClassComponent(current, workInProgress, renderExpirationTime);

          case HostRoot:
            return updateHostRoot(current, workInProgress, renderExpirationTime);

          case HostComponent:
            return updateHostComponent(current, workInProgress, renderExpirationTime);

          case HostText:
            return updateHostText(current, workInProgress);

          case CallHandlerPhase:
            // This is a restart. Reset the tag to the initial phase.
            workInProgress.tag = CallComponent;
          // Intentionally fall through since this is now the same.

          case CallComponent:
            return updateCallComponent(current, workInProgress, renderExpirationTime);

          case ReturnComponent:
            // A return component is just a placeholder, we can just run through the
            // next one immediately.
            return null;

          case HostPortal:
            return updatePortalComponent(current, workInProgress, renderExpirationTime);

          case Fragment:
            return updateFragment(current, workInProgress);

          default:
            invariant(false, 'Unknown unit of work tag. This error is likely caused by a bug in React. Please file an issue.');
        }
      }

      function beginFailedWork(current, workInProgress, renderExpirationTime) {
        // Push context providers here to avoid a push/pop context mismatch.
        switch (workInProgress.tag) {
          case ClassComponent:
            pushContextProvider(workInProgress);
            break;

          case HostRoot:
            pushHostRootContext(workInProgress);
            break;

          default:
            invariant(false, 'Invalid type of work. This error is likely caused by a bug in React. Please file an issue.');
        } // Add an error effect so we can handle the error during the commit phase


        workInProgress.effectTag |= Err; // This is a weird case where we do "resume" work  work that failed on
        // our first attempt. Because we no longer have a notion of "progressed
        // deletions," reset the child to the current child to make sure we delete
        // it again. TODO: Find a better way to handle this, perhaps during a more
        // general overhaul of error handling.

        if (current === null) {
          workInProgress.child = null;
        } else if (workInProgress.child !== current.child) {
          workInProgress.child = current.child;
        }

        if (workInProgress.expirationTime === NoWork || workInProgress.expirationTime > renderExpirationTime) {
          return bailoutOnLowPriority(current, workInProgress);
        } // If we don't bail out, we're going be recomputing our children so we need
        // to drop our effect list.


        workInProgress.firstEffect = null;
        workInProgress.lastEffect = null; // Unmount the current children as if the component rendered null

        var nextChildren = null;
        reconcileChildrenAtExpirationTime(current, workInProgress, nextChildren, renderExpirationTime);

        if (workInProgress.tag === ClassComponent) {
          var instance = workInProgress.stateNode;
          workInProgress.memoizedProps = instance.props;
          workInProgress.memoizedState = instance.state;
        }

        return workInProgress.child;
      }

      return {
        beginWork: beginWork,
        beginFailedWork: beginFailedWork
      };
    };

    var ReactFiberCompleteWork = function ReactFiberCompleteWork(config, hostContext, hydrationContext) {
      var createInstance = config.createInstance,
          createTextInstance = config.createTextInstance,
          appendInitialChild = config.appendInitialChild,
          finalizeInitialChildren = config.finalizeInitialChildren,
          prepareUpdate = config.prepareUpdate,
          mutation = config.mutation,
          persistence = config.persistence;
      var getRootHostContainer = hostContext.getRootHostContainer,
          popHostContext = hostContext.popHostContext,
          getHostContext = hostContext.getHostContext,
          popHostContainer = hostContext.popHostContainer;
      var prepareToHydrateHostInstance = hydrationContext.prepareToHydrateHostInstance,
          prepareToHydrateHostTextInstance = hydrationContext.prepareToHydrateHostTextInstance,
          popHydrationState = hydrationContext.popHydrationState;

      function markUpdate(workInProgress) {
        // Tag the fiber with an update effect. This turns a Placement into
        // an UpdateAndPlacement.
        workInProgress.effectTag |= Update;
      }

      function markRef(workInProgress) {
        workInProgress.effectTag |= Ref;
      }

      function appendAllReturns(returns, workInProgress) {
        var node = workInProgress.stateNode;

        if (node) {
          node['return'] = workInProgress;
        }

        while (node !== null) {
          if (node.tag === HostComponent || node.tag === HostText || node.tag === HostPortal) {
            invariant(false, 'A call cannot have host component children.');
          } else if (node.tag === ReturnComponent) {
            returns.push(node.type);
          } else if (node.child !== null) {
            node.child['return'] = node;
            node = node.child;
            continue;
          }

          while (node.sibling === null) {
            if (node['return'] === null || node['return'] === workInProgress) {
              return;
            }

            node = node['return'];
          }

          node.sibling['return'] = node['return'];
          node = node.sibling;
        }
      }

      function moveCallToHandlerPhase(current, workInProgress, renderExpirationTime) {
        var call = workInProgress.memoizedProps;
        !call ? invariant(false, 'Should be resolved by now. This error is likely caused by a bug in React. Please file an issue.') : void 0; // First step of the call has completed. Now we need to do the second.
        // TODO: It would be nice to have a multi stage call represented by a
        // single component, or at least tail call optimize nested ones. Currently
        // that requires additional fields that we don't want to add to the fiber.
        // So this requires nested handlers.
        // Note: This doesn't mutate the alternate node. I don't think it needs to
        // since this stage is reset for every pass.

        workInProgress.tag = CallHandlerPhase; // Build up the returns.
        // TODO: Compare this to a generator or opaque helpers like Children.

        var returns = [];
        appendAllReturns(returns, workInProgress);
        var fn = call.handler;
        var props = call.props;
        var nextChildren = fn(props, returns);
        var currentFirstChild = current !== null ? current.child : null;
        workInProgress.child = reconcileChildFibers(workInProgress, currentFirstChild, nextChildren, renderExpirationTime);
        return workInProgress.child;
      }

      function appendAllChildren(parent, workInProgress) {
        // We only have the top Fiber that was created but we need recurse down its
        // children to find all the terminal nodes.
        var node = workInProgress.child;

        while (node !== null) {
          if (node.tag === HostComponent || node.tag === HostText) {
            appendInitialChild(parent, node.stateNode);
          } else if (node.tag === HostPortal) {// If we have a portal child, then we don't want to traverse
            // down its children. Instead, we'll get insertions from each child in
            // the portal directly.
          } else if (node.child !== null) {
            node.child['return'] = node;
            node = node.child;
            continue;
          }

          if (node === workInProgress) {
            return;
          }

          while (node.sibling === null) {
            if (node['return'] === null || node['return'] === workInProgress) {
              return;
            }

            node = node['return'];
          }

          node.sibling['return'] = node['return'];
          node = node.sibling;
        }
      }

      var updateHostContainer = void 0;
      var updateHostComponent = void 0;
      var updateHostText = void 0;

      if (mutation) {
        if (enableMutatingReconciler) {
          // Mutation mode
          updateHostContainer = function updateHostContainer(workInProgress) {// Noop
          };

          updateHostComponent = function updateHostComponent(current, workInProgress, updatePayload, type, oldProps, newProps, rootContainerInstance) {
            // TODO: Type this specific to this type of component.
            workInProgress.updateQueue = updatePayload; // If the update payload indicates that there is a change or if there
            // is a new ref we mark this as an update. All the work is done in commitWork.

            if (updatePayload) {
              markUpdate(workInProgress);
            }
          };

          updateHostText = function updateHostText(current, workInProgress, oldText, newText) {
            // If the text differs, mark it as an update. All the work in done in commitWork.
            if (oldText !== newText) {
              markUpdate(workInProgress);
            }
          };
        } else {
          invariant(false, 'Mutating reconciler is disabled.');
        }
      } else if (persistence) {
        if (enablePersistentReconciler) {
          // Persistent host tree mode
          var cloneInstance = persistence.cloneInstance,
              createContainerChildSet = persistence.createContainerChildSet,
              appendChildToContainerChildSet = persistence.appendChildToContainerChildSet,
              finalizeContainerChildren = persistence.finalizeContainerChildren; // An unfortunate fork of appendAllChildren because we have two different parent types.

          var appendAllChildrenToContainer = function appendAllChildrenToContainer(containerChildSet, workInProgress) {
            // We only have the top Fiber that was created but we need recurse down its
            // children to find all the terminal nodes.
            var node = workInProgress.child;

            while (node !== null) {
              if (node.tag === HostComponent || node.tag === HostText) {
                appendChildToContainerChildSet(containerChildSet, node.stateNode);
              } else if (node.tag === HostPortal) {// If we have a portal child, then we don't want to traverse
                // down its children. Instead, we'll get insertions from each child in
                // the portal directly.
              } else if (node.child !== null) {
                node.child['return'] = node;
                node = node.child;
                continue;
              }

              if (node === workInProgress) {
                return;
              }

              while (node.sibling === null) {
                if (node['return'] === null || node['return'] === workInProgress) {
                  return;
                }

                node = node['return'];
              }

              node.sibling['return'] = node['return'];
              node = node.sibling;
            }
          };

          updateHostContainer = function updateHostContainer(workInProgress) {
            var portalOrRoot = workInProgress.stateNode;
            var childrenUnchanged = workInProgress.firstEffect === null;

            if (childrenUnchanged) {// No changes, just reuse the existing instance.
            } else {
              var container = portalOrRoot.containerInfo;
              var newChildSet = createContainerChildSet(container);

              if (finalizeContainerChildren(container, newChildSet)) {
                markUpdate(workInProgress);
              }

              portalOrRoot.pendingChildren = newChildSet; // If children might have changed, we have to add them all to the set.

              appendAllChildrenToContainer(newChildSet, workInProgress); // Schedule an update on the container to swap out the container.

              markUpdate(workInProgress);
            }
          };

          updateHostComponent = function updateHostComponent(current, workInProgress, updatePayload, type, oldProps, newProps, rootContainerInstance) {
            // If there are no effects associated with this node, then none of our children had any updates.
            // This guarantees that we can reuse all of them.
            var childrenUnchanged = workInProgress.firstEffect === null;
            var currentInstance = current.stateNode;

            if (childrenUnchanged && updatePayload === null) {
              // No changes, just reuse the existing instance.
              // Note that this might release a previous clone.
              workInProgress.stateNode = currentInstance;
            } else {
              var recyclableInstance = workInProgress.stateNode;
              var newInstance = cloneInstance(currentInstance, updatePayload, type, oldProps, newProps, workInProgress, childrenUnchanged, recyclableInstance);

              if (finalizeInitialChildren(newInstance, type, newProps, rootContainerInstance)) {
                markUpdate(workInProgress);
              }

              workInProgress.stateNode = newInstance;

              if (childrenUnchanged) {
                // If there are no other effects in this tree, we need to flag this node as having one.
                // Even though we're not going to use it for anything.
                // Otherwise parents won't know that there are new children to propagate upwards.
                markUpdate(workInProgress);
              } else {
                // If children might have changed, we have to add them all to the set.
                appendAllChildren(newInstance, workInProgress);
              }
            }
          };

          updateHostText = function updateHostText(current, workInProgress, oldText, newText) {
            if (oldText !== newText) {
              // If the text content differs, we'll create a new text instance for it.
              var rootContainerInstance = getRootHostContainer();
              var currentHostContext = getHostContext();
              workInProgress.stateNode = createTextInstance(newText, rootContainerInstance, currentHostContext, workInProgress); // We'll have to mark it as having an effect, even though we won't use the effect for anything.
              // This lets the parents know that at least one of their children has changed.

              markUpdate(workInProgress);
            }
          };
        } else {
          invariant(false, 'Persistent reconciler is disabled.');
        }
      } else {
        if (enableNoopReconciler) {
          // No host operations
          updateHostContainer = function updateHostContainer(workInProgress) {// Noop
          };

          updateHostComponent = function updateHostComponent(current, workInProgress, updatePayload, type, oldProps, newProps, rootContainerInstance) {// Noop
          };

          updateHostText = function updateHostText(current, workInProgress, oldText, newText) {// Noop
          };
        } else {
          invariant(false, 'Noop reconciler is disabled.');
        }
      }

      function completeWork(current, workInProgress, renderExpirationTime) {
        // Get the latest props.
        var newProps = workInProgress.pendingProps;

        if (newProps === null) {
          newProps = workInProgress.memoizedProps;
        } else if (workInProgress.expirationTime !== Never || renderExpirationTime === Never) {
          // Reset the pending props, unless this was a down-prioritization.
          workInProgress.pendingProps = null;
        }

        switch (workInProgress.tag) {
          case FunctionalComponent:
            return null;

          case ClassComponent:
            {
              // We are leaving this subtree, so pop context if any.
              popContextProvider(workInProgress);
              return null;
            }

          case HostRoot:
            {
              popHostContainer(workInProgress);
              popTopLevelContextObject(workInProgress);
              var fiberRoot = workInProgress.stateNode;

              if (fiberRoot.pendingContext) {
                fiberRoot.context = fiberRoot.pendingContext;
                fiberRoot.pendingContext = null;
              }

              if (current === null || current.child === null) {
                // If we hydrated, pop so that we can delete any remaining children
                // that weren't hydrated.
                popHydrationState(workInProgress); // This resets the hacky state to fix isMounted before committing.
                // TODO: Delete this when we delete isMounted and findDOMNode.

                workInProgress.effectTag &= ~Placement;
              }

              updateHostContainer(workInProgress);
              return null;
            }

          case HostComponent:
            {
              popHostContext(workInProgress);
              var rootContainerInstance = getRootHostContainer();
              var type = workInProgress.type;

              if (current !== null && workInProgress.stateNode != null) {
                // If we have an alternate, that means this is an update and we need to
                // schedule a side-effect to do the updates.
                var oldProps = current.memoizedProps; // If we get updated because one of our children updated, we don't
                // have newProps so we'll have to reuse them.
                // TODO: Split the update API as separate for the props vs. children.
                // Even better would be if children weren't special cased at all tho.

                var instance = workInProgress.stateNode;
                var currentHostContext = getHostContext();
                var updatePayload = prepareUpdate(instance, type, oldProps, newProps, rootContainerInstance, currentHostContext);
                updateHostComponent(current, workInProgress, updatePayload, type, oldProps, newProps, rootContainerInstance);

                if (current.ref !== workInProgress.ref) {
                  markRef(workInProgress);
                }
              } else {
                if (!newProps) {
                  !(workInProgress.stateNode !== null) ? invariant(false, 'We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.') : void 0; // This can happen when we abort work.

                  return null;
                }

                var _currentHostContext = getHostContext(); // TODO: Move createInstance to beginWork and keep it on a context
                // "stack" as the parent. Then append children as we go in beginWork
                // or completeWork depending on we want to add then top->down or
                // bottom->up. Top->down is faster in IE11.


                var wasHydrated = popHydrationState(workInProgress);

                if (wasHydrated) {
                  // TODO: Move this and createInstance step into the beginPhase
                  // to consolidate.
                  if (prepareToHydrateHostInstance(workInProgress, rootContainerInstance, _currentHostContext)) {
                    // If changes to the hydrated node needs to be applied at the
                    // commit-phase we mark this as such.
                    markUpdate(workInProgress);
                  }
                } else {
                  var _instance = createInstance(type, newProps, rootContainerInstance, _currentHostContext, workInProgress);

                  appendAllChildren(_instance, workInProgress); // Certain renderers require commit-time effects for initial mount.
                  // (eg DOM renderer supports auto-focus for certain elements).
                  // Make sure such renderers get scheduled for later work.

                  if (finalizeInitialChildren(_instance, type, newProps, rootContainerInstance)) {
                    markUpdate(workInProgress);
                  }

                  workInProgress.stateNode = _instance;
                }

                if (workInProgress.ref !== null) {
                  // If there is a ref on a host node we need to schedule a callback
                  markRef(workInProgress);
                }
              }

              return null;
            }

          case HostText:
            {
              var newText = newProps;

              if (current && workInProgress.stateNode != null) {
                var oldText = current.memoizedProps; // If we have an alternate, that means this is an update and we need
                // to schedule a side-effect to do the updates.

                updateHostText(current, workInProgress, oldText, newText);
              } else {
                if (typeof newText !== 'string') {
                  !(workInProgress.stateNode !== null) ? invariant(false, 'We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.') : void 0; // This can happen when we abort work.

                  return null;
                }

                var _rootContainerInstance = getRootHostContainer();

                var _currentHostContext2 = getHostContext();

                var _wasHydrated = popHydrationState(workInProgress);

                if (_wasHydrated) {
                  if (prepareToHydrateHostTextInstance(workInProgress)) {
                    markUpdate(workInProgress);
                  }
                } else {
                  workInProgress.stateNode = createTextInstance(newText, _rootContainerInstance, _currentHostContext2, workInProgress);
                }
              }

              return null;
            }

          case CallComponent:
            return moveCallToHandlerPhase(current, workInProgress, renderExpirationTime);

          case CallHandlerPhase:
            // Reset the tag to now be a first phase call.
            workInProgress.tag = CallComponent;
            return null;

          case ReturnComponent:
            // Does nothing.
            return null;

          case Fragment:
            return null;

          case HostPortal:
            popHostContainer(workInProgress);
            updateHostContainer(workInProgress);
            return null;
          // Error cases

          case IndeterminateComponent:
            invariant(false, 'An indeterminate component should have become determinate before completing. This error is likely caused by a bug in React. Please file an issue.');
          // eslint-disable-next-line no-fallthrough

          default:
            invariant(false, 'Unknown unit of work tag. This error is likely caused by a bug in React. Please file an issue.');
        }
      }

      return {
        completeWork: completeWork
      };
    };

    var invokeGuardedCallback$2 = ReactErrorUtils.invokeGuardedCallback;
    var hasCaughtError$1 = ReactErrorUtils.hasCaughtError;
    var clearCaughtError$1 = ReactErrorUtils.clearCaughtError;

    var ReactFiberCommitWork = function ReactFiberCommitWork(config, captureError) {
      var getPublicInstance = config.getPublicInstance,
          mutation = config.mutation,
          persistence = config.persistence;

      var callComponentWillUnmountWithTimer = function callComponentWillUnmountWithTimer(current, instance) {
        startPhaseTimer(current, 'componentWillUnmount');
        instance.props = current.memoizedProps;
        instance.state = current.memoizedState;
        instance.componentWillUnmount();
        stopPhaseTimer();
      }; // Capture errors so they don't interrupt unmounting.


      function safelyCallComponentWillUnmount(current, instance) {
        {
          invokeGuardedCallback$2(null, callComponentWillUnmountWithTimer, null, current, instance);

          if (hasCaughtError$1()) {
            var unmountError = clearCaughtError$1();
            captureError(current, unmountError);
          }
        }
      }

      function safelyDetachRef(current) {
        var ref = current.ref;

        if (ref !== null) {
          {
            invokeGuardedCallback$2(null, ref, null, null);

            if (hasCaughtError$1()) {
              var refError = clearCaughtError$1();
              captureError(current, refError);
            }
          }
        }
      }

      function commitLifeCycles(current, finishedWork) {
        switch (finishedWork.tag) {
          case ClassComponent:
            {
              var instance = finishedWork.stateNode;

              if (finishedWork.effectTag & Update) {
                if (current === null) {
                  startPhaseTimer(finishedWork, 'componentDidMount');
                  instance.props = finishedWork.memoizedProps;
                  instance.state = finishedWork.memoizedState;
                  instance.componentDidMount();
                  stopPhaseTimer();
                } else {
                  var prevProps = current.memoizedProps;
                  var prevState = current.memoizedState;
                  startPhaseTimer(finishedWork, 'componentDidUpdate');
                  instance.props = finishedWork.memoizedProps;
                  instance.state = finishedWork.memoizedState;
                  instance.componentDidUpdate(prevProps, prevState);
                  stopPhaseTimer();
                }
              }

              var updateQueue = finishedWork.updateQueue;

              if (updateQueue !== null) {
                commitCallbacks(updateQueue, instance);
              }

              return;
            }

          case HostRoot:
            {
              var _updateQueue = finishedWork.updateQueue;

              if (_updateQueue !== null) {
                var _instance = finishedWork.child !== null ? finishedWork.child.stateNode : null;

                commitCallbacks(_updateQueue, _instance);
              }

              return;
            }

          case HostComponent:
            {
              var _instance2 = finishedWork.stateNode; // Renderers may schedule work to be done after host components are mounted
              // (eg DOM renderer may schedule auto-focus for inputs and form controls).
              // These effects should only be committed when components are first mounted,
              // aka when there is no current/alternate.

              if (current === null && finishedWork.effectTag & Update) {
                var type = finishedWork.type;
                var props = finishedWork.memoizedProps;
                commitMount(_instance2, type, props, finishedWork);
              }

              return;
            }

          case HostText:
            {
              // We have no life-cycles associated with text.
              return;
            }

          case HostPortal:
            {
              // We have no life-cycles associated with portals.
              return;
            }

          default:
            {
              invariant(false, 'This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.');
            }
        }
      }

      function commitAttachRef(finishedWork) {
        var ref = finishedWork.ref;

        if (ref !== null) {
          var instance = finishedWork.stateNode;

          switch (finishedWork.tag) {
            case HostComponent:
              ref(getPublicInstance(instance));
              break;

            default:
              ref(instance);
          }
        }
      }

      function commitDetachRef(current) {
        var currentRef = current.ref;

        if (currentRef !== null) {
          currentRef(null);
        }
      } // User-originating errors (lifecycles and refs) should not interrupt
      // deletion, so don't let them throw. Host-originating errors should
      // interrupt deletion, so it's okay


      function commitUnmount(current) {
        if (typeof onCommitUnmount === 'function') {
          onCommitUnmount(current);
        }

        switch (current.tag) {
          case ClassComponent:
            {
              safelyDetachRef(current);
              var instance = current.stateNode;

              if (typeof instance.componentWillUnmount === 'function') {
                safelyCallComponentWillUnmount(current, instance);
              }

              return;
            }

          case HostComponent:
            {
              safelyDetachRef(current);
              return;
            }

          case CallComponent:
            {
              commitNestedUnmounts(current.stateNode);
              return;
            }

          case HostPortal:
            {
              // TODO: this is recursive.
              // We are also not using this parent because
              // the portal will get pushed immediately.
              if (enableMutatingReconciler && mutation) {
                unmountHostComponents(current);
              } else if (enablePersistentReconciler && persistence) {
                emptyPortalContainer(current);
              }

              return;
            }
        }
      }

      function commitNestedUnmounts(root) {
        // While we're inside a removed host node we don't want to call
        // removeChild on the inner nodes because they're removed by the top
        // call anyway. We also want to call componentWillUnmount on all
        // composites before this host node is removed from the tree. Therefore
        var node = root;

        while (true) {
          commitUnmount(node); // Visit children because they may contain more composite or host nodes.
          // Skip portals because commitUnmount() currently visits them recursively.

          if (node.child !== null && ( // If we use mutation we drill down into portals using commitUnmount above.
          // If we don't use mutation we drill down into portals here instead.
          !mutation || node.tag !== HostPortal)) {
            node.child['return'] = node;
            node = node.child;
            continue;
          }

          if (node === root) {
            return;
          }

          while (node.sibling === null) {
            if (node['return'] === null || node['return'] === root) {
              return;
            }

            node = node['return'];
          }

          node.sibling['return'] = node['return'];
          node = node.sibling;
        }
      }

      function detachFiber(current) {
        // Cut off the return pointers to disconnect it from the tree. Ideally, we
        // should clear the child pointer of the parent alternate to let this
        // get GC:ed but we don't know which for sure which parent is the current
        // one so we'll settle for GC:ing the subtree of this child. This child
        // itself will be GC:ed when the parent updates the next time.
        current['return'] = null;
        current.child = null;

        if (current.alternate) {
          current.alternate.child = null;
          current.alternate['return'] = null;
        }
      }

      if (!mutation) {
        var commitContainer = void 0;

        if (persistence) {
          var replaceContainerChildren = persistence.replaceContainerChildren,
              createContainerChildSet = persistence.createContainerChildSet;

          var emptyPortalContainer = function emptyPortalContainer(current) {
            var portal = current.stateNode;
            var containerInfo = portal.containerInfo;
            var emptyChildSet = createContainerChildSet(containerInfo);
            replaceContainerChildren(containerInfo, emptyChildSet);
          };

          commitContainer = function commitContainer(finishedWork) {
            switch (finishedWork.tag) {
              case ClassComponent:
                {
                  return;
                }

              case HostComponent:
                {
                  return;
                }

              case HostText:
                {
                  return;
                }

              case HostRoot:
              case HostPortal:
                {
                  var portalOrRoot = finishedWork.stateNode;
                  var containerInfo = portalOrRoot.containerInfo,
                      _pendingChildren = portalOrRoot.pendingChildren;
                  replaceContainerChildren(containerInfo, _pendingChildren);
                  return;
                }

              default:
                {
                  invariant(false, 'This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.');
                }
            }
          };
        } else {
          commitContainer = function commitContainer(finishedWork) {// Noop
          };
        }

        if (enablePersistentReconciler || enableNoopReconciler) {
          return {
            commitResetTextContent: function commitResetTextContent(finishedWork) {},
            commitPlacement: function commitPlacement(finishedWork) {},
            commitDeletion: function commitDeletion(current) {
              // Detach refs and call componentWillUnmount() on the whole subtree.
              commitNestedUnmounts(current);
              detachFiber(current);
            },
            commitWork: function commitWork(current, finishedWork) {
              commitContainer(finishedWork);
            },
            commitLifeCycles: commitLifeCycles,
            commitAttachRef: commitAttachRef,
            commitDetachRef: commitDetachRef
          };
        } else if (persistence) {
          invariant(false, 'Persistent reconciler is disabled.');
        } else {
          invariant(false, 'Noop reconciler is disabled.');
        }
      }

      var commitMount = mutation.commitMount,
          commitUpdate = mutation.commitUpdate,
          resetTextContent = mutation.resetTextContent,
          commitTextUpdate = mutation.commitTextUpdate,
          appendChild = mutation.appendChild,
          appendChildToContainer = mutation.appendChildToContainer,
          insertBefore = mutation.insertBefore,
          insertInContainerBefore = mutation.insertInContainerBefore,
          removeChild = mutation.removeChild,
          removeChildFromContainer = mutation.removeChildFromContainer;

      function getHostParentFiber(fiber) {
        var parent = fiber['return'];

        while (parent !== null) {
          if (isHostParent(parent)) {
            return parent;
          }

          parent = parent['return'];
        }

        invariant(false, 'Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.');
      }

      function isHostParent(fiber) {
        return fiber.tag === HostComponent || fiber.tag === HostRoot || fiber.tag === HostPortal;
      }

      function getHostSibling(fiber) {
        // We're going to search forward into the tree until we find a sibling host
        // node. Unfortunately, if multiple insertions are done in a row we have to
        // search past them. This leads to exponential search for the next sibling.
        var node = fiber;

        siblings: while (true) {
          // If we didn't find anything, let's try the next sibling.
          while (node.sibling === null) {
            if (node['return'] === null || isHostParent(node['return'])) {
              // If we pop out of the root or hit the parent the fiber we are the
              // last sibling.
              return null;
            }

            node = node['return'];
          }

          node.sibling['return'] = node['return'];
          node = node.sibling;

          while (node.tag !== HostComponent && node.tag !== HostText) {
            // If it is not host node and, we might have a host node inside it.
            // Try to search down until we find one.
            if (node.effectTag & Placement) {
              // If we don't have a child, try the siblings instead.
              continue siblings;
            } // If we don't have a child, try the siblings instead.
            // We also skip portals because they are not part of this host tree.


            if (node.child === null || node.tag === HostPortal) {
              continue siblings;
            } else {
              node.child['return'] = node;
              node = node.child;
            }
          } // Check if this host node is stable or about to be placed.


          if (!(node.effectTag & Placement)) {
            // Found it!
            return node.stateNode;
          }
        }
      }

      function commitPlacement(finishedWork) {
        // Recursively insert all host nodes into the parent.
        var parentFiber = getHostParentFiber(finishedWork);
        var parent = void 0;
        var isContainer = void 0;

        switch (parentFiber.tag) {
          case HostComponent:
            parent = parentFiber.stateNode;
            isContainer = false;
            break;

          case HostRoot:
            parent = parentFiber.stateNode.containerInfo;
            isContainer = true;
            break;

          case HostPortal:
            parent = parentFiber.stateNode.containerInfo;
            isContainer = true;
            break;

          default:
            invariant(false, 'Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue.');
        }

        if (parentFiber.effectTag & ContentReset) {
          // Reset the text content of the parent before doing any insertions
          resetTextContent(parent); // Clear ContentReset from the effect tag

          parentFiber.effectTag &= ~ContentReset;
        }

        var before = getHostSibling(finishedWork); // We only have the top Fiber that was inserted but we need recurse down its
        // children to find all the terminal nodes.

        var node = finishedWork;

        while (true) {
          if (node.tag === HostComponent || node.tag === HostText) {
            if (before) {
              if (isContainer) {
                insertInContainerBefore(parent, node.stateNode, before);
              } else {
                insertBefore(parent, node.stateNode, before);
              }
            } else {
              if (isContainer) {
                appendChildToContainer(parent, node.stateNode);
              } else {
                appendChild(parent, node.stateNode);
              }
            }
          } else if (node.tag === HostPortal) {// If the insertion itself is a portal, then we don't want to traverse
            // down its children. Instead, we'll get insertions from each child in
            // the portal directly.
          } else if (node.child !== null) {
            node.child['return'] = node;
            node = node.child;
            continue;
          }

          if (node === finishedWork) {
            return;
          }

          while (node.sibling === null) {
            if (node['return'] === null || node['return'] === finishedWork) {
              return;
            }

            node = node['return'];
          }

          node.sibling['return'] = node['return'];
          node = node.sibling;
        }
      }

      function unmountHostComponents(current) {
        // We only have the top Fiber that was inserted but we need recurse down its
        var node = current; // Each iteration, currentParent is populated with node's host parent if not
        // currentParentIsValid.

        var currentParentIsValid = false;
        var currentParent = void 0;
        var currentParentIsContainer = void 0;

        while (true) {
          if (!currentParentIsValid) {
            var parent = node['return'];

            findParent: while (true) {
              !(parent !== null) ? invariant(false, 'Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.') : void 0;

              switch (parent.tag) {
                case HostComponent:
                  currentParent = parent.stateNode;
                  currentParentIsContainer = false;
                  break findParent;

                case HostRoot:
                  currentParent = parent.stateNode.containerInfo;
                  currentParentIsContainer = true;
                  break findParent;

                case HostPortal:
                  currentParent = parent.stateNode.containerInfo;
                  currentParentIsContainer = true;
                  break findParent;
              }

              parent = parent['return'];
            }

            currentParentIsValid = true;
          }

          if (node.tag === HostComponent || node.tag === HostText) {
            commitNestedUnmounts(node); // After all the children have unmounted, it is now safe to remove the
            // node from the tree.

            if (currentParentIsContainer) {
              removeChildFromContainer(currentParent, node.stateNode);
            } else {
              removeChild(currentParent, node.stateNode);
            } // Don't visit children because we already visited them.

          } else if (node.tag === HostPortal) {
            // When we go into a portal, it becomes the parent to remove from.
            // We will reassign it back when we pop the portal on the way up.
            currentParent = node.stateNode.containerInfo; // Visit children because portals might contain host components.

            if (node.child !== null) {
              node.child['return'] = node;
              node = node.child;
              continue;
            }
          } else {
            commitUnmount(node); // Visit children because we may find more host components below.

            if (node.child !== null) {
              node.child['return'] = node;
              node = node.child;
              continue;
            }
          }

          if (node === current) {
            return;
          }

          while (node.sibling === null) {
            if (node['return'] === null || node['return'] === current) {
              return;
            }

            node = node['return'];

            if (node.tag === HostPortal) {
              // When we go out of the portal, we need to restore the parent.
              // Since we don't keep a stack of them, we will search for it.
              currentParentIsValid = false;
            }
          }

          node.sibling['return'] = node['return'];
          node = node.sibling;
        }
      }

      function commitDeletion(current) {
        // Recursively delete all host nodes from the parent.
        // Detach refs and call componentWillUnmount() on the whole subtree.
        unmountHostComponents(current);
        detachFiber(current);
      }

      function commitWork(current, finishedWork) {
        switch (finishedWork.tag) {
          case ClassComponent:
            {
              return;
            }

          case HostComponent:
            {
              var instance = finishedWork.stateNode;

              if (instance != null) {
                // Commit the work prepared earlier.
                var newProps = finishedWork.memoizedProps; // For hydration we reuse the update path but we treat the oldProps
                // as the newProps. The updatePayload will contain the real change in
                // this case.

                var oldProps = current !== null ? current.memoizedProps : newProps;
                var type = finishedWork.type; // TODO: Type the updateQueue to be specific to host components.

                var updatePayload = finishedWork.updateQueue;
                finishedWork.updateQueue = null;

                if (updatePayload !== null) {
                  commitUpdate(instance, updatePayload, type, oldProps, newProps, finishedWork);
                }
              }

              return;
            }

          case HostText:
            {
              !(finishedWork.stateNode !== null) ? invariant(false, 'This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue.') : void 0;
              var textInstance = finishedWork.stateNode;
              var newText = finishedWork.memoizedProps; // For hydration we reuse the update path but we treat the oldProps
              // as the newProps. The updatePayload will contain the real change in
              // this case.

              var oldText = current !== null ? current.memoizedProps : newText;
              commitTextUpdate(textInstance, oldText, newText);
              return;
            }

          case HostRoot:
            {
              return;
            }

          default:
            {
              invariant(false, 'This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.');
            }
        }
      }

      function commitResetTextContent(current) {
        resetTextContent(current.stateNode);
      }

      if (enableMutatingReconciler) {
        return {
          commitResetTextContent: commitResetTextContent,
          commitPlacement: commitPlacement,
          commitDeletion: commitDeletion,
          commitWork: commitWork,
          commitLifeCycles: commitLifeCycles,
          commitAttachRef: commitAttachRef,
          commitDetachRef: commitDetachRef
        };
      } else {
        invariant(false, 'Mutating reconciler is disabled.');
      }
    };

    var NO_CONTEXT = {};

    var ReactFiberHostContext = function ReactFiberHostContext(config) {
      var getChildHostContext = config.getChildHostContext,
          getRootHostContext = config.getRootHostContext;
      var contextStackCursor = createCursor(NO_CONTEXT);
      var contextFiberStackCursor = createCursor(NO_CONTEXT);
      var rootInstanceStackCursor = createCursor(NO_CONTEXT);

      function requiredContext(c) {
        !(c !== NO_CONTEXT) ? invariant(false, 'Expected host context to exist. This error is likely caused by a bug in React. Please file an issue.') : void 0;
        return c;
      }

      function getRootHostContainer() {
        var rootInstance = requiredContext(rootInstanceStackCursor.current);
        return rootInstance;
      }

      function pushHostContainer(fiber, nextRootInstance) {
        // Push current root instance onto the stack;
        // This allows us to reset root when portals are popped.
        push(rootInstanceStackCursor, nextRootInstance, fiber);
        var nextRootContext = getRootHostContext(nextRootInstance); // Track the context and the Fiber that provided it.
        // This enables us to pop only Fibers that provide unique contexts.

        push(contextFiberStackCursor, fiber, fiber);
        push(contextStackCursor, nextRootContext, fiber);
      }

      function popHostContainer(fiber) {
        pop(contextStackCursor, fiber);
        pop(contextFiberStackCursor, fiber);
        pop(rootInstanceStackCursor, fiber);
      }

      function getHostContext() {
        var context = requiredContext(contextStackCursor.current);
        return context;
      }

      function pushHostContext(fiber) {
        var rootInstance = requiredContext(rootInstanceStackCursor.current);
        var context = requiredContext(contextStackCursor.current);
        var nextContext = getChildHostContext(context, fiber.type, rootInstance); // Don't push this Fiber's context unless it's unique.

        if (context === nextContext) {
          return;
        } // Track the context and the Fiber that provided it.
        // This enables us to pop only Fibers that provide unique contexts.


        push(contextFiberStackCursor, fiber, fiber);
        push(contextStackCursor, nextContext, fiber);
      }

      function popHostContext(fiber) {
        // Do not pop unless this Fiber provided the current context.
        // pushHostContext() only pushes Fibers that provide unique contexts.
        if (contextFiberStackCursor.current !== fiber) {
          return;
        }

        pop(contextStackCursor, fiber);
        pop(contextFiberStackCursor, fiber);
      }

      function resetHostContainer() {
        contextStackCursor.current = NO_CONTEXT;
        rootInstanceStackCursor.current = NO_CONTEXT;
      }

      return {
        getHostContext: getHostContext,
        getRootHostContainer: getRootHostContainer,
        popHostContainer: popHostContainer,
        popHostContext: popHostContext,
        pushHostContainer: pushHostContainer,
        pushHostContext: pushHostContext,
        resetHostContainer: resetHostContainer
      };
    };

    var ReactFiberHydrationContext = function ReactFiberHydrationContext(config) {
      var shouldSetTextContent = config.shouldSetTextContent,
          hydration = config.hydration; // If this doesn't have hydration mode.

      if (!hydration) {
        return {
          enterHydrationState: function enterHydrationState() {
            return false;
          },
          resetHydrationState: function resetHydrationState() {},
          tryToClaimNextHydratableInstance: function tryToClaimNextHydratableInstance() {},
          prepareToHydrateHostInstance: function prepareToHydrateHostInstance() {
            invariant(false, 'Expected prepareToHydrateHostInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.');
          },
          prepareToHydrateHostTextInstance: function prepareToHydrateHostTextInstance() {
            invariant(false, 'Expected prepareToHydrateHostTextInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.');
          },
          popHydrationState: function popHydrationState(fiber) {
            return false;
          }
        };
      }

      var canHydrateInstance = hydration.canHydrateInstance,
          canHydrateTextInstance = hydration.canHydrateTextInstance,
          getNextHydratableSibling = hydration.getNextHydratableSibling,
          getFirstHydratableChild = hydration.getFirstHydratableChild,
          hydrateInstance = hydration.hydrateInstance,
          hydrateTextInstance = hydration.hydrateTextInstance,
          didNotMatchHydratedContainerTextInstance = hydration.didNotMatchHydratedContainerTextInstance,
          didNotMatchHydratedTextInstance = hydration.didNotMatchHydratedTextInstance,
          didNotHydrateContainerInstance = hydration.didNotHydrateContainerInstance,
          didNotHydrateInstance = hydration.didNotHydrateInstance,
          didNotFindHydratableContainerInstance = hydration.didNotFindHydratableContainerInstance,
          didNotFindHydratableContainerTextInstance = hydration.didNotFindHydratableContainerTextInstance,
          didNotFindHydratableInstance = hydration.didNotFindHydratableInstance,
          didNotFindHydratableTextInstance = hydration.didNotFindHydratableTextInstance; // The deepest Fiber on the stack involved in a hydration context.
      // This may have been an insertion or a hydration.

      var hydrationParentFiber = null;
      var nextHydratableInstance = null;
      var isHydrating = false;

      function enterHydrationState(fiber) {
        var parentInstance = fiber.stateNode.containerInfo;
        nextHydratableInstance = getFirstHydratableChild(parentInstance);
        hydrationParentFiber = fiber;
        isHydrating = true;
        return true;
      }

      function deleteHydratableInstance(returnFiber, instance) {
        {
          switch (returnFiber.tag) {
            case HostRoot:
              didNotHydrateContainerInstance(returnFiber.stateNode.containerInfo, instance);
              break;

            case HostComponent:
              didNotHydrateInstance(returnFiber.type, returnFiber.memoizedProps, returnFiber.stateNode, instance);
              break;
          }
        }
        var childToDelete = createFiberFromHostInstanceForDeletion();
        childToDelete.stateNode = instance;
        childToDelete['return'] = returnFiber;
        childToDelete.effectTag = Deletion; // This might seem like it belongs on progressedFirstDeletion. However,
        // these children are not part of the reconciliation list of children.
        // Even if we abort and rereconcile the children, that will try to hydrate
        // again and the nodes are still in the host tree so these will be
        // recreated.

        if (returnFiber.lastEffect !== null) {
          returnFiber.lastEffect.nextEffect = childToDelete;
          returnFiber.lastEffect = childToDelete;
        } else {
          returnFiber.firstEffect = returnFiber.lastEffect = childToDelete;
        }
      }

      function insertNonHydratedInstance(returnFiber, fiber) {
        fiber.effectTag |= Placement;
        {
          switch (returnFiber.tag) {
            case HostRoot:
              {
                var parentContainer = returnFiber.stateNode.containerInfo;

                switch (fiber.tag) {
                  case HostComponent:
                    var type = fiber.type;
                    var props = fiber.pendingProps;
                    didNotFindHydratableContainerInstance(parentContainer, type, props);
                    break;

                  case HostText:
                    var text = fiber.pendingProps;
                    didNotFindHydratableContainerTextInstance(parentContainer, text);
                    break;
                }

                break;
              }

            case HostComponent:
              {
                var parentType = returnFiber.type;
                var parentProps = returnFiber.memoizedProps;
                var parentInstance = returnFiber.stateNode;

                switch (fiber.tag) {
                  case HostComponent:
                    var _type = fiber.type;
                    var _props = fiber.pendingProps;
                    didNotFindHydratableInstance(parentType, parentProps, parentInstance, _type, _props);
                    break;

                  case HostText:
                    var _text = fiber.pendingProps;
                    didNotFindHydratableTextInstance(parentType, parentProps, parentInstance, _text);
                    break;
                }

                break;
              }

            default:
              return;
          }
        }
      }

      function tryHydrate(fiber, nextInstance) {
        switch (fiber.tag) {
          case HostComponent:
            {
              var type = fiber.type;
              var props = fiber.pendingProps;
              var instance = canHydrateInstance(nextInstance, type, props);

              if (instance !== null) {
                fiber.stateNode = instance;
                return true;
              }

              return false;
            }

          case HostText:
            {
              var text = fiber.pendingProps;
              var textInstance = canHydrateTextInstance(nextInstance, text);

              if (textInstance !== null) {
                fiber.stateNode = textInstance;
                return true;
              }

              return false;
            }

          default:
            return false;
        }
      }

      function tryToClaimNextHydratableInstance(fiber) {
        if (!isHydrating) {
          return;
        }

        var nextInstance = nextHydratableInstance;

        if (!nextInstance) {
          // Nothing to hydrate. Make it an insertion.
          insertNonHydratedInstance(hydrationParentFiber, fiber);
          isHydrating = false;
          hydrationParentFiber = fiber;
          return;
        }

        if (!tryHydrate(fiber, nextInstance)) {
          // If we can't hydrate this instance let's try the next one.
          // We use this as a heuristic. It's based on intuition and not data so it
          // might be flawed or unnecessary.
          nextInstance = getNextHydratableSibling(nextInstance);

          if (!nextInstance || !tryHydrate(fiber, nextInstance)) {
            // Nothing to hydrate. Make it an insertion.
            insertNonHydratedInstance(hydrationParentFiber, fiber);
            isHydrating = false;
            hydrationParentFiber = fiber;
            return;
          } // We matched the next one, we'll now assume that the first one was
          // superfluous and we'll delete it. Since we can't eagerly delete it
          // we'll have to schedule a deletion. To do that, this node needs a dummy
          // fiber associated with it.


          deleteHydratableInstance(hydrationParentFiber, nextHydratableInstance);
        }

        hydrationParentFiber = fiber;
        nextHydratableInstance = getFirstHydratableChild(nextInstance);
      }

      function prepareToHydrateHostInstance(fiber, rootContainerInstance, hostContext) {
        var instance = fiber.stateNode;
        var updatePayload = hydrateInstance(instance, fiber.type, fiber.memoizedProps, rootContainerInstance, hostContext, fiber); // TODO: Type this specific to this type of component.

        fiber.updateQueue = updatePayload; // If the update payload indicates that there is a change or if there
        // is a new ref we mark this as an update.

        if (updatePayload !== null) {
          return true;
        }

        return false;
      }

      function prepareToHydrateHostTextInstance(fiber) {
        var textInstance = fiber.stateNode;
        var textContent = fiber.memoizedProps;
        var shouldUpdate = hydrateTextInstance(textInstance, textContent, fiber);
        {
          if (shouldUpdate) {
            // We assume that prepareToHydrateHostTextInstance is called in a context where the
            // hydration parent is the parent host component of this host text.
            var returnFiber = hydrationParentFiber;

            if (returnFiber !== null) {
              switch (returnFiber.tag) {
                case HostRoot:
                  {
                    var parentContainer = returnFiber.stateNode.containerInfo;
                    didNotMatchHydratedContainerTextInstance(parentContainer, textInstance, textContent);
                    break;
                  }

                case HostComponent:
                  {
                    var parentType = returnFiber.type;
                    var parentProps = returnFiber.memoizedProps;
                    var parentInstance = returnFiber.stateNode;
                    didNotMatchHydratedTextInstance(parentType, parentProps, parentInstance, textInstance, textContent);
                    break;
                  }
              }
            }
          }
        }
        return shouldUpdate;
      }

      function popToNextHostParent(fiber) {
        var parent = fiber['return'];

        while (parent !== null && parent.tag !== HostComponent && parent.tag !== HostRoot) {
          parent = parent['return'];
        }

        hydrationParentFiber = parent;
      }

      function popHydrationState(fiber) {
        if (fiber !== hydrationParentFiber) {
          // We're deeper than the current hydration context, inside an inserted
          // tree.
          return false;
        }

        if (!isHydrating) {
          // If we're not currently hydrating but we're in a hydration context, then
          // we were an insertion and now need to pop up reenter hydration of our
          // siblings.
          popToNextHostParent(fiber);
          isHydrating = true;
          return false;
        }

        var type = fiber.type; // If we have any remaining hydratable nodes, we need to delete them now.
        // We only do this deeper than head and body since they tend to have random
        // other nodes in them. We also ignore components with pure text content in
        // side of them.
        // TODO: Better heuristic.

        if (fiber.tag !== HostComponent || type !== 'head' && type !== 'body' && !shouldSetTextContent(type, fiber.memoizedProps)) {
          var nextInstance = nextHydratableInstance;

          while (nextInstance) {
            deleteHydratableInstance(fiber, nextInstance);
            nextInstance = getNextHydratableSibling(nextInstance);
          }
        }

        popToNextHostParent(fiber);
        nextHydratableInstance = hydrationParentFiber ? getNextHydratableSibling(fiber.stateNode) : null;
        return true;
      }

      function resetHydrationState() {
        hydrationParentFiber = null;
        nextHydratableInstance = null;
        isHydrating = false;
      }

      return {
        enterHydrationState: enterHydrationState,
        resetHydrationState: resetHydrationState,
        tryToClaimNextHydratableInstance: tryToClaimNextHydratableInstance,
        prepareToHydrateHostInstance: prepareToHydrateHostInstance,
        prepareToHydrateHostTextInstance: prepareToHydrateHostTextInstance,
        popHydrationState: popHydrationState
      };
    }; // This lets us hook into Fiber to debug what it's doing.
    // See https://github.com/facebook/react/pull/8033.
    // This is not part of the public API, not even for React DevTools.
    // You may only inject a debugTool if you work on React Fiber itself.


    var ReactFiberInstrumentation = {
      debugTool: null
    };
    var ReactFiberInstrumentation_1 = ReactFiberInstrumentation;

    var defaultShowDialog = function defaultShowDialog(capturedError) {
      return true;
    };

    var showDialog = defaultShowDialog;

    function logCapturedError(capturedError) {
      var logError = showDialog(capturedError); // Allow injected showDialog() to prevent default console.error logging.
      // This enables renderers like ReactNative to better manage redbox behavior.

      if (logError === false) {
        return;
      }

      var error = capturedError.error;
      var suppressLogging = error && error.suppressReactErrorLogging;

      if (suppressLogging) {
        return;
      }

      {
        var componentName = capturedError.componentName,
            componentStack = capturedError.componentStack,
            errorBoundaryName = capturedError.errorBoundaryName,
            errorBoundaryFound = capturedError.errorBoundaryFound,
            willRetry = capturedError.willRetry;
        var componentNameMessage = componentName ? 'The above error occurred in the <' + componentName + '> component:' : 'The above error occurred in one of your React components:';
        var errorBoundaryMessage = void 0; // errorBoundaryFound check is sufficient; errorBoundaryName check is to satisfy Flow.

        if (errorBoundaryFound && errorBoundaryName) {
          if (willRetry) {
            errorBoundaryMessage = 'React will try to recreate this component tree from scratch ' + ('using the error boundary you provided, ' + errorBoundaryName + '.');
          } else {
            errorBoundaryMessage = 'This error was initially handled by the error boundary ' + errorBoundaryName + '.\n' + 'Recreating the tree from scratch failed so React will unmount the tree.';
          }
        } else {
          errorBoundaryMessage = 'Consider adding an error boundary to your tree to customize error handling behavior.\n' + 'Visit https://fb.me/react-error-boundaries to learn more about error boundaries.';
        }

        var combinedMessage = '' + componentNameMessage + componentStack + '\n\n' + ('' + errorBoundaryMessage); // In development, we provide our own message with just the component stack.
        // We don't include the original error message and JS stack because the browser
        // has already printed it. Even if the application swallows the error, it is still
        // displayed by the browser thanks to the DEV-only fake event trick in ReactErrorUtils.

        console.error(combinedMessage);
      }
    }

    var invokeGuardedCallback = ReactErrorUtils.invokeGuardedCallback;
    var hasCaughtError = ReactErrorUtils.hasCaughtError;
    var clearCaughtError = ReactErrorUtils.clearCaughtError;
    {
      var didWarnAboutStateTransition = false;
      var didWarnSetStateChildContext = false;
      var didWarnStateUpdateForUnmountedComponent = {};

      var warnAboutUpdateOnUnmounted = function warnAboutUpdateOnUnmounted(fiber) {
        var componentName = getComponentName(fiber) || 'ReactClass';

        if (didWarnStateUpdateForUnmountedComponent[componentName]) {
          return;
        }

        warning(false, 'Can only update a mounted or mounting ' + 'component. This usually means you called setState, replaceState, ' + 'or forceUpdate on an unmounted component. This is a no-op.\n\nPlease ' + 'check the code for the %s component.', componentName);
        didWarnStateUpdateForUnmountedComponent[componentName] = true;
      };

      var warnAboutInvalidUpdates = function warnAboutInvalidUpdates(instance) {
        switch (ReactDebugCurrentFiber.phase) {
          case 'getChildContext':
            if (didWarnSetStateChildContext) {
              return;
            }

            warning(false, 'setState(...): Cannot call setState() inside getChildContext()');
            didWarnSetStateChildContext = true;
            break;

          case 'render':
            if (didWarnAboutStateTransition) {
              return;
            }

            warning(false, 'Cannot update during an existing state transition (such as within ' + "`render` or another component's constructor). Render methods should " + 'be a pure function of props and state; constructor side-effects are ' + 'an anti-pattern, but can be moved to `componentWillMount`.');
            didWarnAboutStateTransition = true;
            break;
        }
      };
    }

    var ReactFiberScheduler = function ReactFiberScheduler(config) {
      var hostContext = ReactFiberHostContext(config);
      var hydrationContext = ReactFiberHydrationContext(config);
      var popHostContainer = hostContext.popHostContainer,
          popHostContext = hostContext.popHostContext,
          resetHostContainer = hostContext.resetHostContainer;

      var _ReactFiberBeginWork = ReactFiberBeginWork(config, hostContext, hydrationContext, scheduleWork, computeExpirationForFiber),
          beginWork = _ReactFiberBeginWork.beginWork,
          beginFailedWork = _ReactFiberBeginWork.beginFailedWork;

      var _ReactFiberCompleteWo = ReactFiberCompleteWork(config, hostContext, hydrationContext),
          completeWork = _ReactFiberCompleteWo.completeWork;

      var _ReactFiberCommitWork = ReactFiberCommitWork(config, captureError),
          commitResetTextContent = _ReactFiberCommitWork.commitResetTextContent,
          commitPlacement = _ReactFiberCommitWork.commitPlacement,
          commitDeletion = _ReactFiberCommitWork.commitDeletion,
          commitWork = _ReactFiberCommitWork.commitWork,
          commitLifeCycles = _ReactFiberCommitWork.commitLifeCycles,
          commitAttachRef = _ReactFiberCommitWork.commitAttachRef,
          commitDetachRef = _ReactFiberCommitWork.commitDetachRef;

      var now = config.now,
          scheduleDeferredCallback = config.scheduleDeferredCallback,
          cancelDeferredCallback = config.cancelDeferredCallback,
          useSyncScheduling = config.useSyncScheduling,
          prepareForCommit = config.prepareForCommit,
          resetAfterCommit = config.resetAfterCommit; // Represents the current time in ms.

      var startTime = now();
      var mostRecentCurrentTime = msToExpirationTime(0); // Represents the expiration time that incoming updates should use. (If this
      // is NoWork, use the default strategy: async updates in async mode, sync
      // updates in sync mode.)

      var expirationContext = NoWork;
      var isWorking = false; // The next work in progress fiber that we're currently working on.

      var nextUnitOfWork = null;
      var nextRoot = null; // The time at which we're currently rendering work.

      var nextRenderExpirationTime = NoWork; // The next fiber with an effect that we're currently committing.

      var nextEffect = null; // Keep track of which fibers have captured an error that need to be handled.
      // Work is removed from this collection after componentDidCatch is called.

      var capturedErrors = null; // Keep track of which fibers have failed during the current batch of work.
      // This is a different set than capturedErrors, because it is not reset until
      // the end of the batch. This is needed to propagate errors correctly if a
      // subtree fails more than once.

      var failedBoundaries = null; // Error boundaries that captured an error during the current commit.

      var commitPhaseBoundaries = null;
      var firstUncaughtError = null;
      var didFatal = false;
      var isCommitting = false;
      var isUnmounting = false; // Used for performance tracking.

      var interruptedBy = null;

      function resetContextStack() {
        // Reset the stack
        reset(); // Reset the cursors

        resetContext();
        resetHostContainer();
      }

      function commitAllHostEffects() {
        while (nextEffect !== null) {
          {
            ReactDebugCurrentFiber.setCurrentFiber(nextEffect);
          }
          recordEffect();
          var effectTag = nextEffect.effectTag;

          if (effectTag & ContentReset) {
            commitResetTextContent(nextEffect);
          }

          if (effectTag & Ref) {
            var current = nextEffect.alternate;

            if (current !== null) {
              commitDetachRef(current);
            }
          } // The following switch statement is only concerned about placement,
          // updates, and deletions. To avoid needing to add a case for every
          // possible bitmap value, we remove the secondary effects from the
          // effect tag and switch on that value.


          var primaryEffectTag = effectTag & ~(Callback | Err | ContentReset | Ref | PerformedWork);

          switch (primaryEffectTag) {
            case Placement:
              {
                commitPlacement(nextEffect); // Clear the "placement" from effect tag so that we know that this is inserted, before
                // any life-cycles like componentDidMount gets called.
                // TODO: findDOMNode doesn't rely on this any more but isMounted
                // does and isMounted is deprecated anyway so we should be able
                // to kill this.

                nextEffect.effectTag &= ~Placement;
                break;
              }

            case PlacementAndUpdate:
              {
                // Placement
                commitPlacement(nextEffect); // Clear the "placement" from effect tag so that we know that this is inserted, before
                // any life-cycles like componentDidMount gets called.

                nextEffect.effectTag &= ~Placement; // Update

                var _current = nextEffect.alternate;
                commitWork(_current, nextEffect);
                break;
              }

            case Update:
              {
                var _current2 = nextEffect.alternate;
                commitWork(_current2, nextEffect);
                break;
              }

            case Deletion:
              {
                isUnmounting = true;
                commitDeletion(nextEffect);
                isUnmounting = false;
                break;
              }
          }

          nextEffect = nextEffect.nextEffect;
        }

        {
          ReactDebugCurrentFiber.resetCurrentFiber();
        }
      }

      function commitAllLifeCycles() {
        while (nextEffect !== null) {
          var effectTag = nextEffect.effectTag;

          if (effectTag & (Update | Callback)) {
            recordEffect();
            var current = nextEffect.alternate;
            commitLifeCycles(current, nextEffect);
          }

          if (effectTag & Ref) {
            recordEffect();
            commitAttachRef(nextEffect);
          }

          if (effectTag & Err) {
            recordEffect();
            commitErrorHandling(nextEffect);
          }

          var next = nextEffect.nextEffect; // Ensure that we clean these up so that we don't accidentally keep them.
          // I'm not actually sure this matters because we can't reset firstEffect
          // and lastEffect since they're on every node, not just the effectful
          // ones. So we have to clean everything as we reuse nodes anyway.

          nextEffect.nextEffect = null; // Ensure that we reset the effectTag here so that we can rely on effect
          // tags to reason about the current life-cycle.

          nextEffect = next;
        }
      }

      function commitRoot(finishedWork) {
        // We keep track of this so that captureError can collect any boundaries
        // that capture an error during the commit phase. The reason these aren't
        // local to this function is because errors that occur during cWU are
        // captured elsewhere, to prevent the unmount from being interrupted.
        isWorking = true;
        isCommitting = true;
        startCommitTimer();
        var root = finishedWork.stateNode;
        !(root.current !== finishedWork) ? invariant(false, 'Cannot commit the same tree as before. This is probably a bug related to the return field. This error is likely caused by a bug in React. Please file an issue.') : void 0;
        root.isReadyForCommit = false; // Reset this to null before calling lifecycles

        ReactCurrentOwner.current = null;
        var firstEffect = void 0;

        if (finishedWork.effectTag > PerformedWork) {
          // A fiber's effect list consists only of its children, not itself. So if
          // the root has an effect, we need to add it to the end of the list. The
          // resulting list is the set that would belong to the root's parent, if
          // it had one; that is, all the effects in the tree including the root.
          if (finishedWork.lastEffect !== null) {
            finishedWork.lastEffect.nextEffect = finishedWork;
            firstEffect = finishedWork.firstEffect;
          } else {
            firstEffect = finishedWork;
          }
        } else {
          // There is no effect on the root.
          firstEffect = finishedWork.firstEffect;
        }

        prepareForCommit(); // Commit all the side-effects within a tree. We'll do this in two passes.
        // The first pass performs all the host insertions, updates, deletions and
        // ref unmounts.

        nextEffect = firstEffect;
        startCommitHostEffectsTimer();

        while (nextEffect !== null) {
          var didError = false;

          var _error = void 0;

          {
            invokeGuardedCallback(null, commitAllHostEffects, null);

            if (hasCaughtError()) {
              didError = true;
              _error = clearCaughtError();
            }
          }

          if (didError) {
            !(nextEffect !== null) ? invariant(false, 'Should have next effect. This error is likely caused by a bug in React. Please file an issue.') : void 0;
            captureError(nextEffect, _error); // Clean-up

            if (nextEffect !== null) {
              nextEffect = nextEffect.nextEffect;
            }
          }
        }

        stopCommitHostEffectsTimer();
        resetAfterCommit(); // The work-in-progress tree is now the current tree. This must come after
        // the first pass of the commit phase, so that the previous tree is still
        // current during componentWillUnmount, but before the second pass, so that
        // the finished work is current during componentDidMount/Update.

        root.current = finishedWork; // In the second pass we'll perform all life-cycles and ref callbacks.
        // Life-cycles happen as a separate pass so that all placements, updates,
        // and deletions in the entire tree have already been invoked.
        // This pass also triggers any renderer-specific initial effects.

        nextEffect = firstEffect;
        startCommitLifeCyclesTimer();

        while (nextEffect !== null) {
          var _didError = false;

          var _error2 = void 0;

          {
            invokeGuardedCallback(null, commitAllLifeCycles, null);

            if (hasCaughtError()) {
              _didError = true;
              _error2 = clearCaughtError();
            }
          }

          if (_didError) {
            !(nextEffect !== null) ? invariant(false, 'Should have next effect. This error is likely caused by a bug in React. Please file an issue.') : void 0;
            captureError(nextEffect, _error2);

            if (nextEffect !== null) {
              nextEffect = nextEffect.nextEffect;
            }
          }
        }

        isCommitting = false;
        isWorking = false;
        stopCommitLifeCyclesTimer();
        stopCommitTimer();

        if (typeof onCommitRoot === 'function') {
          onCommitRoot(finishedWork.stateNode);
        }

        if (true && ReactFiberInstrumentation_1.debugTool) {
          ReactFiberInstrumentation_1.debugTool.onCommitWork(finishedWork);
        } // If we caught any errors during this commit, schedule their boundaries
        // to update.


        if (commitPhaseBoundaries) {
          commitPhaseBoundaries.forEach(scheduleErrorRecovery);
          commitPhaseBoundaries = null;
        }

        if (firstUncaughtError !== null) {
          var _error3 = firstUncaughtError;
          firstUncaughtError = null;
          onUncaughtError(_error3);
        }

        var remainingTime = root.current.expirationTime;

        if (remainingTime === NoWork) {
          capturedErrors = null;
          failedBoundaries = null;
        }

        return remainingTime;
      }

      function resetExpirationTime(workInProgress, renderTime) {
        if (renderTime !== Never && workInProgress.expirationTime === Never) {
          // The children of this component are hidden. Don't bubble their
          // expiration times.
          return;
        } // Check for pending updates.


        var newExpirationTime = getUpdateExpirationTime(workInProgress); // TODO: Calls need to visit stateNode
        // Bubble up the earliest expiration time.

        var child = workInProgress.child;

        while (child !== null) {
          if (child.expirationTime !== NoWork && (newExpirationTime === NoWork || newExpirationTime > child.expirationTime)) {
            newExpirationTime = child.expirationTime;
          }

          child = child.sibling;
        }

        workInProgress.expirationTime = newExpirationTime;
      }

      function completeUnitOfWork(workInProgress) {
        while (true) {
          // The current, flushed, state of this fiber is the alternate.
          // Ideally nothing should rely on this, but relying on it here
          // means that we don't need an additional field on the work in
          // progress.
          var current = workInProgress.alternate;
          {
            ReactDebugCurrentFiber.setCurrentFiber(workInProgress);
          }
          var next = completeWork(current, workInProgress, nextRenderExpirationTime);
          {
            ReactDebugCurrentFiber.resetCurrentFiber();
          }
          var returnFiber = workInProgress['return'];
          var siblingFiber = workInProgress.sibling;
          resetExpirationTime(workInProgress, nextRenderExpirationTime);

          if (next !== null) {
            stopWorkTimer(workInProgress);

            if (true && ReactFiberInstrumentation_1.debugTool) {
              ReactFiberInstrumentation_1.debugTool.onCompleteWork(workInProgress);
            } // If completing this work spawned new work, do that next. We'll come
            // back here again.


            return next;
          }

          if (returnFiber !== null) {
            // Append all the effects of the subtree and this fiber onto the effect
            // list of the parent. The completion order of the children affects the
            // side-effect order.
            if (returnFiber.firstEffect === null) {
              returnFiber.firstEffect = workInProgress.firstEffect;
            }

            if (workInProgress.lastEffect !== null) {
              if (returnFiber.lastEffect !== null) {
                returnFiber.lastEffect.nextEffect = workInProgress.firstEffect;
              }

              returnFiber.lastEffect = workInProgress.lastEffect;
            } // If this fiber had side-effects, we append it AFTER the children's
            // side-effects. We can perform certain side-effects earlier if
            // needed, by doing multiple passes over the effect list. We don't want
            // to schedule our own side-effect on our own list because if end up
            // reusing children we'll schedule this effect onto itself since we're
            // at the end.


            var effectTag = workInProgress.effectTag; // Skip both NoWork and PerformedWork tags when creating the effect list.
            // PerformedWork effect is read by React DevTools but shouldn't be committed.

            if (effectTag > PerformedWork) {
              if (returnFiber.lastEffect !== null) {
                returnFiber.lastEffect.nextEffect = workInProgress;
              } else {
                returnFiber.firstEffect = workInProgress;
              }

              returnFiber.lastEffect = workInProgress;
            }
          }

          stopWorkTimer(workInProgress);

          if (true && ReactFiberInstrumentation_1.debugTool) {
            ReactFiberInstrumentation_1.debugTool.onCompleteWork(workInProgress);
          }

          if (siblingFiber !== null) {
            // If there is more work to do in this returnFiber, do that next.
            return siblingFiber;
          } else if (returnFiber !== null) {
            // If there's no more work in this returnFiber. Complete the returnFiber.
            workInProgress = returnFiber;
            continue;
          } else {
            // We've reached the root.
            var root = workInProgress.stateNode;
            root.isReadyForCommit = true;
            return null;
          }
        } // Without this explicit null return Flow complains of invalid return type
        // TODO Remove the above while(true) loop
        // eslint-disable-next-line no-unreachable


        return null;
      }

      function performUnitOfWork(workInProgress) {
        // The current, flushed, state of this fiber is the alternate.
        // Ideally nothing should rely on this, but relying on it here
        // means that we don't need an additional field on the work in
        // progress.
        var current = workInProgress.alternate; // See if beginning this work spawns more work.

        startWorkTimer(workInProgress);
        {
          ReactDebugCurrentFiber.setCurrentFiber(workInProgress);
        }
        var next = beginWork(current, workInProgress, nextRenderExpirationTime);
        {
          ReactDebugCurrentFiber.resetCurrentFiber();
        }

        if (true && ReactFiberInstrumentation_1.debugTool) {
          ReactFiberInstrumentation_1.debugTool.onBeginWork(workInProgress);
        }

        if (next === null) {
          // If this doesn't spawn new work, complete the current work.
          next = completeUnitOfWork(workInProgress);
        }

        ReactCurrentOwner.current = null;
        return next;
      }

      function performFailedUnitOfWork(workInProgress) {
        // The current, flushed, state of this fiber is the alternate.
        // Ideally nothing should rely on this, but relying on it here
        // means that we don't need an additional field on the work in
        // progress.
        var current = workInProgress.alternate; // See if beginning this work spawns more work.

        startWorkTimer(workInProgress);
        {
          ReactDebugCurrentFiber.setCurrentFiber(workInProgress);
        }
        var next = beginFailedWork(current, workInProgress, nextRenderExpirationTime);
        {
          ReactDebugCurrentFiber.resetCurrentFiber();
        }

        if (true && ReactFiberInstrumentation_1.debugTool) {
          ReactFiberInstrumentation_1.debugTool.onBeginWork(workInProgress);
        }

        if (next === null) {
          // If this doesn't spawn new work, complete the current work.
          next = completeUnitOfWork(workInProgress);
        }

        ReactCurrentOwner.current = null;
        return next;
      }

      function workLoop(expirationTime) {
        if (capturedErrors !== null) {
          // If there are unhandled errors, switch to the slow work loop.
          // TODO: How to avoid this check in the fast path? Maybe the renderer
          // could keep track of which roots have unhandled errors and call a
          // forked version of renderRoot.
          slowWorkLoopThatChecksForFailedWork(expirationTime);
          return;
        }

        if (nextRenderExpirationTime === NoWork || nextRenderExpirationTime > expirationTime) {
          return;
        }

        if (nextRenderExpirationTime <= mostRecentCurrentTime) {
          // Flush all expired work.
          while (nextUnitOfWork !== null) {
            nextUnitOfWork = performUnitOfWork(nextUnitOfWork);
          }
        } else {
          // Flush asynchronous work until the deadline runs out of time.
          while (nextUnitOfWork !== null && !shouldYield()) {
            nextUnitOfWork = performUnitOfWork(nextUnitOfWork);
          }
        }
      }

      function slowWorkLoopThatChecksForFailedWork(expirationTime) {
        if (nextRenderExpirationTime === NoWork || nextRenderExpirationTime > expirationTime) {
          return;
        }

        if (nextRenderExpirationTime <= mostRecentCurrentTime) {
          // Flush all expired work.
          while (nextUnitOfWork !== null) {
            if (hasCapturedError(nextUnitOfWork)) {
              // Use a forked version of performUnitOfWork
              nextUnitOfWork = performFailedUnitOfWork(nextUnitOfWork);
            } else {
              nextUnitOfWork = performUnitOfWork(nextUnitOfWork);
            }
          }
        } else {
          // Flush asynchronous work until the deadline runs out of time.
          while (nextUnitOfWork !== null && !shouldYield()) {
            if (hasCapturedError(nextUnitOfWork)) {
              // Use a forked version of performUnitOfWork
              nextUnitOfWork = performFailedUnitOfWork(nextUnitOfWork);
            } else {
              nextUnitOfWork = performUnitOfWork(nextUnitOfWork);
            }
          }
        }
      }

      function renderRootCatchBlock(root, failedWork, boundary, expirationTime) {
        // We're going to restart the error boundary that captured the error.
        // Conceptually, we're unwinding the stack. We need to unwind the
        // context stack, too.
        unwindContexts(failedWork, boundary); // Restart the error boundary using a forked version of
        // performUnitOfWork that deletes the boundary's children. The entire
        // failed subree will be unmounted. During the commit phase, a special
        // lifecycle method is called on the error boundary, which triggers
        // a re-render.

        nextUnitOfWork = performFailedUnitOfWork(boundary); // Continue working.

        workLoop(expirationTime);
      }

      function renderRoot(root, expirationTime) {
        !!isWorking ? invariant(false, 'renderRoot was called recursively. This error is likely caused by a bug in React. Please file an issue.') : void 0;
        isWorking = true; // We're about to mutate the work-in-progress tree. If the root was pending
        // commit, it no longer is: we'll need to complete it again.

        root.isReadyForCommit = false; // Check if we're starting from a fresh stack, or if we're resuming from
        // previously yielded work.

        if (root !== nextRoot || expirationTime !== nextRenderExpirationTime || nextUnitOfWork === null) {
          // Reset the stack and start working from the root.
          resetContextStack();
          nextRoot = root;
          nextRenderExpirationTime = expirationTime;
          nextUnitOfWork = createWorkInProgress(nextRoot.current, null, expirationTime);
        }

        startWorkLoopTimer(nextUnitOfWork);
        var didError = false;
        var error = null;
        {
          invokeGuardedCallback(null, workLoop, null, expirationTime);

          if (hasCaughtError()) {
            didError = true;
            error = clearCaughtError();
          }
        } // An error was thrown during the render phase.

        while (didError) {
          if (didFatal) {
            // This was a fatal error. Don't attempt to recover from it.
            firstUncaughtError = error;
            break;
          }

          var failedWork = nextUnitOfWork;

          if (failedWork === null) {
            // An error was thrown but there's no current unit of work. This can
            // happen during the commit phase if there's a bug in the renderer.
            didFatal = true;
            continue;
          } // "Capture" the error by finding the nearest boundary. If there is no
          // error boundary, we use the root.


          var boundary = captureError(failedWork, error);
          !(boundary !== null) ? invariant(false, 'Should have found an error boundary. This error is likely caused by a bug in React. Please file an issue.') : void 0;

          if (didFatal) {
            // The error we just captured was a fatal error. This happens
            // when the error propagates to the root more than once.
            continue;
          }

          didError = false;
          error = null;
          {
            invokeGuardedCallback(null, renderRootCatchBlock, null, root, failedWork, boundary, expirationTime);

            if (hasCaughtError()) {
              didError = true;
              error = clearCaughtError();
              continue;
            }
          } // We're finished working. Exit the error loop.

          break;
        }

        var uncaughtError = firstUncaughtError; // We're done performing work. Time to clean up.

        stopWorkLoopTimer(interruptedBy);
        interruptedBy = null;
        isWorking = false;
        didFatal = false;
        firstUncaughtError = null;

        if (uncaughtError !== null) {
          onUncaughtError(uncaughtError);
        }

        return root.isReadyForCommit ? root.current.alternate : null;
      } // Returns the boundary that captured the error, or null if the error is ignored


      function captureError(failedWork, error) {
        // It is no longer valid because we exited the user code.
        ReactCurrentOwner.current = null;
        {
          ReactDebugCurrentFiber.resetCurrentFiber();
        } // Search for the nearest error boundary.

        var boundary = null; // Passed to logCapturedError()

        var errorBoundaryFound = false;
        var willRetry = false;
        var errorBoundaryName = null; // Host containers are a special case. If the failed work itself is a host
        // container, then it acts as its own boundary. In all other cases, we
        // ignore the work itself and only search through the parents.

        if (failedWork.tag === HostRoot) {
          boundary = failedWork;

          if (isFailedBoundary(failedWork)) {
            // If this root already failed, there must have been an error when
            // attempting to unmount it. This is a worst-case scenario and
            // should only be possible if there's a bug in the renderer.
            didFatal = true;
          }
        } else {
          var node = failedWork['return'];

          while (node !== null && boundary === null) {
            if (node.tag === ClassComponent) {
              var instance = node.stateNode;

              if (typeof instance.componentDidCatch === 'function') {
                errorBoundaryFound = true;
                errorBoundaryName = getComponentName(node); // Found an error boundary!

                boundary = node;
                willRetry = true;
              }
            } else if (node.tag === HostRoot) {
              // Treat the root like a no-op error boundary
              boundary = node;
            }

            if (isFailedBoundary(node)) {
              // This boundary is already in a failed state.
              // If we're currently unmounting, that means this error was
              // thrown while unmounting a failed subtree. We should ignore
              // the error.
              if (isUnmounting) {
                return null;
              } // If we're in the commit phase, we should check to see if
              // this boundary already captured an error during this commit.
              // This case exists because multiple errors can be thrown during
              // a single commit without interruption.


              if (commitPhaseBoundaries !== null && (commitPhaseBoundaries.has(node) || node.alternate !== null && commitPhaseBoundaries.has(node.alternate))) {
                // If so, we should ignore this error.
                return null;
              } // The error should propagate to the next boundary - we keep looking.


              boundary = null;
              willRetry = false;
            }

            node = node['return'];
          }
        }

        if (boundary !== null) {
          // Add to the collection of failed boundaries. This lets us know that
          // subsequent errors in this subtree should propagate to the next boundary.
          if (failedBoundaries === null) {
            failedBoundaries = new Set();
          }

          failedBoundaries.add(boundary); // This method is unsafe outside of the begin and complete phases.
          // We might be in the commit phase when an error is captured.
          // The risk is that the return path from this Fiber may not be accurate.
          // That risk is acceptable given the benefit of providing users more context.

          var _componentStack = getStackAddendumByWorkInProgressFiber(failedWork);

          var _componentName = getComponentName(failedWork); // Add to the collection of captured errors. This is stored as a global
          // map of errors and their component stack location keyed by the boundaries
          // that capture them. We mostly use this Map as a Set; it's a Map only to
          // avoid adding a field to Fiber to store the error.


          if (capturedErrors === null) {
            capturedErrors = new Map();
          }

          var capturedError = {
            componentName: _componentName,
            componentStack: _componentStack,
            error: error,
            errorBoundary: errorBoundaryFound ? boundary.stateNode : null,
            errorBoundaryFound: errorBoundaryFound,
            errorBoundaryName: errorBoundaryName,
            willRetry: willRetry
          };
          capturedErrors.set(boundary, capturedError);

          try {
            logCapturedError(capturedError);
          } catch (e) {
            // Prevent cycle if logCapturedError() throws.
            // A cycle may still occur if logCapturedError renders a component that throws.
            var suppressLogging = e && e.suppressReactErrorLogging;

            if (!suppressLogging) {
              console.error(e);
            }
          } // If we're in the commit phase, defer scheduling an update on the
          // boundary until after the commit is complete


          if (isCommitting) {
            if (commitPhaseBoundaries === null) {
              commitPhaseBoundaries = new Set();
            }

            commitPhaseBoundaries.add(boundary);
          } else {
            // Otherwise, schedule an update now.
            // TODO: Is this actually necessary during the render phase? Is it
            // possible to unwind and continue rendering at the same priority,
            // without corrupting internal state?
            scheduleErrorRecovery(boundary);
          }

          return boundary;
        } else if (firstUncaughtError === null) {
          // If no boundary is found, we'll need to throw the error
          firstUncaughtError = error;
        }

        return null;
      }

      function hasCapturedError(fiber) {
        // TODO: capturedErrors should store the boundary instance, to avoid needing
        // to check the alternate.
        return capturedErrors !== null && (capturedErrors.has(fiber) || fiber.alternate !== null && capturedErrors.has(fiber.alternate));
      }

      function isFailedBoundary(fiber) {
        // TODO: failedBoundaries should store the boundary instance, to avoid
        // needing to check the alternate.
        return failedBoundaries !== null && (failedBoundaries.has(fiber) || fiber.alternate !== null && failedBoundaries.has(fiber.alternate));
      }

      function commitErrorHandling(effectfulFiber) {
        var capturedError = void 0;

        if (capturedErrors !== null) {
          capturedError = capturedErrors.get(effectfulFiber);
          capturedErrors['delete'](effectfulFiber);

          if (capturedError == null) {
            if (effectfulFiber.alternate !== null) {
              effectfulFiber = effectfulFiber.alternate;
              capturedError = capturedErrors.get(effectfulFiber);
              capturedErrors['delete'](effectfulFiber);
            }
          }
        }

        !(capturedError != null) ? invariant(false, 'No error for given unit of work. This error is likely caused by a bug in React. Please file an issue.') : void 0;

        switch (effectfulFiber.tag) {
          case ClassComponent:
            var instance = effectfulFiber.stateNode;
            var info = {
              componentStack: capturedError.componentStack
            }; // Allow the boundary to handle the error, usually by scheduling
            // an update to itself

            instance.componentDidCatch(capturedError.error, info);
            return;

          case HostRoot:
            if (firstUncaughtError === null) {
              firstUncaughtError = capturedError.error;
            }

            return;

          default:
            invariant(false, 'Invalid type of work. This error is likely caused by a bug in React. Please file an issue.');
        }
      }

      function unwindContexts(from, to) {
        var node = from;

        while (node !== null) {
          switch (node.tag) {
            case ClassComponent:
              popContextProvider(node);
              break;

            case HostComponent:
              popHostContext(node);
              break;

            case HostRoot:
              popHostContainer(node);
              break;

            case HostPortal:
              popHostContainer(node);
              break;
          }

          if (node === to || node.alternate === to) {
            stopFailedWorkTimer(node);
            break;
          } else {
            stopWorkTimer(node);
          }

          node = node['return'];
        }
      }

      function computeAsyncExpiration() {
        // Given the current clock time, returns an expiration time. We use rounding
        // to batch like updates together.
        // Should complete within ~1000ms. 1200ms max.
        var currentTime = recalculateCurrentTime();
        var expirationMs = 1000;
        var bucketSizeMs = 200;
        return computeExpirationBucket(currentTime, expirationMs, bucketSizeMs);
      }

      function computeExpirationForFiber(fiber) {
        var expirationTime = void 0;

        if (expirationContext !== NoWork) {
          // An explicit expiration context was set;
          expirationTime = expirationContext;
        } else if (isWorking) {
          if (isCommitting) {
            // Updates that occur during the commit phase should have sync priority
            // by default.
            expirationTime = Sync;
          } else {
            // Updates during the render phase should expire at the same time as
            // the work that is being rendered.
            expirationTime = nextRenderExpirationTime;
          }
        } else {
          // No explicit expiration context was set, and we're not currently
          // performing work. Calculate a new expiration time.
          if (useSyncScheduling && !(fiber.internalContextTag & AsyncUpdates)) {
            // This is a sync update
            expirationTime = Sync;
          } else {
            // This is an async update
            expirationTime = computeAsyncExpiration();
          }
        }

        return expirationTime;
      }

      function scheduleWork(fiber, expirationTime) {
        return scheduleWorkImpl(fiber, expirationTime, false);
      }

      function checkRootNeedsClearing(root, fiber, expirationTime) {
        if (!isWorking && root === nextRoot && expirationTime < nextRenderExpirationTime) {
          // Restart the root from the top.
          if (nextUnitOfWork !== null) {
            // This is an interruption. (Used for performance tracking.)
            interruptedBy = fiber;
          }

          nextRoot = null;
          nextUnitOfWork = null;
          nextRenderExpirationTime = NoWork;
        }
      }

      function scheduleWorkImpl(fiber, expirationTime, isErrorRecovery) {
        recordScheduleUpdate();
        {
          if (!isErrorRecovery && fiber.tag === ClassComponent) {
            var instance = fiber.stateNode;
            warnAboutInvalidUpdates(instance);
          }
        }
        var node = fiber;

        while (node !== null) {
          // Walk the parent path to the root and update each node's
          // expiration time.
          if (node.expirationTime === NoWork || node.expirationTime > expirationTime) {
            node.expirationTime = expirationTime;
          }

          if (node.alternate !== null) {
            if (node.alternate.expirationTime === NoWork || node.alternate.expirationTime > expirationTime) {
              node.alternate.expirationTime = expirationTime;
            }
          }

          if (node['return'] === null) {
            if (node.tag === HostRoot) {
              var root = node.stateNode;
              checkRootNeedsClearing(root, fiber, expirationTime);
              requestWork(root, expirationTime);
              checkRootNeedsClearing(root, fiber, expirationTime);
            } else {
              {
                if (!isErrorRecovery && fiber.tag === ClassComponent) {
                  warnAboutUpdateOnUnmounted(fiber);
                }
              }
              return;
            }
          }

          node = node['return'];
        }
      }

      function scheduleErrorRecovery(fiber) {
        scheduleWorkImpl(fiber, Sync, true);
      }

      function recalculateCurrentTime() {
        // Subtract initial time so it fits inside 32bits
        var ms = now() - startTime;
        mostRecentCurrentTime = msToExpirationTime(ms);
        return mostRecentCurrentTime;
      }

      function deferredUpdates(fn) {
        var previousExpirationContext = expirationContext;
        expirationContext = computeAsyncExpiration();

        try {
          return fn();
        } finally {
          expirationContext = previousExpirationContext;
        }
      }

      function syncUpdates(fn) {
        var previousExpirationContext = expirationContext;
        expirationContext = Sync;

        try {
          return fn();
        } finally {
          expirationContext = previousExpirationContext;
        }
      } // TODO: Everything below this is written as if it has been lifted to the
      // renderers. I'll do this in a follow-up.
      // Linked-list of roots


      var firstScheduledRoot = null;
      var lastScheduledRoot = null;
      var callbackExpirationTime = NoWork;
      var callbackID = -1;
      var isRendering = false;
      var nextFlushedRoot = null;
      var nextFlushedExpirationTime = NoWork;
      var deadlineDidExpire = false;
      var hasUnhandledError = false;
      var unhandledError = null;
      var deadline = null;
      var isBatchingUpdates = false;
      var isUnbatchingUpdates = false; // Use these to prevent an infinite loop of nested updates

      var NESTED_UPDATE_LIMIT = 1000;
      var nestedUpdateCount = 0;
      var timeHeuristicForUnitOfWork = 1;

      function scheduleCallbackWithExpiration(expirationTime) {
        if (callbackExpirationTime !== NoWork) {
          // A callback is already scheduled. Check its expiration time (timeout).
          if (expirationTime > callbackExpirationTime) {
            // Existing callback has sufficient timeout. Exit.
            return;
          } else {
            // Existing callback has insufficient timeout. Cancel and schedule a
            // new one.
            cancelDeferredCallback(callbackID);
          } // The request callback timer is already running. Don't start a new one.

        } else {
          startRequestCallbackTimer();
        } // Compute a timeout for the given expiration time.


        var currentMs = now() - startTime;
        var expirationMs = expirationTimeToMs(expirationTime);
        var timeout = expirationMs - currentMs;
        callbackExpirationTime = expirationTime;
        callbackID = scheduleDeferredCallback(performAsyncWork, {
          timeout: timeout
        });
      } // requestWork is called by the scheduler whenever a root receives an update.
      // It's up to the renderer to call renderRoot at some point in the future.


      function requestWork(root, expirationTime) {
        if (nestedUpdateCount > NESTED_UPDATE_LIMIT) {
          invariant(false, 'Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.');
        } // Add the root to the schedule.
        // Check if this root is already part of the schedule.


        if (root.nextScheduledRoot === null) {
          // This root is not already scheduled. Add it.
          root.remainingExpirationTime = expirationTime;

          if (lastScheduledRoot === null) {
            firstScheduledRoot = lastScheduledRoot = root;
            root.nextScheduledRoot = root;
          } else {
            lastScheduledRoot.nextScheduledRoot = root;
            lastScheduledRoot = root;
            lastScheduledRoot.nextScheduledRoot = firstScheduledRoot;
          }
        } else {
          // This root is already scheduled, but its priority may have increased.
          var remainingExpirationTime = root.remainingExpirationTime;

          if (remainingExpirationTime === NoWork || expirationTime < remainingExpirationTime) {
            // Update the priority.
            root.remainingExpirationTime = expirationTime;
          }
        }

        if (isRendering) {
          // Prevent reentrancy. Remaining work will be scheduled at the end of
          // the currently rendering batch.
          return;
        }

        if (isBatchingUpdates) {
          // Flush work at the end of the batch.
          if (isUnbatchingUpdates) {
            // ...unless we're inside unbatchedUpdates, in which case we should
            // flush it now.
            nextFlushedRoot = root;
            nextFlushedExpirationTime = Sync;
            performWorkOnRoot(nextFlushedRoot, nextFlushedExpirationTime);
          }

          return;
        } // TODO: Get rid of Sync and use current time?


        if (expirationTime === Sync) {
          performWork(Sync, null);
        } else {
          scheduleCallbackWithExpiration(expirationTime);
        }
      }

      function findHighestPriorityRoot() {
        var highestPriorityWork = NoWork;
        var highestPriorityRoot = null;

        if (lastScheduledRoot !== null) {
          var previousScheduledRoot = lastScheduledRoot;
          var root = firstScheduledRoot;

          while (root !== null) {
            var remainingExpirationTime = root.remainingExpirationTime;

            if (remainingExpirationTime === NoWork) {
              // This root no longer has work. Remove it from the scheduler.
              // TODO: This check is redudant, but Flow is confused by the branch
              // below where we set lastScheduledRoot to null, even though we break
              // from the loop right after.
              !(previousScheduledRoot !== null && lastScheduledRoot !== null) ? invariant(false, 'Should have a previous and last root. This error is likely caused by a bug in React. Please file an issue.') : void 0;

              if (root === root.nextScheduledRoot) {
                // This is the only root in the list.
                root.nextScheduledRoot = null;
                firstScheduledRoot = lastScheduledRoot = null;
                break;
              } else if (root === firstScheduledRoot) {
                // This is the first root in the list.
                var next = root.nextScheduledRoot;
                firstScheduledRoot = next;
                lastScheduledRoot.nextScheduledRoot = next;
                root.nextScheduledRoot = null;
              } else if (root === lastScheduledRoot) {
                // This is the last root in the list.
                lastScheduledRoot = previousScheduledRoot;
                lastScheduledRoot.nextScheduledRoot = firstScheduledRoot;
                root.nextScheduledRoot = null;
                break;
              } else {
                previousScheduledRoot.nextScheduledRoot = root.nextScheduledRoot;
                root.nextScheduledRoot = null;
              }

              root = previousScheduledRoot.nextScheduledRoot;
            } else {
              if (highestPriorityWork === NoWork || remainingExpirationTime < highestPriorityWork) {
                // Update the priority, if it's higher
                highestPriorityWork = remainingExpirationTime;
                highestPriorityRoot = root;
              }

              if (root === lastScheduledRoot) {
                break;
              }

              previousScheduledRoot = root;
              root = root.nextScheduledRoot;
            }
          }
        } // If the next root is the same as the previous root, this is a nested
        // update. To prevent an infinite loop, increment the nested update count.


        var previousFlushedRoot = nextFlushedRoot;

        if (previousFlushedRoot !== null && previousFlushedRoot === highestPriorityRoot) {
          nestedUpdateCount++;
        } else {
          // Reset whenever we switch roots.
          nestedUpdateCount = 0;
        }

        nextFlushedRoot = highestPriorityRoot;
        nextFlushedExpirationTime = highestPriorityWork;
      }

      function performAsyncWork(dl) {
        performWork(NoWork, dl);
      }

      function performWork(minExpirationTime, dl) {
        deadline = dl; // Keep working on roots until there's no more work, or until the we reach
        // the deadline.

        findHighestPriorityRoot();

        if (enableUserTimingAPI && deadline !== null) {
          var didExpire = nextFlushedExpirationTime < recalculateCurrentTime();
          stopRequestCallbackTimer(didExpire);
        }

        while (nextFlushedRoot !== null && nextFlushedExpirationTime !== NoWork && (minExpirationTime === NoWork || nextFlushedExpirationTime <= minExpirationTime) && !deadlineDidExpire) {
          performWorkOnRoot(nextFlushedRoot, nextFlushedExpirationTime); // Find the next highest priority work.

          findHighestPriorityRoot();
        } // We're done flushing work. Either we ran out of time in this callback,
        // or there's no more work left with sufficient priority.
        // If we're inside a callback, set this to false since we just completed it.


        if (deadline !== null) {
          callbackExpirationTime = NoWork;
          callbackID = -1;
        } // If there's work left over, schedule a new callback.


        if (nextFlushedExpirationTime !== NoWork) {
          scheduleCallbackWithExpiration(nextFlushedExpirationTime);
        } // Clean-up.


        deadline = null;
        deadlineDidExpire = false;
        nestedUpdateCount = 0;

        if (hasUnhandledError) {
          var _error4 = unhandledError;
          unhandledError = null;
          hasUnhandledError = false;
          throw _error4;
        }
      }

      function performWorkOnRoot(root, expirationTime) {
        !!isRendering ? invariant(false, 'performWorkOnRoot was called recursively. This error is likely caused by a bug in React. Please file an issue.') : void 0;
        isRendering = true; // Check if this is async work or sync/expired work.
        // TODO: Pass current time as argument to renderRoot, commitRoot

        if (expirationTime <= recalculateCurrentTime()) {
          // Flush sync work.
          var finishedWork = root.finishedWork;

          if (finishedWork !== null) {
            // This root is already complete. We can commit it.
            root.finishedWork = null;
            root.remainingExpirationTime = commitRoot(finishedWork);
          } else {
            root.finishedWork = null;
            finishedWork = renderRoot(root, expirationTime);

            if (finishedWork !== null) {
              // We've completed the root. Commit it.
              root.remainingExpirationTime = commitRoot(finishedWork);
            }
          }
        } else {
          // Flush async work.
          var _finishedWork = root.finishedWork;

          if (_finishedWork !== null) {
            // This root is already complete. We can commit it.
            root.finishedWork = null;
            root.remainingExpirationTime = commitRoot(_finishedWork);
          } else {
            root.finishedWork = null;
            _finishedWork = renderRoot(root, expirationTime);

            if (_finishedWork !== null) {
              // We've completed the root. Check the deadline one more time
              // before committing.
              if (!shouldYield()) {
                // Still time left. Commit the root.
                root.remainingExpirationTime = commitRoot(_finishedWork);
              } else {
                // There's no time left. Mark this root as complete. We'll come
                // back and commit it later.
                root.finishedWork = _finishedWork;
              }
            }
          }
        }

        isRendering = false;
      } // When working on async work, the reconciler asks the renderer if it should
      // yield execution. For DOM, we implement this with requestIdleCallback.


      function shouldYield() {
        if (deadline === null) {
          return false;
        }

        if (deadline.timeRemaining() > timeHeuristicForUnitOfWork) {
          // Disregard deadline.didTimeout. Only expired work should be flushed
          // during a timeout. This path is only hit for non-expired work.
          return false;
        }

        deadlineDidExpire = true;
        return true;
      } // TODO: Not happy about this hook. Conceptually, renderRoot should return a
      // tuple of (isReadyForCommit, didError, error)


      function onUncaughtError(error) {
        !(nextFlushedRoot !== null) ? invariant(false, 'Should be working on a root. This error is likely caused by a bug in React. Please file an issue.') : void 0; // Unschedule this root so we don't work on it again until there's
        // another update.

        nextFlushedRoot.remainingExpirationTime = NoWork;

        if (!hasUnhandledError) {
          hasUnhandledError = true;
          unhandledError = error;
        }
      } // TODO: Batching should be implemented at the renderer level, not inside
      // the reconciler.


      function batchedUpdates(fn, a) {
        var previousIsBatchingUpdates = isBatchingUpdates;
        isBatchingUpdates = true;

        try {
          return fn(a);
        } finally {
          isBatchingUpdates = previousIsBatchingUpdates;

          if (!isBatchingUpdates && !isRendering) {
            performWork(Sync, null);
          }
        }
      } // TODO: Batching should be implemented at the renderer level, not inside
      // the reconciler.


      function unbatchedUpdates(fn) {
        if (isBatchingUpdates && !isUnbatchingUpdates) {
          isUnbatchingUpdates = true;

          try {
            return fn();
          } finally {
            isUnbatchingUpdates = false;
          }
        }

        return fn();
      } // TODO: Batching should be implemented at the renderer level, not within
      // the reconciler.


      function flushSync(fn) {
        var previousIsBatchingUpdates = isBatchingUpdates;
        isBatchingUpdates = true;

        try {
          return syncUpdates(fn);
        } finally {
          isBatchingUpdates = previousIsBatchingUpdates;
          !!isRendering ? invariant(false, 'flushSync was called from inside a lifecycle method. It cannot be called when React is already rendering.') : void 0;
          performWork(Sync, null);
        }
      }

      return {
        computeAsyncExpiration: computeAsyncExpiration,
        computeExpirationForFiber: computeExpirationForFiber,
        scheduleWork: scheduleWork,
        batchedUpdates: batchedUpdates,
        unbatchedUpdates: unbatchedUpdates,
        flushSync: flushSync,
        deferredUpdates: deferredUpdates
      };
    };

    {
      var didWarnAboutNestedUpdates = false;
    } // 0 is PROD, 1 is DEV.
    // Might add PROFILE later.

    function getContextForSubtree(parentComponent) {
      if (!parentComponent) {
        return emptyObject;
      }

      var fiber = get(parentComponent);
      var parentContext = findCurrentUnmaskedContext(fiber);
      return isContextProvider(fiber) ? processChildContext(fiber, parentContext) : parentContext;
    }

    var ReactFiberReconciler$1 = function ReactFiberReconciler$1(config) {
      var getPublicInstance = config.getPublicInstance;

      var _ReactFiberScheduler = ReactFiberScheduler(config),
          computeAsyncExpiration = _ReactFiberScheduler.computeAsyncExpiration,
          computeExpirationForFiber = _ReactFiberScheduler.computeExpirationForFiber,
          scheduleWork = _ReactFiberScheduler.scheduleWork,
          batchedUpdates = _ReactFiberScheduler.batchedUpdates,
          unbatchedUpdates = _ReactFiberScheduler.unbatchedUpdates,
          flushSync = _ReactFiberScheduler.flushSync,
          deferredUpdates = _ReactFiberScheduler.deferredUpdates;

      function scheduleTopLevelUpdate(current, element, callback) {
        {
          if (ReactDebugCurrentFiber.phase === 'render' && ReactDebugCurrentFiber.current !== null && !didWarnAboutNestedUpdates) {
            didWarnAboutNestedUpdates = true;
            warning(false, 'Render methods should be a pure function of props and state; ' + 'triggering nested component updates from render is not allowed. ' + 'If necessary, trigger nested updates in componentDidUpdate.\n\n' + 'Check the render method of %s.', getComponentName(ReactDebugCurrentFiber.current) || 'Unknown');
          }
        }
        callback = callback === undefined ? null : callback;
        {
          warning(callback === null || typeof callback === 'function', 'render(...): Expected the last optional `callback` argument to be a ' + 'function. Instead received: %s.', callback);
        }
        var expirationTime = void 0; // Check if the top-level element is an async wrapper component. If so,
        // treat updates to the root as async. This is a bit weird but lets us
        // avoid a separate `renderAsync` API.

        if (enableAsyncSubtreeAPI && element != null && element.type != null && element.type.prototype != null && element.type.prototype.unstable_isAsyncReactComponent === true) {
          expirationTime = computeAsyncExpiration();
        } else {
          expirationTime = computeExpirationForFiber(current);
        }

        var update = {
          expirationTime: expirationTime,
          partialState: {
            element: element
          },
          callback: callback,
          isReplace: false,
          isForced: false,
          nextCallback: null,
          next: null
        };
        insertUpdateIntoFiber(current, update);
        scheduleWork(current, expirationTime);
      }

      function findHostInstance(fiber) {
        var hostFiber = findCurrentHostFiber(fiber);

        if (hostFiber === null) {
          return null;
        }

        return hostFiber.stateNode;
      }

      return {
        createContainer: function createContainer(containerInfo, hydrate) {
          return createFiberRoot(containerInfo, hydrate);
        },
        updateContainer: function updateContainer(element, container, parentComponent, callback) {
          // TODO: If this is a nested container, this won't be the root.
          var current = container.current;
          {
            if (ReactFiberInstrumentation_1.debugTool) {
              if (current.alternate === null) {
                ReactFiberInstrumentation_1.debugTool.onMountContainer(container);
              } else if (element === null) {
                ReactFiberInstrumentation_1.debugTool.onUnmountContainer(container);
              } else {
                ReactFiberInstrumentation_1.debugTool.onUpdateContainer(container);
              }
            }
          }
          var context = getContextForSubtree(parentComponent);

          if (container.context === null) {
            container.context = context;
          } else {
            container.pendingContext = context;
          }

          scheduleTopLevelUpdate(current, element, callback);
        },
        batchedUpdates: batchedUpdates,
        unbatchedUpdates: unbatchedUpdates,
        deferredUpdates: deferredUpdates,
        flushSync: flushSync,
        getPublicRootInstance: function getPublicRootInstance(container) {
          var containerFiber = container.current;

          if (!containerFiber.child) {
            return null;
          }

          switch (containerFiber.child.tag) {
            case HostComponent:
              return getPublicInstance(containerFiber.child.stateNode);

            default:
              return containerFiber.child.stateNode;
          }
        },
        findHostInstance: findHostInstance,
        findHostInstanceWithNoPortals: function findHostInstanceWithNoPortals(fiber) {
          var hostFiber = findCurrentHostFiberWithNoPortals(fiber);

          if (hostFiber === null) {
            return null;
          }

          return hostFiber.stateNode;
        },
        injectIntoDevTools: function injectIntoDevTools(devToolsConfig) {
          var _findFiberByHostInstance = devToolsConfig.findFiberByHostInstance;
          return injectInternals(_assign({}, devToolsConfig, {
            findHostInstanceByFiber: function findHostInstanceByFiber(fiber) {
              return findHostInstance(fiber);
            },
            findFiberByHostInstance: function findFiberByHostInstance(instance) {
              if (!_findFiberByHostInstance) {
                // Might not be implemented by the renderer.
                return null;
              }

              return _findFiberByHostInstance(instance);
            }
          }));
        }
      };
    };

    var ReactFiberReconciler$2 = Object.freeze({
      default: ReactFiberReconciler$1
    });
    var ReactFiberReconciler$3 = ReactFiberReconciler$2 && ReactFiberReconciler$1 || ReactFiberReconciler$2; // TODO: bundle Flow types with the package.
    // TODO: decide on the top-level export form.
    // This is hacky but makes it work with both Rollup and Jest.

    var reactReconciler = ReactFiberReconciler$3['default'] ? ReactFiberReconciler$3['default'] : ReactFiberReconciler$3;
    var getFiberCurrentPropsFromNode = null;
    var getInstanceFromNode = null;
    {}
    /**
     * Standard/simple iteration through an event's collected dispatches.
     */

    /**
     * @see executeDispatchesInOrderStopAtTrueImpl
     */

    /**
     * Execution of a "direct" dispatch - there must be at most one dispatch
     * accumulated on the event or it is considered an error. It doesn't really make
     * sense for an event with multiple dispatches (bubbled) to keep track of the
     * return values at each dispatch execution, but it does tend to make sense when
     * dealing with "direct" dispatches.
     *
     * @return {*} The return value of executing the single dispatch.
     */

    /**
     * @param {SyntheticEvent} event
     * @return {boolean} True iff number of dispatches accumulated is greater than 0.
     */
    // Use to restore controlled state after a change event has fired.

    var fiberHostComponent = null;
    var restoreTarget = null;
    var restoreQueue = null;

    function restoreStateOfTarget(target) {
      // We perform this translation at the end of the event loop so that we
      // always receive the correct fiber here
      var internalInstance = getInstanceFromNode(target);

      if (!internalInstance) {
        // Unmounted
        return;
      }

      !(fiberHostComponent && typeof fiberHostComponent.restoreControlledState === 'function') ? invariant(false, 'Fiber needs to be injected to handle a fiber target for controlled events. This error is likely caused by a bug in React. Please file an issue.') : void 0;
      var props = getFiberCurrentPropsFromNode(internalInstance.stateNode);
      fiberHostComponent.restoreControlledState(internalInstance.stateNode, internalInstance.type, props);
    }

    function restoreStateIfNeeded() {
      if (!restoreTarget) {
        return;
      }

      var target = restoreTarget;
      var queuedTargets = restoreQueue;
      restoreTarget = null;
      restoreQueue = null;
      restoreStateOfTarget(target);

      if (queuedTargets) {
        for (var i = 0; i < queuedTargets.length; i++) {
          restoreStateOfTarget(queuedTargets[i]);
        }
      }
    } // Used as a way to call batchedUpdates when we don't have a reference to
    // the renderer. Such as when we're dispatching events or if third party
    // libraries need to call batchedUpdates. Eventually, this API will go away when
    // everything is batched by default. We'll then have a similar API to opt-out of
    // scheduled work and instead do synchronous work.
    // Defaults


    var fiberBatchedUpdates = function fiberBatchedUpdates(fn, bookkeeping) {
      return fn(bookkeeping);
    };

    var isNestingBatched = false;

    function batchedUpdates(fn, bookkeeping) {
      if (isNestingBatched) {
        // If we are currently inside another batch, we need to wait until it
        // fully completes before restoring state. Therefore, we add the target to
        // a queue of work.
        return fiberBatchedUpdates(fn, bookkeeping);
      }

      isNestingBatched = true;

      try {
        return fiberBatchedUpdates(fn, bookkeeping);
      } finally {
        // Here we wait until all updates have propagated, which is important
        // when using controlled components within layers:
        // https://github.com/facebook/react/issues/1698
        // Then we restore state of any controlled component.
        isNestingBatched = false;
        restoreStateIfNeeded();
      }
    }

    var _createClass = function () {
      function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }

      return function (Constructor, protoProps, staticProps) {
        if (protoProps) defineProperties(Constructor.prototype, protoProps);
        if (staticProps) defineProperties(Constructor, staticProps);
        return Constructor;
      };
    }();

    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }

    function _objectWithoutProperties(obj, keys) {
      var target = {};

      for (var i in obj) {
        if (keys.indexOf(i) >= 0) continue;
        if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;
        target[i] = obj[i];
      }

      return target;
    }

    var UPDATE_SIGNAL = {};

    function getPublicInstance(inst) {
      switch (inst.tag) {
        case 'INSTANCE':
          var _createNodeMock = inst.rootContainerInstance.createNodeMock;
          return _createNodeMock({
            type: inst.type,
            props: inst.props
          });

        default:
          return inst;
      }
    }

    function appendChild(parentInstance, child) {
      var index = parentInstance.children.indexOf(child);

      if (index !== -1) {
        parentInstance.children.splice(index, 1);
      }

      parentInstance.children.push(child);
    }

    function insertBefore(parentInstance, child, beforeChild) {
      var index = parentInstance.children.indexOf(child);

      if (index !== -1) {
        parentInstance.children.splice(index, 1);
      }

      var beforeIndex = parentInstance.children.indexOf(beforeChild);
      parentInstance.children.splice(beforeIndex, 0, child);
    }

    function removeChild(parentInstance, child) {
      var index = parentInstance.children.indexOf(child);
      parentInstance.children.splice(index, 1);
    }

    var TestRenderer = reactReconciler({
      getRootHostContext: function getRootHostContext() {
        return emptyObject;
      },
      getChildHostContext: function getChildHostContext() {
        return emptyObject;
      },
      prepareForCommit: function prepareForCommit() {// noop
      },
      resetAfterCommit: function resetAfterCommit() {// noop
      },
      createInstance: function createInstance(type, props, rootContainerInstance, hostContext, internalInstanceHandle) {
        return {
          type: type,
          props: props,
          children: [],
          rootContainerInstance: rootContainerInstance,
          tag: 'INSTANCE'
        };
      },
      appendInitialChild: function appendInitialChild(parentInstance, child) {
        var index = parentInstance.children.indexOf(child);

        if (index !== -1) {
          parentInstance.children.splice(index, 1);
        }

        parentInstance.children.push(child);
      },
      finalizeInitialChildren: function finalizeInitialChildren(testElement, type, props, rootContainerInstance) {
        return false;
      },
      prepareUpdate: function prepareUpdate(testElement, type, oldProps, newProps, rootContainerInstance, hostContext) {
        return UPDATE_SIGNAL;
      },
      shouldSetTextContent: function shouldSetTextContent(type, props) {
        return false;
      },
      shouldDeprioritizeSubtree: function shouldDeprioritizeSubtree(type, props) {
        return false;
      },
      createTextInstance: function createTextInstance(text, rootContainerInstance, hostContext, internalInstanceHandle) {
        return {
          text: text,
          tag: 'TEXT'
        };
      },
      scheduleDeferredCallback: function scheduleDeferredCallback(fn) {
        return setTimeout(fn, 0, {
          timeRemaining: Infinity
        });
      },
      cancelDeferredCallback: function cancelDeferredCallback(timeoutID) {
        clearTimeout(timeoutID);
      },
      useSyncScheduling: true,
      getPublicInstance: getPublicInstance,
      now: function now() {
        // Test renderer does not use expiration
        return 0;
      },
      mutation: {
        commitUpdate: function commitUpdate(instance, updatePayload, type, oldProps, newProps, internalInstanceHandle) {
          instance.type = type;
          instance.props = newProps;
        },
        commitMount: function commitMount(instance, type, newProps, internalInstanceHandle) {// noop
        },
        commitTextUpdate: function commitTextUpdate(textInstance, oldText, newText) {
          textInstance.text = newText;
        },
        resetTextContent: function resetTextContent(testElement) {// noop
        },
        appendChild: appendChild,
        appendChildToContainer: appendChild,
        insertBefore: insertBefore,
        insertInContainerBefore: insertBefore,
        removeChild: removeChild,
        removeChildFromContainer: removeChild
      }
    });
    var defaultTestOptions = {
      createNodeMock: function createNodeMock() {
        return null;
      }
    };

    function _toJSON(inst) {
      switch (inst.tag) {
        case 'TEXT':
          return inst.text;

        case 'INSTANCE':
          /* eslint-disable no-unused-vars */
          // We don't include the `children` prop in JSON.
          // Instead, we will include the actual rendered children.
          var _inst$props = inst.props,
              _children = _inst$props.children,
              _props = _objectWithoutProperties(_inst$props, ['children']);
          /* eslint-enable */


          var renderedChildren = null;

          if (inst.children && inst.children.length) {
            renderedChildren = inst.children.map(_toJSON);
          }

          var json = {
            type: inst.type,
            props: _props,
            children: renderedChildren
          };
          Object.defineProperty(json, '$$typeof', {
            value: Symbol['for']('react.test.json')
          });
          return json;

        default:
          throw new Error('Unexpected node type in toJSON: ' + inst.tag);
      }
    }

    function nodeAndSiblingsTrees(nodeWithSibling) {
      var array = [];
      var node = nodeWithSibling;

      while (node != null) {
        array.push(node);
        node = node.sibling;
      }

      var trees = array.map(_toTree);
      return trees.length ? trees : null;
    }

    function hasSiblings(node) {
      return node && node.sibling;
    }

    function _toTree(node) {
      if (node == null) {
        return null;
      }

      switch (node.tag) {
        case HostRoot:
          // 3
          return _toTree(node.child);

        case ClassComponent:
          return {
            nodeType: 'component',
            type: node.type,
            props: _assign({}, node.memoizedProps),
            instance: node.stateNode,
            rendered: hasSiblings(node.child) ? nodeAndSiblingsTrees(node.child) : _toTree(node.child)
          };

        case FunctionalComponent:
          // 1
          return {
            nodeType: 'component',
            type: node.type,
            props: _assign({}, node.memoizedProps),
            instance: null,
            rendered: hasSiblings(node.child) ? nodeAndSiblingsTrees(node.child) : _toTree(node.child)
          };

        case HostComponent:
          // 5
          return {
            nodeType: 'host',
            type: node.type,
            props: _assign({}, node.memoizedProps),
            instance: null,
            // TODO: use createNodeMock here somehow?
            rendered: nodeAndSiblingsTrees(node.child)
          };

        case HostText:
          // 6
          return node.stateNode.text;

        default:
          invariant(false, 'toTree() does not yet know how to handle nodes with tag=%s', node.tag);
      }
    }

    var fiberToWrapper = new WeakMap();

    function wrapFiber(fiber) {
      var wrapper = fiberToWrapper.get(fiber);

      if (wrapper === undefined && fiber.alternate !== null) {
        wrapper = fiberToWrapper.get(fiber.alternate);
      }

      if (wrapper === undefined) {
        wrapper = new ReactTestInstance(fiber);
        fiberToWrapper.set(fiber, wrapper);
      }

      return wrapper;
    }

    var validWrapperTypes = new Set([FunctionalComponent, ClassComponent, HostComponent]);

    var ReactTestInstance = function () {
      ReactTestInstance.prototype._currentFiber = function _currentFiber() {
        // Throws if this component has been unmounted.
        var fiber = findCurrentFiberUsingSlowPath(this._fiber);
        !(fiber !== null) ? invariant(false, 'Can\'t read from currently-mounting component. This error is likely caused by a bug in React. Please file an issue.') : void 0;
        return fiber;
      };

      function ReactTestInstance(fiber) {
        _classCallCheck(this, ReactTestInstance);

        !validWrapperTypes.has(fiber.tag) ? invariant(false, 'Unexpected object passed to ReactTestInstance constructor (tag: %s). This is probably a bug in React.', fiber.tag) : void 0;
        this._fiber = fiber;
      } // Custom search functions


      ReactTestInstance.prototype.find = function find(predicate) {
        return expectOne(this.findAll(predicate, {
          deep: false
        }), 'matching custom predicate: ' + predicate.toString());
      };

      ReactTestInstance.prototype.findByType = function findByType(type) {
        return expectOne(this.findAllByType(type, {
          deep: false
        }), 'with node type: "' + (type.displayName || type.name) + '"');
      };

      ReactTestInstance.prototype.findByProps = function findByProps(props) {
        return expectOne(this.findAllByProps(props, {
          deep: false
        }), 'with props: ' + JSON.stringify(props));
      };

      ReactTestInstance.prototype.findAll = function findAll(predicate) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
        return _findAll(this, predicate, options);
      };

      ReactTestInstance.prototype.findAllByType = function findAllByType(type) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
        return _findAll(this, function (node) {
          return node.type === type;
        }, options);
      };

      ReactTestInstance.prototype.findAllByProps = function findAllByProps(props) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
        return _findAll(this, function (node) {
          return node.props && propsMatch(node.props, props);
        }, options);
      };

      _createClass(ReactTestInstance, [{
        key: 'instance',
        get: function get() {
          if (this._fiber.tag === HostComponent) {
            return getPublicInstance(this._fiber.stateNode);
          } else {
            return this._fiber.stateNode;
          }
        }
      }, {
        key: 'type',
        get: function get() {
          return this._fiber.type;
        }
      }, {
        key: 'props',
        get: function get() {
          return this._currentFiber().memoizedProps;
        }
      }, {
        key: 'parent',
        get: function get() {
          var parent = this._fiber['return'];
          return parent === null || parent.tag === HostRoot ? null : wrapFiber(parent);
        }
      }, {
        key: 'children',
        get: function get() {
          var children = [];

          var startingNode = this._currentFiber();

          var node = startingNode;

          if (node.child === null) {
            return children;
          }

          node.child['return'] = node;
          node = node.child;

          outer: while (true) {
            var descend = false;

            switch (node.tag) {
              case FunctionalComponent:
              case ClassComponent:
              case HostComponent:
                children.push(wrapFiber(node));
                break;

              case HostText:
                children.push('' + node.memoizedProps);
                break;

              case Fragment:
                descend = true;
                break;

              default:
                invariant(false, 'Unsupported component type %s in test renderer. This is probably a bug in React.', node.tag);
            }

            if (descend && node.child !== null) {
              node.child['return'] = node;
              node = node.child;
              continue;
            }

            while (node.sibling === null) {
              if (node['return'] === startingNode) {
                break outer;
              }

              node = node['return'];
            }

            node.sibling['return'] = node['return'];
            node = node.sibling;
          }

          return children;
        }
      }]);

      return ReactTestInstance;
    }();

    function _findAll(root, predicate, options) {
      var deep = options ? options.deep : true;
      var results = [];

      if (predicate(root)) {
        results.push(root);

        if (!deep) {
          return results;
        }
      }

      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = root.children[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var child = _step.value;

          if (typeof child === 'string') {
            continue;
          }

          results.push.apply(results, _findAll(child, predicate, options));
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator['return']) {
            _iterator['return']();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      return results;
    }

    function expectOne(all, message) {
      if (all.length === 1) {
        return all[0];
      }

      var prefix = all.length === 0 ? 'No instances found ' : 'Expected 1 but found ' + all.length + ' instances ';
      throw new Error(prefix + message);
    }

    function propsMatch(props, filter) {
      for (var key in filter) {
        if (props[key] !== filter[key]) {
          return false;
        }
      }

      return true;
    }

    var ReactTestRendererFiber = {
      create: function create(element, options) {
        var createNodeMock = defaultTestOptions.createNodeMock;

        if (options && typeof options.createNodeMock === 'function') {
          createNodeMock = options.createNodeMock;
        }

        var container = {
          children: [],
          createNodeMock: createNodeMock,
          tag: 'CONTAINER'
        };
        var root = TestRenderer.createContainer(container, false);
        !(root != null) ? invariant(false, 'something went wrong') : void 0;
        TestRenderer.updateContainer(element, root, null, null);
        var entry = {
          root: undefined,
          // makes flow happy
          // we define a 'getter' for 'root' below using 'Object.defineProperty'
          toJSON: function toJSON() {
            if (root == null || root.current == null || container == null) {
              return null;
            }

            if (container.children.length === 0) {
              return null;
            }

            if (container.children.length === 1) {
              return _toJSON(container.children[0]);
            }

            return container.children.map(_toJSON);
          },
          toTree: function toTree() {
            if (root == null || root.current == null) {
              return null;
            }

            return _toTree(root.current);
          },
          update: function update(newElement) {
            if (root == null || root.current == null) {
              return;
            }

            TestRenderer.updateContainer(newElement, root, null, null);
          },
          unmount: function unmount() {
            if (root == null || root.current == null) {
              return;
            }

            TestRenderer.updateContainer(null, root, null);
            container = null;
            root = null;
          },
          getInstance: function getInstance() {
            if (root == null || root.current == null) {
              return null;
            }

            return TestRenderer.getPublicRootInstance(root);
          }
        };
        Object.defineProperty(entry, 'root', {
          configurable: true,
          enumerable: true,
          get: function get() {
            if (root === null || root.current.child === null) {
              throw new Error("Can't access .root on unmounted test renderer");
            }

            return wrapFiber(root.current.child);
          }
        });
        return entry;
      },

      /* eslint-disable camelcase */
      unstable_batchedUpdates: batchedUpdates
    };
    var ReactTestRenderer = Object.freeze({
      default: ReactTestRendererFiber
    });
    var ReactTestRenderer$1 = ReactTestRenderer && ReactTestRendererFiber || ReactTestRenderer; // TODO: decide on the top-level export form.
    // This is hacky but makes it work with both Rollup and Jest.

    var reactTestRenderer = ReactTestRenderer$1['default'] ? ReactTestRenderer$1['default'] : ReactTestRenderer$1;
    module.exports = reactTestRenderer;
  })();
}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__("./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/react-test-renderer/cjs/react-test-renderer.production.min.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/** @license React v16.2.0
 * react-test-renderer.production.min.js
 *
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */


var n = __webpack_require__("./node_modules/object-assign/index.js"),
    da = __webpack_require__("./node_modules/react/index.js"),
    F = __webpack_require__("./node_modules/fbjs/lib/emptyObject.js"),
    ha = __webpack_require__("./node_modules/fbjs/lib/shallowEqual.js");

function K(a) {
  for (var b = arguments.length - 1, d = "Minified React error #" + a + "; visit http://facebook.github.io/react/docs/error-decoder.html?invariant\x3d" + a, c = 0; c < b; c++) {
    d += "\x26args[]\x3d" + encodeURIComponent(arguments[c + 1]);
  }

  b = Error(d + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.");
  b.name = "Invariant Violation";
  b.framesToPop = 1;
  throw b;
}

var ia = da.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner;

function ja(a) {
  a = a.type;
  return "string" === typeof a ? a : "function" === typeof a ? a.displayName || a.name : null;
}

function ka(a) {
  var b = a;
  if (a.alternate) for (; b["return"];) {
    b = b["return"];
  } else {
    if (0 !== (b.effectTag & 2)) return 1;

    for (; b["return"];) {
      if (b = b["return"], 0 !== (b.effectTag & 2)) return 1;
    }
  }
  return 3 === b.tag ? 2 : 3;
}

function la(a) {
  return (a = a._reactInternalFiber) ? 2 === ka(a) : !1;
}

function ma(a) {
  2 !== ka(a) ? K("188") : void 0;
}

function na(a) {
  var b = a.alternate;
  if (!b) return b = ka(a), 3 === b ? K("188") : void 0, 1 === b ? null : a;

  for (var d = a, c = b;;) {
    var e = d["return"],
        p = e ? e.alternate : null;
    if (!e || !p) break;

    if (e.child === p.child) {
      for (var k = e.child; k;) {
        if (k === d) return ma(e), a;
        if (k === c) return ma(e), b;
        k = k.sibling;
      }

      K("188");
    }

    if (d["return"] !== c["return"]) d = e, c = p;else {
      k = !1;

      for (var g = e.child; g;) {
        if (g === d) {
          k = !0;
          d = e;
          c = p;
          break;
        }

        if (g === c) {
          k = !0;
          c = e;
          d = p;
          break;
        }

        g = g.sibling;
      }

      if (!k) {
        for (g = p.child; g;) {
          if (g === d) {
            k = !0;
            d = p;
            c = e;
            break;
          }

          if (g === c) {
            k = !0;
            c = p;
            d = e;
            break;
          }

          g = g.sibling;
        }

        k ? void 0 : K("189");
      }
    }
    d.alternate !== c ? K("190") : void 0;
  }

  3 !== d.tag ? K("188") : void 0;
  return d.stateNode.current === d ? a : b;
}

function oa(a) {
  a = na(a);
  if (!a) return null;

  for (var b = a;;) {
    if (5 === b.tag || 6 === b.tag) return b;
    if (b.child) b.child["return"] = b, b = b.child;else {
      if (b === a) break;

      for (; !b.sibling;) {
        if (!b["return"] || b["return"] === a) return null;
        b = b["return"];
      }

      b.sibling["return"] = b["return"];
      b = b.sibling;
    }
  }

  return null;
}

function pa(a) {
  a = na(a);
  if (!a) return null;

  for (var b = a;;) {
    if (5 === b.tag || 6 === b.tag) return b;
    if (b.child && 4 !== b.tag) b.child["return"] = b, b = b.child;else {
      if (b === a) break;

      for (; !b.sibling;) {
        if (!b["return"] || b["return"] === a) return null;
        b = b["return"];
      }

      b.sibling["return"] = b["return"];
      b = b.sibling;
    }
  }

  return null;
}

var sa = [],
    L = -1;

function M(a) {
  0 > L || (a.current = sa[L], sa[L] = null, L--);
}

function N(a, b) {
  L++;
  sa[L] = a.current;
  a.current = b;
}

new Set();
var O = {
  current: F
},
    Q = {
  current: !1
},
    ta = F;

function ua(a) {
  return va(a) ? ta : O.current;
}

function wa(a, b) {
  var d = a.type.contextTypes;
  if (!d) return F;
  var c = a.stateNode;
  if (c && c.__reactInternalMemoizedUnmaskedChildContext === b) return c.__reactInternalMemoizedMaskedChildContext;
  var e = {},
      p;

  for (p in d) {
    e[p] = b[p];
  }

  c && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = b, a.__reactInternalMemoizedMaskedChildContext = e);
  return e;
}

function va(a) {
  return 2 === a.tag && null != a.type.childContextTypes;
}

function xa(a) {
  va(a) && (M(Q, a), M(O, a));
}

function ya(a, b, d) {
  null != O.cursor ? K("168") : void 0;
  N(O, b, a);
  N(Q, d, a);
}

function za(a, b) {
  var d = a.stateNode,
      c = a.type.childContextTypes;
  if ("function" !== typeof d.getChildContext) return b;
  d = d.getChildContext();

  for (var e in d) {
    e in c ? void 0 : K("108", ja(a) || "Unknown", e);
  }

  return n({}, b, d);
}

function Aa(a) {
  if (!va(a)) return !1;
  var b = a.stateNode;
  b = b && b.__reactInternalMemoizedMergedChildContext || F;
  ta = O.current;
  N(O, b, a);
  N(Q, Q.current, a);
  return !0;
}

function Ba(a, b) {
  var d = a.stateNode;
  d ? void 0 : K("169");

  if (b) {
    var c = za(a, ta);
    d.__reactInternalMemoizedMergedChildContext = c;
    M(Q, a);
    M(O, a);
    N(O, c, a);
  } else M(Q, a);

  N(Q, b, a);
}

function X(a, b, d) {
  this.tag = a;
  this.key = b;
  this.stateNode = this.type = null;
  this.sibling = this.child = this["return"] = null;
  this.index = 0;
  this.memoizedState = this.updateQueue = this.memoizedProps = this.pendingProps = this.ref = null;
  this.internalContextTag = d;
  this.effectTag = 0;
  this.lastEffect = this.firstEffect = this.nextEffect = null;
  this.expirationTime = 0;
  this.alternate = null;
}

function Ca(a, b, d) {
  var c = a.alternate;
  null === c ? (c = new X(a.tag, a.key, a.internalContextTag), c.type = a.type, c.stateNode = a.stateNode, c.alternate = a, a.alternate = c) : (c.effectTag = 0, c.nextEffect = null, c.firstEffect = null, c.lastEffect = null);
  c.expirationTime = d;
  c.pendingProps = b;
  c.child = a.child;
  c.memoizedProps = a.memoizedProps;
  c.memoizedState = a.memoizedState;
  c.updateQueue = a.updateQueue;
  c.sibling = a.sibling;
  c.index = a.index;
  c.ref = a.ref;
  return c;
}

function Da(a, b, d) {
  var c = void 0,
      e = a.type,
      p = a.key;
  "function" === typeof e ? (c = e.prototype && e.prototype.isReactComponent ? new X(2, p, b) : new X(0, p, b), c.type = e, c.pendingProps = a.props) : "string" === typeof e ? (c = new X(5, p, b), c.type = e, c.pendingProps = a.props) : "object" === typeof e && null !== e && "number" === typeof e.tag ? (c = e, c.pendingProps = a.props) : K("130", null == e ? e : typeof e, "");
  c.expirationTime = d;
  return c;
}

function Ea(a, b, d, c) {
  b = new X(10, c, b);
  b.pendingProps = a;
  b.expirationTime = d;
  return b;
}

function Fa(a, b, d) {
  b = new X(6, null, b);
  b.pendingProps = a;
  b.expirationTime = d;
  return b;
}

function Ga(a, b, d) {
  b = new X(7, a.key, b);
  b.type = a.handler;
  b.pendingProps = a;
  b.expirationTime = d;
  return b;
}

function Ha(a, b, d) {
  a = new X(9, null, b);
  a.expirationTime = d;
  return a;
}

function Ia(a, b, d) {
  b = new X(4, a.key, b);
  b.pendingProps = a.children || [];
  b.expirationTime = d;
  b.stateNode = {
    containerInfo: a.containerInfo,
    pendingChildren: null,
    implementation: a.implementation
  };
  return b;
}

var Oa = null,
    Pa = null;

function Qa(a) {
  return function (b) {
    try {
      return a(b);
    } catch (d) {}
  };
}

function Ra(a) {
  if ("undefined" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) return !1;
  var b = __REACT_DEVTOOLS_GLOBAL_HOOK__;
  if (b.isDisabled || !b.supportsFiber) return !0;

  try {
    var d = b.inject(a);
    Oa = Qa(function (a) {
      return b.onCommitFiberRoot(d, a);
    });
    Pa = Qa(function (a) {
      return b.onCommitFiberUnmount(d, a);
    });
  } catch (c) {}

  return !0;
}

function Sa(a) {
  "function" === typeof Oa && Oa(a);
}

function Ta(a) {
  "function" === typeof Pa && Pa(a);
}

function Ua(a) {
  return {
    baseState: a,
    expirationTime: 0,
    first: null,
    last: null,
    callbackList: null,
    hasForceUpdate: !1,
    isInitialized: !1
  };
}

function Va(a, b) {
  null === a.last ? a.first = a.last = b : (a.last.next = b, a.last = b);
  if (0 === a.expirationTime || a.expirationTime > b.expirationTime) a.expirationTime = b.expirationTime;
}

function Wa(a, b) {
  var d = a.alternate,
      c = a.updateQueue;
  null === c && (c = a.updateQueue = Ua(null));
  null !== d ? (a = d.updateQueue, null === a && (a = d.updateQueue = Ua(null))) : a = null;
  a = a !== c ? a : null;
  null === a ? Va(c, b) : null === c.last || null === a.last ? (Va(c, b), Va(a, b)) : (Va(c, b), a.last = b);
}

function Xa(a, b, d, c) {
  a = a.partialState;
  return "function" === typeof a ? a.call(b, d, c) : a;
}

function gb(a, b, d, c, e, p) {
  null !== a && a.updateQueue === d && (d = b.updateQueue = {
    baseState: d.baseState,
    expirationTime: d.expirationTime,
    first: d.first,
    last: d.last,
    isInitialized: d.isInitialized,
    callbackList: null,
    hasForceUpdate: !1
  });
  d.expirationTime = 0;
  d.isInitialized ? a = d.baseState : (a = d.baseState = b.memoizedState, d.isInitialized = !0);

  for (var k = !0, g = d.first, l = !1; null !== g;) {
    var u = g.expirationTime;

    if (u > p) {
      var A = d.expirationTime;
      if (0 === A || A > u) d.expirationTime = u;
      l || (l = !0, d.baseState = a);
    } else {
      l || (d.first = g.next, null === d.first && (d.last = null));
      if (g.isReplace) a = Xa(g, c, a, e), k = !0;else if (u = Xa(g, c, a, e)) a = k ? n({}, a, u) : n(a, u), k = !1;
      g.isForced && (d.hasForceUpdate = !0);
      null !== g.callback && (u = d.callbackList, null === u && (u = d.callbackList = []), u.push(g));
    }

    g = g.next;
  }

  null !== d.callbackList ? b.effectTag |= 32 : null !== d.first || d.hasForceUpdate || (b.updateQueue = null);
  l || (d.baseState = a);
  return a;
}

function hb(a, b) {
  var d = a.callbackList;
  if (null !== d) for (a.callbackList = null, a = 0; a < d.length; a++) {
    var c = d[a],
        e = c.callback;
    c.callback = null;
    "function" !== typeof e ? K("191", e) : void 0;
    e.call(b);
  }
}

function ib(a, b, d, c) {
  function e(a, b) {
    b.updater = p;
    a.stateNode = b;
    b._reactInternalFiber = a;
  }

  var p = {
    isMounted: la,
    enqueueSetState: function enqueueSetState(d, c, e) {
      d = d._reactInternalFiber;
      e = void 0 === e ? null : e;
      var k = b(d);
      Wa(d, {
        expirationTime: k,
        partialState: c,
        callback: e,
        isReplace: !1,
        isForced: !1,
        nextCallback: null,
        next: null
      });
      a(d, k);
    },
    enqueueReplaceState: function enqueueReplaceState(d, c, e) {
      d = d._reactInternalFiber;
      e = void 0 === e ? null : e;
      var g = b(d);
      Wa(d, {
        expirationTime: g,
        partialState: c,
        callback: e,
        isReplace: !0,
        isForced: !1,
        nextCallback: null,
        next: null
      });
      a(d, g);
    },
    enqueueForceUpdate: function enqueueForceUpdate(d, c) {
      d = d._reactInternalFiber;
      c = void 0 === c ? null : c;
      var e = b(d);
      Wa(d, {
        expirationTime: e,
        partialState: null,
        callback: c,
        isReplace: !1,
        isForced: !0,
        nextCallback: null,
        next: null
      });
      a(d, e);
    }
  };
  return {
    adoptClassInstance: e,
    constructClassInstance: function constructClassInstance(a, b) {
      var d = a.type,
          c = ua(a),
          g = 2 === a.tag && null != a.type.contextTypes,
          k = g ? wa(a, c) : F;
      b = new d(b, k);
      e(a, b);
      g && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = c, a.__reactInternalMemoizedMaskedChildContext = k);
      return b;
    },
    mountClassInstance: function mountClassInstance(a, b) {
      var d = a.alternate,
          c = a.stateNode,
          e = c.state || null,
          g = a.pendingProps;
      g ? void 0 : K("158");
      var k = ua(a);
      c.props = g;
      c.state = a.memoizedState = e;
      c.refs = F;
      c.context = wa(a, k);
      null != a.type && null != a.type.prototype && !0 === a.type.prototype.unstable_isAsyncReactComponent && (a.internalContextTag |= 1);
      "function" === typeof c.componentWillMount && (e = c.state, c.componentWillMount(), e !== c.state && p.enqueueReplaceState(c, c.state, null), e = a.updateQueue, null !== e && (c.state = gb(d, a, e, c, g, b)));
      "function" === typeof c.componentDidMount && (a.effectTag |= 4);
    },
    updateClassInstance: function updateClassInstance(a, b, e) {
      var g = b.stateNode;
      g.props = b.memoizedProps;
      g.state = b.memoizedState;
      var k = b.memoizedProps,
          l = b.pendingProps;
      l || (l = k, null == l ? K("159") : void 0);
      var w = g.context,
          x = ua(b);
      x = wa(b, x);
      "function" !== typeof g.componentWillReceiveProps || k === l && w === x || (w = g.state, g.componentWillReceiveProps(l, x), g.state !== w && p.enqueueReplaceState(g, g.state, null));
      w = b.memoizedState;
      e = null !== b.updateQueue ? gb(a, b, b.updateQueue, g, l, e) : w;
      if (!(k !== l || w !== e || Q.current || null !== b.updateQueue && b.updateQueue.hasForceUpdate)) return "function" !== typeof g.componentDidUpdate || k === a.memoizedProps && w === a.memoizedState || (b.effectTag |= 4), !1;
      var B = l;
      if (null === k || null !== b.updateQueue && b.updateQueue.hasForceUpdate) B = !0;else {
        var D = b.stateNode,
            G = b.type;
        B = "function" === typeof D.shouldComponentUpdate ? D.shouldComponentUpdate(B, e, x) : G.prototype && G.prototype.isPureReactComponent ? !ha(k, B) || !ha(w, e) : !0;
      }
      B ? ("function" === typeof g.componentWillUpdate && g.componentWillUpdate(l, e, x), "function" === typeof g.componentDidUpdate && (b.effectTag |= 4)) : ("function" !== typeof g.componentDidUpdate || k === a.memoizedProps && w === a.memoizedState || (b.effectTag |= 4), d(b, l), c(b, e));
      g.props = l;
      g.state = e;
      g.context = x;
      return B;
    }
  };
}

var jb = "function" === typeof Symbol && Symbol["for"],
    kb = jb ? Symbol["for"]("react.element") : 60103,
    lb = jb ? Symbol["for"]("react.call") : 60104,
    mb = jb ? Symbol["for"]("react.return") : 60105,
    nb = jb ? Symbol["for"]("react.portal") : 60106,
    Y = jb ? Symbol["for"]("react.fragment") : 60107,
    ob = "function" === typeof Symbol && Symbol.iterator;

function pb(a) {
  if (null === a || "undefined" === typeof a) return null;
  a = ob && a[ob] || a["@@iterator"];
  return "function" === typeof a ? a : null;
}

var qb = Array.isArray;

function rb(a, b) {
  var d = b.ref;

  if (null !== d && "function" !== typeof d) {
    if (b._owner) {
      b = b._owner;
      var c = void 0;
      b && (2 !== b.tag ? K("110") : void 0, c = b.stateNode);
      c ? void 0 : K("147", d);
      var e = "" + d;
      if (null !== a && null !== a.ref && a.ref._stringRef === e) return a.ref;

      a = function a(_a) {
        var b = c.refs === F ? c.refs = {} : c.refs;
        null === _a ? delete b[e] : b[e] = _a;
      };

      a._stringRef = e;
      return a;
    }

    "string" !== typeof d ? K("148") : void 0;
    b._owner ? void 0 : K("149", d);
  }

  return d;
}

function sb(a, b) {
  "textarea" !== a.type && K("31", "[object Object]" === Object.prototype.toString.call(b) ? "object with keys {" + Object.keys(b).join(", ") + "}" : b, "");
}

function tb(a) {
  function b(b, t) {
    if (a) {
      var f = b.lastEffect;
      null !== f ? (f.nextEffect = t, b.lastEffect = t) : b.firstEffect = b.lastEffect = t;
      t.nextEffect = null;
      t.effectTag = 8;
    }
  }

  function d(d, t) {
    if (!a) return null;

    for (; null !== t;) {
      b(d, t), t = t.sibling;
    }

    return null;
  }

  function c(a, b) {
    for (a = new Map(); null !== b;) {
      null !== b.key ? a.set(b.key, b) : a.set(b.index, b), b = b.sibling;
    }

    return a;
  }

  function e(a, b, f) {
    a = Ca(a, b, f);
    a.index = 0;
    a.sibling = null;
    return a;
  }

  function p(b, t, f) {
    b.index = f;
    if (!a) return t;
    f = b.alternate;
    if (null !== f) return f = f.index, f < t ? (b.effectTag = 2, t) : f;
    b.effectTag = 2;
    return t;
  }

  function k(b) {
    a && null === b.alternate && (b.effectTag = 2);
    return b;
  }

  function g(a, b, f, h) {
    if (null === b || 6 !== b.tag) return b = Fa(f, a.internalContextTag, h), b["return"] = a, b;
    b = e(b, f, h);
    b["return"] = a;
    return b;
  }

  function l(a, b, f, h) {
    if (null !== b && b.type === f.type) return h = e(b, f.props, h), h.ref = rb(b, f), h["return"] = a, h;
    h = Da(f, a.internalContextTag, h);
    h.ref = rb(b, f);
    h["return"] = a;
    return h;
  }

  function u(a, b, f, h) {
    if (null === b || 7 !== b.tag) return b = Ga(f, a.internalContextTag, h), b["return"] = a, b;
    b = e(b, f, h);
    b["return"] = a;
    return b;
  }

  function A(a, b, f, h) {
    if (null === b || 9 !== b.tag) return b = Ha(f, a.internalContextTag, h), b.type = f.value, b["return"] = a, b;
    b = e(b, null, h);
    b.type = f.value;
    b["return"] = a;
    return b;
  }

  function y(a, b, f, h) {
    if (null === b || 4 !== b.tag || b.stateNode.containerInfo !== f.containerInfo || b.stateNode.implementation !== f.implementation) return b = Ia(f, a.internalContextTag, h), b["return"] = a, b;
    b = e(b, f.children || [], h);
    b["return"] = a;
    return b;
  }

  function w(a, b, f, h, d) {
    if (null === b || 10 !== b.tag) return b = Ea(f, a.internalContextTag, h, d), b["return"] = a, b;
    b = e(b, f, h);
    b["return"] = a;
    return b;
  }

  function x(a, b, f) {
    if ("string" === typeof b || "number" === typeof b) return b = Fa("" + b, a.internalContextTag, f), b["return"] = a, b;

    if ("object" === typeof b && null !== b) {
      switch (b.$$typeof) {
        case kb:
          if (b.type === Y) return b = Ea(b.props.children, a.internalContextTag, f, b.key), b["return"] = a, b;
          f = Da(b, a.internalContextTag, f);
          f.ref = rb(null, b);
          f["return"] = a;
          return f;

        case lb:
          return b = Ga(b, a.internalContextTag, f), b["return"] = a, b;

        case mb:
          return f = Ha(b, a.internalContextTag, f), f.type = b.value, f["return"] = a, f;

        case nb:
          return b = Ia(b, a.internalContextTag, f), b["return"] = a, b;
      }

      if (qb(b) || pb(b)) return b = Ea(b, a.internalContextTag, f, null), b["return"] = a, b;
      sb(a, b);
    }

    return null;
  }

  function B(a, b, f, h) {
    var d = null !== b ? b.key : null;
    if ("string" === typeof f || "number" === typeof f) return null !== d ? null : g(a, b, "" + f, h);

    if ("object" === typeof f && null !== f) {
      switch (f.$$typeof) {
        case kb:
          return f.key === d ? f.type === Y ? w(a, b, f.props.children, h, d) : l(a, b, f, h) : null;

        case lb:
          return f.key === d ? u(a, b, f, h) : null;

        case mb:
          return null === d ? A(a, b, f, h) : null;

        case nb:
          return f.key === d ? y(a, b, f, h) : null;
      }

      if (qb(f) || pb(f)) return null !== d ? null : w(a, b, f, h, null);
      sb(a, f);
    }

    return null;
  }

  function D(a, b, f, h, d) {
    if ("string" === typeof h || "number" === typeof h) return a = a.get(f) || null, g(b, a, "" + h, d);

    if ("object" === typeof h && null !== h) {
      switch (h.$$typeof) {
        case kb:
          return a = a.get(null === h.key ? f : h.key) || null, h.type === Y ? w(b, a, h.props.children, d, h.key) : l(b, a, h, d);

        case lb:
          return a = a.get(null === h.key ? f : h.key) || null, u(b, a, h, d);

        case mb:
          return a = a.get(f) || null, A(b, a, h, d);

        case nb:
          return a = a.get(null === h.key ? f : h.key) || null, y(b, a, h, d);
      }

      if (qb(h) || pb(h)) return a = a.get(f) || null, w(b, a, h, d, null);
      sb(b, h);
    }

    return null;
  }

  function G(e, t, f, h) {
    for (var g = null, r = null, q = t, m = t = 0, k = null; null !== q && m < f.length; m++) {
      q.index > m ? (k = q, q = null) : k = q.sibling;
      var l = B(e, q, f[m], h);

      if (null === l) {
        null === q && (q = k);
        break;
      }

      a && q && null === l.alternate && b(e, q);
      t = p(l, t, m);
      null === r ? g = l : r.sibling = l;
      r = l;
      q = k;
    }

    if (m === f.length) return d(e, q), g;

    if (null === q) {
      for (; m < f.length; m++) {
        if (q = x(e, f[m], h)) t = p(q, t, m), null === r ? g = q : r.sibling = q, r = q;
      }

      return g;
    }

    for (q = c(e, q); m < f.length; m++) {
      if (k = D(q, e, m, f[m], h)) {
        if (a && null !== k.alternate) q["delete"](null === k.key ? m : k.key);
        t = p(k, t, m);
        null === r ? g = k : r.sibling = k;
        r = k;
      }
    }

    a && q.forEach(function (a) {
      return b(e, a);
    });
    return g;
  }

  function H(e, t, f, h) {
    var g = pb(f);
    "function" !== typeof g ? K("150") : void 0;
    f = g.call(f);
    null == f ? K("151") : void 0;

    for (var r = g = null, q = t, m = t = 0, k = null, l = f.next(); null !== q && !l.done; m++, l = f.next()) {
      q.index > m ? (k = q, q = null) : k = q.sibling;
      var E = B(e, q, l.value, h);

      if (null === E) {
        q || (q = k);
        break;
      }

      a && q && null === E.alternate && b(e, q);
      t = p(E, t, m);
      null === r ? g = E : r.sibling = E;
      r = E;
      q = k;
    }

    if (l.done) return d(e, q), g;

    if (null === q) {
      for (; !l.done; m++, l = f.next()) {
        l = x(e, l.value, h), null !== l && (t = p(l, t, m), null === r ? g = l : r.sibling = l, r = l);
      }

      return g;
    }

    for (q = c(e, q); !l.done; m++, l = f.next()) {
      if (l = D(q, e, m, l.value, h), null !== l) {
        if (a && null !== l.alternate) q["delete"](null === l.key ? m : l.key);
        t = p(l, t, m);
        null === r ? g = l : r.sibling = l;
        r = l;
      }
    }

    a && q.forEach(function (a) {
      return b(e, a);
    });
    return g;
  }

  return function (a, c, f, h) {
    "object" === typeof f && null !== f && f.type === Y && null === f.key && (f = f.props.children);
    var g = "object" === typeof f && null !== f;
    if (g) switch (f.$$typeof) {
      case kb:
        a: {
          var r = f.key;

          for (g = c; null !== g;) {
            if (g.key === r) {
              if (10 === g.tag ? f.type === Y : g.type === f.type) {
                d(a, g.sibling);
                c = e(g, f.type === Y ? f.props.children : f.props, h);
                c.ref = rb(g, f);
                c["return"] = a;
                a = c;
                break a;
              } else {
                d(a, g);
                break;
              }
            } else b(a, g);
            g = g.sibling;
          }

          f.type === Y ? (c = Ea(f.props.children, a.internalContextTag, h, f.key), c["return"] = a, a = c) : (h = Da(f, a.internalContextTag, h), h.ref = rb(c, f), h["return"] = a, a = h);
        }

        return k(a);

      case lb:
        a: {
          for (g = f.key; null !== c;) {
            if (c.key === g) {
              if (7 === c.tag) {
                d(a, c.sibling);
                c = e(c, f, h);
                c["return"] = a;
                a = c;
                break a;
              } else {
                d(a, c);
                break;
              }
            } else b(a, c);
            c = c.sibling;
          }

          c = Ga(f, a.internalContextTag, h);
          c["return"] = a;
          a = c;
        }

        return k(a);

      case mb:
        a: {
          if (null !== c) if (9 === c.tag) {
            d(a, c.sibling);
            c = e(c, null, h);
            c.type = f.value;
            c["return"] = a;
            a = c;
            break a;
          } else d(a, c);
          c = Ha(f, a.internalContextTag, h);
          c.type = f.value;
          c["return"] = a;
          a = c;
        }

        return k(a);

      case nb:
        a: {
          for (g = f.key; null !== c;) {
            if (c.key === g) {
              if (4 === c.tag && c.stateNode.containerInfo === f.containerInfo && c.stateNode.implementation === f.implementation) {
                d(a, c.sibling);
                c = e(c, f.children || [], h);
                c["return"] = a;
                a = c;
                break a;
              } else {
                d(a, c);
                break;
              }
            } else b(a, c);
            c = c.sibling;
          }

          c = Ia(f, a.internalContextTag, h);
          c["return"] = a;
          a = c;
        }

        return k(a);
    }
    if ("string" === typeof f || "number" === typeof f) return f = "" + f, null !== c && 6 === c.tag ? (d(a, c.sibling), c = e(c, f, h)) : (d(a, c), c = Fa(f, a.internalContextTag, h)), c["return"] = a, a = c, k(a);
    if (qb(f)) return G(a, c, f, h);
    if (pb(f)) return H(a, c, f, h);
    g && sb(a, f);
    if ("undefined" === typeof f) switch (a.tag) {
      case 2:
      case 1:
        h = a.type, K("152", h.displayName || h.name || "Component");
    }
    return d(a, c);
  };
}

var ub = tb(!0),
    vb = tb(!1);

function wb(a, b, d, c, e) {
  function p(a, b, f) {
    var c = b.expirationTime;
    b.child = null === a ? vb(b, null, f, c) : ub(b, a.child, f, c);
  }

  function k(a, b) {
    var f = b.ref;
    null === f || a && a.ref === f || (b.effectTag |= 128);
  }

  function g(a, b, f, c) {
    k(a, b);
    if (!f) return c && Ba(b, !1), u(a, b);
    f = b.stateNode;
    ia.current = b;
    var h = f.render();
    b.effectTag |= 1;
    p(a, b, h);
    b.memoizedState = f.state;
    b.memoizedProps = f.props;
    c && Ba(b, !0);
    return b.child;
  }

  function l(a) {
    var b = a.stateNode;
    b.pendingContext ? ya(a, b.pendingContext, b.pendingContext !== b.context) : b.context && ya(a, b.context, !1);
    D(a, b.containerInfo);
  }

  function u(a, b) {
    null !== a && b.child !== a.child ? K("153") : void 0;

    if (null !== b.child) {
      a = b.child;
      var f = Ca(a, a.pendingProps, a.expirationTime);
      b.child = f;

      for (f["return"] = b; null !== a.sibling;) {
        a = a.sibling, f = f.sibling = Ca(a, a.pendingProps, a.expirationTime), f["return"] = b;
      }

      f.sibling = null;
    }

    return b.child;
  }

  function A(a, b) {
    switch (b.tag) {
      case 3:
        l(b);
        break;

      case 2:
        Aa(b);
        break;

      case 4:
        D(b, b.stateNode.containerInfo);
    }

    return null;
  }

  var y = a.shouldSetTextContent,
      w = a.useSyncScheduling,
      x = a.shouldDeprioritizeSubtree,
      B = b.pushHostContext,
      D = b.pushHostContainer,
      G = d.enterHydrationState,
      H = d.resetHydrationState,
      E = d.tryToClaimNextHydratableInstance;
  a = ib(c, e, function (a, b) {
    a.memoizedProps = b;
  }, function (a, b) {
    a.memoizedState = b;
  });
  var t = a.adoptClassInstance,
      f = a.constructClassInstance,
      h = a.mountClassInstance,
      ca = a.updateClassInstance;
  return {
    beginWork: function beginWork(a, b, c) {
      if (0 === b.expirationTime || b.expirationTime > c) return A(a, b);

      switch (b.tag) {
        case 0:
          null !== a ? K("155") : void 0;
          var d = b.type,
              e = b.pendingProps,
              r = ua(b);
          r = wa(b, r);
          d = d(e, r);
          b.effectTag |= 1;
          "object" === typeof d && null !== d && "function" === typeof d.render ? (b.tag = 2, e = Aa(b), t(b, d), h(b, c), b = g(a, b, !0, e)) : (b.tag = 1, p(a, b, d), b.memoizedProps = e, b = b.child);
          return b;

        case 1:
          a: {
            e = b.type;
            c = b.pendingProps;
            d = b.memoizedProps;
            if (Q.current) null === c && (c = d);else if (null === c || d === c) {
              b = u(a, b);
              break a;
            }
            d = ua(b);
            d = wa(b, d);
            e = e(c, d);
            b.effectTag |= 1;
            p(a, b, e);
            b.memoizedProps = c;
            b = b.child;
          }

          return b;

        case 2:
          return e = Aa(b), d = void 0, null === a ? b.stateNode ? K("153") : (f(b, b.pendingProps), h(b, c), d = !0) : d = ca(a, b, c), g(a, b, d, e);

        case 3:
          return l(b), e = b.updateQueue, null !== e ? (d = b.memoizedState, e = gb(a, b, e, null, null, c), d === e ? (H(), b = u(a, b)) : (d = e.element, r = b.stateNode, (null === a || null === a.child) && r.hydrate && G(b) ? (b.effectTag |= 2, b.child = vb(b, null, d, c)) : (H(), p(a, b, d)), b.memoizedState = e, b = b.child)) : (H(), b = u(a, b)), b;

        case 5:
          B(b);
          null === a && E(b);
          e = b.type;
          var m = b.memoizedProps;
          d = b.pendingProps;
          null === d && (d = m, null === d ? K("154") : void 0);
          r = null !== a ? a.memoizedProps : null;
          Q.current || null !== d && m !== d ? (m = d.children, y(e, d) ? m = null : r && y(e, r) && (b.effectTag |= 16), k(a, b), 2147483647 !== c && !w && x(e, d) ? (b.expirationTime = 2147483647, b = null) : (p(a, b, m), b.memoizedProps = d, b = b.child)) : b = u(a, b);
          return b;

        case 6:
          return null === a && E(b), a = b.pendingProps, null === a && (a = b.memoizedProps), b.memoizedProps = a, null;

        case 8:
          b.tag = 7;

        case 7:
          e = b.pendingProps;
          if (Q.current) null === e && (e = a && a.memoizedProps, null === e ? K("154") : void 0);else if (null === e || b.memoizedProps === e) e = b.memoizedProps;
          d = e.children;
          b.stateNode = null === a ? vb(b, b.stateNode, d, c) : ub(b, b.stateNode, d, c);
          b.memoizedProps = e;
          return b.stateNode;

        case 9:
          return null;

        case 4:
          a: {
            D(b, b.stateNode.containerInfo);
            e = b.pendingProps;
            if (Q.current) null === e && (e = a && a.memoizedProps, null == e ? K("154") : void 0);else if (null === e || b.memoizedProps === e) {
              b = u(a, b);
              break a;
            }
            null === a ? b.child = ub(b, null, e, c) : p(a, b, e);
            b.memoizedProps = e;
            b = b.child;
          }

          return b;

        case 10:
          a: {
            c = b.pendingProps;
            if (Q.current) null === c && (c = b.memoizedProps);else if (null === c || b.memoizedProps === c) {
              b = u(a, b);
              break a;
            }
            p(a, b, c);
            b.memoizedProps = c;
            b = b.child;
          }

          return b;

        default:
          K("156");
      }
    },
    beginFailedWork: function beginFailedWork(b, a, c) {
      switch (a.tag) {
        case 2:
          Aa(a);
          break;

        case 3:
          l(a);
          break;

        default:
          K("157");
      }

      a.effectTag |= 64;
      null === b ? a.child = null : a.child !== b.child && (a.child = b.child);
      if (0 === a.expirationTime || a.expirationTime > c) return A(b, a);
      a.firstEffect = null;
      a.lastEffect = null;
      a.child = null === b ? vb(a, null, null, c) : ub(a, b.child, null, c);
      2 === a.tag && (b = a.stateNode, a.memoizedProps = b.props, a.memoizedState = b.state);
      return a.child;
    }
  };
}

function xb(a, b, d) {
  function c(a) {
    a.effectTag |= 4;
  }

  var e = a.createInstance,
      p = a.createTextInstance,
      k = a.appendInitialChild,
      g = a.finalizeInitialChildren,
      l = a.prepareUpdate,
      u = a.persistence,
      A = b.getRootHostContainer,
      y = b.popHostContext,
      w = b.getHostContext,
      x = b.popHostContainer,
      B = d.prepareToHydrateHostInstance,
      D = d.prepareToHydrateHostTextInstance,
      G = d.popHydrationState,
      H = void 0,
      E = void 0,
      t = void 0;
  a.mutation ? (H = function H() {}, E = function E(a, b, d) {
    (b.updateQueue = d) && c(b);
  }, t = function t(a, b, d, e) {
    d !== e && c(b);
  }) : u ? K("235") : K("236");
  return {
    completeWork: function completeWork(a, b, d) {
      var f = b.pendingProps;
      if (null === f) f = b.memoizedProps;else if (2147483647 !== b.expirationTime || 2147483647 === d) b.pendingProps = null;

      switch (b.tag) {
        case 1:
          return null;

        case 2:
          return xa(b), null;

        case 3:
          x(b);
          M(Q, b);
          M(O, b);
          f = b.stateNode;
          f.pendingContext && (f.context = f.pendingContext, f.pendingContext = null);
          if (null === a || null === a.child) G(b), b.effectTag &= -3;
          H(b);
          return null;

        case 5:
          y(b);
          d = A();
          var h = b.type;

          if (null !== a && null != b.stateNode) {
            var m = a.memoizedProps,
                u = b.stateNode,
                ca = w();
            u = l(u, h, m, f, d, ca);
            E(a, b, u, h, m, f, d);
            a.ref !== b.ref && (b.effectTag |= 128);
          } else {
            if (!f) return null === b.stateNode ? K("166") : void 0, null;
            a = w();
            if (G(b)) B(b, d, a) && c(b);else {
              a = e(h, f, d, a, b);

              a: for (m = b.child; null !== m;) {
                if (5 === m.tag || 6 === m.tag) k(a, m.stateNode);else if (4 !== m.tag && null !== m.child) {
                  m.child["return"] = m;
                  m = m.child;
                  continue;
                }
                if (m === b) break;

                for (; null === m.sibling;) {
                  if (null === m["return"] || m["return"] === b) break a;
                  m = m["return"];
                }

                m.sibling["return"] = m["return"];
                m = m.sibling;
              }

              g(a, h, f, d) && c(b);
              b.stateNode = a;
            }
            null !== b.ref && (b.effectTag |= 128);
          }

          return null;

        case 6:
          if (a && null != b.stateNode) t(a, b, a.memoizedProps, f);else {
            if ("string" !== typeof f) return null === b.stateNode ? K("166") : void 0, null;
            a = A();
            d = w();
            G(b) ? D(b) && c(b) : b.stateNode = p(f, a, d, b);
          }
          return null;

        case 7:
          (f = b.memoizedProps) ? void 0 : K("165");
          b.tag = 8;
          h = [];

          a: for ((m = b.stateNode) && (m["return"] = b); null !== m;) {
            if (5 === m.tag || 6 === m.tag || 4 === m.tag) K("247");else if (9 === m.tag) h.push(m.type);else if (null !== m.child) {
              m.child["return"] = m;
              m = m.child;
              continue;
            }

            for (; null === m.sibling;) {
              if (null === m["return"] || m["return"] === b) break a;
              m = m["return"];
            }

            m.sibling["return"] = m["return"];
            m = m.sibling;
          }

          m = f.handler;
          f = m(f.props, h);
          b.child = ub(b, null !== a ? a.child : null, f, d);
          return b.child;

        case 8:
          return b.tag = 7, null;

        case 9:
          return null;

        case 10:
          return null;

        case 4:
          return x(b), H(b), null;

        case 0:
          K("167");

        default:
          K("156");
      }
    }
  };
}

function yb(a, b) {
  function d(a) {
    var c = a.ref;
    if (null !== c) try {
      c(null);
    } catch (h) {
      b(a, h);
    }
  }

  function c(a) {
    "function" === typeof Ta && Ta(a);

    switch (a.tag) {
      case 2:
        d(a);
        var c = a.stateNode;
        if ("function" === typeof c.componentWillUnmount) try {
          c.props = a.memoizedProps, c.state = a.memoizedState, c.componentWillUnmount();
        } catch (h) {
          b(a, h);
        }
        break;

      case 5:
        d(a);
        break;

      case 7:
        e(a.stateNode);
        break;

      case 4:
        l && k(a);
    }
  }

  function e(b) {
    for (var a = b;;) {
      if (c(a), null === a.child || l && 4 === a.tag) {
        if (a === b) break;

        for (; null === a.sibling;) {
          if (null === a["return"] || a["return"] === b) return;
          a = a["return"];
        }

        a.sibling["return"] = a["return"];
        a = a.sibling;
      } else a.child["return"] = a, a = a.child;
    }
  }

  function p(a) {
    return 5 === a.tag || 3 === a.tag || 4 === a.tag;
  }

  function k(a) {
    for (var b = a, d = !1, g = void 0, l = void 0;;) {
      if (!d) {
        d = b["return"];

        a: for (;;) {
          null === d ? K("160") : void 0;

          switch (d.tag) {
            case 5:
              g = d.stateNode;
              l = !1;
              break a;

            case 3:
              g = d.stateNode.containerInfo;
              l = !0;
              break a;

            case 4:
              g = d.stateNode.containerInfo;
              l = !0;
              break a;
          }

          d = d["return"];
        }

        d = !0;
      }

      if (5 === b.tag || 6 === b.tag) e(b), l ? E(g, b.stateNode) : H(g, b.stateNode);else if (4 === b.tag ? g = b.stateNode.containerInfo : c(b), null !== b.child) {
        b.child["return"] = b;
        b = b.child;
        continue;
      }
      if (b === a) break;

      for (; null === b.sibling;) {
        if (null === b["return"] || b["return"] === a) return;
        b = b["return"];
        4 === b.tag && (d = !1);
      }

      b.sibling["return"] = b["return"];
      b = b.sibling;
    }
  }

  var g = a.getPublicInstance,
      l = a.mutation;
  a = a.persistence;
  l || (a ? K("235") : K("236"));
  var u = l.commitMount,
      A = l.commitUpdate,
      y = l.resetTextContent,
      w = l.commitTextUpdate,
      x = l.appendChild,
      B = l.appendChildToContainer,
      D = l.insertBefore,
      G = l.insertInContainerBefore,
      H = l.removeChild,
      E = l.removeChildFromContainer;
  return {
    commitResetTextContent: function commitResetTextContent(b) {
      y(b.stateNode);
    },
    commitPlacement: function commitPlacement(b) {
      a: {
        for (var a = b["return"]; null !== a;) {
          if (p(a)) {
            var c = a;
            break a;
          }

          a = a["return"];
        }

        K("160");
        c = void 0;
      }

      var d = a = void 0;

      switch (c.tag) {
        case 5:
          a = c.stateNode;
          d = !1;
          break;

        case 3:
          a = c.stateNode.containerInfo;
          d = !0;
          break;

        case 4:
          a = c.stateNode.containerInfo;
          d = !0;
          break;

        default:
          K("161");
      }

      c.effectTag & 16 && (y(a), c.effectTag &= -17);

      a: b: for (c = b;;) {
        for (; null === c.sibling;) {
          if (null === c["return"] || p(c["return"])) {
            c = null;
            break a;
          }

          c = c["return"];
        }

        c.sibling["return"] = c["return"];

        for (c = c.sibling; 5 !== c.tag && 6 !== c.tag;) {
          if (c.effectTag & 2) continue b;
          if (null === c.child || 4 === c.tag) continue b;else c.child["return"] = c, c = c.child;
        }

        if (!(c.effectTag & 2)) {
          c = c.stateNode;
          break a;
        }
      }

      for (var e = b;;) {
        if (5 === e.tag || 6 === e.tag) c ? d ? G(a, e.stateNode, c) : D(a, e.stateNode, c) : d ? B(a, e.stateNode) : x(a, e.stateNode);else if (4 !== e.tag && null !== e.child) {
          e.child["return"] = e;
          e = e.child;
          continue;
        }
        if (e === b) break;

        for (; null === e.sibling;) {
          if (null === e["return"] || e["return"] === b) return;
          e = e["return"];
        }

        e.sibling["return"] = e["return"];
        e = e.sibling;
      }
    },
    commitDeletion: function commitDeletion(b) {
      k(b);
      b["return"] = null;
      b.child = null;
      b.alternate && (b.alternate.child = null, b.alternate["return"] = null);
    },
    commitWork: function commitWork(b, a) {
      switch (a.tag) {
        case 2:
          break;

        case 5:
          var c = a.stateNode;

          if (null != c) {
            var d = a.memoizedProps;
            b = null !== b ? b.memoizedProps : d;
            var e = a.type,
                f = a.updateQueue;
            a.updateQueue = null;
            null !== f && A(c, f, e, b, d, a);
          }

          break;

        case 6:
          null === a.stateNode ? K("162") : void 0;
          c = a.memoizedProps;
          w(a.stateNode, null !== b ? b.memoizedProps : c, c);
          break;

        case 3:
          break;

        default:
          K("163");
      }
    },
    commitLifeCycles: function commitLifeCycles(b, a) {
      switch (a.tag) {
        case 2:
          var c = a.stateNode;
          if (a.effectTag & 4) if (null === b) c.props = a.memoizedProps, c.state = a.memoizedState, c.componentDidMount();else {
            var d = b.memoizedProps;
            b = b.memoizedState;
            c.props = a.memoizedProps;
            c.state = a.memoizedState;
            c.componentDidUpdate(d, b);
          }
          a = a.updateQueue;
          null !== a && hb(a, c);
          break;

        case 3:
          c = a.updateQueue;
          null !== c && hb(c, null !== a.child ? a.child.stateNode : null);
          break;

        case 5:
          c = a.stateNode;
          null === b && a.effectTag & 4 && u(c, a.type, a.memoizedProps, a);
          break;

        case 6:
          break;

        case 4:
          break;

        default:
          K("163");
      }
    },
    commitAttachRef: function commitAttachRef(a) {
      var b = a.ref;

      if (null !== b) {
        var c = a.stateNode;

        switch (a.tag) {
          case 5:
            b(g(c));
            break;

          default:
            b(c);
        }
      }
    },
    commitDetachRef: function commitDetachRef(a) {
      a = a.ref;
      null !== a && a(null);
    }
  };
}

var zb = {};

function Ab(a) {
  function b(a) {
    a === zb ? K("174") : void 0;
    return a;
  }

  var d = a.getChildHostContext,
      c = a.getRootHostContext,
      e = {
    current: zb
  },
      p = {
    current: zb
  },
      k = {
    current: zb
  };
  return {
    getHostContext: function getHostContext() {
      return b(e.current);
    },
    getRootHostContainer: function getRootHostContainer() {
      return b(k.current);
    },
    popHostContainer: function popHostContainer(a) {
      M(e, a);
      M(p, a);
      M(k, a);
    },
    popHostContext: function popHostContext(a) {
      p.current === a && (M(e, a), M(p, a));
    },
    pushHostContainer: function pushHostContainer(a, b) {
      N(k, b, a);
      b = c(b);
      N(p, a, a);
      N(e, b, a);
    },
    pushHostContext: function pushHostContext(a) {
      var c = b(k.current),
          g = b(e.current);
      c = d(g, a.type, c);
      g !== c && (N(p, a, a), N(e, c, a));
    },
    resetHostContainer: function resetHostContainer() {
      e.current = zb;
      k.current = zb;
    }
  };
}

function Bb(a) {
  function b(a, b) {
    var c = new X(5, null, 0);
    c.type = "DELETED";
    c.stateNode = b;
    c["return"] = a;
    c.effectTag = 8;
    null !== a.lastEffect ? (a.lastEffect.nextEffect = c, a.lastEffect = c) : a.firstEffect = a.lastEffect = c;
  }

  function d(a, b) {
    switch (a.tag) {
      case 5:
        return b = p(b, a.type, a.pendingProps), null !== b ? (a.stateNode = b, !0) : !1;

      case 6:
        return b = k(b, a.pendingProps), null !== b ? (a.stateNode = b, !0) : !1;

      default:
        return !1;
    }
  }

  function c(a) {
    for (a = a["return"]; null !== a && 5 !== a.tag && 3 !== a.tag;) {
      a = a["return"];
    }

    y = a;
  }

  var e = a.shouldSetTextContent;
  a = a.hydration;
  if (!a) return {
    enterHydrationState: function enterHydrationState() {
      return !1;
    },
    resetHydrationState: function resetHydrationState() {},
    tryToClaimNextHydratableInstance: function tryToClaimNextHydratableInstance() {},
    prepareToHydrateHostInstance: function prepareToHydrateHostInstance() {
      K("175");
    },
    prepareToHydrateHostTextInstance: function prepareToHydrateHostTextInstance() {
      K("176");
    },
    popHydrationState: function popHydrationState() {
      return !1;
    }
  };
  var p = a.canHydrateInstance,
      k = a.canHydrateTextInstance,
      g = a.getNextHydratableSibling,
      l = a.getFirstHydratableChild,
      u = a.hydrateInstance,
      A = a.hydrateTextInstance,
      y = null,
      w = null,
      x = !1;
  return {
    enterHydrationState: function enterHydrationState(a) {
      w = l(a.stateNode.containerInfo);
      y = a;
      return x = !0;
    },
    resetHydrationState: function resetHydrationState() {
      w = y = null;
      x = !1;
    },
    tryToClaimNextHydratableInstance: function tryToClaimNextHydratableInstance(a) {
      if (x) {
        var c = w;

        if (c) {
          if (!d(a, c)) {
            c = g(c);

            if (!c || !d(a, c)) {
              a.effectTag |= 2;
              x = !1;
              y = a;
              return;
            }

            b(y, w);
          }

          y = a;
          w = l(c);
        } else a.effectTag |= 2, x = !1, y = a;
      }
    },
    prepareToHydrateHostInstance: function prepareToHydrateHostInstance(a, b, c) {
      b = u(a.stateNode, a.type, a.memoizedProps, b, c, a);
      a.updateQueue = b;
      return null !== b ? !0 : !1;
    },
    prepareToHydrateHostTextInstance: function prepareToHydrateHostTextInstance(a) {
      return A(a.stateNode, a.memoizedProps, a);
    },
    popHydrationState: function popHydrationState(a) {
      if (a !== y) return !1;
      if (!x) return c(a), x = !0, !1;
      var d = a.type;
      if (5 !== a.tag || "head" !== d && "body" !== d && !e(d, a.memoizedProps)) for (d = w; d;) {
        b(a, d), d = g(d);
      }
      c(a);
      w = y ? g(a.stateNode) : null;
      return !0;
    }
  };
}

function Cb(a) {
  function b(a) {
    Ja = S = !0;
    var b = a.stateNode;
    b.current === a ? K("177") : void 0;
    b.isReadyForCommit = !1;
    ia.current = null;
    if (1 < a.effectTag) {
      if (null !== a.lastEffect) {
        a.lastEffect.nextEffect = a;
        var c = a.firstEffect;
      } else c = a;
    } else c = a.firstEffect;
    fc();

    for (v = c; null !== v;) {
      var d = !1,
          e = void 0;

      try {
        for (; null !== v;) {
          var f = v.effectTag;
          f & 16 && gc(v);

          if (f & 128) {
            var ea = v.alternate;
            null !== ea && hc(ea);
          }

          switch (f & -242) {
            case 2:
              Eb(v);
              v.effectTag &= -3;
              break;

            case 6:
              Eb(v);
              v.effectTag &= -3;
              Fb(v.alternate, v);
              break;

            case 4:
              Fb(v.alternate, v);
              break;

            case 8:
              Za = !0, ic(v), Za = !1;
          }

          v = v.nextEffect;
        }
      } catch ($a) {
        d = !0, e = $a;
      }

      d && (null === v ? K("178") : void 0, g(v, e), null !== v && (v = v.nextEffect));
    }

    jc();
    b.current = a;

    for (v = c; null !== v;) {
      c = !1;
      d = void 0;

      try {
        for (; null !== v;) {
          var k = v.effectTag;
          k & 36 && kc(v.alternate, v);
          k & 128 && lc(v);
          if (k & 64) switch (e = v, f = void 0, null !== J && (f = J.get(e), J["delete"](e), null == f && null !== e.alternate && (e = e.alternate, f = J.get(e), J["delete"](e))), null == f ? K("184") : void 0, e.tag) {
            case 2:
              e.stateNode.componentDidCatch(f.error, {
                componentStack: f.componentStack
              });
              break;

            case 3:
              null === P && (P = f.error);
              break;

            default:
              K("157");
          }
          var h = v.nextEffect;
          v.nextEffect = null;
          v = h;
        }
      } catch ($a) {
        c = !0, d = $a;
      }

      c && (null === v ? K("178") : void 0, g(v, d), null !== v && (v = v.nextEffect));
    }

    S = Ja = !1;
    "function" === typeof Sa && Sa(a.stateNode);
    R && (R.forEach(B), R = null);
    null !== P && (a = P, P = null, ca(a));
    b = b.current.expirationTime;
    0 === b && (Z = J = null);
    return b;
  }

  function d(a) {
    for (;;) {
      var b = mc(a.alternate, a, C),
          c = a["return"],
          d = a.sibling;
      var e = a;

      if (2147483647 === C || 2147483647 !== e.expirationTime) {
        if (2 !== e.tag && 3 !== e.tag) var f = 0;else f = e.updateQueue, f = null === f ? 0 : f.expirationTime;

        for (var g = e.child; null !== g;) {
          0 !== g.expirationTime && (0 === f || f > g.expirationTime) && (f = g.expirationTime), g = g.sibling;
        }

        e.expirationTime = f;
      }

      if (null !== b) return b;
      null !== c && (null === c.firstEffect && (c.firstEffect = a.firstEffect), null !== a.lastEffect && (null !== c.lastEffect && (c.lastEffect.nextEffect = a.firstEffect), c.lastEffect = a.lastEffect), 1 < a.effectTag && (null !== c.lastEffect ? c.lastEffect.nextEffect = a : c.firstEffect = a, c.lastEffect = a));
      if (null !== d) return d;
      if (null !== c) a = c;else {
        a.stateNode.isReadyForCommit = !0;
        break;
      }
    }

    return null;
  }

  function c(a) {
    var b = Zb(a.alternate, a, C);
    null === b && (b = d(a));
    ia.current = null;
    return b;
  }

  function e(a) {
    var b = nc(a.alternate, a, C);
    null === b && (b = d(a));
    ia.current = null;
    return b;
  }

  function p(a) {
    if (null !== J) {
      if (!(0 === C || C > a)) if (C <= ab) for (; null !== z;) {
        z = l(z) ? e(z) : c(z);
      } else for (; null !== z && !h();) {
        z = l(z) ? e(z) : c(z);
      }
    } else if (!(0 === C || C > a)) if (C <= ab) for (; null !== z;) {
      z = c(z);
    } else for (; null !== z && !h();) {
      z = c(z);
    }
  }

  function k(a, b) {
    S ? K("243") : void 0;
    S = !0;
    a.isReadyForCommit = !1;

    if (a !== aa || b !== C || null === z) {
      for (; -1 < L;) {
        sa[L] = null, L--;
      }

      ta = F;
      O.current = F;
      Q.current = !1;
      Yb();
      aa = a;
      C = b;
      z = Ca(aa.current, null, b);
    }

    var c = !1,
        d = null;

    try {
      p(b);
    } catch (Ya) {
      c = !0, d = Ya;
    }

    for (; c;) {
      if (qa) {
        P = d;
        break;
      }

      var f = z;
      if (null === f) qa = !0;else {
        var k = g(f, d);
        null === k ? K("183") : void 0;

        if (!qa) {
          try {
            c = k;
            d = b;

            for (k = c; null !== f;) {
              switch (f.tag) {
                case 2:
                  xa(f);
                  break;

                case 5:
                  Xb(f);
                  break;

                case 3:
                  m(f);
                  break;

                case 4:
                  m(f);
              }

              if (f === k || f.alternate === k) break;
              f = f["return"];
            }

            z = e(c);
            p(d);
          } catch (Ya) {
            c = !0;
            d = Ya;
            continue;
          }

          break;
        }
      }
    }

    b = P;
    qa = S = !1;
    P = null;
    null !== b && ca(b);
    return a.isReadyForCommit ? a.current.alternate : null;
  }

  function g(a, b) {
    var c = ia.current = null,
        d = !1,
        e = !1,
        f = null;
    if (3 === a.tag) c = a, u(a) && (qa = !0);else for (var g = a["return"]; null !== g && null === c;) {
      2 === g.tag ? "function" === typeof g.stateNode.componentDidCatch && (d = !0, f = ja(g), c = g, e = !0) : 3 === g.tag && (c = g);

      if (u(g)) {
        if (Za || null !== R && (R.has(g) || null !== g.alternate && R.has(g.alternate))) return null;
        c = null;
        e = !1;
      }

      g = g["return"];
    }

    if (null !== c) {
      null === Z && (Z = new Set());
      Z.add(c);
      var k = "";
      g = a;

      do {
        a: switch (g.tag) {
          case 0:
          case 1:
          case 2:
          case 5:
            var h = g._debugOwner,
                l = g._debugSource;
            var m = ja(g);
            var ea = null;
            h && (ea = ja(h));
            h = l;
            m = "\n    in " + (m || "Unknown") + (h ? " (at " + h.fileName.replace(/^.*[\\\/]/, "") + ":" + h.lineNumber + ")" : ea ? " (created by " + ea + ")" : "");
            break a;

          default:
            m = "";
        }

        k += m;
        g = g["return"];
      } while (g);

      g = k;
      a = ja(a);
      null === J && (J = new Map());
      b = {
        componentName: a,
        componentStack: g,
        error: b,
        errorBoundary: d ? c.stateNode : null,
        errorBoundaryFound: d,
        errorBoundaryName: f,
        willRetry: e
      };
      J.set(c, b);

      try {
        var p = b.error;
        p && p.suppressReactErrorLogging || console.error(p);
      } catch (bb) {
        bb && bb.suppressReactErrorLogging || console.error(bb);
      }

      Ja ? (null === R && (R = new Set()), R.add(c)) : B(c);
      return c;
    }

    null === P && (P = b);
    return null;
  }

  function l(a) {
    return null !== J && (J.has(a) || null !== a.alternate && J.has(a.alternate));
  }

  function u(a) {
    return null !== Z && (Z.has(a) || null !== a.alternate && Z.has(a.alternate));
  }

  function A() {
    return 20 * (((D() + 100) / 20 | 0) + 1);
  }

  function y(a) {
    return 0 !== T ? T : S ? Ja ? 1 : C : !oc || a.internalContextTag & 1 ? A() : 1;
  }

  function w(a, b) {
    return x(a, b, !1);
  }

  function x(a, b) {
    for (; null !== a;) {
      if (0 === a.expirationTime || a.expirationTime > b) a.expirationTime = b;
      null !== a.alternate && (0 === a.alternate.expirationTime || a.alternate.expirationTime > b) && (a.alternate.expirationTime = b);
      if (null === a["return"]) if (3 === a.tag) {
        var c = a.stateNode;
        !S && c === aa && b < C && (z = aa = null, C = 0);
        var d = c,
            e = b;
        Ka > pc && K("185");
        if (null === d.nextScheduledRoot) d.remainingExpirationTime = e, null === I ? (ba = I = d, d.nextScheduledRoot = d) : (I = I.nextScheduledRoot = d, I.nextScheduledRoot = ba);else {
          var g = d.remainingExpirationTime;
          if (0 === g || e < g) d.remainingExpirationTime = e;
        }
        fa || (U ? La && (V = d, W = 1, f(V, W)) : 1 === e ? t(1, null) : G(e));
        !S && c === aa && b < C && (z = aa = null, C = 0);
      } else break;
      a = a["return"];
    }
  }

  function B(a) {
    x(a, 1, !0);
  }

  function D() {
    return ab = ((cb() - Gb) / 10 | 0) + 2;
  }

  function G(a) {
    if (0 !== Ma) {
      if (a > Ma) return;
      qc(db);
    }

    var b = cb() - Gb;
    Ma = a;
    db = rc(E, {
      timeout: 10 * (a - 2) - b
    });
  }

  function H() {
    var a = 0,
        b = null;
    if (null !== I) for (var c = I, d = ba; null !== d;) {
      var e = d.remainingExpirationTime;

      if (0 === e) {
        null === c || null === I ? K("244") : void 0;

        if (d === d.nextScheduledRoot) {
          ba = I = d.nextScheduledRoot = null;
          break;
        } else if (d === ba) ba = e = d.nextScheduledRoot, I.nextScheduledRoot = e, d.nextScheduledRoot = null;else if (d === I) {
          I = c;
          I.nextScheduledRoot = ba;
          d.nextScheduledRoot = null;
          break;
        } else c.nextScheduledRoot = d.nextScheduledRoot, d.nextScheduledRoot = null;

        d = c.nextScheduledRoot;
      } else {
        if (0 === a || e < a) a = e, b = d;
        if (d === I) break;
        c = d;
        d = d.nextScheduledRoot;
      }
    }
    c = V;
    null !== c && c === b ? Ka++ : Ka = 0;
    V = b;
    W = a;
  }

  function E(a) {
    t(0, a);
  }

  function t(a, b) {
    ra = b;

    for (H(); null !== V && 0 !== W && (0 === a || W <= a) && !eb;) {
      f(V, W), H();
    }

    null !== ra && (Ma = 0, db = -1);
    0 !== W && G(W);
    ra = null;
    eb = !1;
    Ka = 0;
    if (Na) throw a = fb, fb = null, Na = !1, a;
  }

  function f(a, c) {
    fa ? K("245") : void 0;
    fa = !0;

    if (c <= D()) {
      var d = a.finishedWork;
      null !== d ? (a.finishedWork = null, a.remainingExpirationTime = b(d)) : (a.finishedWork = null, d = k(a, c), null !== d && (a.remainingExpirationTime = b(d)));
    } else d = a.finishedWork, null !== d ? (a.finishedWork = null, a.remainingExpirationTime = b(d)) : (a.finishedWork = null, d = k(a, c), null !== d && (h() ? a.finishedWork = d : a.remainingExpirationTime = b(d)));

    fa = !1;
  }

  function h() {
    return null === ra || ra.timeRemaining() > sc ? !1 : eb = !0;
  }

  function ca(a) {
    null === V ? K("246") : void 0;
    V.remainingExpirationTime = 0;
    Na || (Na = !0, fb = a);
  }

  var r = Ab(a),
      q = Bb(a),
      m = r.popHostContainer,
      Xb = r.popHostContext,
      Yb = r.resetHostContainer,
      Db = wb(a, r, q, w, y),
      Zb = Db.beginWork,
      nc = Db.beginFailedWork,
      mc = xb(a, r, q).completeWork;
  r = yb(a, g);
  var gc = r.commitResetTextContent,
      Eb = r.commitPlacement,
      ic = r.commitDeletion,
      Fb = r.commitWork,
      kc = r.commitLifeCycles,
      lc = r.commitAttachRef,
      hc = r.commitDetachRef,
      cb = a.now,
      rc = a.scheduleDeferredCallback,
      qc = a.cancelDeferredCallback,
      oc = a.useSyncScheduling,
      fc = a.prepareForCommit,
      jc = a.resetAfterCommit,
      Gb = cb(),
      ab = 2,
      T = 0,
      S = !1,
      z = null,
      aa = null,
      C = 0,
      v = null,
      J = null,
      Z = null,
      R = null,
      P = null,
      qa = !1,
      Ja = !1,
      Za = !1,
      ba = null,
      I = null,
      Ma = 0,
      db = -1,
      fa = !1,
      V = null,
      W = 0,
      eb = !1,
      Na = !1,
      fb = null,
      ra = null,
      U = !1,
      La = !1,
      pc = 1E3,
      Ka = 0,
      sc = 1;
  return {
    computeAsyncExpiration: A,
    computeExpirationForFiber: y,
    scheduleWork: w,
    batchedUpdates: function batchedUpdates(a, b) {
      var c = U;
      U = !0;

      try {
        return a(b);
      } finally {
        (U = c) || fa || t(1, null);
      }
    },
    unbatchedUpdates: function unbatchedUpdates(a) {
      if (U && !La) {
        La = !0;

        try {
          return a();
        } finally {
          La = !1;
        }
      }

      return a();
    },
    flushSync: function flushSync(a) {
      var b = U;
      U = !0;

      try {
        a: {
          var c = T;
          T = 1;

          try {
            var d = a();
            break a;
          } finally {
            T = c;
          }

          d = void 0;
        }

        return d;
      } finally {
        U = b, fa ? K("187") : void 0, t(1, null);
      }
    },
    deferredUpdates: function deferredUpdates(a) {
      var b = T;
      T = A();

      try {
        return a();
      } finally {
        T = b;
      }
    }
  };
}

function Hb(a) {
  function b(a) {
    a = oa(a);
    return null === a ? null : a.stateNode;
  }

  var d = a.getPublicInstance;
  a = Cb(a);
  var c = a.computeAsyncExpiration,
      e = a.computeExpirationForFiber,
      p = a.scheduleWork;
  return {
    createContainer: function createContainer(a, b) {
      var c = new X(3, null, 0);
      a = {
        current: c,
        containerInfo: a,
        pendingChildren: null,
        remainingExpirationTime: 0,
        isReadyForCommit: !1,
        finishedWork: null,
        context: null,
        pendingContext: null,
        hydrate: b,
        nextScheduledRoot: null
      };
      return c.stateNode = a;
    },
    updateContainer: function updateContainer(a, b, d, u) {
      var g = b.current;

      if (d) {
        d = d._reactInternalFiber;
        var k;

        b: {
          2 === ka(d) && 2 === d.tag ? void 0 : K("170");

          for (k = d; 3 !== k.tag;) {
            if (va(k)) {
              k = k.stateNode.__reactInternalMemoizedMergedChildContext;
              break b;
            }

            (k = k["return"]) ? void 0 : K("171");
          }

          k = k.stateNode.context;
        }

        d = va(d) ? za(d, k) : k;
      } else d = F;

      null === b.context ? b.context = d : b.pendingContext = d;
      b = u;
      b = void 0 === b ? null : b;
      u = null != a && null != a.type && null != a.type.prototype && !0 === a.type.prototype.unstable_isAsyncReactComponent ? c() : e(g);
      Wa(g, {
        expirationTime: u,
        partialState: {
          element: a
        },
        callback: b,
        isReplace: !1,
        isForced: !1,
        nextCallback: null,
        next: null
      });
      p(g, u);
    },
    batchedUpdates: a.batchedUpdates,
    unbatchedUpdates: a.unbatchedUpdates,
    deferredUpdates: a.deferredUpdates,
    flushSync: a.flushSync,
    getPublicRootInstance: function getPublicRootInstance(a) {
      a = a.current;
      if (!a.child) return null;

      switch (a.child.tag) {
        case 5:
          return d(a.child.stateNode);

        default:
          return a.child.stateNode;
      }
    },
    findHostInstance: b,
    findHostInstanceWithNoPortals: function findHostInstanceWithNoPortals(a) {
      a = pa(a);
      return null === a ? null : a.stateNode;
    },
    injectIntoDevTools: function injectIntoDevTools(a) {
      var c = a.findFiberByHostInstance;
      return Ra(n({}, a, {
        findHostInstanceByFiber: function findHostInstanceByFiber(a) {
          return b(a);
        },
        findFiberByHostInstance: function findFiberByHostInstance(a) {
          return c ? c(a) : null;
        }
      }));
    }
  };
}

var Ib = Object.freeze({
  default: Hb
}),
    Jb = Ib && Hb || Ib,
    Kb = Jb["default"] ? Jb["default"] : Jb,
    Lb = null,
    Mb = null;

function Nb(a) {
  if (a = null(a)) {
    K("194");
    var b = null(a.stateNode);
    null.restoreControlledState(a.stateNode, a.type, b);
  }
}

var Ob = !1,
    Pb = function () {
  function a(a, d) {
    for (var b = 0; b < d.length; b++) {
      var e = d[b];
      e.enumerable = e.enumerable || !1;
      e.configurable = !0;
      "value" in e && (e.writable = !0);
      Object.defineProperty(a, e.key, e);
    }
  }

  return function (b, d, c) {
    d && a(b.prototype, d);
    c && a(b, c);
    return b;
  };
}(),
    Qb = {};

function Rb(a) {
  switch (a.tag) {
    case "INSTANCE":
      var b = a.rootContainerInstance.createNodeMock;
      return b({
        type: a.type,
        props: a.props
      });

    default:
      return a;
  }
}

function Sb(a, b) {
  var d = a.children.indexOf(b);
  -1 !== d && a.children.splice(d, 1);
  a.children.push(b);
}

function Tb(a, b, d) {
  var c = a.children.indexOf(b);
  -1 !== c && a.children.splice(c, 1);
  d = a.children.indexOf(d);
  a.children.splice(d, 0, b);
}

function Ub(a, b) {
  b = a.children.indexOf(b);
  a.children.splice(b, 1);
}

var Vb = Kb({
  getRootHostContext: function getRootHostContext() {
    return F;
  },
  getChildHostContext: function getChildHostContext() {
    return F;
  },
  prepareForCommit: function prepareForCommit() {},
  resetAfterCommit: function resetAfterCommit() {},
  createInstance: function createInstance(a, b, d) {
    return {
      type: a,
      props: b,
      children: [],
      rootContainerInstance: d,
      tag: "INSTANCE"
    };
  },
  appendInitialChild: function appendInitialChild(a, b) {
    var d = a.children.indexOf(b);
    -1 !== d && a.children.splice(d, 1);
    a.children.push(b);
  },
  finalizeInitialChildren: function finalizeInitialChildren() {
    return !1;
  },
  prepareUpdate: function prepareUpdate() {
    return Qb;
  },
  shouldSetTextContent: function shouldSetTextContent() {
    return !1;
  },
  shouldDeprioritizeSubtree: function shouldDeprioritizeSubtree() {
    return !1;
  },
  createTextInstance: function createTextInstance(a) {
    return {
      text: a,
      tag: "TEXT"
    };
  },
  scheduleDeferredCallback: function scheduleDeferredCallback(a) {
    return setTimeout(a, 0, {
      timeRemaining: Infinity
    });
  },
  cancelDeferredCallback: function cancelDeferredCallback(a) {
    clearTimeout(a);
  },
  useSyncScheduling: !0,
  getPublicInstance: Rb,
  now: function now() {
    return 0;
  },
  mutation: {
    commitUpdate: function commitUpdate(a, b, d, c, e) {
      a.type = d;
      a.props = e;
    },
    commitMount: function commitMount() {},
    commitTextUpdate: function commitTextUpdate(a, b, d) {
      a.text = d;
    },
    resetTextContent: function resetTextContent() {},
    appendChild: Sb,
    appendChildToContainer: Sb,
    insertBefore: Tb,
    insertInContainerBefore: Tb,
    removeChild: Ub,
    removeChildFromContainer: Ub
  }
}),
    Wb = {
  createNodeMock: function createNodeMock() {
    return null;
  }
};

function $b(a) {
  switch (a.tag) {
    case "TEXT":
      return a.text;

    case "INSTANCE":
      var b = a.props,
          d = ["children"],
          c = {},
          e;

      for (e in b) {
        0 <= d.indexOf(e) || Object.prototype.hasOwnProperty.call(b, e) && (c[e] = b[e]);
      }

      b = null;
      a.children && a.children.length && (b = a.children.map($b));
      a = {
        type: a.type,
        props: c,
        children: b
      };
      Object.defineProperty(a, "$$typeof", {
        value: Symbol["for"]("react.test.json")
      });
      return a;

    default:
      throw Error("Unexpected node type in toJSON: " + a.tag);
  }
}

function ac(a) {
  for (var b = []; null != a;) {
    b.push(a), a = a.sibling;
  }

  b = b.map(bc);
  return b.length ? b : null;
}

function bc(a) {
  if (null == a) return null;

  switch (a.tag) {
    case 3:
      return bc(a.child);

    case 2:
      var b = a.type,
          d = n({}, a.memoizedProps),
          c = a.child;
      return {
        nodeType: "component",
        type: b,
        props: d,
        instance: a.stateNode,
        rendered: c && c.sibling ? ac(a.child) : bc(a.child)
      };

    case 1:
      return b = a.type, d = n({}, a.memoizedProps), c = a.child, {
        nodeType: "component",
        type: b,
        props: d,
        instance: null,
        rendered: c && c.sibling ? ac(a.child) : bc(a.child)
      };

    case 5:
      return {
        nodeType: "host",
        type: a.type,
        props: n({}, a.memoizedProps),
        instance: null,
        rendered: ac(a.child)
      };

    case 6:
      return a.stateNode.text;

    default:
      K("214", a.tag);
  }
}

var cc = new WeakMap();

function dc(a) {
  var b = cc.get(a);
  void 0 === b && null !== a.alternate && (b = cc.get(a.alternate));
  void 0 === b && (b = new ec(a), cc.set(a, b));
  return b;
}

var tc = new Set([1, 2, 5]),
    ec = function () {
  function a(b) {
    if (!(this instanceof a)) throw new TypeError("Cannot call a class as a function");
    tc.has(b.tag) ? void 0 : K("225", b.tag);
    this._fiber = b;
  }

  a.prototype._currentFiber = function () {
    var a = na(this._fiber);
    null === a ? K("224") : void 0;
    return a;
  };

  a.prototype.find = function (a) {
    return uc(this.findAll(a, {
      deep: !1
    }), "matching custom predicate: " + a.toString());
  };

  a.prototype.findByType = function (a) {
    return uc(this.findAllByType(a, {
      deep: !1
    }), 'with node type: "' + (a.displayName || a.name) + '"');
  };

  a.prototype.findByProps = function (a) {
    return uc(this.findAllByProps(a, {
      deep: !1
    }), "with props: " + JSON.stringify(a));
  };

  a.prototype.findAll = function (a) {
    return vc(this, a, 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : null);
  };

  a.prototype.findAllByType = function (a) {
    return vc(this, function (b) {
      return b.type === a;
    }, 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : null);
  };

  a.prototype.findAllByProps = function (a) {
    return vc(this, function (b) {
      var c;
      if (c = b.props) a: {
        for (var d in a) {
          if (b.props[d] !== a[d]) {
            c = !1;
            break a;
          }
        }

        c = !0;
      }
      return c;
    }, 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : null);
  };

  Pb(a, [{
    key: "instance",
    get: function get() {
      return 5 === this._fiber.tag ? Rb(this._fiber.stateNode) : this._fiber.stateNode;
    }
  }, {
    key: "type",
    get: function get() {
      return this._fiber.type;
    }
  }, {
    key: "props",
    get: function get() {
      return this._currentFiber().memoizedProps;
    }
  }, {
    key: "parent",
    get: function get() {
      var a = this._fiber["return"];
      return null === a || 3 === a.tag ? null : dc(a);
    }
  }, {
    key: "children",
    get: function get() {
      var a = [],
          d = this._currentFiber(),
          c = d;

      if (null === c.child) return a;
      c.child["return"] = c;
      c = c.child;

      a: for (;;) {
        var e = !1;

        switch (c.tag) {
          case 1:
          case 2:
          case 5:
            a.push(dc(c));
            break;

          case 6:
            a.push("" + c.memoizedProps);
            break;

          case 10:
            e = !0;
            break;

          default:
            K("226", c.tag);
        }

        if (e && null !== c.child) c.child["return"] = c, c = c.child;else {
          for (; null === c.sibling;) {
            if (c["return"] === d) break a;
            c = c["return"];
          }

          c.sibling["return"] = c["return"];
          c = c.sibling;
        }
      }

      return a;
    }
  }]);
  return a;
}();

function vc(a, b, d) {
  var c = d ? d.deep : !0,
      e = [];
  if (b(a) && (e.push(a), !c)) return e;
  c = !0;
  var p = !1,
      k = void 0;

  try {
    for (var g = a.children[Symbol.iterator](), l; !(c = (l = g.next()).done); c = !0) {
      var u = l.value;
      "string" !== typeof u && e.push.apply(e, vc(u, b, d));
    }
  } catch (A) {
    p = !0, k = A;
  } finally {
    try {
      if (!c && g["return"]) g["return"]();
    } finally {
      if (p) throw k;
    }
  }

  return e;
}

function uc(a, b) {
  if (1 === a.length) return a[0];
  throw Error((0 === a.length ? "No instances found " : "Expected 1 but found " + a.length + " instances ") + b);
}

var wc = {
  create: function create(a, b) {
    var d = Wb.createNodeMock;
    b && "function" === typeof b.createNodeMock && (d = b.createNodeMock);
    var c = {
      children: [],
      createNodeMock: d,
      tag: "CONTAINER"
    },
        e = Vb.createContainer(c, !1);
    null == e ? K("215") : void 0;
    Vb.updateContainer(a, e, null, null);
    a = {
      root: void 0,
      toJSON: function toJSON() {
        return null == e || null == e.current || null == c || 0 === c.children.length ? null : 1 === c.children.length ? $b(c.children[0]) : c.children.map($b);
      },
      toTree: function toTree() {
        return null == e || null == e.current ? null : bc(e.current);
      },
      update: function update(a) {
        null != e && null != e.current && Vb.updateContainer(a, e, null, null);
      },
      unmount: function unmount() {
        null != e && null != e.current && (Vb.updateContainer(null, e, null), e = c = null);
      },
      getInstance: function getInstance() {
        return null == e || null == e.current ? null : Vb.getPublicRootInstance(e);
      }
    };
    Object.defineProperty(a, "root", {
      configurable: !0,
      enumerable: !0,
      get: function get() {
        if (null === e || null === e.current.child) throw Error("Can't access .root on unmounted test renderer");
        return dc(e.current.child);
      }
    });
    return a;
  },
  unstable_batchedUpdates: function unstable_batchedUpdates(a, b) {
    if (Ob) return a(b);
    Ob = !0;

    try {
      return a(b);
    } finally {
      if (Ob = !1, Lb && (b = Lb, a = Mb, Mb = Lb = null, Nb(b), a)) for (b = 0; b < a.length; b++) {
        Nb(a[b]);
      }
    }
  }
},
    xc = Object.freeze({
  default: wc
}),
    yc = xc && wc || xc;
module.exports = yc["default"] ? yc["default"] : yc;

/***/ }),

/***/ "./node_modules/react-test-renderer/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

if (process.env.NODE_ENV === 'production') {
  module.exports = __webpack_require__("./node_modules/react-test-renderer/cjs/react-test-renderer.production.min.js");
} else {
  module.exports = __webpack_require__("./node_modules/react-test-renderer/cjs/react-test-renderer.development.js");
}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__("./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/react/cjs/react.development.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/** @license React v16.2.0
 * react.development.js
 *
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */


if (process.env.NODE_ENV !== "production") {
  (function () {
    'use strict';

    var _assign = __webpack_require__("./node_modules/object-assign/index.js");

    var emptyObject = __webpack_require__("./node_modules/fbjs/lib/emptyObject.js");

    var invariant = __webpack_require__("./node_modules/fbjs/lib/invariant.js");

    var warning = __webpack_require__("./node_modules/fbjs/lib/warning.js");

    var emptyFunction = __webpack_require__("./node_modules/fbjs/lib/emptyFunction.js");

    var checkPropTypes = __webpack_require__("./node_modules/prop-types/checkPropTypes.js"); // TODO: this is special because it gets imported during build.


    var ReactVersion = '16.2.0'; // The Symbol used to tag the ReactElement-like types. If there is no native Symbol
    // nor polyfill, then a plain number is used for performance.

    var hasSymbol = typeof Symbol === 'function' && Symbol['for'];
    var REACT_ELEMENT_TYPE = hasSymbol ? Symbol['for']('react.element') : 0xeac7;
    var REACT_CALL_TYPE = hasSymbol ? Symbol['for']('react.call') : 0xeac8;
    var REACT_RETURN_TYPE = hasSymbol ? Symbol['for']('react.return') : 0xeac9;
    var REACT_PORTAL_TYPE = hasSymbol ? Symbol['for']('react.portal') : 0xeaca;
    var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol['for']('react.fragment') : 0xeacb;
    var MAYBE_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
    var FAUX_ITERATOR_SYMBOL = '@@iterator';

    function getIteratorFn(maybeIterable) {
      if (maybeIterable === null || typeof maybeIterable === 'undefined') {
        return null;
      }

      var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];

      if (typeof maybeIterator === 'function') {
        return maybeIterator;
      }

      return null;
    }
    /**
     * WARNING: DO NOT manually require this module.
     * This is a replacement for `invariant(...)` used by the error code system
     * and will _only_ be required by the corresponding babel pass.
     * It always throws.
     */

    /**
     * Forked from fbjs/warning:
     * https://github.com/facebook/fbjs/blob/e66ba20ad5be433eb54423f2b097d829324d9de6/packages/fbjs/src/__forks__/warning.js
     *
     * Only change is we use console.warn instead of console.error,
     * and do nothing when 'console' is not supported.
     * This really simplifies the code.
     * ---
     * Similar to invariant but only logs a warning if the condition is not met.
     * This can be used to log issues in development environments in critical
     * paths. Removing the logging code for production environments will keep the
     * same logic and follow the same code paths.
     */


    var lowPriorityWarning = function lowPriorityWarning() {};

    {
      var printWarning = function printWarning(format) {
        for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }

        var argIndex = 0;
        var message = 'Warning: ' + format.replace(/%s/g, function () {
          return args[argIndex++];
        });

        if (typeof console !== 'undefined') {
          console.warn(message);
        }

        try {
          // --- Welcome to debugging React ---
          // This error was thrown as a convenience so that you can use this stack
          // to find the callsite that caused this warning to fire.
          throw new Error(message);
        } catch (x) {}
      };

      lowPriorityWarning = function lowPriorityWarning(condition, format) {
        if (format === undefined) {
          throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
        }

        if (!condition) {
          for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
            args[_key2 - 2] = arguments[_key2];
          }

          printWarning.apply(undefined, [format].concat(args));
        }
      };
    }
    var lowPriorityWarning$1 = lowPriorityWarning;
    var didWarnStateUpdateForUnmountedComponent = {};

    function warnNoop(publicInstance, callerName) {
      {
        var constructor = publicInstance.constructor;
        var componentName = constructor && (constructor.displayName || constructor.name) || 'ReactClass';
        var warningKey = componentName + '.' + callerName;

        if (didWarnStateUpdateForUnmountedComponent[warningKey]) {
          return;
        }

        warning(false, '%s(...): Can only update a mounted or mounting component. ' + 'This usually means you called %s() on an unmounted component. ' + 'This is a no-op.\n\nPlease check the code for the %s component.', callerName, callerName, componentName);
        didWarnStateUpdateForUnmountedComponent[warningKey] = true;
      }
    }
    /**
     * This is the abstract API for an update queue.
     */


    var ReactNoopUpdateQueue = {
      /**
       * Checks whether or not this composite component is mounted.
       * @param {ReactClass} publicInstance The instance we want to test.
       * @return {boolean} True if mounted, false otherwise.
       * @protected
       * @final
       */
      isMounted: function isMounted(publicInstance) {
        return false;
      },

      /**
       * Forces an update. This should only be invoked when it is known with
       * certainty that we are **not** in a DOM transaction.
       *
       * You may want to call this when you know that some deeper aspect of the
       * component's state has changed but `setState` was not called.
       *
       * This will not invoke `shouldComponentUpdate`, but it will invoke
       * `componentWillUpdate` and `componentDidUpdate`.
       *
       * @param {ReactClass} publicInstance The instance that should rerender.
       * @param {?function} callback Called after component is updated.
       * @param {?string} callerName name of the calling function in the public API.
       * @internal
       */
      enqueueForceUpdate: function enqueueForceUpdate(publicInstance, callback, callerName) {
        warnNoop(publicInstance, 'forceUpdate');
      },

      /**
       * Replaces all of the state. Always use this or `setState` to mutate state.
       * You should treat `this.state` as immutable.
       *
       * There is no guarantee that `this.state` will be immediately updated, so
       * accessing `this.state` after calling this method may return the old value.
       *
       * @param {ReactClass} publicInstance The instance that should rerender.
       * @param {object} completeState Next state.
       * @param {?function} callback Called after component is updated.
       * @param {?string} callerName name of the calling function in the public API.
       * @internal
       */
      enqueueReplaceState: function enqueueReplaceState(publicInstance, completeState, callback, callerName) {
        warnNoop(publicInstance, 'replaceState');
      },

      /**
       * Sets a subset of the state. This only exists because _pendingState is
       * internal. This provides a merging strategy that is not available to deep
       * properties which is confusing. TODO: Expose pendingState or don't use it
       * during the merge.
       *
       * @param {ReactClass} publicInstance The instance that should rerender.
       * @param {object} partialState Next partial state to be merged with state.
       * @param {?function} callback Called after component is updated.
       * @param {?string} Name of the calling function in the public API.
       * @internal
       */
      enqueueSetState: function enqueueSetState(publicInstance, partialState, callback, callerName) {
        warnNoop(publicInstance, 'setState');
      }
    };
    /**
     * Base class helpers for the updating state of a component.
     */

    function Component(props, context, updater) {
      this.props = props;
      this.context = context;
      this.refs = emptyObject; // We initialize the default updater but the real one gets injected by the
      // renderer.

      this.updater = updater || ReactNoopUpdateQueue;
    }

    Component.prototype.isReactComponent = {};
    /**
     * Sets a subset of the state. Always use this to mutate
     * state. You should treat `this.state` as immutable.
     *
     * There is no guarantee that `this.state` will be immediately updated, so
     * accessing `this.state` after calling this method may return the old value.
     *
     * There is no guarantee that calls to `setState` will run synchronously,
     * as they may eventually be batched together.  You can provide an optional
     * callback that will be executed when the call to setState is actually
     * completed.
     *
     * When a function is provided to setState, it will be called at some point in
     * the future (not synchronously). It will be called with the up to date
     * component arguments (state, props, context). These values can be different
     * from this.* because your function may be called after receiveProps but before
     * shouldComponentUpdate, and this new state, props, and context will not yet be
     * assigned to this.
     *
     * @param {object|function} partialState Next partial state or function to
     *        produce next partial state to be merged with current state.
     * @param {?function} callback Called after state is updated.
     * @final
     * @protected
     */

    Component.prototype.setState = function (partialState, callback) {
      !(typeof partialState === 'object' || typeof partialState === 'function' || partialState == null) ? invariant(false, 'setState(...): takes an object of state variables to update or a function which returns an object of state variables.') : void 0;
      this.updater.enqueueSetState(this, partialState, callback, 'setState');
    };
    /**
     * Forces an update. This should only be invoked when it is known with
     * certainty that we are **not** in a DOM transaction.
     *
     * You may want to call this when you know that some deeper aspect of the
     * component's state has changed but `setState` was not called.
     *
     * This will not invoke `shouldComponentUpdate`, but it will invoke
     * `componentWillUpdate` and `componentDidUpdate`.
     *
     * @param {?function} callback Called after update is complete.
     * @final
     * @protected
     */


    Component.prototype.forceUpdate = function (callback) {
      this.updater.enqueueForceUpdate(this, callback, 'forceUpdate');
    };
    /**
     * Deprecated APIs. These APIs used to exist on classic React classes but since
     * we would like to deprecate them, we're not going to move them over to this
     * modern base class. Instead, we define a getter that warns if it's accessed.
     */


    {
      var deprecatedAPIs = {
        isMounted: ['isMounted', 'Instead, make sure to clean up subscriptions and pending requests in ' + 'componentWillUnmount to prevent memory leaks.'],
        replaceState: ['replaceState', 'Refactor your code to use setState instead (see ' + 'https://github.com/facebook/react/issues/3236).']
      };

      var defineDeprecationWarning = function defineDeprecationWarning(methodName, info) {
        Object.defineProperty(Component.prototype, methodName, {
          get: function get() {
            lowPriorityWarning$1(false, '%s(...) is deprecated in plain JavaScript React classes. %s', info[0], info[1]);
            return undefined;
          }
        });
      };

      for (var fnName in deprecatedAPIs) {
        if (deprecatedAPIs.hasOwnProperty(fnName)) {
          defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
        }
      }
    }
    /**
     * Base class helpers for the updating state of a component.
     */

    function PureComponent(props, context, updater) {
      // Duplicated from Component.
      this.props = props;
      this.context = context;
      this.refs = emptyObject; // We initialize the default updater but the real one gets injected by the
      // renderer.

      this.updater = updater || ReactNoopUpdateQueue;
    }

    function ComponentDummy() {}

    ComponentDummy.prototype = Component.prototype;
    var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();
    pureComponentPrototype.constructor = PureComponent; // Avoid an extra prototype jump for these methods.

    _assign(pureComponentPrototype, Component.prototype);

    pureComponentPrototype.isPureReactComponent = true;

    function AsyncComponent(props, context, updater) {
      // Duplicated from Component.
      this.props = props;
      this.context = context;
      this.refs = emptyObject; // We initialize the default updater but the real one gets injected by the
      // renderer.

      this.updater = updater || ReactNoopUpdateQueue;
    }

    var asyncComponentPrototype = AsyncComponent.prototype = new ComponentDummy();
    asyncComponentPrototype.constructor = AsyncComponent; // Avoid an extra prototype jump for these methods.

    _assign(asyncComponentPrototype, Component.prototype);

    asyncComponentPrototype.unstable_isAsyncReactComponent = true;

    asyncComponentPrototype.render = function () {
      return this.props.children;
    };
    /**
     * Keeps track of the current owner.
     *
     * The current owner is the component who should own any components that are
     * currently being constructed.
     */


    var ReactCurrentOwner = {
      /**
       * @internal
       * @type {ReactComponent}
       */
      current: null
    };
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var RESERVED_PROPS = {
      key: true,
      ref: true,
      __self: true,
      __source: true
    };
    var specialPropKeyWarningShown;
    var specialPropRefWarningShown;

    function hasValidRef(config) {
      {
        if (hasOwnProperty.call(config, 'ref')) {
          var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;

          if (getter && getter.isReactWarning) {
            return false;
          }
        }
      }
      return config.ref !== undefined;
    }

    function hasValidKey(config) {
      {
        if (hasOwnProperty.call(config, 'key')) {
          var getter = Object.getOwnPropertyDescriptor(config, 'key').get;

          if (getter && getter.isReactWarning) {
            return false;
          }
        }
      }
      return config.key !== undefined;
    }

    function defineKeyPropWarningGetter(props, displayName) {
      var warnAboutAccessingKey = function warnAboutAccessingKey() {
        if (!specialPropKeyWarningShown) {
          specialPropKeyWarningShown = true;
          warning(false, '%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://fb.me/react-special-props)', displayName);
        }
      };

      warnAboutAccessingKey.isReactWarning = true;
      Object.defineProperty(props, 'key', {
        get: warnAboutAccessingKey,
        configurable: true
      });
    }

    function defineRefPropWarningGetter(props, displayName) {
      var warnAboutAccessingRef = function warnAboutAccessingRef() {
        if (!specialPropRefWarningShown) {
          specialPropRefWarningShown = true;
          warning(false, '%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://fb.me/react-special-props)', displayName);
        }
      };

      warnAboutAccessingRef.isReactWarning = true;
      Object.defineProperty(props, 'ref', {
        get: warnAboutAccessingRef,
        configurable: true
      });
    }
    /**
     * Factory method to create a new React element. This no longer adheres to
     * the class pattern, so do not use new to call it. Also, no instanceof check
     * will work. Instead test $$typeof field against Symbol.for('react.element') to check
     * if something is a React Element.
     *
     * @param {*} type
     * @param {*} key
     * @param {string|object} ref
     * @param {*} self A *temporary* helper to detect places where `this` is
     * different from the `owner` when React.createElement is called, so that we
     * can warn. We want to get rid of owner and replace string `ref`s with arrow
     * functions, and as long as `this` and owner are the same, there will be no
     * change in behavior.
     * @param {*} source An annotation object (added by a transpiler or otherwise)
     * indicating filename, line number, and/or other information.
     * @param {*} owner
     * @param {*} props
     * @internal
     */


    var ReactElement = function ReactElement(type, key, ref, self, source, owner, props) {
      var element = {
        // This tag allow us to uniquely identify this as a React Element
        $$typeof: REACT_ELEMENT_TYPE,
        // Built-in properties that belong on the element
        type: type,
        key: key,
        ref: ref,
        props: props,
        // Record the component responsible for creating this element.
        _owner: owner
      };
      {
        // The validation flag is currently mutative. We put it on
        // an external backing store so that we can freeze the whole object.
        // This can be replaced with a WeakMap once they are implemented in
        // commonly used development environments.
        element._store = {}; // To make comparing ReactElements easier for testing purposes, we make
        // the validation flag non-enumerable (where possible, which should
        // include every environment we run tests in), so the test framework
        // ignores it.

        Object.defineProperty(element._store, 'validated', {
          configurable: false,
          enumerable: false,
          writable: true,
          value: false
        }); // self and source are DEV only properties.

        Object.defineProperty(element, '_self', {
          configurable: false,
          enumerable: false,
          writable: false,
          value: self
        }); // Two elements created in two different places should be considered
        // equal for testing purposes and therefore we hide it from enumeration.

        Object.defineProperty(element, '_source', {
          configurable: false,
          enumerable: false,
          writable: false,
          value: source
        });

        if (Object.freeze) {
          Object.freeze(element.props);
          Object.freeze(element);
        }
      }
      return element;
    };
    /**
     * Create and return a new ReactElement of the given type.
     * See https://reactjs.org/docs/react-api.html#createelement
     */


    function createElement(type, config, children) {
      var propName; // Reserved names are extracted

      var props = {};
      var key = null;
      var ref = null;
      var self = null;
      var source = null;

      if (config != null) {
        if (hasValidRef(config)) {
          ref = config.ref;
        }

        if (hasValidKey(config)) {
          key = '' + config.key;
        }

        self = config.__self === undefined ? null : config.__self;
        source = config.__source === undefined ? null : config.__source; // Remaining properties are added to a new props object

        for (propName in config) {
          if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
            props[propName] = config[propName];
          }
        }
      } // Children can be more than one argument, and those are transferred onto
      // the newly allocated props object.


      var childrenLength = arguments.length - 2;

      if (childrenLength === 1) {
        props.children = children;
      } else if (childrenLength > 1) {
        var childArray = Array(childrenLength);

        for (var i = 0; i < childrenLength; i++) {
          childArray[i] = arguments[i + 2];
        }

        {
          if (Object.freeze) {
            Object.freeze(childArray);
          }
        }
        props.children = childArray;
      } // Resolve default props


      if (type && type.defaultProps) {
        var defaultProps = type.defaultProps;

        for (propName in defaultProps) {
          if (props[propName] === undefined) {
            props[propName] = defaultProps[propName];
          }
        }
      }

      {
        if (key || ref) {
          if (typeof props.$$typeof === 'undefined' || props.$$typeof !== REACT_ELEMENT_TYPE) {
            var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;

            if (key) {
              defineKeyPropWarningGetter(props, displayName);
            }

            if (ref) {
              defineRefPropWarningGetter(props, displayName);
            }
          }
        }
      }
      return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
    }
    /**
     * Return a function that produces ReactElements of a given type.
     * See https://reactjs.org/docs/react-api.html#createfactory
     */


    function cloneAndReplaceKey(oldElement, newKey) {
      var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);
      return newElement;
    }
    /**
     * Clone and return a new ReactElement using element as the starting point.
     * See https://reactjs.org/docs/react-api.html#cloneelement
     */


    function cloneElement(element, config, children) {
      var propName; // Original props are copied

      var props = _assign({}, element.props); // Reserved names are extracted


      var key = element.key;
      var ref = element.ref; // Self is preserved since the owner is preserved.

      var self = element._self; // Source is preserved since cloneElement is unlikely to be targeted by a
      // transpiler, and the original source is probably a better indicator of the
      // true owner.

      var source = element._source; // Owner will be preserved, unless ref is overridden

      var owner = element._owner;

      if (config != null) {
        if (hasValidRef(config)) {
          // Silently steal the ref from the parent.
          ref = config.ref;
          owner = ReactCurrentOwner.current;
        }

        if (hasValidKey(config)) {
          key = '' + config.key;
        } // Remaining properties override existing props


        var defaultProps;

        if (element.type && element.type.defaultProps) {
          defaultProps = element.type.defaultProps;
        }

        for (propName in config) {
          if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
            if (config[propName] === undefined && defaultProps !== undefined) {
              // Resolve default props
              props[propName] = defaultProps[propName];
            } else {
              props[propName] = config[propName];
            }
          }
        }
      } // Children can be more than one argument, and those are transferred onto
      // the newly allocated props object.


      var childrenLength = arguments.length - 2;

      if (childrenLength === 1) {
        props.children = children;
      } else if (childrenLength > 1) {
        var childArray = Array(childrenLength);

        for (var i = 0; i < childrenLength; i++) {
          childArray[i] = arguments[i + 2];
        }

        props.children = childArray;
      }

      return ReactElement(element.type, key, ref, self, source, owner, props);
    }
    /**
     * Verifies the object is a ReactElement.
     * See https://reactjs.org/docs/react-api.html#isvalidelement
     * @param {?object} object
     * @return {boolean} True if `object` is a valid component.
     * @final
     */


    function isValidElement(object) {
      return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
    }

    var ReactDebugCurrentFrame = {};
    {
      // Component that is being worked on
      ReactDebugCurrentFrame.getCurrentStack = null;

      ReactDebugCurrentFrame.getStackAddendum = function () {
        var impl = ReactDebugCurrentFrame.getCurrentStack;

        if (impl) {
          return impl();
        }

        return null;
      };
    }
    var SEPARATOR = '.';
    var SUBSEPARATOR = ':';
    /**
     * Escape and wrap key so it is safe to use as a reactid
     *
     * @param {string} key to be escaped.
     * @return {string} the escaped key.
     */

    function escape(key) {
      var escapeRegex = /[=:]/g;
      var escaperLookup = {
        '=': '=0',
        ':': '=2'
      };
      var escapedString = ('' + key).replace(escapeRegex, function (match) {
        return escaperLookup[match];
      });
      return '$' + escapedString;
    }
    /**
     * TODO: Test that a single child and an array with one item have the same key
     * pattern.
     */


    var didWarnAboutMaps = false;
    var userProvidedKeyEscapeRegex = /\/+/g;

    function escapeUserProvidedKey(text) {
      return ('' + text).replace(userProvidedKeyEscapeRegex, '$&/');
    }

    var POOL_SIZE = 10;
    var traverseContextPool = [];

    function getPooledTraverseContext(mapResult, keyPrefix, mapFunction, mapContext) {
      if (traverseContextPool.length) {
        var traverseContext = traverseContextPool.pop();
        traverseContext.result = mapResult;
        traverseContext.keyPrefix = keyPrefix;
        traverseContext.func = mapFunction;
        traverseContext.context = mapContext;
        traverseContext.count = 0;
        return traverseContext;
      } else {
        return {
          result: mapResult,
          keyPrefix: keyPrefix,
          func: mapFunction,
          context: mapContext,
          count: 0
        };
      }
    }

    function releaseTraverseContext(traverseContext) {
      traverseContext.result = null;
      traverseContext.keyPrefix = null;
      traverseContext.func = null;
      traverseContext.context = null;
      traverseContext.count = 0;

      if (traverseContextPool.length < POOL_SIZE) {
        traverseContextPool.push(traverseContext);
      }
    }
    /**
     * @param {?*} children Children tree container.
     * @param {!string} nameSoFar Name of the key path so far.
     * @param {!function} callback Callback to invoke with each child found.
     * @param {?*} traverseContext Used to pass information throughout the traversal
     * process.
     * @return {!number} The number of children in this subtree.
     */


    function traverseAllChildrenImpl(children, nameSoFar, callback, traverseContext) {
      var type = typeof children;

      if (type === 'undefined' || type === 'boolean') {
        // All of the above are perceived as null.
        children = null;
      }

      var invokeCallback = false;

      if (children === null) {
        invokeCallback = true;
      } else {
        switch (type) {
          case 'string':
          case 'number':
            invokeCallback = true;
            break;

          case 'object':
            switch (children.$$typeof) {
              case REACT_ELEMENT_TYPE:
              case REACT_CALL_TYPE:
              case REACT_RETURN_TYPE:
              case REACT_PORTAL_TYPE:
                invokeCallback = true;
            }

        }
      }

      if (invokeCallback) {
        callback(traverseContext, children, // If it's the only child, treat the name as if it was wrapped in an array
        // so that it's consistent if the number of children grows.
        nameSoFar === '' ? SEPARATOR + getComponentKey(children, 0) : nameSoFar);
        return 1;
      }

      var child;
      var nextName;
      var subtreeCount = 0; // Count of children found in the current subtree.

      var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;

      if (Array.isArray(children)) {
        for (var i = 0; i < children.length; i++) {
          child = children[i];
          nextName = nextNamePrefix + getComponentKey(child, i);
          subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
        }
      } else {
        var iteratorFn = getIteratorFn(children);

        if (typeof iteratorFn === 'function') {
          {
            // Warn about using Maps as children
            if (iteratorFn === children.entries) {
              warning(didWarnAboutMaps, 'Using Maps as children is unsupported and will likely yield ' + 'unexpected results. Convert it to a sequence/iterable of keyed ' + 'ReactElements instead.%s', ReactDebugCurrentFrame.getStackAddendum());
              didWarnAboutMaps = true;
            }
          }
          var iterator = iteratorFn.call(children);
          var step;
          var ii = 0;

          while (!(step = iterator.next()).done) {
            child = step.value;
            nextName = nextNamePrefix + getComponentKey(child, ii++);
            subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
          }
        } else if (type === 'object') {
          var addendum = '';
          {
            addendum = ' If you meant to render a collection of children, use an array ' + 'instead.' + ReactDebugCurrentFrame.getStackAddendum();
          }
          var childrenString = '' + children;
          invariant(false, 'Objects are not valid as a React child (found: %s).%s', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum);
        }
      }

      return subtreeCount;
    }
    /**
     * Traverses children that are typically specified as `props.children`, but
     * might also be specified through attributes:
     *
     * - `traverseAllChildren(this.props.children, ...)`
     * - `traverseAllChildren(this.props.leftPanelChildren, ...)`
     *
     * The `traverseContext` is an optional argument that is passed through the
     * entire traversal. It can be used to store accumulations or anything else that
     * the callback might find relevant.
     *
     * @param {?*} children Children tree object.
     * @param {!function} callback To invoke upon traversing each child.
     * @param {?*} traverseContext Context for traversal.
     * @return {!number} The number of children in this subtree.
     */


    function traverseAllChildren(children, callback, traverseContext) {
      if (children == null) {
        return 0;
      }

      return traverseAllChildrenImpl(children, '', callback, traverseContext);
    }
    /**
     * Generate a key string that identifies a component within a set.
     *
     * @param {*} component A component that could contain a manual key.
     * @param {number} index Index that is used if a manual key is not provided.
     * @return {string}
     */


    function getComponentKey(component, index) {
      // Do some typechecking here since we call this blindly. We want to ensure
      // that we don't block potential future ES APIs.
      if (typeof component === 'object' && component !== null && component.key != null) {
        // Explicit key
        return escape(component.key);
      } // Implicit key determined by the index in the set


      return index.toString(36);
    }

    function forEachSingleChild(bookKeeping, child, name) {
      var func = bookKeeping.func,
          context = bookKeeping.context;
      func.call(context, child, bookKeeping.count++);
    }
    /**
     * Iterates through children that are typically specified as `props.children`.
     *
     * See https://reactjs.org/docs/react-api.html#react.children.foreach
     *
     * The provided forEachFunc(child, index) will be called for each
     * leaf child.
     *
     * @param {?*} children Children tree container.
     * @param {function(*, int)} forEachFunc
     * @param {*} forEachContext Context for forEachContext.
     */


    function forEachChildren(children, forEachFunc, forEachContext) {
      if (children == null) {
        return children;
      }

      var traverseContext = getPooledTraverseContext(null, null, forEachFunc, forEachContext);
      traverseAllChildren(children, forEachSingleChild, traverseContext);
      releaseTraverseContext(traverseContext);
    }

    function mapSingleChildIntoContext(bookKeeping, child, childKey) {
      var result = bookKeeping.result,
          keyPrefix = bookKeeping.keyPrefix,
          func = bookKeeping.func,
          context = bookKeeping.context;
      var mappedChild = func.call(context, child, bookKeeping.count++);

      if (Array.isArray(mappedChild)) {
        mapIntoWithKeyPrefixInternal(mappedChild, result, childKey, emptyFunction.thatReturnsArgument);
      } else if (mappedChild != null) {
        if (isValidElement(mappedChild)) {
          mappedChild = cloneAndReplaceKey(mappedChild, // Keep both the (mapped) and old keys if they differ, just as
          // traverseAllChildren used to do for objects as children
          keyPrefix + (mappedChild.key && (!child || child.key !== mappedChild.key) ? escapeUserProvidedKey(mappedChild.key) + '/' : '') + childKey);
        }

        result.push(mappedChild);
      }
    }

    function mapIntoWithKeyPrefixInternal(children, array, prefix, func, context) {
      var escapedPrefix = '';

      if (prefix != null) {
        escapedPrefix = escapeUserProvidedKey(prefix) + '/';
      }

      var traverseContext = getPooledTraverseContext(array, escapedPrefix, func, context);
      traverseAllChildren(children, mapSingleChildIntoContext, traverseContext);
      releaseTraverseContext(traverseContext);
    }
    /**
     * Maps children that are typically specified as `props.children`.
     *
     * See https://reactjs.org/docs/react-api.html#react.children.map
     *
     * The provided mapFunction(child, key, index) will be called for each
     * leaf child.
     *
     * @param {?*} children Children tree container.
     * @param {function(*, int)} func The map function.
     * @param {*} context Context for mapFunction.
     * @return {object} Object containing the ordered map of results.
     */


    function mapChildren(children, func, context) {
      if (children == null) {
        return children;
      }

      var result = [];
      mapIntoWithKeyPrefixInternal(children, result, null, func, context);
      return result;
    }
    /**
     * Count the number of children that are typically specified as
     * `props.children`.
     *
     * See https://reactjs.org/docs/react-api.html#react.children.count
     *
     * @param {?*} children Children tree container.
     * @return {number} The number of children.
     */


    function countChildren(children, context) {
      return traverseAllChildren(children, emptyFunction.thatReturnsNull, null);
    }
    /**
     * Flatten a children object (typically specified as `props.children`) and
     * return an array with appropriately re-keyed children.
     *
     * See https://reactjs.org/docs/react-api.html#react.children.toarray
     */


    function toArray(children) {
      var result = [];
      mapIntoWithKeyPrefixInternal(children, result, null, emptyFunction.thatReturnsArgument);
      return result;
    }
    /**
     * Returns the first child in a collection of children and verifies that there
     * is only one child in the collection.
     *
     * See https://reactjs.org/docs/react-api.html#react.children.only
     *
     * The current implementation of this function assumes that a single child gets
     * passed without a wrapper, but the purpose of this helper function is to
     * abstract away the particular structure of children.
     *
     * @param {?object} children Child collection structure.
     * @return {ReactElement} The first and only `ReactElement` contained in the
     * structure.
     */


    function onlyChild(children) {
      !isValidElement(children) ? invariant(false, 'React.Children.only expected to receive a single React element child.') : void 0;
      return children;
    }

    var describeComponentFrame = function describeComponentFrame(name, source, ownerName) {
      return '\n    in ' + (name || 'Unknown') + (source ? ' (at ' + source.fileName.replace(/^.*[\\\/]/, '') + ':' + source.lineNumber + ')' : ownerName ? ' (created by ' + ownerName + ')' : '');
    };

    function getComponentName(fiber) {
      var type = fiber.type;

      if (typeof type === 'string') {
        return type;
      }

      if (typeof type === 'function') {
        return type.displayName || type.name;
      }

      return null;
    }
    /**
     * ReactElementValidator provides a wrapper around a element factory
     * which validates the props passed to the element. This is intended to be
     * used only in DEV and could be replaced by a static type checker for languages
     * that support it.
     */


    {
      var currentlyValidatingElement = null;
      var propTypesMisspellWarningShown = false;

      var getDisplayName = function getDisplayName(element) {
        if (element == null) {
          return '#empty';
        } else if (typeof element === 'string' || typeof element === 'number') {
          return '#text';
        } else if (typeof element.type === 'string') {
          return element.type;
        } else if (element.type === REACT_FRAGMENT_TYPE) {
          return 'React.Fragment';
        } else {
          return element.type.displayName || element.type.name || 'Unknown';
        }
      };

      var getStackAddendum = function getStackAddendum() {
        var stack = '';

        if (currentlyValidatingElement) {
          var name = getDisplayName(currentlyValidatingElement);
          var owner = currentlyValidatingElement._owner;
          stack += describeComponentFrame(name, currentlyValidatingElement._source, owner && getComponentName(owner));
        }

        stack += ReactDebugCurrentFrame.getStackAddendum() || '';
        return stack;
      };

      var VALID_FRAGMENT_PROPS = new Map([['children', true], ['key', true]]);
    }

    function getDeclarationErrorAddendum() {
      if (ReactCurrentOwner.current) {
        var name = getComponentName(ReactCurrentOwner.current);

        if (name) {
          return '\n\nCheck the render method of `' + name + '`.';
        }
      }

      return '';
    }

    function getSourceInfoErrorAddendum(elementProps) {
      if (elementProps !== null && elementProps !== undefined && elementProps.__source !== undefined) {
        var source = elementProps.__source;
        var fileName = source.fileName.replace(/^.*[\\\/]/, '');
        var lineNumber = source.lineNumber;
        return '\n\nCheck your code at ' + fileName + ':' + lineNumber + '.';
      }

      return '';
    }
    /**
     * Warn if there's no key explicitly set on dynamic arrays of children or
     * object keys are not valid. This allows us to keep track of children between
     * updates.
     */


    var ownerHasKeyUseWarning = {};

    function getCurrentComponentErrorInfo(parentType) {
      var info = getDeclarationErrorAddendum();

      if (!info) {
        var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;

        if (parentName) {
          info = '\n\nCheck the top-level render call using <' + parentName + '>.';
        }
      }

      return info;
    }
    /**
     * Warn if the element doesn't have an explicit key assigned to it.
     * This element is in an array. The array could grow and shrink or be
     * reordered. All children that haven't already been validated are required to
     * have a "key" property assigned to it. Error statuses are cached so a warning
     * will only be shown once.
     *
     * @internal
     * @param {ReactElement} element Element that requires a key.
     * @param {*} parentType element's parent's type.
     */


    function validateExplicitKey(element, parentType) {
      if (!element._store || element._store.validated || element.key != null) {
        return;
      }

      element._store.validated = true;
      var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);

      if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
        return;
      }

      ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a
      // property, it may be the creator of the child that's responsible for
      // assigning it a key.

      var childOwner = '';

      if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
        // Give the component that originally created this child.
        childOwner = ' It was passed a child from ' + getComponentName(element._owner) + '.';
      }

      currentlyValidatingElement = element;
      {
        warning(false, 'Each child in an array or iterator should have a unique "key" prop.' + '%s%s See https://fb.me/react-warning-keys for more information.%s', currentComponentErrorInfo, childOwner, getStackAddendum());
      }
      currentlyValidatingElement = null;
    }
    /**
     * Ensure that every element either is passed in a static location, in an
     * array with an explicit keys property defined, or in an object literal
     * with valid key property.
     *
     * @internal
     * @param {ReactNode} node Statically passed child of any type.
     * @param {*} parentType node's parent's type.
     */


    function validateChildKeys(node, parentType) {
      if (typeof node !== 'object') {
        return;
      }

      if (Array.isArray(node)) {
        for (var i = 0; i < node.length; i++) {
          var child = node[i];

          if (isValidElement(child)) {
            validateExplicitKey(child, parentType);
          }
        }
      } else if (isValidElement(node)) {
        // This element was passed in a valid location.
        if (node._store) {
          node._store.validated = true;
        }
      } else if (node) {
        var iteratorFn = getIteratorFn(node);

        if (typeof iteratorFn === 'function') {
          // Entry iterators used to provide implicit keys,
          // but now we print a separate warning for them later.
          if (iteratorFn !== node.entries) {
            var iterator = iteratorFn.call(node);
            var step;

            while (!(step = iterator.next()).done) {
              if (isValidElement(step.value)) {
                validateExplicitKey(step.value, parentType);
              }
            }
          }
        }
      }
    }
    /**
     * Given an element, validate that its props follow the propTypes definition,
     * provided by the type.
     *
     * @param {ReactElement} element
     */


    function validatePropTypes(element) {
      var componentClass = element.type;

      if (typeof componentClass !== 'function') {
        return;
      }

      var name = componentClass.displayName || componentClass.name;
      var propTypes = componentClass.propTypes;

      if (propTypes) {
        currentlyValidatingElement = element;
        checkPropTypes(propTypes, element.props, 'prop', name, getStackAddendum);
        currentlyValidatingElement = null;
      } else if (componentClass.PropTypes !== undefined && !propTypesMisspellWarningShown) {
        propTypesMisspellWarningShown = true;
        warning(false, 'Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', name || 'Unknown');
      }

      if (typeof componentClass.getDefaultProps === 'function') {
        warning(componentClass.getDefaultProps.isReactClassApproved, 'getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.');
      }
    }
    /**
     * Given a fragment, validate that it can only be provided with fragment props
     * @param {ReactElement} fragment
     */


    function validateFragmentProps(fragment) {
      currentlyValidatingElement = fragment;
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = Object.keys(fragment.props)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var key = _step.value;

          if (!VALID_FRAGMENT_PROPS.has(key)) {
            warning(false, 'Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.%s', key, getStackAddendum());
            break;
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator['return']) {
            _iterator['return']();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      if (fragment.ref !== null) {
        warning(false, 'Invalid attribute `ref` supplied to `React.Fragment`.%s', getStackAddendum());
      }

      currentlyValidatingElement = null;
    }

    function createElementWithValidation(type, props, children) {
      var validType = typeof type === 'string' || typeof type === 'function' || typeof type === 'symbol' || typeof type === 'number'; // We warn in this case but don't throw. We expect the element creation to
      // succeed and there will likely be errors in render.

      if (!validType) {
        var info = '';

        if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {
          info += ' You likely forgot to export your component from the file ' + "it's defined in, or you might have mixed up default and named imports.";
        }

        var sourceInfo = getSourceInfoErrorAddendum(props);

        if (sourceInfo) {
          info += sourceInfo;
        } else {
          info += getDeclarationErrorAddendum();
        }

        info += getStackAddendum() || '';
        warning(false, 'React.createElement: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', type == null ? type : typeof type, info);
      }

      var element = createElement.apply(this, arguments); // The result can be nullish if a mock or a custom function is used.
      // TODO: Drop this when these are no longer allowed as the type argument.

      if (element == null) {
        return element;
      } // Skip key warning if the type isn't valid since our key validation logic
      // doesn't expect a non-string/function type and can throw confusing errors.
      // We don't want exception behavior to differ between dev and prod.
      // (Rendering will throw with a helpful message and as soon as the type is
      // fixed, the key warnings will appear.)


      if (validType) {
        for (var i = 2; i < arguments.length; i++) {
          validateChildKeys(arguments[i], type);
        }
      }

      if (typeof type === 'symbol' && type === REACT_FRAGMENT_TYPE) {
        validateFragmentProps(element);
      } else {
        validatePropTypes(element);
      }

      return element;
    }

    function createFactoryWithValidation(type) {
      var validatedFactory = createElementWithValidation.bind(null, type); // Legacy hook TODO: Warn if this is accessed

      validatedFactory.type = type;
      {
        Object.defineProperty(validatedFactory, 'type', {
          enumerable: false,
          get: function get() {
            lowPriorityWarning$1(false, 'Factory.type is deprecated. Access the class directly ' + 'before passing it to createFactory.');
            Object.defineProperty(this, 'type', {
              value: type
            });
            return type;
          }
        });
      }
      return validatedFactory;
    }

    function cloneElementWithValidation(element, props, children) {
      var newElement = cloneElement.apply(this, arguments);

      for (var i = 2; i < arguments.length; i++) {
        validateChildKeys(arguments[i], newElement.type);
      }

      validatePropTypes(newElement);
      return newElement;
    }

    var React = {
      Children: {
        map: mapChildren,
        forEach: forEachChildren,
        count: countChildren,
        toArray: toArray,
        only: onlyChild
      },
      Component: Component,
      PureComponent: PureComponent,
      unstable_AsyncComponent: AsyncComponent,
      Fragment: REACT_FRAGMENT_TYPE,
      createElement: createElementWithValidation,
      cloneElement: cloneElementWithValidation,
      createFactory: createFactoryWithValidation,
      isValidElement: isValidElement,
      version: ReactVersion,
      __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: {
        ReactCurrentOwner: ReactCurrentOwner,
        // Used by renderers to avoid bundling object-assign twice in UMD bundles:
        assign: _assign
      }
    };
    {
      _assign(React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, {
        // These should not be included in production.
        ReactDebugCurrentFrame: ReactDebugCurrentFrame,
        // Shim for React DOM 16.0.0 which still destructured (but not used) this.
        // TODO: remove in React 17.0.
        ReactComponentTreeHook: {}
      });
    }
    var React$2 = Object.freeze({
      default: React
    });
    var React$3 = React$2 && React || React$2; // TODO: decide on the top-level export form.
    // This is hacky but makes it work with both Rollup and Jest.

    var react = React$3['default'] ? React$3['default'] : React$3;
    module.exports = react;
  })();
}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__("./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/react/cjs/react.production.min.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/** @license React v16.2.0
 * react.production.min.js
 *
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */


var m = __webpack_require__("./node_modules/object-assign/index.js"),
    n = __webpack_require__("./node_modules/fbjs/lib/emptyObject.js"),
    p = __webpack_require__("./node_modules/fbjs/lib/emptyFunction.js"),
    q = "function" === typeof Symbol && Symbol["for"],
    r = q ? Symbol["for"]("react.element") : 60103,
    t = q ? Symbol["for"]("react.call") : 60104,
    u = q ? Symbol["for"]("react.return") : 60105,
    v = q ? Symbol["for"]("react.portal") : 60106,
    w = q ? Symbol["for"]("react.fragment") : 60107,
    x = "function" === typeof Symbol && Symbol.iterator;

function y(a) {
  for (var b = arguments.length - 1, e = "Minified React error #" + a + "; visit http://facebook.github.io/react/docs/error-decoder.html?invariant\x3d" + a, c = 0; c < b; c++) {
    e += "\x26args[]\x3d" + encodeURIComponent(arguments[c + 1]);
  }

  b = Error(e + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.");
  b.name = "Invariant Violation";
  b.framesToPop = 1;
  throw b;
}

var z = {
  isMounted: function isMounted() {
    return !1;
  },
  enqueueForceUpdate: function enqueueForceUpdate() {},
  enqueueReplaceState: function enqueueReplaceState() {},
  enqueueSetState: function enqueueSetState() {}
};

function A(a, b, e) {
  this.props = a;
  this.context = b;
  this.refs = n;
  this.updater = e || z;
}

A.prototype.isReactComponent = {};

A.prototype.setState = function (a, b) {
  "object" !== typeof a && "function" !== typeof a && null != a ? y("85") : void 0;
  this.updater.enqueueSetState(this, a, b, "setState");
};

A.prototype.forceUpdate = function (a) {
  this.updater.enqueueForceUpdate(this, a, "forceUpdate");
};

function B(a, b, e) {
  this.props = a;
  this.context = b;
  this.refs = n;
  this.updater = e || z;
}

function C() {}

C.prototype = A.prototype;
var D = B.prototype = new C();
D.constructor = B;
m(D, A.prototype);
D.isPureReactComponent = !0;

function E(a, b, e) {
  this.props = a;
  this.context = b;
  this.refs = n;
  this.updater = e || z;
}

var F = E.prototype = new C();
F.constructor = E;
m(F, A.prototype);
F.unstable_isAsyncReactComponent = !0;

F.render = function () {
  return this.props.children;
};

var G = {
  current: null
},
    H = Object.prototype.hasOwnProperty,
    I = {
  key: !0,
  ref: !0,
  __self: !0,
  __source: !0
};

function J(a, b, e) {
  var c,
      d = {},
      g = null,
      k = null;
  if (null != b) for (c in void 0 !== b.ref && (k = b.ref), void 0 !== b.key && (g = "" + b.key), b) {
    H.call(b, c) && !I.hasOwnProperty(c) && (d[c] = b[c]);
  }
  var f = arguments.length - 2;
  if (1 === f) d.children = e;else if (1 < f) {
    for (var h = Array(f), l = 0; l < f; l++) {
      h[l] = arguments[l + 2];
    }

    d.children = h;
  }
  if (a && a.defaultProps) for (c in f = a.defaultProps, f) {
    void 0 === d[c] && (d[c] = f[c]);
  }
  return {
    $$typeof: r,
    type: a,
    key: g,
    ref: k,
    props: d,
    _owner: G.current
  };
}

function K(a) {
  return "object" === typeof a && null !== a && a.$$typeof === r;
}

function escape(a) {
  var b = {
    "\x3d": "\x3d0",
    ":": "\x3d2"
  };
  return "$" + ("" + a).replace(/[=:]/g, function (a) {
    return b[a];
  });
}

var L = /\/+/g,
    M = [];

function N(a, b, e, c) {
  if (M.length) {
    var d = M.pop();
    d.result = a;
    d.keyPrefix = b;
    d.func = e;
    d.context = c;
    d.count = 0;
    return d;
  }

  return {
    result: a,
    keyPrefix: b,
    func: e,
    context: c,
    count: 0
  };
}

function O(a) {
  a.result = null;
  a.keyPrefix = null;
  a.func = null;
  a.context = null;
  a.count = 0;
  10 > M.length && M.push(a);
}

function P(a, b, e, c) {
  var d = typeof a;
  if ("undefined" === d || "boolean" === d) a = null;
  var g = !1;
  if (null === a) g = !0;else switch (d) {
    case "string":
    case "number":
      g = !0;
      break;

    case "object":
      switch (a.$$typeof) {
        case r:
        case t:
        case u:
        case v:
          g = !0;
      }

  }
  if (g) return e(c, a, "" === b ? "." + Q(a, 0) : b), 1;
  g = 0;
  b = "" === b ? "." : b + ":";
  if (Array.isArray(a)) for (var k = 0; k < a.length; k++) {
    d = a[k];
    var f = b + Q(d, k);
    g += P(d, f, e, c);
  } else if (null === a || "undefined" === typeof a ? f = null : (f = x && a[x] || a["@@iterator"], f = "function" === typeof f ? f : null), "function" === typeof f) for (a = f.call(a), k = 0; !(d = a.next()).done;) {
    d = d.value, f = b + Q(d, k++), g += P(d, f, e, c);
  } else "object" === d && (e = "" + a, y("31", "[object Object]" === e ? "object with keys {" + Object.keys(a).join(", ") + "}" : e, ""));
  return g;
}

function Q(a, b) {
  return "object" === typeof a && null !== a && null != a.key ? escape(a.key) : b.toString(36);
}

function R(a, b) {
  a.func.call(a.context, b, a.count++);
}

function S(a, b, e) {
  var c = a.result,
      d = a.keyPrefix;
  a = a.func.call(a.context, b, a.count++);
  Array.isArray(a) ? T(a, c, e, p.thatReturnsArgument) : null != a && (K(a) && (b = d + (!a.key || b && b.key === a.key ? "" : ("" + a.key).replace(L, "$\x26/") + "/") + e, a = {
    $$typeof: r,
    type: a.type,
    key: b,
    ref: a.ref,
    props: a.props,
    _owner: a._owner
  }), c.push(a));
}

function T(a, b, e, c, d) {
  var g = "";
  null != e && (g = ("" + e).replace(L, "$\x26/") + "/");
  b = N(b, g, c, d);
  null == a || P(a, "", S, b);
  O(b);
}

var U = {
  Children: {
    map: function map(a, b, e) {
      if (null == a) return a;
      var c = [];
      T(a, c, null, b, e);
      return c;
    },
    forEach: function forEach(a, b, e) {
      if (null == a) return a;
      b = N(null, null, b, e);
      null == a || P(a, "", R, b);
      O(b);
    },
    count: function count(a) {
      return null == a ? 0 : P(a, "", p.thatReturnsNull, null);
    },
    toArray: function toArray(a) {
      var b = [];
      T(a, b, null, p.thatReturnsArgument);
      return b;
    },
    only: function only(a) {
      K(a) ? void 0 : y("143");
      return a;
    }
  },
  Component: A,
  PureComponent: B,
  unstable_AsyncComponent: E,
  Fragment: w,
  createElement: J,
  cloneElement: function cloneElement(a, b, e) {
    var c = m({}, a.props),
        d = a.key,
        g = a.ref,
        k = a._owner;

    if (null != b) {
      void 0 !== b.ref && (g = b.ref, k = G.current);
      void 0 !== b.key && (d = "" + b.key);
      if (a.type && a.type.defaultProps) var f = a.type.defaultProps;

      for (h in b) {
        H.call(b, h) && !I.hasOwnProperty(h) && (c[h] = void 0 === b[h] && void 0 !== f ? f[h] : b[h]);
      }
    }

    var h = arguments.length - 2;
    if (1 === h) c.children = e;else if (1 < h) {
      f = Array(h);

      for (var l = 0; l < h; l++) {
        f[l] = arguments[l + 2];
      }

      c.children = f;
    }
    return {
      $$typeof: r,
      type: a.type,
      key: d,
      ref: g,
      props: c,
      _owner: k
    };
  },
  createFactory: function createFactory(a) {
    var b = J.bind(null, a);
    b.type = a;
    return b;
  },
  isValidElement: K,
  version: "16.2.0",
  __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: {
    ReactCurrentOwner: G,
    assign: m
  }
},
    V = Object.freeze({
  default: U
}),
    W = V && U || V;
module.exports = W["default"] ? W["default"] : W;

/***/ }),

/***/ "./node_modules/react/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

if (process.env.NODE_ENV === 'production') {
  module.exports = __webpack_require__("./node_modules/react/cjs/react.production.min.js");
} else {
  module.exports = __webpack_require__("./node_modules/react/cjs/react.development.js");
}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__("./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/regenerator-runtime/runtime.js":
/***/ (function(module, exports) {

/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
!function (global) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.

  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
  var inModule = typeof module === "object";
  var runtime = global.regeneratorRuntime;

  if (runtime) {
    if (inModule) {
      // If regeneratorRuntime is defined globally and we're in a module,
      // make the exports object identical to regeneratorRuntime.
      module.exports = runtime;
    } // Don't bother evaluating the rest of this file if the runtime was
    // already defined globally.


    return;
  } // Define the runtime globally (as expected by generated code) as either
  // module.exports (if we're in a module) or a new, empty object.


  runtime = global.regeneratorRuntime = inModule ? module.exports : {};

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []); // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.

    generator._invoke = makeInvokeMethod(innerFn, self, context);
    return generator;
  }

  runtime.wrap = wrap; // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.

  function tryCatch(fn, obj, arg) {
    try {
      return {
        type: "normal",
        arg: fn.call(obj, arg)
      };
    } catch (err) {
      return {
        type: "throw",
        arg: err
      };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed"; // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.

  var ContinueSentinel = {}; // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.

  function Generator() {}

  function GeneratorFunction() {}

  function GeneratorFunctionPrototype() {} // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.


  var IteratorPrototype = {};

  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));

  if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunctionPrototype[toStringTagSymbol] = GeneratorFunction.displayName = "GeneratorFunction"; // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.

  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function (method) {
      prototype[method] = function (arg) {
        return this._invoke(method, arg);
      };
    });
  }

  runtime.isGeneratorFunction = function (genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor ? ctor === GeneratorFunction || // For the native GeneratorFunction constructor, the best we can
    // do is to check its .name property.
    (ctor.displayName || ctor.name) === "GeneratorFunction" : false;
  };

  runtime.mark = function (genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;

      if (!(toStringTagSymbol in genFun)) {
        genFun[toStringTagSymbol] = "GeneratorFunction";
      }
    }

    genFun.prototype = Object.create(Gp);
    return genFun;
  }; // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.


  runtime.awrap = function (arg) {
    return {
      __await: arg
    };
  };

  function AsyncIterator(generator) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);

      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;

        if (value && typeof value === "object" && hasOwn.call(value, "__await")) {
          return Promise.resolve(value.__await).then(function (value) {
            invoke("next", value, resolve, reject);
          }, function (err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return Promise.resolve(value).then(function (unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration. If the Promise is rejected, however, the
          // result for this iteration will be rejected with the same
          // reason. Note that rejections of yielded Promises are not
          // thrown back into the generator function, as is the case
          // when an awaited Promise is rejected. This difference in
          // behavior between yield and await is important, because it
          // allows the consumer to decide what to do with the yielded
          // rejection (swallow it and continue, manually .throw it back
          // into the generator, abandon iteration, whatever). With
          // await, by contrast, there is no opportunity to examine the
          // rejection reason outside the generator function, so the
          // only option is to throw it from the await expression, and
          // let the generator function handle the exception.
          result.value = unwrapped;
          resolve(result);
        }, reject);
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new Promise(function (resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise = // If enqueue has been called before, then we want to wait until
      // all previous Promises have been resolved before calling invoke,
      // so that results are always delivered in the correct order. If
      // enqueue has not been called before, then it is important to
      // call invoke immediately, without waiting on a callback to fire,
      // so that the async generator function has the opportunity to do
      // any necessary setup in a predictable way. This predictability
      // is why the Promise constructor synchronously invokes its
      // executor callback, and why async functions synchronously
      // execute code before the first await. Since we implement simple
      // async functions in terms of async generators, it is especially
      // important to get this right, even though it requires care.
      previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, // Avoid propagating failures to Promises returned by later
      // invocations of the iterator.
      callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
    } // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).


    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);

  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };

  runtime.AsyncIterator = AsyncIterator; // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.

  runtime.async = function (innerFn, outerFn, self, tryLocsList) {
    var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList));
    return runtime.isGeneratorFunction(outerFn) ? iter // If outerFn is a generator, return the full iterator.
    : iter.next().then(function (result) {
      return result.done ? result.value : iter.next();
    });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;
    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        } // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume


        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;

        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);

          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;
        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);
        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;
        var record = tryCatch(innerFn, self, context);

        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done ? GenStateCompleted : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };
        } else if (record.type === "throw") {
          state = GenStateCompleted; // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.

          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  } // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.


  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];

    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        if (delegate.iterator.return) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError("The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (!info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value; // Resume execution at the desired location (see delegateYield).

      context.next = delegate.nextLoc; // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.

      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }
    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    } // The delegate iterator is finished, so forget it and continue with
    // the outer generator.


    context.delegate = null;
    return ContinueSentinel;
  } // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.


  defineIteratorMethods(Gp);
  Gp[toStringTagSymbol] = "Generator"; // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.

  Gp[iteratorSymbol] = function () {
    return this;
  };

  Gp.toString = function () {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = {
      tryLoc: locs[0]
    };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{
      tryLoc: "root"
    }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  runtime.keys = function (object) {
    var keys = [];

    for (var key in object) {
      keys.push(key);
    }

    keys.reverse(); // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.

    return function next() {
      while (keys.length) {
        var key = keys.pop();

        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      } // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.


      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];

      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1,
            next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;
          return next;
        };

        return next.next = next;
      }
    } // Return an iterator with no values.


    return {
      next: doneResult
    };
  }

  runtime.values = values;

  function doneResult() {
    return {
      value: undefined,
      done: true
    };
  }

  Context.prototype = {
    constructor: Context,
    reset: function reset(skipTempReset) {
      this.prev = 0;
      this.next = 0; // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.

      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;
      this.method = "next";
      this.arg = undefined;
      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },
    stop: function stop() {
      this.done = true;
      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;

      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },
    dispatchException: function dispatchException(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;

      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !!caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }
          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }
          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }
          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },
    abrupt: function abrupt(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];

        if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry && (type === "break" || type === "continue") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },
    complete: function complete(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" || record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },
    finish: function finish(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];

        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },
    "catch": function _catch(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];

        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;

          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }

          return thrown;
        }
      } // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.


      throw new Error("illegal catch attempt");
    },
    delegateYield: function delegateYield(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };
}( // In sloppy mode, unbound `this` refers to the global object, fallback to
// Function constructor if we're in global strict mode. That is sadly a form
// of indirect eval which violates Content Security Policy.
function () {
  return this;
}() || Function("return this")());

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/***/ (function(module, exports) {

var g; // This works in non-strict mode

g = function () {
  return this;
}();

try {
  // This works if eval is allowed (see CSP)
  g = g || Function("return this")() || (1, eval)("this");
} catch (e) {
  // This works if the window reference is available
  if (typeof window === "object") g = window;
} // g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}


module.exports = g;

/***/ }),

/***/ "./src/engine/browser/hot-reload.tsx":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__("./node_modules/@babel/polyfill/lib/index.js");

var React = _interopRequireWildcard(__webpack_require__("./node_modules/react/index.js"));

var _gameRender = __webpack_require__("./src/main/game-render.tsx");

var _render = __webpack_require__("./node_modules/@morleydev/pauper/render/jsx/render.js");

var _webAssetLoader = __webpack_require__("./node_modules/@morleydev/pauper/assets/web-asset-loader.service.js");

var _renderToCanvas = __webpack_require__("./node_modules/@morleydev/pauper/render/render-to-canvas.func.js");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

var canvas = document.getElementById("render-target");

if (canvas == null) {
  throw new Error("Could not find #render-target");
}

var context = canvas.getContext("2d");

if (context == null) {
  throw new Error("Could not acquire 2d rendering context");
}

var element = document.getElementById("canvas-container");

if (element == null) {
  throw new Error("Could not find #canvas-container");
}

var assets = new _webAssetLoader.WebAssetLoader();
var renderer = new _render.ReactRenderer(React.createElement(_gameRender.Game, null));
requestAnimationFrame(function draw() {
  var frame = renderer.frame();
  (0, _renderToCanvas.renderToCanvas)({
    canvas: canvas,
    context: context,
    assets: assets
  }, frame);
  requestAnimationFrame(draw);
});

/***/ }),

/***/ "./src/engine/browser/production.tsx":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__("./node_modules/@babel/polyfill/lib/index.js");

var React = _interopRequireWildcard(__webpack_require__("./node_modules/react/index.js"));

var _gameRender = __webpack_require__("./src/main/game-render.tsx");

var _render = __webpack_require__("./node_modules/@morleydev/pauper/render/jsx/render.js");

var _webAssetLoader = __webpack_require__("./node_modules/@morleydev/pauper/assets/web-asset-loader.service.js");

var _renderToCanvas = __webpack_require__("./node_modules/@morleydev/pauper/render/render-to-canvas.func.js");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

var canvas = document.getElementById("render-target");

if (canvas == null) {
  throw new Error("Could not find #render-target");
}

var context = canvas.getContext("2d");

if (context == null) {
  throw new Error("Could not acquire 2d rendering context");
}

var element = document.getElementById("canvas-container");

if (element == null) {
  throw new Error("Could not find #canvas-container");
}

var assets = new _webAssetLoader.WebAssetLoader();
var renderer = new _render.ReactRenderer(React.createElement(_gameRender.Game, null));
requestAnimationFrame(function draw() {
  var frame = renderer.frame();
  (0, _renderToCanvas.renderToCanvas)({
    canvas: canvas,
    context: context,
    assets: assets
  }, frame);
  requestAnimationFrame(draw);
});

/***/ }),

/***/ "./src/index.ts":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__("./node_modules/@babel/polyfill/lib/index.js");

var _isBrowser = __webpack_require__("./node_modules/@morleydev/pauper/utility/is-browser.js");

var _isProduction = __webpack_require__("./node_modules/@morleydev/pauper/utility/is-production.js");

if (_isBrowser.isBrowser) {
  if (!_isProduction.isProduction && module.hot) {
    __webpack_require__("./src/engine/browser/hot-reload.tsx");
  } else {
    __webpack_require__("./src/engine/browser/production.tsx");
  }
} else {}

/***/ }),

/***/ "./src/main/game-render.tsx":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.Game = void 0;

__webpack_require__("./node_modules/@morleydev/pauper/render/jsx/render.js");

var React = _interopRequireWildcard(__webpack_require__("./node_modules/react/index.js"));

var _shapes = __webpack_require__("./node_modules/@morleydev/pauper/models/shapes.model.js");

var _colour = __webpack_require__("./node_modules/@morleydev/pauper/models/colour.model.js");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var Game = function Game(props) {
  return React.createElement("clear", {
    colour: (0, _colour.RGB)(0, 0, 0)
  }, React.createElement("origin", {
    coords: (0, _shapes.Point2)(256, 256)
  }, React.createElement(BallColourFader, null)));
};

exports.Game = Game;

function _ref(state) {
  return {
    colour: (0, _colour.RGBA)(Math.random() * 255, Math.random() * 255, Math.random() * 255, 1)
  };
}

function _componentWillMount() {
  var _this2 = this;

  this.timer = setInterval(function () {
    return _this2.setState(_ref);
  }, 50);
}

function _componentWillUnmount() {
  clearInterval(this.timer);
}

function _render() {
  console.log(this.state.colour);
  return React.createElement("fill", {
    shape: (0, _shapes.Circle)(0, 0, 25),
    colour: this.state.colour
  });
}

var BallColourFader =
/*#__PURE__*/
function (_React$Component) {
  _inheritsLoose(BallColourFader, _React$Component);

  function BallColourFader(props) {
    var _this;

    _this = _React$Component.call(this, props) || this;
    _this.colourWheel = [];
    _this.timer = null;
    _this.state = {
      colour: (0, _colour.RGBA)(0, 0, 0, 1)
    };
    return _this;
  }

  var _proto = BallColourFader.prototype;
  _proto.componentWillMount = _componentWillMount;
  _proto.componentWillUnmount = _componentWillUnmount;
  _proto.render = _render;
  return BallColourFader;
}(React.Component);

/***/ })

/******/ });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgOTI0MDZiOGIxMzAxNmNjMTRmNTYiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9wb2x5ZmlsbC9saWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Btb3JsZXlkZXYvZnVuY3Rpb25hbC1waXBlL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AbW9ybGV5ZGV2L2Z1bmN0aW9uYWwtcGlwZS9pdGVyYWJsZS9nZW5lcmF0b3JzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AbW9ybGV5ZGV2L2Z1bmN0aW9uYWwtcGlwZS9pdGVyYWJsZS9vcGVyYXRvcnMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Btb3JsZXlkZXYvZnVuY3Rpb25hbC1waXBlL3BpcGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Btb3JsZXlkZXYvcGF1cGVyL2Fzc2V0cy93ZWItYXNzZXQtbG9hZGVyLnNlcnZpY2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Btb3JsZXlkZXYvcGF1cGVyL21hdGhzL2ludGVycG9sYXRpb24ubWF0aHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Btb3JsZXlkZXYvcGF1cGVyL21hdGhzL3ZlY3Rvci5tYXRocy5mdW5jLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AbW9ybGV5ZGV2L3BhdXBlci9tYXRocy92ZWN0b3IubWF0aHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Btb3JsZXlkZXYvcGF1cGVyL21hdGhzL3ZlY3Rvci5tYXRocy52YWx1ZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Btb3JsZXlkZXYvcGF1cGVyL21vZGVscy9jaXJjbGUvY2lyY2xlLm1vZGVsLmJvdW5kaW5nLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AbW9ybGV5ZGV2L3BhdXBlci9tb2RlbHMvY2lyY2xlL2NpcmNsZS5tb2RlbC5pcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQG1vcmxleWRldi9wYXVwZXIvbW9kZWxzL2NpcmNsZS9jaXJjbGUubW9kZWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Btb3JsZXlkZXYvcGF1cGVyL21vZGVscy9jaXJjbGUvY2lyY2xlLm1vZGVsLmxpbmVUby5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQG1vcmxleWRldi9wYXVwZXIvbW9kZWxzL2NpcmNsZS9jaXJjbGUubW9kZWwub3ZlcmxhcC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQG1vcmxleWRldi9wYXVwZXIvbW9kZWxzL2NvbG91ci5tb2RlbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQG1vcmxleWRldi9wYXVwZXIvbW9kZWxzL2xpbmUvbGluZS5tb2RlbC5pbnRlcnNlY3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Btb3JsZXlkZXYvcGF1cGVyL21vZGVscy9saW5lL2xpbmUubW9kZWwuaXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Btb3JsZXlkZXYvcGF1cGVyL21vZGVscy9saW5lL2xpbmUubW9kZWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Btb3JsZXlkZXYvcGF1cGVyL21vZGVscy9saW5lL2xpbmUubW9kZWwubGVuZ3RoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AbW9ybGV5ZGV2L3BhdXBlci9tb2RlbHMvbGluZS9saW5lLm1vZGVsLmxpbmVUby5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQG1vcmxleWRldi9wYXVwZXIvbW9kZWxzL3BvaW50L3BvaW50Lm1vZGVsLmJvdW5kaW5nLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AbW9ybGV5ZGV2L3BhdXBlci9tb2RlbHMvcG9pbnQvcG9pbnQubW9kZWwuaXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Btb3JsZXlkZXYvcGF1cGVyL21vZGVscy9wb2ludC9wb2ludC5tb2RlbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQG1vcmxleWRldi9wYXVwZXIvbW9kZWxzL3BvaW50L3BvaW50Lm1vZGVsLnRsYnIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Btb3JsZXlkZXYvcGF1cGVyL21vZGVscy9yZWN0YW5nbGUvcmVjdGFuZ2xlLm1vZGVsLmJvdW5kaW5nLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AbW9ybGV5ZGV2L3BhdXBlci9tb2RlbHMvcmVjdGFuZ2xlL3JlY3RhbmdsZS5tb2RlbC5pcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQG1vcmxleWRldi9wYXVwZXIvbW9kZWxzL3JlY3RhbmdsZS9yZWN0YW5nbGUubW9kZWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Btb3JsZXlkZXYvcGF1cGVyL21vZGVscy9yZWN0YW5nbGUvcmVjdGFuZ2xlLm1vZGVsLmxpbmVUby5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQG1vcmxleWRldi9wYXVwZXIvbW9kZWxzL3JlY3RhbmdsZS9yZWN0YW5nbGUubW9kZWwubGluZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Btb3JsZXlkZXYvcGF1cGVyL21vZGVscy9yZWN0YW5nbGUvcmVjdGFuZ2xlLm1vZGVsLm92ZXJsYXAuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Btb3JsZXlkZXYvcGF1cGVyL21vZGVscy9yZWN0YW5nbGUvcmVjdGFuZ2xlLm1vZGVsLnRsYnIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Btb3JsZXlkZXYvcGF1cGVyL21vZGVscy9zaGFwZXMubW9kZWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Btb3JsZXlkZXYvcGF1cGVyL21vZGVscy90ZXh0L3RleHQubW9kZWwuaXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Btb3JsZXlkZXYvcGF1cGVyL21vZGVscy90ZXh0L3RleHQubW9kZWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Btb3JsZXlkZXYvcGF1cGVyL21vZGVscy90cmlhbmdsZS90cmlhbmdsZS5tb2RlbC5pcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQG1vcmxleWRldi9wYXVwZXIvbW9kZWxzL3RyaWFuZ2xlL3RyaWFuZ2xlLm1vZGVsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AbW9ybGV5ZGV2L3BhdXBlci9tb2RlbHMvdHJpYW5nbGUvdHJpYW5nbGUubW9kZWwubGluZVRvLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AbW9ybGV5ZGV2L3BhdXBlci9tb2RlbHMvdHJpYW5nbGUvdHJpYW5nbGUubW9kZWwubGluZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Btb3JsZXlkZXYvcGF1cGVyL21vZGVscy90cmlhbmdsZS90cmlhbmdsZS5tb2RlbC5vdmVybGFwLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AbW9ybGV5ZGV2L3BhdXBlci9yZW5kZXIvanN4L3JlbmRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQG1vcmxleWRldi9wYXVwZXIvcmVuZGVyL3JlbmRlci1mcmFtZS5tb2RlbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQG1vcmxleWRldi9wYXVwZXIvcmVuZGVyL3JlbmRlci10by1jYW52YXMuZnVuYy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQG1vcmxleWRldi9wYXVwZXIvdXRpbGl0eS9pcy1icm93c2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AbW9ybGV5ZGV2L3BhdXBlci91dGlsaXR5L2lzLXByb2R1Y3Rpb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYS1mdW5jdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hLW51bWJlci12YWx1ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hZGQtdG8tdW5zY29wYWJsZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYW4taW5zdGFuY2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYW4tb2JqZWN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2FycmF5LWNvcHktd2l0aGluLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2FycmF5LWZpbGwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYXJyYXktZnJvbS1pdGVyYWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hcnJheS1pbmNsdWRlcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hcnJheS1tZXRob2RzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2FycmF5LXJlZHVjZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hcnJheS1zcGVjaWVzLWNvbnN0cnVjdG9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2FycmF5LXNwZWNpZXMtY3JlYXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2JpbmQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fY2xhc3NvZi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19jb2YuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fY29sbGVjdGlvbi1zdHJvbmcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fY29sbGVjdGlvbi10by1qc29uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2NvbGxlY3Rpb24td2Vhay5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19jb2xsZWN0aW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2NvcmUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fY3JlYXRlLXByb3BlcnR5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2N0eC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19kYXRlLXRvLWlzby1zdHJpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZGF0ZS10by1wcmltaXRpdmUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZGVmaW5lZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19kZXNjcmlwdG9ycy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19kb20tY3JlYXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2VudW0tYnVnLWtleXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZW51bS1rZXlzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2V4cG9ydC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19mYWlscy1pcy1yZWdleHAuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZmFpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZml4LXJlLXdrcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19mbGFncy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19mbGF0dGVuLWludG8tYXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZm9yLW9mLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2dsb2JhbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19oYXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faGlkZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19odG1sLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2llOC1kb20tZGVmaW5lLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2luaGVyaXQtaWYtcmVxdWlyZWQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faW52b2tlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2lvYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faXMtYXJyYXktaXRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pcy1hcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pcy1pbnRlZ2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2lzLW9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pcy1yZWdleHAuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faXRlci1jYWxsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2l0ZXItY3JlYXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2l0ZXItZGVmaW5lLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2l0ZXItZGV0ZWN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2l0ZXItc3RlcC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pdGVyYXRvcnMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fbGlicmFyeS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19tYXRoLWV4cG0xLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX21hdGgtZnJvdW5kLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX21hdGgtbG9nMXAuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fbWF0aC1zY2FsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19tYXRoLXNpZ24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fbWV0YS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19tZXRhZGF0YS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19taWNyb3Rhc2suanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fbmV3LXByb21pc2UtY2FwYWJpbGl0eS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtYXNzaWduLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1jcmVhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWRwLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1kcHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWZvcmNlZC1wYW0uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWdvcGQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWdvcG4tZXh0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1nb3BuLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1nb3BzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1ncG8uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWtleXMtaW50ZXJuYWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWtleXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LXBpZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3Qtc2FwLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC10by1hcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vd24ta2V5cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19wYXJzZS1mbG9hdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19wYXJzZS1pbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fcGVyZm9ybS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19wcm9taXNlLXJlc29sdmUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fcHJvcGVydHktZGVzYy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19yZWRlZmluZS1hbGwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fcmVkZWZpbmUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc2FtZS12YWx1ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zZXQtY29sbGVjdGlvbi1mcm9tLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3NldC1jb2xsZWN0aW9uLW9mLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3NldC1wcm90by5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zZXQtc3BlY2llcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zZXQtdG8tc3RyaW5nLXRhZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zaGFyZWQta2V5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3NoYXJlZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zcGVjaWVzLWNvbnN0cnVjdG9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3N0cmljdC1tZXRob2QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc3RyaW5nLWF0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3N0cmluZy1jb250ZXh0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3N0cmluZy1odG1sLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3N0cmluZy1wYWQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc3RyaW5nLXJlcGVhdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zdHJpbmctdHJpbS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zdHJpbmctd3MuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdGFzay5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190by1hYnNvbHV0ZS1pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190by1pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190by1pbnRlZ2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3RvLWlvYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdG8tbGVuZ3RoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3RvLW9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190by1wcmltaXRpdmUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdHlwZWQtYXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdHlwZWQtYnVmZmVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3R5cGVkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3VpZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL192YWxpZGF0ZS1jb2xsZWN0aW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3drcy1kZWZpbmUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fd2tzLWV4dC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL193a3MuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9jb3JlLmdldC1pdGVyYXRvci1tZXRob2QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuY29weS13aXRoaW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuZXZlcnkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuZmlsbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5maWx0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuZmluZC1pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5maW5kLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmZvci1lYWNoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmZyb20uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuaW5kZXgtb2YuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuaXMtYXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuaXRlcmF0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuam9pbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5sYXN0LWluZGV4LW9mLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5Lm1hcC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5vZi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5yZWR1Y2UtcmlnaHQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkucmVkdWNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LnNsaWNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LnNvbWUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuc29ydC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5zcGVjaWVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmRhdGUubm93LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmRhdGUudG8taXNvLXN0cmluZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5kYXRlLnRvLWpzb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuZGF0ZS50by1wcmltaXRpdmUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuZGF0ZS50by1zdHJpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuZnVuY3Rpb24uYmluZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5mdW5jdGlvbi5oYXMtaW5zdGFuY2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuZnVuY3Rpb24ubmFtZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5tYXAuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5hY29zaC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmFzaW5oLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguYXRhbmguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5jYnJ0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguY2x6MzIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5jb3NoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguZXhwbTEuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5mcm91bmQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5oeXBvdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmltdWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5sb2cxMC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmxvZzFwLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGgubG9nMi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLnNpZ24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5zaW5oLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGgudGFuaC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLnRydW5jLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci5jb25zdHJ1Y3Rvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5udW1iZXIuZXBzaWxvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5udW1iZXIuaXMtZmluaXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci5pcy1pbnRlZ2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci5pcy1uYW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLmlzLXNhZmUtaW50ZWdlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5udW1iZXIubWF4LXNhZmUtaW50ZWdlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5udW1iZXIubWluLXNhZmUtaW50ZWdlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5udW1iZXIucGFyc2UtZmxvYXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLnBhcnNlLWludC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5udW1iZXIudG8tZml4ZWQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLnRvLXByZWNpc2lvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuYXNzaWduLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5jcmVhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmRlZmluZS1wcm9wZXJ0aWVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5kZWZpbmUtcHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmZyZWV6ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5nZXQtb3duLXByb3BlcnR5LW5hbWVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5nZXQtcHJvdG90eXBlLW9mLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5pcy1leHRlbnNpYmxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5pcy1mcm96ZW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmlzLXNlYWxlZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuaXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmtleXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LnByZXZlbnQtZXh0ZW5zaW9ucy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3Quc2VhbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3Quc2V0LXByb3RvdHlwZS1vZi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QudG8tc3RyaW5nLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnBhcnNlLWZsb2F0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnBhcnNlLWludC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5wcm9taXNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QuYXBwbHkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5jb25zdHJ1Y3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5kZWZpbmUtcHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5kZWxldGUtcHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5lbnVtZXJhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5nZXQtcHJvdG90eXBlLW9mLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QuZ2V0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QuaGFzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QuaXMtZXh0ZW5zaWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0Lm93bi1rZXlzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QucHJldmVudC1leHRlbnNpb25zLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3Quc2V0LXByb3RvdHlwZS1vZi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LnNldC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWdleHAuY29uc3RydWN0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVnZXhwLmZsYWdzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZ2V4cC5tYXRjaC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWdleHAucmVwbGFjZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWdleHAuc2VhcmNoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZ2V4cC5zcGxpdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWdleHAudG8tc3RyaW5nLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnNldC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuYW5jaG9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5iaWcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmJsaW5rLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5ib2xkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5jb2RlLXBvaW50LWF0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5lbmRzLXdpdGguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmZpeGVkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5mb250Y29sb3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmZvbnRzaXplLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5mcm9tLWNvZGUtcG9pbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmluY2x1ZGVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5pdGFsaWNzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5pdGVyYXRvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcubGluay5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcucmF3LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5yZXBlYXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLnNtYWxsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5zdGFydHMtd2l0aC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuc3RyaWtlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5zdWIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLnN1cC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcudHJpbS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zeW1ib2wuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQuYXJyYXktYnVmZmVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnR5cGVkLmRhdGEtdmlldy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC5mbG9hdDMyLWFycmF5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnR5cGVkLmZsb2F0NjQtYXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQuaW50MTYtYXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQuaW50MzItYXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQuaW50OC1hcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC51aW50MTYtYXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQudWludDMyLWFycmF5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnR5cGVkLnVpbnQ4LWFycmF5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnR5cGVkLnVpbnQ4LWNsYW1wZWQtYXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYud2Vhay1tYXAuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYud2Vhay1zZXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcuYXJyYXkuZmxhdC1tYXAuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcuYXJyYXkuZmxhdHRlbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5hcnJheS5pbmNsdWRlcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5hc2FwLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LmVycm9yLmlzLWVycm9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3Lmdsb2JhbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5tYXAuZnJvbS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5tYXAub2YuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcubWFwLnRvLWpzb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcubWF0aC5jbGFtcC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5tYXRoLmRlZy1wZXItcmFkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3Lm1hdGguZGVncmVlcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5tYXRoLmZzY2FsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5tYXRoLmlhZGRoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3Lm1hdGguaW11bGguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcubWF0aC5pc3ViaC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5tYXRoLnJhZC1wZXItZGVnLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3Lm1hdGgucmFkaWFucy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5tYXRoLnNjYWxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3Lm1hdGguc2lnbmJpdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5tYXRoLnVtdWxoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3Lm9iamVjdC5kZWZpbmUtZ2V0dGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3Lm9iamVjdC5kZWZpbmUtc2V0dGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3Lm9iamVjdC5lbnRyaWVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3Lm9iamVjdC5nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3JzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3Lm9iamVjdC5sb29rdXAtZ2V0dGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3Lm9iamVjdC5sb29rdXAtc2V0dGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3Lm9iamVjdC52YWx1ZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcub2JzZXJ2YWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5wcm9taXNlLmZpbmFsbHkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcucHJvbWlzZS50cnkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcucmVmbGVjdC5kZWZpbmUtbWV0YWRhdGEuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcucmVmbGVjdC5kZWxldGUtbWV0YWRhdGEuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcucmVmbGVjdC5nZXQtbWV0YWRhdGEta2V5cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5yZWZsZWN0LmdldC1tZXRhZGF0YS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5yZWZsZWN0LmdldC1vd24tbWV0YWRhdGEta2V5cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5yZWZsZWN0LmdldC1vd24tbWV0YWRhdGEuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcucmVmbGVjdC5oYXMtbWV0YWRhdGEuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcucmVmbGVjdC5oYXMtb3duLW1ldGFkYXRhLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnJlZmxlY3QubWV0YWRhdGEuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcuc2V0LmZyb20uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcuc2V0Lm9mLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnNldC50by1qc29uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnN0cmluZy5hdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5zdHJpbmcubWF0Y2gtYWxsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnN0cmluZy5wYWQtZW5kLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnN0cmluZy5wYWQtc3RhcnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcuc3RyaW5nLnRyaW0tbGVmdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5zdHJpbmcudHJpbS1yaWdodC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5zeW1ib2wuYXN5bmMtaXRlcmF0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcuc3ltYm9sLm9ic2VydmFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcuc3lzdGVtLmdsb2JhbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy53ZWFrLW1hcC5mcm9tLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LndlYWstbWFwLm9mLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LndlYWstc2V0LmZyb20uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcud2Vhay1zZXQub2YuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy93ZWIuZG9tLml0ZXJhYmxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvd2ViLmltbWVkaWF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL3dlYi50aW1lcnMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvc2hpbS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvZW1wdHlGdW5jdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvZW1wdHlPYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2ludmFyaWFudC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvc2hhbGxvd0VxdWFsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mYmpzL2xpYi93YXJuaW5nLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ob3dsZXIvZGlzdC9ob3dsZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29iamVjdC1hc3NpZ24vaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9jaGVja1Byb3BUeXBlcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9saWIvUmVhY3RQcm9wVHlwZXNTZWNyZXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXRlc3QtcmVuZGVyZXIvY2pzL3JlYWN0LXRlc3QtcmVuZGVyZXIuZGV2ZWxvcG1lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXRlc3QtcmVuZGVyZXIvY2pzL3JlYWN0LXRlc3QtcmVuZGVyZXIucHJvZHVjdGlvbi5taW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXRlc3QtcmVuZGVyZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0L2Nqcy9yZWFjdC5kZXZlbG9wbWVudC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QvY2pzL3JlYWN0LnByb2R1Y3Rpb24ubWluLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lLmpzIiwid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2VuZ2luZS9icm93c2VyL2hvdC1yZWxvYWQudHN4Iiwid2VicGFjazovLy8uL3NyYy9lbmdpbmUvYnJvd3Nlci9wcm9kdWN0aW9uLnRzeCIsIndlYnBhY2s6Ly8vLi9zcmMvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL21haW4vZ2FtZS1yZW5kZXIudHN4Il0sIm5hbWVzIjpbInJlcXVpcmUiLCJnbG9iYWwiLCJfYmFiZWxQb2x5ZmlsbCIsIkVycm9yIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJJdGVyYWJsZXMiLCJHZW5lcmF0b3JzIiwicGlwZV8xIiwiJCQiLCJyYW5nZSIsImluZmluaXRlIiwiZW1wdHkiLCJjb25jYXQiLCJrZXlzIiwidmFsdWVzIiwic3RhcnQiLCJjb3VudCIsImkiLCJpdGVyYWJsZXMiLCJpdGVyYWJsZSIsIml0ZW0iLCJrZXkiLCJ1bml0IiwiZGlzdGluY3QiLCJ0YXAiLCJ0YXBwZXIiLCJpdCIsImluZGV4IiwibWFwIiwibWFwcGVyIiwiZmxhdE1hcCIsImlubmVySXRlcmFibGUiLCJpbm5lciIsImZpbHRlciIsInByZWRpY2F0ZSIsInJlZHVjZSIsImluaXRpYWwiLCJwcmV2U3RhdGUiLCJzY2FuIiwiZm9sZCIsIkFycmF5IiwiZnJvbSIsImhlYWQiLCJ0YWlsIiwidGFrZSIsImxhc3QiLCJ1bmRlZmluZWQiLCJmaXJzdCIsInNraXAiLCJ0YWtlV2hpbGUiLCJ0YWtlVW50aWwiLCJza2lwV2hpbGUiLCJjYW5SZXR1cm4iLCJza2lwVW50aWwiLCJwdXNoIiwibmV4dCIsInVuc2hpZnQiLCJsZW5ndGgiLCJzb21lIiwiZXZlcnkiLCJyZXN1bHRTZXQiLCJTZXQiLCJoYXMiLCJhZGQiLCJ4IiwiJCIsImhvd2xlcl8xIiwiV2ViQXNzZXRMb2FkZXIiLCJpbWFnZXMiLCJzb3VuZGVmZmVjdHMiLCJtdXNpYyIsImpzb25zIiwibG9hZEZvbnQiLCJpZCIsInBhdGgiLCJQcm9taXNlIiwicmVzb2x2ZSIsImdldFNvdW5kRWZmZWN0IiwiYXVkaW8iLCJob3dsIiwiSG93bCIsInNyYyIsIm5hbWUiLCJsb2FkU291bmRFZmZlY3QiLCJsb2FkQXVkaW9Gcm9tVXJsIiwiZ2V0SW1hZ2UiLCJpbWFnZSIsImltZyIsIkltYWdlIiwibG9hZEltYWdlIiwiaW1hZ2VBbHJlYWR5TG9hZGVkIiwibG9hZEltYWdlRnJvbVVybCIsImdldE11c2ljIiwibG9hZE11c2ljIiwiZ2V0SnNvbiIsIm5vdEZvdW5kIiwiYXNzZXQiLCJsb2FkSnNvbiIsImZldGNoIiwicmVzdWx0Iiwic3RhdHVzIiwianNvbiIsImJvZHkiLCJyZWplY3QiLCJvbmxvYWQiLCJvbmVycm9yIiwiaHRtbDUiLCJzdGF0ZSIsIm9uY2UiLCJlcnIiLCJsb2FkIiwibGluZWFySW50ZXJwb2xhdGlvbiIsImVuZCIsInBlcmNlbnRhZ2UiLCJjb3NpbmVJbnRlcnBvbGF0aW9uIiwibXUyIiwiTWF0aCIsImNvcyIsIlBJIiwiZXhwb25lbnRpYWxJbnRlcnBvbGF0aW9uIiwicG93ZXIiLCJpbnRlcnBvbGF0aW9uX21hdGhzXzEiLCJhYnMiLCJ5IiwiaW52ZXJ0IiwibGhzIiwicmhzIiwic3VidHJhY3QiLCJtdWx0aXBseSIsImRvdCIsImRpdmlkZSIsIm1hZ25pdHVkZVNxdWFyZWQiLCJtYWduaXR1ZGUiLCJzcXJ0Iiwibm9ybWFsaXNlIiwiZG90UHJvZHVjdCIsIm5vcm1hbCIsImNvbnN0cmFpbnQiLCJ0b3BMZWZ0IiwiYm90dG9tUmlnaHQiLCJtaW4iLCJtYXgiLCJjcm9zc1Byb2R1Y3QiLCJpbnRlcnBvbGF0ZVgiLCJpbnRlcnBvbGF0ZVkiLCJleHBvbmVudCIsImV4cG9uZW50aWFsSW50ZXJwb2xhdG9yIiwiZnVuYyIsIlZlY3RvcjIiLCJhc3NpZ24iLCJaZXJvIiwiVW5pdCIsImJvdW5kaW5nQm94IiwiY2lyY2xlIiwicmFkaXVzIiwid2lkdGgiLCJoZWlnaHQiLCJpcyIsInBvc3NpYmxlIiwiYm91bmRpbmciLCJsaW5lVG8iLCJvdmVybGFwIiwiQ2lyY2xlIiwidmVjdG9yX21hdGhzX2Z1bmNfMSIsImxpbmVfbW9kZWxfaXNfMSIsImxpbmVfbW9kZWxfbGluZVRvXzEiLCJyZWN0YW5nbGVfbW9kZWxfaXNfMSIsInJlY3RhbmdsZV9tb2RlbF9saW5lVG9fMSIsInRyaWFuZ2xlX21vZGVsX2lzXzEiLCJjaXJjbGVfbW9kZWxfaXNfMSIsImxpbmVMaW5lMlRvQ2lyY2xlIiwiYiIsImEiLCJsaW5lQ2lyY2xlVG9UcmlhbmdsZTIiLCJsaW5lQ2lyY2xlVG9DaXJjbGUiLCJsaW5lUmVjdGFuZ2xlVG9DaXJjbGUiLCJsaW5lQ2lyY2xlVG9Qb2ludDIiLCJvZmZzZXQiLCJub3JtYWxpc2VkIiwiYyIsIm1hZ0EiLCJtYWdCIiwibWFnQyIsIm4iLCJsIiwiciIsImxpbmVfbW9kZWxfaW50ZXJzZWN0XzEiLCJsaW5lX21vZGVsX2xlbmd0aF8xIiwidHJpYW5nbGVfbW9kZWxfb3ZlcmxhcF8xIiwib3ZlcmxhcHMiLCJjaXJjbGVPdmVybGFwc0xpbmUyIiwiY2lyY2xlT3ZlcmxhcHNUcmlhbmdsZTIiLCJjaXJjbGVPdmVybGFwc0NpcmNsZSIsImNpcmNsZU92ZXJsYXBzUmVjdGFuZ2xlIiwiY2lyY2xlT3ZlcmxhcHNQb2ludDIiLCJsaW5lMkludGVyc2VjdHNDaXJjbGUiLCJ0cmlhbmdsZTJPdmVybGFwc0NpcmNsZSIsImxlbmd0aE9mIiwiUkdCQSIsImciLCJSR0IiLCJwb2ludF9tb2RlbF9ib3VuZGluZ18xIiwicmVjdGFuZ2xlX21vZGVsX2xpbmVzXzEiLCJpbnRlcnNlY3RzIiwidG9sZXJhbmNlIiwibGluZTJJbnRlcnNlY3RzTGluZTIiLCJsaW5lMkludGVyc2VjdHNUcmlhbmdsZTIiLCJsaW5lMkludGVyc2VjdHNSZWN0YW5nbGUiLCJsaW5lMkludGVyc2VjdHNQb2ludDIiLCJhMSIsImEyIiwidjEiLCJ2MiIsInYzIiwiYTAiLCJkaXN0VG9TZWdtZW50U3F1YXJlZCIsIm1hZ25pdHVkZUJldHdlZW5Qb2ludHNTcXVhcmVkIiwidiIsInciLCJsZW5ndGhTcXVhcmVkT2ZMaW5lIiwiYW5nbGVPZkF0dGFjayIsInBvaW50T25MaW5lIiwibGluZXMiLCJib3R0b20iLCJ0b3AiLCJsZWZ0IiwicmlnaHQiLCJiMSIsImIyIiwic2FtZVNpZ24iLCJ4MSIsInkxIiwieDIiLCJ5MiIsIngzIiwieTMiLCJ4NCIsInk0IiwiczEiLCJ0MSIsInUxIiwicjMiLCJyNCIsInMyIiwidDIiLCJ1MiIsInIxIiwicjIiLCJib3VuZGluZ1RMQlIiLCJwb2ludF9tb2RlbF9pc18xIiwicG9zc2libHkiLCJpc0FycmF5IiwiaW50ZXJzZWN0IiwiTGluZTIiLCJ2ZWN0b3JfbWF0aHNfMSIsImxpbmUiLCJmdW5jdGlvbmFsX3BpcGVfMSIsIm9wZXJhdG9yc18xIiwibGluZUxpbmUyVG9MaW5lMiIsImxpbmVMaW5lMlRvVHJpYW5nbGUyIiwibGluZUxpbmUyVG9SZWN0YW5nbGUiLCJsaW5lTGluZTJUb1BvaW50MiIsImZpbmRTaG9ydGVzdExpbmUiLCJzZWdtZW50IiwibGVuZ3RoMiIsInByZXYiLCJjdXJyIiwibGluZVNldCIsImdldENlbnRyZU9mTGluZSIsImwwIiwibGVuZ3RoT2ZMaW5lIiwiYW5nbGVPZkxpbmUiLCJyYWRpdXNPZkxpbmUiLCJyaHNQb3NpdGlvbiIsInBvc2l0aW9uT25MaW5lIiwicG9pbnRfbW9kZWxfdGxicl8xIiwiZ2V0VG9wTGVmdCIsImdldEJvdHRvbVJpZ2h0IiwidGxiciIsIlBvaW50MiIsIl9wb2ludHMiLCJwb2ludCIsImdldFRvcFJpZ2h0IiwiZ2V0Qm90dG9tTGVmdCIsImdldENlbnRyZSIsInRsIiwiYnIiLCJfcmVjdHMiLCJyZWN0IiwiUmVjdGFuZ2xlIiwicmVjdGFuZ2xlX21vZGVsX3RsYnJfMSIsImxpbmVSZWN0YW5nbGVUb1RyaWFuZ2xlIiwibGluZVJlY3RhbmdsZVRvUmVjdGFuZ2xlIiwibGluZVJlY3RhbmdsZVRvUG9pbnQyIiwibGhzQ2VudHJlIiwicmhzQ2VudHJlIiwibGhzRWRnZSIsInJoc0VkZ2UiLCJwb2ludE9uUmVjdGFuZ2xlIiwiY2VudHJlT2ZDaXJjbGUiLCJ2ZWN0b3JPZkxpbmUiLCJub3JtYWxpc2VkTGluZSIsImxpbmVPZlJhZGl1c0xlbmd0aCIsInBvaW50T25DaXJjbGUiLCJyZWN0YW5nbGVfbW9kZWxfYm91bmRpbmdfMSIsInJlY3RhbmdsZSIsInJlY3RhbmdsZU92ZXJsYXBzTGluZTIiLCJyZWN0YW5nbGVPdmVybGFwc1RyaWFuZ2xlMiIsInJlY3RhbmdsZU92ZXJsYXBzUmVjdGFuZ2xlIiwicmVjdGFuZ2xlT3ZlcmxhcHNDaXJjbGUiLCJyZWN0YW5nbGVPdmVybGFwc1BvaW50MiIsInRyaWFuZ2xlMk92ZXJsYXBzUmVjdGFuZ2xlIiwiZnJvbVRvcExlZnRCb3R0b21SaWdodCIsImNpcmNsZV9tb2RlbF8xIiwibGluZV9tb2RlbF8xIiwicG9pbnRfbW9kZWxfMSIsInJlY3RhbmdsZV9tb2RlbF8xIiwidHJpYW5nbGVfbW9kZWxfMSIsImNpcmNsZV9tb2RlbF8yIiwicG9pbnRfbW9kZWxfMiIsImxpbmVfbW9kZWxfMiIsInJlY3RhbmdsZV9tb2RlbF8yIiwidGV4dF9tb2RlbF8xIiwiVGV4dDIiLCJ0cmlhbmdsZV9tb2RlbF8yIiwiVHJpYW5nbGUyIiwiU2hhcGUyIiwiY29sbGlzaW9uIiwidmVydCIsInNoYXBlIiwic3VtIiwiZmxpcCIsInRleHQiLCJmb250U2l6ZSIsImZvbnRGYW1pbHkiLCJjaXJjbGVfbW9kZWxfbGluZVRvXzEiLCJ0cmlhbmdsZV9tb2RlbF9saW5lc18xIiwibGluZVRyaWFuZ2xlMlRvVHJpYW5nbGUyIiwibGluZVRyaWFuZ2xlVG9Qb2ludDIiLCJsZWZ0TGluZXMiLCJyaWdodExpbmVzIiwibGxpbmUiLCJybGluZSIsInRyaWFuZ2xlMk92ZXJsYXBzVHJpYW5nbGUyIiwidHJpYW5nbGUyT3ZlcmxhcHNMaW5lMiIsInRyaWFuZ2xlMk92ZXJsYXBzUG9pbnQyIiwicmVjdExpbmVTZXQiLCJsaHNMaW5lcyIsInJoc0xpbmUiLCJzaWduIiwicDEiLCJwMiIsInAzIiwiYjMiLCJyZW5kZXJfZnJhbWVfbW9kZWxfMSIsImNvbG91cl9tb2RlbF8xIiwicmVhY3RfdGVzdF9yZW5kZXJlcl8xIiwiUmVhY3RSZW5kZXJlciIsImVsZW1lbnQiLCJyZW5kZXJlciIsImNyZWF0ZSIsImZyYW1lIiwidG9KU09OIiwianNvblRvRnJhbWUiLCJ0eXBlIiwiQ2xlYXIiLCJwcm9wcyIsImNoaWxkcmVuIiwiT3JpZ2luIiwiUm90YXRlIiwiU2NhbGUiLCJGaWxsIiwiU3Ryb2tlIiwiQmxpdCIsIlJlbmRlclRhcmdldCIsIkZyYW1lIiwiX2NvbW1hbmRzIiwiRnJhbWVDb21tYW5kVHlwZSIsImNvbG91ciIsIm9yaWdpbiIsImNoaWxkIiwicmFkaWFuIiwic2NhbGUiLCJkc3QiLCJzaXplIiwic2hhcGVzX21vZGVsXzEiLCJyZW5kZXJUb0NhbnZhcyIsInRhcmdldCIsImZvckVhY2giLCJjb21tYW5kIiwiUmVuZGVyQ29tbWFuZCIsImNvbW1hbmRUeXBlIiwicmVuZGVyQ2xlYXIiLCJyZW5kZXJPcmlnaW4iLCJyZW5kZXJSZW5kZXJUYXJnZXQiLCJyZW5kZXJSb3RhdGUiLCJyZW5kZXJTY2FsZSIsInJlbmRlckZpbGwiLCJyZW5kZXJTdHJva2UiLCJyZW5kZXJCbGl0IiwiY2FudmFzIiwiY29udGV4dCIsImFzc2V0cyIsInRyYW5zbGF0ZSIsInJvdGF0aW9uIiwicm90YXRlIiwiaW1nQXNzZXQiLCJkcmF3SW1hZ2UiLCJmaWxsIiwiYmVnaW5QYXRoIiwiZmlsbFN0eWxlIiwiZ2V0UkdCQSIsIm1vdmVUbyIsImZvbnQiLCJmaWxsVGV4dCIsImZpbGxSZWN0IiwiYXJjIiwic3Ryb2tlU3R5bGUiLCJzdHJva2UiLCJzdHJva2VUZXh0Iiwic3Ryb2tlUmVjdCIsImNsb3NlUGF0aCIsImNsZWFyIiwic2V0VHJhbnNmb3JtIiwiY2xlYXJSZWN0IiwiZ2V0UkdCIiwiY2FudmFzQ2FjaGUiLCJfIiwiZnJhbWVzIiwidGFyZ2V0Q2FudmFzIiwibmV3Q2FudmFzIiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50IiwiZ2V0Q29udGV4dCIsImlzQnJvd3NlciIsIndpbmRvdyIsImlzUHJvZHVjdGlvbiIsInByb2Nlc3MiLCJlbnYiLCJtb2R1bGUiLCJUeXBlRXJyb3IiLCJjb2YiLCJtc2ciLCJVTlNDT1BBQkxFUyIsIkFycmF5UHJvdG8iLCJwcm90b3R5cGUiLCJDb25zdHJ1Y3RvciIsImZvcmJpZGRlbkZpZWxkIiwiaXNPYmplY3QiLCJ0b09iamVjdCIsInRvQWJzb2x1dGVJbmRleCIsInRvTGVuZ3RoIiwiY29weVdpdGhpbiIsIk8iLCJsZW4iLCJ0byIsImFyZ3VtZW50cyIsImluYyIsImFMZW4iLCJlbmRQb3MiLCJmb3JPZiIsIml0ZXIiLCJJVEVSQVRPUiIsInRvSU9iamVjdCIsIklTX0lOQ0xVREVTIiwiJHRoaXMiLCJlbCIsImZyb21JbmRleCIsImN0eCIsIklPYmplY3QiLCJhc2MiLCJUWVBFIiwiJGNyZWF0ZSIsIklTX01BUCIsIklTX0ZJTFRFUiIsIklTX1NPTUUiLCJJU19FVkVSWSIsIklTX0ZJTkRfSU5ERVgiLCJOT19IT0xFUyIsImNhbGxiYWNrZm4iLCJ0aGF0Iiwic2VsZiIsImYiLCJ2YWwiLCJyZXMiLCJhRnVuY3Rpb24iLCJtZW1vIiwiaXNSaWdodCIsIlNQRUNJRVMiLCJvcmlnaW5hbCIsIkMiLCJjb25zdHJ1Y3RvciIsInNwZWNpZXNDb25zdHJ1Y3RvciIsImludm9rZSIsImFycmF5U2xpY2UiLCJzbGljZSIsImZhY3RvcmllcyIsImNvbnN0cnVjdCIsIkYiLCJhcmdzIiwiRnVuY3Rpb24iLCJqb2luIiwiYmluZCIsImZuIiwicGFydEFyZ3MiLCJjYWxsIiwiYm91bmQiLCJUQUciLCJBUkciLCJ0cnlHZXQiLCJlIiwiVCIsIkIiLCJjYWxsZWUiLCJ0b1N0cmluZyIsImRQIiwicmVkZWZpbmVBbGwiLCJhbkluc3RhbmNlIiwiJGl0ZXJEZWZpbmUiLCJzdGVwIiwic2V0U3BlY2llcyIsIkRFU0NSSVBUT1JTIiwiZmFzdEtleSIsInZhbGlkYXRlIiwiU0laRSIsImdldEVudHJ5IiwiZW50cnkiLCJfaSIsIl9mIiwiayIsImdldENvbnN0cnVjdG9yIiwid3JhcHBlciIsIk5BTUUiLCJBRERFUiIsIl90IiwiX2wiLCJkYXRhIiwicCIsImdldCIsImRlZiIsInNldFN0cm9uZyIsIml0ZXJhdGVkIiwia2luZCIsIl9rIiwiY2xhc3NvZiIsImdldFdlYWsiLCJhbk9iamVjdCIsImNyZWF0ZUFycmF5TWV0aG9kIiwiJGhhcyIsImFycmF5RmluZCIsImFycmF5RmluZEluZGV4IiwidW5jYXVnaHRGcm96ZW5TdG9yZSIsIlVuY2F1Z2h0RnJvemVuU3RvcmUiLCJmaW5kVW5jYXVnaHRGcm96ZW4iLCJzdG9yZSIsInNldCIsInNwbGljZSIsInVmc3RvcmUiLCIkZXhwb3J0IiwicmVkZWZpbmUiLCJtZXRhIiwiZmFpbHMiLCIkaXRlckRldGVjdCIsInNldFRvU3RyaW5nVGFnIiwiaW5oZXJpdElmUmVxdWlyZWQiLCJtZXRob2RzIiwiY29tbW9uIiwiSVNfV0VBSyIsIkJhc2UiLCJwcm90byIsImZpeE1ldGhvZCIsIktFWSIsImVudHJpZXMiLCJORUVEIiwiaW5zdGFuY2UiLCJIQVNOVF9DSEFJTklORyIsIlRIUk9XU19PTl9QUklNSVRJVkVTIiwiQUNDRVBUX0lURVJBQkxFUyIsIkJVR0dZX1pFUk8iLCIkaW5zdGFuY2UiLCJHIiwiVyIsImNvcmUiLCJ2ZXJzaW9uIiwiX19lIiwiJGRlZmluZVByb3BlcnR5IiwiY3JlYXRlRGVzYyIsIm9iamVjdCIsImFwcGx5IiwiZ2V0VGltZSIsIkRhdGUiLCIkdG9JU09TdHJpbmciLCJ0b0lTT1N0cmluZyIsImx6IiwibnVtIiwiTmFOIiwiaXNGaW5pdGUiLCJSYW5nZUVycm9yIiwiZCIsImdldFVUQ0Z1bGxZZWFyIiwibSIsImdldFVUQ01pbGxpc2Vjb25kcyIsInMiLCJnZXRVVENNb250aCIsImdldFVUQ0RhdGUiLCJnZXRVVENIb3VycyIsImdldFVUQ01pbnV0ZXMiLCJnZXRVVENTZWNvbmRzIiwidG9QcmltaXRpdmUiLCJOVU1CRVIiLCJoaW50Iiwic3BsaXQiLCJnZXRLZXlzIiwiZ09QUyIsInBJRSIsImdldFN5bWJvbHMiLCJzeW1ib2xzIiwiaXNFbnVtIiwiaGlkZSIsIlBST1RPVFlQRSIsInNvdXJjZSIsIklTX0ZPUkNFRCIsIklTX0dMT0JBTCIsIklTX1NUQVRJQyIsIlMiLCJJU19QUk9UTyIsIlAiLCJJU19CSU5EIiwiZXhwUHJvdG8iLCJvd24iLCJvdXQiLCJleHAiLCJVIiwiUiIsIk1BVENIIiwicmUiLCJleGVjIiwiZGVmaW5lZCIsIndrcyIsIlNZTUJPTCIsImZucyIsInN0cmZuIiwicnhmbiIsIlN0cmluZyIsIlJlZ0V4cCIsInN0cmluZyIsImFyZyIsImlnbm9yZUNhc2UiLCJtdWx0aWxpbmUiLCJ1bmljb2RlIiwic3RpY2t5IiwiSVNfQ09OQ0FUX1NQUkVBREFCTEUiLCJmbGF0dGVuSW50b0FycmF5Iiwic291cmNlTGVuIiwiZGVwdGgiLCJ0aGlzQXJnIiwidGFyZ2V0SW5kZXgiLCJzb3VyY2VJbmRleCIsIm1hcEZuIiwic3ByZWFkYWJsZSIsImlzQXJyYXlJdGVyIiwiZ2V0SXRlckZuIiwiQlJFQUsiLCJSRVRVUk4iLCJpdGVyRm4iLCJpdGVyYXRvciIsImRvbmUiLCJfX2ciLCJoYXNPd25Qcm9wZXJ0eSIsImRvY3VtZW50RWxlbWVudCIsInNldFByb3RvdHlwZU9mIiwidW4iLCJwcm9wZXJ0eUlzRW51bWVyYWJsZSIsIkl0ZXJhdG9ycyIsImZsb29yIiwiaXNJbnRlZ2VyIiwiaXNSZWdFeHAiLCJyZXQiLCJkZXNjcmlwdG9yIiwiSXRlcmF0b3JQcm90b3R5cGUiLCJMSUJSQVJZIiwiJGl0ZXJDcmVhdGUiLCJnZXRQcm90b3R5cGVPZiIsIkJVR0dZIiwiRkZfSVRFUkFUT1IiLCJLRVlTIiwiVkFMVUVTIiwicmV0dXJuVGhpcyIsIkRFRkFVTFQiLCJJU19TRVQiLCJGT1JDRUQiLCJnZXRNZXRob2QiLCJERUZfVkFMVUVTIiwiVkFMVUVTX0JVRyIsIiRuYXRpdmUiLCIkZGVmYXVsdCIsIiRlbnRyaWVzIiwiJGFueU5hdGl2ZSIsIlNBRkVfQ0xPU0lORyIsInJpdGVyIiwic2tpcENsb3NpbmciLCJzYWZlIiwiYXJyIiwiJGV4cG0xIiwiZXhwbTEiLCJwb3ciLCJFUFNJTE9OIiwiRVBTSUxPTjMyIiwiTUFYMzIiLCJNSU4zMiIsInJvdW5kVGllc1RvRXZlbiIsImZyb3VuZCIsIiRhYnMiLCIkc2lnbiIsIkluZmluaXR5IiwibG9nMXAiLCJsb2ciLCJpbkxvdyIsImluSGlnaCIsIm91dExvdyIsIm91dEhpZ2giLCJNRVRBIiwic2V0RGVzYyIsImlzRXh0ZW5zaWJsZSIsIkZSRUVaRSIsInByZXZlbnRFeHRlbnNpb25zIiwic2V0TWV0YSIsIm9uRnJlZXplIiwiTWFwIiwic2hhcmVkIiwiZ2V0T3JDcmVhdGVNZXRhZGF0YU1hcCIsInRhcmdldEtleSIsInRhcmdldE1ldGFkYXRhIiwia2V5TWV0YWRhdGEiLCJvcmRpbmFyeUhhc093bk1ldGFkYXRhIiwiTWV0YWRhdGFLZXkiLCJtZXRhZGF0YU1hcCIsIm9yZGluYXJ5R2V0T3duTWV0YWRhdGEiLCJvcmRpbmFyeURlZmluZU93bk1ldGFkYXRhIiwiTWV0YWRhdGFWYWx1ZSIsIm9yZGluYXJ5T3duTWV0YWRhdGFLZXlzIiwidG9NZXRhS2V5IiwibWFjcm90YXNrIiwiT2JzZXJ2ZXIiLCJNdXRhdGlvbk9ic2VydmVyIiwiV2ViS2l0TXV0YXRpb25PYnNlcnZlciIsImlzTm9kZSIsIm5vdGlmeSIsImZsdXNoIiwicGFyZW50IiwiZG9tYWluIiwiZXhpdCIsImVudGVyIiwibmV4dFRpY2siLCJ0b2dnbGUiLCJub2RlIiwiY3JlYXRlVGV4dE5vZGUiLCJvYnNlcnZlIiwiY2hhcmFjdGVyRGF0YSIsInByb21pc2UiLCJ0aGVuIiwidGFzayIsIlByb21pc2VDYXBhYmlsaXR5IiwiJCRyZXNvbHZlIiwiJCRyZWplY3QiLCIkYXNzaWduIiwiQSIsIlN5bWJvbCIsIksiLCJqIiwiZFBzIiwiZW51bUJ1Z0tleXMiLCJJRV9QUk9UTyIsIkVtcHR5IiwiY3JlYXRlRGljdCIsImlmcmFtZSIsImx0IiwiZ3QiLCJpZnJhbWVEb2N1bWVudCIsInN0eWxlIiwiZGlzcGxheSIsImFwcGVuZENoaWxkIiwiY29udGVudFdpbmRvdyIsIm9wZW4iLCJ3cml0ZSIsImNsb3NlIiwiUHJvcGVydGllcyIsIklFOF9ET01fREVGSU5FIiwiQXR0cmlidXRlcyIsImRlZmluZVByb3BlcnRpZXMiLCJyYW5kb20iLCJfX2RlZmluZVNldHRlcl9fIiwiZ09QRCIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImdPUE4iLCJ3aW5kb3dOYW1lcyIsImdldE93blByb3BlcnR5TmFtZXMiLCJnZXRXaW5kb3dOYW1lcyIsIiRrZXlzIiwiaGlkZGVuS2V5cyIsImdldE93blByb3BlcnR5U3ltYm9scyIsIk9iamVjdFByb3RvIiwiYXJyYXlJbmRleE9mIiwibmFtZXMiLCJpc0VudHJpZXMiLCJSZWZsZWN0Iiwib3duS2V5cyIsIiRwYXJzZUZsb2F0IiwicGFyc2VGbG9hdCIsIiR0cmltIiwidHJpbSIsInN0ciIsImNoYXJBdCIsIiRwYXJzZUludCIsInBhcnNlSW50Iiwid3MiLCJoZXgiLCJyYWRpeCIsInRlc3QiLCJuZXdQcm9taXNlQ2FwYWJpbGl0eSIsInByb21pc2VDYXBhYmlsaXR5IiwiYml0bWFwIiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwiU1JDIiwiVE9fU1RSSU5HIiwiJHRvU3RyaW5nIiwiVFBMIiwiaW5zcGVjdFNvdXJjZSIsImlzRnVuY3Rpb24iLCJDT0xMRUNUSU9OIiwibWFwcGluZyIsImNiIiwibmV4dEl0ZW0iLCJvZiIsImNoZWNrIiwiYnVnZ3kiLCJfX3Byb3RvX18iLCJ0YWciLCJzdGF0IiwidWlkIiwiU0hBUkVEIiwiRCIsIm1ldGhvZCIsInRvSW50ZWdlciIsInBvcyIsImNoYXJDb2RlQXQiLCJzZWFyY2hTdHJpbmciLCJxdW90IiwiY3JlYXRlSFRNTCIsImF0dHJpYnV0ZSIsInJlcGxhY2UiLCJ0b0xvd2VyQ2FzZSIsInJlcGVhdCIsIm1heExlbmd0aCIsImZpbGxTdHJpbmciLCJzdHJpbmdMZW5ndGgiLCJmaWxsU3RyIiwiaW50TWF4TGVuZ3RoIiwiZmlsbExlbiIsInN0cmluZ0ZpbGxlciIsImNlaWwiLCJzcGFjZXMiLCJzcGFjZSIsIm5vbiIsImx0cmltIiwicnRyaW0iLCJleHBvcnRlciIsIkFMSUFTIiwiRk9SQ0UiLCJodG1sIiwiY2VsIiwic2V0VGFzayIsInNldEltbWVkaWF0ZSIsImNsZWFyVGFzayIsImNsZWFySW1tZWRpYXRlIiwiTWVzc2FnZUNoYW5uZWwiLCJEaXNwYXRjaCIsImNvdW50ZXIiLCJxdWV1ZSIsIk9OUkVBRFlTVEFURUNIQU5HRSIsImRlZmVyIiwiY2hhbm5lbCIsInBvcnQiLCJydW4iLCJsaXN0ZW5lciIsImV2ZW50Iiwibm93IiwicG9ydDIiLCJwb3J0MSIsIm9ubWVzc2FnZSIsInBvc3RNZXNzYWdlIiwiYWRkRXZlbnRMaXN0ZW5lciIsImltcG9ydFNjcmlwdHMiLCJyZW1vdmVDaGlsZCIsInNldFRpbWVvdXQiLCJudW1iZXIiLCJpc05hTiIsInZhbHVlT2YiLCIkdHlwZWQiLCIkYnVmZmVyIiwicHJvcGVydHlEZXNjIiwidG9JbmRleCIsImNyZWF0ZUFycmF5SW5jbHVkZXMiLCJBcnJheUl0ZXJhdG9ycyIsImFycmF5RmlsbCIsImFycmF5Q29weVdpdGhpbiIsIiREUCIsIiRHT1BEIiwiVWludDhBcnJheSIsIkFSUkFZX0JVRkZFUiIsIlNIQVJFRF9CVUZGRVIiLCJCWVRFU19QRVJfRUxFTUVOVCIsIiRBcnJheUJ1ZmZlciIsIkFycmF5QnVmZmVyIiwiJERhdGFWaWV3IiwiRGF0YVZpZXciLCJhcnJheUZvckVhY2giLCJhcnJheUZpbHRlciIsImFycmF5U29tZSIsImFycmF5RXZlcnkiLCJhcnJheUluY2x1ZGVzIiwiYXJyYXlWYWx1ZXMiLCJhcnJheUtleXMiLCJhcnJheUVudHJpZXMiLCJhcnJheUxhc3RJbmRleE9mIiwibGFzdEluZGV4T2YiLCJhcnJheVJlZHVjZSIsImFycmF5UmVkdWNlUmlnaHQiLCJyZWR1Y2VSaWdodCIsImFycmF5Sm9pbiIsImFycmF5U29ydCIsInNvcnQiLCJhcnJheVRvU3RyaW5nIiwiYXJyYXlUb0xvY2FsZVN0cmluZyIsInRvTG9jYWxlU3RyaW5nIiwiVFlQRURfQ09OU1RSVUNUT1IiLCJERUZfQ09OU1RSVUNUT1IiLCJBTExfQ09OU1RSVUNUT1JTIiwiQ09OU1RSIiwiVFlQRURfQVJSQVkiLCJUWVBFRCIsIlZJRVciLCJXUk9OR19MRU5HVEgiLCIkbWFwIiwiYWxsb2NhdGUiLCJMSVRUTEVfRU5ESUFOIiwiVWludDE2QXJyYXkiLCJidWZmZXIiLCJGT1JDRURfU0VUIiwidG9PZmZzZXQiLCJCWVRFUyIsInNwZWNpZXNGcm9tTGlzdCIsImxpc3QiLCJmcm9tTGlzdCIsImFkZEdldHRlciIsImludGVybmFsIiwiX2QiLCIkZnJvbSIsIm1hcGZuIiwiJG9mIiwiVE9fTE9DQUxFX0JVRyIsIiR0b0xvY2FsZVN0cmluZyIsImZpbmQiLCJmaW5kSW5kZXgiLCJpbmRleE9mIiwic2VhcmNoRWxlbWVudCIsImluY2x1ZGVzIiwic2VwYXJhdG9yIiwicmV2ZXJzZSIsIm1pZGRsZSIsImNvbXBhcmVmbiIsInN1YmFycmF5IiwiYmVnaW4iLCIkYmVnaW4iLCJieXRlT2Zmc2V0IiwiJHNsaWNlIiwiJHNldCIsImFycmF5TGlrZSIsIiRpdGVyYXRvcnMiLCJpc1RBSW5kZXgiLCIkZ2V0RGVzYyIsIiRzZXREZXNjIiwiZGVzYyIsIiRUeXBlZEFycmF5UHJvdG90eXBlJCIsIkNMQU1QRUQiLCJHRVRURVIiLCJTRVRURVIiLCJUeXBlZEFycmF5IiwiVEFDIiwiQUJWIiwiVHlwZWRBcnJheVByb3RvdHlwZSIsImdldHRlciIsIm8iLCJzZXR0ZXIiLCJyb3VuZCIsImFkZEVsZW1lbnQiLCIkb2Zmc2V0IiwiJGxlbmd0aCIsImJ5dGVMZW5ndGgiLCJrbGFzcyIsIiRsZW4iLCIkbmF0aXZlSXRlcmF0b3IiLCJDT1JSRUNUX0lURVJfTkFNRSIsIiRpdGVyYXRvciIsIkRBVEFfVklFVyIsIldST05HX0lOREVYIiwiQmFzZUJ1ZmZlciIsIkxOMiIsIkJVRkZFUiIsIkJZVEVfTEVOR1RIIiwiQllURV9PRkZTRVQiLCIkQlVGRkVSIiwiJExFTkdUSCIsIiRPRkZTRVQiLCJwYWNrSUVFRTc1NCIsIm1MZW4iLCJuQnl0ZXMiLCJlTGVuIiwiZU1heCIsImVCaWFzIiwicnQiLCJ1bnBhY2tJRUVFNzU0IiwibkJpdHMiLCJ1bnBhY2tJMzIiLCJieXRlcyIsInBhY2tJOCIsInBhY2tJMTYiLCJwYWNrSTMyIiwicGFja0Y2NCIsInBhY2tGMzIiLCJ2aWV3IiwiaXNMaXR0bGVFbmRpYW4iLCJudW1JbmRleCIsImludEluZGV4IiwiX2IiLCJwYWNrIiwiY29udmVyc2lvbiIsImJ1ZmZlckxlbmd0aCIsImdldEludDgiLCJnZXRVaW50OCIsImdldEludDE2IiwiZ2V0VWludDE2IiwiZ2V0SW50MzIiLCJnZXRVaW50MzIiLCJnZXRGbG9hdDMyIiwiZ2V0RmxvYXQ2NCIsInNldEludDgiLCJzZXRVaW50OCIsInNldEludDE2Iiwic2V0VWludDE2Iiwic2V0SW50MzIiLCJzZXRVaW50MzIiLCJzZXRGbG9hdDMyIiwic2V0RmxvYXQ2NCIsIkFycmF5QnVmZmVyUHJvdG8iLCIkc2V0SW50OCIsIlR5cGVkIiwiVHlwZWRBcnJheUNvbnN0cnVjdG9ycyIsInB4Iiwid2tzRXh0IiwiJFN5bWJvbCIsIlVTRV9TWU1CT0wiLCIkZXhwb3J0cyIsImdldEl0ZXJhdG9yTWV0aG9kIiwiJGV2ZXJ5IiwiJGZpbHRlciIsIiRmaW5kIiwiZm9yY2VkIiwiJGZvckVhY2giLCJTVFJJQ1QiLCJjcmVhdGVQcm9wZXJ0eSIsIiRpbmRleE9mIiwiTkVHQVRJVkVfWkVSTyIsImFkZFRvVW5zY29wYWJsZXMiLCJBcmd1bWVudHMiLCIkcmVkdWNlIiwidXBUbyIsImNsb25lZCIsIiRzb21lIiwiJHNvcnQiLCJwdiIsIlRPX1BSSU1JVElWRSIsIkRhdGVQcm90byIsIklOVkFMSURfREFURSIsIkhBU19JTlNUQU5DRSIsIkZ1bmN0aW9uUHJvdG8iLCJGUHJvdG8iLCJuYW1lUkUiLCJtYXRjaCIsInN0cm9uZyIsIk1BUCIsIiRhY29zaCIsImFjb3NoIiwiTnVtYmVyIiwiTUFYX1ZBTFVFIiwiJGFzaW5oIiwiYXNpbmgiLCIkYXRhbmgiLCJhdGFuaCIsImNicnQiLCJjbHozMiIsIkxPRzJFIiwiY29zaCIsImh5cG90IiwidmFsdWUxIiwidmFsdWUyIiwibGFyZyIsImRpdiIsIiRpbXVsIiwiaW11bCIsIlVJTlQxNiIsInhuIiwieW4iLCJ4bCIsInlsIiwibG9nMTAiLCJMT0cxMEUiLCJsb2cyIiwic2luaCIsIkUiLCJ0YW5oIiwidHJ1bmMiLCIkTnVtYmVyIiwiQlJPS0VOX0NPRiIsIlRSSU0iLCJ0b051bWJlciIsImFyZ3VtZW50IiwidGhpcmQiLCJtYXhDb2RlIiwiZGlnaXRzIiwiY29kZSIsIl9pc0Zpbml0ZSIsImlzU2FmZUludGVnZXIiLCJNQVhfU0FGRV9JTlRFR0VSIiwiTUlOX1NBRkVfSU5URUdFUiIsImFOdW1iZXJWYWx1ZSIsIiR0b0ZpeGVkIiwidG9GaXhlZCIsIkVSUk9SIiwiWkVSTyIsImMyIiwibnVtVG9TdHJpbmciLCJ0IiwiYWNjIiwiZnJhY3Rpb25EaWdpdHMiLCJ6IiwiJGZhaWxzIiwiJHRvUHJlY2lzaW9uIiwidG9QcmVjaXNpb24iLCJwcmVjaXNpb24iLCIkZnJlZXplIiwiZnJlZXplIiwiJGdldE93blByb3BlcnR5RGVzY3JpcHRvciIsIiRnZXRQcm90b3R5cGVPZiIsIiRpc0V4dGVuc2libGUiLCIkaXNGcm96ZW4iLCJpc0Zyb3plbiIsIiRpc1NlYWxlZCIsImlzU2VhbGVkIiwiJHByZXZlbnRFeHRlbnNpb25zIiwiJHNlYWwiLCJzZWFsIiwibWljcm90YXNrIiwibmV3UHJvbWlzZUNhcGFiaWxpdHlNb2R1bGUiLCJwZXJmb3JtIiwicHJvbWlzZVJlc29sdmUiLCJQUk9NSVNFIiwiJFByb21pc2UiLCJJbnRlcm5hbCIsIm5ld0dlbmVyaWNQcm9taXNlQ2FwYWJpbGl0eSIsIk93blByb21pc2VDYXBhYmlsaXR5IiwiV3JhcHBlciIsIlVTRV9OQVRJVkUiLCJGYWtlUHJvbWlzZSIsIlByb21pc2VSZWplY3Rpb25FdmVudCIsImlzVGhlbmFibGUiLCJpc1JlamVjdCIsIl9uIiwiY2hhaW4iLCJfYyIsIl92Iiwib2siLCJfcyIsInJlYWN0aW9uIiwiaGFuZGxlciIsImZhaWwiLCJfaCIsIm9uSGFuZGxlVW5oYW5kbGVkIiwib25VbmhhbmRsZWQiLCJ1bmhhbmRsZWQiLCJpc1VuaGFuZGxlZCIsImNvbnNvbGUiLCJlbWl0Iiwib251bmhhbmRsZWRyZWplY3Rpb24iLCJyZWFzb24iLCJlcnJvciIsIl9hIiwib25yZWplY3Rpb25oYW5kbGVkIiwiJHJlamVjdCIsIl93IiwiJHJlc29sdmUiLCJleGVjdXRvciIsIm9uRnVsZmlsbGVkIiwib25SZWplY3RlZCIsImNhcGFiaWxpdHkiLCJhbGwiLCJyZW1haW5pbmciLCIkaW5kZXgiLCJhbHJlYWR5Q2FsbGVkIiwicmFjZSIsInJBcHBseSIsImZBcHBseSIsInRoaXNBcmd1bWVudCIsImFyZ3VtZW50c0xpc3QiLCJMIiwickNvbnN0cnVjdCIsIk5FV19UQVJHRVRfQlVHIiwiQVJHU19CVUciLCJUYXJnZXQiLCJuZXdUYXJnZXQiLCIkYXJncyIsInByb3BlcnR5S2V5IiwiYXR0cmlidXRlcyIsImRlbGV0ZVByb3BlcnR5IiwiRW51bWVyYXRlIiwiZW51bWVyYXRlIiwiZ2V0UHJvdG8iLCJyZWNlaXZlciIsInNldFByb3RvIiwiViIsIm93bkRlc2MiLCJleGlzdGluZ0Rlc2NyaXB0b3IiLCIkZmxhZ3MiLCIkUmVnRXhwIiwicmUxIiwicmUyIiwiQ09SUkVDVF9ORVciLCJ0aVJFIiwicGlSRSIsImZpVSIsInByb3h5IiwiZmxhZ3MiLCIkbWF0Y2giLCJyZWdleHAiLCJSRVBMQUNFIiwiJHJlcGxhY2UiLCJzZWFyY2hWYWx1ZSIsInJlcGxhY2VWYWx1ZSIsIlNFQVJDSCIsIiRzZWFyY2giLCJzZWFyY2giLCJTUExJVCIsIiRzcGxpdCIsIl9zcGxpdCIsIiRwdXNoIiwiJFNQTElUIiwiTEVOR1RIIiwiTEFTVF9JTkRFWCIsIk5QQ0ciLCJsaW1pdCIsIm91dHB1dCIsImxhc3RMYXN0SW5kZXgiLCJzcGxpdExpbWl0Iiwic2VwYXJhdG9yQ29weSIsInNlcGFyYXRvcjIiLCJsYXN0SW5kZXgiLCJsYXN0TGVuZ3RoIiwiZGVmaW5lIiwiU0VUIiwiYW5jaG9yIiwiYmlnIiwiYmxpbmsiLCJib2xkIiwiJGF0IiwiY29kZVBvaW50QXQiLCJFTkRTX1dJVEgiLCIkZW5kc1dpdGgiLCJlbmRzV2l0aCIsImVuZFBvc2l0aW9uIiwiZml4ZWQiLCJmb250Y29sb3IiLCJjb2xvciIsImZvbnRzaXplIiwiZnJvbUNoYXJDb2RlIiwiJGZyb21Db2RlUG9pbnQiLCJmcm9tQ29kZVBvaW50IiwiSU5DTFVERVMiLCJpdGFsaWNzIiwibGluayIsInVybCIsInJhdyIsImNhbGxTaXRlIiwidHBsIiwic21hbGwiLCJTVEFSVFNfV0lUSCIsIiRzdGFydHNXaXRoIiwic3RhcnRzV2l0aCIsInN0cmlrZSIsInN1YiIsInN1cCIsIndrc0RlZmluZSIsImVudW1LZXlzIiwiX2NyZWF0ZSIsImdPUE5FeHQiLCIkSlNPTiIsIkpTT04iLCJfc3RyaW5naWZ5Iiwic3RyaW5naWZ5IiwiSElEREVOIiwiU3ltYm9sUmVnaXN0cnkiLCJBbGxTeW1ib2xzIiwiT1BTeW1ib2xzIiwiUU9iamVjdCIsImZpbmRDaGlsZCIsInNldFN5bWJvbERlc2MiLCJwcm90b0Rlc2MiLCJ3cmFwIiwic3ltIiwiaXNTeW1ib2wiLCIkZGVmaW5lUHJvcGVydGllcyIsIiRwcm9wZXJ0eUlzRW51bWVyYWJsZSIsIiRnZXRPd25Qcm9wZXJ0eU5hbWVzIiwiJGdldE93blByb3BlcnR5U3ltYm9scyIsIklTX09QIiwiZXM2U3ltYm9scyIsIndlbGxLbm93blN5bWJvbHMiLCJrZXlGb3IiLCJ1c2VTZXR0ZXIiLCJ1c2VTaW1wbGUiLCJyZXBsYWNlciIsIiRyZXBsYWNlciIsIiRpc1ZpZXciLCJpc1ZpZXciLCJmaW5hbCIsInZpZXdTIiwidmlld1QiLCJpbml0IiwiRmxvYXQzMkFycmF5IiwiRmxvYXQ2NEFycmF5IiwiSW50MTZBcnJheSIsIkludDMyQXJyYXkiLCJJbnQ4QXJyYXkiLCJVaW50MzJBcnJheSIsIlVpbnQ4Q2xhbXBlZEFycmF5IiwiZWFjaCIsIndlYWsiLCJXRUFLX01BUCIsInRtcCIsIkludGVybmFsTWFwIiwiV2Vha01hcCIsIiRXZWFrTWFwIiwiV0VBS19TRVQiLCJXZWFrU2V0IiwiYXJyYXlTcGVjaWVzQ3JlYXRlIiwiZmxhdHRlbiIsImRlcHRoQXJnIiwiJGluY2x1ZGVzIiwiYXNhcCIsImlzRXJyb3IiLCJjbGFtcCIsImxvd2VyIiwidXBwZXIiLCJERUdfUEVSX1JBRCIsIlJBRF9QRVJfREVHIiwiZGVncmVlcyIsInJhZGlhbnMiLCJmc2NhbGUiLCJpYWRkaCIsIngwIiwieTAiLCIkeDAiLCIkeDEiLCIkeTAiLCJpbXVsaCIsInUiLCIkdSIsIiR2IiwidTAiLCJ2MCIsImlzdWJoIiwic2lnbmJpdCIsInVtdWxoIiwiX19kZWZpbmVHZXR0ZXJfXyIsImdldE93blByb3BlcnR5RGVzY3JpcHRvcnMiLCJnZXREZXNjIiwiX19sb29rdXBHZXR0ZXJfXyIsIl9fbG9va3VwU2V0dGVyX18iLCIkdmFsdWVzIiwiT0JTRVJWQUJMRSIsImNsZWFudXBTdWJzY3JpcHRpb24iLCJzdWJzY3JpcHRpb24iLCJjbGVhbnVwIiwic3Vic2NyaXB0aW9uQ2xvc2VkIiwiX28iLCJjbG9zZVN1YnNjcmlwdGlvbiIsIlN1YnNjcmlwdGlvbiIsIm9ic2VydmVyIiwic3Vic2NyaWJlciIsIlN1YnNjcmlwdGlvbk9ic2VydmVyIiwidW5zdWJzY3JpYmUiLCJjb21wbGV0ZSIsIiRPYnNlcnZhYmxlIiwiT2JzZXJ2YWJsZSIsInN1YnNjcmliZSIsIm9ic2VydmFibGUiLCJpdGVtcyIsIm9uRmluYWxseSIsIm1ldGFkYXRhIiwiZGVmaW5lTWV0YWRhdGEiLCJtZXRhZGF0YUtleSIsIm1ldGFkYXRhVmFsdWUiLCJkZWxldGVNZXRhZGF0YSIsIm9yZGluYXJ5TWV0YWRhdGFLZXlzIiwib0tleXMiLCJwS2V5cyIsImdldE1ldGFkYXRhS2V5cyIsIm9yZGluYXJ5R2V0TWV0YWRhdGEiLCJoYXNPd24iLCJnZXRNZXRhZGF0YSIsImdldE93bk1ldGFkYXRhS2V5cyIsImdldE93bk1ldGFkYXRhIiwib3JkaW5hcnlIYXNNZXRhZGF0YSIsImhhc01ldGFkYXRhIiwiaGFzT3duTWV0YWRhdGEiLCIkbWV0YWRhdGEiLCJkZWNvcmF0b3IiLCJhdCIsImdldEZsYWdzIiwiUmVnRXhwUHJvdG8iLCIkUmVnRXhwU3RyaW5nSXRlcmF0b3IiLCJfciIsIm1hdGNoQWxsIiwicngiLCIkcGFkIiwicGFkRW5kIiwicGFkU3RhcnQiLCJ0cmltTGVmdCIsInRyaW1SaWdodCIsIlRPX1NUUklOR19UQUciLCJBcnJheVZhbHVlcyIsIkRPTUl0ZXJhYmxlcyIsIkNTU1J1bGVMaXN0IiwiQ1NTU3R5bGVEZWNsYXJhdGlvbiIsIkNTU1ZhbHVlTGlzdCIsIkNsaWVudFJlY3RMaXN0IiwiRE9NUmVjdExpc3QiLCJET01TdHJpbmdMaXN0IiwiRE9NVG9rZW5MaXN0IiwiRGF0YVRyYW5zZmVySXRlbUxpc3QiLCJGaWxlTGlzdCIsIkhUTUxBbGxDb2xsZWN0aW9uIiwiSFRNTENvbGxlY3Rpb24iLCJIVE1MRm9ybUVsZW1lbnQiLCJIVE1MU2VsZWN0RWxlbWVudCIsIk1lZGlhTGlzdCIsIk1pbWVUeXBlQXJyYXkiLCJOYW1lZE5vZGVNYXAiLCJOb2RlTGlzdCIsIlBhaW50UmVxdWVzdExpc3QiLCJQbHVnaW4iLCJQbHVnaW5BcnJheSIsIlNWR0xlbmd0aExpc3QiLCJTVkdOdW1iZXJMaXN0IiwiU1ZHUGF0aFNlZ0xpc3QiLCJTVkdQb2ludExpc3QiLCJTVkdTdHJpbmdMaXN0IiwiU1ZHVHJhbnNmb3JtTGlzdCIsIlNvdXJjZUJ1ZmZlckxpc3QiLCJTdHlsZVNoZWV0TGlzdCIsIlRleHRUcmFja0N1ZUxpc3QiLCJUZXh0VHJhY2tMaXN0IiwiVG91Y2hMaXN0IiwiY29sbGVjdGlvbnMiLCJleHBsaWNpdCIsIkNvbGxlY3Rpb24iLCIkdGFzayIsIm5hdmlnYXRvciIsIk1TSUUiLCJ1c2VyQWdlbnQiLCJ0aW1lIiwiYm91bmRBcmdzIiwic2V0SW50ZXJ2YWwiLCJtYWtlRW1wdHlGdW5jdGlvbiIsImVtcHR5RnVuY3Rpb24iLCJ0aGF0UmV0dXJucyIsInRoYXRSZXR1cm5zRmFsc2UiLCJ0aGF0UmV0dXJuc1RydWUiLCJ0aGF0UmV0dXJuc051bGwiLCJ0aGF0UmV0dXJuc1RoaXMiLCJ0aGF0UmV0dXJuc0FyZ3VtZW50IiwiZW1wdHlPYmplY3QiLCJOT0RFX0VOViIsInZhbGlkYXRlRm9ybWF0IiwiZm9ybWF0IiwiaW52YXJpYW50IiwiY29uZGl0aW9uIiwiYXJnSW5kZXgiLCJmcmFtZXNUb1BvcCIsInNoYWxsb3dFcXVhbCIsIm9iakEiLCJvYmpCIiwia2V5c0EiLCJrZXlzQiIsIndhcm5pbmciLCJwcmludFdhcm5pbmciLCJfbGVuIiwiX2tleSIsIm1lc3NhZ2UiLCJfbGVuMiIsIl9rZXkyIiwiSG93bGVyR2xvYmFsIiwiSG93bGVyIiwiX2NvdW50ZXIiLCJfY29kZWNzIiwiX2hvd2xzIiwiX211dGVkIiwiX3ZvbHVtZSIsIl9jYW5QbGF5RXZlbnQiLCJfbmF2aWdhdG9yIiwibWFzdGVyR2FpbiIsIm5vQXVkaW8iLCJ1c2luZ1dlYkF1ZGlvIiwiYXV0b1N1c3BlbmQiLCJtb2JpbGVBdXRvRW5hYmxlIiwiX3NldHVwIiwidm9sdW1lIiwidm9sIiwic2V0dXBBdWRpb0NvbnRleHQiLCJnYWluIiwiX3dlYkF1ZGlvIiwiaWRzIiwiX2dldFNvdW5kSWRzIiwic291bmQiLCJfc291bmRCeUlkIiwiX25vZGUiLCJtdXRlIiwibXV0ZWQiLCJ1bmxvYWQiLCJjb2RlY3MiLCJleHQiLCJfYXV0b1N1c3BlbmQiLCJBdWRpbyIsIm9uY2FucGxheXRocm91Z2giLCJfc2V0dXBDb2RlY3MiLCJhdWRpb1Rlc3QiLCJjYW5QbGF5VHlwZSIsIm1wZWdUZXN0IiwiY2hlY2tPcGVyYSIsImlzT2xkT3BlcmEiLCJtcDMiLCJtcGVnIiwib3B1cyIsIm9nZyIsIm9nYSIsIndhdiIsImFhYyIsImNhZiIsIm00YSIsIm1wNCIsIndlYmEiLCJ3ZWJtIiwiZG9sYnkiLCJmbGFjIiwiX2VuYWJsZU1vYmlsZUF1ZGlvIiwiaXNNb2JpbGUiLCJpc1RvdWNoIiwibWF4VG91Y2hQb2ludHMiLCJtc01heFRvdWNoUG9pbnRzIiwiX21vYmlsZUVuYWJsZWQiLCJfbW9iaWxlVW5sb2FkZWQiLCJzYW1wbGVSYXRlIiwiX3NjcmF0Y2hCdWZmZXIiLCJjcmVhdGVCdWZmZXIiLCJ1bmxvY2siLCJfYXV0b1Jlc3VtZSIsImNyZWF0ZUJ1ZmZlclNvdXJjZSIsImNvbm5lY3QiLCJkZXN0aW5hdGlvbiIsIm5vdGVPbiIsInJlc3VtZSIsIm9uZW5kZWQiLCJkaXNjb25uZWN0IiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsInN1c3BlbmQiLCJfc291bmRzIiwiX3BhdXNlZCIsIl9zdXNwZW5kVGltZXIiLCJjbGVhclRpbWVvdXQiLCJfcmVzdW1lQWZ0ZXJTdXNwZW5kIiwiX2VtaXQiLCJfYXV0b3BsYXkiLCJhdXRvcGxheSIsIl9mb3JtYXQiLCJfaHRtbDUiLCJfbG9vcCIsImxvb3AiLCJfcG9vbCIsInBvb2wiLCJfcHJlbG9hZCIsInByZWxvYWQiLCJfcmF0ZSIsInJhdGUiLCJfc3ByaXRlIiwic3ByaXRlIiwiX3NyYyIsIl94aHJXaXRoQ3JlZGVudGlhbHMiLCJ4aHJXaXRoQ3JlZGVudGlhbHMiLCJfZHVyYXRpb24iLCJfc3RhdGUiLCJfZW5kVGltZXJzIiwiX3F1ZXVlIiwiX29uZW5kIiwib25lbmQiLCJfb25mYWRlIiwib25mYWRlIiwiX29ubG9hZCIsIl9vbmxvYWRlcnJvciIsIm9ubG9hZGVycm9yIiwiX29ucGxheWVycm9yIiwib25wbGF5ZXJyb3IiLCJfb25wYXVzZSIsIm9ucGF1c2UiLCJfb25wbGF5Iiwib25wbGF5IiwiX29uc3RvcCIsIm9uc3RvcCIsIl9vbm11dGUiLCJvbm11dGUiLCJfb252b2x1bWUiLCJvbnZvbHVtZSIsIl9vbnJhdGUiLCJvbnJhdGUiLCJfb25zZWVrIiwib25zZWVrIiwiX29ucmVzdW1lIiwiYWN0aW9uIiwicGxheSIsIndhcm4iLCJsb2NhdGlvbiIsInByb3RvY29sIiwiU291bmQiLCJsb2FkQnVmZmVyIiwiX2VuZGVkIiwiX2lkIiwiX2luYWN0aXZlU291bmQiLCJzb3VuZElkIiwic2VlayIsIl9zZWVrIiwiZHVyYXRpb24iLCJ0aW1lb3V0IiwiX3N0YXJ0IiwiX3N0b3AiLCJwbGF5V2ViQXVkaW8iLCJfcmVmcmVzaEJ1ZmZlciIsInNldFZhbHVlQXRUaW1lIiwiY3VycmVudFRpbWUiLCJfcGxheVN0YXJ0IiwiYnVmZmVyU291cmNlIiwibm90ZUdyYWluT24iLCJfY2xlYXJUaW1lciIsInBsYXlIdG1sNSIsInBsYXliYWNrUmF0ZSIsInBhdXNlZCIsImxvYWRlZE5vUmVhZHlTdGF0ZSIsImVqZWN0YSIsInJlYWR5U3RhdGUiLCJpc0NvY29vbkpTIiwicGF1c2UiLCJfcmF0ZVNlZWsiLCJfc3RvcEZhZGUiLCJzdG9wIiwibm90ZU9mZiIsIl9jbGVhbkJ1ZmZlciIsImZhZGUiLCJsaW5lYXJSYW1wVG9WYWx1ZUF0VGltZSIsIl9zdGFydEZhZGVJbnRlcnZhbCIsImRpciIsImRpZmYiLCJzdGVwcyIsInN0ZXBMZW4iLCJfaW50ZXJ2YWwiLCJjbGVhckludGVydmFsIiwiY2FuY2VsU2NoZWR1bGVkVmFsdWVzIiwibG9vcFN0YXJ0IiwibG9vcEVuZCIsInBsYXlpbmciLCJyZWFsVGltZSIsInJhdGVTZWVrIiwic291bmRzIiwiY2hlY2tJRSIsIl9lcnJvckZuIiwiX2xvYWRGbiIsInJlbUNhY2hlIiwiY2FjaGUiLCJvbiIsImV2ZW50cyIsIm9mZiIsImlzSWQiLCJfbG9hZFF1ZXVlIiwic2hpZnQiLCJfZHJhaW4iLCJyZXNldCIsImNudCIsIl9wYW5uZXIiLCJfcGFyZW50IiwiY3JlYXRlR2FpbiIsImNyZWF0ZUdhaW5Ob2RlIiwiX2Vycm9yTGlzdGVuZXIiLCJfbG9hZExpc3RlbmVyIiwiX19kZWZhdWx0IiwibG9hZFNvdW5kIiwiYXRvYiIsImRhdGFWaWV3IiwiZGVjb2RlQXVkaW9EYXRhIiwieGhyIiwiWE1MSHR0cFJlcXVlc3QiLCJ3aXRoQ3JlZGVudGlhbHMiLCJyZXNwb25zZVR5cGUiLCJyZXNwb25zZSIsInNhZmVYaHJTZW5kIiwic2VuZCIsImFycmF5YnVmZmVyIiwiQXVkaW9Db250ZXh0Iiwid2Via2l0QXVkaW9Db250ZXh0IiwiaU9TIiwicGxhdGZvcm0iLCJhcHBWZXJzaW9uIiwic2FmYXJpIiwic3RhbmRhbG9uZSIsIl9wb3MiLCJfb3JpZW50YXRpb24iLCJzdGVyZW8iLCJwYW4iLCJzZXRQb3NpdGlvbiIsIm9yaWVudGF0aW9uIiwieFVwIiwieVVwIiwielVwIiwib3IiLCJzZXRPcmllbnRhdGlvbiIsIl9zdXBlciIsIl9zdGVyZW8iLCJfcGFubmVyQXR0ciIsImNvbmVJbm5lckFuZ2xlIiwiY29uZU91dGVyQW5nbGUiLCJjb25lT3V0ZXJHYWluIiwiZGlzdGFuY2VNb2RlbCIsIm1heERpc3RhbmNlIiwicGFubmluZ01vZGVsIiwicmVmRGlzdGFuY2UiLCJyb2xsb2ZmRmFjdG9yIiwiX29uc3RlcmVvIiwib25zdGVyZW8iLCJfb25wb3MiLCJvbnBvcyIsIl9vbm9yaWVudGF0aW9uIiwib25vcmllbnRhdGlvbiIsInBhbm5lclR5cGUiLCJjcmVhdGVTdGVyZW9QYW5uZXIiLCJzZXR1cFBhbm5lciIsInBhbm5lckF0dHIiLCJfY29uZUlubmVyQW5nbGUiLCJfY29uZU91dGVyQW5nbGUiLCJfY29uZU91dGVyR2FpbiIsIl9kaXN0YW5jZU1vZGVsIiwiX21heERpc3RhbmNlIiwiX3JlZkRpc3RhbmNlIiwiX3JvbGxvZmZGYWN0b3IiLCJfcGFubmluZ01vZGVsIiwicGEiLCJwYW5uZXIiLCJjcmVhdGVQYW5uZXIiLCJwcm9wSXNFbnVtZXJhYmxlIiwic2hvdWxkVXNlTmF0aXZlIiwidGVzdDEiLCJ0ZXN0MiIsIm9yZGVyMiIsInRlc3QzIiwibGV0dGVyIiwiY2FjaGVkU2V0VGltZW91dCIsImNhY2hlZENsZWFyVGltZW91dCIsImRlZmF1bHRTZXRUaW1vdXQiLCJkZWZhdWx0Q2xlYXJUaW1lb3V0IiwicnVuVGltZW91dCIsImZ1biIsInJ1bkNsZWFyVGltZW91dCIsIm1hcmtlciIsImRyYWluaW5nIiwiY3VycmVudFF1ZXVlIiwicXVldWVJbmRleCIsImNsZWFuVXBOZXh0VGljayIsImRyYWluUXVldWUiLCJJdGVtIiwiYXJyYXkiLCJ0aXRsZSIsImJyb3dzZXIiLCJhcmd2IiwidmVyc2lvbnMiLCJub29wIiwiYWRkTGlzdGVuZXIiLCJyZW1vdmVMaXN0ZW5lciIsInJlbW92ZUFsbExpc3RlbmVycyIsInByZXBlbmRMaXN0ZW5lciIsInByZXBlbmRPbmNlTGlzdGVuZXIiLCJsaXN0ZW5lcnMiLCJiaW5kaW5nIiwiY3dkIiwiY2hkaXIiLCJ1bWFzayIsIlJlYWN0UHJvcFR5cGVzU2VjcmV0IiwibG9nZ2VkVHlwZUZhaWx1cmVzIiwiY2hlY2tQcm9wVHlwZXMiLCJ0eXBlU3BlY3MiLCJjb21wb25lbnROYW1lIiwiZ2V0U3RhY2siLCJ0eXBlU3BlY05hbWUiLCJleCIsInN0YWNrIiwiX2Fzc2lnbiIsIlJlYWN0IiwiZW5hYmxlQXN5bmNTdWJ0cmVlQVBJIiwiZW5hYmxlVXNlclRpbWluZ0FQSSIsImVuYWJsZU11dGF0aW5nUmVjb25jaWxlciIsImVuYWJsZU5vb3BSZWNvbmNpbGVyIiwiZW5hYmxlUGVyc2lzdGVudFJlY29uY2lsZXIiLCJkZWJ1Z1JlbmRlclBoYXNlU2lkZUVmZmVjdHMiLCJfcmVhY3RJbnRlcm5hbEZpYmVyIiwiUmVhY3RJbnRlcm5hbHMiLCJfX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRCIsIlJlYWN0Q3VycmVudE93bmVyIiwiUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSIsImdldENvbXBvbmVudE5hbWUiLCJmaWJlciIsImRpc3BsYXlOYW1lIiwiSW5kZXRlcm1pbmF0ZUNvbXBvbmVudCIsIkZ1bmN0aW9uYWxDb21wb25lbnQiLCJDbGFzc0NvbXBvbmVudCIsIkhvc3RSb290IiwiSG9zdFBvcnRhbCIsIkhvc3RDb21wb25lbnQiLCJIb3N0VGV4dCIsIkNhbGxDb21wb25lbnQiLCJDYWxsSGFuZGxlclBoYXNlIiwiUmV0dXJuQ29tcG9uZW50IiwiRnJhZ21lbnQiLCJOb0VmZmVjdCIsIlBlcmZvcm1lZFdvcmsiLCJQbGFjZW1lbnQiLCJVcGRhdGUiLCJQbGFjZW1lbnRBbmRVcGRhdGUiLCJEZWxldGlvbiIsIkNvbnRlbnRSZXNldCIsIkNhbGxiYWNrIiwiRXJyIiwiUmVmIiwiTU9VTlRJTkciLCJNT1VOVEVEIiwiVU5NT1VOVEVEIiwiaXNGaWJlck1vdW50ZWRJbXBsIiwiYWx0ZXJuYXRlIiwiZWZmZWN0VGFnIiwiaXNGaWJlck1vdW50ZWQiLCJpc01vdW50ZWQiLCJjb21wb25lbnQiLCJvd25lciIsImN1cnJlbnQiLCJvd25lckZpYmVyIiwic3RhdGVOb2RlIiwiX3dhcm5lZEFib3V0UmVmc0luUmVuZGVyIiwiYXNzZXJ0SXNNb3VudGVkIiwiZmluZEN1cnJlbnRGaWJlclVzaW5nU2xvd1BhdGgiLCJwYXJlbnRBIiwicGFyZW50QiIsInNpYmxpbmciLCJkaWRGaW5kQ2hpbGQiLCJfY2hpbGQiLCJmaW5kQ3VycmVudEhvc3RGaWJlciIsImN1cnJlbnRQYXJlbnQiLCJmaW5kQ3VycmVudEhvc3RGaWJlcldpdGhOb1BvcnRhbHMiLCJ2YWx1ZVN0YWNrIiwiZmliZXJTdGFjayIsImNyZWF0ZUN1cnNvciIsImRlZmF1bHRWYWx1ZSIsInBvcCIsImN1cnNvciIsImRlc2NyaWJlQ29tcG9uZW50RnJhbWUiLCJvd25lck5hbWUiLCJmaWxlTmFtZSIsImxpbmVOdW1iZXIiLCJkZXNjcmliZUZpYmVyIiwiX2RlYnVnT3duZXIiLCJfZGVidWdTb3VyY2UiLCJnZXRTdGFja0FkZGVuZHVtQnlXb3JrSW5Qcm9ncmVzc0ZpYmVyIiwid29ya0luUHJvZ3Jlc3MiLCJpbmZvIiwiZ2V0Q3VycmVudEZpYmVyT3duZXJOYW1lIiwiUmVhY3REZWJ1Z0N1cnJlbnRGaWJlciIsImdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW0iLCJyZXNldEN1cnJlbnRGaWJlciIsImdldEN1cnJlbnRTdGFjayIsInBoYXNlIiwic2V0Q3VycmVudEZpYmVyIiwic2V0Q3VycmVudFBoYXNlIiwicmVhY3RFbW9qaSIsIndhcm5pbmdFbW9qaSIsInN1cHBvcnRzVXNlclRpbWluZyIsInBlcmZvcm1hbmNlIiwibWFyayIsImNsZWFyTWFya3MiLCJtZWFzdXJlIiwiY2xlYXJNZWFzdXJlcyIsImN1cnJlbnRGaWJlciIsImN1cnJlbnRQaGFzZSIsImN1cnJlbnRQaGFzZUZpYmVyIiwiaXNDb21taXR0aW5nIiwiaGFzU2NoZWR1bGVkVXBkYXRlSW5DdXJyZW50Q29tbWl0IiwiaGFzU2NoZWR1bGVkVXBkYXRlSW5DdXJyZW50UGhhc2UiLCJjb21taXRDb3VudEluQ3VycmVudFdvcmtMb29wIiwiZWZmZWN0Q291bnRJbkN1cnJlbnRDb21taXQiLCJpc1dhaXRpbmdGb3JDYWxsYmFjayIsImxhYmVsc0luQ3VycmVudENvbW1pdCIsImZvcm1hdE1hcmtOYW1lIiwibWFya05hbWUiLCJmb3JtYXRMYWJlbCIsImxhYmVsIiwid2FybmluZyQkMSIsInByZWZpeCIsInN1ZmZpeCIsImJlZ2luTWFyayIsImNsZWFyTWFyayIsImVuZE1hcmsiLCJmb3JtYXR0ZWRNYXJrTmFtZSIsImZvcm1hdHRlZExhYmVsIiwiZ2V0RmliZXJNYXJrTmFtZSIsImRlYnVnSUQiLCJnZXRGaWJlckxhYmVsIiwiYmVnaW5GaWJlck1hcmsiLCJfZGVidWdJRCIsImNsZWFyRmliZXJNYXJrIiwiZW5kRmliZXJNYXJrIiwic2hvdWxkSWdub3JlRmliZXIiLCJjbGVhclBlbmRpbmdQaGFzZU1lYXN1cmVtZW50IiwicGF1c2VUaW1lcnMiLCJfZGVidWdJc0N1cnJlbnRseVRpbWluZyIsInJlc3VtZVRpbWVyc1JlY3Vyc2l2ZWx5IiwicmVzdW1lVGltZXJzIiwicmVjb3JkRWZmZWN0IiwicmVjb3JkU2NoZWR1bGVVcGRhdGUiLCJzdGFydFJlcXVlc3RDYWxsYmFja1RpbWVyIiwic3RvcFJlcXVlc3RDYWxsYmFja1RpbWVyIiwiZGlkRXhwaXJlIiwic3RhcnRXb3JrVGltZXIiLCJjYW5jZWxXb3JrVGltZXIiLCJzdG9wV29ya1RpbWVyIiwic3RvcEZhaWxlZFdvcmtUaW1lciIsInN0YXJ0UGhhc2VUaW1lciIsInN0b3BQaGFzZVRpbWVyIiwic3RhcnRXb3JrTG9vcFRpbWVyIiwibmV4dFVuaXRPZldvcmsiLCJzdG9wV29ya0xvb3BUaW1lciIsImludGVycnVwdGVkQnkiLCJzdGFydENvbW1pdFRpbWVyIiwic3RvcENvbW1pdFRpbWVyIiwic3RhcnRDb21taXRIb3N0RWZmZWN0c1RpbWVyIiwic3RvcENvbW1pdEhvc3RFZmZlY3RzVGltZXIiLCJzdGFydENvbW1pdExpZmVDeWNsZXNUaW1lciIsInN0b3BDb21taXRMaWZlQ3ljbGVzVGltZXIiLCJ3YXJuZWRBYm91dE1pc3NpbmdHZXRDaGlsZENvbnRleHQiLCJjb250ZXh0U3RhY2tDdXJzb3IiLCJkaWRQZXJmb3JtV29ya1N0YWNrQ3Vyc29yIiwicHJldmlvdXNDb250ZXh0IiwiZ2V0VW5tYXNrZWRDb250ZXh0IiwiaGFzT3duQ29udGV4dCIsImlzQ29udGV4dFByb3ZpZGVyIiwiY2FjaGVDb250ZXh0IiwidW5tYXNrZWRDb250ZXh0IiwibWFza2VkQ29udGV4dCIsIl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkVW5tYXNrZWRDaGlsZENvbnRleHQiLCJfX3JlYWN0SW50ZXJuYWxNZW1vaXplZE1hc2tlZENoaWxkQ29udGV4dCIsImdldE1hc2tlZENvbnRleHQiLCJjb250ZXh0VHlwZXMiLCJoYXNDb250ZXh0Q2hhbmdlZCIsImlzQ29udGV4dENvbnN1bWVyIiwiY2hpbGRDb250ZXh0VHlwZXMiLCJwb3BDb250ZXh0UHJvdmlkZXIiLCJwb3BUb3BMZXZlbENvbnRleHRPYmplY3QiLCJwdXNoVG9wTGV2ZWxDb250ZXh0T2JqZWN0IiwiZGlkQ2hhbmdlIiwicHJvY2Vzc0NoaWxkQ29udGV4dCIsInBhcmVudENvbnRleHQiLCJnZXRDaGlsZENvbnRleHQiLCJjaGlsZENvbnRleHQiLCJjb250ZXh0S2V5IiwicHVzaENvbnRleHRQcm92aWRlciIsIm1lbW9pemVkTWVyZ2VkQ2hpbGRDb250ZXh0IiwiX19yZWFjdEludGVybmFsTWVtb2l6ZWRNZXJnZWRDaGlsZENvbnRleHQiLCJpbnZhbGlkYXRlQ29udGV4dFByb3ZpZGVyIiwibWVyZ2VkQ29udGV4dCIsInJlc2V0Q29udGV4dCIsImZpbmRDdXJyZW50VW5tYXNrZWRDb250ZXh0IiwiTm9Xb3JrIiwiU3luYyIsIk5ldmVyIiwiVU5JVF9TSVpFIiwiTUFHSUNfTlVNQkVSX09GRlNFVCIsIm1zVG9FeHBpcmF0aW9uVGltZSIsIm1zIiwiZXhwaXJhdGlvblRpbWVUb01zIiwiZXhwaXJhdGlvblRpbWUiLCJjZWlsaW5nIiwiY29tcHV0ZUV4cGlyYXRpb25CdWNrZXQiLCJleHBpcmF0aW9uSW5NcyIsImJ1Y2tldFNpemVNcyIsIk5vQ29udGV4dCIsIkFzeW5jVXBkYXRlcyIsImhhc0JhZE1hcFBvbHlmaWxsIiwibm9uRXh0ZW5zaWJsZU9iamVjdCIsImRlYnVnQ291bnRlciIsIkZpYmVyTm9kZSIsImludGVybmFsQ29udGV4dFRhZyIsInJlZiIsInBlbmRpbmdQcm9wcyIsIm1lbW9pemVkUHJvcHMiLCJ1cGRhdGVRdWV1ZSIsIm1lbW9pemVkU3RhdGUiLCJuZXh0RWZmZWN0IiwiZmlyc3RFZmZlY3QiLCJsYXN0RWZmZWN0IiwiY3JlYXRlRmliZXIiLCJzaG91bGRDb25zdHJ1Y3QiLCJDb21wb25lbnQiLCJpc1JlYWN0Q29tcG9uZW50IiwiY3JlYXRlV29ya0luUHJvZ3Jlc3MiLCJjcmVhdGVIb3N0Um9vdEZpYmVyIiwiY3JlYXRlRmliZXJGcm9tRWxlbWVudCIsIl9vd25lciIsIl9zb3VyY2UiLCJjcmVhdGVGaWJlckZyb21GcmFnbWVudCIsImVsZW1lbnRzIiwiY3JlYXRlRmliZXJGcm9tVGV4dCIsImNvbnRlbnQiLCJjcmVhdGVGaWJlckZyb21Ib3N0SW5zdGFuY2VGb3JEZWxldGlvbiIsImNyZWF0ZUZpYmVyRnJvbUNhbGwiLCJjcmVhdGVGaWJlckZyb21SZXR1cm4iLCJyZXR1cm5Ob2RlIiwiY3JlYXRlRmliZXJGcm9tUG9ydGFsIiwicG9ydGFsIiwiY29udGFpbmVySW5mbyIsInBlbmRpbmdDaGlsZHJlbiIsImltcGxlbWVudGF0aW9uIiwiY3JlYXRlRmliZXJSb290IiwiaHlkcmF0ZSIsInVuaW5pdGlhbGl6ZWRGaWJlciIsInJvb3QiLCJyZW1haW5pbmdFeHBpcmF0aW9uVGltZSIsImlzUmVhZHlGb3JDb21taXQiLCJmaW5pc2hlZFdvcmsiLCJwZW5kaW5nQ29udGV4dCIsIm5leHRTY2hlZHVsZWRSb290Iiwib25Db21taXRGaWJlclJvb3QiLCJvbkNvbW1pdEZpYmVyVW5tb3VudCIsImhhc0xvZ2dlZEVycm9yIiwiY2F0Y2hFcnJvcnMiLCJpbmplY3RJbnRlcm5hbHMiLCJpbnRlcm5hbHMiLCJfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18iLCJob29rIiwiaXNEaXNhYmxlZCIsInN1cHBvcnRzRmliZXIiLCJyZW5kZXJlcklEIiwiaW5qZWN0Iiwib25Db21taXRSb290Iiwib25Db21taXRVbm1vdW50IiwiUmVhY3RFcnJvclV0aWxzIiwiX2NhdWdodEVycm9yIiwiX2hhc0NhdWdodEVycm9yIiwiX3JldGhyb3dFcnJvciIsIl9oYXNSZXRocm93RXJyb3IiLCJpbmplY3Rpb24iLCJpbmplY3RFcnJvclV0aWxzIiwiaW5qZWN0ZWRFcnJvclV0aWxzIiwiaW52b2tlR3VhcmRlZENhbGxiYWNrIiwiaW52b2tlR3VhcmRlZENhbGxiYWNrJDEiLCJpbnZva2VHdWFyZGVkQ2FsbGJhY2tBbmRDYXRjaEZpcnN0RXJyb3IiLCJoYXNDYXVnaHRFcnJvciIsImNsZWFyQ2F1Z2h0RXJyb3IiLCJyZXRocm93Q2F1Z2h0RXJyb3IiLCJmdW5jQXJncyIsImRpc3BhdGNoRXZlbnQiLCJjcmVhdGVFdmVudCIsImZha2VOb2RlIiwiaW52b2tlR3VhcmRlZENhbGxiYWNrRGV2IiwiZGlkRXJyb3IiLCJjYWxsQ2FsbGJhY2siLCJldnRUeXBlIiwiZGlkU2V0RXJyb3IiLCJpc0Nyb3NzT3JpZ2luRXJyb3IiLCJvbkVycm9yIiwiY29sbm8iLCJsaW5lbm8iLCJldnQiLCJpbml0RXZlbnQiLCJkaWRXYXJuVXBkYXRlSW5zaWRlVXBkYXRlIiwiY3JlYXRlVXBkYXRlUXVldWUiLCJiYXNlU3RhdGUiLCJjYWxsYmFja0xpc3QiLCJoYXNGb3JjZVVwZGF0ZSIsImlzSW5pdGlhbGl6ZWQiLCJpc1Byb2Nlc3NpbmciLCJpbnNlcnRVcGRhdGVJbnRvUXVldWUiLCJ1cGRhdGUiLCJpbnNlcnRVcGRhdGVJbnRvRmliZXIiLCJhbHRlcm5hdGVGaWJlciIsInF1ZXVlMSIsInF1ZXVlMiIsImdldFVwZGF0ZUV4cGlyYXRpb25UaW1lIiwiZ2V0U3RhdGVGcm9tVXBkYXRlIiwicGFydGlhbFN0YXRlIiwidXBkYXRlRm4iLCJwcm9jZXNzVXBkYXRlUXVldWUiLCJyZW5kZXJFeHBpcmF0aW9uVGltZSIsImRvbnRNdXRhdGVQcmV2U3RhdGUiLCJkaWRTa2lwIiwidXBkYXRlRXhwaXJhdGlvblRpbWUiLCJfcGFydGlhbFN0YXRlIiwiaXNSZXBsYWNlIiwiaXNGb3JjZWQiLCJjYWxsYmFjayIsIl9jYWxsYmFja0xpc3QiLCJjb21taXRDYWxsYmFja3MiLCJfY2FsbGJhY2siLCJmYWtlSW50ZXJuYWxJbnN0YW5jZSIsImRpZFdhcm5BYm91dFN0YXRlQXNzaWdubWVudEZvckNvbXBvbmVudCIsIndhcm5PbkludmFsaWRDYWxsYmFjayIsImNhbGxlck5hbWUiLCJSZWFjdEZpYmVyQ2xhc3NDb21wb25lbnQiLCJzY2hlZHVsZVdvcmsiLCJjb21wdXRlRXhwaXJhdGlvbkZvckZpYmVyIiwibWVtb2l6ZVByb3BzIiwibWVtb2l6ZVN0YXRlIiwidXBkYXRlciIsImVucXVldWVTZXRTdGF0ZSIsIm5leHRDYWxsYmFjayIsImVucXVldWVSZXBsYWNlU3RhdGUiLCJlbnF1ZXVlRm9yY2VVcGRhdGUiLCJjaGVja1Nob3VsZENvbXBvbmVudFVwZGF0ZSIsIm9sZFByb3BzIiwibmV3UHJvcHMiLCJvbGRTdGF0ZSIsIm5ld1N0YXRlIiwibmV3Q29udGV4dCIsInNob3VsZENvbXBvbmVudFVwZGF0ZSIsInNob3VsZFVwZGF0ZSIsImlzUHVyZVJlYWN0Q29tcG9uZW50IiwiY2hlY2tDbGFzc0luc3RhbmNlIiwicmVuZGVyUHJlc2VudCIsInJlbmRlciIsIm5vR2V0SW5pdGlhbFN0YXRlT25FUzYiLCJnZXRJbml0aWFsU3RhdGUiLCJpc1JlYWN0Q2xhc3NBcHByb3ZlZCIsIm5vR2V0RGVmYXVsdFByb3BzT25FUzYiLCJnZXREZWZhdWx0UHJvcHMiLCJub0luc3RhbmNlUHJvcFR5cGVzIiwicHJvcFR5cGVzIiwibm9JbnN0YW5jZUNvbnRleHRUeXBlcyIsIm5vQ29tcG9uZW50U2hvdWxkVXBkYXRlIiwiY29tcG9uZW50U2hvdWxkVXBkYXRlIiwibm9Db21wb25lbnREaWRVbm1vdW50IiwiY29tcG9uZW50RGlkVW5tb3VudCIsIm5vQ29tcG9uZW50RGlkUmVjZWl2ZVByb3BzIiwiY29tcG9uZW50RGlkUmVjZWl2ZVByb3BzIiwibm9Db21wb25lbnRXaWxsUmVjaWV2ZVByb3BzIiwiY29tcG9uZW50V2lsbFJlY2lldmVQcm9wcyIsImhhc011dGF0ZWRQcm9wcyIsIm5vSW5zdGFuY2VEZWZhdWx0UHJvcHMiLCJkZWZhdWx0UHJvcHMiLCJyZXNldElucHV0UG9pbnRlcnMiLCJhZG9wdENsYXNzSW5zdGFuY2UiLCJfcmVhY3RJbnRlcm5hbEluc3RhbmNlIiwiY29uc3RydWN0Q2xhc3NJbnN0YW5jZSIsImN0b3IiLCJuZWVkc0NvbnRleHQiLCJjYWxsQ29tcG9uZW50V2lsbE1vdW50IiwiY29tcG9uZW50V2lsbE1vdW50IiwiY2FsbENvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMiLCJjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzIiwibW91bnRDbGFzc0luc3RhbmNlIiwicmVmcyIsInVuc3RhYmxlX2lzQXN5bmNSZWFjdENvbXBvbmVudCIsImNvbXBvbmVudERpZE1vdW50IiwidXBkYXRlQ2xhc3NJbnN0YW5jZSIsIm9sZENvbnRleHQiLCJuZXdVbm1hc2tlZENvbnRleHQiLCJjb21wb25lbnREaWRVcGRhdGUiLCJjb21wb25lbnRXaWxsVXBkYXRlIiwiaGFzU3ltYm9sIiwiUkVBQ1RfRUxFTUVOVF9UWVBFIiwiUkVBQ1RfQ0FMTF9UWVBFIiwiUkVBQ1RfUkVUVVJOX1RZUEUiLCJSRUFDVF9QT1JUQUxfVFlQRSIsIlJFQUNUX0ZSQUdNRU5UX1RZUEUiLCJNQVlCRV9JVEVSQVRPUl9TWU1CT0wiLCJGQVVYX0lURVJBVE9SX1NZTUJPTCIsImdldEl0ZXJhdG9yRm4iLCJtYXliZUl0ZXJhYmxlIiwibWF5YmVJdGVyYXRvciIsImdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW0kMSIsImRpZFdhcm5BYm91dE1hcHMiLCJvd25lckhhc0tleVVzZVdhcm5pbmciLCJvd25lckhhc0Z1bmN0aW9uVHlwZVdhcm5pbmciLCJ3YXJuRm9yTWlzc2luZ0tleSIsIl9zdG9yZSIsInZhbGlkYXRlZCIsImN1cnJlbnRDb21wb25lbnRFcnJvckluZm8iLCJpc0FycmF5JDEiLCJjb2VyY2VSZWYiLCJtaXhlZFJlZiIsImluc3QiLCJzdHJpbmdSZWYiLCJfc3RyaW5nUmVmIiwidGhyb3dPbkludmFsaWRPYmplY3RUeXBlIiwicmV0dXJuRmliZXIiLCJuZXdDaGlsZCIsImFkZGVuZHVtIiwid2Fybk9uRnVuY3Rpb25UeXBlIiwiQ2hpbGRSZWNvbmNpbGVyIiwic2hvdWxkVHJhY2tTaWRlRWZmZWN0cyIsImRlbGV0ZUNoaWxkIiwiY2hpbGRUb0RlbGV0ZSIsImRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuIiwiY3VycmVudEZpcnN0Q2hpbGQiLCJtYXBSZW1haW5pbmdDaGlsZHJlbiIsImV4aXN0aW5nQ2hpbGRyZW4iLCJleGlzdGluZ0NoaWxkIiwidXNlRmliZXIiLCJjbG9uZSIsInBsYWNlQ2hpbGQiLCJuZXdGaWJlciIsImxhc3RQbGFjZWRJbmRleCIsIm5ld0luZGV4Iiwib2xkSW5kZXgiLCJwbGFjZVNpbmdsZUNoaWxkIiwidXBkYXRlVGV4dE5vZGUiLCJ0ZXh0Q29udGVudCIsImNyZWF0ZWQiLCJleGlzdGluZyIsInVwZGF0ZUVsZW1lbnQiLCJ1cGRhdGVDYWxsIiwidXBkYXRlUmV0dXJuIiwidXBkYXRlUG9ydGFsIiwidXBkYXRlRnJhZ21lbnQiLCJmcmFnbWVudCIsImNyZWF0ZUNoaWxkIiwiJCR0eXBlb2YiLCJfY3JlYXRlZCIsIl9jcmVhdGVkMiIsIl9jcmVhdGVkMyIsIl9jcmVhdGVkNCIsIl9jcmVhdGVkNSIsIl9jcmVhdGVkNiIsInVwZGF0ZVNsb3QiLCJvbGRGaWJlciIsInVwZGF0ZUZyb21NYXAiLCJuZXdJZHgiLCJtYXRjaGVkRmliZXIiLCJfbWF0Y2hlZEZpYmVyIiwiX21hdGNoZWRGaWJlcjIiLCJfbWF0Y2hlZEZpYmVyMyIsIl9tYXRjaGVkRmliZXI0IiwiX21hdGNoZWRGaWJlcjUiLCJ3YXJuT25JbnZhbGlkS2V5Iiwia25vd25LZXlzIiwicmVjb25jaWxlQ2hpbGRyZW5BcnJheSIsIm5ld0NoaWxkcmVuIiwicmVzdWx0aW5nRmlyc3RDaGlsZCIsInByZXZpb3VzTmV3RmliZXIiLCJuZXh0T2xkRmliZXIiLCJfbmV3RmliZXIiLCJfbmV3RmliZXIyIiwicmVjb25jaWxlQ2hpbGRyZW5JdGVyYXRvciIsIm5ld0NoaWxkcmVuSXRlcmFibGUiLCJpdGVyYXRvckZuIiwicG9zc2libGVNYXAiLCJfbmV3Q2hpbGRyZW4iLCJfc3RlcCIsIl9uZXdGaWJlcjMiLCJfbmV3RmliZXI0IiwicmVjb25jaWxlU2luZ2xlVGV4dE5vZGUiLCJyZWNvbmNpbGVTaW5nbGVFbGVtZW50IiwiX2NyZWF0ZWQ3IiwicmVjb25jaWxlU2luZ2xlQ2FsbCIsInJlY29uY2lsZVNpbmdsZVJldHVybiIsInJlY29uY2lsZVNpbmdsZVBvcnRhbCIsInJlY29uY2lsZUNoaWxkRmliZXJzIiwiX2lzTW9ja0Z1bmN0aW9uIiwibW91bnRDaGlsZEZpYmVycyIsImNsb25lQ2hpbGRGaWJlcnMiLCJjdXJyZW50Q2hpbGQiLCJ3YXJuZWRBYm91dFN0YXRlbGVzc1JlZnMiLCJSZWFjdEZpYmVyQmVnaW5Xb3JrIiwiY29uZmlnIiwiaG9zdENvbnRleHQiLCJoeWRyYXRpb25Db250ZXh0Iiwic2hvdWxkU2V0VGV4dENvbnRlbnQiLCJ1c2VTeW5jU2NoZWR1bGluZyIsInNob3VsZERlcHJpb3JpdGl6ZVN1YnRyZWUiLCJwdXNoSG9zdENvbnRleHQiLCJwdXNoSG9zdENvbnRhaW5lciIsImVudGVySHlkcmF0aW9uU3RhdGUiLCJyZXNldEh5ZHJhdGlvblN0YXRlIiwidHJ5VG9DbGFpbU5leHRIeWRyYXRhYmxlSW5zdGFuY2UiLCJfUmVhY3RGaWJlckNsYXNzQ29tcG8iLCJyZWNvbmNpbGVDaGlsZHJlbiIsIm5leHRDaGlsZHJlbiIsInJlY29uY2lsZUNoaWxkcmVuQXRFeHBpcmF0aW9uVGltZSIsImJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsiLCJtYXJrUmVmIiwidXBkYXRlRnVuY3Rpb25hbENvbXBvbmVudCIsIm5leHRQcm9wcyIsInVwZGF0ZUNsYXNzQ29tcG9uZW50IiwiaGFzQ29udGV4dCIsImZpbmlzaENsYXNzQ29tcG9uZW50IiwicHVzaEhvc3RSb290Q29udGV4dCIsInVwZGF0ZUhvc3RSb290IiwidXBkYXRlSG9zdENvbXBvbmVudCIsInByZXZQcm9wcyIsImlzRGlyZWN0VGV4dENoaWxkIiwidXBkYXRlSG9zdFRleHQiLCJtb3VudEluZGV0ZXJtaW5hdGVDb21wb25lbnQiLCJ3YXJuaW5nS2V5IiwiZGVidWdTb3VyY2UiLCJ1cGRhdGVDYWxsQ29tcG9uZW50IiwibmV4dENhbGwiLCJ1cGRhdGVQb3J0YWxDb21wb25lbnQiLCJiYWlsb3V0T25Mb3dQcmlvcml0eSIsIm5leHRTdGF0ZSIsImJlZ2luV29yayIsImJlZ2luRmFpbGVkV29yayIsIlJlYWN0RmliZXJDb21wbGV0ZVdvcmsiLCJjcmVhdGVJbnN0YW5jZSIsImNyZWF0ZVRleHRJbnN0YW5jZSIsImFwcGVuZEluaXRpYWxDaGlsZCIsImZpbmFsaXplSW5pdGlhbENoaWxkcmVuIiwicHJlcGFyZVVwZGF0ZSIsIm11dGF0aW9uIiwicGVyc2lzdGVuY2UiLCJnZXRSb290SG9zdENvbnRhaW5lciIsInBvcEhvc3RDb250ZXh0IiwiZ2V0SG9zdENvbnRleHQiLCJwb3BIb3N0Q29udGFpbmVyIiwicHJlcGFyZVRvSHlkcmF0ZUhvc3RJbnN0YW5jZSIsInByZXBhcmVUb0h5ZHJhdGVIb3N0VGV4dEluc3RhbmNlIiwicG9wSHlkcmF0aW9uU3RhdGUiLCJtYXJrVXBkYXRlIiwiYXBwZW5kQWxsUmV0dXJucyIsInJldHVybnMiLCJtb3ZlQ2FsbFRvSGFuZGxlclBoYXNlIiwiYXBwZW5kQWxsQ2hpbGRyZW4iLCJ1cGRhdGVIb3N0Q29udGFpbmVyIiwidXBkYXRlUGF5bG9hZCIsInJvb3RDb250YWluZXJJbnN0YW5jZSIsIm9sZFRleHQiLCJuZXdUZXh0IiwiY2xvbmVJbnN0YW5jZSIsImNyZWF0ZUNvbnRhaW5lckNoaWxkU2V0IiwiYXBwZW5kQ2hpbGRUb0NvbnRhaW5lckNoaWxkU2V0IiwiZmluYWxpemVDb250YWluZXJDaGlsZHJlbiIsImFwcGVuZEFsbENoaWxkcmVuVG9Db250YWluZXIiLCJjb250YWluZXJDaGlsZFNldCIsInBvcnRhbE9yUm9vdCIsImNoaWxkcmVuVW5jaGFuZ2VkIiwiY29udGFpbmVyIiwibmV3Q2hpbGRTZXQiLCJjdXJyZW50SW5zdGFuY2UiLCJyZWN5Y2xhYmxlSW5zdGFuY2UiLCJuZXdJbnN0YW5jZSIsImN1cnJlbnRIb3N0Q29udGV4dCIsImNvbXBsZXRlV29yayIsImZpYmVyUm9vdCIsIl9jdXJyZW50SG9zdENvbnRleHQiLCJ3YXNIeWRyYXRlZCIsIl9pbnN0YW5jZSIsIl9yb290Q29udGFpbmVySW5zdGFuY2UiLCJfY3VycmVudEhvc3RDb250ZXh0MiIsIl93YXNIeWRyYXRlZCIsImludm9rZUd1YXJkZWRDYWxsYmFjayQyIiwiaGFzQ2F1Z2h0RXJyb3IkMSIsImNsZWFyQ2F1Z2h0RXJyb3IkMSIsIlJlYWN0RmliZXJDb21taXRXb3JrIiwiY2FwdHVyZUVycm9yIiwiZ2V0UHVibGljSW5zdGFuY2UiLCJjYWxsQ29tcG9uZW50V2lsbFVubW91bnRXaXRoVGltZXIiLCJjb21wb25lbnRXaWxsVW5tb3VudCIsInNhZmVseUNhbGxDb21wb25lbnRXaWxsVW5tb3VudCIsInVubW91bnRFcnJvciIsInNhZmVseURldGFjaFJlZiIsInJlZkVycm9yIiwiY29tbWl0TGlmZUN5Y2xlcyIsIl91cGRhdGVRdWV1ZSIsIl9pbnN0YW5jZTIiLCJjb21taXRNb3VudCIsImNvbW1pdEF0dGFjaFJlZiIsImNvbW1pdERldGFjaFJlZiIsImN1cnJlbnRSZWYiLCJjb21taXRVbm1vdW50IiwiY29tbWl0TmVzdGVkVW5tb3VudHMiLCJ1bm1vdW50SG9zdENvbXBvbmVudHMiLCJlbXB0eVBvcnRhbENvbnRhaW5lciIsImRldGFjaEZpYmVyIiwiY29tbWl0Q29udGFpbmVyIiwicmVwbGFjZUNvbnRhaW5lckNoaWxkcmVuIiwiZW1wdHlDaGlsZFNldCIsIl9wZW5kaW5nQ2hpbGRyZW4iLCJjb21taXRSZXNldFRleHRDb250ZW50IiwiY29tbWl0UGxhY2VtZW50IiwiY29tbWl0RGVsZXRpb24iLCJjb21taXRXb3JrIiwiY29tbWl0VXBkYXRlIiwicmVzZXRUZXh0Q29udGVudCIsImNvbW1pdFRleHRVcGRhdGUiLCJhcHBlbmRDaGlsZFRvQ29udGFpbmVyIiwiaW5zZXJ0QmVmb3JlIiwiaW5zZXJ0SW5Db250YWluZXJCZWZvcmUiLCJyZW1vdmVDaGlsZEZyb21Db250YWluZXIiLCJnZXRIb3N0UGFyZW50RmliZXIiLCJpc0hvc3RQYXJlbnQiLCJnZXRIb3N0U2libGluZyIsInNpYmxpbmdzIiwicGFyZW50RmliZXIiLCJpc0NvbnRhaW5lciIsImJlZm9yZSIsImN1cnJlbnRQYXJlbnRJc1ZhbGlkIiwiY3VycmVudFBhcmVudElzQ29udGFpbmVyIiwiZmluZFBhcmVudCIsInRleHRJbnN0YW5jZSIsIk5PX0NPTlRFWFQiLCJSZWFjdEZpYmVySG9zdENvbnRleHQiLCJnZXRDaGlsZEhvc3RDb250ZXh0IiwiZ2V0Um9vdEhvc3RDb250ZXh0IiwiY29udGV4dEZpYmVyU3RhY2tDdXJzb3IiLCJyb290SW5zdGFuY2VTdGFja0N1cnNvciIsInJlcXVpcmVkQ29udGV4dCIsInJvb3RJbnN0YW5jZSIsIm5leHRSb290SW5zdGFuY2UiLCJuZXh0Um9vdENvbnRleHQiLCJuZXh0Q29udGV4dCIsInJlc2V0SG9zdENvbnRhaW5lciIsIlJlYWN0RmliZXJIeWRyYXRpb25Db250ZXh0IiwiaHlkcmF0aW9uIiwiY2FuSHlkcmF0ZUluc3RhbmNlIiwiY2FuSHlkcmF0ZVRleHRJbnN0YW5jZSIsImdldE5leHRIeWRyYXRhYmxlU2libGluZyIsImdldEZpcnN0SHlkcmF0YWJsZUNoaWxkIiwiaHlkcmF0ZUluc3RhbmNlIiwiaHlkcmF0ZVRleHRJbnN0YW5jZSIsImRpZE5vdE1hdGNoSHlkcmF0ZWRDb250YWluZXJUZXh0SW5zdGFuY2UiLCJkaWROb3RNYXRjaEh5ZHJhdGVkVGV4dEluc3RhbmNlIiwiZGlkTm90SHlkcmF0ZUNvbnRhaW5lckluc3RhbmNlIiwiZGlkTm90SHlkcmF0ZUluc3RhbmNlIiwiZGlkTm90RmluZEh5ZHJhdGFibGVDb250YWluZXJJbnN0YW5jZSIsImRpZE5vdEZpbmRIeWRyYXRhYmxlQ29udGFpbmVyVGV4dEluc3RhbmNlIiwiZGlkTm90RmluZEh5ZHJhdGFibGVJbnN0YW5jZSIsImRpZE5vdEZpbmRIeWRyYXRhYmxlVGV4dEluc3RhbmNlIiwiaHlkcmF0aW9uUGFyZW50RmliZXIiLCJuZXh0SHlkcmF0YWJsZUluc3RhbmNlIiwiaXNIeWRyYXRpbmciLCJwYXJlbnRJbnN0YW5jZSIsImRlbGV0ZUh5ZHJhdGFibGVJbnN0YW5jZSIsImluc2VydE5vbkh5ZHJhdGVkSW5zdGFuY2UiLCJwYXJlbnRDb250YWluZXIiLCJwYXJlbnRUeXBlIiwicGFyZW50UHJvcHMiLCJfdHlwZSIsIl9wcm9wcyIsIl90ZXh0IiwidHJ5SHlkcmF0ZSIsIm5leHRJbnN0YW5jZSIsInBvcFRvTmV4dEhvc3RQYXJlbnQiLCJSZWFjdEZpYmVySW5zdHJ1bWVudGF0aW9uIiwiZGVidWdUb29sIiwiUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbl8xIiwiZGVmYXVsdFNob3dEaWFsb2ciLCJjYXB0dXJlZEVycm9yIiwic2hvd0RpYWxvZyIsImxvZ0NhcHR1cmVkRXJyb3IiLCJsb2dFcnJvciIsInN1cHByZXNzTG9nZ2luZyIsInN1cHByZXNzUmVhY3RFcnJvckxvZ2dpbmciLCJjb21wb25lbnRTdGFjayIsImVycm9yQm91bmRhcnlOYW1lIiwiZXJyb3JCb3VuZGFyeUZvdW5kIiwid2lsbFJldHJ5IiwiY29tcG9uZW50TmFtZU1lc3NhZ2UiLCJlcnJvckJvdW5kYXJ5TWVzc2FnZSIsImNvbWJpbmVkTWVzc2FnZSIsImRpZFdhcm5BYm91dFN0YXRlVHJhbnNpdGlvbiIsImRpZFdhcm5TZXRTdGF0ZUNoaWxkQ29udGV4dCIsImRpZFdhcm5TdGF0ZVVwZGF0ZUZvclVubW91bnRlZENvbXBvbmVudCIsIndhcm5BYm91dFVwZGF0ZU9uVW5tb3VudGVkIiwid2FybkFib3V0SW52YWxpZFVwZGF0ZXMiLCJSZWFjdEZpYmVyU2NoZWR1bGVyIiwiX1JlYWN0RmliZXJCZWdpbldvcmsiLCJfUmVhY3RGaWJlckNvbXBsZXRlV28iLCJfUmVhY3RGaWJlckNvbW1pdFdvcmsiLCJzY2hlZHVsZURlZmVycmVkQ2FsbGJhY2siLCJjYW5jZWxEZWZlcnJlZENhbGxiYWNrIiwicHJlcGFyZUZvckNvbW1pdCIsInJlc2V0QWZ0ZXJDb21taXQiLCJzdGFydFRpbWUiLCJtb3N0UmVjZW50Q3VycmVudFRpbWUiLCJleHBpcmF0aW9uQ29udGV4dCIsImlzV29ya2luZyIsIm5leHRSb290IiwibmV4dFJlbmRlckV4cGlyYXRpb25UaW1lIiwiY2FwdHVyZWRFcnJvcnMiLCJmYWlsZWRCb3VuZGFyaWVzIiwiY29tbWl0UGhhc2VCb3VuZGFyaWVzIiwiZmlyc3RVbmNhdWdodEVycm9yIiwiZGlkRmF0YWwiLCJpc1VubW91bnRpbmciLCJyZXNldENvbnRleHRTdGFjayIsImNvbW1pdEFsbEhvc3RFZmZlY3RzIiwicHJpbWFyeUVmZmVjdFRhZyIsIl9jdXJyZW50IiwiX2N1cnJlbnQyIiwiY29tbWl0QWxsTGlmZUN5Y2xlcyIsImNvbW1pdEVycm9ySGFuZGxpbmciLCJjb21taXRSb290IiwiX2Vycm9yIiwiX2RpZEVycm9yIiwiX2Vycm9yMiIsIm9uQ29tbWl0V29yayIsInNjaGVkdWxlRXJyb3JSZWNvdmVyeSIsIl9lcnJvcjMiLCJvblVuY2F1Z2h0RXJyb3IiLCJyZW1haW5pbmdUaW1lIiwicmVzZXRFeHBpcmF0aW9uVGltZSIsInJlbmRlclRpbWUiLCJuZXdFeHBpcmF0aW9uVGltZSIsImNvbXBsZXRlVW5pdE9mV29yayIsInNpYmxpbmdGaWJlciIsIm9uQ29tcGxldGVXb3JrIiwicGVyZm9ybVVuaXRPZldvcmsiLCJvbkJlZ2luV29yayIsInBlcmZvcm1GYWlsZWRVbml0T2ZXb3JrIiwid29ya0xvb3AiLCJzbG93V29ya0xvb3BUaGF0Q2hlY2tzRm9yRmFpbGVkV29yayIsInNob3VsZFlpZWxkIiwiaGFzQ2FwdHVyZWRFcnJvciIsInJlbmRlclJvb3RDYXRjaEJsb2NrIiwiZmFpbGVkV29yayIsImJvdW5kYXJ5IiwidW53aW5kQ29udGV4dHMiLCJyZW5kZXJSb290IiwidW5jYXVnaHRFcnJvciIsImlzRmFpbGVkQm91bmRhcnkiLCJjb21wb25lbnREaWRDYXRjaCIsIl9jb21wb25lbnRTdGFjayIsIl9jb21wb25lbnROYW1lIiwiZXJyb3JCb3VuZGFyeSIsImVmZmVjdGZ1bEZpYmVyIiwiY29tcHV0ZUFzeW5jRXhwaXJhdGlvbiIsInJlY2FsY3VsYXRlQ3VycmVudFRpbWUiLCJleHBpcmF0aW9uTXMiLCJzY2hlZHVsZVdvcmtJbXBsIiwiY2hlY2tSb290TmVlZHNDbGVhcmluZyIsImlzRXJyb3JSZWNvdmVyeSIsInJlcXVlc3RXb3JrIiwiZGVmZXJyZWRVcGRhdGVzIiwicHJldmlvdXNFeHBpcmF0aW9uQ29udGV4dCIsInN5bmNVcGRhdGVzIiwiZmlyc3RTY2hlZHVsZWRSb290IiwibGFzdFNjaGVkdWxlZFJvb3QiLCJjYWxsYmFja0V4cGlyYXRpb25UaW1lIiwiY2FsbGJhY2tJRCIsImlzUmVuZGVyaW5nIiwibmV4dEZsdXNoZWRSb290IiwibmV4dEZsdXNoZWRFeHBpcmF0aW9uVGltZSIsImRlYWRsaW5lRGlkRXhwaXJlIiwiaGFzVW5oYW5kbGVkRXJyb3IiLCJ1bmhhbmRsZWRFcnJvciIsImRlYWRsaW5lIiwiaXNCYXRjaGluZ1VwZGF0ZXMiLCJpc1VuYmF0Y2hpbmdVcGRhdGVzIiwiTkVTVEVEX1VQREFURV9MSU1JVCIsIm5lc3RlZFVwZGF0ZUNvdW50IiwidGltZUhldXJpc3RpY0ZvclVuaXRPZldvcmsiLCJzY2hlZHVsZUNhbGxiYWNrV2l0aEV4cGlyYXRpb24iLCJjdXJyZW50TXMiLCJwZXJmb3JtQXN5bmNXb3JrIiwicGVyZm9ybVdvcmtPblJvb3QiLCJwZXJmb3JtV29yayIsImZpbmRIaWdoZXN0UHJpb3JpdHlSb290IiwiaGlnaGVzdFByaW9yaXR5V29yayIsImhpZ2hlc3RQcmlvcml0eVJvb3QiLCJwcmV2aW91c1NjaGVkdWxlZFJvb3QiLCJwcmV2aW91c0ZsdXNoZWRSb290IiwiZGwiLCJtaW5FeHBpcmF0aW9uVGltZSIsIl9lcnJvcjQiLCJfZmluaXNoZWRXb3JrIiwidGltZVJlbWFpbmluZyIsImJhdGNoZWRVcGRhdGVzIiwicHJldmlvdXNJc0JhdGNoaW5nVXBkYXRlcyIsInVuYmF0Y2hlZFVwZGF0ZXMiLCJmbHVzaFN5bmMiLCJkaWRXYXJuQWJvdXROZXN0ZWRVcGRhdGVzIiwiZ2V0Q29udGV4dEZvclN1YnRyZWUiLCJwYXJlbnRDb21wb25lbnQiLCJSZWFjdEZpYmVyUmVjb25jaWxlciQxIiwiX1JlYWN0RmliZXJTY2hlZHVsZXIiLCJzY2hlZHVsZVRvcExldmVsVXBkYXRlIiwiZmluZEhvc3RJbnN0YW5jZSIsImhvc3RGaWJlciIsImNyZWF0ZUNvbnRhaW5lciIsInVwZGF0ZUNvbnRhaW5lciIsIm9uTW91bnRDb250YWluZXIiLCJvblVubW91bnRDb250YWluZXIiLCJvblVwZGF0ZUNvbnRhaW5lciIsImdldFB1YmxpY1Jvb3RJbnN0YW5jZSIsImNvbnRhaW5lckZpYmVyIiwiZmluZEhvc3RJbnN0YW5jZVdpdGhOb1BvcnRhbHMiLCJpbmplY3RJbnRvRGV2VG9vbHMiLCJkZXZUb29sc0NvbmZpZyIsImZpbmRGaWJlckJ5SG9zdEluc3RhbmNlIiwiZmluZEhvc3RJbnN0YW5jZUJ5RmliZXIiLCJSZWFjdEZpYmVyUmVjb25jaWxlciQyIiwiZGVmYXVsdCIsIlJlYWN0RmliZXJSZWNvbmNpbGVyJDMiLCJyZWFjdFJlY29uY2lsZXIiLCJnZXRGaWJlckN1cnJlbnRQcm9wc0Zyb21Ob2RlIiwiZ2V0SW5zdGFuY2VGcm9tTm9kZSIsImZpYmVySG9zdENvbXBvbmVudCIsInJlc3RvcmVUYXJnZXQiLCJyZXN0b3JlUXVldWUiLCJyZXN0b3JlU3RhdGVPZlRhcmdldCIsImludGVybmFsSW5zdGFuY2UiLCJyZXN0b3JlQ29udHJvbGxlZFN0YXRlIiwicmVzdG9yZVN0YXRlSWZOZWVkZWQiLCJxdWV1ZWRUYXJnZXRzIiwiZmliZXJCYXRjaGVkVXBkYXRlcyIsImJvb2trZWVwaW5nIiwiaXNOZXN0aW5nQmF0Y2hlZCIsIl9jcmVhdGVDbGFzcyIsInByb3RvUHJvcHMiLCJzdGF0aWNQcm9wcyIsIl9jbGFzc0NhbGxDaGVjayIsIl9vYmplY3RXaXRob3V0UHJvcGVydGllcyIsIm9iaiIsIlVQREFURV9TSUdOQUwiLCJfY3JlYXRlTm9kZU1vY2siLCJjcmVhdGVOb2RlTW9jayIsImJlZm9yZUNoaWxkIiwiYmVmb3JlSW5kZXgiLCJUZXN0UmVuZGVyZXIiLCJpbnRlcm5hbEluc3RhbmNlSGFuZGxlIiwidGVzdEVsZW1lbnQiLCJ0aW1lb3V0SUQiLCJkZWZhdWx0VGVzdE9wdGlvbnMiLCJfaW5zdCRwcm9wcyIsIl9jaGlsZHJlbiIsInJlbmRlcmVkQ2hpbGRyZW4iLCJub2RlQW5kU2libGluZ3NUcmVlcyIsIm5vZGVXaXRoU2libGluZyIsInRyZWVzIiwidG9UcmVlIiwiaGFzU2libGluZ3MiLCJub2RlVHlwZSIsInJlbmRlcmVkIiwiZmliZXJUb1dyYXBwZXIiLCJ3cmFwRmliZXIiLCJSZWFjdFRlc3RJbnN0YW5jZSIsInZhbGlkV3JhcHBlclR5cGVzIiwiX2N1cnJlbnRGaWJlciIsIl9maWJlciIsImV4cGVjdE9uZSIsImZpbmRBbGwiLCJkZWVwIiwiZmluZEJ5VHlwZSIsImZpbmRBbGxCeVR5cGUiLCJmaW5kQnlQcm9wcyIsImZpbmRBbGxCeVByb3BzIiwib3B0aW9ucyIsIl9maW5kQWxsIiwicHJvcHNNYXRjaCIsInN0YXJ0aW5nTm9kZSIsIm91dGVyIiwiZGVzY2VuZCIsInJlc3VsdHMiLCJfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uIiwiX2RpZEl0ZXJhdG9yRXJyb3IiLCJfaXRlcmF0b3JFcnJvciIsIl9pdGVyYXRvciIsIlJlYWN0VGVzdFJlbmRlcmVyRmliZXIiLCJuZXdFbGVtZW50IiwidW5tb3VudCIsImdldEluc3RhbmNlIiwidW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXMiLCJSZWFjdFRlc3RSZW5kZXJlciIsIlJlYWN0VGVzdFJlbmRlcmVyJDEiLCJyZWFjdFRlc3RSZW5kZXJlciIsImRhIiwiaGEiLCJlbmNvZGVVUklDb21wb25lbnQiLCJpYSIsImphIiwia2EiLCJsYSIsIm1hIiwibmEiLCJvYSIsInNhIiwiTSIsIk4iLCJRIiwidGEiLCJ1YSIsInZhIiwid2EiLCJ4YSIsInlhIiwiemEiLCJBYSIsIkJhIiwiWCIsIkNhIiwiRGEiLCJFYSIsIkZhIiwiR2EiLCJIYSIsIklhIiwiT2EiLCJQYSIsIlFhIiwiUmEiLCJTYSIsIlRhIiwiVWEiLCJWYSIsIldhIiwiWGEiLCJnYiIsImhiIiwiaWIiLCJqYiIsImtiIiwibGIiLCJtYiIsIm5iIiwiWSIsIm9iIiwicGIiLCJxYiIsInJiIiwic2IiLCJ0YiIsImgiLCJxIiwiSCIsInViIiwidmIiLCJ3YiIsImNhIiwieGIiLCJ5YiIsInpiIiwiQWIiLCJCYiIsIkNiIiwiSmEiLCJmYyIsImdjIiwiZWEiLCJoYyIsIkViIiwiRmIiLCJaYSIsImljIiwiJGEiLCJqYyIsImtjIiwibGMiLCJKIiwiWiIsIm1jIiwiWmIiLCJuYyIsImFiIiwiYWEiLCJZYiIsIllhIiwicWEiLCJYYiIsImJiIiwib2MiLCJLYSIsInBjIiwiSSIsImJhIiwiZmEiLCJMYSIsIkdiIiwiTWEiLCJxYyIsImRiIiwicmMiLCJyYSIsImViIiwiTmEiLCJmYiIsInNjIiwiRGIiLCJIYiIsIkliIiwiSmIiLCJLYiIsIkxiIiwiTWIiLCJOYiIsIk9iIiwiUGIiLCJRYiIsIlJiIiwiU2IiLCJUYiIsIlViIiwiVmIiLCJXYiIsIiRiIiwiYWMiLCJiYyIsImNjIiwiZGMiLCJlYyIsInRjIiwidWMiLCJ2YyIsIndjIiwieGMiLCJ5YyIsIlJlYWN0VmVyc2lvbiIsImxvd1ByaW9yaXR5V2FybmluZyIsImxvd1ByaW9yaXR5V2FybmluZyQxIiwid2Fybk5vb3AiLCJwdWJsaWNJbnN0YW5jZSIsIlJlYWN0Tm9vcFVwZGF0ZVF1ZXVlIiwiY29tcGxldGVTdGF0ZSIsInNldFN0YXRlIiwiZm9yY2VVcGRhdGUiLCJkZXByZWNhdGVkQVBJcyIsInJlcGxhY2VTdGF0ZSIsImRlZmluZURlcHJlY2F0aW9uV2FybmluZyIsIm1ldGhvZE5hbWUiLCJmbk5hbWUiLCJQdXJlQ29tcG9uZW50IiwiQ29tcG9uZW50RHVtbXkiLCJwdXJlQ29tcG9uZW50UHJvdG90eXBlIiwiQXN5bmNDb21wb25lbnQiLCJhc3luY0NvbXBvbmVudFByb3RvdHlwZSIsIlJFU0VSVkVEX1BST1BTIiwiX19zZWxmIiwiX19zb3VyY2UiLCJzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93biIsInNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duIiwiaGFzVmFsaWRSZWYiLCJpc1JlYWN0V2FybmluZyIsImhhc1ZhbGlkS2V5IiwiZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIiLCJ3YXJuQWJvdXRBY2Nlc3NpbmdLZXkiLCJkZWZpbmVSZWZQcm9wV2FybmluZ0dldHRlciIsIndhcm5BYm91dEFjY2Vzc2luZ1JlZiIsIlJlYWN0RWxlbWVudCIsInByb3BOYW1lIiwiY2hpbGRyZW5MZW5ndGgiLCJjaGlsZEFycmF5IiwiY2xvbmVBbmRSZXBsYWNlS2V5Iiwib2xkRWxlbWVudCIsIm5ld0tleSIsIl9zZWxmIiwiY2xvbmVFbGVtZW50IiwiaXNWYWxpZEVsZW1lbnQiLCJnZXRTdGFja0FkZGVuZHVtIiwiaW1wbCIsIlNFUEFSQVRPUiIsIlNVQlNFUEFSQVRPUiIsImVzY2FwZSIsImVzY2FwZVJlZ2V4IiwiZXNjYXBlckxvb2t1cCIsImVzY2FwZWRTdHJpbmciLCJ1c2VyUHJvdmlkZWRLZXlFc2NhcGVSZWdleCIsImVzY2FwZVVzZXJQcm92aWRlZEtleSIsIlBPT0xfU0laRSIsInRyYXZlcnNlQ29udGV4dFBvb2wiLCJnZXRQb29sZWRUcmF2ZXJzZUNvbnRleHQiLCJtYXBSZXN1bHQiLCJrZXlQcmVmaXgiLCJtYXBGdW5jdGlvbiIsIm1hcENvbnRleHQiLCJ0cmF2ZXJzZUNvbnRleHQiLCJyZWxlYXNlVHJhdmVyc2VDb250ZXh0IiwidHJhdmVyc2VBbGxDaGlsZHJlbkltcGwiLCJuYW1lU29GYXIiLCJpbnZva2VDYWxsYmFjayIsImdldENvbXBvbmVudEtleSIsIm5leHROYW1lIiwic3VidHJlZUNvdW50IiwibmV4dE5hbWVQcmVmaXgiLCJpaSIsImNoaWxkcmVuU3RyaW5nIiwidHJhdmVyc2VBbGxDaGlsZHJlbiIsImZvckVhY2hTaW5nbGVDaGlsZCIsImJvb2tLZWVwaW5nIiwiZm9yRWFjaENoaWxkcmVuIiwiZm9yRWFjaEZ1bmMiLCJmb3JFYWNoQ29udGV4dCIsIm1hcFNpbmdsZUNoaWxkSW50b0NvbnRleHQiLCJjaGlsZEtleSIsIm1hcHBlZENoaWxkIiwibWFwSW50b1dpdGhLZXlQcmVmaXhJbnRlcm5hbCIsImVzY2FwZWRQcmVmaXgiLCJtYXBDaGlsZHJlbiIsImNvdW50Q2hpbGRyZW4iLCJ0b0FycmF5Iiwib25seUNoaWxkIiwiY3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQiLCJwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93biIsImdldERpc3BsYXlOYW1lIiwiVkFMSURfRlJBR01FTlRfUFJPUFMiLCJnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0iLCJnZXRTb3VyY2VJbmZvRXJyb3JBZGRlbmR1bSIsImVsZW1lbnRQcm9wcyIsImdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8iLCJwYXJlbnROYW1lIiwidmFsaWRhdGVFeHBsaWNpdEtleSIsImNoaWxkT3duZXIiLCJ2YWxpZGF0ZUNoaWxkS2V5cyIsInZhbGlkYXRlUHJvcFR5cGVzIiwiY29tcG9uZW50Q2xhc3MiLCJQcm9wVHlwZXMiLCJ2YWxpZGF0ZUZyYWdtZW50UHJvcHMiLCJjcmVhdGVFbGVtZW50V2l0aFZhbGlkYXRpb24iLCJ2YWxpZFR5cGUiLCJzb3VyY2VJbmZvIiwiY3JlYXRlRmFjdG9yeVdpdGhWYWxpZGF0aW9uIiwidmFsaWRhdGVkRmFjdG9yeSIsImNsb25lRWxlbWVudFdpdGhWYWxpZGF0aW9uIiwiQ2hpbGRyZW4iLCJvbmx5IiwidW5zdGFibGVfQXN5bmNDb21wb25lbnQiLCJjcmVhdGVGYWN0b3J5IiwiUmVhY3RDb21wb25lbnRUcmVlSG9vayIsIlJlYWN0JDIiLCJSZWFjdCQzIiwicmVhY3QiLCJPcCIsIml0ZXJhdG9yU3ltYm9sIiwiYXN5bmNJdGVyYXRvclN5bWJvbCIsImFzeW5jSXRlcmF0b3IiLCJ0b1N0cmluZ1RhZ1N5bWJvbCIsInRvU3RyaW5nVGFnIiwiaW5Nb2R1bGUiLCJydW50aW1lIiwicmVnZW5lcmF0b3JSdW50aW1lIiwiaW5uZXJGbiIsIm91dGVyRm4iLCJ0cnlMb2NzTGlzdCIsInByb3RvR2VuZXJhdG9yIiwiR2VuZXJhdG9yIiwiZ2VuZXJhdG9yIiwiQ29udGV4dCIsIl9pbnZva2UiLCJtYWtlSW52b2tlTWV0aG9kIiwidHJ5Q2F0Y2giLCJHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0IiwiR2VuU3RhdGVTdXNwZW5kZWRZaWVsZCIsIkdlblN0YXRlRXhlY3V0aW5nIiwiR2VuU3RhdGVDb21wbGV0ZWQiLCJDb250aW51ZVNlbnRpbmVsIiwiR2VuZXJhdG9yRnVuY3Rpb24iLCJHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSIsIk5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlIiwiR3AiLCJkZWZpbmVJdGVyYXRvck1ldGhvZHMiLCJpc0dlbmVyYXRvckZ1bmN0aW9uIiwiZ2VuRnVuIiwiYXdyYXAiLCJfX2F3YWl0IiwiQXN5bmNJdGVyYXRvciIsInJlY29yZCIsInVud3JhcHBlZCIsInByZXZpb3VzUHJvbWlzZSIsImVucXVldWUiLCJjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZyIsImFzeW5jIiwiZG9uZVJlc3VsdCIsImRlbGVnYXRlIiwiZGVsZWdhdGVSZXN1bHQiLCJtYXliZUludm9rZURlbGVnYXRlIiwic2VudCIsIl9zZW50IiwiZGlzcGF0Y2hFeGNlcHRpb24iLCJhYnJ1cHQiLCJyZXR1cm4iLCJyZXN1bHROYW1lIiwibmV4dExvYyIsInB1c2hUcnlFbnRyeSIsImxvY3MiLCJ0cnlMb2MiLCJjYXRjaExvYyIsImZpbmFsbHlMb2MiLCJhZnRlckxvYyIsInRyeUVudHJpZXMiLCJyZXNldFRyeUVudHJ5IiwiY29tcGxldGlvbiIsIml0ZXJhdG9yTWV0aG9kIiwic2tpcFRlbXBSZXNldCIsInJvb3RFbnRyeSIsInJvb3RSZWNvcmQiLCJydmFsIiwiZXhjZXB0aW9uIiwiaGFuZGxlIiwibG9jIiwiY2F1Z2h0IiwiaGFzQ2F0Y2giLCJoYXNGaW5hbGx5IiwiZmluYWxseUVudHJ5IiwiZmluaXNoIiwidGhyb3duIiwiZGVsZWdhdGVZaWVsZCIsImV2YWwiXSwibWFwcGluZ3MiOiI7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQTJEO0FBQzNEO0FBQ0E7QUFDQSxXQUFHOztBQUVILG9EQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQU07QUFDTjtBQUNBO0FBQ0EsY0FBTTtBQUNOO0FBQ0E7QUFDQSxjQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsZUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQUk7QUFDSjs7OztBQUlBO0FBQ0Esc0RBQThDO0FBQzlDO0FBQ0E7QUFDQSxvQ0FBNEI7QUFDNUIscUNBQTZCO0FBQzdCLHlDQUFpQzs7QUFFakMsK0NBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDhDQUFzQztBQUN0QztBQUNBO0FBQ0EscUNBQTZCO0FBQzdCLHFDQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQW9CLGdCQUFnQjtBQUNwQztBQUNBO0FBQ0E7QUFDQSxhQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLGFBQUs7QUFDTDtBQUNBO0FBQ0EsYUFBSztBQUNMO0FBQ0E7QUFDQSxhQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsYUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFLO0FBQ0w7QUFDQTtBQUNBLGFBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxhQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx5QkFBaUIsOEJBQThCO0FBQy9DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFLO0FBQ0w7QUFDQTtBQUNBLGFBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQUk7QUFDSjs7QUFFQSw0REFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFLO0FBQ0w7QUFDQTtBQUNBLGNBQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQW1CLDJCQUEyQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQkFBa0IsY0FBYztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQkFBYSw0QkFBNEI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0Esc0JBQWMsNEJBQTRCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esc0JBQWMsNEJBQTRCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUFnQix1Q0FBdUM7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUFnQix1Q0FBdUM7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBZ0Isc0JBQXNCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLGdCQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFCQUFhLHdDQUF3QztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGVBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBSTtBQUNKOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBMkIsMEJBQTBCLEVBQUU7QUFDdkQseUNBQWlDLGVBQWU7QUFDaEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOERBQXNELCtEQUErRDs7QUFFckg7QUFDQTs7QUFFQTtBQUNBLDhDQUFzQyx1QkFBdUI7O0FBRTdEO0FBQ0E7Ozs7Ozs7Ozs4Q0NudEJBOztBQUVBLG1CQUFBQSxDQUFRLGdDQUFSOztBQUVBLG1CQUFBQSxDQUFRLCtDQUFSOztBQUVBLElBQUlDLE9BQU9DLGNBQVgsRUFBMkI7QUFDekIsUUFBTSxJQUFJQyxLQUFKLENBQVUsaURBQVYsQ0FBTjtBQUNEOztBQUVERixPQUFPQyxjQUFQLEdBQXdCLElBQXhCLEM7Ozs7Ozs7OztBQ1ZBOztBQUNBRSxPQUFPQyxjQUFQLENBQXNCQyxPQUF0QixFQUErQixZQUEvQixFQUE2QztBQUFFQyxTQUFPO0FBQVQsQ0FBN0M7O0FBQ0EsSUFBTUMsWUFBWSxtQkFBQVIsQ0FBUSxpRUFBUixDQUFsQjs7QUFDQU0sUUFBUUUsU0FBUixHQUFvQkEsU0FBcEI7O0FBQ0EsSUFBTUMsYUFBYSxtQkFBQVQsQ0FBUSxrRUFBUixDQUFuQjs7QUFDQU0sUUFBUUcsVUFBUixHQUFxQkEsVUFBckI7O0FBQ0EsSUFBTUMsU0FBUyxtQkFBQVYsQ0FBUSxtREFBUixDQUFmOztBQUNBTSxRQUFRSyxFQUFSLEdBQWFELE9BQU9DLEVBQXBCLEMsQ0FDQSxpQzs7Ozs7Ozs7QUNSQTs7Ozt3QkFFVUMsSzs7O3dCQU1BQyxROzs7d0JBTUFDLEs7Ozt3QkFFQUMsTTs7O3dCQU1BQyxJOzs7d0JBTUFDLE07O0FBM0JWYixPQUFPQyxjQUFQLENBQXNCQyxPQUF0QixFQUErQixZQUEvQixFQUE2QztBQUFFQyxTQUFPO0FBQVQsQ0FBN0M7O0FBQ0EsU0FBVUssS0FBVixDQUFnQk0sS0FBaEIsRUFBdUJDLEtBQXZCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNhQyxXQURiLEdBQ2lCLENBRGpCOztBQUFBO0FBQUEsZ0JBQ29CQSxJQUFJRCxLQUR4QjtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBLGlCQUVjRCxRQUFRRSxDQUZ0Qjs7QUFBQTtBQUMrQixZQUFFQSxDQURqQztBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBS0FkLFFBQVFNLEtBQVIsR0FBZ0JBLEtBQWhCOztBQUNBLFNBQVVDLFFBQVY7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ2FPLFdBRGIsR0FDaUIsQ0FEakI7O0FBQUE7QUFBQTtBQUFBLGlCQUVjQSxDQUZkOztBQUFBO0FBQ3FCLFlBQUVBLENBRHZCO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFLQWQsUUFBUU8sUUFBUixHQUFtQkEsUUFBbkI7O0FBQ0EsU0FBVUMsS0FBVjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUNBUixRQUFRUSxLQUFSLEdBQWdCQSxLQUFoQjs7QUFDQSxTQUFVQyxNQUFWO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEscUNBQW9CTSxTQUFwQjtBQUFvQkEscUJBQXBCO0FBQUE7O0FBQUE7O0FBQUE7QUFBQSxxQkFDMkJBLFNBRDNCO0FBQUE7QUFBQTtBQUFBOztBQUNlQyxrQkFEZixHQUMyQkQsU0FEM0I7QUFBQSx5Q0FFZUMsUUFGZjs7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFLQWhCLFFBQVFTLE1BQVIsR0FBaUJBLE1BQWpCOztBQUNBLFNBQVVDLElBQVYsQ0FBZU8sSUFBZjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxpREFDc0JBLElBRHRCOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQ2VDLGFBRGY7QUFBQTtBQUFBLGlCQUVjQSxHQUZkOztBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFLQWxCLFFBQVFVLElBQVIsR0FBZUEsSUFBZjs7QUFDQSxTQUFVQyxNQUFWLENBQWlCTSxJQUFqQjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxpREFDc0JBLElBRHRCOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQ2VDLGFBRGY7QUFBQTtBQUFBLGlCQUVjRCxLQUFLQyxHQUFMLENBRmQ7O0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUtBbEIsUUFBUVcsTUFBUixHQUFpQkEsTUFBakIsQyxDQUNBLHNDOzs7Ozs7OztBQ2xDQTs7Ozt3QkFFVVEsSTs7O3dCQTRPQUMsUTs7QUE3T1Z0QixPQUFPQyxjQUFQLENBQXNCQyxPQUF0QixFQUErQixZQUEvQixFQUE2QztBQUFFQyxTQUFPO0FBQVQsQ0FBN0M7O0FBQ0EsU0FBVWtCLElBQVYsQ0FBZUgsUUFBZjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsd0NBQ2tCQSxRQURsQjs7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUdBaEIsUUFBUW1CLElBQVIsR0FBZUEsSUFBZjs7QUFDQSxTQUFTRSxHQUFULENBQWFDLE1BQWIsRUFBcUI7QUFDakI7QUFBQTtBQUFBLDRCQUFPLGlCQUFXQyxFQUFYO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQ0MsbUJBREQsR0FDUyxDQURUO0FBQUEsMEJBRWlCRCxFQUZqQjs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7O0FBQUE7QUFBQTs7QUFBQTtBQUVRdEIsb0JBRlI7QUFHQ3FCLHFCQUFPckIsTUFBUCxFQUFjdUIsS0FBZDtBQUhEO0FBQUEscUJBSU92QixNQUpQOztBQUFBO0FBS0N1QixzQkFBUUEsUUFBUSxDQUFoQjs7QUFMRDtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsS0FBUDtBQUFBO0FBUUg7O0FBQ0R4QixRQUFRcUIsR0FBUixHQUFjQSxHQUFkOztBQUNBLFNBQVNJLEdBQVQsQ0FBYUMsTUFBYixFQUFxQjtBQUNqQjtBQUFBO0FBQUEsNEJBQU8sa0JBQVdWLFFBQVg7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNDUSxtQkFERCxHQUNTLENBRFQ7QUFBQSwyQkFFaUJSLFFBRmpCOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTs7QUFBQTtBQUFBOztBQUFBO0FBRVFmLHFCQUZSO0FBQUE7QUFBQSxxQkFHT3lCLE9BQU96QixPQUFQLEVBQWN1QixLQUFkLENBSFA7O0FBQUE7QUFJQ0Esc0JBQVFBLFFBQVEsQ0FBaEI7O0FBSkQ7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEtBQVA7QUFBQTtBQU9IOztBQUNEeEIsUUFBUXlCLEdBQVIsR0FBY0EsR0FBZDs7QUFDQSxTQUFTRSxPQUFULENBQWlCRCxNQUFqQixFQUF5QjtBQUNyQjtBQUFBO0FBQUEsNEJBQU8sa0JBQVdWLFFBQVg7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNDUSxtQkFERCxHQUNTLENBRFQ7QUFBQSwyQkFFaUJSLFFBRmpCOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTs7QUFBQTtBQUFBOztBQUFBO0FBRVFmLHFCQUZSO0FBR08yQiwyQkFIUCxHQUd1QkYsT0FBT3pCLE9BQVAsRUFBY3VCLEtBQWQsQ0FIdkI7QUFBQSwyQkFJcUJJLGFBSnJCOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTs7QUFBQTtBQUFBOztBQUFBO0FBSVlDLG9CQUpaO0FBQUE7QUFBQSxxQkFLV0EsTUFMWDs7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFPQ0wsc0JBQVFBLFFBQVEsQ0FBaEI7O0FBUEQ7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEtBQVA7QUFBQTtBQVVIOztBQUNEeEIsUUFBUTJCLE9BQVIsR0FBa0JBLE9BQWxCOztBQUNBLFNBQVNHLE1BQVQsQ0FBZ0JDLFNBQWhCLEVBQTJCO0FBQ3ZCO0FBQUE7QUFBQSw0QkFBTyxrQkFBV2YsUUFBWDtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0NRLG1CQURELEdBQ1MsQ0FEVDtBQUFBLDJCQUVpQlIsUUFGakI7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBOztBQUFBO0FBQUE7O0FBQUE7QUFFUWYscUJBRlI7O0FBQUEsbUJBR0s4QixVQUFVOUIsT0FBVixFQUFpQnVCLEtBQWpCLENBSEw7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQSxxQkFJV3ZCLE9BSlg7O0FBQUE7QUFNQ3VCLHNCQUFRQSxRQUFRLENBQWhCOztBQU5EO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxLQUFQO0FBQUE7QUFTSDs7QUFDRHhCLFFBQVE4QixNQUFSLEdBQWlCQSxNQUFqQjs7QUFDQSxTQUFTRSxNQUFULENBQWdCRCxTQUFoQixFQUEyQkUsT0FBM0IsRUFBb0M7QUFDaEMsU0FBTyxVQUFVakIsUUFBVixFQUFvQjtBQUN2QixRQUFJUSxRQUFRLENBQVo7QUFDQSxRQUFJVSxZQUFZRCxPQUFoQjs7QUFDQSwwQkFBb0JqQixRQUFwQix5SEFBOEI7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBLFVBQW5CZixPQUFtQjtBQUMxQmlDLGtCQUFZSCxVQUFVRyxTQUFWLEVBQXFCakMsT0FBckIsRUFBNEJ1QixLQUE1QixDQUFaO0FBQ0FBLGNBQVFBLFFBQVEsQ0FBaEI7QUFDSDs7QUFDRCxXQUFPVSxTQUFQO0FBQ0gsR0FSRDtBQVNIOztBQUNEbEMsUUFBUWdDLE1BQVIsR0FBaUJBLE1BQWpCOztBQUNBLFNBQVNHLElBQVQsQ0FBY0osU0FBZCxFQUF5QkUsT0FBekIsRUFBa0M7QUFDOUI7QUFBQTtBQUFBLDRCQUFPLGtCQUFXakIsUUFBWDtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0NRLG1CQURELEdBQ1MsQ0FEVDtBQUVDVSx1QkFGRCxHQUVhRCxPQUZiO0FBQUEsMkJBR2lCakIsUUFIakI7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBOztBQUFBO0FBQUE7O0FBQUE7QUFHUWYscUJBSFI7QUFJQ2lDLDBCQUFZSCxVQUFVRyxTQUFWLEVBQXFCakMsT0FBckIsRUFBNEJ1QixLQUE1QixDQUFaO0FBSkQ7QUFBQSxxQkFLT1UsU0FMUDs7QUFBQTtBQU1DVixzQkFBUUEsUUFBUSxDQUFoQjs7QUFORDtBQUFBO0FBQUE7O0FBQUE7QUFBQSxnREFRSVUsU0FSSjs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxLQUFQO0FBQUE7QUFVSDs7QUFDRGxDLFFBQVFtQyxJQUFSLEdBQWVBLElBQWY7O0FBQ0EsU0FBU0MsSUFBVCxDQUFjTCxTQUFkLEVBQXlCO0FBQ3JCLFNBQU8sVUFBVWYsUUFBVixFQUFvQjtBQUFBLHNCQUNDcUIsTUFBTUMsSUFBTixDQUFXdEIsUUFBWCxDQUREO0FBQUEsUUFDaEJ1QixJQURnQjtBQUFBLFFBQ1BDLElBRE87O0FBRXZCLFdBQU9SLE9BQU9ELFNBQVAsRUFBa0JRLElBQWxCLEVBQXdCQyxJQUF4QixDQUFQO0FBQ0gsR0FIRDtBQUlIOztBQUNEeEMsUUFBUW9DLElBQVIsR0FBZUEsSUFBZjs7QUFDQSxTQUFTSyxJQUFULENBQWM1QixLQUFkLEVBQXFCO0FBQ2pCO0FBQUE7QUFBQSw0QkFBTyxrQkFBV0csUUFBWDtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0NGLGVBREQsR0FDSyxDQURMO0FBQUEsMkJBRWdCRSxRQUZoQjs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7O0FBQUE7QUFBQTs7QUFBQTtBQUVRQyxtQkFGUjs7QUFBQSxvQkFHS0gsS0FBS0QsS0FIVjtBQUFBO0FBQUE7QUFBQTs7QUFBQTs7QUFBQTtBQUFBO0FBQUEscUJBTU9JLEtBTlA7O0FBQUE7QUFPQ0gsa0JBQUlBLElBQUksQ0FBUjs7QUFQRDtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsS0FBUDtBQUFBO0FBVUg7O0FBQ0RkLFFBQVF5QyxJQUFSLEdBQWVBLElBQWY7O0FBQ0EsU0FBU0MsSUFBVCxDQUFjMUIsUUFBZCxFQUF3QjtBQUNwQixNQUFJMEIsT0FBT0MsU0FBWDs7QUFDQSx3QkFBbUIzQixRQUFuQix5SEFBNkI7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBLFFBQWxCQyxNQUFrQjtBQUN6QnlCLFdBQU96QixNQUFQO0FBQ0g7O0FBQ0QsU0FBT3lCLElBQVA7QUFDSDs7QUFDRDFDLFFBQVEwQyxJQUFSLEdBQWVBLElBQWY7O0FBQ0EsU0FBU0UsS0FBVCxDQUFlNUIsUUFBZixFQUF5QjtBQUNyQix5QkFBbUJBLFFBQW5CLGdJQUE2QjtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUEsUUFBbEJDLE1BQWtCO0FBQ3pCLFdBQU9BLE1BQVA7QUFDSDs7QUFDRCxTQUFPMEIsU0FBUDtBQUNIOztBQUNEM0MsUUFBUTRDLEtBQVIsR0FBZ0JBLEtBQWhCOztBQUNBLFNBQVNDLElBQVQsQ0FBY2hDLEtBQWQsRUFBcUI7QUFDakI7QUFBQTtBQUFBLDRCQUFPLGtCQUFXRyxRQUFYO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQ0YsZUFERCxHQUNLLENBREw7QUFBQSw0QkFFZ0JFLFFBRmhCOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTs7QUFBQTtBQUFBOztBQUFBO0FBRVFDLG9CQUZSOztBQUFBLG9CQUdLSCxLQUFLRCxLQUhWO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUEscUJBSVdJLE1BSlg7O0FBQUE7QUFNQ0gsa0JBQUlBLElBQUksQ0FBUjs7QUFORDtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsS0FBUDtBQUFBO0FBU0g7O0FBQ0RkLFFBQVE2QyxJQUFSLEdBQWVBLElBQWY7O0FBQ0EsU0FBU0MsU0FBVCxDQUFtQmYsU0FBbkIsRUFBOEI7QUFDMUI7QUFBQTtBQUFBLDRCQUFPLGtCQUFXZixRQUFYO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQ0YsZUFERCxHQUNLLENBREw7QUFBQSw0QkFFZ0JFLFFBRmhCOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTs7QUFBQTtBQUFBOztBQUFBO0FBRVFDLG9CQUZSOztBQUFBLGtCQUdNYyxVQUFVZCxNQUFWLEVBQWdCSCxDQUFoQixDQUhOO0FBQUE7QUFBQTtBQUFBOztBQUFBOztBQUFBO0FBQUE7QUFBQSxxQkFNT0csTUFOUDs7QUFBQTtBQU9DSCxrQkFBSUEsSUFBSSxDQUFSOztBQVBEO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxLQUFQO0FBQUE7QUFVSDs7QUFDRGQsUUFBUThDLFNBQVIsR0FBb0JBLFNBQXBCOztBQUNBLFNBQVNDLFNBQVQsQ0FBbUJoQixTQUFuQixFQUE4QjtBQUMxQjtBQUFBO0FBQUEsNEJBQU8sa0JBQVdmLFFBQVg7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNDRixlQURELEdBQ0ssQ0FETDtBQUFBLDRCQUVnQkUsUUFGaEI7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBOztBQUFBO0FBQUE7O0FBQUE7QUFFUUMsb0JBRlI7O0FBQUEsbUJBR0tjLFVBQVVkLE1BQVYsRUFBZ0JILENBQWhCLENBSEw7QUFBQTtBQUFBO0FBQUE7O0FBQUE7O0FBQUE7QUFBQTtBQUFBLHFCQU1PRyxNQU5QOztBQUFBO0FBT0NILGtCQUFJQSxJQUFJLENBQVI7O0FBUEQ7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEtBQVA7QUFBQTtBQVVIOztBQUNEZCxRQUFRK0MsU0FBUixHQUFvQkEsU0FBcEI7O0FBQ0EsU0FBU0MsU0FBVCxDQUFtQmpCLFNBQW5CLEVBQThCO0FBQzFCO0FBQUE7QUFBQSw0QkFBTyxtQkFBV2YsUUFBWDtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0NGLGVBREQsR0FDSyxDQURMO0FBRUNtQyx1QkFGRCxHQUVhLEtBRmI7QUFBQSw0QkFHZ0JqQyxRQUhoQjs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7O0FBQUE7QUFBQTs7QUFBQTtBQUdRQyxvQkFIUjs7QUFBQSxrQkFJTWdDLFNBSk47QUFBQTtBQUFBO0FBQUE7O0FBS0tBLDBCQUFZLENBQUNsQixVQUFVZCxNQUFWLEVBQWdCSCxDQUFoQixDQUFiOztBQUxMLG1CQU1TbUMsU0FOVDtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBLHFCQU9laEMsTUFQZjs7QUFBQTtBQVNLSCxrQkFBSUEsSUFBSSxDQUFSO0FBVEw7QUFBQTs7QUFBQTtBQUFBO0FBQUEscUJBWVdHLE1BWlg7O0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEtBQVA7QUFBQTtBQWdCSDs7QUFDRGpCLFFBQVFnRCxTQUFSLEdBQW9CQSxTQUFwQjs7QUFDQSxTQUFTRSxTQUFULENBQW1CbkIsU0FBbkIsRUFBOEI7QUFDMUI7QUFBQTtBQUFBLDRCQUFPLG1CQUFXZixRQUFYO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQ0YsZUFERCxHQUNLLENBREw7QUFFQ21DLHVCQUZELEdBRWEsS0FGYjtBQUFBLDRCQUdnQmpDLFFBSGhCOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTs7QUFBQTtBQUFBOztBQUFBO0FBR1FDLG9CQUhSOztBQUFBLGtCQUlNZ0MsU0FKTjtBQUFBO0FBQUE7QUFBQTs7QUFLS0EsMEJBQVlsQixVQUFVZCxNQUFWLEVBQWdCSCxDQUFoQixDQUFaOztBQUxMLG1CQU1TbUMsU0FOVDtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBLHFCQU9laEMsTUFQZjs7QUFBQTtBQVNLSCxrQkFBSUEsSUFBSSxDQUFSO0FBVEw7QUFBQTs7QUFBQTtBQUFBO0FBQUEscUJBWVdHLE1BWlg7O0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEtBQVA7QUFBQTtBQWdCSDs7QUFDRGpCLFFBQVFrRCxTQUFSLEdBQW9CQSxTQUFwQjs7QUFDQSxTQUFTekMsTUFBVCxHQUE4QjtBQUFBLG9DQUFYTSxTQUFXO0FBQVhBLGFBQVc7QUFBQTs7QUFDMUI7QUFBQTtBQUFBLDRCQUFPLG1CQUFXUSxFQUFYO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSw4Q0FDSUEsRUFESjs7QUFBQTtBQUFBOztBQUFBO0FBQUEsMkJBRW9CUixTQUZwQjtBQUFBO0FBQUE7QUFBQTs7QUFFUUMsc0JBRlIsR0FFb0JELFNBRnBCO0FBQUEsOENBR1FDLFFBSFI7O0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsS0FBUDtBQUFBO0FBS0g7O0FBQ0RoQixRQUFRUyxNQUFSLEdBQWlCQSxNQUFqQjs7QUFDQSxTQUFTMEMsSUFBVCxHQUF1QjtBQUFBLHFDQUFOQyxJQUFNO0FBQU5BLFFBQU07QUFBQTs7QUFDbkI7QUFBQTtBQUFBLDRCQUFPLG1CQUFXN0IsRUFBWDtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsOENBQ0lBLEVBREo7O0FBQUE7QUFBQTs7QUFBQTtBQUFBLDJCQUVvQjZCLElBRnBCO0FBQUE7QUFBQTtBQUFBOztBQUVRcEMsc0JBRlIsR0FFb0JvQyxJQUZwQjtBQUFBO0FBQUEscUJBR09wQyxRQUhQOztBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEtBQVA7QUFBQTtBQUtIOztBQUNEaEIsUUFBUW1ELElBQVIsR0FBZUEsSUFBZjs7QUFDQSxTQUFTRSxPQUFULEdBQTBCO0FBQUEscUNBQU5ELElBQU07QUFBTkEsUUFBTTtBQUFBOztBQUN0QjtBQUFBO0FBQUEsNEJBQU8sbUJBQVc3QixFQUFYO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNNVCxlQUROLEdBQ1UsQ0FEVjs7QUFBQTtBQUFBLG9CQUNhQSxJQUFJc0MsS0FBS0UsTUFEdEI7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQSxxQkFFT0YsS0FBS0EsS0FBS0UsTUFBTCxHQUFjeEMsQ0FBZCxHQUFrQixDQUF2QixDQUZQOztBQUFBO0FBQzhCLGdCQUFFQSxDQURoQztBQUFBO0FBQUE7O0FBQUE7QUFBQSw4Q0FHSVMsRUFISjs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxLQUFQO0FBQUE7QUFLSDs7QUFDRHZCLFFBQVFxRCxPQUFSLEdBQWtCQSxPQUFsQjs7QUFDQSxTQUFTRSxJQUFULENBQWN4QixTQUFkLEVBQXlCO0FBQ3JCLFNBQU8sY0FBTTtBQUNULFFBQUlqQixJQUFJLENBQVI7O0FBQ0EsMkJBQW1CUyxFQUFuQixnSUFBdUI7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBLFVBQVpOLE1BQVk7O0FBQ25CLFVBQUljLFVBQVVkLE1BQVYsRUFBZ0JILENBQWhCLENBQUosRUFBd0I7QUFDcEIsZUFBTyxJQUFQO0FBQ0g7O0FBQ0RBLFVBQUlBLElBQUksQ0FBUjtBQUNIOztBQUNELFdBQU8sS0FBUDtBQUNILEdBVEQ7QUFVSDs7QUFDRGQsUUFBUXVELElBQVIsR0FBZUEsSUFBZjs7QUFDQSxTQUFTQyxLQUFULENBQWV6QixTQUFmLEVBQTBCO0FBQ3RCLFNBQU8sY0FBTTtBQUNULFFBQUlqQixJQUFJLENBQVI7O0FBQ0EsMkJBQW1CUyxFQUFuQixnSUFBdUI7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBLFVBQVpOLE9BQVk7O0FBQ25CLFVBQUksQ0FBQ2MsVUFBVWQsT0FBVixFQUFnQkgsQ0FBaEIsQ0FBTCxFQUF5QjtBQUNyQixlQUFPLEtBQVA7QUFDSDs7QUFDREEsVUFBSUEsSUFBSSxDQUFSO0FBQ0g7O0FBQ0QsV0FBTyxJQUFQO0FBQ0gsR0FURDtBQVVIOztBQUNEZCxRQUFRd0QsS0FBUixHQUFnQkEsS0FBaEI7O0FBQ0EsU0FBVXBDLFFBQVYsQ0FBbUJHLEVBQW5CO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDVWtDLG1CQURWLEdBQ3NCLElBQUlDLEdBQUosRUFEdEI7QUFBQSx3QkFFdUJuQyxFQUZ2Qjs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7O0FBQUE7QUFBQTs7QUFBQTtBQUVlTixpQkFGZjs7QUFBQSxjQUdhd0MsVUFBVUUsR0FBVixDQUFjMUMsT0FBZCxDQUhiO0FBQUE7QUFBQTtBQUFBOztBQUlZd0Msb0JBQVVHLEdBQVYsQ0FBYzNDLE9BQWQ7QUFKWjtBQUFBLGlCQUtrQkEsT0FMbEI7O0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQVNBakIsUUFBUW9CLFFBQVIsR0FBbUJBLFFBQW5CLEMsQ0FDQSxxQzs7Ozs7Ozs7QUN4UEE7O0FBQ0F0QixPQUFPQyxjQUFQLENBQXNCQyxPQUF0QixFQUErQixZQUEvQixFQUE2QztBQUFFQyxTQUFPO0FBQVQsQ0FBN0M7O0FBQ0FELFFBQVFLLEVBQVIsR0FBYSxVQUFDd0QsQ0FBRDtBQUFBLFNBQVE7QUFDakJDLE9BQUcsV0FBQ3JDLEdBQUQ7QUFBQSxhQUFTekIsUUFBUUssRUFBUixDQUFXb0IsSUFBSW9DLENBQUosQ0FBWCxDQUFUO0FBQUEsS0FEYztBQUVqQnhELFFBQUksWUFBQ29CLEdBQUQ7QUFBQSxhQUFTQSxJQUFJb0MsQ0FBSixDQUFUO0FBQUE7QUFGYSxHQUFSO0FBQUEsQ0FBYixDLENBSUEsZ0M7Ozs7Ozs7O0FDTkE7Ozs7QUFDQS9ELE9BQU9DLGNBQVAsQ0FBc0JDLE9BQXRCLEVBQStCLFlBQS9CLEVBQTZDO0FBQUVDLFNBQU87QUFBVCxDQUE3Qzs7QUFDQSxJQUFNOEQsV0FBVyxtQkFBQXJFLENBQVEsc0NBQVIsQ0FBakI7O0lBQ01zRSxjOzs7QUFDRiw0QkFBYztBQUNWLFNBQUtDLE1BQUwsR0FBYyxFQUFkO0FBQ0EsU0FBS0MsWUFBTCxHQUFvQixFQUFwQjtBQUNBLFNBQUtDLEtBQUwsR0FBYSxFQUFiO0FBQ0EsU0FBS0MsS0FBTCxHQUFhLEVBQWI7QUFDSDs7OztTQUNEQyxRLHFCQUFTQyxFLEVBQUlDLEksRUFBTTtBQUNmLFdBQU9DLFFBQVFDLE9BQVIsRUFBUDtBQUNILEc7O1NBQ0RDLGMsMkJBQWVKLEUsRUFBSUMsSSxFQUFNO0FBQ3JCLFFBQU1JLFFBQVEsS0FBS1QsWUFBTCxDQUFrQkksRUFBbEIsQ0FBZDs7QUFDQSxRQUFJSyxLQUFKLEVBQVc7QUFDUCxhQUFPQSxLQUFQO0FBQ0gsS0FGRCxNQUdLO0FBQ0QsVUFBTUMsT0FBTyxJQUFJYixTQUFTYyxJQUFiLENBQWtCO0FBQUVDLGFBQUtQLFFBQVEsZUFBYUQsRUFBYix5QkFBbUNBLEVBQW5DLDBCQUEwREEsRUFBMUQseUJBQWdGQSxFQUFoRjtBQUFmLE9BQWxCLENBQWI7QUFDQSxhQUFPLEtBQUtKLFlBQUwsQ0FBa0JJLEVBQWxCLElBQXdCO0FBQUVNLGtCQUFGO0FBQVFHLGNBQU1UO0FBQWQsT0FBL0I7QUFDSDtBQUNKLEc7O1NBQ0tVLGU7Ozs7OzZDQUFnQlYsRSxFQUFJQyxJOzs7Ozs7QUFDaEJJLG1CLEdBQVEsS0FBS1QsWUFBTCxDQUFrQkksRUFBbEIsQzs7bUJBQ1ZLLEs7Ozs7OytDQUNPQSxLOzs7O3FCQUdZTSxpQkFBaUJWLElBQWpCLEM7OztBQUFiSyxrQjsrQ0FDQyxLQUFLVixZQUFMLENBQWtCSSxFQUFsQixJQUF3QjtBQUFFTSwwQkFBRjtBQUFRRyxzQkFBTVQ7QUFBZCxlOzs7Ozs7Ozs7Ozs7Ozs7U0FHdkNZLFEscUJBQVNaLEUsRUFBSUMsSSxFQUFNO0FBQ2YsUUFBTVksUUFBUSxLQUFLbEIsTUFBTCxDQUFZSyxFQUFaLENBQWQ7O0FBQ0EsUUFBSWEsU0FBUyxJQUFiLEVBQW1CO0FBQ2YsYUFBT0EsS0FBUDtBQUNILEtBRkQsTUFHSztBQUNELFVBQU1DLE1BQU0sSUFBSUMsS0FBSixFQUFaO0FBQ0FELFVBQUlOLEdBQUosR0FBVVAsc0JBQW9CRCxFQUFwQixTQUFWO0FBQ0EsV0FBS0wsTUFBTCxDQUFZSyxFQUFaLElBQWtCYyxHQUFsQjtBQUNBLGFBQU9BLEdBQVA7QUFDSDtBQUNKLEc7O1NBQ0tFLFM7Ozs7OzhDQUFVaEIsRSxFQUFJQyxJOzs7Ozs7QUFDVmdCLGdDLEdBQXFCLEtBQUt0QixNQUFMLENBQVlLLEVBQVosQzs7b0JBQ3ZCaUIsc0JBQXNCLEk7Ozs7O2dEQUNmQSxrQjs7OztxQkFHYUMsaUJBQWlCakIsSUFBakIsQzs7O0FBQWRZLG1CO0FBQ04sbUJBQUtsQixNQUFMLENBQVlLLEVBQVosSUFBa0JhLEtBQWxCO2dEQUNPQSxLOzs7Ozs7Ozs7Ozs7Ozs7U0FHZk0sUSxxQkFBU25CLEUsRUFBSUMsSSxFQUFNO0FBQ2YsUUFBTUksUUFBUSxLQUFLUixLQUFMLENBQVdHLEVBQVgsQ0FBZDs7QUFDQSxRQUFJSyxLQUFKLEVBQVc7QUFDUCxhQUFPQSxLQUFQO0FBQ0gsS0FGRCxNQUdLO0FBQ0QsVUFBTUMsT0FBTyxJQUFJYixTQUFTYyxJQUFiLENBQWtCO0FBQUVDLGFBQUtQLFFBQVEsZUFBYUQsRUFBYix5QkFBbUNBLEVBQW5DLDBCQUEwREEsRUFBMUQseUJBQWdGQSxFQUFoRjtBQUFmLE9BQWxCLENBQWI7QUFDQSxhQUFPLEtBQUtILEtBQUwsQ0FBV0csRUFBWCxJQUFpQjtBQUFFTSxrQkFBRjtBQUFRRyxjQUFNVDtBQUFkLE9BQXhCO0FBQ0g7QUFDSixHOztTQUNLb0IsUzs7Ozs7OENBQVVwQixFLEVBQUlDLEk7Ozs7OztBQUNWSSxtQixHQUFRLEtBQUtSLEtBQUwsQ0FBV0csRUFBWCxDOzttQkFDVkssSzs7Ozs7Z0RBQ09BLEs7Ozs7cUJBR1lNLGlCQUFpQlYsSUFBakIsQzs7O0FBQWJLLGtCO2dEQUNDLEtBQUtULEtBQUwsQ0FBV0csRUFBWCxJQUFpQjtBQUFFTSwwQkFBRjtBQUFRRyxzQkFBTVQ7QUFBZCxlOzs7Ozs7Ozs7Ozs7Ozs7U0FHaENxQixPLG9CQUFRckIsRSxFQUFJQyxJLEVBQU1xQixRLEVBQVU7QUFDeEIsUUFBTUMsUUFBUSxLQUFLekIsS0FBTCxDQUFXRSxFQUFYLENBQWQ7O0FBQ0EsUUFBSXVCLFNBQVMsSUFBYixFQUFtQjtBQUNmLGFBQU9BLEtBQVA7QUFDSCxLQUZELE1BR0s7QUFDRCxVQUFJRCxZQUFZLElBQWhCLEVBQXNCO0FBQ2xCLGFBQUt4QixLQUFMLENBQVdFLEVBQVgsSUFBaUJzQixRQUFqQjtBQUNIOztBQUNELGFBQU9BLFFBQVA7QUFDSDtBQUNKLEc7O1NBQ0tFLFE7Ozs7OzhDQUFTeEIsRSxFQUFJQyxJLEVBQU1xQixROzs7Ozs7QUFDZkMsbUIsR0FBUSxLQUFLekIsS0FBTCxDQUFXRSxFQUFYLEM7O29CQUNWdUIsU0FBUyxJOzs7OztnREFDRkEsSzs7OztxQkFFVUUsTUFBTXhCLElBQU4sQzs7O0FBQWZ5QixvQjs7b0JBQ0ZBLE9BQU9DLE1BQVAsR0FBZ0IsR0FBaEIsSUFBdUJELE9BQU9DLE1BQVAsSUFBaUIsRzs7Ozs7b0JBQ3BDTCxZQUFZLEk7Ozs7O0FBQ1osbUJBQUt4QixLQUFMLENBQVdFLEVBQVgsSUFBaUJzQixRQUFqQjtnREFDT0EsUTs7O29CQUdELElBQUkvRixLQUFKLGlDQUF3Q3lFLEVBQXhDLFVBQStDQyxJQUEvQyxPOzs7Ozs7OztxQkFJU3lCLE9BQU9FLElBQVAsRTs7O0FBQWJDLGtCO0FBQ04sbUJBQUsvQixLQUFMLENBQVdFLEVBQVgsSUFBaUI2QixJQUFqQjtnREFDT0EsSTs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBSW5CbkcsUUFBUWdFLGNBQVIsR0FBeUJBLGNBQXpCOztBQUNBLFNBQVN3QixnQkFBVCxDQUEwQmpCLElBQTFCLEVBQWdDO0FBQzVCLFNBQU8sSUFBSUMsT0FBSixDQUFZLFVBQUNDLE9BQUQsRUFBVTJCLE1BQVYsRUFBcUI7QUFDcEMsUUFBTWhCLE1BQU0sSUFBSUMsS0FBSixFQUFaOztBQUNBRCxRQUFJaUIsTUFBSixHQUFhO0FBQUEsYUFBTTVCLFFBQVFXLEdBQVIsQ0FBTjtBQUFBLEtBQWI7O0FBQ0FBLFFBQUlrQixPQUFKLEdBQWM7QUFBQSxhQUFNRixRQUFOO0FBQUEsS0FBZDs7QUFDQWhCLFFBQUlOLEdBQUosR0FBVVAsSUFBVjtBQUNILEdBTE0sQ0FBUDtBQU1IOztBQUNELFNBQVNVLGdCQUFULENBQTBCVixJQUExQixFQUFnQztBQUM1QixTQUFPLElBQUlDLE9BQUosQ0FBWSxVQUFDQyxPQUFELEVBQVUyQixNQUFWLEVBQXFCO0FBQ3BDLFFBQU14QixPQUFPLElBQUliLFNBQVNjLElBQWIsQ0FBa0I7QUFBRUMsV0FBSyxDQUFDUCxJQUFELENBQVA7QUFBZWdDLGFBQU87QUFBdEIsS0FBbEIsQ0FBYjs7QUFDQSxRQUFJM0IsS0FBSzRCLEtBQUwsT0FBaUIsUUFBckIsRUFBK0I7QUFDM0IsYUFBTzVCLElBQVA7QUFDSCxLQUZELE1BR0s7QUFDREEsV0FBSzZCLElBQUwsQ0FBVSxNQUFWLEVBQWtCO0FBQUEsZUFBTWhDLFFBQVFHLElBQVIsQ0FBTjtBQUFBLE9BQWxCO0FBQ0FBLFdBQUs2QixJQUFMLENBQVUsV0FBVixFQUF1QixVQUFDbkMsRUFBRCxFQUFLb0MsR0FBTDtBQUFBLGVBQWFOLE9BQU9NLEdBQVAsQ0FBYjtBQUFBLE9BQXZCO0FBQ0E5QixXQUFLK0IsSUFBTDtBQUNBLGFBQU8vQixJQUFQO0FBQ0g7QUFDSixHQVhNLENBQVA7QUFZSCxDOzs7Ozs7OztBQ3BJRDs7QUFDQTlFLE9BQU9DLGNBQVAsQ0FBc0JDLE9BQXRCLEVBQStCLFlBQS9CLEVBQTZDO0FBQUVDLFNBQU87QUFBVCxDQUE3Qzs7QUFDQUQsUUFBUTRHLG1CQUFSLEdBQThCLFVBQUNoRyxLQUFELEVBQVFpRyxHQUFSO0FBQUEsU0FBZ0I7QUFBQSxXQUFjakcsUUFBUSxDQUFDaUcsTUFBTWpHLEtBQVAsSUFBZ0JrRyxVQUF0QztBQUFBLEdBQWhCO0FBQUEsQ0FBOUI7O0FBQ0E5RyxRQUFRK0csbUJBQVIsR0FBOEIsVUFBQ25HLEtBQUQsRUFBUWlHLEdBQVI7QUFBQSxTQUFnQixzQkFBYztBQUN4RCxRQUFNRyxNQUFNLENBQUMsSUFBSUMsS0FBS0MsR0FBTCxDQUFTSixhQUFhRyxLQUFLRSxFQUEzQixDQUFMLElBQXVDLENBQW5EO0FBQ0EsV0FBUXZHLFNBQVMsSUFBSW9HLEdBQWIsSUFBb0JILE1BQU1HLEdBQWxDO0FBQ0gsR0FINkI7QUFBQSxDQUE5Qjs7QUFJQWhILFFBQVFvSCx3QkFBUixHQUFtQztBQUFBLFNBQVMsVUFBQ3hHLEtBQUQsRUFBUWlHLEdBQVI7QUFBQSxXQUFnQjtBQUFBLGFBQWM3RyxRQUFRNEcsbUJBQVIsQ0FBNEJoRyxLQUE1QixFQUFtQ2lHLEdBQW5DLFdBQXdDQyxVQUF4QyxFQUFzRE8sS0FBdEQsRUFBZDtBQUFBLEtBQWhCO0FBQUEsR0FBVDtBQUFBLENBQW5DLEM7Ozs7Ozs7O0FDUEE7O0FBQ0F2SCxPQUFPQyxjQUFQLENBQXNCQyxPQUF0QixFQUErQixZQUEvQixFQUE2QztBQUFFQyxTQUFPO0FBQVQsQ0FBN0M7O0FBQ0EsSUFBTXFILHdCQUF3QixtQkFBQTVILENBQVEsK0RBQVIsQ0FBOUI7O0FBQ0EsU0FBUzZILEdBQVQsT0FBdUI7QUFBQSxNQUFSMUQsQ0FBUSxRQUFSQSxDQUFRO0FBQUEsTUFBTDJELENBQUssUUFBTEEsQ0FBSztBQUNuQixTQUFPO0FBQ0gzRCxPQUFHb0QsS0FBS00sR0FBTCxDQUFTMUQsQ0FBVCxDQURBO0FBRUgyRCxPQUFHUCxLQUFLTSxHQUFMLENBQVNDLENBQVQ7QUFGQSxHQUFQO0FBSUg7O0FBQ0R4SCxRQUFRdUgsR0FBUixHQUFjQSxHQUFkOztBQUNBLFNBQVNFLE1BQVQsUUFBMEI7QUFBQSxNQUFSNUQsQ0FBUSxTQUFSQSxDQUFRO0FBQUEsTUFBTDJELENBQUssU0FBTEEsQ0FBSztBQUN0QixTQUFPO0FBQ0gzRCxPQUFHLENBQUNBLENBREQ7QUFFSDJELE9BQUcsQ0FBQ0E7QUFGRCxHQUFQO0FBSUg7O0FBQ0R4SCxRQUFReUgsTUFBUixHQUFpQkEsTUFBakI7O0FBQ0EsU0FBUzdELEdBQVQsQ0FBYThELEdBQWIsRUFBa0JDLEdBQWxCLEVBQXVCO0FBQ25CLFNBQU87QUFDSDlELE9BQUc2RCxJQUFJN0QsQ0FBSixHQUFROEQsSUFBSTlELENBRFo7QUFFSDJELE9BQUdFLElBQUlGLENBQUosR0FBUUcsSUFBSUg7QUFGWixHQUFQO0FBSUg7O0FBQ0R4SCxRQUFRNEQsR0FBUixHQUFjQSxHQUFkOztBQUNBLFNBQVNnRSxRQUFULENBQWtCRixHQUFsQixFQUF1QkMsR0FBdkIsRUFBNEI7QUFDeEIsU0FBTztBQUNIOUQsT0FBRzZELElBQUk3RCxDQUFKLEdBQVE4RCxJQUFJOUQsQ0FEWjtBQUVIMkQsT0FBR0UsSUFBSUYsQ0FBSixHQUFRRyxJQUFJSDtBQUZaLEdBQVA7QUFJSDs7QUFDRHhILFFBQVE0SCxRQUFSLEdBQW1CQSxRQUFuQjs7QUFDQSxTQUFTQyxRQUFULENBQWtCSCxHQUFsQixFQUF1QkMsR0FBdkIsRUFBNEI7QUFDeEIsU0FBTztBQUNIOUQsT0FBRzZELElBQUk3RCxDQUFKLEdBQVE4RCxHQURSO0FBRUhILE9BQUdFLElBQUlGLENBQUosR0FBUUc7QUFGUixHQUFQO0FBSUg7O0FBQ0QzSCxRQUFRNkgsUUFBUixHQUFtQkEsUUFBbkI7O0FBQ0EsU0FBU0MsR0FBVCxDQUFhSixHQUFiLEVBQWtCQyxHQUFsQixFQUF1QjtBQUNuQixTQUFPO0FBQ0g5RCxPQUFHNkQsSUFBSTdELENBQUosR0FBUThELElBQUk5RCxDQURaO0FBRUgyRCxPQUFHRSxJQUFJRixDQUFKLEdBQVFHLElBQUlIO0FBRlosR0FBUDtBQUlIOztBQUNEeEgsUUFBUThILEdBQVIsR0FBY0EsR0FBZDs7QUFDQSxTQUFTQyxNQUFULENBQWdCTCxHQUFoQixFQUFxQkMsR0FBckIsRUFBMEI7QUFDdEIsU0FBTztBQUNIOUQsT0FBRzZELElBQUk3RCxDQUFKLEdBQVE4RCxHQURSO0FBRUhILE9BQUdFLElBQUlGLENBQUosR0FBUUc7QUFGUixHQUFQO0FBSUg7O0FBQ0QzSCxRQUFRK0gsTUFBUixHQUFpQkEsTUFBakI7O0FBQ0EsU0FBU0MsZ0JBQVQsQ0FBMEJOLEdBQTFCLEVBQStCO0FBQzNCLFNBQU9BLElBQUk3RCxDQUFKLEdBQVE2RCxJQUFJN0QsQ0FBWixHQUFnQjZELElBQUlGLENBQUosR0FBUUUsSUFBSUYsQ0FBbkM7QUFDSDs7QUFDRHhILFFBQVFnSSxnQkFBUixHQUEyQkEsZ0JBQTNCOztBQUNBLFNBQVNDLFNBQVQsQ0FBbUJQLEdBQW5CLEVBQXdCO0FBQ3BCLFNBQU9ULEtBQUtpQixJQUFMLENBQVVGLGlCQUFpQk4sR0FBakIsQ0FBVixDQUFQO0FBQ0g7O0FBQ0QxSCxRQUFRaUksU0FBUixHQUFvQkEsU0FBcEI7O0FBQ0EsU0FBU0UsU0FBVCxDQUFtQlQsR0FBbkIsRUFBd0I7QUFDcEIsU0FBT0ssT0FBT0wsR0FBUCxFQUFZTyxVQUFVUCxHQUFWLENBQVosQ0FBUDtBQUNIOztBQUNEMUgsUUFBUW1JLFNBQVIsR0FBb0JBLFNBQXBCOztBQUNBLFNBQVNDLFVBQVQsQ0FBb0JWLEdBQXBCLEVBQXlCQyxHQUF6QixFQUE4QjtBQUMxQixTQUFPRCxJQUFJN0QsQ0FBSixHQUFROEQsSUFBSTlELENBQVosR0FBZ0I2RCxJQUFJRixDQUFKLEdBQVFHLElBQUlILENBQW5DO0FBQ0g7O0FBQ0R4SCxRQUFRb0ksVUFBUixHQUFxQkEsVUFBckI7O0FBQ0EsU0FBU0MsTUFBVCxDQUFnQlgsR0FBaEIsRUFBcUI7QUFDakIsU0FBTztBQUNIN0QsT0FBRyxDQUFDNkQsSUFBSUYsQ0FETDtBQUVIQSxPQUFHRSxJQUFJN0Q7QUFGSixHQUFQO0FBSUg7O0FBQ0Q3RCxRQUFRcUksTUFBUixHQUFpQkEsTUFBakI7O0FBQ0EsU0FBU0MsVUFBVCxDQUFvQkMsT0FBcEIsRUFBNkJDLFdBQTdCLEVBQTBDO0FBQ3RDLFNBQU87QUFBQSxXQUFRO0FBQ1gzRSxTQUFHb0QsS0FBS3dCLEdBQUwsQ0FBU3hCLEtBQUt5QixHQUFMLENBQVNILFFBQVExRSxDQUFqQixFQUFvQjZELElBQUk3RCxDQUF4QixDQUFULEVBQXFDMkUsWUFBWTNFLENBQWpELENBRFE7QUFFWDJELFNBQUdQLEtBQUt3QixHQUFMLENBQVN4QixLQUFLeUIsR0FBTCxDQUFTSCxRQUFRZixDQUFqQixFQUFvQkUsSUFBSUYsQ0FBeEIsQ0FBVCxFQUFxQ2dCLFlBQVloQixDQUFqRDtBQUZRLEtBQVI7QUFBQSxHQUFQO0FBSUg7O0FBQ0R4SCxRQUFRc0ksVUFBUixHQUFxQkEsVUFBckI7O0FBQ0EsU0FBU0ssWUFBVCxDQUFzQmpCLEdBQXRCLEVBQTJCQyxHQUEzQixFQUFnQztBQUM1QixTQUFPRCxJQUFJN0QsQ0FBSixHQUFROEQsSUFBSUgsQ0FBWixHQUFnQkUsSUFBSUYsQ0FBSixHQUFRRyxJQUFJOUQsQ0FBbkM7QUFDSDs7QUFDRDdELFFBQVEySSxZQUFSLEdBQXVCQSxZQUF2Qjs7QUFDQSxTQUFTL0IsbUJBQVQsQ0FBNkJjLEdBQTdCLEVBQWtDQyxHQUFsQyxFQUF1QztBQUNuQyxNQUFNaUIsZUFBZXRCLHNCQUFzQlYsbUJBQXRCLENBQTBDYyxJQUFJN0QsQ0FBOUMsRUFBaUQ4RCxJQUFJOUQsQ0FBckQsQ0FBckI7QUFDQSxNQUFNZ0YsZUFBZXZCLHNCQUFzQlYsbUJBQXRCLENBQTBDYyxJQUFJRixDQUE5QyxFQUFpREcsSUFBSUgsQ0FBckQsQ0FBckI7QUFDQSxTQUFPO0FBQUEsV0FBZTtBQUFFM0QsU0FBRytFLGFBQWE5QixVQUFiLENBQUw7QUFBK0JVLFNBQUdxQixhQUFhL0IsVUFBYjtBQUFsQyxLQUFmO0FBQUEsR0FBUDtBQUNIOztBQUNEOUcsUUFBUTRHLG1CQUFSLEdBQThCQSxtQkFBOUI7O0FBQ0EsU0FBU0csbUJBQVQsQ0FBNkJXLEdBQTdCLEVBQWtDQyxHQUFsQyxFQUF1QztBQUNuQyxNQUFNaUIsZUFBZXRCLHNCQUFzQlAsbUJBQXRCLENBQTBDVyxJQUFJN0QsQ0FBOUMsRUFBaUQ4RCxJQUFJOUQsQ0FBckQsQ0FBckI7QUFDQSxNQUFNZ0YsZUFBZXZCLHNCQUFzQlAsbUJBQXRCLENBQTBDVyxJQUFJRixDQUE5QyxFQUFpREcsSUFBSUgsQ0FBckQsQ0FBckI7QUFDQSxTQUFPO0FBQUEsV0FBZTtBQUFFM0QsU0FBRytFLGFBQWE5QixVQUFiLENBQUw7QUFBK0JVLFNBQUdxQixhQUFhL0IsVUFBYjtBQUFsQyxLQUFmO0FBQUEsR0FBUDtBQUNIOztBQUNEOUcsUUFBUStHLG1CQUFSLEdBQThCQSxtQkFBOUI7O0FBQ0EsU0FBU0ssd0JBQVQsQ0FBa0MwQixRQUFsQyxFQUE0QztBQUN4QyxNQUFNQywwQkFBMEJ6QixzQkFBc0JGLHdCQUF0QixDQUErQzBCLFFBQS9DLENBQWhDO0FBQ0EsU0FBTyxVQUFDcEIsR0FBRCxFQUFNQyxHQUFOLEVBQWM7QUFDakIsUUFBTWlCLGVBQWVHLHdCQUF3QnJCLElBQUk3RCxDQUE1QixFQUErQjhELElBQUk5RCxDQUFuQyxDQUFyQjtBQUNBLFFBQU1nRixlQUFlRSx3QkFBd0JyQixJQUFJRixDQUE1QixFQUErQkcsSUFBSUgsQ0FBbkMsQ0FBckI7QUFDQSxXQUFPO0FBQUEsYUFBZTtBQUFFM0QsV0FBRytFLGFBQWE5QixVQUFiLENBQUw7QUFBK0JVLFdBQUdxQixhQUFhL0IsVUFBYjtBQUFsQyxPQUFmO0FBQUEsS0FBUDtBQUNILEdBSkQ7QUFLSDs7QUFDRDlHLFFBQVFvSCx3QkFBUixHQUFtQ0Esd0JBQW5DLEM7Ozs7Ozs7O0FDMUdBOztBQUNBdEgsT0FBT0MsY0FBUCxDQUFzQkMsT0FBdEIsRUFBK0IsWUFBL0IsRUFBNkM7QUFBRUMsU0FBTztBQUFULENBQTdDOztBQUNBLElBQU0rSSxPQUFPLG1CQUFBdEosQ0FBUSw2REFBUixDQUFiOztBQUNBLElBQU1pQixTQUFTLG1CQUFBakIsQ0FBUSwrREFBUixDQUFmOztBQUNBTSxRQUFRaUosT0FBUixHQUFrQm5KLE9BQU9vSixNQUFQLENBQWMsVUFBQ3JGLENBQUQsRUFBSTJELENBQUo7QUFBQSxTQUFXO0FBQUUzRCxRQUFGO0FBQUsyRDtBQUFMLEdBQVg7QUFBQSxDQUFkLEVBQW9DMUgsT0FBT29KLE1BQVAsQ0FBYyxFQUFkLEVBQWtCRixJQUFsQixFQUF3QnJJLE1BQXhCLENBQXBDLENBQWxCLEM7Ozs7Ozs7O0FDSkE7O0FBQ0FiLE9BQU9DLGNBQVAsQ0FBc0JDLE9BQXRCLEVBQStCLFlBQS9CLEVBQTZDO0FBQUVDLFNBQU87QUFBVCxDQUE3QztBQUNBRCxRQUFRbUosSUFBUixHQUFlO0FBQUV0RixLQUFHLENBQUw7QUFBUTJELEtBQUc7QUFBWCxDQUFmO0FBQ0F4SCxRQUFRb0osSUFBUixHQUFlO0FBQUV2RixLQUFHb0QsS0FBS2lCLElBQUwsQ0FBVSxHQUFWLENBQUw7QUFBcUJWLEtBQUdQLEtBQUtpQixJQUFMLENBQVUsR0FBVjtBQUF4QixDQUFmLEM7Ozs7Ozs7O0FDSEE7O0FBQ0FwSSxPQUFPQyxjQUFQLENBQXNCQyxPQUF0QixFQUErQixZQUEvQixFQUE2QztBQUFFQyxTQUFPO0FBQVQsQ0FBN0M7O0FBQ0EsU0FBU29KLFdBQVQsQ0FBcUJDLE1BQXJCLEVBQTZCO0FBQ3pCLFNBQU87QUFDSHpGLE9BQUd5RixPQUFPekYsQ0FBUCxHQUFXeUYsT0FBT0MsTUFEbEI7QUFFSC9CLE9BQUc4QixPQUFPOUIsQ0FBUCxHQUFXOEIsT0FBT0MsTUFGbEI7QUFHSEMsV0FBT0YsT0FBT0MsTUFBUCxHQUFnQixDQUhwQjtBQUlIRSxZQUFRSCxPQUFPQyxNQUFQLEdBQWdCO0FBSnJCLEdBQVA7QUFNSDs7QUFDRHZKLFFBQVFxSixXQUFSLEdBQXNCQSxXQUF0QixDOzs7Ozs7OztBQ1ZBOztBQUNBdkosT0FBT0MsY0FBUCxDQUFzQkMsT0FBdEIsRUFBK0IsWUFBL0IsRUFBNkM7QUFBRUMsU0FBTztBQUFULENBQTdDOztBQUNBLFNBQVN5SixFQUFULENBQVlDLFFBQVosRUFBc0I7QUFDbEIsU0FBT0EsU0FBU0osTUFBVCxJQUFtQixJQUFuQixJQUEyQkksU0FBUzlGLENBQVQsSUFBYyxJQUF6QyxJQUFpRDhGLFNBQVNuQyxDQUFULElBQWMsSUFBdEU7QUFDSDs7QUFDRHhILFFBQVEwSixFQUFSLEdBQWFBLEVBQWIsQzs7Ozs7Ozs7QUNMQTs7QUFDQTVKLE9BQU9DLGNBQVAsQ0FBc0JDLE9BQXRCLEVBQStCLFlBQS9CLEVBQTZDO0FBQUVDLFNBQU87QUFBVCxDQUE3Qzs7QUFDQSxJQUFNMkosV0FBVyxtQkFBQWxLLENBQVEseUVBQVIsQ0FBakI7O0FBQ0EsSUFBTWdLLEtBQUssbUJBQUFoSyxDQUFRLG1FQUFSLENBQVg7O0FBQ0EsSUFBTW1LLFNBQVMsbUJBQUFuSyxDQUFRLHVFQUFSLENBQWY7O0FBQ0EsSUFBTW9LLFVBQVUsbUJBQUFwSyxDQUFRLHdFQUFSLENBQWhCOztBQUNBTSxRQUFRK0osTUFBUixHQUFpQmpLLE9BQU9vSixNQUFQLENBQWMsVUFBQ3JGLENBQUQsRUFBSTJELENBQUosRUFBTytCLE1BQVA7QUFBQSxTQUFtQjtBQUFFMUYsUUFBRjtBQUFLMkQsUUFBTDtBQUFRK0I7QUFBUixHQUFuQjtBQUFBLENBQWQsRUFBb0R6SixPQUFPb0osTUFBUCxDQUFjLEVBQWQsRUFBa0JVLFFBQWxCLEVBQTRCRixFQUE1QixFQUFnQ0ksT0FBaEMsRUFBeUNELE1BQXpDLENBQXBELENBQWpCLEM7Ozs7Ozs7O0FDTkE7O0FBQ0EvSixPQUFPQyxjQUFQLENBQXNCQyxPQUF0QixFQUErQixZQUEvQixFQUE2QztBQUFFQyxTQUFPO0FBQVQsQ0FBN0M7O0FBQ0EsSUFBTStKLHNCQUFzQixtQkFBQXRLLENBQVEsNkRBQVIsQ0FBNUI7O0FBQ0EsSUFBTXVLLGtCQUFrQixtQkFBQXZLLENBQVEsK0RBQVIsQ0FBeEI7O0FBQ0EsSUFBTXdLLHNCQUFzQixtQkFBQXhLLENBQVEsbUVBQVIsQ0FBNUI7O0FBQ0EsSUFBTXlLLHVCQUF1QixtQkFBQXpLLENBQVEseUVBQVIsQ0FBN0I7O0FBQ0EsSUFBTTBLLDJCQUEyQixtQkFBQTFLLENBQVEsNkVBQVIsQ0FBakM7O0FBQ0EsSUFBTTJLLHNCQUFzQixtQkFBQTNLLENBQVEsdUVBQVIsQ0FBNUI7O0FBQ0EsSUFBTTRLLG9CQUFvQixtQkFBQTVLLENBQVEsbUVBQVIsQ0FBMUI7O0FBQ0EsU0FBU21LLE1BQVQsQ0FBZ0JuQyxHQUFoQixFQUFxQkMsR0FBckIsRUFBMEI7QUFDdEIsTUFBSXNDLGdCQUFnQlAsRUFBaEIsQ0FBbUIvQixHQUFuQixDQUFKLEVBQTZCO0FBQUEsZ0NBQ1Z1QyxvQkFBb0JLLGlCQUFwQixDQUFzQzVDLEdBQXRDLEVBQTJDRCxHQUEzQyxDQURVO0FBQUEsUUFDbEI4QyxDQURrQjtBQUFBLFFBQ2ZDLENBRGU7O0FBRXpCLFdBQU8sQ0FBQ0EsQ0FBRCxFQUFJRCxDQUFKLENBQVA7QUFDSCxHQUhELE1BSUssSUFBSUgsb0JBQW9CWCxFQUFwQixDQUF1Qi9CLEdBQXZCLENBQUosRUFBaUM7QUFDbEMsV0FBTytDLHNCQUFzQmhELEdBQXRCLEVBQTJCQyxHQUEzQixDQUFQO0FBQ0gsR0FGSSxNQUdBLElBQUkyQyxrQkFBa0JaLEVBQWxCLENBQXFCL0IsR0FBckIsQ0FBSixFQUErQjtBQUNoQyxXQUFPZ0QsbUJBQW1CakQsR0FBbkIsRUFBd0JDLEdBQXhCLENBQVA7QUFDSCxHQUZJLE1BR0EsSUFBSXdDLHFCQUFxQlQsRUFBckIsQ0FBd0IvQixHQUF4QixDQUFKLEVBQWtDO0FBQUEsZ0NBQ3BCeUMseUJBQXlCUSxxQkFBekIsQ0FBK0NqRCxHQUEvQyxFQUFvREQsR0FBcEQsQ0FEb0I7QUFBQSxRQUM1QjhDLEVBRDRCO0FBQUEsUUFDekJDLEVBRHlCOztBQUVuQyxXQUFPLENBQUNBLEVBQUQsRUFBSUQsRUFBSixDQUFQO0FBQ0gsR0FISSxNQUlBO0FBQ0QsV0FBT0ssbUJBQW1CbkQsR0FBbkIsRUFBd0JDLEdBQXhCLENBQVA7QUFDSDtBQUNKOztBQUNEM0gsUUFBUTZKLE1BQVIsR0FBaUJBLE1BQWpCOztBQUNBLFNBQVNnQixrQkFBVCxDQUE0Qm5ELEdBQTVCLEVBQWlDQyxHQUFqQyxFQUFzQztBQUNsQyxNQUFNbUQsU0FBU2Qsb0JBQW9CcEMsUUFBcEIsQ0FBNkJELEdBQTdCLEVBQWtDRCxHQUFsQyxDQUFmO0FBQ0EsTUFBTXFELGFBQWFmLG9CQUFvQnBHLEdBQXBCLENBQXdCb0csb0JBQW9CbkMsUUFBcEIsQ0FBNkJtQyxvQkFBb0I3QixTQUFwQixDQUE4QjJDLE1BQTlCLENBQTdCLEVBQW9FcEQsSUFBSTZCLE1BQXhFLENBQXhCLEVBQXlHN0IsR0FBekcsQ0FBbkI7QUFDQSxTQUFPLENBQUNxRCxVQUFELEVBQWFwRCxHQUFiLENBQVA7QUFDSDs7QUFDRDNILFFBQVE2SyxrQkFBUixHQUE2QkEsa0JBQTdCOztBQUNBLFNBQVNILHFCQUFULENBQStCaEQsR0FBL0IsRUFBb0NDLEdBQXBDLEVBQXlDO0FBQ3JDLE1BQU04QyxJQUFJUCxvQkFBb0JLLGlCQUFwQixDQUFzQyxDQUFDNUMsSUFBSSxDQUFKLENBQUQsRUFBU0EsSUFBSSxDQUFKLENBQVQsQ0FBdEMsRUFBd0RELEdBQXhELENBQVY7QUFDQSxNQUFNOEMsSUFBSU4sb0JBQW9CSyxpQkFBcEIsQ0FBc0MsQ0FBQzVDLElBQUksQ0FBSixDQUFELEVBQVNBLElBQUksQ0FBSixDQUFULENBQXRDLEVBQXdERCxHQUF4RCxDQUFWO0FBQ0EsTUFBTXNELElBQUlkLG9CQUFvQkssaUJBQXBCLENBQXNDLENBQUM1QyxJQUFJLENBQUosQ0FBRCxFQUFTQSxJQUFJLENBQUosQ0FBVCxDQUF0QyxFQUF3REQsR0FBeEQsQ0FBVjtBQUNBLE1BQU11RCxPQUFPakIsb0JBQW9CaEMsZ0JBQXBCLENBQXFDZ0Msb0JBQW9CcEMsUUFBcEIsQ0FBNkI2QyxFQUFFLENBQUYsQ0FBN0IsRUFBbUMvQyxHQUFuQyxDQUFyQyxDQUFiO0FBQ0EsTUFBTXdELE9BQU9sQixvQkFBb0JoQyxnQkFBcEIsQ0FBcUNnQyxvQkFBb0JwQyxRQUFwQixDQUE2QjRDLEVBQUUsQ0FBRixDQUE3QixFQUFtQzlDLEdBQW5DLENBQXJDLENBQWI7QUFDQSxNQUFNeUQsT0FBT25CLG9CQUFvQmhDLGdCQUFwQixDQUFxQ2dDLG9CQUFvQnBDLFFBQXBCLENBQTZCb0QsRUFBRSxDQUFGLENBQTdCLEVBQW1DdEQsR0FBbkMsQ0FBckMsQ0FBYjs7QUFDQSxNQUFJdUQsT0FBT0MsSUFBWCxFQUFpQjtBQUNiLFdBQU9ELE9BQU9FLElBQVAsR0FBY1YsQ0FBZCxHQUFrQk8sQ0FBekI7QUFDSCxHQUZELE1BR0s7QUFDRCxXQUFPRSxPQUFPQyxJQUFQLEdBQWNYLENBQWQsR0FBa0JRLENBQXpCO0FBQ0g7QUFDSjs7QUFDRGhMLFFBQVEwSyxxQkFBUixHQUFnQ0EscUJBQWhDOztBQUNBLFNBQVNDLGtCQUFULENBQTRCakQsR0FBNUIsRUFBaUNDLEdBQWpDLEVBQXNDO0FBQ2xDLE1BQU1tRCxTQUFTZCxvQkFBb0JwQyxRQUFwQixDQUE2QkQsR0FBN0IsRUFBa0NELEdBQWxDLENBQWY7QUFDQSxNQUFNMEQsSUFBSXBCLG9CQUFvQjdCLFNBQXBCLENBQThCMkMsTUFBOUIsQ0FBVjtBQUNBLE1BQU1PLElBQUlyQixvQkFBb0JwRyxHQUFwQixDQUF3Qm9HLG9CQUFvQm5DLFFBQXBCLENBQTZCdUQsQ0FBN0IsRUFBZ0MxRCxJQUFJNkIsTUFBcEMsQ0FBeEIsRUFBcUU3QixHQUFyRSxDQUFWO0FBQ0EsTUFBTTRELElBQUl0QixvQkFBb0JwQyxRQUFwQixDQUE2QkQsR0FBN0IsRUFBa0NxQyxvQkFBb0JuQyxRQUFwQixDQUE2QnVELENBQTdCLEVBQWdDekQsSUFBSTRCLE1BQXBDLENBQWxDLENBQVY7QUFDQSxTQUFPLENBQUM4QixDQUFELEVBQUlDLENBQUosQ0FBUDtBQUNIOztBQUNEdEwsUUFBUTJLLGtCQUFSLEdBQTZCQSxrQkFBN0IsQzs7Ozs7Ozs7QUN6REE7O0FBQ0E3SyxPQUFPQyxjQUFQLENBQXNCQyxPQUF0QixFQUErQixZQUEvQixFQUE2QztBQUFFQyxTQUFPO0FBQVQsQ0FBN0M7O0FBQ0EsSUFBTStKLHNCQUFzQixtQkFBQXRLLENBQVEsNkRBQVIsQ0FBNUI7O0FBQ0EsSUFBTTZMLHlCQUF5QixtQkFBQTdMLENBQVEsc0VBQVIsQ0FBL0I7O0FBQ0EsSUFBTXVLLGtCQUFrQixtQkFBQXZLLENBQVEsK0RBQVIsQ0FBeEI7O0FBQ0EsSUFBTThMLHNCQUFzQixtQkFBQTlMLENBQVEsbUVBQVIsQ0FBNUI7O0FBQ0EsSUFBTXlLLHVCQUF1QixtQkFBQXpLLENBQVEseUVBQVIsQ0FBN0I7O0FBQ0EsSUFBTTBLLDJCQUEyQixtQkFBQTFLLENBQVEsNkVBQVIsQ0FBakM7O0FBQ0EsSUFBTTJLLHNCQUFzQixtQkFBQTNLLENBQVEsdUVBQVIsQ0FBNUI7O0FBQ0EsSUFBTStMLDJCQUEyQixtQkFBQS9MLENBQVEsNEVBQVIsQ0FBakM7O0FBQ0EsSUFBTTRLLG9CQUFvQixtQkFBQTVLLENBQVEsbUVBQVIsQ0FBMUI7O0FBQ0EsU0FBU2dNLFFBQVQsQ0FBa0JoRSxHQUFsQixFQUF1QkMsR0FBdkIsRUFBNEI7QUFDeEIsTUFBSXNDLGdCQUFnQlAsRUFBaEIsQ0FBbUIvQixHQUFuQixDQUFKLEVBQTZCO0FBQ3pCLFdBQU9nRSxvQkFBb0JqRSxHQUFwQixFQUF5QkMsR0FBekIsQ0FBUDtBQUNILEdBRkQsTUFHSyxJQUFJMEMsb0JBQW9CWCxFQUFwQixDQUF1Qi9CLEdBQXZCLENBQUosRUFBaUM7QUFDbEMsV0FBT2lFLHdCQUF3QmxFLEdBQXhCLEVBQTZCQyxHQUE3QixDQUFQO0FBQ0gsR0FGSSxNQUdBLElBQUkyQyxrQkFBa0JaLEVBQWxCLENBQXFCL0IsR0FBckIsQ0FBSixFQUErQjtBQUNoQyxXQUFPa0UscUJBQXFCbkUsR0FBckIsRUFBMEJDLEdBQTFCLENBQVA7QUFDSCxHQUZJLE1BR0EsSUFBSXdDLHFCQUFxQlQsRUFBckIsQ0FBd0IvQixHQUF4QixDQUFKLEVBQWtDO0FBQ25DLFdBQU9tRSx3QkFBd0JwRSxHQUF4QixFQUE2QkMsR0FBN0IsQ0FBUDtBQUNILEdBRkksTUFHQTtBQUNELFdBQU9vRSxxQkFBcUJyRSxHQUFyQixFQUEwQkMsR0FBMUIsQ0FBUDtBQUNIO0FBQ0o7O0FBQ0QzSCxRQUFRMEwsUUFBUixHQUFtQkEsUUFBbkI7O0FBQ0EsU0FBU0MsbUJBQVQsQ0FBNkJqRSxHQUE3QixFQUFrQ0MsR0FBbEMsRUFBdUM7QUFDbkMsU0FBTzRELHVCQUF1QlMscUJBQXZCLENBQTZDckUsR0FBN0MsRUFBa0RELEdBQWxELENBQVA7QUFDSDs7QUFDRDFILFFBQVEyTCxtQkFBUixHQUE4QkEsbUJBQTlCOztBQUNBLFNBQVNDLHVCQUFULENBQWlDbEUsR0FBakMsRUFBc0NDLEdBQXRDLEVBQTJDO0FBQ3ZDLFNBQU84RCx5QkFBeUJRLHVCQUF6QixDQUFpRHRFLEdBQWpELEVBQXNERCxHQUF0RCxDQUFQO0FBQ0g7O0FBQ0QxSCxRQUFRNEwsdUJBQVIsR0FBa0NBLHVCQUFsQzs7QUFDQSxTQUFTQyxvQkFBVCxDQUE4QnBCLENBQTlCLEVBQWlDRCxDQUFqQyxFQUFvQztBQUNoQyxTQUFPUixvQkFBb0JoQyxnQkFBcEIsQ0FBcUNnQyxvQkFBb0JwQyxRQUFwQixDQUE2QjZDLENBQTdCLEVBQWdDRCxDQUFoQyxDQUFyQyxLQUE0RSxDQUFDQyxFQUFFbEIsTUFBRixHQUFXaUIsRUFBRWpCLE1BQWQsS0FBeUJrQixFQUFFbEIsTUFBRixHQUFXaUIsRUFBRWpCLE1BQXRDLENBQW5GO0FBQ0g7O0FBQ0R2SixRQUFRNkwsb0JBQVIsR0FBK0JBLG9CQUEvQjs7QUFDQSxTQUFTRSxvQkFBVCxDQUE4QnRCLENBQTlCLEVBQWlDRCxDQUFqQyxFQUFvQztBQUNoQyxTQUFPUixvQkFBb0JoQyxnQkFBcEIsQ0FBcUNnQyxvQkFBb0JwQyxRQUFwQixDQUE2QjZDLENBQTdCLEVBQWdDRCxDQUFoQyxDQUFyQyxLQUE0RUMsRUFBRWxCLE1BQUYsR0FBV2tCLEVBQUVsQixNQUFoRztBQUNIOztBQUNEdkosUUFBUStMLG9CQUFSLEdBQStCQSxvQkFBL0I7O0FBQ0EsU0FBU0QsdUJBQVQsQ0FBaUNwRSxHQUFqQyxFQUFzQ0MsR0FBdEMsRUFBMkM7QUFDdkMsU0FBT29FLHFCQUFxQnJFLEdBQXJCLEVBQTBCQyxHQUExQixLQUFtQzZELG9CQUFvQlUsUUFBcEIsQ0FBNkI5Qix5QkFBeUJQLE1BQXpCLENBQWdDbEMsR0FBaEMsRUFBcUM7QUFBRTlELE9BQUc2RCxJQUFJN0QsQ0FBVDtBQUFZMkQsT0FBR0UsSUFBSUY7QUFBbkIsR0FBckMsQ0FBN0IsS0FBOEZFLElBQUk2QixNQUE1STtBQUNIOztBQUNEdkosUUFBUThMLHVCQUFSLEdBQWtDQSx1QkFBbEMsQzs7Ozs7Ozs7QUNoREE7O0FBQ0FoTSxPQUFPQyxjQUFQLENBQXNCQyxPQUF0QixFQUErQixZQUEvQixFQUE2QztBQUFFQyxTQUFPO0FBQVQsQ0FBN0M7O0FBQ0FELFFBQVFtTSxJQUFSLEdBQWUsVUFBQ2IsQ0FBRCxFQUFJYyxDQUFKLEVBQU81QixDQUFQLEVBQVVDLENBQVY7QUFBQSxNQUFVQSxDQUFWO0FBQVVBLEtBQVYsR0FBYyxDQUFkO0FBQUE7O0FBQUEsU0FBcUI7QUFBRWEsUUFBRjtBQUFLYyxRQUFMO0FBQVE1QixRQUFSO0FBQVdDO0FBQVgsR0FBckI7QUFBQSxDQUFmOztBQUNBekssUUFBUXFNLEdBQVIsR0FBYyxVQUFDZixDQUFELEVBQUljLENBQUosRUFBTzVCLENBQVA7QUFBQSxTQUFjO0FBQUVjLFFBQUY7QUFBS2MsUUFBTDtBQUFRNUI7QUFBUixHQUFkO0FBQUEsQ0FBZCxDOzs7Ozs7OztBQ0hBOztBQUNBMUssT0FBT0MsY0FBUCxDQUFzQkMsT0FBdEIsRUFBK0IsWUFBL0IsRUFBNkM7QUFBRUMsU0FBTztBQUFULENBQTdDOztBQUNBLElBQU1xSyxvQkFBb0IsbUJBQUE1SyxDQUFRLG1FQUFSLENBQTFCOztBQUNBLElBQU00TSx5QkFBeUIsbUJBQUE1TSxDQUFRLHVFQUFSLENBQS9COztBQUNBLElBQU15Syx1QkFBdUIsbUJBQUF6SyxDQUFRLHlFQUFSLENBQTdCOztBQUNBLElBQU02TSwwQkFBMEIsbUJBQUE3TSxDQUFRLDRFQUFSLENBQWhDOztBQUNBLElBQU0ySyxzQkFBc0IsbUJBQUEzSyxDQUFRLHVFQUFSLENBQTVCOztBQUNBLElBQU11SyxrQkFBa0IsbUJBQUF2SyxDQUFRLCtEQUFSLENBQXhCOztBQUNBLFNBQVM4TSxVQUFULENBQW9COUUsR0FBcEIsRUFBeUJDLEdBQXpCLEVBQThCOEUsU0FBOUIsRUFBaUQ7QUFBQSxNQUFuQkEsU0FBbUI7QUFBbkJBLGFBQW1CLEdBQVAsS0FBTztBQUFBOztBQUM3QyxNQUFJeEMsZ0JBQWdCUCxFQUFoQixDQUFtQi9CLEdBQW5CLENBQUosRUFBNkI7QUFDekIsV0FBTytFLHFCQUFxQmhGLEdBQXJCLEVBQTBCQyxHQUExQixDQUFQO0FBQ0gsR0FGRCxNQUdLLElBQUkwQyxvQkFBb0JYLEVBQXBCLENBQXVCL0IsR0FBdkIsQ0FBSixFQUFpQztBQUNsQyxXQUFPZ0YseUJBQXlCakYsR0FBekIsRUFBOEJDLEdBQTlCLENBQVA7QUFDSCxHQUZJLE1BR0EsSUFBSTJDLGtCQUFrQlosRUFBbEIsQ0FBcUIvQixHQUFyQixDQUFKLEVBQStCO0FBQ2hDLFdBQU9xRSxzQkFBc0J0RSxHQUF0QixFQUEyQkMsR0FBM0IsQ0FBUDtBQUNILEdBRkksTUFHQSxJQUFJd0MscUJBQXFCVCxFQUFyQixDQUF3Qi9CLEdBQXhCLENBQUosRUFBa0M7QUFDbkMsV0FBT2lGLHlCQUF5QmxGLEdBQXpCLEVBQThCQyxHQUE5QixDQUFQO0FBQ0gsR0FGSSxNQUdBO0FBQ0QsV0FBT2tGLHNCQUFzQm5GLEdBQXRCLEVBQTJCQyxHQUEzQixFQUFnQzhFLFNBQWhDLENBQVA7QUFDSDtBQUNKOztBQUNEek0sUUFBUXdNLFVBQVIsR0FBcUJBLFVBQXJCOztBQUNBLFNBQVNHLHdCQUFULGNBQTBEO0FBQUEsTUFBdkJHLEVBQXVCO0FBQUEsTUFBbkJDLEVBQW1CO0FBQUEsTUFBYkMsRUFBYTtBQUFBLE1BQVRDLEVBQVM7QUFBQSxNQUFMQyxFQUFLO0FBQ3RELFNBQU9SLHFCQUFxQixDQUFDTSxFQUFELEVBQUtDLEVBQUwsQ0FBckIsRUFBK0IsQ0FBQ0gsRUFBRCxFQUFLQyxFQUFMLENBQS9CLEtBQ0FMLHFCQUFxQixDQUFDTyxFQUFELEVBQUtDLEVBQUwsQ0FBckIsRUFBK0IsQ0FBQ0osRUFBRCxFQUFLQyxFQUFMLENBQS9CLENBREEsSUFFQUwscUJBQXFCLENBQUNRLEVBQUQsRUFBS0YsRUFBTCxDQUFyQixFQUErQixDQUFDRixFQUFELEVBQUtDLEVBQUwsQ0FBL0IsQ0FGUDtBQUdIOztBQUNEL00sUUFBUTJNLHdCQUFSLEdBQW1DQSx3QkFBbkM7O0FBQ0EsU0FBU1gscUJBQVQsQ0FBK0J0RSxHQUEvQixFQUFvQ0MsR0FBcEMsRUFBeUM7QUFDckMsU0FBT2tGLHNCQUFzQm5GLEdBQXRCLEVBQTJCQyxHQUEzQixFQUFnQ0EsSUFBSTRCLE1BQXBDLENBQVA7QUFDSDs7QUFDRHZKLFFBQVFnTSxxQkFBUixHQUFnQ0EscUJBQWhDOztBQUNBLFNBQVNhLHFCQUFULFFBQXlDTSxFQUF6QyxFQUE2Q1YsU0FBN0MsRUFBd0Q7QUFBQSxNQUF4QkssRUFBd0I7QUFBQSxNQUFwQkMsRUFBb0I7O0FBQ3BELFdBQVNLLG9CQUFULENBQThCRCxFQUE5QixFQUFrQ0wsRUFBbEMsRUFBc0NDLEVBQXRDLEVBQTBDO0FBQ3RDLGFBQVNNLDZCQUFULENBQXVDQyxDQUF2QyxFQUEwQ0MsQ0FBMUMsRUFBNkM7QUFDekMsYUFBTyxTQUFDRCxFQUFFekosQ0FBRixHQUFNMEosRUFBRTFKLENBQVQsRUFBZSxDQUFmLGFBQW9CeUosRUFBRTlGLENBQUYsR0FBTStGLEVBQUUvRixDQUE1QixFQUFrQyxDQUFsQyxDQUFQO0FBQ0g7O0FBQ0QsUUFBTWdHLHNCQUFzQkgsOEJBQThCUCxFQUE5QixFQUFrQ0MsRUFBbEMsQ0FBNUI7O0FBQ0EsUUFBSVMsd0JBQXdCLENBQTVCLEVBQStCO0FBQzNCLGFBQU9ILDhCQUE4QkYsRUFBOUIsRUFBa0NMLEVBQWxDLENBQVA7QUFDSDs7QUFDRCxRQUFNVyxnQkFBZ0IsQ0FBQyxDQUFDTixHQUFHdEosQ0FBSCxHQUFPaUosR0FBR2pKLENBQVgsS0FBaUJrSixHQUFHbEosQ0FBSCxHQUFPaUosR0FBR2pKLENBQTNCLElBQWdDLENBQUNzSixHQUFHM0YsQ0FBSCxHQUFPc0YsR0FBR3RGLENBQVgsS0FBaUJ1RixHQUFHdkYsQ0FBSCxHQUFPc0YsR0FBR3RGLENBQTNCLENBQWpDLElBQWtFZ0csbUJBQXhGOztBQUNBLFFBQUlDLGdCQUFnQixDQUFwQixFQUF1QjtBQUNuQixhQUFPSiw4QkFBOEJGLEVBQTlCLEVBQWtDTCxFQUFsQyxDQUFQO0FBQ0gsS0FGRCxNQUdLLElBQUlXLGdCQUFnQixDQUFwQixFQUF1QjtBQUN4QixhQUFPSiw4QkFBOEJGLEVBQTlCLEVBQWtDSixFQUFsQyxDQUFQO0FBQ0gsS0FGSSxNQUdBO0FBQ0QsVUFBTVcsY0FBYztBQUNoQjdKLFdBQUdpSixHQUFHakosQ0FBSCxHQUFPNEosaUJBQWlCVixHQUFHbEosQ0FBSCxHQUFPaUosR0FBR2pKLENBQTNCLENBRE07QUFFaEIyRCxXQUFHc0YsR0FBR3RGLENBQUgsR0FBT2lHLGlCQUFpQlYsR0FBR3ZGLENBQUgsR0FBT3NGLEdBQUd0RixDQUEzQjtBQUZNLE9BQXBCO0FBSUEsYUFBTzZGLDhCQUE4QkYsRUFBOUIsRUFBa0NPLFdBQWxDLENBQVA7QUFDSDtBQUNKOztBQUNELFNBQU9OLHFCQUFxQkQsRUFBckIsRUFBeUJMLEVBQXpCLEVBQTZCQyxFQUE3QixLQUFxQ04sWUFBWUEsU0FBeEQ7QUFDSDs7QUFDRHpNLFFBQVE2TSxxQkFBUixHQUFnQ0EscUJBQWhDOztBQUNBLFNBQVNELHdCQUFULENBQWtDbEYsR0FBbEMsRUFBdUNDLEdBQXZDLEVBQTRDO0FBQUEsOEJBQ0g0RSx3QkFBd0JvQixLQUF4QixDQUE4QmhHLEdBQTlCLENBREc7QUFBQSxNQUNoQ2lHLE1BRGdDLHlCQUNoQ0EsTUFEZ0M7QUFBQSxNQUN4QkMsR0FEd0IseUJBQ3hCQSxHQUR3QjtBQUFBLE1BQ25CQyxJQURtQix5QkFDbkJBLElBRG1CO0FBQUEsTUFDYkMsS0FEYSx5QkFDYkEsS0FEYTs7QUFFeEMsU0FBT3JCLHFCQUFxQmhGLEdBQXJCLEVBQTBCbUcsR0FBMUIsS0FDQW5CLHFCQUFxQmhGLEdBQXJCLEVBQTBCa0csTUFBMUIsQ0FEQSxJQUVBbEIscUJBQXFCaEYsR0FBckIsRUFBMEJvRyxJQUExQixDQUZBLElBR0FwQixxQkFBcUJoRixHQUFyQixFQUEwQnFHLEtBQTFCLENBSFA7QUFJSDs7QUFDRC9OLFFBQVE0TSx3QkFBUixHQUFtQ0Esd0JBQW5DOztBQUNBLFNBQVNGLG9CQUFULGVBQWtEO0FBQUEsTUFBbkJJLEVBQW1CO0FBQUEsTUFBZkMsRUFBZTtBQUFBLE1BQVRpQixFQUFTO0FBQUEsTUFBTEMsRUFBSzs7QUFDOUMsTUFBTUMsV0FBVyxTQUFYQSxRQUFXLENBQUNySyxDQUFELEVBQUkyRCxDQUFKO0FBQUEsV0FBVTNELEtBQUssQ0FBTCxJQUFVMkQsS0FBSyxDQUFmLElBQW9CM0QsS0FBSyxDQUFMLElBQVUyRCxLQUFLLENBQTdDO0FBQUEsR0FBakI7O0FBQ0EsTUFBTTJHLEtBQUtyQixHQUFHakosQ0FBZDtBQUNBLE1BQU11SyxLQUFLdEIsR0FBR3RGLENBQWQ7QUFDQSxNQUFNNkcsS0FBS3RCLEdBQUdsSixDQUFkO0FBQ0EsTUFBTXlLLEtBQUt2QixHQUFHdkYsQ0FBZDtBQUNBLE1BQU0rRyxLQUFLUCxHQUFHbkssQ0FBZDtBQUNBLE1BQU0ySyxLQUFLUixHQUFHeEcsQ0FBZDtBQUNBLE1BQU1pSCxLQUFLUixHQUFHcEssQ0FBZDtBQUNBLE1BQU02SyxLQUFLVCxHQUFHekcsQ0FBZDtBQUNBLE1BQU1tSCxLQUFLTCxLQUFLRixFQUFoQjtBQUNBLE1BQU1RLEtBQUtULEtBQUtFLEVBQWhCO0FBQ0EsTUFBTVEsS0FBTVIsS0FBS0QsRUFBTixHQUFhRCxLQUFLRyxFQUE3QjtBQUNBLE1BQU1RLEtBQU9ILEtBQUtKLEVBQU4sR0FBYUssS0FBS0osRUFBbEIsR0FBd0JLLEVBQXBDO0FBQ0EsTUFBTUUsS0FBT0osS0FBS0YsRUFBTixHQUFhRyxLQUFLRixFQUFsQixHQUF3QkcsRUFBcEM7O0FBQ0EsTUFBS0MsT0FBTyxDQUFSLElBQWVDLE9BQU8sQ0FBdEIsSUFBNEJiLFNBQVNZLEVBQVQsRUFBYUMsRUFBYixDQUFoQyxFQUFrRDtBQUM5QyxXQUFPLEtBQVA7QUFDSDs7QUFDRCxNQUFNQyxLQUFLTixLQUFLRixFQUFoQjtBQUNBLE1BQU1TLEtBQUtWLEtBQUtFLEVBQWhCO0FBQ0EsTUFBTVMsS0FBTVQsS0FBS0QsRUFBTixHQUFhRCxLQUFLRyxFQUE3QjtBQUNBLE1BQU1TLEtBQU1ILEtBQUtiLEVBQU4sR0FBYWMsS0FBS2IsRUFBbEIsR0FBd0JjLEVBQW5DO0FBQ0EsTUFBTUUsS0FBTUosS0FBS1gsRUFBTixHQUFhWSxLQUFLWCxFQUFsQixHQUF3QlksRUFBbkM7O0FBQ0EsTUFBS0MsT0FBTyxDQUFSLElBQWVDLE9BQU8sQ0FBdEIsSUFBNkJsQixTQUFTaUIsRUFBVCxFQUFhQyxFQUFiLENBQWpDLEVBQW9EO0FBQ2hELFdBQU8sS0FBUDtBQUNIOztBQUNELE1BQU0zRSxJQUFJNkIsdUJBQXVCK0MsWUFBdkIsQ0FBb0N2QyxFQUFwQyxFQUF3Q0MsRUFBeEMsQ0FBVjtBQUNBLE1BQU12QyxJQUFJOEIsdUJBQXVCK0MsWUFBdkIsQ0FBb0NyQixFQUFwQyxFQUF3Q0MsRUFBeEMsQ0FBVjtBQUNBLFNBQU8sRUFBRXhELEVBQUVsQyxPQUFGLENBQVUxRSxDQUFWLEdBQWMyRyxFQUFFaEMsV0FBRixDQUFjM0UsQ0FBNUIsSUFDRjRHLEVBQUVsQyxPQUFGLENBQVVmLENBQVYsR0FBY2dELEVBQUVoQyxXQUFGLENBQWNoQixDQUQxQixJQUVGaUQsRUFBRWpDLFdBQUYsQ0FBYzNFLENBQWQsR0FBa0IyRyxFQUFFakMsT0FBRixDQUFVMUUsQ0FGMUIsSUFHRjRHLEVBQUVqQyxXQUFGLENBQWNoQixDQUFkLEdBQWtCZ0QsRUFBRWpDLE9BQUYsQ0FBVWYsQ0FINUIsQ0FBUDtBQUlIOztBQUNEeEgsUUFBUTBNLG9CQUFSLEdBQStCQSxvQkFBL0IsQzs7Ozs7Ozs7QUN4R0E7O0FBQ0E1TSxPQUFPQyxjQUFQLENBQXNCQyxPQUF0QixFQUErQixZQUEvQixFQUE2QztBQUFFQyxTQUFPO0FBQVQsQ0FBN0M7O0FBQ0EsSUFBTXFQLG1CQUFtQixtQkFBQTVQLENBQVEsaUVBQVIsQ0FBekI7O0FBQ0EsU0FBU2dLLEVBQVQsQ0FBWTZGLFFBQVosRUFBc0I7QUFDbEIsU0FBT2xOLE1BQU1tTixPQUFOLENBQWNELFFBQWQsS0FBMkJBLFNBQVNqTSxNQUFULEtBQW9CLENBQS9DLElBQW9EaU0sU0FBUy9MLEtBQVQsQ0FBZThMLGlCQUFpQjVGLEVBQWhDLENBQTNEO0FBQ0g7O0FBQ0QxSixRQUFRMEosRUFBUixHQUFhQSxFQUFiLEM7Ozs7Ozs7O0FDTkE7O0FBQ0E1SixPQUFPQyxjQUFQLENBQXNCQyxPQUF0QixFQUErQixZQUEvQixFQUE2QztBQUFFQyxTQUFPO0FBQVQsQ0FBN0M7O0FBQ0EsSUFBTXdQLFlBQVksbUJBQUEvUCxDQUFRLHNFQUFSLENBQWxCOztBQUNBLElBQU1nSyxLQUFLLG1CQUFBaEssQ0FBUSwrREFBUixDQUFYOztBQUNBLElBQU00RCxTQUFTLG1CQUFBNUQsQ0FBUSxtRUFBUixDQUFmOztBQUNBLElBQU1tSyxTQUFTLG1CQUFBbkssQ0FBUSxtRUFBUixDQUFmOztBQUNBTSxRQUFRMFAsS0FBUixHQUFnQjVQLE9BQU9vSixNQUFQLENBQWMsVUFBQ3VCLENBQUQsRUFBSUQsQ0FBSjtBQUFBLFNBQVUsQ0FBQ0MsQ0FBRCxFQUFJRCxDQUFKLENBQVY7QUFBQSxDQUFkLEVBQWdDMUssT0FBT29KLE1BQVAsQ0FBYyxFQUFkLEVBQWtCdUcsU0FBbEIsRUFBNkIvRixFQUE3QixFQUFpQ3BHLE1BQWpDLEVBQXlDdUcsTUFBekMsQ0FBaEMsQ0FBaEIsQzs7Ozs7Ozs7QUNOQTs7QUFDQS9KLE9BQU9DLGNBQVAsQ0FBc0JDLE9BQXRCLEVBQStCLFlBQS9CLEVBQTZDO0FBQUVDLFNBQU87QUFBVCxDQUE3Qzs7QUFDQSxJQUFNMFAsaUJBQWlCLG1CQUFBalEsQ0FBUSx3REFBUixDQUF2Qjs7QUFDQSxTQUFTd00sUUFBVCxDQUFrQjBELElBQWxCLEVBQXdCO0FBQ3BCLFNBQU9ELGVBQWUxRyxPQUFmLENBQXVCaEIsU0FBdkIsQ0FBaUMwSCxlQUFlMUcsT0FBZixDQUF1QnJCLFFBQXZCLENBQWdDZ0ksS0FBSyxDQUFMLENBQWhDLEVBQXlDQSxLQUFLLENBQUwsQ0FBekMsQ0FBakMsQ0FBUDtBQUNIOztBQUNENVAsUUFBUWtNLFFBQVIsR0FBbUJBLFFBQW5CLEM7Ozs7Ozs7O0FDTkE7O0FBQ0FwTSxPQUFPQyxjQUFQLENBQXNCQyxPQUF0QixFQUErQixZQUEvQixFQUE2QztBQUFFQyxTQUFPO0FBQVQsQ0FBN0M7O0FBQ0EsSUFBTTRQLG9CQUFvQixtQkFBQW5RLENBQVEsb0RBQVIsQ0FBMUI7O0FBQ0EsSUFBTW9RLGNBQWMsbUJBQUFwUSxDQUFRLGlFQUFSLENBQXBCOztBQUNBLElBQU1zSyxzQkFBc0IsbUJBQUF0SyxDQUFRLDZEQUFSLENBQTVCOztBQUNBLElBQU00SyxvQkFBb0IsbUJBQUE1SyxDQUFRLG1FQUFSLENBQTFCOztBQUNBLElBQU15Syx1QkFBdUIsbUJBQUF6SyxDQUFRLHlFQUFSLENBQTdCOztBQUNBLElBQU02TSwwQkFBMEIsbUJBQUE3TSxDQUFRLDRFQUFSLENBQWhDOztBQUNBLElBQU0ySyxzQkFBc0IsbUJBQUEzSyxDQUFRLHVFQUFSLENBQTVCOztBQUNBLElBQU11SyxrQkFBa0IsbUJBQUF2SyxDQUFRLCtEQUFSLENBQXhCOztBQUNBLFNBQVNtSyxNQUFULENBQWdCbkMsR0FBaEIsRUFBcUJDLEdBQXJCLEVBQTBCO0FBQ3RCLE1BQUlzQyxnQkFBZ0JQLEVBQWhCLENBQW1CL0IsR0FBbkIsQ0FBSixFQUE2QjtBQUN6QixXQUFPb0ksaUJBQWlCckksR0FBakIsRUFBc0JDLEdBQXRCLENBQVA7QUFDSCxHQUZELE1BR0ssSUFBSTBDLG9CQUFvQlgsRUFBcEIsQ0FBdUIvQixHQUF2QixDQUFKLEVBQWlDO0FBQ2xDLFdBQU9xSSxxQkFBcUJ0SSxHQUFyQixFQUEwQkMsR0FBMUIsQ0FBUDtBQUNILEdBRkksTUFHQSxJQUFJMkMsa0JBQWtCWixFQUFsQixDQUFxQi9CLEdBQXJCLENBQUosRUFBK0I7QUFDaEMsV0FBTzRDLGtCQUFrQjdDLEdBQWxCLEVBQXVCQyxHQUF2QixDQUFQO0FBQ0gsR0FGSSxNQUdBLElBQUl3QyxxQkFBcUJULEVBQXJCLENBQXdCL0IsR0FBeEIsQ0FBSixFQUFrQztBQUNuQyxXQUFPc0kscUJBQXFCdkksR0FBckIsRUFBMEJDLEdBQTFCLENBQVA7QUFDSCxHQUZJLE1BR0E7QUFDRCxXQUFPdUksa0JBQWtCeEksR0FBbEIsRUFBdUJDLEdBQXZCLENBQVA7QUFDSDtBQUNKOztBQUNEM0gsUUFBUTZKLE1BQVIsR0FBaUJBLE1BQWpCOztBQUNBLFNBQVNtRyxvQkFBVCxDQUE4QnRJLEdBQTlCLEVBQW1DQyxHQUFuQyxFQUF3QztBQUNwQyxTQUFPd0ksaUJBQWlCLENBQ3BCSixpQkFBaUJySSxHQUFqQixFQUFzQixDQUFDQyxJQUFJLENBQUosQ0FBRCxFQUFTQSxJQUFJLENBQUosQ0FBVCxDQUF0QixDQURvQixFQUVwQm9JLGlCQUFpQnJJLEdBQWpCLEVBQXNCLENBQUNDLElBQUksQ0FBSixDQUFELEVBQVNBLElBQUksQ0FBSixDQUFULENBQXRCLENBRm9CLEVBR3BCb0ksaUJBQWlCckksR0FBakIsRUFBc0IsQ0FBQ0MsSUFBSSxDQUFKLENBQUQsRUFBU0EsSUFBSSxDQUFKLENBQVQsQ0FBdEIsQ0FIb0IsQ0FBakIsQ0FBUDtBQUtIOztBQUNEM0gsUUFBUWdRLG9CQUFSLEdBQStCQSxvQkFBL0I7O0FBQ0EsU0FBU0csZ0JBQVQsQ0FBMEJ4QyxLQUExQixFQUFpQztBQUM3QixTQUFPa0Msa0JBQWtCeFAsRUFBbEIsQ0FBcUJzTixLQUFyQixFQUNGN0osQ0FERSxDQUNBZ00sWUFBWXJPLEdBQVosQ0FBZ0I7QUFBQSxXQUFTO0FBQUUyTyxlQUFTUixJQUFYO0FBQWlCUyxlQUFTckcsb0JBQW9CaEMsZ0JBQXBCLENBQXFDZ0Msb0JBQW9CcEMsUUFBcEIsQ0FBNkJnSSxLQUFLLENBQUwsQ0FBN0IsRUFBc0NBLEtBQUssQ0FBTCxDQUF0QyxDQUFyQztBQUExQixLQUFUO0FBQUEsR0FBaEIsQ0FEQSxFQUVGOUwsQ0FGRSxDQUVBZ00sWUFBWTFOLElBQVosQ0FBaUIsVUFBQ2tPLElBQUQsRUFBT0MsSUFBUDtBQUFBLFdBQWdCRCxLQUFLRCxPQUFMLEdBQWVFLEtBQUtGLE9BQXBCLEdBQThCQyxJQUE5QixHQUFxQ0MsSUFBckQ7QUFBQSxHQUFqQixDQUZBLEVBR0ZsUSxFQUhFLENBR0M7QUFBQSxXQUFRdVAsS0FBS1EsT0FBYjtBQUFBLEdBSEQsQ0FBUDtBQUlIOztBQUNEcFEsUUFBUW1RLGdCQUFSLEdBQTJCQSxnQkFBM0I7O0FBQ0EsU0FBU0Ysb0JBQVQsQ0FBOEJ2SSxHQUE5QixFQUFtQ0MsR0FBbkMsRUFBd0M7QUFDcEMsTUFBTTZJLFVBQVVqRSx3QkFBd0JvQixLQUF4QixDQUE4QmhHLEdBQTlCLENBQWhCO0FBQ0EsU0FBT3dJLGlCQUFpQixDQUNwQkosaUJBQWlCckksR0FBakIsRUFBc0I4SSxRQUFRM0MsR0FBOUIsQ0FEb0IsRUFFcEJrQyxpQkFBaUJySSxHQUFqQixFQUFzQjhJLFFBQVE1QyxNQUE5QixDQUZvQixFQUdwQm1DLGlCQUFpQnJJLEdBQWpCLEVBQXNCOEksUUFBUTFDLElBQTlCLENBSG9CLEVBSXBCaUMsaUJBQWlCckksR0FBakIsRUFBc0I4SSxRQUFRekMsS0FBOUIsQ0FKb0IsQ0FBakIsQ0FBUDtBQU1IOztBQUNEL04sUUFBUWlRLG9CQUFSLEdBQStCQSxvQkFBL0I7O0FBQ0EsU0FBU0YsZ0JBQVQsQ0FBMEJySSxHQUExQixFQUErQkMsR0FBL0IsRUFBb0M7QUFDaEM7QUFDQSxTQUFPLENBQUM4SSxnQkFBZ0IvSSxHQUFoQixDQUFELEVBQXVCK0ksZ0JBQWdCOUksR0FBaEIsQ0FBdkIsQ0FBUDtBQUNIOztBQUNEM0gsUUFBUStQLGdCQUFSLEdBQTJCQSxnQkFBM0I7O0FBQ0EsU0FBU3hGLGlCQUFULENBQTJCN0MsR0FBM0IsRUFBZ0NDLEdBQWhDLEVBQXFDO0FBQUEsMEJBQ3BCdUksa0JBQWtCeEksR0FBbEIsRUFBdUJDLEdBQXZCLENBRG9CO0FBQUEsTUFDMUIrSSxFQUQwQjs7QUFFakMsTUFBTW5ILFNBQVM1QixJQUFJNEIsTUFBbkI7QUFDQSxNQUFNb0gsZUFBZTNHLG9CQUFvQnBDLFFBQXBCLENBQTZCRCxHQUE3QixFQUFrQytJLEVBQWxDLENBQXJCO0FBQ0EsTUFBTUUsY0FBYzVHLG9CQUFvQjdCLFNBQXBCLENBQThCd0ksWUFBOUIsQ0FBcEI7QUFDQSxNQUFNRSxlQUFlN0csb0JBQW9CbkMsUUFBcEIsQ0FBNkIrSSxXQUE3QixFQUEwQ2pKLElBQUk0QixNQUE5QyxDQUFyQjtBQUNBLE1BQU11SCxjQUFjOUcsb0JBQW9CcEcsR0FBcEIsQ0FBd0IrRCxHQUF4QixFQUE2QmtKLFlBQTdCLENBQXBCO0FBQ0EsU0FBTyxDQUFDSCxFQUFELEVBQUtJLFdBQUwsQ0FBUDtBQUNIOztBQUNEOVEsUUFBUXVLLGlCQUFSLEdBQTRCQSxpQkFBNUI7O0FBQ0EsU0FBUzJGLGlCQUFULENBQTJCeEksR0FBM0IsRUFBZ0NDLEdBQWhDLEVBQXFDO0FBQ2pDLE1BQU13RixLQUFLeEYsR0FBWDtBQURpQyxNQUUxQm1GLEVBRjBCLEdBRWhCcEYsR0FGZ0I7QUFBQSxNQUV0QnFGLEVBRnNCLEdBRWhCckYsR0FGZ0I7O0FBR2pDLFdBQVMyRiw2QkFBVCxDQUF1Q0MsQ0FBdkMsRUFBMENDLENBQTFDLEVBQTZDO0FBQ3pDLFdBQU8sU0FBQ0QsRUFBRXpKLENBQUYsR0FBTTBKLEVBQUUxSixDQUFULEVBQWUsQ0FBZixhQUFvQnlKLEVBQUU5RixDQUFGLEdBQU0rRixFQUFFL0YsQ0FBNUIsRUFBa0MsQ0FBbEMsQ0FBUDtBQUNIOztBQUNELE1BQU1nRyxzQkFBc0JILDhCQUE4QlAsRUFBOUIsRUFBa0NDLEVBQWxDLENBQTVCOztBQUNBLE1BQUlTLHdCQUF3QixDQUE1QixFQUErQjtBQUMzQixXQUFPLENBQUNWLEVBQUQsRUFBS0ssRUFBTCxDQUFQO0FBQ0g7O0FBQ0QsTUFBTTRELGlCQUFpQixDQUFDLENBQUM1RCxHQUFHdEosQ0FBSCxHQUFPaUosR0FBR2pKLENBQVgsS0FBaUJrSixHQUFHbEosQ0FBSCxHQUFPaUosR0FBR2pKLENBQTNCLElBQWdDLENBQUNzSixHQUFHM0YsQ0FBSCxHQUFPc0YsR0FBR3RGLENBQVgsS0FBaUJ1RixHQUFHdkYsQ0FBSCxHQUFPc0YsR0FBR3RGLENBQTNCLENBQWpDLElBQWtFZ0csbUJBQXpGOztBQUNBLE1BQUl1RCxpQkFBaUIsQ0FBckIsRUFBd0I7QUFDcEIsV0FBTyxDQUFDakUsRUFBRCxFQUFLSyxFQUFMLENBQVA7QUFDSCxHQUZELE1BR0ssSUFBSTRELGlCQUFpQixDQUFyQixFQUF3QjtBQUN6QixXQUFPLENBQUNoRSxFQUFELEVBQUtJLEVBQUwsQ0FBUDtBQUNILEdBRkksTUFHQTtBQUNELFFBQU1PLGNBQWM7QUFDaEI3SixTQUFHaUosR0FBR2pKLENBQUgsR0FBT2tOLGtCQUFrQmhFLEdBQUdsSixDQUFILEdBQU9pSixHQUFHakosQ0FBNUIsQ0FETTtBQUVoQjJELFNBQUdzRixHQUFHdEYsQ0FBSCxHQUFPdUosa0JBQWtCaEUsR0FBR3ZGLENBQUgsR0FBT3NGLEdBQUd0RixDQUE1QjtBQUZNLEtBQXBCO0FBSUEsV0FBTyxDQUFDa0csV0FBRCxFQUFjUCxFQUFkLENBQVA7QUFDSDtBQUNKOztBQUNEbk4sUUFBUWtRLGlCQUFSLEdBQTRCQSxpQkFBNUI7O0FBQ0EsU0FBU08sZUFBVCxDQUF5Qi9JLEdBQXpCLEVBQThCO0FBQzFCLFNBQU9zQyxvQkFBb0JwRyxHQUFwQixDQUF3QjhELElBQUksQ0FBSixDQUF4QixFQUFnQ3NDLG9CQUFvQmpDLE1BQXBCLENBQTJCaUMsb0JBQW9CcEMsUUFBcEIsQ0FBNkJGLElBQUksQ0FBSixDQUE3QixFQUFxQ0EsSUFBSSxDQUFKLENBQXJDLENBQTNCLEVBQXlFLENBQXpFLENBQWhDLENBQVA7QUFDSCxDOzs7Ozs7OztBQ2hHRDs7QUFDQTVILE9BQU9DLGNBQVAsQ0FBc0JDLE9BQXRCLEVBQStCLFlBQS9CLEVBQTZDO0FBQUVDLFNBQU87QUFBVCxDQUE3Qzs7QUFDQSxJQUFNK1EscUJBQXFCLG1CQUFBdFIsQ0FBUSxtRUFBUixDQUEzQjs7QUFDQSxTQUFTMlAsWUFBVCxHQUFrQztBQUM5QixTQUFPO0FBQ0g5RyxhQUFTeUksbUJBQW1CQyxVQUFuQixxQ0FETjtBQUVIekksaUJBQWF3SSxtQkFBbUJFLGNBQW5CO0FBRlYsR0FBUDtBQUlIOztBQUNEbFIsUUFBUXFQLFlBQVIsR0FBdUJBLFlBQXZCOztBQUNBLFNBQVN6RixRQUFULEdBQThCO0FBQUEsc0JBQ095RixxQ0FEUDtBQUFBLE1BQ2xCOUcsT0FEa0IsaUJBQ2xCQSxPQURrQjtBQUFBLE1BQ1RDLFdBRFMsaUJBQ1RBLFdBRFM7O0FBRTFCLFNBQU87QUFDSDNFLE9BQUcwRSxRQUFRMUUsQ0FEUjtBQUVIMkQsT0FBR2UsUUFBUWYsQ0FGUjtBQUdIZ0MsV0FBT2hCLFlBQVkzRSxDQUFaLEdBQWdCMEUsUUFBUTFFLENBSDVCO0FBSUg0RixZQUFRakIsWUFBWWhCLENBQVosR0FBZ0JlLFFBQVFmO0FBSjdCLEdBQVA7QUFNSDs7QUFDRHhILFFBQVE0SixRQUFSLEdBQW1CQSxRQUFuQixDOzs7Ozs7OztBQ25CQTs7QUFDQTlKLE9BQU9DLGNBQVAsQ0FBc0JDLE9BQXRCLEVBQStCLFlBQS9CLEVBQTZDO0FBQUVDLFNBQU87QUFBVCxDQUE3Qzs7QUFDQSxTQUFTeUosRUFBVCxDQUFZNkYsUUFBWixFQUFzQjtBQUNsQixTQUFPQSxTQUFTMUwsQ0FBVCxJQUFjLElBQWQsSUFBc0IwTCxTQUFTL0gsQ0FBVCxJQUFjLElBQTNDO0FBQ0g7O0FBQ0R4SCxRQUFRMEosRUFBUixHQUFhQSxFQUFiLEM7Ozs7Ozs7O0FDTEE7O0FBQ0E1SixPQUFPQyxjQUFQLENBQXNCQyxPQUF0QixFQUErQixZQUEvQixFQUE2QztBQUFFQyxTQUFPO0FBQVQsQ0FBN0M7O0FBQ0EsSUFBTTJKLFdBQVcsbUJBQUFsSyxDQUFRLHVFQUFSLENBQWpCOztBQUNBLElBQU1nSyxLQUFLLG1CQUFBaEssQ0FBUSxpRUFBUixDQUFYOztBQUNBLElBQU15UixPQUFPLG1CQUFBelIsQ0FBUSxtRUFBUixDQUFiOztBQUNBTSxRQUFRb1IsTUFBUixHQUFpQnRSLE9BQU9vSixNQUFQLENBQWMsVUFBQ3JGLENBQUQsRUFBSTJELENBQUo7QUFBQSxTQUFXO0FBQUUzRCxRQUFGO0FBQUsyRDtBQUFMLEdBQVg7QUFBQSxDQUFkLEVBQW9DMUgsT0FBT29KLE1BQVAsQ0FBYyxFQUFkLEVBQWtCaUksSUFBbEIsRUFBd0J2SCxRQUF4QixFQUFrQ0YsRUFBbEMsQ0FBcEMsQ0FBakIsQzs7Ozs7Ozs7QUNMQTs7QUFDQTVKLE9BQU9DLGNBQVAsQ0FBc0JDLE9BQXRCLEVBQStCLFlBQS9CLEVBQTZDO0FBQUVDLFNBQU87QUFBVCxDQUE3Qzs7QUFDQSxJQUFNNlAsY0FBYyxtQkFBQXBRLENBQVEsaUVBQVIsQ0FBcEI7O0FBQ0EsU0FBU3VSLFVBQVQsR0FBZ0M7QUFBQSxvQ0FBVEksT0FBUztBQUFUQSxXQUFTO0FBQUE7O0FBQzVCLFNBQU87QUFDSHhOLE9BQUdvRCxLQUFLd0IsR0FBTCxhQUFZcUgsWUFBWXJPLEdBQVosQ0FBZ0IsVUFBQzZQLEtBQUQ7QUFBQSxhQUFXQSxNQUFNek4sQ0FBakI7QUFBQSxLQUFoQixFQUFvQ3dOLE9BQXBDLENBQVosQ0FEQTtBQUVIN0osT0FBR1AsS0FBS3dCLEdBQUwsYUFBWXFILFlBQVlyTyxHQUFaLENBQWdCLFVBQUM2UCxLQUFEO0FBQUEsYUFBV0EsTUFBTTlKLENBQWpCO0FBQUEsS0FBaEIsRUFBb0M2SixPQUFwQyxDQUFaO0FBRkEsR0FBUDtBQUlIOztBQUNEclIsUUFBUWlSLFVBQVIsR0FBcUJBLFVBQXJCOztBQUNBLFNBQVNNLFdBQVQsR0FBaUM7QUFBQSxxQ0FBVEYsT0FBUztBQUFUQSxXQUFTO0FBQUE7O0FBQzdCLFNBQU87QUFDSHhOLE9BQUdvRCxLQUFLeUIsR0FBTCxhQUFZb0gsWUFBWXJPLEdBQVosQ0FBZ0IsVUFBQzZQLEtBQUQ7QUFBQSxhQUFXQSxNQUFNek4sQ0FBakI7QUFBQSxLQUFoQixFQUFvQ3dOLE9BQXBDLENBQVosQ0FEQTtBQUVIN0osT0FBR1AsS0FBS3dCLEdBQUwsYUFBWXFILFlBQVlyTyxHQUFaLENBQWdCLFVBQUM2UCxLQUFEO0FBQUEsYUFBV0EsTUFBTTlKLENBQWpCO0FBQUEsS0FBaEIsRUFBb0M2SixPQUFwQyxDQUFaO0FBRkEsR0FBUDtBQUlIOztBQUNEclIsUUFBUXVSLFdBQVIsR0FBc0JBLFdBQXRCOztBQUNBLFNBQVNDLGFBQVQsR0FBbUM7QUFBQSxxQ0FBVEgsT0FBUztBQUFUQSxXQUFTO0FBQUE7O0FBQy9CLFNBQU87QUFDSHhOLE9BQUdvRCxLQUFLeUIsR0FBTCxhQUFZb0gsWUFBWXJPLEdBQVosQ0FBZ0IsVUFBQzZQLEtBQUQ7QUFBQSxhQUFXQSxNQUFNek4sQ0FBakI7QUFBQSxLQUFoQixFQUFvQ3dOLE9BQXBDLENBQVosQ0FEQTtBQUVIN0osT0FBR1AsS0FBS3dCLEdBQUwsYUFBWXFILFlBQVlyTyxHQUFaLENBQWdCLFVBQUM2UCxLQUFEO0FBQUEsYUFBV0EsTUFBTTlKLENBQWpCO0FBQUEsS0FBaEIsRUFBb0M2SixPQUFwQyxDQUFaO0FBRkEsR0FBUDtBQUlIOztBQUNEclIsUUFBUXdSLGFBQVIsR0FBd0JBLGFBQXhCOztBQUNBLFNBQVNOLGNBQVQsR0FBb0M7QUFBQSxxQ0FBVEcsT0FBUztBQUFUQSxXQUFTO0FBQUE7O0FBQ2hDLFNBQU87QUFDSHhOLE9BQUdvRCxLQUFLeUIsR0FBTCxhQUFZb0gsWUFBWXJPLEdBQVosQ0FBZ0IsVUFBQzZQLEtBQUQ7QUFBQSxhQUFXQSxNQUFNek4sQ0FBakI7QUFBQSxLQUFoQixFQUFvQ3dOLE9BQXBDLENBQVosQ0FEQTtBQUVIN0osT0FBR1AsS0FBS3lCLEdBQUwsYUFBWW9ILFlBQVlyTyxHQUFaLENBQWdCLFVBQUM2UCxLQUFEO0FBQUEsYUFBV0EsTUFBTTlKLENBQWpCO0FBQUEsS0FBaEIsRUFBb0M2SixPQUFwQyxDQUFaO0FBRkEsR0FBUDtBQUlIOztBQUNEclIsUUFBUWtSLGNBQVIsR0FBeUJBLGNBQXpCOztBQUNBLFNBQVNPLFNBQVQsR0FBK0I7QUFDM0IsTUFBTUMsS0FBS1QsbUNBQVg7QUFDQSxNQUFNVSxLQUFLVCx1Q0FBWDtBQUNBLFNBQU87QUFDSHJOLE9BQUc2TixHQUFHN04sQ0FBSCxHQUFPLENBQUM4TixHQUFHOU4sQ0FBSCxHQUFPNk4sR0FBRzdOLENBQVgsSUFBZ0IsQ0FEdkI7QUFFSDJELE9BQUdrSyxHQUFHbEssQ0FBSCxHQUFPLENBQUNtSyxHQUFHbkssQ0FBSCxHQUFPa0ssR0FBR2xLLENBQVgsSUFBZ0I7QUFGdkIsR0FBUDtBQUlIOztBQUNEeEgsUUFBUXlSLFNBQVIsR0FBb0JBLFNBQXBCLEM7Ozs7Ozs7O0FDdkNBOztBQUNBM1IsT0FBT0MsY0FBUCxDQUFzQkMsT0FBdEIsRUFBK0IsWUFBL0IsRUFBNkM7QUFBRUMsU0FBTztBQUFULENBQTdDOztBQUNBLElBQU1xTSx5QkFBeUIsbUJBQUE1TSxDQUFRLHVFQUFSLENBQS9COztBQUNBLFNBQVMyUCxZQUFULEdBQWlDO0FBQUEsb0NBQVJ1QyxNQUFRO0FBQVJBLFVBQVE7QUFBQTs7QUFDN0IsU0FBT3RGLHVCQUF1QitDLFlBQXZCLCtCQUF1Q3VDLE1BQXZDLFFBQWtEQSxPQUFPblEsR0FBUCxDQUFXO0FBQUEsV0FBUztBQUFFb0MsU0FBR2dPLEtBQUtoTyxDQUFMLEdBQVNnTyxLQUFLckksS0FBbkI7QUFBMEJoQyxTQUFHcUssS0FBS3JLLENBQUwsR0FBU3FLLEtBQUtwSTtBQUEzQyxLQUFUO0FBQUEsR0FBWCxDQUFsRCxFQUFQO0FBQ0g7O0FBQ0R6SixRQUFRcVAsWUFBUixHQUF1QkEsWUFBdkI7O0FBQ0EsU0FBU3pGLFFBQVQsR0FBNkI7QUFBQSxxQ0FBUmdJLE1BQVE7QUFBUkEsVUFBUTtBQUFBOztBQUN6QixTQUFPdEYsdUJBQXVCMUMsUUFBdkIsK0JBQW1DZ0ksTUFBbkMsUUFBOENBLE9BQU9uUSxHQUFQLENBQVc7QUFBQSxXQUFTO0FBQUVvQyxTQUFHZ08sS0FBS2hPLENBQUwsR0FBU2dPLEtBQUtySSxLQUFuQjtBQUEwQmhDLFNBQUdxSyxLQUFLckssQ0FBTCxHQUFTcUssS0FBS3BJO0FBQTNDLEtBQVQ7QUFBQSxHQUFYLENBQTlDLEVBQVA7QUFDSDs7QUFDRHpKLFFBQVE0SixRQUFSLEdBQW1CQSxRQUFuQixDOzs7Ozs7OztBQ1ZBOztBQUNBOUosT0FBT0MsY0FBUCxDQUFzQkMsT0FBdEIsRUFBK0IsWUFBL0IsRUFBNkM7QUFBRUMsU0FBTztBQUFULENBQTdDOztBQUNBLFNBQVN5SixFQUFULENBQVlDLFFBQVosRUFBc0I7QUFDbEIsU0FBT0EsU0FBUzlGLENBQVQsSUFBYyxJQUFkLElBQXNCOEYsU0FBU25DLENBQVQsSUFBYyxJQUFwQyxJQUE0Q21DLFNBQVNILEtBQVQsSUFBa0IsSUFBOUQsSUFBc0VHLFNBQVNGLE1BQVQsSUFBbUIsSUFBaEc7QUFDSDs7QUFDRHpKLFFBQVEwSixFQUFSLEdBQWFBLEVBQWIsQzs7Ozs7Ozs7QUNMQTs7QUFDQTVKLE9BQU9DLGNBQVAsQ0FBc0JDLE9BQXRCLEVBQStCLFlBQS9CLEVBQTZDO0FBQUVDLFNBQU87QUFBVCxDQUE3Qzs7QUFDQSxJQUFNMkosV0FBVyxtQkFBQWxLLENBQVEsK0VBQVIsQ0FBakI7O0FBQ0EsSUFBTWdLLEtBQUssbUJBQUFoSyxDQUFRLHlFQUFSLENBQVg7O0FBQ0EsSUFBTWlPLFFBQVEsbUJBQUFqTyxDQUFRLDRFQUFSLENBQWQ7O0FBQ0EsSUFBTW1LLFNBQVMsbUJBQUFuSyxDQUFRLDZFQUFSLENBQWY7O0FBQ0EsSUFBTWdNLFdBQVcsbUJBQUFoTSxDQUFRLDhFQUFSLENBQWpCOztBQUNBLElBQU15UixPQUFPLG1CQUFBelIsQ0FBUSwyRUFBUixDQUFiOztBQUNBTSxRQUFROFIsU0FBUixHQUFvQmhTLE9BQU9vSixNQUFQLENBQWMsVUFBQ3JGLENBQUQsRUFBSTJELENBQUosRUFBT2dDLEtBQVAsRUFBY0MsTUFBZDtBQUFBLFNBQTBCO0FBQUU1RixRQUFGO0FBQUsyRCxRQUFMO0FBQVFnQyxnQkFBUjtBQUFlQztBQUFmLEdBQTFCO0FBQUEsQ0FBZCxFQUFrRTNKLE9BQU9vSixNQUFQLENBQWMsRUFBZCxFQUFrQlUsUUFBbEIsRUFBNEJ1SCxJQUE1QixFQUFrQ3pILEVBQWxDLEVBQXNDZ0MsUUFBdEMsRUFBZ0Q3QixNQUFoRCxFQUF3RDhELEtBQXhELENBQWxFLENBQXBCLEM7Ozs7Ozs7O0FDUkE7O0FBQ0E3TixPQUFPQyxjQUFQLENBQXNCQyxPQUF0QixFQUErQixZQUEvQixFQUE2QztBQUFFQyxTQUFPO0FBQVQsQ0FBN0M7O0FBQ0EsSUFBTStKLHNCQUFzQixtQkFBQXRLLENBQVEsNkRBQVIsQ0FBNUI7O0FBQ0EsSUFBTTRLLG9CQUFvQixtQkFBQTVLLENBQVEsbUVBQVIsQ0FBMUI7O0FBQ0EsSUFBTXVLLGtCQUFrQixtQkFBQXZLLENBQVEsK0RBQVIsQ0FBeEI7O0FBQ0EsSUFBTXdLLHNCQUFzQixtQkFBQXhLLENBQVEsbUVBQVIsQ0FBNUI7O0FBQ0EsSUFBTTJLLHNCQUFzQixtQkFBQTNLLENBQVEsdUVBQVIsQ0FBNUI7O0FBQ0EsSUFBTXlLLHVCQUF1QixtQkFBQXpLLENBQVEseUVBQVIsQ0FBN0I7O0FBQ0EsSUFBTTZNLDBCQUEwQixtQkFBQTdNLENBQVEsNEVBQVIsQ0FBaEM7O0FBQ0EsSUFBTXFTLHlCQUF5QixtQkFBQXJTLENBQVEsMkVBQVIsQ0FBL0I7O0FBQ0EsU0FBU21LLE1BQVQsQ0FBZ0JuQyxHQUFoQixFQUFxQkMsR0FBckIsRUFBMEI7QUFDdEIsTUFBSXNDLGdCQUFnQlAsRUFBaEIsQ0FBbUIvQixHQUFuQixDQUFKLEVBQTZCO0FBQUEsZ0NBQ1Z1QyxvQkFBb0IrRixvQkFBcEIsQ0FBeUN0SSxHQUF6QyxFQUE4Q0QsR0FBOUMsQ0FEVTtBQUFBLFFBQ2xCOEMsQ0FEa0I7QUFBQSxRQUNmQyxDQURlOztBQUV6QixXQUFPLENBQUNBLENBQUQsRUFBSUQsQ0FBSixDQUFQO0FBQ0gsR0FIRCxNQUlLLElBQUlILG9CQUFvQlgsRUFBcEIsQ0FBdUIvQixHQUF2QixDQUFKLEVBQWlDO0FBQ2xDLFdBQU9xSyx3QkFBd0J0SyxHQUF4QixFQUE2QkMsR0FBN0IsQ0FBUDtBQUNILEdBRkksTUFHQSxJQUFJMkMsa0JBQWtCWixFQUFsQixDQUFxQi9CLEdBQXJCLENBQUosRUFBK0I7QUFDaEMsV0FBT2lELHNCQUFzQmxELEdBQXRCLEVBQTJCQyxHQUEzQixDQUFQO0FBQ0gsR0FGSSxNQUdBLElBQUl3QyxxQkFBcUJULEVBQXJCLENBQXdCL0IsR0FBeEIsQ0FBSixFQUFrQztBQUNuQyxXQUFPc0sseUJBQXlCdkssR0FBekIsRUFBOEJDLEdBQTlCLENBQVA7QUFDSCxHQUZJLE1BR0E7QUFDRCxXQUFPdUssc0JBQXNCeEssR0FBdEIsRUFBMkJDLEdBQTNCLENBQVA7QUFDSDtBQUNKOztBQUNEM0gsUUFBUTZKLE1BQVIsR0FBaUJBLE1BQWpCOztBQUNBLFNBQVNtSSx1QkFBVCxDQUFpQ3RLLEdBQWpDLEVBQXNDQyxHQUF0QyxFQUEyQztBQUFBLDhCQUNGNEUsd0JBQXdCb0IsS0FBeEIsQ0FBOEJqRyxHQUE5QixDQURFO0FBQUEsTUFDL0JvRyxJQUQrQix5QkFDL0JBLElBRCtCO0FBQUEsTUFDekJDLEtBRHlCLHlCQUN6QkEsS0FEeUI7QUFBQSxNQUNsQkYsR0FEa0IseUJBQ2xCQSxHQURrQjtBQUFBLE1BQ2JELE1BRGEseUJBQ2JBLE1BRGE7O0FBRXZDLFNBQU8xRCxvQkFBb0JpRyxnQkFBcEIsQ0FBcUMsQ0FDeENqRyxvQkFBb0I4RixvQkFBcEIsQ0FBeUNsQyxJQUF6QyxFQUErQ25HLEdBQS9DLENBRHdDLEVBRXhDdUMsb0JBQW9COEYsb0JBQXBCLENBQXlDakMsS0FBekMsRUFBZ0RwRyxHQUFoRCxDQUZ3QyxFQUd4Q3VDLG9CQUFvQjhGLG9CQUFwQixDQUF5Q25DLEdBQXpDLEVBQThDbEcsR0FBOUMsQ0FId0MsRUFJeEN1QyxvQkFBb0I4RixvQkFBcEIsQ0FBeUNwQyxNQUF6QyxFQUFpRGpHLEdBQWpELENBSndDLENBQXJDLENBQVA7QUFNSDs7QUFDRDNILFFBQVFnUyx1QkFBUixHQUFrQ0EsdUJBQWxDOztBQUNBLFNBQVNDLHdCQUFULENBQWtDdkssR0FBbEMsRUFBdUNDLEdBQXZDLEVBQTRDO0FBQ3hDO0FBQ0EsTUFBTXdLLFlBQVlKLHVCQUF1Qk4sU0FBdkIsQ0FBaUMvSixHQUFqQyxDQUFsQjtBQUNBLE1BQU0wSyxZQUFZTCx1QkFBdUJOLFNBQXZCLENBQWlDOUosR0FBakMsQ0FBbEI7O0FBSHdDLGdCQUl0QmtDLE9BQU9uQyxHQUFQLEVBQVkwSyxTQUFaLENBSnNCO0FBQUEsTUFJakNDLE9BSmlDOztBQUFBLGlCQUt0QnhJLE9BQU9sQyxHQUFQLEVBQVl3SyxTQUFaLENBTHNCO0FBQUEsTUFLakNHLE9BTGlDOztBQU14QyxTQUFPLENBQUNELE9BQUQsRUFBVUMsT0FBVixDQUFQO0FBQ0g7O0FBQ0R0UyxRQUFRaVMsd0JBQVIsR0FBbUNBLHdCQUFuQzs7QUFDQSxTQUFTckgscUJBQVQsQ0FBK0JsRCxHQUEvQixFQUFvQ0MsR0FBcEMsRUFBeUM7QUFBQSw4QkFDTXVLLHNCQUFzQnhLLEdBQXRCLEVBQTJCQyxHQUEzQixDQUROO0FBQUEsTUFDOUI0SyxnQkFEOEI7QUFBQSxNQUNaQyxjQURZOztBQUVyQyxNQUFNQyxlQUFlekksb0JBQW9CcEMsUUFBcEIsQ0FBNkIySyxnQkFBN0IsRUFBK0NDLGNBQS9DLENBQXJCO0FBQ0EsTUFBTUUsaUJBQWlCMUksb0JBQW9CN0IsU0FBcEIsQ0FBOEJzSyxZQUE5QixDQUF2QjtBQUNBLE1BQU1FLHFCQUFxQjNJLG9CQUFvQm5DLFFBQXBCLENBQTZCNkssY0FBN0IsRUFBNkMvSyxJQUFJNEIsTUFBakQsQ0FBM0I7QUFDQSxNQUFNcUosZ0JBQWdCNUksb0JBQW9CcEcsR0FBcEIsQ0FBd0IrTyxrQkFBeEIsRUFBNENILGNBQTVDLENBQXRCO0FBQ0EsU0FBTyxDQUFDRCxnQkFBRCxFQUFtQkssYUFBbkIsQ0FBUDtBQUNIOztBQUNENVMsUUFBUTRLLHFCQUFSLEdBQWdDQSxxQkFBaEM7O0FBQ0EsU0FBU3NILHFCQUFULENBQStCeEssR0FBL0IsRUFBb0NDLEdBQXBDLEVBQXlDO0FBQ3JDLE1BQUlBLElBQUk5RCxDQUFKLElBQVM2RCxJQUFJN0QsQ0FBakIsRUFBb0I7QUFDaEIsUUFBSThELElBQUlILENBQUosSUFBU0UsSUFBSUYsQ0FBakIsRUFBb0I7QUFDaEIsYUFBTyxDQUFDRSxHQUFELEVBQU1DLEdBQU4sQ0FBUDtBQUNILEtBRkQsTUFHSyxJQUFJQSxJQUFJSCxDQUFKLEdBQVFFLElBQUlGLENBQUosR0FBUUUsSUFBSStCLE1BQXhCLEVBQWdDO0FBQ2pDLGFBQU8sQ0FBQ3NJLHVCQUF1QlAsYUFBdkIsQ0FBcUM5SixHQUFyQyxDQUFELEVBQTRDQyxHQUE1QyxDQUFQO0FBQ0gsS0FGSSxNQUdBO0FBQ0QsYUFBTyxDQUFDO0FBQUU5RCxXQUFHNkQsSUFBSTdELENBQVQ7QUFBWTJELFdBQUdHLElBQUlIO0FBQW5CLE9BQUQsRUFBeUJHLEdBQXpCLENBQVA7QUFDSDtBQUNKLEdBVkQsTUFXSyxJQUFJQSxJQUFJOUQsQ0FBSixJQUFTNkQsSUFBSTdELENBQUosR0FBUTZELElBQUk4QixLQUF6QixFQUFnQztBQUNqQyxRQUFJN0IsSUFBSUgsQ0FBSixHQUFRRSxJQUFJRixDQUFoQixFQUFtQjtBQUNmLGFBQU8sQ0FBQ3VLLHVCQUF1QlIsV0FBdkIsQ0FBbUM3SixHQUFuQyxDQUFELEVBQTBDQyxHQUExQyxDQUFQO0FBQ0gsS0FGRCxNQUdLLElBQUlBLElBQUlILENBQUosR0FBUUUsSUFBSUYsQ0FBSixHQUFRRSxJQUFJK0IsTUFBeEIsRUFBZ0M7QUFDakMsYUFBTyxDQUFDc0ksdUJBQXVCYixjQUF2QixDQUFzQ3hKLEdBQXRDLENBQUQsRUFBNkNDLEdBQTdDLENBQVA7QUFDSCxLQUZJLE1BR0E7QUFDRCxhQUFPLENBQUM7QUFBRTlELFdBQUc2RCxJQUFJN0QsQ0FBSixHQUFRNkQsSUFBSThCLEtBQWpCO0FBQXdCaEMsV0FBR0csSUFBSUg7QUFBL0IsT0FBRCxFQUFxQ0csR0FBckMsQ0FBUDtBQUNIO0FBQ0osR0FWSSxNQVdBLElBQUlBLElBQUlILENBQUosSUFBU0UsSUFBSUYsQ0FBakIsRUFBb0I7QUFDckIsV0FBTyxDQUFDO0FBQUUzRCxTQUFHOEQsSUFBSTlELENBQVQ7QUFBWTJELFNBQUdFLElBQUlGO0FBQW5CLEtBQUQsRUFBeUJHLEdBQXpCLENBQVA7QUFDSCxHQUZJLE1BR0EsSUFBSUEsSUFBSUgsQ0FBSixJQUFTRSxJQUFJRixDQUFKLEdBQVFFLElBQUkrQixNQUF6QixFQUFpQztBQUNsQyxXQUFPLENBQUM7QUFBRTVGLFNBQUc4RCxJQUFJOUQsQ0FBVDtBQUFZMkQsU0FBR0UsSUFBSUYsQ0FBSixHQUFRRSxJQUFJK0I7QUFBM0IsS0FBRCxFQUFzQzlCLEdBQXRDLENBQVA7QUFDSCxHQUZJLE1BR0E7QUFDRCxXQUFPLENBQUNvSyx1QkFBdUJOLFNBQXZCLENBQWlDL0osR0FBakMsQ0FBRCxFQUF3Q0MsR0FBeEMsQ0FBUDtBQUNIO0FBQ0o7O0FBQ0QzSCxRQUFRa1MscUJBQVIsR0FBZ0NBLHFCQUFoQyxDOzs7Ozs7OztBQzFGQTs7QUFDQXBTLE9BQU9DLGNBQVAsQ0FBc0JDLE9BQXRCLEVBQStCLFlBQS9CLEVBQTZDO0FBQUVDLFNBQU87QUFBVCxDQUE3Qzs7QUFDQSxJQUFNNFMsNkJBQTZCLG1CQUFBblQsQ0FBUSwrRUFBUixDQUFuQzs7QUFDQSxTQUFTaU8sS0FBVCxDQUFlbUYsU0FBZixFQUEwQjtBQUN0QixNQUFNbEosV0FBV2lKLDJCQUEyQnhELFlBQTNCLENBQXdDeUQsU0FBeEMsQ0FBakI7QUFDQSxTQUFPO0FBQ0hqRixTQUFLLENBQUNqRSxTQUFTckIsT0FBVixFQUFtQjtBQUFFMUUsU0FBRytGLFNBQVNwQixXQUFULENBQXFCM0UsQ0FBMUI7QUFBNkIyRCxTQUFHb0MsU0FBU3JCLE9BQVQsQ0FBaUJmO0FBQWpELEtBQW5CLENBREY7QUFFSHNHLFVBQU0sQ0FBQ2xFLFNBQVNyQixPQUFWLEVBQW1CO0FBQUUxRSxTQUFHK0YsU0FBU3JCLE9BQVQsQ0FBaUIxRSxDQUF0QjtBQUF5QjJELFNBQUdvQyxTQUFTcEIsV0FBVCxDQUFxQmhCO0FBQWpELEtBQW5CLENBRkg7QUFHSG9HLFlBQVEsQ0FBQztBQUFFL0osU0FBRytGLFNBQVNyQixPQUFULENBQWlCMUUsQ0FBdEI7QUFBeUIyRCxTQUFHb0MsU0FBU3BCLFdBQVQsQ0FBcUJoQjtBQUFqRCxLQUFELEVBQXVEb0MsU0FBU3BCLFdBQWhFLENBSEw7QUFJSHVGLFdBQU8sQ0FBQztBQUFFbEssU0FBRytGLFNBQVNwQixXQUFULENBQXFCM0UsQ0FBMUI7QUFBNkIyRCxTQUFHb0MsU0FBU3JCLE9BQVQsQ0FBaUJmO0FBQWpELEtBQUQsRUFBdURvQyxTQUFTcEIsV0FBaEU7QUFKSixHQUFQO0FBTUg7O0FBQ0R4SSxRQUFRMk4sS0FBUixHQUFnQkEsS0FBaEIsQzs7Ozs7Ozs7QUNaQTs7QUFDQTdOLE9BQU9DLGNBQVAsQ0FBc0JDLE9BQXRCLEVBQStCLFlBQS9CLEVBQTZDO0FBQUVDLFNBQU87QUFBVCxDQUE3Qzs7QUFDQSxJQUFNcUssb0JBQW9CLG1CQUFBNUssQ0FBUSxtRUFBUixDQUExQjs7QUFDQSxJQUFNNkwseUJBQXlCLG1CQUFBN0wsQ0FBUSxzRUFBUixDQUEvQjs7QUFDQSxJQUFNdUssa0JBQWtCLG1CQUFBdkssQ0FBUSwrREFBUixDQUF4Qjs7QUFDQSxJQUFNOEwsc0JBQXNCLG1CQUFBOUwsQ0FBUSxtRUFBUixDQUE1Qjs7QUFDQSxJQUFNMkssc0JBQXNCLG1CQUFBM0ssQ0FBUSx1RUFBUixDQUE1Qjs7QUFDQSxJQUFNK0wsMkJBQTJCLG1CQUFBL0wsQ0FBUSw0RUFBUixDQUFqQzs7QUFDQSxJQUFNeUssdUJBQXVCLG1CQUFBekssQ0FBUSx5RUFBUixDQUE3Qjs7QUFDQSxJQUFNMEssMkJBQTJCLG1CQUFBMUssQ0FBUSw2RUFBUixDQUFqQzs7QUFDQSxTQUFTZ00sUUFBVCxDQUFrQmhFLEdBQWxCLEVBQXVCQyxHQUF2QixFQUE0QjtBQUN4QixNQUFJc0MsZ0JBQWdCUCxFQUFoQixDQUFtQi9CLEdBQW5CLENBQUosRUFBNkI7QUFDekIsV0FBT29MLHVCQUF1QnJMLEdBQXZCLEVBQTRCQyxHQUE1QixDQUFQO0FBQ0gsR0FGRCxNQUdLLElBQUkwQyxvQkFBb0JYLEVBQXBCLENBQXVCL0IsR0FBdkIsQ0FBSixFQUFpQztBQUNsQyxXQUFPcUwsMkJBQTJCdEwsR0FBM0IsRUFBZ0NDLEdBQWhDLENBQVA7QUFDSCxHQUZJLE1BR0EsSUFBSXdDLHFCQUFxQlQsRUFBckIsQ0FBd0IvQixHQUF4QixDQUFKLEVBQWtDO0FBQ25DLFdBQU9zTCwyQkFBMkJ2TCxHQUEzQixFQUFnQ0MsR0FBaEMsQ0FBUDtBQUNILEdBRkksTUFHQSxJQUFJMkMsa0JBQWtCWixFQUFsQixDQUFxQi9CLEdBQXJCLENBQUosRUFBK0I7QUFDaEMsV0FBT3VMLHdCQUF3QnhMLEdBQXhCLEVBQTZCQyxHQUE3QixDQUFQO0FBQ0gsR0FGSSxNQUdBO0FBQ0QsV0FBT3dMLHdCQUF3QnpMLEdBQXhCLEVBQTZCQyxHQUE3QixDQUFQO0FBQ0g7QUFDSjs7QUFDRDNILFFBQVEwTCxRQUFSLEdBQW1CQSxRQUFuQjs7QUFDQSxTQUFTcUgsc0JBQVQsQ0FBZ0NyTCxHQUFoQyxFQUFxQ0MsR0FBckMsRUFBMEM7QUFDdEMsTUFBSXdMLHdCQUF3QnpMLEdBQXhCLEVBQTZCQyxJQUFJLENBQUosQ0FBN0IsS0FBd0N3TCx3QkFBd0J6TCxHQUF4QixFQUE2QkMsSUFBSSxDQUFKLENBQTdCLENBQTVDLEVBQWtGO0FBQzlFLFdBQU8sSUFBUDtBQUNIOztBQUNELFNBQU80RCx1QkFBdUJxQix3QkFBdkIsQ0FBZ0RqRixHQUFoRCxFQUFxREQsR0FBckQsQ0FBUDtBQUNIOztBQUNEMUgsUUFBUStTLHNCQUFSLEdBQWlDQSxzQkFBakM7O0FBQ0EsU0FBU0MsMEJBQVQsQ0FBb0N0TCxHQUFwQyxFQUF5Q0MsR0FBekMsRUFBOEM7QUFDMUMsU0FBTzhELHlCQUF5QjJILDBCQUF6QixDQUFvRHpMLEdBQXBELEVBQXlERCxHQUF6RCxDQUFQO0FBQ0g7O0FBQ0QxSCxRQUFRZ1QsMEJBQVIsR0FBcUNBLDBCQUFyQzs7QUFDQSxTQUFTQywwQkFBVCxDQUFvQ3ZMLEdBQXBDLEVBQXlDQyxHQUF6QyxFQUE4QztBQUMxQyxTQUFPLEVBQUVELElBQUk3RCxDQUFKLEdBQVE4RCxJQUFJOUQsQ0FBSixHQUFROEQsSUFBSTZCLEtBQXBCLElBQ0Y5QixJQUFJRixDQUFKLEdBQVFHLElBQUlILENBQUosR0FBUUcsSUFBSThCLE1BRGxCLElBRUYvQixJQUFJN0QsQ0FBSixHQUFRNkQsSUFBSThCLEtBQVosR0FBb0I3QixJQUFJOUQsQ0FGdEIsSUFHRjZELElBQUlGLENBQUosR0FBUUUsSUFBSStCLE1BQVosR0FBcUI5QixJQUFJSCxDQUh6QixDQUFQO0FBSUg7O0FBQ0R4SCxRQUFRaVQsMEJBQVIsR0FBcUNBLDBCQUFyQzs7QUFDQSxTQUFTQyx1QkFBVCxDQUFpQ3hMLEdBQWpDLEVBQXNDQyxHQUF0QyxFQUEyQztBQUN2QyxTQUFPd0wsd0JBQXdCekwsR0FBeEIsRUFBNkJDLEdBQTdCLEtBQXFDNkQsb0JBQW9CVSxRQUFwQixDQUE2QjlCLHlCQUF5QlAsTUFBekIsQ0FBZ0NuQyxHQUFoQyxFQUFxQztBQUFFN0QsT0FBRzhELElBQUk5RCxDQUFUO0FBQVkyRCxPQUFHRyxJQUFJSDtBQUFuQixHQUFyQyxDQUE3QixLQUE4RkcsSUFBSTRCLE1BQTlJO0FBQ0g7O0FBQ0R2SixRQUFRa1QsdUJBQVIsR0FBa0NBLHVCQUFsQzs7QUFDQSxTQUFTQyx1QkFBVCxDQUFpQ3pMLEdBQWpDLEVBQXNDQyxHQUF0QyxFQUEyQztBQUN2QyxTQUFPQSxJQUFJOUQsQ0FBSixJQUFTNkQsSUFBSTdELENBQWIsSUFBa0I4RCxJQUFJOUQsQ0FBSixJQUFTNkQsSUFBSTdELENBQUosR0FBUTZELElBQUk4QixLQUF2QyxJQUFnRDdCLElBQUlILENBQUosSUFBU0UsSUFBSUYsQ0FBN0QsSUFBa0VHLElBQUlILENBQUosSUFBU0UsSUFBSUYsQ0FBSixHQUFRRSxJQUFJK0IsTUFBOUY7QUFDSDs7QUFDRHpKLFFBQVFtVCx1QkFBUixHQUFrQ0EsdUJBQWxDLEM7Ozs7Ozs7O0FDckRBOztBQUNBclQsT0FBT0MsY0FBUCxDQUFzQkMsT0FBdEIsRUFBK0IsWUFBL0IsRUFBNkM7QUFBRUMsU0FBTztBQUFULENBQTdDOztBQUNBLFNBQVN3UixTQUFULENBQW1CcUIsU0FBbkIsRUFBOEI7QUFDMUIsU0FBTztBQUNIalAsT0FBR2lQLFVBQVVqUCxDQUFWLEdBQWNpUCxVQUFVdEosS0FBVixHQUFrQixDQURoQztBQUVIaEMsT0FBR3NMLFVBQVV0TCxDQUFWLEdBQWNzTCxVQUFVckosTUFBVixHQUFtQjtBQUZqQyxHQUFQO0FBSUg7O0FBQ0R6SixRQUFReVIsU0FBUixHQUFvQkEsU0FBcEI7O0FBQ0EsU0FBU1IsVUFBVCxDQUFvQjZCLFNBQXBCLEVBQStCO0FBQzNCLFNBQU87QUFDSGpQLE9BQUdpUCxVQUFValAsQ0FEVjtBQUVIMkQsT0FBR3NMLFVBQVV0TDtBQUZWLEdBQVA7QUFJSDs7QUFDRHhILFFBQVFpUixVQUFSLEdBQXFCQSxVQUFyQjs7QUFDQSxTQUFTTSxXQUFULENBQXFCdUIsU0FBckIsRUFBZ0M7QUFDNUIsU0FBTztBQUNIalAsT0FBR2lQLFVBQVVqUCxDQUFWLEdBQWNpUCxVQUFVdEosS0FEeEI7QUFFSGhDLE9BQUdzTCxVQUFVdEw7QUFGVixHQUFQO0FBSUg7O0FBQ0R4SCxRQUFRdVIsV0FBUixHQUFzQkEsV0FBdEI7O0FBQ0EsU0FBU0MsYUFBVCxDQUF1QnNCLFNBQXZCLEVBQWtDO0FBQzlCLFNBQU87QUFDSGpQLE9BQUdpUCxVQUFValAsQ0FEVjtBQUVIMkQsT0FBR3NMLFVBQVV0TCxDQUFWLEdBQWNzTCxVQUFVcko7QUFGeEIsR0FBUDtBQUlIOztBQUNEekosUUFBUXdSLGFBQVIsR0FBd0JBLGFBQXhCOztBQUNBLFNBQVNOLGNBQVQsQ0FBd0I0QixTQUF4QixFQUFtQztBQUMvQixTQUFPO0FBQ0hqUCxPQUFHaVAsVUFBVWpQLENBQVYsR0FBY2lQLFVBQVV0SixLQUR4QjtBQUVIaEMsT0FBR3NMLFVBQVV0TCxDQUFWLEdBQWNzTCxVQUFVcko7QUFGeEIsR0FBUDtBQUlIOztBQUNEekosUUFBUWtSLGNBQVIsR0FBeUJBLGNBQXpCOztBQUNBLFNBQVNtQyxzQkFBVCxDQUFnQzNCLEVBQWhDLEVBQW9DQyxFQUFwQyxFQUF3QztBQUNwQyxTQUFPO0FBQ0g5TixPQUFHNk4sR0FBRzdOLENBREg7QUFFSDJELE9BQUdrSyxHQUFHbEssQ0FGSDtBQUdIZ0MsV0FBT21JLEdBQUc5TixDQUFILEdBQU82TixHQUFHN04sQ0FIZDtBQUlINEYsWUFBUWtJLEdBQUduSyxDQUFILEdBQU9rSyxHQUFHbEs7QUFKZixHQUFQO0FBTUg7O0FBQ0R4SCxRQUFRcVQsc0JBQVIsR0FBaUNBLHNCQUFqQyxDOzs7Ozs7OztBQzdDQTs7QUFDQXZULE9BQU9DLGNBQVAsQ0FBc0JDLE9BQXRCLEVBQStCLFlBQS9CLEVBQTZDO0FBQUVDLFNBQU87QUFBVCxDQUE3Qzs7QUFDQSxJQUFNMFAsaUJBQWlCLG1CQUFBalEsQ0FBUSx3REFBUixDQUF2Qjs7QUFDQSxJQUFNNFQsaUJBQWlCLG1CQUFBNVQsQ0FBUSxnRUFBUixDQUF2Qjs7QUFDQSxJQUFNNlQsZUFBZSxtQkFBQTdULENBQVEsNERBQVIsQ0FBckI7O0FBQ0EsSUFBTThULGdCQUFnQixtQkFBQTlULENBQVEsOERBQVIsQ0FBdEI7O0FBQ0EsSUFBTStULG9CQUFvQixtQkFBQS9ULENBQVEsc0VBQVIsQ0FBMUI7O0FBQ0EsSUFBTXFTLHlCQUF5QixtQkFBQXJTLENBQVEsMkVBQVIsQ0FBL0I7O0FBQ0EsSUFBTWdVLG1CQUFtQixtQkFBQWhVLENBQVEsb0VBQVIsQ0FBekI7O0FBQ0EsSUFBSWlVLGlCQUFpQixtQkFBQWpVLENBQVEsZ0VBQVIsQ0FBckI7O0FBQ0FNLFFBQVErSixNQUFSLEdBQWlCNEosZUFBZTVKLE1BQWhDOztBQUNBLElBQUk2SixnQkFBZ0IsbUJBQUFsVSxDQUFRLDhEQUFSLENBQXBCOztBQUNBTSxRQUFRb1IsTUFBUixHQUFpQndDLGNBQWN4QyxNQUEvQjs7QUFDQSxJQUFJeUMsZUFBZSxtQkFBQW5VLENBQVEsNERBQVIsQ0FBbkI7O0FBQ0FNLFFBQVEwUCxLQUFSLEdBQWdCbUUsYUFBYW5FLEtBQTdCOztBQUNBLElBQUlvRSxvQkFBb0IsbUJBQUFwVSxDQUFRLHNFQUFSLENBQXhCOztBQUNBTSxRQUFROFIsU0FBUixHQUFvQmdDLGtCQUFrQmhDLFNBQXRDOztBQUNBLElBQUlpQyxlQUFlLG1CQUFBclUsQ0FBUSw0REFBUixDQUFuQjs7QUFDQU0sUUFBUWdVLEtBQVIsR0FBZ0JELGFBQWFDLEtBQTdCOztBQUNBLElBQUlDLG1CQUFtQixtQkFBQXZVLENBQVEsb0VBQVIsQ0FBdkI7O0FBQ0FNLFFBQVFrVSxTQUFSLEdBQW9CRCxpQkFBaUJDLFNBQXJDO0FBQ0FsVSxRQUFRbVUsTUFBUixHQUFpQjtBQUNiQyxXQURhLHFCQUNIMU0sR0FERyxFQUNFQyxHQURGLEVBQ087QUFDaEIsUUFBSTRMLGFBQWE3RCxLQUFiLENBQW1CaEcsRUFBbkIsQ0FBc0JoQyxHQUF0QixDQUFKLEVBQWdDO0FBQzVCLGFBQU82TCxhQUFhN0QsS0FBYixDQUFtQmxELFVBQW5CLENBQThCOUUsR0FBOUIsRUFBbUNDLEdBQW5DLENBQVA7QUFDSCxLQUZELE1BR0ssSUFBSStMLGlCQUFpQlEsU0FBakIsQ0FBMkJ4SyxFQUEzQixDQUE4QmhDLEdBQTlCLENBQUosRUFBd0M7QUFDekMsYUFBT2dNLGlCQUFpQlEsU0FBakIsQ0FBMkJ4SSxRQUEzQixDQUFvQ2hFLEdBQXBDLEVBQXlDQyxHQUF6QyxDQUFQO0FBQ0gsS0FGSSxNQUdBLElBQUkyTCxlQUFldkosTUFBZixDQUFzQkwsRUFBdEIsQ0FBeUJoQyxHQUF6QixDQUFKLEVBQW1DO0FBQ3BDLGFBQU80TCxlQUFldkosTUFBZixDQUFzQjJCLFFBQXRCLENBQStCaEUsR0FBL0IsRUFBb0NDLEdBQXBDLENBQVA7QUFDSCxLQUZJLE1BR0EsSUFBSThMLGtCQUFrQjNCLFNBQWxCLENBQTRCcEksRUFBNUIsQ0FBK0JoQyxHQUEvQixDQUFKLEVBQXlDO0FBQzFDLGFBQU8rTCxrQkFBa0IzQixTQUFsQixDQUE0QnBHLFFBQTVCLENBQXFDaEUsR0FBckMsRUFBMENDLEdBQTFDLENBQVA7QUFDSCxLQUZJLE1BR0E7QUFDRCxhQUFPLEtBQVA7QUFDSDtBQUNKLEdBakJZO0FBa0JiL0QsS0FsQmEsZUFrQlQ4RCxHQWxCUyxFQWtCSkMsR0FsQkksRUFrQkM7QUFDVixRQUFJdEYsTUFBTW1OLE9BQU4sQ0FBYzlILEdBQWQsQ0FBSixFQUF3QjtBQUNwQixhQUFPQSxJQUFJakcsR0FBSixDQUFRO0FBQUEsZUFBUWtPLGVBQWUxRyxPQUFmLENBQXVCckYsR0FBdkIsQ0FBMkJ5USxJQUEzQixFQUFpQzFNLEdBQWpDLENBQVI7QUFBQSxPQUFSLENBQVA7QUFDSCxLQUZELE1BR0s7QUFDRCxhQUFPN0gsT0FBT29KLE1BQVAsQ0FBYyxFQUFkLEVBQWtCeEIsR0FBbEIsRUFBdUJpSSxlQUFlMUcsT0FBZixDQUF1QnJGLEdBQXZCLENBQTJCOEQsR0FBM0IsRUFBZ0NDLEdBQWhDLENBQXZCLENBQVA7QUFDSDtBQUNKLEdBekJZO0FBMEJiOEosV0ExQmEscUJBMEJINkMsS0ExQkcsRUEwQkk7QUFDYixRQUFJalMsTUFBTW1OLE9BQU4sQ0FBYzhFLEtBQWQsQ0FBSixFQUEwQjtBQUN0QixhQUFPO0FBQ0h6USxXQUFHeVEsTUFBTTdTLEdBQU4sQ0FBVTtBQUFBLGlCQUFLZ0osRUFBRTVHLENBQVA7QUFBQSxTQUFWLEVBQW9CN0IsTUFBcEIsQ0FBMkIsVUFBQ3VTLEdBQUQsRUFBTWhFLElBQU47QUFBQSxpQkFBZWdFLE1BQU1oRSxJQUFyQjtBQUFBLFNBQTNCLElBQXdEK0QsTUFBTWhSLE1BRDlEO0FBRUhrRSxXQUFHOE0sTUFBTTdTLEdBQU4sQ0FBVTtBQUFBLGlCQUFLZ0osRUFBRWpELENBQVA7QUFBQSxTQUFWLEVBQW9CeEYsTUFBcEIsQ0FBMkIsVUFBQ3VTLEdBQUQsRUFBTWhFLElBQU47QUFBQSxpQkFBZWdFLE1BQU1oRSxJQUFyQjtBQUFBLFNBQTNCLElBQXdEK0QsTUFBTWhSO0FBRjlELE9BQVA7QUFJSCxLQUxELE1BTUssSUFBSW1RLGtCQUFrQjNCLFNBQWxCLENBQTRCcEksRUFBNUIsQ0FBK0I0SyxLQUEvQixDQUFKLEVBQTJDO0FBQzVDLGFBQU92Qyx1QkFBdUJOLFNBQXZCLENBQWlDNkMsS0FBakMsQ0FBUDtBQUNILEtBRkksTUFHQTtBQUNELGFBQU87QUFBRXpRLFdBQUd5USxNQUFNelEsQ0FBWDtBQUFjMkQsV0FBRzhNLE1BQU05TTtBQUF2QixPQUFQO0FBQ0g7QUFDSixHQXZDWTtBQXdDYm9DLFVBeENhLG9CQXdDSmxDLEdBeENJLEVBd0NDO0FBQ1YsUUFBSTZMLGFBQWE3RCxLQUFiLENBQW1CaEcsRUFBbkIsQ0FBc0JoQyxHQUF0QixDQUFKLEVBQWdDO0FBQzVCLFVBQU1hLFVBQVU7QUFBRTFFLFdBQUdvRCxLQUFLd0IsR0FBTCxDQUFTZixJQUFJLENBQUosRUFBTzdELENBQWhCLEVBQW1CNkQsSUFBSSxDQUFKLEVBQU83RCxDQUExQixDQUFMO0FBQW1DMkQsV0FBR1AsS0FBS3dCLEdBQUwsQ0FBU2YsSUFBSSxDQUFKLEVBQU9GLENBQWhCLEVBQW1CRSxJQUFJLENBQUosRUFBT0YsQ0FBMUI7QUFBdEMsT0FBaEI7QUFDQSxVQUFNZ0IsY0FBYztBQUFFM0UsV0FBR29ELEtBQUt5QixHQUFMLENBQVNoQixJQUFJLENBQUosRUFBTzdELENBQWhCLEVBQW1CNkQsSUFBSSxDQUFKLEVBQU83RCxDQUExQixDQUFMO0FBQW1DMkQsV0FBR1AsS0FBS3lCLEdBQUwsQ0FBU2hCLElBQUksQ0FBSixFQUFPRixDQUFoQixFQUFtQkUsSUFBSSxDQUFKLEVBQU9GLENBQTFCO0FBQXRDLE9BQXBCO0FBQ0EsYUFBT2lNLGtCQUFrQjNCLFNBQWxCLENBQTRCdUIsc0JBQTVCLENBQW1EOUssT0FBbkQsRUFBNERDLFdBQTVELENBQVA7QUFDSCxLQUpELE1BS0ssSUFBSWtMLGlCQUFpQlEsU0FBakIsQ0FBMkJ4SyxFQUEzQixDQUE4QmhDLEdBQTlCLENBQUosRUFBd0M7QUFDekMsVUFBTWEsV0FBVTtBQUFFMUUsV0FBR29ELEtBQUt3QixHQUFMLENBQVNmLElBQUksQ0FBSixFQUFPN0QsQ0FBaEIsRUFBbUI2RCxJQUFJLENBQUosRUFBTzdELENBQTFCLEVBQTZCNkQsSUFBSSxDQUFKLEVBQU83RCxDQUFwQyxDQUFMO0FBQTZDMkQsV0FBR1AsS0FBS3dCLEdBQUwsQ0FBU2YsSUFBSSxDQUFKLEVBQU9GLENBQWhCLEVBQW1CRSxJQUFJLENBQUosRUFBT0YsQ0FBMUIsRUFBNkJFLElBQUksQ0FBSixFQUFPRixDQUFwQztBQUFoRCxPQUFoQjtBQUNBLFVBQU1nQixlQUFjO0FBQUUzRSxXQUFHb0QsS0FBS3lCLEdBQUwsQ0FBU2hCLElBQUksQ0FBSixFQUFPN0QsQ0FBaEIsRUFBbUI2RCxJQUFJLENBQUosRUFBTzdELENBQTFCLEVBQTZCNkQsSUFBSSxDQUFKLEVBQU83RCxDQUFwQyxDQUFMO0FBQTZDMkQsV0FBR1AsS0FBS3lCLEdBQUwsQ0FBU2hCLElBQUksQ0FBSixFQUFPRixDQUFoQixFQUFtQkUsSUFBSSxDQUFKLEVBQU9GLENBQTFCLEVBQTZCRSxJQUFJLENBQUosRUFBT0YsQ0FBcEM7QUFBaEQsT0FBcEI7QUFDQSxhQUFPaU0sa0JBQWtCM0IsU0FBbEIsQ0FBNEJ1QixzQkFBNUIsQ0FBbUQ5SyxRQUFuRCxFQUE0REMsWUFBNUQsQ0FBUDtBQUNILEtBSkksTUFLQSxJQUFJOEssZUFBZXZKLE1BQWYsQ0FBc0JMLEVBQXRCLENBQXlCaEMsR0FBekIsQ0FBSixFQUFtQztBQUNwQyxhQUFPK0wsa0JBQWtCM0IsU0FBbEIsQ0FBNEJwSyxJQUFJN0QsQ0FBSixHQUFRNkQsSUFBSTZCLE1BQXhDLEVBQWdEN0IsSUFBSUYsQ0FBSixHQUFRRSxJQUFJNkIsTUFBNUQsRUFBb0U3QixJQUFJNkIsTUFBSixHQUFhLENBQWpGLEVBQW9GN0IsSUFBSTZCLE1BQUosR0FBYSxDQUFqRyxDQUFQO0FBQ0gsS0FGSSxNQUdBLElBQUlrSyxrQkFBa0IzQixTQUFsQixDQUE0QnBJLEVBQTVCLENBQStCaEMsR0FBL0IsQ0FBSixFQUF5QztBQUMxQyxhQUFPQSxHQUFQO0FBQ0gsS0FGSSxNQUdBLElBQUk4TCxjQUFjcEMsTUFBZCxDQUFxQjFILEVBQXJCLENBQXdCaEMsR0FBeEIsQ0FBSixFQUFrQztBQUNuQyxhQUFPK0wsa0JBQWtCM0IsU0FBbEIsQ0FBNEJwSyxJQUFJN0QsQ0FBaEMsRUFBbUM2RCxJQUFJRixDQUF2QyxFQUEwQyxDQUExQyxFQUE2QyxDQUE3QyxDQUFQO0FBQ0gsS0FGSSxNQUdBO0FBQ0QsYUFBT2lNLGtCQUFrQjNCLFNBQWxCLENBQTRCLENBQTVCLEVBQStCLENBQS9CLEVBQWtDLENBQWxDLEVBQXFDLENBQXJDLENBQVA7QUFDSDtBQUNKLEdBL0RZO0FBZ0ViakksUUFoRWEsa0JBZ0VObkMsR0FoRU0sRUFnRURDLEdBaEVDLEVBZ0VJO0FBQ2IsUUFBSTRMLGFBQWE3RCxLQUFiLENBQW1CaEcsRUFBbkIsQ0FBc0JoQyxHQUF0QixDQUFKLEVBQWdDO0FBQzVCLGFBQU82TCxhQUFhN0QsS0FBYixDQUFtQjdGLE1BQW5CLENBQTBCbkMsR0FBMUIsRUFBK0JDLEdBQS9CLENBQVA7QUFDSCxLQUZELE1BR0ssSUFBSStMLGlCQUFpQlEsU0FBakIsQ0FBMkJ4SyxFQUEzQixDQUE4QmhDLEdBQTlCLENBQUosRUFBd0M7QUFDekMsYUFBT2dNLGlCQUFpQlEsU0FBakIsQ0FBMkJySyxNQUEzQixDQUFrQ25DLEdBQWxDLEVBQXVDQyxHQUF2QyxDQUFQO0FBQ0gsS0FGSSxNQUdBLElBQUkyTCxlQUFldkosTUFBZixDQUFzQkwsRUFBdEIsQ0FBeUJoQyxHQUF6QixDQUFKLEVBQW1DO0FBQ3BDLGFBQU80TCxlQUFldkosTUFBZixDQUFzQkYsTUFBdEIsQ0FBNkJuQyxHQUE3QixFQUFrQ0MsR0FBbEMsQ0FBUDtBQUNILEtBRkksTUFHQSxJQUFJOEwsa0JBQWtCM0IsU0FBbEIsQ0FBNEJwSSxFQUE1QixDQUErQmhDLEdBQS9CLENBQUosRUFBeUM7QUFDMUMsYUFBTytMLGtCQUFrQjNCLFNBQWxCLENBQTRCakksTUFBNUIsQ0FBbUNuQyxHQUFuQyxFQUF3Q0MsR0FBeEMsQ0FBUDtBQUNILEtBRkksTUFHQSxJQUFJNkwsY0FBY3BDLE1BQWQsQ0FBcUIxSCxFQUFyQixDQUF3QmhDLEdBQXhCLENBQUosRUFBa0M7QUFDbkMsVUFBTThNLE9BQU8sU0FBUEEsSUFBTztBQUFBLFlBQUUvSixDQUFGO0FBQUEsWUFBS0QsQ0FBTDtBQUFBLGVBQVksQ0FBQ0EsQ0FBRCxFQUFJQyxDQUFKLENBQVo7QUFBQSxPQUFiOztBQUNBLFVBQUk4SSxhQUFhN0QsS0FBYixDQUFtQmhHLEVBQW5CLENBQXNCL0IsR0FBdEIsQ0FBSixFQUFnQztBQUM1QixlQUFPNk0sS0FBS3hVLFFBQVFtVSxNQUFSLENBQWV0SyxNQUFmLENBQXNCbEMsR0FBdEIsRUFBMkJELEdBQTNCLENBQUwsQ0FBUDtBQUNILE9BRkQsTUFHSyxJQUFJZ00saUJBQWlCUSxTQUFqQixDQUEyQnhLLEVBQTNCLENBQThCL0IsR0FBOUIsQ0FBSixFQUF3QztBQUN6QyxlQUFPNk0sS0FBS2QsaUJBQWlCUSxTQUFqQixDQUEyQnJLLE1BQTNCLENBQWtDbEMsR0FBbEMsRUFBdUNELEdBQXZDLENBQUwsQ0FBUDtBQUNILE9BRkksTUFHQSxJQUFJNEwsZUFBZXZKLE1BQWYsQ0FBc0JMLEVBQXRCLENBQXlCL0IsR0FBekIsQ0FBSixFQUFtQztBQUNwQyxlQUFPNk0sS0FBS2xCLGVBQWV2SixNQUFmLENBQXNCRixNQUF0QixDQUE2QmxDLEdBQTdCLEVBQWtDRCxHQUFsQyxDQUFMLENBQVA7QUFDSCxPQUZJLE1BR0EsSUFBSStMLGtCQUFrQjNCLFNBQWxCLENBQTRCcEksRUFBNUIsQ0FBK0IvQixHQUEvQixDQUFKLEVBQXlDO0FBQzFDLGVBQU82TSxLQUFLZixrQkFBa0IzQixTQUFsQixDQUE0QmpJLE1BQTVCLENBQW1DbEMsR0FBbkMsRUFBd0NELEdBQXhDLENBQUwsQ0FBUDtBQUNILE9BRkksTUFHQSxJQUFJOEwsY0FBY3BDLE1BQWQsQ0FBcUIxSCxFQUFyQixDQUF3Qi9CLEdBQXhCLENBQUosRUFBa0M7QUFDbkMsZUFBTyxDQUFDRCxHQUFELEVBQU1DLEdBQU4sQ0FBUDtBQUNILE9BRkksTUFHQTtBQUNELGVBQU8sQ0FBQzZMLGNBQWNwQyxNQUFkLENBQXFCLENBQXJCLEVBQXdCLENBQXhCLENBQUQsRUFBNkJvQyxjQUFjcEMsTUFBZCxDQUFxQixDQUFyQixFQUF3QixDQUF4QixDQUE3QixDQUFQO0FBQ0g7QUFDSixLQXBCSSxNQXFCQTtBQUNELGFBQU8sQ0FBQ29DLGNBQWNwQyxNQUFkLENBQXFCLENBQXJCLEVBQXdCLENBQXhCLENBQUQsRUFBNkJvQyxjQUFjcEMsTUFBZCxDQUFxQixDQUFyQixFQUF3QixDQUF4QixDQUE3QixDQUFQO0FBQ0g7QUFDSjtBQXJHWSxDQUFqQixDOzs7Ozs7OztBQ3JCQTs7QUFDQXRSLE9BQU9DLGNBQVAsQ0FBc0JDLE9BQXRCLEVBQStCLFlBQS9CLEVBQTZDO0FBQUVDLFNBQU87QUFBVCxDQUE3Qzs7QUFDQSxTQUFTeUosRUFBVCxDQUFZQyxRQUFaLEVBQXNCO0FBQ2xCLFNBQU9BLFNBQVM4SyxJQUFULElBQWlCLElBQWpCLElBQXlCOUssU0FBUzlGLENBQVQsSUFBYyxJQUF2QyxJQUErQzhGLFNBQVNuQyxDQUFULElBQWMsSUFBcEU7QUFDSDs7QUFDRHhILFFBQVEwSixFQUFSLEdBQWFBLEVBQWIsQzs7Ozs7Ozs7QUNMQTs7QUFDQTVKLE9BQU9DLGNBQVAsQ0FBc0JDLE9BQXRCLEVBQStCLFlBQS9CLEVBQTZDO0FBQUVDLFNBQU87QUFBVCxDQUE3Qzs7QUFDQSxJQUFNeUosS0FBSyxtQkFBQWhLLENBQVEsK0RBQVIsQ0FBWDs7QUFDQU0sUUFBUWdVLEtBQVIsR0FBZ0JsVSxPQUFPb0osTUFBUCxDQUFjLFVBQUN1TCxJQUFELEVBQU81USxDQUFQLEVBQVUyRCxDQUFWLEVBQWFrTixRQUFiLEVBQXVCQyxVQUF2QjtBQUFBLFNBQXVDO0FBQUVGLGNBQUY7QUFBUTVRLFFBQVI7QUFBVzJELFFBQVg7QUFBY2tOLHNCQUFkO0FBQXdCQztBQUF4QixHQUF2QztBQUFBLENBQWQsRUFBNEY3VSxPQUFPb0osTUFBUCxDQUFjLEVBQWQsRUFBa0JRLEVBQWxCLENBQTVGLENBQWhCLEM7Ozs7Ozs7O0FDSEE7O0FBQ0E1SixPQUFPQyxjQUFQLENBQXNCQyxPQUF0QixFQUErQixZQUEvQixFQUE2QztBQUFFQyxTQUFPO0FBQVQsQ0FBN0M7O0FBQ0EsU0FBU3lKLEVBQVQsQ0FBWUMsUUFBWixFQUFzQjtBQUNsQixTQUFPdEgsTUFBTW1OLE9BQU4sQ0FBYzdGLFFBQWQsS0FBMkJBLFNBQVNyRyxNQUFULEtBQW9CLENBQXREO0FBQ0g7O0FBQ0R0RCxRQUFRMEosRUFBUixHQUFhQSxFQUFiLEM7Ozs7Ozs7O0FDTEE7O0FBQ0E1SixPQUFPQyxjQUFQLENBQXNCQyxPQUF0QixFQUErQixZQUEvQixFQUE2QztBQUFFQyxTQUFPO0FBQVQsQ0FBN0M7O0FBQ0EsSUFBTXlKLEtBQUssbUJBQUFoSyxDQUFRLHVFQUFSLENBQVg7O0FBQ0EsSUFBTWlPLFFBQVEsbUJBQUFqTyxDQUFRLDBFQUFSLENBQWQ7O0FBQ0EsSUFBTWdNLFdBQVcsbUJBQUFoTSxDQUFRLDRFQUFSLENBQWpCOztBQUNBLElBQU1tSyxTQUFTLG1CQUFBbkssQ0FBUSwyRUFBUixDQUFmOztBQUNBTSxRQUFRa1UsU0FBUixHQUFvQnBVLE9BQU9vSixNQUFQLENBQWMsVUFBQ3VCLENBQUQsRUFBSUQsQ0FBSixFQUFPUSxDQUFQO0FBQUEsU0FBYSxDQUFDUCxDQUFELEVBQUlELENBQUosRUFBT1EsQ0FBUCxDQUFiO0FBQUEsQ0FBZCxFQUFzQ2xMLE9BQU9vSixNQUFQLENBQWMsRUFBZCxFQUFrQlEsRUFBbEIsRUFBc0JnQyxRQUF0QixFQUFnQ2lDLEtBQWhDLEVBQXVDOUQsTUFBdkMsQ0FBdEMsQ0FBcEIsQzs7Ozs7Ozs7QUNOQTs7QUFDQS9KLE9BQU9DLGNBQVAsQ0FBc0JDLE9BQXRCLEVBQStCLFlBQS9CLEVBQTZDO0FBQUVDLFNBQU87QUFBVCxDQUE3Qzs7QUFDQSxJQUFNNFAsb0JBQW9CLG1CQUFBblEsQ0FBUSxvREFBUixDQUExQjs7QUFDQSxJQUFNb1EsY0FBYyxtQkFBQXBRLENBQVEsaUVBQVIsQ0FBcEI7O0FBQ0EsSUFBTTRLLG9CQUFvQixtQkFBQTVLLENBQVEsbUVBQVIsQ0FBMUI7O0FBQ0EsSUFBTWtWLHdCQUF3QixtQkFBQWxWLENBQVEsdUVBQVIsQ0FBOUI7O0FBQ0EsSUFBTXVLLGtCQUFrQixtQkFBQXZLLENBQVEsK0RBQVIsQ0FBeEI7O0FBQ0EsSUFBTXdLLHNCQUFzQixtQkFBQXhLLENBQVEsbUVBQVIsQ0FBNUI7O0FBQ0EsSUFBTXlLLHVCQUF1QixtQkFBQXpLLENBQVEseUVBQVIsQ0FBN0I7O0FBQ0EsSUFBTTBLLDJCQUEyQixtQkFBQTFLLENBQVEsNkVBQVIsQ0FBakM7O0FBQ0EsSUFBTTJLLHNCQUFzQixtQkFBQTNLLENBQVEsdUVBQVIsQ0FBNUI7O0FBQ0EsSUFBTW1WLHlCQUF5QixtQkFBQW5WLENBQVEsMEVBQVIsQ0FBL0I7O0FBQ0EsU0FBU21LLE1BQVQsQ0FBZ0JuQyxHQUFoQixFQUFxQkMsR0FBckIsRUFBMEI7QUFDdEIsTUFBSXNDLGdCQUFnQlAsRUFBaEIsQ0FBbUIvQixHQUFuQixDQUFKLEVBQTZCO0FBQ3pCLFdBQU82TSxLQUFLdEssb0JBQW9COEYsb0JBQXBCLENBQXlDckksR0FBekMsRUFBOENELEdBQTlDLENBQUwsQ0FBUDtBQUNILEdBRkQsTUFHSyxJQUFJMkMsb0JBQW9CWCxFQUFwQixDQUF1Qi9CLEdBQXZCLENBQUosRUFBaUM7QUFDbEMsV0FBT21OLHlCQUF5QnBOLEdBQXpCLEVBQThCQyxHQUE5QixDQUFQO0FBQ0gsR0FGSSxNQUdBLElBQUkyQyxrQkFBa0JaLEVBQWxCLENBQXFCL0IsR0FBckIsQ0FBSixFQUErQjtBQUNoQyxXQUFPNk0sS0FBS0ksc0JBQXNCbEsscUJBQXRCLENBQTRDL0MsR0FBNUMsRUFBaURELEdBQWpELENBQUwsQ0FBUDtBQUNILEdBRkksTUFHQSxJQUFJeUMscUJBQXFCVCxFQUFyQixDQUF3Qi9CLEdBQXhCLENBQUosRUFBa0M7QUFDbkMsV0FBTzZNLEtBQUtwSyx5QkFBeUI0SCx1QkFBekIsQ0FBaURySyxHQUFqRCxFQUFzREQsR0FBdEQsQ0FBTCxDQUFQO0FBQ0gsR0FGSSxNQUdBO0FBQ0QsV0FBT3FOLHFCQUFxQnJOLEdBQXJCLEVBQTBCQyxHQUExQixDQUFQO0FBQ0g7QUFDSjs7QUFDRDNILFFBQVE2SixNQUFSLEdBQWlCQSxNQUFqQjs7QUFDQSxJQUFNMkssT0FBTyxTQUFQQSxJQUFPO0FBQUEsTUFBRS9KLENBQUY7QUFBQSxNQUFLRCxDQUFMO0FBQUEsU0FBWSxDQUFDQSxDQUFELEVBQUlDLENBQUosQ0FBWjtBQUFBLENBQWI7O0FBQ0EsU0FBU3FLLHdCQUFULENBQWtDcE4sR0FBbEMsRUFBdUNDLEdBQXZDLEVBQTRDO0FBQ3hDLE1BQU1xTixZQUFZSCx1QkFBdUJsSCxLQUF2QixDQUE2QmpHLEdBQTdCLENBQWxCO0FBQ0EsTUFBTXVOLGFBQWFKLHVCQUF1QmxILEtBQXZCLENBQTZCaEcsR0FBN0IsQ0FBbkI7QUFDQSxTQUFPa0ksa0JBQWtCeFAsRUFBbEIsQ0FBcUIyVSxTQUFyQixFQUNGbFIsQ0FERSxDQUNBZ00sWUFBWW5PLE9BQVosQ0FBb0IsVUFBQ3VULEtBQUQ7QUFBQSxXQUFXcEYsWUFBWXJPLEdBQVosQ0FBZ0IsVUFBQzBULEtBQUQ7QUFBQSxhQUFXakwsb0JBQW9CNkYsZ0JBQXBCLENBQXFDbUYsS0FBckMsRUFBNENDLEtBQTVDLENBQVg7QUFBQSxLQUFoQixFQUErRUYsVUFBL0UsQ0FBWDtBQUFBLEdBQXBCLENBREEsRUFFRjVVLEVBRkUsQ0FFQzZKLG9CQUFvQmlHLGdCQUZyQixDQUFQO0FBR0g7O0FBQ0RuUSxRQUFROFUsd0JBQVIsR0FBbUNBLHdCQUFuQzs7QUFDQSxTQUFTQyxvQkFBVCxDQUE4QnJOLEdBQTlCLEVBQW1DQyxHQUFuQyxFQUF3QztBQUNwQyxTQUFPa0ksa0JBQWtCeFAsRUFBbEIsQ0FBcUJxSCxHQUFyQixFQUNGNUQsQ0FERSxDQUNBK1EsdUJBQXVCbEgsS0FEdkIsRUFFRjdKLENBRkUsQ0FFQWdNLFlBQVlyTyxHQUFaLENBQWdCO0FBQUEsV0FBUXlJLG9CQUFvQmdHLGlCQUFwQixDQUFzQ04sSUFBdEMsRUFBNENqSSxHQUE1QyxDQUFSO0FBQUEsR0FBaEIsQ0FGQSxFQUdGdEgsRUFIRSxDQUdDNkosb0JBQW9CaUcsZ0JBSHJCLENBQVA7QUFJSDs7QUFDRG5RLFFBQVErVSxvQkFBUixHQUErQkEsb0JBQS9CLEM7Ozs7Ozs7O0FDN0NBOztBQUNBalYsT0FBT0MsY0FBUCxDQUFzQkMsT0FBdEIsRUFBK0IsWUFBL0IsRUFBNkM7QUFBRUMsU0FBTztBQUFULENBQTdDOztBQUNBLFNBQVMwTixLQUFULENBQWVqRyxHQUFmLEVBQW9CO0FBQ2hCLFNBQU8sQ0FDSCxDQUFDQSxJQUFJLENBQUosQ0FBRCxFQUFTQSxJQUFJLENBQUosQ0FBVCxDQURHLEVBRUgsQ0FBQ0EsSUFBSSxDQUFKLENBQUQsRUFBU0EsSUFBSSxDQUFKLENBQVQsQ0FGRyxFQUdILENBQUNBLElBQUksQ0FBSixDQUFELEVBQVNBLElBQUksQ0FBSixDQUFULENBSEcsQ0FBUDtBQUtIOztBQUNEMUgsUUFBUTJOLEtBQVIsR0FBZ0JBLEtBQWhCLEM7Ozs7Ozs7O0FDVEE7O0FBQ0E3TixPQUFPQyxjQUFQLENBQXNCQyxPQUF0QixFQUErQixZQUEvQixFQUE2QztBQUFFQyxTQUFPO0FBQVQsQ0FBN0M7O0FBQ0EsSUFBTXFLLG9CQUFvQixtQkFBQTVLLENBQVEsbUVBQVIsQ0FBMUI7O0FBQ0EsSUFBTTZMLHlCQUF5QixtQkFBQTdMLENBQVEsc0VBQVIsQ0FBL0I7O0FBQ0EsSUFBTXVLLGtCQUFrQixtQkFBQXZLLENBQVEsK0RBQVIsQ0FBeEI7O0FBQ0EsSUFBTXlLLHVCQUF1QixtQkFBQXpLLENBQVEseUVBQVIsQ0FBN0I7O0FBQ0EsSUFBTTZNLDBCQUEwQixtQkFBQTdNLENBQVEsNEVBQVIsQ0FBaEM7O0FBQ0EsSUFBTTJLLHNCQUFzQixtQkFBQTNLLENBQVEsdUVBQVIsQ0FBNUI7O0FBQ0EsSUFBTW1WLHlCQUF5QixtQkFBQW5WLENBQVEsMEVBQVIsQ0FBL0I7O0FBQ0EsU0FBU2dNLFFBQVQsQ0FBa0JoRSxHQUFsQixFQUF1QkMsR0FBdkIsRUFBNEI7QUFDeEIsTUFBSTBDLG9CQUFvQlgsRUFBcEIsQ0FBdUIvQixHQUF2QixDQUFKLEVBQWlDO0FBQzdCLFdBQU95TiwyQkFBMkIxTixHQUEzQixFQUFnQ0MsR0FBaEMsQ0FBUDtBQUNILEdBRkQsTUFHSyxJQUFJc0MsZ0JBQWdCUCxFQUFoQixDQUFtQi9CLEdBQW5CLENBQUosRUFBNkI7QUFDOUIsV0FBTzBOLHVCQUF1QjNOLEdBQXZCLEVBQTRCQyxHQUE1QixDQUFQO0FBQ0gsR0FGSSxNQUdBLElBQUl3QyxxQkFBcUJULEVBQXJCLENBQXdCL0IsR0FBeEIsQ0FBSixFQUFrQztBQUNuQyxXQUFPeUwsMkJBQTJCMUwsR0FBM0IsRUFBZ0NDLEdBQWhDLENBQVA7QUFDSCxHQUZJLE1BR0EsSUFBSTJDLGtCQUFrQlosRUFBbEIsQ0FBcUIvQixHQUFyQixDQUFKLEVBQStCO0FBQ2hDLFdBQU9zRSx3QkFBd0J2RSxHQUF4QixFQUE2QkMsR0FBN0IsQ0FBUDtBQUNILEdBRkksTUFHQTtBQUNELFdBQU8yTix3QkFBd0I1TixHQUF4QixFQUE2QkMsR0FBN0IsQ0FBUDtBQUNIO0FBQ0o7O0FBQ0QzSCxRQUFRMEwsUUFBUixHQUFtQkEsUUFBbkI7O0FBQ0EsU0FBU08sdUJBQVQsQ0FBaUN2RSxHQUFqQyxFQUFzQ0MsR0FBdEMsRUFBMkM7QUFDdkMsTUFBSTJOLHdCQUF3QjVOLEdBQXhCLEVBQTZCQyxHQUE3QixDQUFKLEVBQXVDO0FBQ25DLFdBQU8sSUFBUDtBQUNIOztBQUNELFNBQU9rTix1QkFBdUJsSCxLQUF2QixDQUE2QmpHLEdBQTdCLEVBQWtDbkUsSUFBbEMsQ0FBdUM7QUFBQSxXQUFRZ0ksdUJBQXVCUyxxQkFBdkIsQ0FBNkM0RCxJQUE3QyxFQUFtRGpJLEdBQW5ELENBQVI7QUFBQSxHQUF2QyxDQUFQO0FBQ0g7O0FBQ0QzSCxRQUFRaU0sdUJBQVIsR0FBa0NBLHVCQUFsQzs7QUFDQSxTQUFTbUgsMEJBQVQsQ0FBb0MxTCxHQUFwQyxFQUF5Q0MsR0FBekMsRUFBOEM7QUFBQSw4QkFDTDRFLHdCQUF3Qm9CLEtBQXhCLENBQThCaEcsR0FBOUIsQ0FESztBQUFBLE1BQ2xDaUcsTUFEa0MseUJBQ2xDQSxNQURrQztBQUFBLE1BQzFCQyxHQUQwQix5QkFDMUJBLEdBRDBCO0FBQUEsTUFDckJDLElBRHFCLHlCQUNyQkEsSUFEcUI7QUFBQSxNQUNmQyxLQURlLHlCQUNmQSxLQURlOztBQUUxQyxNQUFNd0gsY0FBYyxDQUFDM0gsTUFBRCxFQUFTQyxHQUFULEVBQWNDLElBQWQsRUFBb0JDLEtBQXBCLENBQXBCO0FBQ0EsU0FBT3dILFlBQVloUyxJQUFaLENBQWlCO0FBQUEsV0FBUThSLHVCQUF1QjNOLEdBQXZCLEVBQTRCa0ksSUFBNUIsQ0FBUjtBQUFBLEdBQWpCLENBQVA7QUFDSDs7QUFDRDVQLFFBQVFvVCwwQkFBUixHQUFxQ0EsMEJBQXJDOztBQUNBLFNBQVNnQywwQkFBVCxDQUFvQzFOLEdBQXBDLEVBQXlDQyxHQUF6QyxFQUE4QztBQUMxQyxNQUFJMk4sd0JBQXdCNU4sR0FBeEIsRUFBNkJDLElBQUksQ0FBSixDQUE3QixLQUF3QzJOLHdCQUF3QjVOLEdBQXhCLEVBQTZCQyxJQUFJLENBQUosQ0FBN0IsQ0FBeEMsSUFBZ0YyTix3QkFBd0I1TixHQUF4QixFQUE2QkMsSUFBSSxDQUFKLENBQTdCLENBQXBGLEVBQTBIO0FBQ3RILFdBQU8sSUFBUDtBQUNIOztBQUNELE1BQU02TixXQUFXWCx1QkFBdUJsSCxLQUF2QixDQUE2QmpHLEdBQTdCLENBQWpCO0FBQ0EsU0FBT21OLHVCQUF1QmxILEtBQXZCLENBQTZCaEcsR0FBN0IsRUFBa0NwRSxJQUFsQyxDQUF1QztBQUFBLFdBQVc4Uix1QkFBdUIzTixHQUF2QixFQUE0QitOLE9BQTVCLENBQVg7QUFBQSxHQUF2QyxDQUFQO0FBQ0g7O0FBQ0R6VixRQUFRb1YsMEJBQVIsR0FBcUNBLDBCQUFyQzs7QUFDQSxTQUFTQyxzQkFBVCxjQUFzRDtBQUFBLE1BQXJCckksRUFBcUI7QUFBQSxNQUFqQkMsRUFBaUI7QUFBQSxNQUFiQyxFQUFhO0FBQUEsTUFBUHpDLENBQU87QUFBQSxNQUFKRCxDQUFJOztBQUNsRCxNQUFJOEssd0JBQXdCLENBQUN0SSxFQUFELEVBQUtDLEVBQUwsRUFBU0MsRUFBVCxDQUF4QixFQUFzQ3pDLENBQXRDLEtBQTRDNkssd0JBQXdCLENBQUN0SSxFQUFELEVBQUtDLEVBQUwsRUFBU0MsRUFBVCxDQUF4QixFQUFzQzFDLENBQXRDLENBQWhELEVBQTBGO0FBQ3RGLFdBQU8sS0FBUDtBQUNIOztBQUNELFNBQU9lLHVCQUF1Qm9CLHdCQUF2QixDQUFnRCxDQUFDbEMsQ0FBRCxFQUFJRCxDQUFKLENBQWhELEVBQXdELENBQUN3QyxFQUFELEVBQUtDLEVBQUwsRUFBU0MsRUFBVCxDQUF4RCxDQUFQO0FBQ0g7O0FBQ0RsTixRQUFRcVYsc0JBQVIsR0FBaUNBLHNCQUFqQzs7QUFDQSxTQUFTQyx1QkFBVCxRQUErQzNOLEdBQS9DLEVBQW9EO0FBQUEsTUFBbEJxRixFQUFrQjtBQUFBLE1BQWRDLEVBQWM7QUFBQSxNQUFWQyxFQUFVOztBQUNoRCxNQUFNd0ksT0FBTyxTQUFQQSxJQUFPLENBQUNDLEVBQUQsRUFBS0MsRUFBTCxFQUFTQyxFQUFUO0FBQUEsV0FBZ0IsQ0FBQ0YsR0FBRzlSLENBQUgsR0FBT2dTLEdBQUdoUyxDQUFYLEtBQWlCK1IsR0FBR3BPLENBQUgsR0FBT3FPLEdBQUdyTyxDQUEzQixJQUFnQyxDQUFDb08sR0FBRy9SLENBQUgsR0FBT2dTLEdBQUdoUyxDQUFYLEtBQWlCOFIsR0FBR25PLENBQUgsR0FBT3FPLEdBQUdyTyxDQUEzQixDQUFoRDtBQUFBLEdBQWI7O0FBQ0EsTUFBTXdHLEtBQUswSCxLQUFLL04sR0FBTCxFQUFVcUYsRUFBVixFQUFjQyxFQUFkLElBQW9CLEdBQS9CO0FBQ0EsTUFBTWdCLEtBQUt5SCxLQUFLL04sR0FBTCxFQUFVc0YsRUFBVixFQUFjQyxFQUFkLElBQW9CLEdBQS9CO0FBQ0EsTUFBTTRJLEtBQUtKLEtBQUsvTixHQUFMLEVBQVV1RixFQUFWLEVBQWNGLEVBQWQsSUFBb0IsR0FBL0I7QUFDQSxTQUFTZ0IsT0FBT0MsRUFBUixJQUFnQkEsT0FBTzZILEVBQS9CO0FBQ0g7O0FBQ0Q5VixRQUFRc1YsdUJBQVIsR0FBa0NBLHVCQUFsQyxDOzs7Ozs7OztBQzlEQTs7QUFDQXhWLE9BQU9DLGNBQVAsQ0FBc0JDLE9BQXRCLEVBQStCLFlBQS9CLEVBQTZDO0FBQUVDLFNBQU87QUFBVCxDQUE3Qzs7QUFDQSxJQUFNOFYsdUJBQXVCLG1CQUFBclcsQ0FBUSwrREFBUixDQUE3Qjs7QUFDQSxJQUFNc1csaUJBQWlCLG1CQUFBdFcsQ0FBUSx5REFBUixDQUF2Qjs7QUFDQSxJQUFNdVcsd0JBQXdCLG1CQUFBdlcsQ0FBUSw2Q0FBUixDQUE5Qjs7SUFDTXdXLGE7OztBQUNGLHlCQUFZQyxPQUFaLEVBQXFCO0FBQ2pCLFNBQUtDLFFBQUwsR0FBZ0JILHNCQUFzQkksTUFBdEIsQ0FBNkJGLE9BQTdCLENBQWhCO0FBQ0g7Ozs7U0FDREcsSyxvQkFBUTtBQUNKLFFBQU1wUSxPQUFPLEtBQUtrUSxRQUFMLENBQWNHLE1BQWQsRUFBYjtBQUNBLFdBQU9yUSxRQUFRLElBQVIsR0FBZXNRLFlBQVl0USxJQUFaLENBQWYsR0FBbUMsRUFBMUM7QUFDSCxHOzs7OztBQUVMbEcsUUFBUWtXLGFBQVIsR0FBd0JBLGFBQXhCOztBQUNBLFNBQVNNLFdBQVQsQ0FBcUJ0USxJQUFyQixFQUEyQjtBQUN2QixVQUFRQSxLQUFLdVEsSUFBYjtBQUNJLFNBQUssT0FBTDtBQUNJLGFBQU8sQ0FDSFYscUJBQXFCVyxLQUFyQixDQUEyQnhRLEtBQUt5USxLQUFMLENBQVcsUUFBWCxLQUF3QlgsZUFBZTNKLEdBQWYsQ0FBbUIsQ0FBbkIsRUFBc0IsQ0FBdEIsRUFBeUIsQ0FBekIsQ0FBbkQsQ0FERyxFQUVILENBQUNuRyxLQUFLMFEsUUFBTCxJQUFpQixFQUFsQixFQUFzQm5WLEdBQXRCLENBQTBCK1UsV0FBMUIsQ0FGRyxDQUFQOztBQUlKLFNBQUssUUFBTDtBQUNJLGFBQU9ULHFCQUFxQmMsTUFBckIsQ0FBNEIzUSxLQUFLeVEsS0FBTCxDQUFXLFFBQVgsQ0FBNUIsRUFBa0QsQ0FBQ3pRLEtBQUswUSxRQUFMLElBQWlCLEVBQWxCLEVBQXNCblYsR0FBdEIsQ0FBMEIrVSxXQUExQixDQUFsRCxDQUFQOztBQUNKLFNBQUssUUFBTDtBQUNJLGFBQU9ULHFCQUFxQmUsTUFBckIsQ0FBNEI1USxLQUFLeVEsS0FBTCxDQUFXLFNBQVgsQ0FBNUIsRUFBbUQsQ0FBQ3pRLEtBQUswUSxRQUFMLElBQWlCLEVBQWxCLEVBQXNCblYsR0FBdEIsQ0FBMEIrVSxXQUExQixDQUFuRCxDQUFQOztBQUNKLFNBQUssT0FBTDtBQUNJLGFBQU9ULHFCQUFxQmdCLEtBQXJCLENBQTJCN1EsS0FBS3lRLEtBQUwsQ0FBVyxJQUFYLENBQTNCLEVBQTZDLENBQUN6USxLQUFLMFEsUUFBTCxJQUFpQixFQUFsQixFQUFzQm5WLEdBQXRCLENBQTBCK1UsV0FBMUIsQ0FBN0MsQ0FBUDs7QUFDSixTQUFLLE1BQUw7QUFDSSxhQUFPVCxxQkFBcUJpQixJQUFyQixDQUEwQjlRLEtBQUt5USxLQUFMLENBQVcsT0FBWCxDQUExQixFQUErQ3pRLEtBQUt5USxLQUFMLENBQVcsUUFBWCxDQUEvQyxDQUFQOztBQUNKLFNBQUssUUFBTDtBQUNJLGFBQU9aLHFCQUFxQmtCLE1BQXJCLENBQTRCL1EsS0FBS3lRLEtBQUwsQ0FBVyxPQUFYLENBQTVCLEVBQWlEelEsS0FBS3lRLEtBQUwsQ0FBVyxRQUFYLENBQWpELENBQVA7O0FBQ0osU0FBSyxNQUFMO0FBQ0ksYUFBT1oscUJBQXFCbUIsSUFBckIsQ0FBMEJoUixLQUFLeVEsS0FBTCxDQUFXLE9BQVgsQ0FBMUIsRUFBK0N6USxLQUFLeVEsS0FBTCxDQUFXLEtBQVgsQ0FBL0MsRUFBa0V6USxLQUFLeVEsS0FBTCxDQUFXLEtBQVgsQ0FBbEUsQ0FBUDs7QUFDSixTQUFLLGNBQUw7QUFDSSxhQUFPWixxQkFBcUJvQixZQUFyQixDQUFrQ2pSLEtBQUt5USxLQUFMLENBQVcsS0FBWCxDQUFsQyxFQUFxRCxDQUFDelEsS0FBSzBRLFFBQUwsSUFBaUIsRUFBbEIsRUFBc0JuVixHQUF0QixDQUEwQitVLFdBQTFCLENBQXJELEVBQTZGdFEsS0FBS3lRLEtBQUwsQ0FBVyxNQUFYLENBQTdGLENBQVA7O0FBQ0o7QUFDSSxhQUFPLENBQUN6USxLQUFLMFEsUUFBTCxJQUFpQixFQUFsQixFQUFzQm5WLEdBQXRCLENBQTBCK1UsV0FBMUIsQ0FBUDtBQXJCUjtBQXVCSCxDOzs7Ozs7OztBQ3ZDRDs7QUFDQTFXLE9BQU9DLGNBQVAsQ0FBc0JDLE9BQXRCLEVBQStCLFlBQS9CLEVBQTZDO0FBQUVDLFNBQU87QUFBVCxDQUE3Qzs7QUFDQUQsUUFBUW9YLEtBQVIsR0FBZ0I7QUFBQSxvQ0FBSUMsU0FBSjtBQUFJQSxhQUFKO0FBQUE7O0FBQUEsU0FBa0JBLFNBQWxCO0FBQUEsQ0FBaEI7O0FBQ0EsSUFBSUMsZ0JBQUo7O0FBQ0EsQ0FBQyxVQUFVQSxnQkFBVixFQUE0QjtBQUN6QkEsbUJBQWlCQSxpQkFBaUIsT0FBakIsSUFBNEIsQ0FBN0MsSUFBa0QsT0FBbEQ7QUFDQUEsbUJBQWlCQSxpQkFBaUIsUUFBakIsSUFBNkIsQ0FBOUMsSUFBbUQsUUFBbkQ7QUFDQUEsbUJBQWlCQSxpQkFBaUIsUUFBakIsSUFBNkIsQ0FBOUMsSUFBbUQsUUFBbkQ7QUFDQUEsbUJBQWlCQSxpQkFBaUIsT0FBakIsSUFBNEIsQ0FBN0MsSUFBa0QsT0FBbEQ7QUFDQUEsbUJBQWlCQSxpQkFBaUIsTUFBakIsSUFBMkIsQ0FBNUMsSUFBaUQsTUFBakQ7QUFDQUEsbUJBQWlCQSxpQkFBaUIsUUFBakIsSUFBNkIsQ0FBOUMsSUFBbUQsUUFBbkQ7QUFDQUEsbUJBQWlCQSxpQkFBaUIsTUFBakIsSUFBMkIsQ0FBNUMsSUFBaUQsTUFBakQ7QUFDQUEsbUJBQWlCQSxpQkFBaUIsY0FBakIsSUFBbUMsQ0FBcEQsSUFBeUQsY0FBekQ7QUFDSCxDQVRELEVBU0dBLG1CQUFtQnRYLFFBQVFzWCxnQkFBUixLQUE2QnRYLFFBQVFzWCxnQkFBUixHQUEyQixFQUF4RCxDQVR0Qjs7QUFVQXRYLFFBQVEwVyxLQUFSLEdBQWdCLFVBQUNhLE1BQUQ7QUFBQSxTQUFZQSxVQUFVLElBQVYsR0FBaUIsQ0FBQ0QsaUJBQWlCWixLQUFsQixFQUF5QmEsTUFBekIsQ0FBakIsR0FBb0QsQ0FBQ0QsaUJBQWlCWixLQUFsQixDQUFoRTtBQUFBLENBQWhCOztBQUNBMVcsUUFBUTZXLE1BQVIsR0FBaUIsVUFBQ1csTUFBRCxFQUFTQyxLQUFUO0FBQUEsU0FBbUIsQ0FBQ0gsaUJBQWlCVCxNQUFsQixFQUEwQlcsTUFBMUIsRUFBa0NDLEtBQWxDLENBQW5CO0FBQUEsQ0FBakI7O0FBQ0F6WCxRQUFROFcsTUFBUixHQUFpQixVQUFDWSxNQUFELEVBQVNELEtBQVQ7QUFBQSxTQUFtQixDQUFDSCxpQkFBaUJSLE1BQWxCLEVBQTBCWSxNQUExQixFQUFrQ0QsS0FBbEMsQ0FBbkI7QUFBQSxDQUFqQjs7QUFDQXpYLFFBQVErVyxLQUFSLEdBQWdCLFVBQUNZLEtBQUQsRUFBUUYsS0FBUjtBQUFBLFNBQWtCLENBQUNILGlCQUFpQlAsS0FBbEIsRUFBeUJZLEtBQXpCLEVBQWdDRixLQUFoQyxDQUFsQjtBQUFBLENBQWhCOztBQUNBelgsUUFBUWdYLElBQVIsR0FBZSxVQUFDWSxHQUFELEVBQU1MLE1BQU47QUFBQSxTQUFpQixDQUFDRCxpQkFBaUJOLElBQWxCLEVBQXdCWSxHQUF4QixFQUE2QkwsTUFBN0IsQ0FBakI7QUFBQSxDQUFmOztBQUNBdlgsUUFBUWlYLE1BQVIsR0FBaUIsVUFBQ1csR0FBRCxFQUFNTCxNQUFOO0FBQUEsU0FBaUIsQ0FBQ0QsaUJBQWlCTCxNQUFsQixFQUEwQlcsR0FBMUIsRUFBK0JMLE1BQS9CLENBQWpCO0FBQUEsQ0FBakI7O0FBQ0F2WCxRQUFRa1gsSUFBUixHQUFlLFVBQUMvUixLQUFELEVBQVF5UyxHQUFSLEVBQWE5UyxHQUFiO0FBQUEsU0FBcUJBLE9BQU8sSUFBUCxHQUFjLENBQUN3UyxpQkFBaUJKLElBQWxCLEVBQXdCL1IsS0FBeEIsRUFBK0J5UyxHQUEvQixFQUFvQzlTLEdBQXBDLENBQWQsR0FBeUQsQ0FBQ3dTLGlCQUFpQkosSUFBbEIsRUFBd0IvUixLQUF4QixFQUErQnlTLEdBQS9CLENBQTlFO0FBQUEsQ0FBZjs7QUFDQTVYLFFBQVFtWCxZQUFSLEdBQXVCLFVBQUNTLEdBQUQsRUFBTXRCLEtBQU4sRUFBYXVCLElBQWI7QUFBQSxTQUFzQixDQUFDUCxpQkFBaUJILFlBQWxCLEVBQWdDUyxHQUFoQyxFQUFxQ3RCLEtBQXJDLEVBQTRDdUIsSUFBNUMsQ0FBdEI7QUFBQSxDQUF2QixDOzs7Ozs7OztBQ3JCQTs7QUFDQS9YLE9BQU9DLGNBQVAsQ0FBc0JDLE9BQXRCLEVBQStCLFlBQS9CLEVBQTZDO0FBQUVDLFNBQU87QUFBVCxDQUE3Qzs7QUFDQSxJQUFNNlgsaUJBQWlCLG1CQUFBcFksQ0FBUSx5REFBUixDQUF2Qjs7QUFDQSxJQUFNcVcsdUJBQXVCLG1CQUFBclcsQ0FBUSwrREFBUixDQUE3Qjs7QUFDQSxTQUFTcVksY0FBVCxDQUF3QkMsTUFBeEIsRUFBZ0MxQixLQUFoQyxFQUF1QztBQUNuQyxTQUFPQSxNQUFNMkIsT0FBTixDQUFjLFVBQUNDLE9BQUQ7QUFBQSxXQUFhQyxjQUFjSCxNQUFkLEVBQXNCRSxPQUF0QixDQUFiO0FBQUEsR0FBZCxDQUFQO0FBQ0g7O0FBQ0RsWSxRQUFRK1gsY0FBUixHQUF5QkEsY0FBekI7O0FBQ0EsU0FBU0ksYUFBVCxDQUF1QkgsTUFBdkIsRUFBK0JFLE9BQS9CLEVBQXdDO0FBQ3BDLE1BQU1FLGNBQWNGLFFBQVEsQ0FBUixDQUFwQjs7QUFDQSxNQUFJLENBQUM3VixNQUFNbU4sT0FBTixDQUFjNEksV0FBZCxDQUFMLEVBQWlDO0FBQzdCLFlBQVFBLFdBQVI7QUFDSSxXQUFLckMscUJBQXFCdUIsZ0JBQXJCLENBQXNDWixLQUEzQztBQUNJLGVBQU8yQixZQUFZTCxNQUFaLEVBQW9CRSxPQUFwQixDQUFQOztBQUNKLFdBQUtuQyxxQkFBcUJ1QixnQkFBckIsQ0FBc0NULE1BQTNDO0FBQ0ksZUFBT3lCLGFBQWFOLE1BQWIsRUFBcUJFLE9BQXJCLENBQVA7O0FBQ0osV0FBS25DLHFCQUFxQnVCLGdCQUFyQixDQUFzQ0gsWUFBM0M7QUFDSSxlQUFPb0IsbUJBQW1CUCxNQUFuQixFQUEyQkUsT0FBM0IsQ0FBUDs7QUFDSixXQUFLbkMscUJBQXFCdUIsZ0JBQXJCLENBQXNDUixNQUEzQztBQUNJLGVBQU8wQixhQUFhUixNQUFiLEVBQXFCRSxPQUFyQixDQUFQOztBQUNKLFdBQUtuQyxxQkFBcUJ1QixnQkFBckIsQ0FBc0NQLEtBQTNDO0FBQ0ksZUFBTzBCLFlBQVlULE1BQVosRUFBb0JFLE9BQXBCLENBQVA7O0FBQ0osV0FBS25DLHFCQUFxQnVCLGdCQUFyQixDQUFzQ04sSUFBM0M7QUFDSSxlQUFPMEIsV0FBV1YsTUFBWCxFQUFtQkUsT0FBbkIsQ0FBUDs7QUFDSixXQUFLbkMscUJBQXFCdUIsZ0JBQXJCLENBQXNDTCxNQUEzQztBQUNJLGVBQU8wQixhQUFhWCxNQUFiLEVBQXFCRSxPQUFyQixDQUFQOztBQUNKLFdBQUtuQyxxQkFBcUJ1QixnQkFBckIsQ0FBc0NKLElBQTNDO0FBQ0ksZUFBTzBCLFdBQVdaLE1BQVgsRUFBbUJFLE9BQW5CLENBQVA7QUFoQlI7QUFrQkgsR0FuQkQsTUFvQks7QUFDRCxXQUFPQSxRQUFRRCxPQUFSLENBQWdCO0FBQUEsYUFBS0UsY0FBY0gsTUFBZCxFQUFzQmhOLENBQXRCLENBQUw7QUFBQSxLQUFoQixDQUFQO0FBQ0g7QUFDSjs7QUFDRCxTQUFTc04sWUFBVCxPQUFtREosT0FBbkQsRUFBNEQ7QUFBQSxNQUFwQ1csTUFBb0MsUUFBcENBLE1BQW9DO0FBQUEsTUFBNUJDLE9BQTRCLFFBQTVCQSxPQUE0QjtBQUFBLE1BQW5CQyxNQUFtQixRQUFuQkEsTUFBbUI7QUFDeEQsTUFBTXZCLFNBQVNVLFFBQVEsQ0FBUixDQUFmO0FBQ0FZLFVBQVFFLFNBQVIsQ0FBa0J4QixPQUFPM1QsQ0FBUCxHQUFXLENBQTdCLEVBQWdDMlQsT0FBT2hRLENBQVAsR0FBVyxDQUEzQztBQUNBdVEsaUJBQWU7QUFBRWMsa0JBQUY7QUFBVUMsb0JBQVY7QUFBbUJDO0FBQW5CLEdBQWYsRUFBNENiLFFBQVEsQ0FBUixDQUE1QztBQUNBWSxVQUFRRSxTQUFSLENBQWtCLENBQUN4QixPQUFPM1QsQ0FBUixHQUFZLENBQTlCLEVBQWlDLENBQUMyVCxPQUFPaFEsQ0FBUixHQUFZLENBQTdDO0FBQ0g7O0FBQ0QsU0FBU2dSLFlBQVQsUUFBbUROLE9BQW5ELEVBQTREO0FBQUEsTUFBcENXLE1BQW9DLFNBQXBDQSxNQUFvQztBQUFBLE1BQTVCQyxPQUE0QixTQUE1QkEsT0FBNEI7QUFBQSxNQUFuQkMsTUFBbUIsU0FBbkJBLE1BQW1CO0FBQ3hELE1BQU1FLFdBQVdmLFFBQVEsQ0FBUixDQUFqQjtBQUNBWSxVQUFRSSxNQUFSLENBQWVELFFBQWY7QUFDQWxCLGlCQUFlO0FBQUVjLGtCQUFGO0FBQVVDLG9CQUFWO0FBQW1CQztBQUFuQixHQUFmLEVBQTRDYixRQUFRLENBQVIsQ0FBNUM7QUFDQVksVUFBUUksTUFBUixDQUFlLENBQUNELFFBQWhCO0FBQ0g7O0FBQ0QsU0FBU1IsV0FBVCxRQUFrRFAsT0FBbEQsRUFBMkQ7QUFBQSxNQUFwQ1csTUFBb0MsU0FBcENBLE1BQW9DO0FBQUEsTUFBNUJDLE9BQTRCLFNBQTVCQSxPQUE0QjtBQUFBLE1BQW5CQyxNQUFtQixTQUFuQkEsTUFBbUI7QUFDdkQsTUFBTXBCLFFBQVFPLFFBQVEsQ0FBUixDQUFkO0FBQ0FZLFVBQVFuQixLQUFSLENBQWNBLE1BQU05VCxDQUFwQixFQUF1QjhULE1BQU1uUSxDQUE3QjtBQUNBdVEsaUJBQWU7QUFBRWMsa0JBQUY7QUFBVUMsb0JBQVY7QUFBbUJDO0FBQW5CLEdBQWYsRUFBNENiLFFBQVEsQ0FBUixDQUE1QztBQUNBWSxVQUFRbkIsS0FBUixDQUFjLElBQUlBLE1BQU05VCxDQUF4QixFQUEyQixJQUFJOFQsTUFBTW5RLENBQXJDO0FBQ0g7O0FBQ0QsU0FBU29SLFVBQVQsUUFBaURWLE9BQWpELEVBQTBEO0FBQUEsTUFBcENXLE1BQW9DLFNBQXBDQSxNQUFvQztBQUFBLE1BQTVCQyxPQUE0QixTQUE1QkEsT0FBNEI7QUFBQSxNQUFuQkMsTUFBbUIsU0FBbkJBLE1BQW1CO0FBQ3RELE1BQU01VCxRQUFRK1MsUUFBUSxDQUFSLENBQWQ7QUFDQSxNQUFNTixNQUFNTSxRQUFRLENBQVIsQ0FBWjtBQUNBLE1BQU1wVCxNQUFNb1QsUUFBUSxDQUFSLENBQVo7QUFDQSxNQUFNaUIsV0FBV0osT0FBTzdULFFBQVAsQ0FBZ0JDLEtBQWhCLENBQWpCOztBQUNBLE1BQUkyUyxlQUFlaEcsU0FBZixDQUF5QnBJLEVBQXpCLENBQTRCa08sR0FBNUIsQ0FBSixFQUFzQztBQUNsQyxRQUFJOVMsT0FBTyxJQUFYLEVBQWlCO0FBQ2JnVSxjQUFRTSxTQUFSLENBQWtCRCxRQUFsQixFQUE0QnJVLElBQUlqQixDQUFKLEdBQVEsQ0FBcEMsRUFBdUNpQixJQUFJMEMsQ0FBSixHQUFRLENBQS9DLEVBQWtEMUMsSUFBSTBFLEtBQUosR0FBWSxDQUE5RCxFQUFpRTFFLElBQUkyRSxNQUFKLEdBQWEsQ0FBOUUsRUFBaUZtTyxJQUFJL1QsQ0FBSixHQUFRLENBQXpGLEVBQTRGK1QsSUFBSXBRLENBQUosR0FBUSxDQUFwRyxFQUF1R29RLElBQUlwTyxLQUFKLEdBQVksQ0FBbkgsRUFBc0hvTyxJQUFJbk8sTUFBSixHQUFhLENBQW5JO0FBQ0gsS0FGRCxNQUdLO0FBQ0RxUCxjQUFRTSxTQUFSLENBQWtCRCxRQUFsQixFQUE0QnZCLElBQUkvVCxDQUFKLEdBQVEsQ0FBcEMsRUFBdUMrVCxJQUFJcFEsQ0FBSixHQUFRLENBQS9DLEVBQWtEb1EsSUFBSXBPLEtBQUosR0FBWSxDQUE5RCxFQUFpRW9PLElBQUluTyxNQUFKLEdBQWEsQ0FBOUU7QUFDSDtBQUNKLEdBUEQsTUFRSztBQUNEcVAsWUFBUU0sU0FBUixDQUFrQkQsUUFBbEIsRUFBNEJ2QixJQUFJL1QsQ0FBSixHQUFRLENBQXBDLEVBQXVDK1QsSUFBSXBRLENBQUosR0FBUSxDQUEvQztBQUNIO0FBQ0o7O0FBQ0QsU0FBU2tSLFVBQVQsUUFBaURXLElBQWpELEVBQXVEO0FBQUEsTUFBakNSLE1BQWlDLFNBQWpDQSxNQUFpQztBQUFBLE1BQXpCQyxPQUF5QixTQUF6QkEsT0FBeUI7QUFBQSxNQUFoQkMsTUFBZ0IsU0FBaEJBLE1BQWdCO0FBQ25ELE1BQU16RSxRQUFRK0UsS0FBSyxDQUFMLENBQWQ7QUFDQSxNQUFNOUIsU0FBUzhCLEtBQUssQ0FBTCxDQUFmO0FBQ0FQLFVBQVFRLFNBQVI7QUFDQVIsVUFBUVMsU0FBUixHQUFvQkMsUUFBUWpDLE1BQVIsQ0FBcEI7O0FBQ0EsTUFBSWxWLE1BQU1tTixPQUFOLENBQWM4RSxLQUFkLENBQUosRUFBMEI7QUFDdEJ3RSxZQUFRVyxNQUFSLENBQWVuRixNQUFNLENBQU4sRUFBU3pRLENBQVQsR0FBYSxDQUE1QixFQUErQnlRLE1BQU0sQ0FBTixFQUFTOU0sQ0FBVCxHQUFhLENBQTVDOztBQUNBLFNBQUssSUFBSTFHLElBQUksQ0FBYixFQUFnQkEsSUFBSXdULE1BQU1oUixNQUExQixFQUFrQyxFQUFFeEMsQ0FBcEMsRUFBdUM7QUFDbkNnWSxjQUFRalAsTUFBUixDQUFleUssTUFBTXhULENBQU4sRUFBUytDLENBQVQsR0FBYSxDQUE1QixFQUErQnlRLE1BQU14VCxDQUFOLEVBQVMwRyxDQUFULEdBQWEsQ0FBNUM7QUFDSDs7QUFDRHNSLFlBQVFPLElBQVI7QUFDSCxHQU5ELE1BT0ssSUFBSXZCLGVBQWU5RCxLQUFmLENBQXFCdEssRUFBckIsQ0FBd0I0SyxLQUF4QixDQUFKLEVBQW9DO0FBQ3JDLFFBQU11RCxPQUFPdkQsTUFBTUksUUFBTixJQUFrQixFQUEvQjtBQUNBb0UsWUFBUVksSUFBUixHQUFrQjdCLElBQWxCLFlBQTRCdkQsTUFBTUssVUFBTixJQUFvQixPQUFoRDtBQUNBbUUsWUFBUWEsUUFBUixDQUFpQnJGLE1BQU1HLElBQXZCLEVBQTZCSCxNQUFNelEsQ0FBTixHQUFVLENBQXZDLEVBQTJDeVEsTUFBTTlNLENBQU4sR0FBV3FRLElBQVosR0FBcUIsQ0FBL0Q7QUFDSCxHQUpJLE1BS0EsSUFBSUMsZUFBZWhHLFNBQWYsQ0FBeUJwSSxFQUF6QixDQUE0QjRLLEtBQTVCLENBQUosRUFBd0M7QUFDekN3RSxZQUFRYyxRQUFSLENBQWlCdEYsTUFBTXpRLENBQU4sR0FBVSxDQUEzQixFQUE4QnlRLE1BQU05TSxDQUFOLEdBQVUsQ0FBeEMsRUFBMkM4TSxNQUFNOUssS0FBTixHQUFjLENBQXpELEVBQTREOEssTUFBTTdLLE1BQU4sR0FBZSxDQUEzRTtBQUNILEdBRkksTUFHQSxJQUFJcU8sZUFBZS9OLE1BQWYsQ0FBc0JMLEVBQXRCLENBQXlCNEssS0FBekIsQ0FBSixFQUFxQztBQUN0Q3dFLFlBQVFlLEdBQVIsQ0FBWXZGLE1BQU16USxDQUFOLEdBQVUsQ0FBdEIsRUFBeUJ5USxNQUFNOU0sQ0FBTixHQUFVLENBQW5DLEVBQXNDOE0sTUFBTS9LLE1BQU4sR0FBZSxDQUFyRCxFQUF3RCxDQUF4RCxFQUEyRCxJQUFJdEMsS0FBS0UsRUFBcEU7QUFDQTJSLFlBQVFPLElBQVI7QUFDSDtBQUNKOztBQUNELFNBQVNWLFlBQVQsUUFBbURVLElBQW5ELEVBQXlEO0FBQUEsTUFBakNSLE1BQWlDLFNBQWpDQSxNQUFpQztBQUFBLE1BQXpCQyxPQUF5QixTQUF6QkEsT0FBeUI7QUFBQSxNQUFoQkMsTUFBZ0IsU0FBaEJBLE1BQWdCO0FBQ3JELE1BQU16RSxRQUFRK0UsS0FBSyxDQUFMLENBQWQ7QUFDQSxNQUFNOUIsU0FBUzhCLEtBQUssQ0FBTCxDQUFmO0FBQ0FQLFVBQVFRLFNBQVI7QUFDQVIsVUFBUWdCLFdBQVIsR0FBc0JOLFFBQVFqQyxNQUFSLENBQXRCOztBQUNBLE1BQUlsVixNQUFNbU4sT0FBTixDQUFjOEUsS0FBZCxDQUFKLEVBQTBCO0FBQ3RCd0UsWUFBUVcsTUFBUixDQUFlbkYsTUFBTSxDQUFOLEVBQVN6USxDQUFULEdBQWEsQ0FBNUIsRUFBK0J5USxNQUFNLENBQU4sRUFBUzlNLENBQVQsR0FBYSxDQUE1Qzs7QUFDQSxTQUFLLElBQUkxRyxJQUFJLENBQWIsRUFBZ0JBLElBQUl3VCxNQUFNaFIsTUFBMUIsRUFBa0MsRUFBRXhDLENBQXBDLEVBQXVDO0FBQ25DZ1ksY0FBUWpQLE1BQVIsQ0FBZXlLLE1BQU14VCxDQUFOLEVBQVMrQyxDQUFULEdBQWEsQ0FBNUIsRUFBK0J5USxNQUFNeFQsQ0FBTixFQUFTMEcsQ0FBVCxHQUFhLENBQTVDO0FBQ0g7O0FBQ0RzUixZQUFRaUIsTUFBUjtBQUNILEdBTkQsTUFPSyxJQUFJakMsZUFBZTlELEtBQWYsQ0FBcUJ0SyxFQUFyQixDQUF3QjRLLEtBQXhCLENBQUosRUFBb0M7QUFDckMsUUFBTXVELE9BQU92RCxNQUFNSSxRQUFOLElBQWtCLEVBQS9CO0FBQ0FvRSxZQUFRWSxJQUFSLEdBQWtCN0IsSUFBbEIsWUFBNEJ2RCxNQUFNSyxVQUFOLElBQW9CLE9BQWhEO0FBQ0FtRSxZQUFRa0IsVUFBUixDQUFtQjFGLE1BQU1HLElBQXpCLEVBQStCSCxNQUFNelEsQ0FBTixHQUFVLENBQXpDLEVBQTZDeVEsTUFBTTlNLENBQU4sR0FBV3FRLE9BQU8sQ0FBbkIsR0FBeUIsQ0FBckU7QUFDSCxHQUpJLE1BS0EsSUFBSUMsZUFBZWhHLFNBQWYsQ0FBeUJwSSxFQUF6QixDQUE0QjRLLEtBQTVCLENBQUosRUFBd0M7QUFDekN3RSxZQUFRbUIsVUFBUixDQUFtQjNGLE1BQU16USxDQUFOLEdBQVUsQ0FBN0IsRUFBZ0N5USxNQUFNOU0sQ0FBTixHQUFVLENBQTFDLEVBQTZDOE0sTUFBTTlLLEtBQU4sR0FBYyxDQUEzRCxFQUE4RDhLLE1BQU03SyxNQUFOLEdBQWUsQ0FBN0U7QUFDSCxHQUZJLE1BR0EsSUFBSXFPLGVBQWUvTixNQUFmLENBQXNCTCxFQUF0QixDQUF5QjRLLEtBQXpCLENBQUosRUFBcUM7QUFDdEN3RSxZQUFRZSxHQUFSLENBQVl2RixNQUFNelEsQ0FBTixHQUFVLENBQXRCLEVBQXlCeVEsTUFBTTlNLENBQU4sR0FBVSxDQUFuQyxFQUFzQzhNLE1BQU0vSyxNQUFOLEdBQWUsQ0FBckQsRUFBd0QsQ0FBeEQsRUFBMkQsSUFBSXRDLEtBQUtFLEVBQXBFO0FBQ0EyUixZQUFRaUIsTUFBUjtBQUNIOztBQUNEakIsVUFBUW9CLFNBQVI7QUFDSDs7QUFDRCxTQUFTN0IsV0FBVCxRQUFrRDhCLEtBQWxELEVBQXlEO0FBQUEsTUFBbEN0QixNQUFrQyxTQUFsQ0EsTUFBa0M7QUFBQSxNQUExQkMsT0FBMEIsU0FBMUJBLE9BQTBCO0FBQUEsTUFBakJDLE1BQWlCLFNBQWpCQSxNQUFpQjtBQUNyREQsVUFBUXNCLFlBQVIsQ0FBcUIsQ0FBckIsRUFBd0IsQ0FBeEIsRUFBMkIsQ0FBM0IsRUFBOEIsQ0FBOUIsRUFBaUMsQ0FBakMsRUFBb0MsQ0FBcEM7QUFDQXRCLFVBQVF1QixTQUFSLENBQWtCLENBQWxCLEVBQXFCLENBQXJCLEVBQXdCeEIsT0FBT3JQLEtBQVAsR0FBZSxDQUF2QyxFQUEwQ3FQLE9BQU9wUCxNQUFQLEdBQWdCLENBQTFEO0FBQ0EsTUFBTThOLFNBQVM0QyxNQUFNLENBQU4sQ0FBZjtBQUNBckIsVUFBUVMsU0FBUixHQUFvQmhDLFNBQVMrQyxPQUFPL0MsTUFBUCxDQUFULEdBQTBCLE9BQTlDO0FBQ0F1QixVQUFRYyxRQUFSLENBQWlCLENBQWpCLEVBQW9CLENBQXBCLEVBQXVCZixPQUFPclAsS0FBUCxHQUFlLENBQXRDLEVBQXlDcVAsT0FBT3BQLE1BQVAsR0FBZ0IsQ0FBekQ7QUFDSCxDLENBQ0Q7OztBQUNBLElBQU04USxjQUFjLEVBQXBCOztBQUNBLFNBQVNoQyxrQkFBVCxlQUFpRjtBQUFBLE1BQW5ETSxNQUFtRCxTQUFuREEsTUFBbUQ7QUFBQSxNQUEzQ0MsT0FBMkMsU0FBM0NBLE9BQTJDO0FBQUEsTUFBbENDLE1BQWtDLFNBQWxDQSxNQUFrQztBQUFBLE1BQXZCeUIsQ0FBdUI7QUFBQSxNQUFwQjVDLEdBQW9CO0FBQUEsTUFBZjZDLE1BQWU7QUFBQSxNQUFQNUMsSUFBTztBQUM3RSxNQUFNck8sUUFBUSxDQUFDcU8sUUFBUSxJQUFSLEdBQWVELElBQUlwTyxLQUFuQixHQUEyQnFPLEtBQUtoVSxDQUFqQyxJQUFzQyxDQUFwRDtBQUNBLE1BQU00RixTQUFTLENBQUNvTyxRQUFRLElBQVIsR0FBZUQsSUFBSW5PLE1BQW5CLEdBQTRCb08sS0FBS3JRLENBQWxDLElBQXVDLENBQXREO0FBQ0EsTUFBTXRHLFdBQVNzSSxLQUFULEdBQWlCQyxNQUF2QjtBQUNBLE1BQUlpUixlQUFlSCxZQUFZclosR0FBWixDQUFuQjtBQUNBcVosY0FBWXJaLEdBQVosSUFBbUIsSUFBbkI7O0FBQ0EsTUFBSXdaLGdCQUFnQixJQUFwQixFQUEwQjtBQUN0QixRQUFNQyxZQUFZQyxTQUFTQyxhQUFULENBQXVCLFFBQXZCLENBQWxCO0FBQ0FGLGNBQVVuUixLQUFWLEdBQWtCLENBQUNxTyxRQUFRLElBQVIsR0FBZUQsSUFBSXBPLEtBQW5CLEdBQTJCcU8sS0FBS2hVLENBQWpDLElBQXNDLENBQXhEO0FBQ0E4VyxjQUFVbFIsTUFBVixHQUFtQixDQUFDb08sUUFBUSxJQUFSLEdBQWVELElBQUluTyxNQUFuQixHQUE0Qm9PLEtBQUtyUSxDQUFsQyxJQUF1QyxDQUExRDtBQUNBa1QsbUJBQWU7QUFBRTdCLGNBQVE4QixTQUFWO0FBQXFCN0IsZUFBUzZCLFVBQVVHLFVBQVYsQ0FBcUIsSUFBckIsQ0FBOUI7QUFBMEQvQjtBQUExRCxLQUFmO0FBQ0g7O0FBQ0RoQixpQkFBZTJDLFlBQWYsRUFBNkJELE1BQTdCO0FBQ0EzQixVQUFRTSxTQUFSLENBQWtCc0IsYUFBYTdCLE1BQS9CLEVBQXVDakIsSUFBSS9ULENBQUosR0FBUSxDQUEvQyxFQUFrRCtULElBQUlwUSxDQUFKLEdBQVEsQ0FBMUQsRUFBNkRvUSxJQUFJcE8sS0FBSixHQUFZLENBQXpFLEVBQTRFb08sSUFBSW5PLE1BQUosR0FBYSxDQUF6RjtBQUNBOFEsY0FBWXJaLEdBQVosSUFBbUJ3WixZQUFuQjtBQUNIOztBQUNELFNBQVNsQixPQUFULENBQWlCakMsTUFBakIsRUFBeUI7QUFDckIsU0FBT0EsT0FBTzlNLENBQVAsSUFBWSxJQUFaLGNBQTJCOE0sT0FBT2pNLENBQVAsR0FBVyxDQUF0QyxZQUE0Q2lNLE9BQU9uTCxDQUFQLEdBQVcsQ0FBdkQsWUFBNkRtTCxPQUFPL00sQ0FBUCxHQUFXLENBQXhFLFdBQThFK00sT0FBTzlNLENBQXJGLFNBQTRGNlAsT0FBTy9DLE1BQVAsQ0FBbkc7QUFDSDs7QUFDRCxTQUFTK0MsTUFBVCxDQUFnQi9DLE1BQWhCLEVBQXdCO0FBQ3BCLG1CQUFjQSxPQUFPak0sQ0FBUCxHQUFXLENBQXpCLFlBQStCaU0sT0FBT25MLENBQVAsR0FBVyxDQUExQyxZQUFnRG1MLE9BQU8vTSxDQUFQLEdBQVcsQ0FBM0Q7QUFDSCxDOzs7Ozs7OztBQ3RKRDs7QUFDQTFLLE9BQU9DLGNBQVAsQ0FBc0JDLE9BQXRCLEVBQStCLFlBQS9CLEVBQTZDO0FBQUVDLFNBQU87QUFBVCxDQUE3QztBQUNBRCxRQUFRK2EsU0FBUixHQUFvQixPQUFPQyxNQUFQLEtBQWtCLFdBQXRDLEM7Ozs7Ozs7OytDQ0ZBOztBQUNBbGIsT0FBT0MsY0FBUCxDQUFzQkMsT0FBdEIsRUFBK0IsWUFBL0IsRUFBNkM7QUFBRUMsU0FBTztBQUFULENBQTdDO0FBQ0FELFFBQVFpYixZQUFSLEdBQXVCQyxXQUFXQSxRQUFRQyxHQUFuQixJQUEwQkQsUUFBUUMsR0FBUixDQUFZLFVBQVosTUFBNEIsWUFBN0UsQzs7Ozs7Ozs7QUNGQUMsT0FBT3BiLE9BQVAsR0FBaUIsVUFBVXVCLEVBQVYsRUFBYztBQUM3QixNQUFJLE9BQU9BLEVBQVAsSUFBYSxVQUFqQixFQUE2QixNQUFNOFosVUFBVTlaLEtBQUsscUJBQWYsQ0FBTjtBQUM3QixTQUFPQSxFQUFQO0FBQ0QsQ0FIRCxDOzs7Ozs7O0FDQUEsSUFBSStaLE1BQU0sbUJBQUE1YixDQUFRLHdDQUFSLENBQVY7O0FBQ0EwYixPQUFPcGIsT0FBUCxHQUFpQixVQUFVdUIsRUFBVixFQUFjZ2EsR0FBZCxFQUFtQjtBQUNsQyxNQUFJLE9BQU9oYSxFQUFQLElBQWEsUUFBYixJQUF5QitaLElBQUkvWixFQUFKLEtBQVcsUUFBeEMsRUFBa0QsTUFBTThaLFVBQVVFLEdBQVYsQ0FBTjtBQUNsRCxTQUFPLENBQUNoYSxFQUFSO0FBQ0QsQ0FIRCxDOzs7Ozs7O0FDREE7QUFDQSxJQUFJaWEsY0FBYyxtQkFBQTliLENBQVEsd0NBQVIsRUFBa0IsYUFBbEIsQ0FBbEI7O0FBQ0EsSUFBSStiLGFBQWFwWixNQUFNcVosU0FBdkI7QUFDQSxJQUFJRCxXQUFXRCxXQUFYLEtBQTJCN1ksU0FBL0IsRUFBMEMsbUJBQUFqRCxDQUFRLHlDQUFSLEVBQW1CK2IsVUFBbkIsRUFBK0JELFdBQS9CLEVBQTRDLEVBQTVDOztBQUMxQ0osT0FBT3BiLE9BQVAsR0FBaUIsVUFBVWtCLEdBQVYsRUFBZTtBQUM5QnVhLGFBQVdELFdBQVgsRUFBd0J0YSxHQUF4QixJQUErQixJQUEvQjtBQUNELENBRkQsQzs7Ozs7OztBQ0pBa2EsT0FBT3BiLE9BQVAsR0FBaUIsVUFBVXVCLEVBQVYsRUFBY29hLFdBQWQsRUFBMkI1VyxJQUEzQixFQUFpQzZXLGNBQWpDLEVBQWlEO0FBQ2hFLE1BQUksRUFBRXJhLGNBQWNvYSxXQUFoQixLQUFpQ0MsbUJBQW1CalosU0FBbkIsSUFBZ0NpWixrQkFBa0JyYSxFQUF2RixFQUE0RjtBQUMxRixVQUFNOFosVUFBVXRXLE9BQU8seUJBQWpCLENBQU47QUFDRDs7QUFBQyxTQUFPeEQsRUFBUDtBQUNILENBSkQsQzs7Ozs7OztBQ0FBLElBQUlzYSxXQUFXLG1CQUFBbmMsQ0FBUSw4Q0FBUixDQUFmOztBQUNBMGIsT0FBT3BiLE9BQVAsR0FBaUIsVUFBVXVCLEVBQVYsRUFBYztBQUM3QixNQUFJLENBQUNzYSxTQUFTdGEsRUFBVCxDQUFMLEVBQW1CLE1BQU04WixVQUFVOVosS0FBSyxvQkFBZixDQUFOO0FBQ25CLFNBQU9BLEVBQVA7QUFDRCxDQUhELEM7Ozs7Ozs7O0FDREE7QUFDQTs7QUFDQSxJQUFJdWEsV0FBVyxtQkFBQXBjLENBQVEsOENBQVIsQ0FBZjs7QUFDQSxJQUFJcWMsa0JBQWtCLG1CQUFBcmMsQ0FBUSxzREFBUixDQUF0Qjs7QUFDQSxJQUFJc2MsV0FBVyxtQkFBQXRjLENBQVEsOENBQVIsQ0FBZjs7QUFFQTBiLE9BQU9wYixPQUFQLEdBQWlCLEdBQUdpYyxVQUFILElBQWlCLFNBQVNBLFVBQVQsQ0FBb0JqRTtBQUFPO0FBQTNCLEVBQXNDcFg7QUFBTTtBQUE1QyxFQUFzRTtBQUN0RyxNQUFJc2IsSUFBSUosU0FBUyxJQUFULENBQVI7QUFDQSxNQUFJSyxNQUFNSCxTQUFTRSxFQUFFNVksTUFBWCxDQUFWO0FBQ0EsTUFBSThZLEtBQUtMLGdCQUFnQi9ELE1BQWhCLEVBQXdCbUUsR0FBeEIsQ0FBVDtBQUNBLE1BQUk3WixPQUFPeVosZ0JBQWdCbmIsS0FBaEIsRUFBdUJ1YixHQUF2QixDQUFYO0FBQ0EsTUFBSXRWLE1BQU13VixVQUFVL1ksTUFBVixHQUFtQixDQUFuQixHQUF1QitZLFVBQVUsQ0FBVixDQUF2QixHQUFzQzFaLFNBQWhEO0FBQ0EsTUFBSTlCLFFBQVFvRyxLQUFLd0IsR0FBTCxDQUFTLENBQUM1QixRQUFRbEUsU0FBUixHQUFvQndaLEdBQXBCLEdBQTBCSixnQkFBZ0JsVixHQUFoQixFQUFxQnNWLEdBQXJCLENBQTNCLElBQXdEN1osSUFBakUsRUFBdUU2WixNQUFNQyxFQUE3RSxDQUFaO0FBQ0EsTUFBSUUsTUFBTSxDQUFWOztBQUNBLE1BQUloYSxPQUFPOFosRUFBUCxJQUFhQSxLQUFLOVosT0FBT3pCLEtBQTdCLEVBQW9DO0FBQ2xDeWIsVUFBTSxDQUFDLENBQVA7QUFDQWhhLFlBQVF6QixRQUFRLENBQWhCO0FBQ0F1YixVQUFNdmIsUUFBUSxDQUFkO0FBQ0Q7O0FBQ0QsU0FBT0EsVUFBVSxDQUFqQixFQUFvQjtBQUNsQixRQUFJeUIsUUFBUTRaLENBQVosRUFBZUEsRUFBRUUsRUFBRixJQUFRRixFQUFFNVosSUFBRixDQUFSLENBQWYsS0FDSyxPQUFPNFosRUFBRUUsRUFBRixDQUFQO0FBQ0xBLFVBQU1FLEdBQU47QUFDQWhhLFlBQVFnYSxHQUFSO0FBQ0Q7O0FBQUMsU0FBT0osQ0FBUDtBQUNILENBbkJELEM7Ozs7Ozs7O0FDTkE7QUFDQTs7QUFDQSxJQUFJSixXQUFXLG1CQUFBcGMsQ0FBUSw4Q0FBUixDQUFmOztBQUNBLElBQUlxYyxrQkFBa0IsbUJBQUFyYyxDQUFRLHNEQUFSLENBQXRCOztBQUNBLElBQUlzYyxXQUFXLG1CQUFBdGMsQ0FBUSw4Q0FBUixDQUFmOztBQUNBMGIsT0FBT3BiLE9BQVAsR0FBaUIsU0FBU3FaLElBQVQsQ0FBY3BaO0FBQU07QUFBcEIsRUFBc0Q7QUFDckUsTUFBSWljLElBQUlKLFNBQVMsSUFBVCxDQUFSO0FBQ0EsTUFBSXhZLFNBQVMwWSxTQUFTRSxFQUFFNVksTUFBWCxDQUFiO0FBQ0EsTUFBSWlaLE9BQU9GLFVBQVUvWSxNQUFyQjtBQUNBLE1BQUk5QixRQUFRdWEsZ0JBQWdCUSxPQUFPLENBQVAsR0FBV0YsVUFBVSxDQUFWLENBQVgsR0FBMEIxWixTQUExQyxFQUFxRFcsTUFBckQsQ0FBWjtBQUNBLE1BQUl1RCxNQUFNMFYsT0FBTyxDQUFQLEdBQVdGLFVBQVUsQ0FBVixDQUFYLEdBQTBCMVosU0FBcEM7QUFDQSxNQUFJNlosU0FBUzNWLFFBQVFsRSxTQUFSLEdBQW9CVyxNQUFwQixHQUE2QnlZLGdCQUFnQmxWLEdBQWhCLEVBQXFCdkQsTUFBckIsQ0FBMUM7O0FBQ0EsU0FBT2taLFNBQVNoYixLQUFoQjtBQUF1QjBhLE1BQUUxYSxPQUFGLElBQWF2QixLQUFiO0FBQXZCOztBQUNBLFNBQU9pYyxDQUFQO0FBQ0QsQ0FURCxDOzs7Ozs7O0FDTEEsSUFBSU8sUUFBUSxtQkFBQS9jLENBQVEsMkNBQVIsQ0FBWjs7QUFFQTBiLE9BQU9wYixPQUFQLEdBQWlCLFVBQVUwYyxJQUFWLEVBQWdCQyxRQUFoQixFQUEwQjtBQUN6QyxNQUFJM1csU0FBUyxFQUFiO0FBQ0F5VyxRQUFNQyxJQUFOLEVBQVksS0FBWixFQUFtQjFXLE9BQU83QyxJQUExQixFQUFnQzZDLE1BQWhDLEVBQXdDMlcsUUFBeEM7QUFDQSxTQUFPM1csTUFBUDtBQUNELENBSkQsQzs7Ozs7OztBQ0ZBO0FBQ0E7QUFDQSxJQUFJNFcsWUFBWSxtQkFBQWxkLENBQVEsK0NBQVIsQ0FBaEI7O0FBQ0EsSUFBSXNjLFdBQVcsbUJBQUF0YyxDQUFRLDhDQUFSLENBQWY7O0FBQ0EsSUFBSXFjLGtCQUFrQixtQkFBQXJjLENBQVEsc0RBQVIsQ0FBdEI7O0FBQ0EwYixPQUFPcGIsT0FBUCxHQUFpQixVQUFVNmMsV0FBVixFQUF1QjtBQUN0QyxTQUFPLFVBQVVDLEtBQVYsRUFBaUJDLEVBQWpCLEVBQXFCQyxTQUFyQixFQUFnQztBQUNyQyxRQUFJZCxJQUFJVSxVQUFVRSxLQUFWLENBQVI7QUFDQSxRQUFJeFosU0FBUzBZLFNBQVNFLEVBQUU1WSxNQUFYLENBQWI7QUFDQSxRQUFJOUIsUUFBUXVhLGdCQUFnQmlCLFNBQWhCLEVBQTJCMVosTUFBM0IsQ0FBWjtBQUNBLFFBQUlyRCxLQUFKLENBSnFDLENBS3JDO0FBQ0E7O0FBQ0EsUUFBSTRjLGVBQWVFLE1BQU1BLEVBQXpCLEVBQTZCLE9BQU96WixTQUFTOUIsS0FBaEIsRUFBdUI7QUFDbER2QixjQUFRaWMsRUFBRTFhLE9BQUYsQ0FBUixDQURrRCxDQUVsRDs7QUFDQSxVQUFJdkIsU0FBU0EsS0FBYixFQUFvQixPQUFPLElBQVAsQ0FIOEIsQ0FJcEQ7QUFDQyxLQUxELE1BS08sT0FBTXFELFNBQVM5QixLQUFmLEVBQXNCQSxPQUF0QjtBQUErQixVQUFJcWIsZUFBZXJiLFNBQVMwYSxDQUE1QixFQUErQjtBQUNuRSxZQUFJQSxFQUFFMWEsS0FBRixNQUFhdWIsRUFBakIsRUFBcUIsT0FBT0YsZUFBZXJiLEtBQWYsSUFBd0IsQ0FBL0I7QUFDdEI7QUFGTTtBQUVMLFdBQU8sQ0FBQ3FiLFdBQUQsSUFBZ0IsQ0FBQyxDQUF4QjtBQUNILEdBZkQ7QUFnQkQsQ0FqQkQsQzs7Ozs7OztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSUksTUFBTSxtQkFBQXZkLENBQVEsd0NBQVIsQ0FBVjs7QUFDQSxJQUFJd2QsVUFBVSxtQkFBQXhkLENBQVEsNENBQVIsQ0FBZDs7QUFDQSxJQUFJb2MsV0FBVyxtQkFBQXBjLENBQVEsOENBQVIsQ0FBZjs7QUFDQSxJQUFJc2MsV0FBVyxtQkFBQXRjLENBQVEsOENBQVIsQ0FBZjs7QUFDQSxJQUFJeWQsTUFBTSxtQkFBQXpkLENBQVEseURBQVIsQ0FBVjs7QUFDQTBiLE9BQU9wYixPQUFQLEdBQWlCLFVBQVVvZCxJQUFWLEVBQWdCQyxPQUFoQixFQUF5QjtBQUN4QyxNQUFJQyxTQUFTRixRQUFRLENBQXJCO0FBQ0EsTUFBSUcsWUFBWUgsUUFBUSxDQUF4QjtBQUNBLE1BQUlJLFVBQVVKLFFBQVEsQ0FBdEI7QUFDQSxNQUFJSyxXQUFXTCxRQUFRLENBQXZCO0FBQ0EsTUFBSU0sZ0JBQWdCTixRQUFRLENBQTVCO0FBQ0EsTUFBSU8sV0FBV1AsUUFBUSxDQUFSLElBQWFNLGFBQTVCO0FBQ0EsTUFBSXJILFNBQVNnSCxXQUFXRixHQUF4QjtBQUNBLFNBQU8sVUFBVUwsS0FBVixFQUFpQmMsVUFBakIsRUFBNkJDLElBQTdCLEVBQW1DO0FBQ3hDLFFBQUkzQixJQUFJSixTQUFTZ0IsS0FBVCxDQUFSO0FBQ0EsUUFBSWdCLE9BQU9aLFFBQVFoQixDQUFSLENBQVg7QUFDQSxRQUFJNkIsSUFBSWQsSUFBSVcsVUFBSixFQUFnQkMsSUFBaEIsRUFBc0IsQ0FBdEIsQ0FBUjtBQUNBLFFBQUl2YSxTQUFTMFksU0FBUzhCLEtBQUt4YSxNQUFkLENBQWI7QUFDQSxRQUFJOUIsUUFBUSxDQUFaO0FBQ0EsUUFBSXdFLFNBQVNzWCxTQUFTakgsT0FBT3lHLEtBQVAsRUFBY3haLE1BQWQsQ0FBVCxHQUFpQ2lhLFlBQVlsSCxPQUFPeUcsS0FBUCxFQUFjLENBQWQsQ0FBWixHQUErQm5hLFNBQTdFO0FBQ0EsUUFBSXFiLEdBQUosRUFBU0MsR0FBVDs7QUFDQSxXQUFNM2EsU0FBUzlCLEtBQWYsRUFBc0JBLE9BQXRCO0FBQStCLFVBQUltYyxZQUFZbmMsU0FBU3NjLElBQXpCLEVBQStCO0FBQzVERSxjQUFNRixLQUFLdGMsS0FBTCxDQUFOO0FBQ0F5YyxjQUFNRixFQUFFQyxHQUFGLEVBQU94YyxLQUFQLEVBQWMwYSxDQUFkLENBQU47O0FBQ0EsWUFBSWtCLElBQUosRUFBVTtBQUNSLGNBQUlFLE1BQUosRUFBWXRYLE9BQU94RSxLQUFQLElBQWdCeWMsR0FBaEIsQ0FBWixDQUFtQztBQUFuQyxlQUNLLElBQUlBLEdBQUosRUFBUyxRQUFRYixJQUFSO0FBQ1osbUJBQUssQ0FBTDtBQUFRLHVCQUFPLElBQVA7QUFBeUI7O0FBQ2pDLG1CQUFLLENBQUw7QUFBUSx1QkFBT1ksR0FBUDtBQUF5Qjs7QUFDakMsbUJBQUssQ0FBTDtBQUFRLHVCQUFPeGMsS0FBUDtBQUF5Qjs7QUFDakMsbUJBQUssQ0FBTDtBQUFRd0UsdUJBQU83QyxJQUFQLENBQVk2YSxHQUFaO0FBQXlCO0FBSnJCLGFBQVQsTUFLRSxJQUFJUCxRQUFKLEVBQWMsT0FBTyxLQUFQLENBUGIsQ0FPMkI7QUFDcEM7QUFDRjtBQVpEOztBQWFBLFdBQU9DLGdCQUFnQixDQUFDLENBQWpCLEdBQXFCRixXQUFXQyxRQUFYLEdBQXNCQSxRQUF0QixHQUFpQ3pYLE1BQTdEO0FBQ0QsR0F0QkQ7QUF1QkQsQ0EvQkQsQzs7Ozs7OztBQ1pBLElBQUlrWSxZQUFZLG1CQUFBeGUsQ0FBUSwrQ0FBUixDQUFoQjs7QUFDQSxJQUFJb2MsV0FBVyxtQkFBQXBjLENBQVEsOENBQVIsQ0FBZjs7QUFDQSxJQUFJd2QsVUFBVSxtQkFBQXhkLENBQVEsNENBQVIsQ0FBZDs7QUFDQSxJQUFJc2MsV0FBVyxtQkFBQXRjLENBQVEsOENBQVIsQ0FBZjs7QUFFQTBiLE9BQU9wYixPQUFQLEdBQWlCLFVBQVU2ZCxJQUFWLEVBQWdCRCxVQUFoQixFQUE0QnJCLElBQTVCLEVBQWtDNEIsSUFBbEMsRUFBd0NDLE9BQXhDLEVBQWlEO0FBQ2hFRixZQUFVTixVQUFWO0FBQ0EsTUFBSTFCLElBQUlKLFNBQVMrQixJQUFULENBQVI7QUFDQSxNQUFJQyxPQUFPWixRQUFRaEIsQ0FBUixDQUFYO0FBQ0EsTUFBSTVZLFNBQVMwWSxTQUFTRSxFQUFFNVksTUFBWCxDQUFiO0FBQ0EsTUFBSTlCLFFBQVE0YyxVQUFVOWEsU0FBUyxDQUFuQixHQUF1QixDQUFuQztBQUNBLE1BQUl4QyxJQUFJc2QsVUFBVSxDQUFDLENBQVgsR0FBZSxDQUF2QjtBQUNBLE1BQUk3QixPQUFPLENBQVgsRUFBYyxTQUFTO0FBQ3JCLFFBQUkvYSxTQUFTc2MsSUFBYixFQUFtQjtBQUNqQkssYUFBT0wsS0FBS3RjLEtBQUwsQ0FBUDtBQUNBQSxlQUFTVixDQUFUO0FBQ0E7QUFDRDs7QUFDRFUsYUFBU1YsQ0FBVDs7QUFDQSxRQUFJc2QsVUFBVTVjLFFBQVEsQ0FBbEIsR0FBc0I4QixVQUFVOUIsS0FBcEMsRUFBMkM7QUFDekMsWUFBTTZaLFVBQVUsNkNBQVYsQ0FBTjtBQUNEO0FBQ0Y7O0FBQ0QsU0FBTStDLFVBQVU1YyxTQUFTLENBQW5CLEdBQXVCOEIsU0FBUzlCLEtBQXRDLEVBQTZDQSxTQUFTVixDQUF0RDtBQUF5RCxRQUFJVSxTQUFTc2MsSUFBYixFQUFtQjtBQUMxRUssYUFBT1AsV0FBV08sSUFBWCxFQUFpQkwsS0FBS3RjLEtBQUwsQ0FBakIsRUFBOEJBLEtBQTlCLEVBQXFDMGEsQ0FBckMsQ0FBUDtBQUNEO0FBRkQ7O0FBR0EsU0FBT2lDLElBQVA7QUFDRCxDQXRCRCxDOzs7Ozs7O0FDTEEsSUFBSXRDLFdBQVcsbUJBQUFuYyxDQUFRLDhDQUFSLENBQWY7O0FBQ0EsSUFBSThQLFVBQVUsbUJBQUE5UCxDQUFRLDZDQUFSLENBQWQ7O0FBQ0EsSUFBSTJlLFVBQVUsbUJBQUEzZSxDQUFRLHdDQUFSLEVBQWtCLFNBQWxCLENBQWQ7O0FBRUEwYixPQUFPcGIsT0FBUCxHQUFpQixVQUFVc2UsUUFBVixFQUFvQjtBQUNuQyxNQUFJQyxDQUFKOztBQUNBLE1BQUkvTyxRQUFROE8sUUFBUixDQUFKLEVBQXVCO0FBQ3JCQyxRQUFJRCxTQUFTRSxXQUFiLENBRHFCLENBRXJCOztBQUNBLFFBQUksT0FBT0QsQ0FBUCxJQUFZLFVBQVosS0FBMkJBLE1BQU1sYyxLQUFOLElBQWVtTixRQUFRK08sRUFBRTdDLFNBQVYsQ0FBMUMsQ0FBSixFQUFxRTZDLElBQUk1YixTQUFKOztBQUNyRSxRQUFJa1osU0FBUzBDLENBQVQsQ0FBSixFQUFpQjtBQUNmQSxVQUFJQSxFQUFFRixPQUFGLENBQUo7QUFDQSxVQUFJRSxNQUFNLElBQVYsRUFBZ0JBLElBQUk1YixTQUFKO0FBQ2pCO0FBQ0Y7O0FBQUMsU0FBTzRiLE1BQU01YixTQUFOLEdBQWtCTixLQUFsQixHQUEwQmtjLENBQWpDO0FBQ0gsQ0FYRCxDOzs7Ozs7O0FDSkE7QUFDQSxJQUFJRSxxQkFBcUIsbUJBQUEvZSxDQUFRLDhEQUFSLENBQXpCOztBQUVBMGIsT0FBT3BiLE9BQVAsR0FBaUIsVUFBVXNlLFFBQVYsRUFBb0JoYixNQUFwQixFQUE0QjtBQUMzQyxTQUFPLEtBQUttYixtQkFBbUJILFFBQW5CLENBQUwsRUFBbUNoYixNQUFuQyxDQUFQO0FBQ0QsQ0FGRCxDOzs7Ozs7OztBQ0hBOztBQUNBLElBQUk0YSxZQUFZLG1CQUFBeGUsQ0FBUSwrQ0FBUixDQUFoQjs7QUFDQSxJQUFJbWMsV0FBVyxtQkFBQW5jLENBQVEsOENBQVIsQ0FBZjs7QUFDQSxJQUFJZ2YsU0FBUyxtQkFBQWhmLENBQVEsMkNBQVIsQ0FBYjs7QUFDQSxJQUFJaWYsYUFBYSxHQUFHQyxLQUFwQjtBQUNBLElBQUlDLFlBQVksRUFBaEI7O0FBRUEsSUFBSUMsWUFBWSxTQUFaQSxTQUFZLENBQVVDLENBQVYsRUFBYTVDLEdBQWIsRUFBa0I2QyxJQUFsQixFQUF3QjtBQUN0QyxNQUFJLEVBQUU3QyxPQUFPMEMsU0FBVCxDQUFKLEVBQXlCO0FBQ3ZCLFNBQUssSUFBSXpULElBQUksRUFBUixFQUFZdEssSUFBSSxDQUFyQixFQUF3QkEsSUFBSXFiLEdBQTVCLEVBQWlDcmIsR0FBakM7QUFBc0NzSyxRQUFFdEssQ0FBRixJQUFPLE9BQU9BLENBQVAsR0FBVyxHQUFsQjtBQUF0QyxLQUR1QixDQUV2Qjs7O0FBQ0ErZCxjQUFVMUMsR0FBVixJQUFpQjhDLFNBQVMsS0FBVCxFQUFnQixrQkFBa0I3VCxFQUFFOFQsSUFBRixDQUFPLEdBQVAsQ0FBbEIsR0FBZ0MsR0FBaEQsQ0FBakI7QUFDRDs7QUFBQyxTQUFPTCxVQUFVMUMsR0FBVixFQUFlNEMsQ0FBZixFQUFrQkMsSUFBbEIsQ0FBUDtBQUNILENBTkQ7O0FBUUE1RCxPQUFPcGIsT0FBUCxHQUFpQmlmLFNBQVNFLElBQVQsSUFBaUIsU0FBU0EsSUFBVCxDQUFjdEI7QUFBSztBQUFuQixFQUFvQztBQUNwRSxNQUFJdUIsS0FBS2xCLFVBQVUsSUFBVixDQUFUO0FBQ0EsTUFBSW1CLFdBQVdWLFdBQVdXLElBQVgsQ0FBZ0JqRCxTQUFoQixFQUEyQixDQUEzQixDQUFmOztBQUNBLE1BQUlrRCxRQUFRLFNBQVJBLEtBQVE7QUFBVTtBQUFlO0FBQ25DLFFBQUlQLE9BQU9LLFNBQVM1ZSxNQUFULENBQWdCa2UsV0FBV1csSUFBWCxDQUFnQmpELFNBQWhCLENBQWhCLENBQVg7QUFDQSxXQUFPLGdCQUFnQmtELEtBQWhCLEdBQXdCVCxVQUFVTSxFQUFWLEVBQWNKLEtBQUsxYixNQUFuQixFQUEyQjBiLElBQTNCLENBQXhCLEdBQTJETixPQUFPVSxFQUFQLEVBQVdKLElBQVgsRUFBaUJuQixJQUFqQixDQUFsRTtBQUNELEdBSEQ7O0FBSUEsTUFBSWhDLFNBQVN1RCxHQUFHMUQsU0FBWixDQUFKLEVBQTRCNkQsTUFBTTdELFNBQU4sR0FBa0IwRCxHQUFHMUQsU0FBckI7QUFDNUIsU0FBTzZELEtBQVA7QUFDRCxDQVRELEM7Ozs7Ozs7QUNmQTtBQUNBLElBQUlqRSxNQUFNLG1CQUFBNWIsQ0FBUSx3Q0FBUixDQUFWOztBQUNBLElBQUk4ZixNQUFNLG1CQUFBOWYsQ0FBUSx3Q0FBUixFQUFrQixhQUFsQixDQUFWLEMsQ0FDQTs7O0FBQ0EsSUFBSStmLE1BQU1uRSxJQUFJLFlBQVk7QUFBRSxTQUFPZSxTQUFQO0FBQW1CLENBQWpDLEVBQUosS0FBNEMsV0FBdEQsQyxDQUVBOztBQUNBLElBQUlxRCxTQUFTLFNBQVRBLE1BQVMsQ0FBVW5lLEVBQVYsRUFBY0wsR0FBZCxFQUFtQjtBQUM5QixNQUFJO0FBQ0YsV0FBT0ssR0FBR0wsR0FBSCxDQUFQO0FBQ0QsR0FGRCxDQUVFLE9BQU95ZSxDQUFQLEVBQVU7QUFBRTtBQUFhO0FBQzVCLENBSkQ7O0FBTUF2RSxPQUFPcGIsT0FBUCxHQUFpQixVQUFVdUIsRUFBVixFQUFjO0FBQzdCLE1BQUkyYSxDQUFKLEVBQU8wRCxDQUFQLEVBQVVDLENBQVY7QUFDQSxTQUFPdGUsT0FBT29CLFNBQVAsR0FBbUIsV0FBbkIsR0FBaUNwQixPQUFPLElBQVAsR0FBYyxNQUFkLENBQ3RDO0FBRHNDLElBRXBDLFFBQVFxZSxJQUFJRixPQUFPeEQsSUFBSXBjLE9BQU95QixFQUFQLENBQVgsRUFBdUJpZSxHQUF2QixDQUFaLEtBQTRDLFFBQTVDLEdBQXVESSxDQUF2RCxDQUNGO0FBREUsSUFFQUgsTUFBTW5FLElBQUlZLENBQUosQ0FBTixDQUNGO0FBREUsSUFFQSxDQUFDMkQsSUFBSXZFLElBQUlZLENBQUosQ0FBTCxLQUFnQixRQUFoQixJQUE0QixPQUFPQSxFQUFFNEQsTUFBVCxJQUFtQixVQUEvQyxHQUE0RCxXQUE1RCxHQUEwRUQsQ0FOOUU7QUFPRCxDQVRELEM7Ozs7Ozs7QUNiQSxJQUFJRSxXQUFXLEdBQUdBLFFBQWxCOztBQUVBM0UsT0FBT3BiLE9BQVAsR0FBaUIsVUFBVXVCLEVBQVYsRUFBYztBQUM3QixTQUFPd2UsU0FBU1QsSUFBVCxDQUFjL2QsRUFBZCxFQUFrQnFkLEtBQWxCLENBQXdCLENBQXhCLEVBQTJCLENBQUMsQ0FBNUIsQ0FBUDtBQUNELENBRkQsQzs7Ozs7Ozs7QUNGQTs7QUFDQSxJQUFJb0IsS0FBSyxtQkFBQXRnQixDQUFRLDhDQUFSLEVBQXdCcWUsQ0FBakM7O0FBQ0EsSUFBSTFILFNBQVMsbUJBQUEzVyxDQUFRLGtEQUFSLENBQWI7O0FBQ0EsSUFBSXVnQixjQUFjLG1CQUFBdmdCLENBQVEsaURBQVIsQ0FBbEI7O0FBQ0EsSUFBSXVkLE1BQU0sbUJBQUF2ZCxDQUFRLHdDQUFSLENBQVY7O0FBQ0EsSUFBSXdnQixhQUFhLG1CQUFBeGdCLENBQVEsZ0RBQVIsQ0FBakI7O0FBQ0EsSUFBSStjLFFBQVEsbUJBQUEvYyxDQUFRLDJDQUFSLENBQVo7O0FBQ0EsSUFBSXlnQixjQUFjLG1CQUFBemdCLENBQVEsZ0RBQVIsQ0FBbEI7O0FBQ0EsSUFBSTBnQixPQUFPLG1CQUFBMWdCLENBQVEsOENBQVIsQ0FBWDs7QUFDQSxJQUFJMmdCLGFBQWEsbUJBQUEzZ0IsQ0FBUSxnREFBUixDQUFqQjs7QUFDQSxJQUFJNGdCLGNBQWMsbUJBQUE1Z0IsQ0FBUSxnREFBUixDQUFsQjs7QUFDQSxJQUFJNmdCLFVBQVUsbUJBQUE3Z0IsQ0FBUSx5Q0FBUixFQUFtQjZnQixPQUFqQzs7QUFDQSxJQUFJQyxXQUFXLG1CQUFBOWdCLENBQVEsd0RBQVIsQ0FBZjs7QUFDQSxJQUFJK2dCLE9BQU9ILGNBQWMsSUFBZCxHQUFxQixNQUFoQzs7QUFFQSxJQUFJSSxXQUFXLFNBQVhBLFFBQVcsQ0FBVTdDLElBQVYsRUFBZ0IzYyxHQUFoQixFQUFxQjtBQUNsQztBQUNBLE1BQUlNLFFBQVErZSxRQUFRcmYsR0FBUixDQUFaO0FBQ0EsTUFBSXlmLEtBQUo7QUFDQSxNQUFJbmYsVUFBVSxHQUFkLEVBQW1CLE9BQU9xYyxLQUFLK0MsRUFBTCxDQUFRcGYsS0FBUixDQUFQLENBSmUsQ0FLbEM7O0FBQ0EsT0FBS21mLFFBQVE5QyxLQUFLZ0QsRUFBbEIsRUFBc0JGLEtBQXRCLEVBQTZCQSxRQUFRQSxNQUFNdlYsQ0FBM0MsRUFBOEM7QUFDNUMsUUFBSXVWLE1BQU1HLENBQU4sSUFBVzVmLEdBQWYsRUFBb0IsT0FBT3lmLEtBQVA7QUFDckI7QUFDRixDQVREOztBQVdBdkYsT0FBT3BiLE9BQVAsR0FBaUI7QUFDZitnQixrQkFBZ0Isd0JBQVVDLE9BQVYsRUFBbUJDLElBQW5CLEVBQXlCM0QsTUFBekIsRUFBaUM0RCxLQUFqQyxFQUF3QztBQUN0RCxRQUFJM0MsSUFBSXlDLFFBQVEsVUFBVW5ELElBQVYsRUFBZ0I3YyxRQUFoQixFQUEwQjtBQUN4Q2tmLGlCQUFXckMsSUFBWCxFQUFpQlUsQ0FBakIsRUFBb0IwQyxJQUFwQixFQUEwQixJQUExQjtBQUNBcEQsV0FBS3NELEVBQUwsR0FBVUYsSUFBVixDQUZ3QyxDQUVoQjs7QUFDeEJwRCxXQUFLK0MsRUFBTCxHQUFVdkssT0FBTyxJQUFQLENBQVYsQ0FId0MsQ0FHaEI7O0FBQ3hCd0gsV0FBS2dELEVBQUwsR0FBVWxlLFNBQVYsQ0FKd0MsQ0FJaEI7O0FBQ3hCa2IsV0FBS3VELEVBQUwsR0FBVXplLFNBQVYsQ0FMd0MsQ0FLaEI7O0FBQ3hCa2IsV0FBSzRDLElBQUwsSUFBYSxDQUFiLENBTndDLENBTWhCOztBQUN4QixVQUFJemYsWUFBWTJCLFNBQWhCLEVBQTJCOFosTUFBTXpiLFFBQU4sRUFBZ0JzYyxNQUFoQixFQUF3Qk8sS0FBS3FELEtBQUwsQ0FBeEIsRUFBcUNyRCxJQUFyQztBQUM1QixLQVJPLENBQVI7QUFTQW9DLGdCQUFZMUIsRUFBRTdDLFNBQWQsRUFBeUI7QUFDdkI7QUFDQTtBQUNBdkIsYUFBTyxTQUFTQSxLQUFULEdBQWlCO0FBQ3RCLGFBQUssSUFBSTBELE9BQU8yQyxTQUFTLElBQVQsRUFBZVMsSUFBZixDQUFYLEVBQWlDSSxPQUFPeEQsS0FBSytDLEVBQTdDLEVBQWlERCxRQUFROUMsS0FBS2dELEVBQW5FLEVBQXVFRixLQUF2RSxFQUE4RUEsUUFBUUEsTUFBTXZWLENBQTVGLEVBQStGO0FBQzdGdVYsZ0JBQU1yVixDQUFOLEdBQVUsSUFBVjtBQUNBLGNBQUlxVixNQUFNVyxDQUFWLEVBQWFYLE1BQU1XLENBQU4sR0FBVVgsTUFBTVcsQ0FBTixDQUFRbFcsQ0FBUixHQUFZekksU0FBdEI7QUFDYixpQkFBTzBlLEtBQUtWLE1BQU03ZixDQUFYLENBQVA7QUFDRDs7QUFDRCtjLGFBQUtnRCxFQUFMLEdBQVVoRCxLQUFLdUQsRUFBTCxHQUFVemUsU0FBcEI7QUFDQWtiLGFBQUs0QyxJQUFMLElBQWEsQ0FBYjtBQUNELE9BWHNCO0FBWXZCO0FBQ0E7QUFDQSxnQkFBVSxpQkFBVXZmLEdBQVYsRUFBZTtBQUN2QixZQUFJMmMsT0FBTzJDLFNBQVMsSUFBVCxFQUFlUyxJQUFmLENBQVg7QUFDQSxZQUFJTixRQUFRRCxTQUFTN0MsSUFBVCxFQUFlM2MsR0FBZixDQUFaOztBQUNBLFlBQUl5ZixLQUFKLEVBQVc7QUFDVCxjQUFJdmQsT0FBT3VkLE1BQU12VixDQUFqQjtBQUNBLGNBQUlrRixPQUFPcVEsTUFBTVcsQ0FBakI7QUFDQSxpQkFBT3pELEtBQUsrQyxFQUFMLENBQVFELE1BQU03ZixDQUFkLENBQVA7QUFDQTZmLGdCQUFNclYsQ0FBTixHQUFVLElBQVY7QUFDQSxjQUFJZ0YsSUFBSixFQUFVQSxLQUFLbEYsQ0FBTCxHQUFTaEksSUFBVDtBQUNWLGNBQUlBLElBQUosRUFBVUEsS0FBS2tlLENBQUwsR0FBU2hSLElBQVQ7QUFDVixjQUFJdU4sS0FBS2dELEVBQUwsSUFBV0YsS0FBZixFQUFzQjlDLEtBQUtnRCxFQUFMLEdBQVV6ZCxJQUFWO0FBQ3RCLGNBQUl5YSxLQUFLdUQsRUFBTCxJQUFXVCxLQUFmLEVBQXNCOUMsS0FBS3VELEVBQUwsR0FBVTlRLElBQVY7QUFDdEJ1TixlQUFLNEMsSUFBTDtBQUNEOztBQUFDLGVBQU8sQ0FBQyxDQUFDRSxLQUFUO0FBQ0gsT0E1QnNCO0FBNkJ2QjtBQUNBO0FBQ0ExSSxlQUFTLFNBQVNBLE9BQVQsQ0FBaUIyRjtBQUFXO0FBQTVCLFFBQXNEO0FBQzdENEMsaUJBQVMsSUFBVCxFQUFlUyxJQUFmO0FBQ0EsWUFBSWxELElBQUlkLElBQUlXLFVBQUosRUFBZ0J2QixVQUFVL1ksTUFBVixHQUFtQixDQUFuQixHQUF1QitZLFVBQVUsQ0FBVixDQUF2QixHQUFzQzFaLFNBQXRELEVBQWlFLENBQWpFLENBQVI7QUFDQSxZQUFJZ2UsS0FBSjs7QUFDQSxlQUFPQSxRQUFRQSxRQUFRQSxNQUFNdlYsQ0FBZCxHQUFrQixLQUFLeVYsRUFBdEMsRUFBMEM7QUFDeEM5QyxZQUFFNEMsTUFBTXJULENBQVIsRUFBV3FULE1BQU1HLENBQWpCLEVBQW9CLElBQXBCLEVBRHdDLENBRXhDOztBQUNBLGlCQUFPSCxTQUFTQSxNQUFNclYsQ0FBdEI7QUFBeUJxVixvQkFBUUEsTUFBTVcsQ0FBZDtBQUF6QjtBQUNEO0FBQ0YsT0F4Q3NCO0FBeUN2QjtBQUNBO0FBQ0EzZCxXQUFLLFNBQVNBLEdBQVQsQ0FBYXpDLEdBQWIsRUFBa0I7QUFDckIsZUFBTyxDQUFDLENBQUN3ZixTQUFTRixTQUFTLElBQVQsRUFBZVMsSUFBZixDQUFULEVBQStCL2YsR0FBL0IsQ0FBVDtBQUNEO0FBN0NzQixLQUF6QjtBQStDQSxRQUFJb2YsV0FBSixFQUFpQk4sR0FBR3pCLEVBQUU3QyxTQUFMLEVBQWdCLE1BQWhCLEVBQXdCO0FBQ3ZDNkYsV0FBSyxlQUFZO0FBQ2YsZUFBT2YsU0FBUyxJQUFULEVBQWVTLElBQWYsRUFBcUJSLElBQXJCLENBQVA7QUFDRDtBQUhzQyxLQUF4QjtBQUtqQixXQUFPbEMsQ0FBUDtBQUNELEdBaEVjO0FBaUVmaUQsT0FBSyxhQUFVM0QsSUFBVixFQUFnQjNjLEdBQWhCLEVBQXFCakIsS0FBckIsRUFBNEI7QUFDL0IsUUFBSTBnQixRQUFRRCxTQUFTN0MsSUFBVCxFQUFlM2MsR0FBZixDQUFaO0FBQ0EsUUFBSW9QLElBQUosRUFBVTlPLEtBQVYsQ0FGK0IsQ0FHL0I7O0FBQ0EsUUFBSW1mLEtBQUosRUFBVztBQUNUQSxZQUFNclQsQ0FBTixHQUFVck4sS0FBVixDQURTLENBRVg7QUFDQyxLQUhELE1BR087QUFDTDRkLFdBQUt1RCxFQUFMLEdBQVVULFFBQVE7QUFDaEI3ZixXQUFHVSxRQUFRK2UsUUFBUXJmLEdBQVIsRUFBYSxJQUFiLENBREs7QUFDZTtBQUMvQjRmLFdBQUc1ZixHQUZhO0FBRWU7QUFDL0JvTSxXQUFHck4sS0FIYTtBQUdlO0FBQy9CcWhCLFdBQUdoUixPQUFPdU4sS0FBS3VELEVBSkM7QUFJZTtBQUMvQmhXLFdBQUd6SSxTQUxhO0FBS2U7QUFDL0IySSxXQUFHLEtBTmEsQ0FNZTs7QUFOZixPQUFsQjtBQVFBLFVBQUksQ0FBQ3VTLEtBQUtnRCxFQUFWLEVBQWNoRCxLQUFLZ0QsRUFBTCxHQUFVRixLQUFWO0FBQ2QsVUFBSXJRLElBQUosRUFBVUEsS0FBS2xGLENBQUwsR0FBU3VWLEtBQVQ7QUFDVjlDLFdBQUs0QyxJQUFMLElBWEssQ0FZTDs7QUFDQSxVQUFJamYsVUFBVSxHQUFkLEVBQW1CcWMsS0FBSytDLEVBQUwsQ0FBUXBmLEtBQVIsSUFBaUJtZixLQUFqQjtBQUNwQjs7QUFBQyxXQUFPOUMsSUFBUDtBQUNILEdBdkZjO0FBd0ZmNkMsWUFBVUEsUUF4Rks7QUF5RmZlLGFBQVcsbUJBQVVsRCxDQUFWLEVBQWEwQyxJQUFiLEVBQW1CM0QsTUFBbkIsRUFBMkI7QUFDcEM7QUFDQTtBQUNBNkMsZ0JBQVk1QixDQUFaLEVBQWUwQyxJQUFmLEVBQXFCLFVBQVVTLFFBQVYsRUFBb0JDLElBQXBCLEVBQTBCO0FBQzdDLFdBQUtSLEVBQUwsR0FBVVgsU0FBU2tCLFFBQVQsRUFBbUJULElBQW5CLENBQVYsQ0FENkMsQ0FDVDs7QUFDcEMsV0FBS1csRUFBTCxHQUFVRCxJQUFWLENBRjZDLENBRVQ7O0FBQ3BDLFdBQUtQLEVBQUwsR0FBVXplLFNBQVYsQ0FINkMsQ0FHVDtBQUNyQyxLQUpELEVBSUcsWUFBWTtBQUNiLFVBQUlrYixPQUFPLElBQVg7QUFDQSxVQUFJOEQsT0FBTzlELEtBQUsrRCxFQUFoQjtBQUNBLFVBQUlqQixRQUFROUMsS0FBS3VELEVBQWpCLENBSGEsQ0FJYjs7QUFDQSxhQUFPVCxTQUFTQSxNQUFNclYsQ0FBdEI7QUFBeUJxVixnQkFBUUEsTUFBTVcsQ0FBZDtBQUF6QixPQUxhLENBTWI7OztBQUNBLFVBQUksQ0FBQ3pELEtBQUtzRCxFQUFOLElBQVksRUFBRXRELEtBQUt1RCxFQUFMLEdBQVVULFFBQVFBLFFBQVFBLE1BQU12VixDQUFkLEdBQWtCeVMsS0FBS3NELEVBQUwsQ0FBUU4sRUFBOUMsQ0FBaEIsRUFBbUU7QUFDakU7QUFDQWhELGFBQUtzRCxFQUFMLEdBQVV4ZSxTQUFWO0FBQ0EsZUFBT3lkLEtBQUssQ0FBTCxDQUFQO0FBQ0QsT0FYWSxDQVliOzs7QUFDQSxVQUFJdUIsUUFBUSxNQUFaLEVBQW9CLE9BQU92QixLQUFLLENBQUwsRUFBUU8sTUFBTUcsQ0FBZCxDQUFQO0FBQ3BCLFVBQUlhLFFBQVEsUUFBWixFQUFzQixPQUFPdkIsS0FBSyxDQUFMLEVBQVFPLE1BQU1yVCxDQUFkLENBQVA7QUFDdEIsYUFBTzhTLEtBQUssQ0FBTCxFQUFRLENBQUNPLE1BQU1HLENBQVAsRUFBVUgsTUFBTXJULENBQWhCLENBQVIsQ0FBUDtBQUNELEtBcEJELEVBb0JHZ1EsU0FBUyxTQUFULEdBQXFCLFFBcEJ4QixFQW9Ca0MsQ0FBQ0EsTUFwQm5DLEVBb0IyQyxJQXBCM0MsRUFIb0MsQ0F5QnBDOztBQUNBK0MsZUFBV1ksSUFBWDtBQUNEO0FBcEhjLENBQWpCLEM7Ozs7Ozs7QUMxQkE7QUFDQSxJQUFJWSxVQUFVLG1CQUFBbmlCLENBQVEsNENBQVIsQ0FBZDs7QUFDQSxJQUFJNEMsT0FBTyxtQkFBQTVDLENBQVEsd0RBQVIsQ0FBWDs7QUFDQTBiLE9BQU9wYixPQUFQLEdBQWlCLFVBQVVpaEIsSUFBVixFQUFnQjtBQUMvQixTQUFPLFNBQVMxSyxNQUFULEdBQWtCO0FBQ3ZCLFFBQUlzTCxRQUFRLElBQVIsS0FBaUJaLElBQXJCLEVBQTJCLE1BQU01RixVQUFVNEYsT0FBTyx1QkFBakIsQ0FBTjtBQUMzQixXQUFPM2UsS0FBSyxJQUFMLENBQVA7QUFDRCxHQUhEO0FBSUQsQ0FMRCxDOzs7Ozs7OztBQ0hBOztBQUNBLElBQUkyZCxjQUFjLG1CQUFBdmdCLENBQVEsaURBQVIsQ0FBbEI7O0FBQ0EsSUFBSW9pQixVQUFVLG1CQUFBcGlCLENBQVEseUNBQVIsRUFBbUJvaUIsT0FBakM7O0FBQ0EsSUFBSUMsV0FBVyxtQkFBQXJpQixDQUFRLDhDQUFSLENBQWY7O0FBQ0EsSUFBSW1jLFdBQVcsbUJBQUFuYyxDQUFRLDhDQUFSLENBQWY7O0FBQ0EsSUFBSXdnQixhQUFhLG1CQUFBeGdCLENBQVEsZ0RBQVIsQ0FBakI7O0FBQ0EsSUFBSStjLFFBQVEsbUJBQUEvYyxDQUFRLDJDQUFSLENBQVo7O0FBQ0EsSUFBSXNpQixvQkFBb0IsbUJBQUF0aUIsQ0FBUSxrREFBUixDQUF4Qjs7QUFDQSxJQUFJdWlCLE9BQU8sbUJBQUF2aUIsQ0FBUSx3Q0FBUixDQUFYOztBQUNBLElBQUk4Z0IsV0FBVyxtQkFBQTlnQixDQUFRLHdEQUFSLENBQWY7O0FBQ0EsSUFBSXdpQixZQUFZRixrQkFBa0IsQ0FBbEIsQ0FBaEI7QUFDQSxJQUFJRyxpQkFBaUJILGtCQUFrQixDQUFsQixDQUFyQjtBQUNBLElBQUkxZCxLQUFLLENBQVQsQyxDQUVBOztBQUNBLElBQUk4ZCxzQkFBc0IsU0FBdEJBLG1CQUFzQixDQUFVdkUsSUFBVixFQUFnQjtBQUN4QyxTQUFPQSxLQUFLdUQsRUFBTCxLQUFZdkQsS0FBS3VELEVBQUwsR0FBVSxJQUFJaUIsbUJBQUosRUFBdEIsQ0FBUDtBQUNELENBRkQ7O0FBR0EsSUFBSUEsc0JBQXNCLFNBQXRCQSxtQkFBc0IsR0FBWTtBQUNwQyxPQUFLNVgsQ0FBTCxHQUFTLEVBQVQ7QUFDRCxDQUZEOztBQUdBLElBQUk2WCxxQkFBcUIsU0FBckJBLGtCQUFxQixDQUFVQyxLQUFWLEVBQWlCcmhCLEdBQWpCLEVBQXNCO0FBQzdDLFNBQU9naEIsVUFBVUssTUFBTTlYLENBQWhCLEVBQW1CLFVBQVVsSixFQUFWLEVBQWM7QUFDdEMsV0FBT0EsR0FBRyxDQUFILE1BQVVMLEdBQWpCO0FBQ0QsR0FGTSxDQUFQO0FBR0QsQ0FKRDs7QUFLQW1oQixvQkFBb0IzRyxTQUFwQixHQUFnQztBQUM5QjZGLE9BQUssYUFBVXJnQixHQUFWLEVBQWU7QUFDbEIsUUFBSXlmLFFBQVEyQixtQkFBbUIsSUFBbkIsRUFBeUJwaEIsR0FBekIsQ0FBWjtBQUNBLFFBQUl5ZixLQUFKLEVBQVcsT0FBT0EsTUFBTSxDQUFOLENBQVA7QUFDWixHQUo2QjtBQUs5QmhkLE9BQUssYUFBVXpDLEdBQVYsRUFBZTtBQUNsQixXQUFPLENBQUMsQ0FBQ29oQixtQkFBbUIsSUFBbkIsRUFBeUJwaEIsR0FBekIsQ0FBVDtBQUNELEdBUDZCO0FBUTlCc2hCLE9BQUssYUFBVXRoQixHQUFWLEVBQWVqQixLQUFmLEVBQXNCO0FBQ3pCLFFBQUkwZ0IsUUFBUTJCLG1CQUFtQixJQUFuQixFQUF5QnBoQixHQUF6QixDQUFaO0FBQ0EsUUFBSXlmLEtBQUosRUFBV0EsTUFBTSxDQUFOLElBQVcxZ0IsS0FBWCxDQUFYLEtBQ0ssS0FBS3dLLENBQUwsQ0FBT3RILElBQVAsQ0FBWSxDQUFDakMsR0FBRCxFQUFNakIsS0FBTixDQUFaO0FBQ04sR0FaNkI7QUFhOUIsWUFBVSxpQkFBVWlCLEdBQVYsRUFBZTtBQUN2QixRQUFJTSxRQUFRMmdCLGVBQWUsS0FBSzFYLENBQXBCLEVBQXVCLFVBQVVsSixFQUFWLEVBQWM7QUFDL0MsYUFBT0EsR0FBRyxDQUFILE1BQVVMLEdBQWpCO0FBQ0QsS0FGVyxDQUFaO0FBR0EsUUFBSSxDQUFDTSxLQUFMLEVBQVksS0FBS2lKLENBQUwsQ0FBT2dZLE1BQVAsQ0FBY2poQixLQUFkLEVBQXFCLENBQXJCO0FBQ1osV0FBTyxDQUFDLENBQUMsQ0FBQ0EsS0FBVjtBQUNEO0FBbkI2QixDQUFoQztBQXNCQTRaLE9BQU9wYixPQUFQLEdBQWlCO0FBQ2YrZ0Isa0JBQWdCLHdCQUFVQyxPQUFWLEVBQW1CQyxJQUFuQixFQUF5QjNELE1BQXpCLEVBQWlDNEQsS0FBakMsRUFBd0M7QUFDdEQsUUFBSTNDLElBQUl5QyxRQUFRLFVBQVVuRCxJQUFWLEVBQWdCN2MsUUFBaEIsRUFBMEI7QUFDeENrZixpQkFBV3JDLElBQVgsRUFBaUJVLENBQWpCLEVBQW9CMEMsSUFBcEIsRUFBMEIsSUFBMUI7QUFDQXBELFdBQUtzRCxFQUFMLEdBQVVGLElBQVYsQ0FGd0MsQ0FFbkI7O0FBQ3JCcEQsV0FBSytDLEVBQUwsR0FBVXRjLElBQVYsQ0FId0MsQ0FHbkI7O0FBQ3JCdVosV0FBS3VELEVBQUwsR0FBVXplLFNBQVYsQ0FKd0MsQ0FJbkI7O0FBQ3JCLFVBQUkzQixZQUFZMkIsU0FBaEIsRUFBMkI4WixNQUFNemIsUUFBTixFQUFnQnNjLE1BQWhCLEVBQXdCTyxLQUFLcUQsS0FBTCxDQUF4QixFQUFxQ3JELElBQXJDO0FBQzVCLEtBTk8sQ0FBUjtBQU9Bb0MsZ0JBQVkxQixFQUFFN0MsU0FBZCxFQUF5QjtBQUN2QjtBQUNBO0FBQ0EsZ0JBQVUsaUJBQVV4YSxHQUFWLEVBQWU7QUFDdkIsWUFBSSxDQUFDMmEsU0FBUzNhLEdBQVQsQ0FBTCxFQUFvQixPQUFPLEtBQVA7QUFDcEIsWUFBSW1nQixPQUFPUyxRQUFRNWdCLEdBQVIsQ0FBWDtBQUNBLFlBQUltZ0IsU0FBUyxJQUFiLEVBQW1CLE9BQU9lLG9CQUFvQjVCLFNBQVMsSUFBVCxFQUFlUyxJQUFmLENBQXBCLEVBQTBDLFFBQTFDLEVBQW9EL2YsR0FBcEQsQ0FBUDtBQUNuQixlQUFPbWdCLFFBQVFZLEtBQUtaLElBQUwsRUFBVyxLQUFLVCxFQUFoQixDQUFSLElBQStCLE9BQU9TLEtBQUssS0FBS1QsRUFBVixDQUE3QztBQUNELE9BUnNCO0FBU3ZCO0FBQ0E7QUFDQWpkLFdBQUssU0FBU0EsR0FBVCxDQUFhekMsR0FBYixFQUFrQjtBQUNyQixZQUFJLENBQUMyYSxTQUFTM2EsR0FBVCxDQUFMLEVBQW9CLE9BQU8sS0FBUDtBQUNwQixZQUFJbWdCLE9BQU9TLFFBQVE1Z0IsR0FBUixDQUFYO0FBQ0EsWUFBSW1nQixTQUFTLElBQWIsRUFBbUIsT0FBT2Usb0JBQW9CNUIsU0FBUyxJQUFULEVBQWVTLElBQWYsQ0FBcEIsRUFBMEN0ZCxHQUExQyxDQUE4Q3pDLEdBQTlDLENBQVA7QUFDbkIsZUFBT21nQixRQUFRWSxLQUFLWixJQUFMLEVBQVcsS0FBS1QsRUFBaEIsQ0FBZjtBQUNEO0FBaEJzQixLQUF6QjtBQWtCQSxXQUFPckMsQ0FBUDtBQUNELEdBNUJjO0FBNkJmaUQsT0FBSyxhQUFVM0QsSUFBVixFQUFnQjNjLEdBQWhCLEVBQXFCakIsS0FBckIsRUFBNEI7QUFDL0IsUUFBSW9oQixPQUFPUyxRQUFRQyxTQUFTN2dCLEdBQVQsQ0FBUixFQUF1QixJQUF2QixDQUFYO0FBQ0EsUUFBSW1nQixTQUFTLElBQWIsRUFBbUJlLG9CQUFvQnZFLElBQXBCLEVBQTBCMkUsR0FBMUIsQ0FBOEJ0aEIsR0FBOUIsRUFBbUNqQixLQUFuQyxFQUFuQixLQUNLb2hCLEtBQUt4RCxLQUFLK0MsRUFBVixJQUFnQjNnQixLQUFoQjtBQUNMLFdBQU80ZCxJQUFQO0FBQ0QsR0FsQ2M7QUFtQ2Y2RSxXQUFTTjtBQW5DTSxDQUFqQixDOzs7Ozs7OztBQ2hEQTs7QUFDQSxJQUFJemlCLFNBQVMsbUJBQUFELENBQVEsMkNBQVIsQ0FBYjs7QUFDQSxJQUFJaWpCLFVBQVUsbUJBQUFqakIsQ0FBUSwyQ0FBUixDQUFkOztBQUNBLElBQUlrakIsV0FBVyxtQkFBQWxqQixDQUFRLDZDQUFSLENBQWY7O0FBQ0EsSUFBSXVnQixjQUFjLG1CQUFBdmdCLENBQVEsaURBQVIsQ0FBbEI7O0FBQ0EsSUFBSW1qQixPQUFPLG1CQUFBbmpCLENBQVEseUNBQVIsQ0FBWDs7QUFDQSxJQUFJK2MsUUFBUSxtQkFBQS9jLENBQVEsMkNBQVIsQ0FBWjs7QUFDQSxJQUFJd2dCLGFBQWEsbUJBQUF4Z0IsQ0FBUSxnREFBUixDQUFqQjs7QUFDQSxJQUFJbWMsV0FBVyxtQkFBQW5jLENBQVEsOENBQVIsQ0FBZjs7QUFDQSxJQUFJb2pCLFFBQVEsbUJBQUFwakIsQ0FBUSwwQ0FBUixDQUFaOztBQUNBLElBQUlxakIsY0FBYyxtQkFBQXJqQixDQUFRLGdEQUFSLENBQWxCOztBQUNBLElBQUlzakIsaUJBQWlCLG1CQUFBdGpCLENBQVEsc0RBQVIsQ0FBckI7O0FBQ0EsSUFBSXVqQixvQkFBb0IsbUJBQUF2akIsQ0FBUSx3REFBUixDQUF4Qjs7QUFFQTBiLE9BQU9wYixPQUFQLEdBQWlCLFVBQVVpaEIsSUFBVixFQUFnQkQsT0FBaEIsRUFBeUJrQyxPQUF6QixFQUFrQ0MsTUFBbEMsRUFBMEM3RixNQUExQyxFQUFrRDhGLE9BQWxELEVBQTJEO0FBQzFFLE1BQUlDLE9BQU8xakIsT0FBT3NoQixJQUFQLENBQVg7QUFDQSxNQUFJMUMsSUFBSThFLElBQVI7QUFDQSxNQUFJbkMsUUFBUTVELFNBQVMsS0FBVCxHQUFpQixLQUE3QjtBQUNBLE1BQUlnRyxRQUFRL0UsS0FBS0EsRUFBRTdDLFNBQW5CO0FBQ0EsTUFBSVEsSUFBSSxFQUFSOztBQUNBLE1BQUlxSCxZQUFZLFNBQVpBLFNBQVksQ0FBVUMsR0FBVixFQUFlO0FBQzdCLFFBQUlwRSxLQUFLa0UsTUFBTUUsR0FBTixDQUFUO0FBQ0FaLGFBQVNVLEtBQVQsRUFBZ0JFLEdBQWhCLEVBQ0VBLE9BQU8sUUFBUCxHQUFrQixVQUFVL1ksQ0FBVixFQUFhO0FBQzdCLGFBQU8yWSxXQUFXLENBQUN2SCxTQUFTcFIsQ0FBVCxDQUFaLEdBQTBCLEtBQTFCLEdBQWtDMlUsR0FBR0UsSUFBSCxDQUFRLElBQVIsRUFBYzdVLE1BQU0sQ0FBTixHQUFVLENBQVYsR0FBY0EsQ0FBNUIsQ0FBekM7QUFDRCxLQUZELEdBRUkrWSxPQUFPLEtBQVAsR0FBZSxTQUFTN2YsR0FBVCxDQUFhOEcsQ0FBYixFQUFnQjtBQUNqQyxhQUFPMlksV0FBVyxDQUFDdkgsU0FBU3BSLENBQVQsQ0FBWixHQUEwQixLQUExQixHQUFrQzJVLEdBQUdFLElBQUgsQ0FBUSxJQUFSLEVBQWM3VSxNQUFNLENBQU4sR0FBVSxDQUFWLEdBQWNBLENBQTVCLENBQXpDO0FBQ0QsS0FGRyxHQUVBK1ksT0FBTyxLQUFQLEdBQWUsU0FBU2pDLEdBQVQsQ0FBYTlXLENBQWIsRUFBZ0I7QUFDakMsYUFBTzJZLFdBQVcsQ0FBQ3ZILFNBQVNwUixDQUFULENBQVosR0FBMEI5SCxTQUExQixHQUFzQ3ljLEdBQUdFLElBQUgsQ0FBUSxJQUFSLEVBQWM3VSxNQUFNLENBQU4sR0FBVSxDQUFWLEdBQWNBLENBQTVCLENBQTdDO0FBQ0QsS0FGRyxHQUVBK1ksT0FBTyxLQUFQLEdBQWUsU0FBUzVmLEdBQVQsQ0FBYTZHLENBQWIsRUFBZ0I7QUFBRTJVLFNBQUdFLElBQUgsQ0FBUSxJQUFSLEVBQWM3VSxNQUFNLENBQU4sR0FBVSxDQUFWLEdBQWNBLENBQTVCO0FBQWdDLGFBQU8sSUFBUDtBQUFjLEtBQS9FLEdBQ0EsU0FBUytYLEdBQVQsQ0FBYS9YLENBQWIsRUFBZ0JELENBQWhCLEVBQW1CO0FBQUU0VSxTQUFHRSxJQUFILENBQVEsSUFBUixFQUFjN1UsTUFBTSxDQUFOLEdBQVUsQ0FBVixHQUFjQSxDQUE1QixFQUErQkQsQ0FBL0I7QUFBbUMsYUFBTyxJQUFQO0FBQWMsS0FSNUU7QUFVRCxHQVpEOztBQWFBLE1BQUksT0FBTytULENBQVAsSUFBWSxVQUFaLElBQTBCLEVBQUU2RSxXQUFXRSxNQUFNckwsT0FBTixJQUFpQixDQUFDNkssTUFBTSxZQUFZO0FBQzdFLFFBQUl2RSxDQUFKLEdBQVFrRixPQUFSLEdBQWtCcmdCLElBQWxCO0FBQ0QsR0FGNEQsQ0FBL0IsQ0FBOUIsRUFFSztBQUNIO0FBQ0FtYixRQUFJNEUsT0FBT3BDLGNBQVAsQ0FBc0JDLE9BQXRCLEVBQStCQyxJQUEvQixFQUFxQzNELE1BQXJDLEVBQTZDNEQsS0FBN0MsQ0FBSjtBQUNBakIsZ0JBQVkxQixFQUFFN0MsU0FBZCxFQUF5QndILE9BQXpCO0FBQ0FMLFNBQUthLElBQUwsR0FBWSxJQUFaO0FBQ0QsR0FQRCxNQU9PO0FBQ0wsUUFBSUMsV0FBVyxJQUFJcEYsQ0FBSixFQUFmLENBREssQ0FFTDs7QUFDQSxRQUFJcUYsaUJBQWlCRCxTQUFTekMsS0FBVCxFQUFnQmtDLFVBQVUsRUFBVixHQUFlLENBQUMsQ0FBaEMsRUFBbUMsQ0FBbkMsS0FBeUNPLFFBQTlELENBSEssQ0FJTDs7QUFDQSxRQUFJRSx1QkFBdUJmLE1BQU0sWUFBWTtBQUFFYSxlQUFTaGdCLEdBQVQsQ0FBYSxDQUFiO0FBQWtCLEtBQXRDLENBQTNCLENBTEssQ0FNTDs7QUFDQSxRQUFJbWdCLG1CQUFtQmYsWUFBWSxVQUFVckcsSUFBVixFQUFnQjtBQUFFLFVBQUk2QixDQUFKLENBQU03QixJQUFOO0FBQWMsS0FBNUMsQ0FBdkIsQ0FQSyxDQU9pRTtBQUN0RTs7QUFDQSxRQUFJcUgsYUFBYSxDQUFDWCxPQUFELElBQVlOLE1BQU0sWUFBWTtBQUM3QztBQUNBLFVBQUlrQixZQUFZLElBQUl6RixDQUFKLEVBQWhCO0FBQ0EsVUFBSS9jLFFBQVEsQ0FBWjs7QUFDQSxhQUFPQSxPQUFQO0FBQWdCd2lCLGtCQUFVOUMsS0FBVixFQUFpQjFmLEtBQWpCLEVBQXdCQSxLQUF4QjtBQUFoQjs7QUFDQSxhQUFPLENBQUN3aUIsVUFBVXJnQixHQUFWLENBQWMsQ0FBQyxDQUFmLENBQVI7QUFDRCxLQU40QixDQUE3Qjs7QUFPQSxRQUFJLENBQUNtZ0IsZ0JBQUwsRUFBdUI7QUFDckJ2RixVQUFJeUMsUUFBUSxVQUFVaEosTUFBVixFQUFrQmhYLFFBQWxCLEVBQTRCO0FBQ3RDa2YsbUJBQVdsSSxNQUFYLEVBQW1CdUcsQ0FBbkIsRUFBc0IwQyxJQUF0QjtBQUNBLFlBQUlwRCxPQUFPb0Ysa0JBQWtCLElBQUlJLElBQUosRUFBbEIsRUFBOEJyTCxNQUE5QixFQUFzQ3VHLENBQXRDLENBQVg7QUFDQSxZQUFJdmQsWUFBWTJCLFNBQWhCLEVBQTJCOFosTUFBTXpiLFFBQU4sRUFBZ0JzYyxNQUFoQixFQUF3Qk8sS0FBS3FELEtBQUwsQ0FBeEIsRUFBcUNyRCxJQUFyQztBQUMzQixlQUFPQSxJQUFQO0FBQ0QsT0FMRyxDQUFKO0FBTUFVLFFBQUU3QyxTQUFGLEdBQWM0SCxLQUFkO0FBQ0FBLFlBQU05RSxXQUFOLEdBQW9CRCxDQUFwQjtBQUNEOztBQUNELFFBQUlzRix3QkFBd0JFLFVBQTVCLEVBQXdDO0FBQ3RDUixnQkFBVSxRQUFWO0FBQ0FBLGdCQUFVLEtBQVY7QUFDQWpHLGdCQUFVaUcsVUFBVSxLQUFWLENBQVY7QUFDRDs7QUFDRCxRQUFJUSxjQUFjSCxjQUFsQixFQUFrQ0wsVUFBVXJDLEtBQVYsRUEvQjdCLENBZ0NMOztBQUNBLFFBQUlrQyxXQUFXRSxNQUFNbkosS0FBckIsRUFBNEIsT0FBT21KLE1BQU1uSixLQUFiO0FBQzdCOztBQUVENkksaUJBQWV6RSxDQUFmLEVBQWtCMEMsSUFBbEI7QUFFQS9FLElBQUUrRSxJQUFGLElBQVUxQyxDQUFWO0FBQ0FvRSxVQUFRQSxRQUFRc0IsQ0FBUixHQUFZdEIsUUFBUXVCLENBQXBCLEdBQXdCdkIsUUFBUTVELENBQVIsSUFBYVIsS0FBSzhFLElBQWxCLENBQWhDLEVBQXlEbkgsQ0FBekQ7QUFFQSxNQUFJLENBQUNrSCxPQUFMLEVBQWNELE9BQU8xQixTQUFQLENBQWlCbEQsQ0FBakIsRUFBb0IwQyxJQUFwQixFQUEwQjNELE1BQTFCO0FBRWQsU0FBT2lCLENBQVA7QUFDRCxDQXRFRCxDOzs7Ozs7O0FDZEEsSUFBSTRGLE9BQU8vSSxPQUFPcGIsT0FBUCxHQUFpQjtBQUFFb2tCLFdBQVM7QUFBWCxDQUE1QjtBQUNBLElBQUksT0FBT0MsR0FBUCxJQUFjLFFBQWxCLEVBQTRCQSxNQUFNRixJQUFOLEMsQ0FBWSwrQjs7Ozs7Ozs7QUNEeEM7O0FBQ0EsSUFBSUcsa0JBQWtCLG1CQUFBNWtCLENBQVEsOENBQVIsQ0FBdEI7O0FBQ0EsSUFBSTZrQixhQUFhLG1CQUFBN2tCLENBQVEsa0RBQVIsQ0FBakI7O0FBRUEwYixPQUFPcGIsT0FBUCxHQUFpQixVQUFVd2tCLE1BQVYsRUFBa0JoakIsS0FBbEIsRUFBeUJ2QixLQUF6QixFQUFnQztBQUMvQyxNQUFJdUIsU0FBU2dqQixNQUFiLEVBQXFCRixnQkFBZ0J2RyxDQUFoQixDQUFrQnlHLE1BQWxCLEVBQTBCaGpCLEtBQTFCLEVBQWlDK2lCLFdBQVcsQ0FBWCxFQUFjdGtCLEtBQWQsQ0FBakMsRUFBckIsS0FDS3VrQixPQUFPaGpCLEtBQVAsSUFBZ0J2QixLQUFoQjtBQUNOLENBSEQsQzs7Ozs7OztBQ0pBO0FBQ0EsSUFBSWllLFlBQVksbUJBQUF4ZSxDQUFRLCtDQUFSLENBQWhCOztBQUNBMGIsT0FBT3BiLE9BQVAsR0FBaUIsVUFBVW9mLEVBQVYsRUFBY3ZCLElBQWQsRUFBb0J2YSxNQUFwQixFQUE0QjtBQUMzQzRhLFlBQVVrQixFQUFWO0FBQ0EsTUFBSXZCLFNBQVNsYixTQUFiLEVBQXdCLE9BQU95YyxFQUFQOztBQUN4QixVQUFROWIsTUFBUjtBQUNFLFNBQUssQ0FBTDtBQUFRLGFBQU8sVUFBVW1ILENBQVYsRUFBYTtBQUMxQixlQUFPMlUsR0FBR0UsSUFBSCxDQUFRekIsSUFBUixFQUFjcFQsQ0FBZCxDQUFQO0FBQ0QsT0FGTzs7QUFHUixTQUFLLENBQUw7QUFBUSxhQUFPLFVBQVVBLENBQVYsRUFBYUQsQ0FBYixFQUFnQjtBQUM3QixlQUFPNFUsR0FBR0UsSUFBSCxDQUFRekIsSUFBUixFQUFjcFQsQ0FBZCxFQUFpQkQsQ0FBakIsQ0FBUDtBQUNELE9BRk87O0FBR1IsU0FBSyxDQUFMO0FBQVEsYUFBTyxVQUFVQyxDQUFWLEVBQWFELENBQWIsRUFBZ0JRLENBQWhCLEVBQW1CO0FBQ2hDLGVBQU9vVSxHQUFHRSxJQUFILENBQVF6QixJQUFSLEVBQWNwVCxDQUFkLEVBQWlCRCxDQUFqQixFQUFvQlEsQ0FBcEIsQ0FBUDtBQUNELE9BRk87QUFQVjs7QUFXQSxTQUFPO0FBQVU7QUFBZTtBQUM5QixXQUFPb1UsR0FBR3FGLEtBQUgsQ0FBUzVHLElBQVQsRUFBZXhCLFNBQWYsQ0FBUDtBQUNELEdBRkQ7QUFHRCxDQWpCRCxDOzs7Ozs7OztDQ0RBOztBQUNBLElBQUl5RyxRQUFRLG1CQUFBcGpCLENBQVEsMENBQVIsQ0FBWjs7QUFDQSxJQUFJZ2xCLFVBQVVDLEtBQUtqSixTQUFMLENBQWVnSixPQUE3QjtBQUNBLElBQUlFLGVBQWVELEtBQUtqSixTQUFMLENBQWVtSixXQUFsQzs7QUFFQSxJQUFJQyxLQUFLLFNBQUxBLEVBQUssQ0FBVUMsR0FBVixFQUFlO0FBQ3RCLFNBQU9BLE1BQU0sQ0FBTixHQUFVQSxHQUFWLEdBQWdCLE1BQU1BLEdBQTdCO0FBQ0QsQ0FGRCxDLENBSUE7OztBQUNBM0osT0FBT3BiLE9BQVAsR0FBa0I4aUIsTUFBTSxZQUFZO0FBQ2xDLFNBQU84QixhQUFhdEYsSUFBYixDQUFrQixJQUFJcUYsSUFBSixDQUFTLENBQUMsSUFBRCxHQUFRLENBQWpCLENBQWxCLEtBQTBDLDBCQUFqRDtBQUNELENBRmlCLEtBRVosQ0FBQzdCLE1BQU0sWUFBWTtBQUN2QjhCLGVBQWF0RixJQUFiLENBQWtCLElBQUlxRixJQUFKLENBQVNLLEdBQVQsQ0FBbEI7QUFDRCxDQUZNLENBRlUsR0FJWCxTQUFTSCxXQUFULEdBQXVCO0FBQzNCLE1BQUksQ0FBQ0ksU0FBU1AsUUFBUXBGLElBQVIsQ0FBYSxJQUFiLENBQVQsQ0FBTCxFQUFtQyxNQUFNNEYsV0FBVyxvQkFBWCxDQUFOO0FBQ25DLE1BQUlDLElBQUksSUFBUjtBQUNBLE1BQUkzZCxJQUFJMmQsRUFBRUMsY0FBRixFQUFSO0FBQ0EsTUFBSUMsSUFBSUYsRUFBRUcsa0JBQUYsRUFBUjtBQUNBLE1BQUlDLElBQUkvZCxJQUFJLENBQUosR0FBUSxHQUFSLEdBQWNBLElBQUksSUFBSixHQUFXLEdBQVgsR0FBaUIsRUFBdkM7QUFDQSxTQUFPK2QsSUFBSSxDQUFDLFVBQVV0ZSxLQUFLTSxHQUFMLENBQVNDLENBQVQsQ0FBWCxFQUF3Qm9YLEtBQXhCLENBQThCMkcsSUFBSSxDQUFDLENBQUwsR0FBUyxDQUFDLENBQXhDLENBQUosR0FDTCxHQURLLEdBQ0NULEdBQUdLLEVBQUVLLFdBQUYsS0FBa0IsQ0FBckIsQ0FERCxHQUMyQixHQUQzQixHQUNpQ1YsR0FBR0ssRUFBRU0sVUFBRixFQUFILENBRGpDLEdBRUwsR0FGSyxHQUVDWCxHQUFHSyxFQUFFTyxXQUFGLEVBQUgsQ0FGRCxHQUV1QixHQUZ2QixHQUU2QlosR0FBR0ssRUFBRVEsYUFBRixFQUFILENBRjdCLEdBR0wsR0FISyxHQUdDYixHQUFHSyxFQUFFUyxhQUFGLEVBQUgsQ0FIRCxHQUd5QixHQUh6QixJQUdnQ1AsSUFBSSxFQUFKLEdBQVNBLENBQVQsR0FBYSxNQUFNUCxHQUFHTyxDQUFILENBSG5ELElBRzRELEdBSG5FO0FBSUQsQ0FkZ0IsR0FjYlQsWUFkSixDOzs7Ozs7OztBQ1hBOztBQUNBLElBQUk3QyxXQUFXLG1CQUFBcmlCLENBQVEsOENBQVIsQ0FBZjs7QUFDQSxJQUFJbW1CLGNBQWMsbUJBQUFubUIsQ0FBUSxpREFBUixDQUFsQjs7QUFDQSxJQUFJb21CLFNBQVMsUUFBYjs7QUFFQTFLLE9BQU9wYixPQUFQLEdBQWlCLFVBQVUrbEIsSUFBVixFQUFnQjtBQUMvQixNQUFJQSxTQUFTLFFBQVQsSUFBcUJBLFNBQVNELE1BQTlCLElBQXdDQyxTQUFTLFNBQXJELEVBQWdFLE1BQU0xSyxVQUFVLGdCQUFWLENBQU47QUFDaEUsU0FBT3dLLFlBQVk5RCxTQUFTLElBQVQsQ0FBWixFQUE0QmdFLFFBQVFELE1BQXBDLENBQVA7QUFDRCxDQUhELEM7Ozs7Ozs7QUNMQTtBQUNBMUssT0FBT3BiLE9BQVAsR0FBaUIsVUFBVXVCLEVBQVYsRUFBYztBQUM3QixNQUFJQSxNQUFNb0IsU0FBVixFQUFxQixNQUFNMFksVUFBVSwyQkFBMkI5WixFQUFyQyxDQUFOO0FBQ3JCLFNBQU9BLEVBQVA7QUFDRCxDQUhELEM7Ozs7Ozs7QUNEQTtBQUNBNlosT0FBT3BiLE9BQVAsR0FBaUIsQ0FBQyxtQkFBQU4sQ0FBUSwwQ0FBUixFQUFvQixZQUFZO0FBQ2hELFNBQU9JLE9BQU9DLGNBQVAsQ0FBc0IsRUFBdEIsRUFBMEIsR0FBMUIsRUFBK0I7QUFBRXdoQixTQUFLLGVBQVk7QUFBRSxhQUFPLENBQVA7QUFBVztBQUFoQyxHQUEvQixFQUFtRTlXLENBQW5FLElBQXdFLENBQS9FO0FBQ0QsQ0FGaUIsQ0FBbEIsQzs7Ozs7OztBQ0RBLElBQUlvUixXQUFXLG1CQUFBbmMsQ0FBUSw4Q0FBUixDQUFmOztBQUNBLElBQUlrYixXQUFXLG1CQUFBbGIsQ0FBUSwyQ0FBUixFQUFxQmtiLFFBQXBDLEMsQ0FDQTs7O0FBQ0EsSUFBSWxSLEtBQUttUyxTQUFTakIsUUFBVCxLQUFzQmlCLFNBQVNqQixTQUFTQyxhQUFsQixDQUEvQjs7QUFDQU8sT0FBT3BiLE9BQVAsR0FBaUIsVUFBVXVCLEVBQVYsRUFBYztBQUM3QixTQUFPbUksS0FBS2tSLFNBQVNDLGFBQVQsQ0FBdUJ0WixFQUF2QixDQUFMLEdBQWtDLEVBQXpDO0FBQ0QsQ0FGRCxDOzs7Ozs7O0FDSkE7QUFDQTZaLE9BQU9wYixPQUFQLEdBQ0UsK0ZBRGUsQ0FFZmdtQixLQUZlLENBRVQsR0FGUyxDQUFqQixDOzs7Ozs7O0FDREE7QUFDQSxJQUFJQyxVQUFVLG1CQUFBdm1CLENBQVEsZ0RBQVIsQ0FBZDs7QUFDQSxJQUFJd21CLE9BQU8sbUJBQUF4bUIsQ0FBUSxnREFBUixDQUFYOztBQUNBLElBQUl5bUIsTUFBTSxtQkFBQXptQixDQUFRLCtDQUFSLENBQVY7O0FBQ0EwYixPQUFPcGIsT0FBUCxHQUFpQixVQUFVdUIsRUFBVixFQUFjO0FBQzdCLE1BQUl5RSxTQUFTaWdCLFFBQVExa0IsRUFBUixDQUFiO0FBQ0EsTUFBSTZrQixhQUFhRixLQUFLbkksQ0FBdEI7O0FBQ0EsTUFBSXFJLFVBQUosRUFBZ0I7QUFDZCxRQUFJQyxVQUFVRCxXQUFXN2tCLEVBQVgsQ0FBZDtBQUNBLFFBQUkra0IsU0FBU0gsSUFBSXBJLENBQWpCO0FBQ0EsUUFBSWpkLElBQUksQ0FBUjtBQUNBLFFBQUlJLEdBQUo7O0FBQ0EsV0FBT21sQixRQUFRL2lCLE1BQVIsR0FBaUJ4QyxDQUF4QjtBQUEyQixVQUFJd2xCLE9BQU9oSCxJQUFQLENBQVkvZCxFQUFaLEVBQWdCTCxNQUFNbWxCLFFBQVF2bEIsR0FBUixDQUF0QixDQUFKLEVBQXlDa0YsT0FBTzdDLElBQVAsQ0FBWWpDLEdBQVo7QUFBcEU7QUFDRDs7QUFBQyxTQUFPOEUsTUFBUDtBQUNILENBVkQsQzs7Ozs7OztBQ0pBLElBQUlyRyxTQUFTLG1CQUFBRCxDQUFRLDJDQUFSLENBQWI7O0FBQ0EsSUFBSXlrQixPQUFPLG1CQUFBemtCLENBQVEseUNBQVIsQ0FBWDs7QUFDQSxJQUFJNm1CLE9BQU8sbUJBQUE3bUIsQ0FBUSx5Q0FBUixDQUFYOztBQUNBLElBQUlrakIsV0FBVyxtQkFBQWxqQixDQUFRLDZDQUFSLENBQWY7O0FBQ0EsSUFBSXVkLE1BQU0sbUJBQUF2ZCxDQUFRLHdDQUFSLENBQVY7O0FBQ0EsSUFBSThtQixZQUFZLFdBQWhCOztBQUVBLElBQUk3RCxVQUFVLFNBQVZBLE9BQVUsQ0FBVWxNLElBQVYsRUFBZ0IxUixJQUFoQixFQUFzQjBoQixNQUF0QixFQUE4QjtBQUMxQyxNQUFJQyxZQUFZalEsT0FBT2tNLFFBQVE1RCxDQUEvQjtBQUNBLE1BQUk0SCxZQUFZbFEsT0FBT2tNLFFBQVFzQixDQUEvQjtBQUNBLE1BQUkyQyxZQUFZblEsT0FBT2tNLFFBQVFrRSxDQUEvQjtBQUNBLE1BQUlDLFdBQVdyUSxPQUFPa00sUUFBUW9FLENBQTlCO0FBQ0EsTUFBSUMsVUFBVXZRLE9BQU9rTSxRQUFROUMsQ0FBN0I7QUFDQSxNQUFJN0gsU0FBUzJPLFlBQVlobkIsTUFBWixHQUFxQmluQixZQUFZam5CLE9BQU9vRixJQUFQLE1BQWlCcEYsT0FBT29GLElBQVAsSUFBZSxFQUFoQyxDQUFaLEdBQWtELENBQUNwRixPQUFPb0YsSUFBUCxLQUFnQixFQUFqQixFQUFxQnloQixTQUFyQixDQUFwRjtBQUNBLE1BQUl4bUIsVUFBVTJtQixZQUFZeEMsSUFBWixHQUFtQkEsS0FBS3BmLElBQUwsTUFBZW9mLEtBQUtwZixJQUFMLElBQWEsRUFBNUIsQ0FBakM7QUFDQSxNQUFJa2lCLFdBQVdqbkIsUUFBUXdtQixTQUFSLE1BQXVCeG1CLFFBQVF3bUIsU0FBUixJQUFxQixFQUE1QyxDQUFmO0FBQ0EsTUFBSXRsQixHQUFKLEVBQVNnbUIsR0FBVCxFQUFjQyxHQUFkLEVBQW1CQyxHQUFuQjtBQUNBLE1BQUlULFNBQUosRUFBZUYsU0FBUzFoQixJQUFUOztBQUNmLE9BQUs3RCxHQUFMLElBQVl1bEIsTUFBWixFQUFvQjtBQUNsQjtBQUNBUyxVQUFNLENBQUNSLFNBQUQsSUFBYzFPLE1BQWQsSUFBd0JBLE9BQU85VyxHQUFQLE1BQWdCeUIsU0FBOUMsQ0FGa0IsQ0FHbEI7O0FBQ0F3a0IsVUFBTSxDQUFDRCxNQUFNbFAsTUFBTixHQUFleU8sTUFBaEIsRUFBd0J2bEIsR0FBeEIsQ0FBTixDQUprQixDQUtsQjs7QUFDQWttQixVQUFNSixXQUFXRSxHQUFYLEdBQWlCakssSUFBSWtLLEdBQUosRUFBU3huQixNQUFULENBQWpCLEdBQW9DbW5CLFlBQVksT0FBT0ssR0FBUCxJQUFjLFVBQTFCLEdBQXVDbEssSUFBSWdDLFNBQVNLLElBQWIsRUFBbUI2SCxHQUFuQixDQUF2QyxHQUFpRUEsR0FBM0csQ0FOa0IsQ0FPbEI7O0FBQ0EsUUFBSW5QLE1BQUosRUFBWTRLLFNBQVM1SyxNQUFULEVBQWlCOVcsR0FBakIsRUFBc0JpbUIsR0FBdEIsRUFBMkIxUSxPQUFPa00sUUFBUTBFLENBQTFDLEVBUk0sQ0FTbEI7O0FBQ0EsUUFBSXJuQixRQUFRa0IsR0FBUixLQUFnQmltQixHQUFwQixFQUF5QlosS0FBS3ZtQixPQUFMLEVBQWNrQixHQUFkLEVBQW1Ca21CLEdBQW5CO0FBQ3pCLFFBQUlOLFlBQVlHLFNBQVMvbEIsR0FBVCxLQUFpQmltQixHQUFqQyxFQUFzQ0YsU0FBUy9sQixHQUFULElBQWdCaW1CLEdBQWhCO0FBQ3ZDO0FBQ0YsQ0F4QkQ7O0FBeUJBeG5CLE9BQU93a0IsSUFBUCxHQUFjQSxJQUFkLEMsQ0FDQTs7QUFDQXhCLFFBQVE1RCxDQUFSLEdBQVksQ0FBWixDLENBQWlCOztBQUNqQjRELFFBQVFzQixDQUFSLEdBQVksQ0FBWixDLENBQWlCOztBQUNqQnRCLFFBQVFrRSxDQUFSLEdBQVksQ0FBWixDLENBQWlCOztBQUNqQmxFLFFBQVFvRSxDQUFSLEdBQVksQ0FBWixDLENBQWlCOztBQUNqQnBFLFFBQVE5QyxDQUFSLEdBQVksRUFBWixDLENBQWlCOztBQUNqQjhDLFFBQVF1QixDQUFSLEdBQVksRUFBWixDLENBQWlCOztBQUNqQnZCLFFBQVEwRSxDQUFSLEdBQVksRUFBWixDLENBQWlCOztBQUNqQjFFLFFBQVEyRSxDQUFSLEdBQVksR0FBWixDLENBQWlCOztBQUNqQmxNLE9BQU9wYixPQUFQLEdBQWlCMmlCLE9BQWpCLEM7Ozs7Ozs7QUMxQ0EsSUFBSTRFLFFBQVEsbUJBQUE3bkIsQ0FBUSx3Q0FBUixFQUFrQixPQUFsQixDQUFaOztBQUNBMGIsT0FBT3BiLE9BQVAsR0FBaUIsVUFBVXdqQixHQUFWLEVBQWU7QUFDOUIsTUFBSWdFLEtBQUssR0FBVDs7QUFDQSxNQUFJO0FBQ0YsVUFBTWhFLEdBQU4sRUFBV2dFLEVBQVg7QUFDRCxHQUZELENBRUUsT0FBTzdILENBQVAsRUFBVTtBQUNWLFFBQUk7QUFDRjZILFNBQUdELEtBQUgsSUFBWSxLQUFaO0FBQ0EsYUFBTyxDQUFDLE1BQU0vRCxHQUFOLEVBQVdnRSxFQUFYLENBQVI7QUFDRCxLQUhELENBR0UsT0FBT3pKLENBQVAsRUFBVTtBQUFFO0FBQWE7QUFDNUI7O0FBQUMsU0FBTyxJQUFQO0FBQ0gsQ0FWRCxDOzs7Ozs7O0FDREEzQyxPQUFPcGIsT0FBUCxHQUFpQixVQUFVeW5CLElBQVYsRUFBZ0I7QUFDL0IsTUFBSTtBQUNGLFdBQU8sQ0FBQyxDQUFDQSxNQUFUO0FBQ0QsR0FGRCxDQUVFLE9BQU85SCxDQUFQLEVBQVU7QUFDVixXQUFPLElBQVA7QUFDRDtBQUNGLENBTkQsQzs7Ozs7Ozs7QUNBQTs7QUFDQSxJQUFJNEcsT0FBTyxtQkFBQTdtQixDQUFRLHlDQUFSLENBQVg7O0FBQ0EsSUFBSWtqQixXQUFXLG1CQUFBbGpCLENBQVEsNkNBQVIsQ0FBZjs7QUFDQSxJQUFJb2pCLFFBQVEsbUJBQUFwakIsQ0FBUSwwQ0FBUixDQUFaOztBQUNBLElBQUlnb0IsVUFBVSxtQkFBQWhvQixDQUFRLDRDQUFSLENBQWQ7O0FBQ0EsSUFBSWlvQixNQUFNLG1CQUFBam9CLENBQVEsd0NBQVIsQ0FBVjs7QUFFQTBiLE9BQU9wYixPQUFQLEdBQWlCLFVBQVV3akIsR0FBVixFQUFlbGdCLE1BQWYsRUFBdUJta0IsSUFBdkIsRUFBNkI7QUFDNUMsTUFBSUcsU0FBU0QsSUFBSW5FLEdBQUosQ0FBYjtBQUNBLE1BQUlxRSxNQUFNSixLQUFLQyxPQUFMLEVBQWNFLE1BQWQsRUFBc0IsR0FBR3BFLEdBQUgsQ0FBdEIsQ0FBVjtBQUNBLE1BQUlzRSxRQUFRRCxJQUFJLENBQUosQ0FBWjtBQUNBLE1BQUlFLE9BQU9GLElBQUksQ0FBSixDQUFYOztBQUNBLE1BQUkvRSxNQUFNLFlBQVk7QUFDcEIsUUFBSTVHLElBQUksRUFBUjs7QUFDQUEsTUFBRTBMLE1BQUYsSUFBWSxZQUFZO0FBQUUsYUFBTyxDQUFQO0FBQVcsS0FBckM7O0FBQ0EsV0FBTyxHQUFHcEUsR0FBSCxFQUFRdEgsQ0FBUixLQUFjLENBQXJCO0FBQ0QsR0FKRyxDQUFKLEVBSUk7QUFDRjBHLGFBQVNvRixPQUFPdE0sU0FBaEIsRUFBMkI4SCxHQUEzQixFQUFnQ3NFLEtBQWhDO0FBQ0F2QixTQUFLMEIsT0FBT3ZNLFNBQVosRUFBdUJrTSxNQUF2QixFQUErQnRrQixVQUFVLENBQVYsQ0FDN0I7QUFDQTtBQUY2QixNQUczQixVQUFVNGtCLE1BQVYsRUFBa0JDLEdBQWxCLEVBQXVCO0FBQUUsYUFBT0osS0FBS3pJLElBQUwsQ0FBVTRJLE1BQVYsRUFBa0IsSUFBbEIsRUFBd0JDLEdBQXhCLENBQVA7QUFBc0MsS0FIcEMsQ0FJN0I7QUFDQTtBQUw2QixNQU0zQixVQUFVRCxNQUFWLEVBQWtCO0FBQUUsYUFBT0gsS0FBS3pJLElBQUwsQ0FBVTRJLE1BQVYsRUFBa0IsSUFBbEIsQ0FBUDtBQUFpQyxLQU56RDtBQVFEO0FBQ0YsQ0FwQkQsQzs7Ozs7Ozs7Q0NOQTs7QUFDQSxJQUFJbkcsV0FBVyxtQkFBQXJpQixDQUFRLDhDQUFSLENBQWY7O0FBQ0EwYixPQUFPcGIsT0FBUCxHQUFpQixZQUFZO0FBQzNCLE1BQUk2ZCxPQUFPa0UsU0FBUyxJQUFULENBQVg7QUFDQSxNQUFJL2IsU0FBUyxFQUFiO0FBQ0EsTUFBSTZYLEtBQUtsZSxNQUFULEVBQWlCcUcsVUFBVSxHQUFWO0FBQ2pCLE1BQUk2WCxLQUFLdUssVUFBVCxFQUFxQnBpQixVQUFVLEdBQVY7QUFDckIsTUFBSTZYLEtBQUt3SyxTQUFULEVBQW9CcmlCLFVBQVUsR0FBVjtBQUNwQixNQUFJNlgsS0FBS3lLLE9BQVQsRUFBa0J0aUIsVUFBVSxHQUFWO0FBQ2xCLE1BQUk2WCxLQUFLMEssTUFBVCxFQUFpQnZpQixVQUFVLEdBQVY7QUFDakIsU0FBT0EsTUFBUDtBQUNELENBVEQsQzs7Ozs7Ozs7Q0NGQTs7QUFDQSxJQUFJd0osVUFBVSxtQkFBQTlQLENBQVEsNkNBQVIsQ0FBZDs7QUFDQSxJQUFJbWMsV0FBVyxtQkFBQW5jLENBQVEsOENBQVIsQ0FBZjs7QUFDQSxJQUFJc2MsV0FBVyxtQkFBQXRjLENBQVEsOENBQVIsQ0FBZjs7QUFDQSxJQUFJdWQsTUFBTSxtQkFBQXZkLENBQVEsd0NBQVIsQ0FBVjs7QUFDQSxJQUFJOG9CLHVCQUF1QixtQkFBQTlvQixDQUFRLHdDQUFSLEVBQWtCLG9CQUFsQixDQUEzQjs7QUFFQSxTQUFTK29CLGdCQUFULENBQTBCelEsTUFBMUIsRUFBa0NzRyxRQUFsQyxFQUE0Q21JLE1BQTVDLEVBQW9EaUMsU0FBcEQsRUFBK0Q5bkIsS0FBL0QsRUFBc0UrbkIsS0FBdEUsRUFBNkVqbkIsTUFBN0UsRUFBcUZrbkIsT0FBckYsRUFBOEY7QUFDNUYsTUFBSUMsY0FBY2pvQixLQUFsQjtBQUNBLE1BQUlrb0IsY0FBYyxDQUFsQjtBQUNBLE1BQUlDLFFBQVFybkIsU0FBU3ViLElBQUl2YixNQUFKLEVBQVlrbkIsT0FBWixFQUFxQixDQUFyQixDQUFULEdBQW1DLEtBQS9DO0FBQ0EsTUFBSXpTLE9BQUosRUFBYTZTLFVBQWI7O0FBRUEsU0FBT0YsY0FBY0osU0FBckIsRUFBZ0M7QUFDOUIsUUFBSUksZUFBZXJDLE1BQW5CLEVBQTJCO0FBQ3pCdFEsZ0JBQVU0UyxRQUFRQSxNQUFNdEMsT0FBT3FDLFdBQVAsQ0FBTixFQUEyQkEsV0FBM0IsRUFBd0N4SyxRQUF4QyxDQUFSLEdBQTREbUksT0FBT3FDLFdBQVAsQ0FBdEU7QUFFQUUsbUJBQWEsS0FBYjs7QUFDQSxVQUFJbk4sU0FBUzFGLE9BQVQsQ0FBSixFQUF1QjtBQUNyQjZTLHFCQUFhN1MsUUFBUXFTLG9CQUFSLENBQWI7QUFDQVEscUJBQWFBLGVBQWVybUIsU0FBZixHQUEyQixDQUFDLENBQUNxbUIsVUFBN0IsR0FBMEN4WixRQUFRMkcsT0FBUixDQUF2RDtBQUNEOztBQUVELFVBQUk2UyxjQUFjTCxRQUFRLENBQTFCLEVBQTZCO0FBQzNCRSxzQkFBY0osaUJBQWlCelEsTUFBakIsRUFBeUJzRyxRQUF6QixFQUFtQ25JLE9BQW5DLEVBQTRDNkYsU0FBUzdGLFFBQVE3UyxNQUFqQixDQUE1QyxFQUFzRXVsQixXQUF0RSxFQUFtRkYsUUFBUSxDQUEzRixJQUFnRyxDQUE5RztBQUNELE9BRkQsTUFFTztBQUNMLFlBQUlFLGVBQWUsZ0JBQW5CLEVBQXFDLE1BQU14TixXQUFOO0FBQ3JDckQsZUFBTzZRLFdBQVAsSUFBc0IxUyxPQUF0QjtBQUNEOztBQUVEMFM7QUFDRDs7QUFDREM7QUFDRDs7QUFDRCxTQUFPRCxXQUFQO0FBQ0Q7O0FBRUR6TixPQUFPcGIsT0FBUCxHQUFpQnlvQixnQkFBakIsQzs7Ozs7OztBQ3RDQSxJQUFJeEwsTUFBTSxtQkFBQXZkLENBQVEsd0NBQVIsQ0FBVjs7QUFDQSxJQUFJNGYsT0FBTyxtQkFBQTVmLENBQVEsOENBQVIsQ0FBWDs7QUFDQSxJQUFJdXBCLGNBQWMsbUJBQUF2cEIsQ0FBUSxrREFBUixDQUFsQjs7QUFDQSxJQUFJcWlCLFdBQVcsbUJBQUFyaUIsQ0FBUSw4Q0FBUixDQUFmOztBQUNBLElBQUlzYyxXQUFXLG1CQUFBdGMsQ0FBUSw4Q0FBUixDQUFmOztBQUNBLElBQUl3cEIsWUFBWSxtQkFBQXhwQixDQUFRLDREQUFSLENBQWhCOztBQUNBLElBQUl5cEIsUUFBUSxFQUFaO0FBQ0EsSUFBSUMsU0FBUyxFQUFiOztBQUNBLElBQUlwcEIsVUFBVW9iLE9BQU9wYixPQUFQLEdBQWlCLFVBQVVnQixRQUFWLEVBQW9CeWlCLE9BQXBCLEVBQTZCckUsRUFBN0IsRUFBaUN2QixJQUFqQyxFQUF1Q2xCLFFBQXZDLEVBQWlEO0FBQzlFLE1BQUkwTSxTQUFTMU0sV0FBVyxZQUFZO0FBQUUsV0FBTzNiLFFBQVA7QUFBa0IsR0FBM0MsR0FBOENrb0IsVUFBVWxvQixRQUFWLENBQTNEO0FBQ0EsTUFBSStjLElBQUlkLElBQUltQyxFQUFKLEVBQVF2QixJQUFSLEVBQWM0RixVQUFVLENBQVYsR0FBYyxDQUE1QixDQUFSO0FBQ0EsTUFBSWppQixRQUFRLENBQVo7QUFDQSxNQUFJOEIsTUFBSixFQUFZOGMsSUFBWixFQUFrQmtKLFFBQWxCLEVBQTRCdGpCLE1BQTVCO0FBQ0EsTUFBSSxPQUFPcWpCLE1BQVAsSUFBaUIsVUFBckIsRUFBaUMsTUFBTWhPLFVBQVVyYSxXQUFXLG1CQUFyQixDQUFOLENBTDZDLENBTTlFOztBQUNBLE1BQUlpb0IsWUFBWUksTUFBWixDQUFKLEVBQXlCLEtBQUsvbEIsU0FBUzBZLFNBQVNoYixTQUFTc0MsTUFBbEIsQ0FBZCxFQUF5Q0EsU0FBUzlCLEtBQWxELEVBQXlEQSxPQUF6RCxFQUFrRTtBQUN6RndFLGFBQVN5ZCxVQUFVMUYsRUFBRWdFLFNBQVMzQixPQUFPcGYsU0FBU1EsS0FBVCxDQUFoQixFQUFpQyxDQUFqQyxDQUFGLEVBQXVDNGUsS0FBSyxDQUFMLENBQXZDLENBQVYsR0FBNERyQyxFQUFFL2MsU0FBU1EsS0FBVCxDQUFGLENBQXJFO0FBQ0EsUUFBSXdFLFdBQVdtakIsS0FBWCxJQUFvQm5qQixXQUFXb2pCLE1BQW5DLEVBQTJDLE9BQU9wakIsTUFBUDtBQUM1QyxHQUhELE1BR08sS0FBS3NqQixXQUFXRCxPQUFPL0osSUFBUCxDQUFZdGUsUUFBWixDQUFoQixFQUF1QyxDQUFDLENBQUNvZixPQUFPa0osU0FBU2xtQixJQUFULEVBQVIsRUFBeUJtbUIsSUFBakUsR0FBd0U7QUFDN0V2akIsYUFBU3NaLEtBQUtnSyxRQUFMLEVBQWV2TCxDQUFmLEVBQWtCcUMsS0FBS25nQixLQUF2QixFQUE4QndqQixPQUE5QixDQUFUO0FBQ0EsUUFBSXpkLFdBQVdtakIsS0FBWCxJQUFvQm5qQixXQUFXb2pCLE1BQW5DLEVBQTJDLE9BQU9wakIsTUFBUDtBQUM1QztBQUNGLENBZEQ7O0FBZUFoRyxRQUFRbXBCLEtBQVIsR0FBZ0JBLEtBQWhCO0FBQ0FucEIsUUFBUW9wQixNQUFSLEdBQWlCQSxNQUFqQixDOzs7Ozs7O0FDeEJBO0FBQ0EsSUFBSXpwQixTQUFTeWIsT0FBT3BiLE9BQVAsR0FBaUIsT0FBT2diLE1BQVAsSUFBaUIsV0FBakIsSUFBZ0NBLE9BQU8vVCxJQUFQLElBQWVBLElBQS9DLEdBQzFCK1QsTUFEMEIsR0FDakIsT0FBTzhDLElBQVAsSUFBZSxXQUFmLElBQThCQSxLQUFLN1csSUFBTCxJQUFhQSxJQUEzQyxHQUFrRDZXLElBQWxELENBQ1g7QUFEVyxFQUVUbUIsU0FBUyxhQUFULEdBSEo7QUFJQSxJQUFJLE9BQU91SyxHQUFQLElBQWMsUUFBbEIsRUFBNEJBLE1BQU03cEIsTUFBTixDLENBQWMsK0I7Ozs7Ozs7QUNMMUMsSUFBSThwQixpQkFBaUIsR0FBR0EsY0FBeEI7O0FBQ0FyTyxPQUFPcGIsT0FBUCxHQUFpQixVQUFVdUIsRUFBVixFQUFjTCxHQUFkLEVBQW1CO0FBQ2xDLFNBQU91b0IsZUFBZW5LLElBQWYsQ0FBb0IvZCxFQUFwQixFQUF3QkwsR0FBeEIsQ0FBUDtBQUNELENBRkQsQzs7Ozs7OztBQ0RBLElBQUk4ZSxLQUFLLG1CQUFBdGdCLENBQVEsOENBQVIsQ0FBVDs7QUFDQSxJQUFJNmtCLGFBQWEsbUJBQUE3a0IsQ0FBUSxrREFBUixDQUFqQjs7QUFDQTBiLE9BQU9wYixPQUFQLEdBQWlCLG1CQUFBTixDQUFRLGdEQUFSLElBQTRCLFVBQVU4a0IsTUFBVixFQUFrQnRqQixHQUFsQixFQUF1QmpCLEtBQXZCLEVBQThCO0FBQ3pFLFNBQU8rZixHQUFHakMsQ0FBSCxDQUFLeUcsTUFBTCxFQUFhdGpCLEdBQWIsRUFBa0JxakIsV0FBVyxDQUFYLEVBQWN0a0IsS0FBZCxDQUFsQixDQUFQO0FBQ0QsQ0FGZ0IsR0FFYixVQUFVdWtCLE1BQVYsRUFBa0J0akIsR0FBbEIsRUFBdUJqQixLQUF2QixFQUE4QjtBQUNoQ3VrQixTQUFPdGpCLEdBQVAsSUFBY2pCLEtBQWQ7QUFDQSxTQUFPdWtCLE1BQVA7QUFDRCxDQUxELEM7Ozs7Ozs7QUNGQSxJQUFJNUosV0FBVyxtQkFBQWxiLENBQVEsMkNBQVIsRUFBcUJrYixRQUFwQzs7QUFDQVEsT0FBT3BiLE9BQVAsR0FBaUI0YSxZQUFZQSxTQUFTOE8sZUFBdEMsQzs7Ozs7OztBQ0RBdE8sT0FBT3BiLE9BQVAsR0FBaUIsQ0FBQyxtQkFBQU4sQ0FBUSxnREFBUixDQUFELElBQThCLENBQUMsbUJBQUFBLENBQVEsMENBQVIsRUFBb0IsWUFBWTtBQUM5RSxTQUFPSSxPQUFPQyxjQUFQLENBQXNCLG1CQUFBTCxDQUFRLCtDQUFSLEVBQXlCLEtBQXpCLENBQXRCLEVBQXVELEdBQXZELEVBQTREO0FBQUU2aEIsU0FBSyxlQUFZO0FBQUUsYUFBTyxDQUFQO0FBQVc7QUFBaEMsR0FBNUQsRUFBZ0c5VyxDQUFoRyxJQUFxRyxDQUE1RztBQUNELENBRitDLENBQWhELEM7Ozs7Ozs7QUNBQSxJQUFJb1IsV0FBVyxtQkFBQW5jLENBQVEsOENBQVIsQ0FBZjs7QUFDQSxJQUFJaXFCLGlCQUFpQixtQkFBQWpxQixDQUFRLDhDQUFSLEVBQXdCOGlCLEdBQTdDOztBQUNBcEgsT0FBT3BiLE9BQVAsR0FBaUIsVUFBVTZkLElBQVYsRUFBZ0I3RixNQUFoQixFQUF3QnVHLENBQXhCLEVBQTJCO0FBQzFDLE1BQUlzSSxJQUFJN08sT0FBT3dHLFdBQWY7QUFDQSxNQUFJdUksQ0FBSjs7QUFDQSxNQUFJRixNQUFNdEksQ0FBTixJQUFXLE9BQU9zSSxDQUFQLElBQVksVUFBdkIsSUFBcUMsQ0FBQ0UsSUFBSUYsRUFBRW5MLFNBQVAsTUFBc0I2QyxFQUFFN0MsU0FBN0QsSUFBMEVHLFNBQVNrTCxDQUFULENBQTFFLElBQXlGNEMsY0FBN0YsRUFBNkc7QUFDM0dBLG1CQUFlOUwsSUFBZixFQUFxQmtKLENBQXJCO0FBQ0Q7O0FBQUMsU0FBT2xKLElBQVA7QUFDSCxDQU5ELEM7Ozs7Ozs7QUNGQTtBQUNBekMsT0FBT3BiLE9BQVAsR0FBaUIsVUFBVW9mLEVBQVYsRUFBY0osSUFBZCxFQUFvQm5CLElBQXBCLEVBQTBCO0FBQ3pDLE1BQUkrTCxLQUFLL0wsU0FBU2xiLFNBQWxCOztBQUNBLFVBQVFxYyxLQUFLMWIsTUFBYjtBQUNFLFNBQUssQ0FBTDtBQUFRLGFBQU9zbUIsS0FBS3hLLElBQUwsR0FDS0EsR0FBR0UsSUFBSCxDQUFRekIsSUFBUixDQURaOztBQUVSLFNBQUssQ0FBTDtBQUFRLGFBQU8rTCxLQUFLeEssR0FBR0osS0FBSyxDQUFMLENBQUgsQ0FBTCxHQUNLSSxHQUFHRSxJQUFILENBQVF6QixJQUFSLEVBQWNtQixLQUFLLENBQUwsQ0FBZCxDQURaOztBQUVSLFNBQUssQ0FBTDtBQUFRLGFBQU80SyxLQUFLeEssR0FBR0osS0FBSyxDQUFMLENBQUgsRUFBWUEsS0FBSyxDQUFMLENBQVosQ0FBTCxHQUNLSSxHQUFHRSxJQUFILENBQVF6QixJQUFSLEVBQWNtQixLQUFLLENBQUwsQ0FBZCxFQUF1QkEsS0FBSyxDQUFMLENBQXZCLENBRFo7O0FBRVIsU0FBSyxDQUFMO0FBQVEsYUFBTzRLLEtBQUt4SyxHQUFHSixLQUFLLENBQUwsQ0FBSCxFQUFZQSxLQUFLLENBQUwsQ0FBWixFQUFxQkEsS0FBSyxDQUFMLENBQXJCLENBQUwsR0FDS0ksR0FBR0UsSUFBSCxDQUFRekIsSUFBUixFQUFjbUIsS0FBSyxDQUFMLENBQWQsRUFBdUJBLEtBQUssQ0FBTCxDQUF2QixFQUFnQ0EsS0FBSyxDQUFMLENBQWhDLENBRFo7O0FBRVIsU0FBSyxDQUFMO0FBQVEsYUFBTzRLLEtBQUt4SyxHQUFHSixLQUFLLENBQUwsQ0FBSCxFQUFZQSxLQUFLLENBQUwsQ0FBWixFQUFxQkEsS0FBSyxDQUFMLENBQXJCLEVBQThCQSxLQUFLLENBQUwsQ0FBOUIsQ0FBTCxHQUNLSSxHQUFHRSxJQUFILENBQVF6QixJQUFSLEVBQWNtQixLQUFLLENBQUwsQ0FBZCxFQUF1QkEsS0FBSyxDQUFMLENBQXZCLEVBQWdDQSxLQUFLLENBQUwsQ0FBaEMsRUFBeUNBLEtBQUssQ0FBTCxDQUF6QyxDQURaO0FBVFY7O0FBV0UsU0FBT0ksR0FBR3FGLEtBQUgsQ0FBUzVHLElBQVQsRUFBZW1CLElBQWYsQ0FBUDtBQUNILENBZEQsQzs7Ozs7OztBQ0RBO0FBQ0EsSUFBSTFELE1BQU0sbUJBQUE1YixDQUFRLHdDQUFSLENBQVYsQyxDQUNBOzs7QUFDQTBiLE9BQU9wYixPQUFQLEdBQWlCRixPQUFPLEdBQVAsRUFBWStwQixvQkFBWixDQUFpQyxDQUFqQyxJQUFzQy9wQixNQUF0QyxHQUErQyxVQUFVeUIsRUFBVixFQUFjO0FBQzVFLFNBQU8rWixJQUFJL1osRUFBSixLQUFXLFFBQVgsR0FBc0JBLEdBQUd5a0IsS0FBSCxDQUFTLEVBQVQsQ0FBdEIsR0FBcUNsbUIsT0FBT3lCLEVBQVAsQ0FBNUM7QUFDRCxDQUZELEM7Ozs7Ozs7QUNIQTtBQUNBLElBQUl1b0IsWUFBWSxtQkFBQXBxQixDQUFRLDhDQUFSLENBQWhCOztBQUNBLElBQUlpZCxXQUFXLG1CQUFBamQsQ0FBUSx3Q0FBUixFQUFrQixVQUFsQixDQUFmOztBQUNBLElBQUkrYixhQUFhcFosTUFBTXFaLFNBQXZCOztBQUVBTixPQUFPcGIsT0FBUCxHQUFpQixVQUFVdUIsRUFBVixFQUFjO0FBQzdCLFNBQU9BLE9BQU9vQixTQUFQLEtBQXFCbW5CLFVBQVV6bkIsS0FBVixLQUFvQmQsRUFBcEIsSUFBMEJrYSxXQUFXa0IsUUFBWCxNQUF5QnBiLEVBQXhFLENBQVA7QUFDRCxDQUZELEM7Ozs7Ozs7QUNMQTtBQUNBLElBQUkrWixNQUFNLG1CQUFBNWIsQ0FBUSx3Q0FBUixDQUFWOztBQUNBMGIsT0FBT3BiLE9BQVAsR0FBaUJxQyxNQUFNbU4sT0FBTixJQUFpQixTQUFTQSxPQUFULENBQWlCMlksR0FBakIsRUFBc0I7QUFDdEQsU0FBTzdNLElBQUk2TSxHQUFKLEtBQVksT0FBbkI7QUFDRCxDQUZELEM7Ozs7Ozs7QUNGQTtBQUNBLElBQUl0TSxXQUFXLG1CQUFBbmMsQ0FBUSw4Q0FBUixDQUFmOztBQUNBLElBQUlxcUIsUUFBUTlpQixLQUFLOGlCLEtBQWpCOztBQUNBM08sT0FBT3BiLE9BQVAsR0FBaUIsU0FBU2dxQixTQUFULENBQW1Cem9CLEVBQW5CLEVBQXVCO0FBQ3RDLFNBQU8sQ0FBQ3NhLFNBQVN0YSxFQUFULENBQUQsSUFBaUIwakIsU0FBUzFqQixFQUFULENBQWpCLElBQWlDd29CLE1BQU14b0IsRUFBTixNQUFjQSxFQUF0RDtBQUNELENBRkQsQzs7Ozs7OztBQ0hBNlosT0FBT3BiLE9BQVAsR0FBaUIsVUFBVXVCLEVBQVYsRUFBYztBQUM3QixTQUFPLE9BQU9BLEVBQVAsS0FBYyxRQUFkLEdBQXlCQSxPQUFPLElBQWhDLEdBQXVDLE9BQU9BLEVBQVAsS0FBYyxVQUE1RDtBQUNELENBRkQsQzs7Ozs7OztBQ0FBO0FBQ0EsSUFBSXNhLFdBQVcsbUJBQUFuYyxDQUFRLDhDQUFSLENBQWY7O0FBQ0EsSUFBSTRiLE1BQU0sbUJBQUE1YixDQUFRLHdDQUFSLENBQVY7O0FBQ0EsSUFBSTZuQixRQUFRLG1CQUFBN25CLENBQVEsd0NBQVIsRUFBa0IsT0FBbEIsQ0FBWjs7QUFDQTBiLE9BQU9wYixPQUFQLEdBQWlCLFVBQVV1QixFQUFWLEVBQWM7QUFDN0IsTUFBSTBvQixRQUFKO0FBQ0EsU0FBT3BPLFNBQVN0YSxFQUFULE1BQWlCLENBQUMwb0IsV0FBVzFvQixHQUFHZ21CLEtBQUgsQ0FBWixNQUEyQjVrQixTQUEzQixHQUF1QyxDQUFDLENBQUNzbkIsUUFBekMsR0FBb0QzTyxJQUFJL1osRUFBSixLQUFXLFFBQWhGLENBQVA7QUFDRCxDQUhELEM7Ozs7Ozs7QUNKQTtBQUNBLElBQUl3Z0IsV0FBVyxtQkFBQXJpQixDQUFRLDhDQUFSLENBQWY7O0FBQ0EwYixPQUFPcGIsT0FBUCxHQUFpQixVQUFVc3BCLFFBQVYsRUFBb0JsSyxFQUFwQixFQUF3Qm5mLEtBQXhCLEVBQStCd2pCLE9BQS9CLEVBQXdDO0FBQ3ZELE1BQUk7QUFDRixXQUFPQSxVQUFVckUsR0FBRzJDLFNBQVM5aEIsS0FBVCxFQUFnQixDQUFoQixDQUFILEVBQXVCQSxNQUFNLENBQU4sQ0FBdkIsQ0FBVixHQUE2Q21mLEdBQUduZixLQUFILENBQXBELENBREUsQ0FFSjtBQUNDLEdBSEQsQ0FHRSxPQUFPMGYsQ0FBUCxFQUFVO0FBQ1YsUUFBSXVLLE1BQU1aLFNBQVMsUUFBVCxDQUFWO0FBQ0EsUUFBSVksUUFBUXZuQixTQUFaLEVBQXVCb2YsU0FBU21JLElBQUk1SyxJQUFKLENBQVNnSyxRQUFULENBQVQ7QUFDdkIsVUFBTTNKLENBQU47QUFDRDtBQUNGLENBVEQsQzs7Ozs7Ozs7QUNGQTs7QUFDQSxJQUFJdEosU0FBUyxtQkFBQTNXLENBQVEsa0RBQVIsQ0FBYjs7QUFDQSxJQUFJeXFCLGFBQWEsbUJBQUF6cUIsQ0FBUSxrREFBUixDQUFqQjs7QUFDQSxJQUFJc2pCLGlCQUFpQixtQkFBQXRqQixDQUFRLHNEQUFSLENBQXJCOztBQUNBLElBQUkwcUIsb0JBQW9CLEVBQXhCLEMsQ0FFQTs7QUFDQSxtQkFBQTFxQixDQUFRLHlDQUFSLEVBQW1CMHFCLGlCQUFuQixFQUFzQyxtQkFBQTFxQixDQUFRLHdDQUFSLEVBQWtCLFVBQWxCLENBQXRDLEVBQXFFLFlBQVk7QUFBRSxTQUFPLElBQVA7QUFBYyxDQUFqRzs7QUFFQTBiLE9BQU9wYixPQUFQLEdBQWlCLFVBQVUyYixXQUFWLEVBQXVCc0YsSUFBdkIsRUFBNkI3ZCxJQUE3QixFQUFtQztBQUNsRHVZLGNBQVlELFNBQVosR0FBd0JyRixPQUFPK1QsaUJBQVAsRUFBMEI7QUFBRWhuQixVQUFNK21CLFdBQVcsQ0FBWCxFQUFjL21CLElBQWQ7QUFBUixHQUExQixDQUF4QjtBQUNBNGYsaUJBQWVySCxXQUFmLEVBQTRCc0YsT0FBTyxXQUFuQztBQUNELENBSEQsQzs7Ozs7Ozs7QUNUQTs7QUFDQSxJQUFJb0osVUFBVSxtQkFBQTNxQixDQUFRLDRDQUFSLENBQWQ7O0FBQ0EsSUFBSWlqQixVQUFVLG1CQUFBampCLENBQVEsMkNBQVIsQ0FBZDs7QUFDQSxJQUFJa2pCLFdBQVcsbUJBQUFsakIsQ0FBUSw2Q0FBUixDQUFmOztBQUNBLElBQUk2bUIsT0FBTyxtQkFBQTdtQixDQUFRLHlDQUFSLENBQVg7O0FBQ0EsSUFBSWlFLE1BQU0sbUJBQUFqRSxDQUFRLHdDQUFSLENBQVY7O0FBQ0EsSUFBSW9xQixZQUFZLG1CQUFBcHFCLENBQVEsOENBQVIsQ0FBaEI7O0FBQ0EsSUFBSTRxQixjQUFjLG1CQUFBNXFCLENBQVEsZ0RBQVIsQ0FBbEI7O0FBQ0EsSUFBSXNqQixpQkFBaUIsbUJBQUF0akIsQ0FBUSxzREFBUixDQUFyQjs7QUFDQSxJQUFJNnFCLGlCQUFpQixtQkFBQTdxQixDQUFRLCtDQUFSLENBQXJCOztBQUNBLElBQUlpZCxXQUFXLG1CQUFBamQsQ0FBUSx3Q0FBUixFQUFrQixVQUFsQixDQUFmOztBQUNBLElBQUk4cUIsUUFBUSxFQUFFLEdBQUc5cEIsSUFBSCxJQUFXLFVBQVUsR0FBR0EsSUFBSCxFQUF2QixDQUFaLEMsQ0FBK0M7O0FBQy9DLElBQUkrcEIsY0FBYyxZQUFsQjtBQUNBLElBQUlDLE9BQU8sTUFBWDtBQUNBLElBQUlDLFNBQVMsUUFBYjs7QUFFQSxJQUFJQyxhQUFhLFNBQWJBLFVBQWEsR0FBWTtBQUFFLFNBQU8sSUFBUDtBQUFjLENBQTdDOztBQUVBeFAsT0FBT3BiLE9BQVAsR0FBaUIsVUFBVXFqQixJQUFWLEVBQWdCcEMsSUFBaEIsRUFBc0J0RixXQUF0QixFQUFtQ3ZZLElBQW5DLEVBQXlDeW5CLE9BQXpDLEVBQWtEQyxNQUFsRCxFQUEwREMsTUFBMUQsRUFBa0U7QUFDakZULGNBQVkzTyxXQUFaLEVBQXlCc0YsSUFBekIsRUFBK0I3ZCxJQUEvQjs7QUFDQSxNQUFJNG5CLFlBQVksU0FBWkEsU0FBWSxDQUFVckosSUFBVixFQUFnQjtBQUM5QixRQUFJLENBQUM2SSxLQUFELElBQVU3SSxRQUFRMkIsS0FBdEIsRUFBNkIsT0FBT0EsTUFBTTNCLElBQU4sQ0FBUDs7QUFDN0IsWUFBUUEsSUFBUjtBQUNFLFdBQUsrSSxJQUFMO0FBQVcsZUFBTyxTQUFTaHFCLElBQVQsR0FBZ0I7QUFBRSxpQkFBTyxJQUFJaWIsV0FBSixDQUFnQixJQUFoQixFQUFzQmdHLElBQXRCLENBQVA7QUFBcUMsU0FBOUQ7O0FBQ1gsV0FBS2dKLE1BQUw7QUFBYSxlQUFPLFNBQVNocUIsTUFBVCxHQUFrQjtBQUFFLGlCQUFPLElBQUlnYixXQUFKLENBQWdCLElBQWhCLEVBQXNCZ0csSUFBdEIsQ0FBUDtBQUFxQyxTQUFoRTtBQUZmOztBQUdFLFdBQU8sU0FBUzhCLE9BQVQsR0FBbUI7QUFBRSxhQUFPLElBQUk5SCxXQUFKLENBQWdCLElBQWhCLEVBQXNCZ0csSUFBdEIsQ0FBUDtBQUFxQyxLQUFqRTtBQUNILEdBTkQ7O0FBT0EsTUFBSW5DLE1BQU15QixPQUFPLFdBQWpCO0FBQ0EsTUFBSWdLLGFBQWFKLFdBQVdGLE1BQTVCO0FBQ0EsTUFBSU8sYUFBYSxLQUFqQjtBQUNBLE1BQUk1SCxRQUFRRCxLQUFLM0gsU0FBakI7QUFDQSxNQUFJeVAsVUFBVTdILE1BQU0zRyxRQUFOLEtBQW1CMkcsTUFBTW1ILFdBQU4sQ0FBbkIsSUFBeUNJLFdBQVd2SCxNQUFNdUgsT0FBTixDQUFsRTtBQUNBLE1BQUlPLFdBQVdELFdBQVdILFVBQVVILE9BQVYsQ0FBMUI7QUFDQSxNQUFJUSxXQUFXUixVQUFVLENBQUNJLFVBQUQsR0FBY0csUUFBZCxHQUF5QkosVUFBVSxTQUFWLENBQW5DLEdBQTBEcm9CLFNBQXpFO0FBQ0EsTUFBSTJvQixhQUFhckssUUFBUSxPQUFSLEdBQWtCcUMsTUFBTUcsT0FBTixJQUFpQjBILE9BQW5DLEdBQTZDQSxPQUE5RDtBQUNBLE1BQUlqSSxPQUFKLEVBQWFoaUIsR0FBYixFQUFrQmtwQixpQkFBbEIsQ0FqQmlGLENBa0JqRjs7QUFDQSxNQUFJa0IsVUFBSixFQUFnQjtBQUNkbEIsd0JBQW9CRyxlQUFlZSxXQUFXaE0sSUFBWCxDQUFnQixJQUFJK0QsSUFBSixFQUFoQixDQUFmLENBQXBCOztBQUNBLFFBQUkrRyxzQkFBc0J0cUIsT0FBTzRiLFNBQTdCLElBQTBDME8sa0JBQWtCaG5CLElBQWhFLEVBQXNFO0FBQ3BFO0FBQ0E0ZixxQkFBZW9ILGlCQUFmLEVBQWtDNUssR0FBbEMsRUFBdUMsSUFBdkMsRUFGb0UsQ0FHcEU7O0FBQ0EsVUFBSSxDQUFDNkssT0FBRCxJQUFZLENBQUMxbUIsSUFBSXltQixpQkFBSixFQUF1QnpOLFFBQXZCLENBQWpCLEVBQW1ENEosS0FBSzZELGlCQUFMLEVBQXdCek4sUUFBeEIsRUFBa0NpTyxVQUFsQztBQUNwRDtBQUNGLEdBM0JnRixDQTRCakY7OztBQUNBLE1BQUlLLGNBQWNFLE9BQWQsSUFBeUJBLFFBQVFwbUIsSUFBUixLQUFpQjRsQixNQUE5QyxFQUFzRDtBQUNwRE8saUJBQWEsSUFBYjs7QUFDQUUsZUFBVyxTQUFTenFCLE1BQVQsR0FBa0I7QUFBRSxhQUFPd3FCLFFBQVE3TCxJQUFSLENBQWEsSUFBYixDQUFQO0FBQTRCLEtBQTNEO0FBQ0QsR0FoQ2dGLENBaUNqRjs7O0FBQ0EsTUFBSSxDQUFDLENBQUMrSyxPQUFELElBQVlVLE1BQWIsTUFBeUJQLFNBQVNVLFVBQVQsSUFBdUIsQ0FBQzVILE1BQU0zRyxRQUFOLENBQWpELENBQUosRUFBdUU7QUFDckU0SixTQUFLakQsS0FBTCxFQUFZM0csUUFBWixFQUFzQnlPLFFBQXRCO0FBQ0QsR0FwQ2dGLENBcUNqRjs7O0FBQ0F0QixZQUFVN0ksSUFBVixJQUFrQm1LLFFBQWxCO0FBQ0F0QixZQUFVdEssR0FBVixJQUFpQm9MLFVBQWpCOztBQUNBLE1BQUlDLE9BQUosRUFBYTtBQUNYM0gsY0FBVTtBQUNSdmlCLGNBQVFzcUIsYUFBYUcsUUFBYixHQUF3QkosVUFBVUwsTUFBVixDQUR4QjtBQUVSanFCLFlBQU1vcUIsU0FBU00sUUFBVCxHQUFvQkosVUFBVU4sSUFBVixDQUZsQjtBQUdSakgsZUFBUzRIO0FBSEQsS0FBVjtBQUtBLFFBQUlOLE1BQUosRUFBWSxLQUFLN3BCLEdBQUwsSUFBWWdpQixPQUFaLEVBQXFCO0FBQy9CLFVBQUksRUFBRWhpQixPQUFPb2lCLEtBQVQsQ0FBSixFQUFxQlYsU0FBU1UsS0FBVCxFQUFnQnBpQixHQUFoQixFQUFxQmdpQixRQUFRaGlCLEdBQVIsQ0FBckI7QUFDdEIsS0FGRCxNQUVPeWhCLFFBQVFBLFFBQVFvRSxDQUFSLEdBQVlwRSxRQUFRNUQsQ0FBUixJQUFheUwsU0FBU1UsVUFBdEIsQ0FBcEIsRUFBdURqSyxJQUF2RCxFQUE2RGlDLE9BQTdEO0FBQ1I7O0FBQ0QsU0FBT0EsT0FBUDtBQUNELENBbkRELEM7Ozs7Ozs7QUNsQkEsSUFBSXZHLFdBQVcsbUJBQUFqZCxDQUFRLHdDQUFSLEVBQWtCLFVBQWxCLENBQWY7O0FBQ0EsSUFBSTZyQixlQUFlLEtBQW5COztBQUVBLElBQUk7QUFDRixNQUFJQyxRQUFRLENBQUMsQ0FBRCxFQUFJN08sUUFBSixHQUFaOztBQUNBNk8sUUFBTSxRQUFOLElBQWtCLFlBQVk7QUFBRUQsbUJBQWUsSUFBZjtBQUFzQixHQUF0RCxDQUZFLENBR0Y7OztBQUNBbHBCLFFBQU1DLElBQU4sQ0FBV2twQixLQUFYLEVBQWtCLFlBQVk7QUFBRSxVQUFNLENBQU47QUFBVSxHQUExQztBQUNELENBTEQsQ0FLRSxPQUFPN0wsQ0FBUCxFQUFVO0FBQUU7QUFBYTs7QUFFM0J2RSxPQUFPcGIsT0FBUCxHQUFpQixVQUFVeW5CLElBQVYsRUFBZ0JnRSxXQUFoQixFQUE2QjtBQUM1QyxNQUFJLENBQUNBLFdBQUQsSUFBZ0IsQ0FBQ0YsWUFBckIsRUFBbUMsT0FBTyxLQUFQO0FBQ25DLE1BQUlHLE9BQU8sS0FBWDs7QUFDQSxNQUFJO0FBQ0YsUUFBSUMsTUFBTSxDQUFDLENBQUQsQ0FBVjtBQUNBLFFBQUlqUCxPQUFPaVAsSUFBSWhQLFFBQUosR0FBWDs7QUFDQUQsU0FBS3RaLElBQUwsR0FBWSxZQUFZO0FBQUUsYUFBTztBQUFFbW1CLGNBQU1tQyxPQUFPO0FBQWYsT0FBUDtBQUErQixLQUF6RDs7QUFDQUMsUUFBSWhQLFFBQUosSUFBZ0IsWUFBWTtBQUFFLGFBQU9ELElBQVA7QUFBYyxLQUE1Qzs7QUFDQStLLFNBQUtrRSxHQUFMO0FBQ0QsR0FORCxDQU1FLE9BQU9oTSxDQUFQLEVBQVU7QUFBRTtBQUFhOztBQUMzQixTQUFPK0wsSUFBUDtBQUNELENBWEQsQzs7Ozs7OztBQ1ZBdFEsT0FBT3BiLE9BQVAsR0FBaUIsVUFBVXVwQixJQUFWLEVBQWdCdHBCLEtBQWhCLEVBQXVCO0FBQ3RDLFNBQU87QUFBRUEsV0FBT0EsS0FBVDtBQUFnQnNwQixVQUFNLENBQUMsQ0FBQ0E7QUFBeEIsR0FBUDtBQUNELENBRkQsQzs7Ozs7OztBQ0FBbk8sT0FBT3BiLE9BQVAsR0FBaUIsRUFBakIsQzs7Ozs7OztBQ0FBb2IsT0FBT3BiLE9BQVAsR0FBaUIsS0FBakIsQzs7Ozs7OztBQ0FBO0FBQ0EsSUFBSTRyQixTQUFTM2tCLEtBQUs0a0IsS0FBbEI7QUFDQXpRLE9BQU9wYixPQUFQLEdBQWtCLENBQUM0ckIsTUFBRCxDQUNoQjtBQURnQixHQUViQSxPQUFPLEVBQVAsSUFBYSxrQkFGQSxJQUVzQkEsT0FBTyxFQUFQLElBQWEsc0JBRm5DLENBR2hCO0FBSGdCLEdBSWJBLE9BQU8sQ0FBQyxLQUFSLEtBQWtCLENBQUMsS0FKUCxHQUtiLFNBQVNDLEtBQVQsQ0FBZWhvQixDQUFmLEVBQWtCO0FBQ3BCLFNBQU8sQ0FBQ0EsSUFBSSxDQUFDQSxDQUFOLEtBQVksQ0FBWixHQUFnQkEsQ0FBaEIsR0FBb0JBLElBQUksQ0FBQyxJQUFMLElBQWFBLElBQUksSUFBakIsR0FBd0JBLElBQUlBLElBQUlBLENBQUosR0FBUSxDQUFwQyxHQUF3Q29ELEtBQUttZ0IsR0FBTCxDQUFTdmpCLENBQVQsSUFBYyxDQUFqRjtBQUNELENBUGdCLEdBT2IrbkIsTUFQSixDOzs7Ozs7O0FDRkE7QUFDQSxJQUFJbFcsT0FBTyxtQkFBQWhXLENBQVEsOENBQVIsQ0FBWDs7QUFDQSxJQUFJb3NCLE1BQU03a0IsS0FBSzZrQixHQUFmO0FBQ0EsSUFBSUMsVUFBVUQsSUFBSSxDQUFKLEVBQU8sQ0FBQyxFQUFSLENBQWQ7QUFDQSxJQUFJRSxZQUFZRixJQUFJLENBQUosRUFBTyxDQUFDLEVBQVIsQ0FBaEI7QUFDQSxJQUFJRyxRQUFRSCxJQUFJLENBQUosRUFBTyxHQUFQLEtBQWUsSUFBSUUsU0FBbkIsQ0FBWjtBQUNBLElBQUlFLFFBQVFKLElBQUksQ0FBSixFQUFPLENBQUMsR0FBUixDQUFaOztBQUVBLElBQUlLLGtCQUFrQixTQUFsQkEsZUFBa0IsQ0FBVS9nQixDQUFWLEVBQWE7QUFDakMsU0FBT0EsSUFBSSxJQUFJMmdCLE9BQVIsR0FBa0IsSUFBSUEsT0FBN0I7QUFDRCxDQUZEOztBQUlBM1EsT0FBT3BiLE9BQVAsR0FBaUJpSCxLQUFLbWxCLE1BQUwsSUFBZSxTQUFTQSxNQUFULENBQWdCdm9CLENBQWhCLEVBQW1CO0FBQ2pELE1BQUl3b0IsT0FBT3BsQixLQUFLTSxHQUFMLENBQVMxRCxDQUFULENBQVg7QUFDQSxNQUFJeW9CLFFBQVE1VyxLQUFLN1IsQ0FBTCxDQUFaO0FBQ0EsTUFBSTRHLENBQUosRUFBT3pFLE1BQVA7QUFDQSxNQUFJcW1CLE9BQU9ILEtBQVgsRUFBa0IsT0FBT0ksUUFBUUgsZ0JBQWdCRSxPQUFPSCxLQUFQLEdBQWVGLFNBQS9CLENBQVIsR0FBb0RFLEtBQXBELEdBQTRERixTQUFuRTtBQUNsQnZoQixNQUFJLENBQUMsSUFBSXVoQixZQUFZRCxPQUFqQixJQUE0Qk0sSUFBaEM7QUFDQXJtQixXQUFTeUUsS0FBS0EsSUFBSTRoQixJQUFULENBQVQsQ0FOaUQsQ0FPakQ7O0FBQ0EsTUFBSXJtQixTQUFTaW1CLEtBQVQsSUFBa0JqbUIsVUFBVUEsTUFBaEMsRUFBd0MsT0FBT3NtQixRQUFRQyxRQUFmO0FBQ3hDLFNBQU9ELFFBQVF0bUIsTUFBZjtBQUNELENBVkQsQzs7Ozs7OztBQ1pBO0FBQ0FvVixPQUFPcGIsT0FBUCxHQUFpQmlILEtBQUt1bEIsS0FBTCxJQUFjLFNBQVNBLEtBQVQsQ0FBZTNvQixDQUFmLEVBQWtCO0FBQy9DLFNBQU8sQ0FBQ0EsSUFBSSxDQUFDQSxDQUFOLElBQVcsQ0FBQyxJQUFaLElBQW9CQSxJQUFJLElBQXhCLEdBQStCQSxJQUFJQSxJQUFJQSxDQUFKLEdBQVEsQ0FBM0MsR0FBK0NvRCxLQUFLd2xCLEdBQUwsQ0FBUyxJQUFJNW9CLENBQWIsQ0FBdEQ7QUFDRCxDQUZELEM7Ozs7Ozs7QUNEQTtBQUNBdVgsT0FBT3BiLE9BQVAsR0FBaUJpSCxLQUFLMFEsS0FBTCxJQUFjLFNBQVNBLEtBQVQsQ0FBZTlULENBQWYsRUFBa0I2b0IsS0FBbEIsRUFBeUJDLE1BQXpCLEVBQWlDQyxNQUFqQyxFQUF5Q0MsT0FBekMsRUFBa0Q7QUFDL0UsTUFDRXhRLFVBQVUvWSxNQUFWLEtBQXFCLENBQXJCLENBQ0U7QUFERixLQUVLTyxLQUFLQSxDQUZWLENBR0U7QUFIRixLQUlLNm9CLFNBQVNBLEtBSmQsQ0FLRTtBQUxGLEtBTUtDLFVBQVVBLE1BTmYsQ0FPRTtBQVBGLEtBUUtDLFVBQVVBLE1BUmYsQ0FTRTtBQVRGLEtBVUtDLFdBQVdBLE9BWGxCLEVBWUUsT0FBTzdILEdBQVA7QUFDRixNQUFJbmhCLE1BQU0wb0IsUUFBTixJQUFrQjFvQixNQUFNLENBQUMwb0IsUUFBN0IsRUFBdUMsT0FBTzFvQixDQUFQO0FBQ3ZDLFNBQU8sQ0FBQ0EsSUFBSTZvQixLQUFMLEtBQWVHLFVBQVVELE1BQXpCLEtBQW9DRCxTQUFTRCxLQUE3QyxJQUFzREUsTUFBN0Q7QUFDRCxDQWhCRCxDOzs7Ozs7O0FDREE7QUFDQXhSLE9BQU9wYixPQUFQLEdBQWlCaUgsS0FBS3lPLElBQUwsSUFBYSxTQUFTQSxJQUFULENBQWM3UixDQUFkLEVBQWlCO0FBQzdDO0FBQ0EsU0FBTyxDQUFDQSxJQUFJLENBQUNBLENBQU4sS0FBWSxDQUFaLElBQWlCQSxLQUFLQSxDQUF0QixHQUEwQkEsQ0FBMUIsR0FBOEJBLElBQUksQ0FBSixHQUFRLENBQUMsQ0FBVCxHQUFhLENBQWxEO0FBQ0QsQ0FIRCxDOzs7Ozs7O0FDREEsSUFBSWlwQixPQUFPLG1CQUFBcHRCLENBQVEsd0NBQVIsRUFBa0IsTUFBbEIsQ0FBWDs7QUFDQSxJQUFJbWMsV0FBVyxtQkFBQW5jLENBQVEsOENBQVIsQ0FBZjs7QUFDQSxJQUFJaUUsTUFBTSxtQkFBQWpFLENBQVEsd0NBQVIsQ0FBVjs7QUFDQSxJQUFJcXRCLFVBQVUsbUJBQUFydEIsQ0FBUSw4Q0FBUixFQUF3QnFlLENBQXRDOztBQUNBLElBQUl6WixLQUFLLENBQVQ7O0FBQ0EsSUFBSTBvQixlQUFlbHRCLE9BQU9rdEIsWUFBUCxJQUF1QixZQUFZO0FBQ3BELFNBQU8sSUFBUDtBQUNELENBRkQ7O0FBR0EsSUFBSUMsU0FBUyxDQUFDLG1CQUFBdnRCLENBQVEsMENBQVIsRUFBb0IsWUFBWTtBQUM1QyxTQUFPc3RCLGFBQWFsdEIsT0FBT290QixpQkFBUCxDQUF5QixFQUF6QixDQUFiLENBQVA7QUFDRCxDQUZhLENBQWQ7O0FBR0EsSUFBSUMsVUFBVSxTQUFWQSxPQUFVLENBQVU1ckIsRUFBVixFQUFjO0FBQzFCd3JCLFVBQVF4ckIsRUFBUixFQUFZdXJCLElBQVosRUFBa0I7QUFBRTdzQixXQUFPO0FBQ3pCYSxTQUFHLE1BQU0sRUFBRXdELEVBRGM7QUFDVjtBQUNmaUosU0FBRyxFQUZzQixDQUVWOztBQUZVO0FBQVQsR0FBbEI7QUFJRCxDQUxEOztBQU1BLElBQUlnVCxVQUFVLFNBQVZBLE9BQVUsQ0FBVWhmLEVBQVYsRUFBYzhVLE1BQWQsRUFBc0I7QUFDbEM7QUFDQSxNQUFJLENBQUN3RixTQUFTdGEsRUFBVCxDQUFMLEVBQW1CLE9BQU8sT0FBT0EsRUFBUCxJQUFhLFFBQWIsR0FBd0JBLEVBQXhCLEdBQTZCLENBQUMsT0FBT0EsRUFBUCxJQUFhLFFBQWIsR0FBd0IsR0FBeEIsR0FBOEIsR0FBL0IsSUFBc0NBLEVBQTFFOztBQUNuQixNQUFJLENBQUNvQyxJQUFJcEMsRUFBSixFQUFRdXJCLElBQVIsQ0FBTCxFQUFvQjtBQUNsQjtBQUNBLFFBQUksQ0FBQ0UsYUFBYXpyQixFQUFiLENBQUwsRUFBdUIsT0FBTyxHQUFQLENBRkwsQ0FHbEI7O0FBQ0EsUUFBSSxDQUFDOFUsTUFBTCxFQUFhLE9BQU8sR0FBUCxDQUpLLENBS2xCOztBQUNBOFcsWUFBUTVyQixFQUFSLEVBTmtCLENBT3BCO0FBQ0M7O0FBQUMsU0FBT0EsR0FBR3VyQixJQUFILEVBQVNoc0IsQ0FBaEI7QUFDSCxDQVpEOztBQWFBLElBQUlnaEIsVUFBVSxTQUFWQSxPQUFVLENBQVV2Z0IsRUFBVixFQUFjOFUsTUFBZCxFQUFzQjtBQUNsQyxNQUFJLENBQUMxUyxJQUFJcEMsRUFBSixFQUFRdXJCLElBQVIsQ0FBTCxFQUFvQjtBQUNsQjtBQUNBLFFBQUksQ0FBQ0UsYUFBYXpyQixFQUFiLENBQUwsRUFBdUIsT0FBTyxJQUFQLENBRkwsQ0FHbEI7O0FBQ0EsUUFBSSxDQUFDOFUsTUFBTCxFQUFhLE9BQU8sS0FBUCxDQUpLLENBS2xCOztBQUNBOFcsWUFBUTVyQixFQUFSLEVBTmtCLENBT3BCO0FBQ0M7O0FBQUMsU0FBT0EsR0FBR3VyQixJQUFILEVBQVN2ZixDQUFoQjtBQUNILENBVkQsQyxDQVdBOzs7QUFDQSxJQUFJNmYsV0FBVyxTQUFYQSxRQUFXLENBQVU3ckIsRUFBVixFQUFjO0FBQzNCLE1BQUkwckIsVUFBVXBLLEtBQUthLElBQWYsSUFBdUJzSixhQUFhenJCLEVBQWIsQ0FBdkIsSUFBMkMsQ0FBQ29DLElBQUlwQyxFQUFKLEVBQVF1ckIsSUFBUixDQUFoRCxFQUErREssUUFBUTVyQixFQUFSO0FBQy9ELFNBQU9BLEVBQVA7QUFDRCxDQUhEOztBQUlBLElBQUlzaEIsT0FBT3pILE9BQU9wYixPQUFQLEdBQWlCO0FBQzFCd2pCLE9BQUtzSixJQURxQjtBQUUxQnBKLFFBQU0sS0FGb0I7QUFHMUJuRCxXQUFTQSxPQUhpQjtBQUkxQnVCLFdBQVNBLE9BSmlCO0FBSzFCc0wsWUFBVUE7QUFMZ0IsQ0FBNUIsQzs7Ozs7OztBQzlDQSxJQUFJQyxNQUFNLG1CQUFBM3RCLENBQVEsMkNBQVIsQ0FBVjs7QUFDQSxJQUFJaWpCLFVBQVUsbUJBQUFqakIsQ0FBUSwyQ0FBUixDQUFkOztBQUNBLElBQUk0dEIsU0FBUyxtQkFBQTV0QixDQUFRLDJDQUFSLEVBQXFCLFVBQXJCLENBQWI7O0FBQ0EsSUFBSTZpQixRQUFRK0ssT0FBTy9LLEtBQVAsS0FBaUIrSyxPQUFPL0ssS0FBUCxHQUFlLEtBQUssbUJBQUE3aUIsQ0FBUSxnREFBUixDQUFMLEdBQWhDLENBQVo7O0FBRUEsSUFBSTZ0Qix5QkFBeUIsU0FBekJBLHNCQUF5QixDQUFVdlYsTUFBVixFQUFrQndWLFNBQWxCLEVBQTZCblgsTUFBN0IsRUFBcUM7QUFDaEUsTUFBSW9YLGlCQUFpQmxMLE1BQU1oQixHQUFOLENBQVV2SixNQUFWLENBQXJCOztBQUNBLE1BQUksQ0FBQ3lWLGNBQUwsRUFBcUI7QUFDbkIsUUFBSSxDQUFDcFgsTUFBTCxFQUFhLE9BQU8xVCxTQUFQO0FBQ2I0ZixVQUFNQyxHQUFOLENBQVV4SyxNQUFWLEVBQWtCeVYsaUJBQWlCLElBQUlKLEdBQUosRUFBbkM7QUFDRDs7QUFDRCxNQUFJSyxjQUFjRCxlQUFlbE0sR0FBZixDQUFtQmlNLFNBQW5CLENBQWxCOztBQUNBLE1BQUksQ0FBQ0UsV0FBTCxFQUFrQjtBQUNoQixRQUFJLENBQUNyWCxNQUFMLEVBQWEsT0FBTzFULFNBQVA7QUFDYjhxQixtQkFBZWpMLEdBQWYsQ0FBbUJnTCxTQUFuQixFQUE4QkUsY0FBYyxJQUFJTCxHQUFKLEVBQTVDO0FBQ0Q7O0FBQUMsU0FBT0ssV0FBUDtBQUNILENBWEQ7O0FBWUEsSUFBSUMseUJBQXlCLFNBQXpCQSxzQkFBeUIsQ0FBVUMsV0FBVixFQUF1QjFSLENBQXZCLEVBQTBCNkssQ0FBMUIsRUFBNkI7QUFDeEQsTUFBSThHLGNBQWNOLHVCQUF1QnJSLENBQXZCLEVBQTBCNkssQ0FBMUIsRUFBNkIsS0FBN0IsQ0FBbEI7QUFDQSxTQUFPOEcsZ0JBQWdCbHJCLFNBQWhCLEdBQTRCLEtBQTVCLEdBQW9Da3JCLFlBQVlscUIsR0FBWixDQUFnQmlxQixXQUFoQixDQUEzQztBQUNELENBSEQ7O0FBSUEsSUFBSUUseUJBQXlCLFNBQXpCQSxzQkFBeUIsQ0FBVUYsV0FBVixFQUF1QjFSLENBQXZCLEVBQTBCNkssQ0FBMUIsRUFBNkI7QUFDeEQsTUFBSThHLGNBQWNOLHVCQUF1QnJSLENBQXZCLEVBQTBCNkssQ0FBMUIsRUFBNkIsS0FBN0IsQ0FBbEI7QUFDQSxTQUFPOEcsZ0JBQWdCbHJCLFNBQWhCLEdBQTRCQSxTQUE1QixHQUF3Q2tyQixZQUFZdE0sR0FBWixDQUFnQnFNLFdBQWhCLENBQS9DO0FBQ0QsQ0FIRDs7QUFJQSxJQUFJRyw0QkFBNEIsU0FBNUJBLHlCQUE0QixDQUFVSCxXQUFWLEVBQXVCSSxhQUF2QixFQUFzQzlSLENBQXRDLEVBQXlDNkssQ0FBekMsRUFBNEM7QUFDMUV3Ryx5QkFBdUJyUixDQUF2QixFQUEwQjZLLENBQTFCLEVBQTZCLElBQTdCLEVBQW1DdkUsR0FBbkMsQ0FBdUNvTCxXQUF2QyxFQUFvREksYUFBcEQ7QUFDRCxDQUZEOztBQUdBLElBQUlDLDBCQUEwQixTQUExQkEsdUJBQTBCLENBQVVqVyxNQUFWLEVBQWtCd1YsU0FBbEIsRUFBNkI7QUFDekQsTUFBSUssY0FBY04sdUJBQXVCdlYsTUFBdkIsRUFBK0J3VixTQUEvQixFQUEwQyxLQUExQyxDQUFsQjtBQUNBLE1BQUk5c0IsT0FBTyxFQUFYO0FBQ0EsTUFBSW10QixXQUFKLEVBQWlCQSxZQUFZNVYsT0FBWixDQUFvQixVQUFVdUMsQ0FBVixFQUFhdFosR0FBYixFQUFrQjtBQUFFUixTQUFLeUMsSUFBTCxDQUFVakMsR0FBVjtBQUFpQixHQUF6RDtBQUNqQixTQUFPUixJQUFQO0FBQ0QsQ0FMRDs7QUFNQSxJQUFJd3RCLFlBQVksU0FBWkEsU0FBWSxDQUFVM3NCLEVBQVYsRUFBYztBQUM1QixTQUFPQSxPQUFPb0IsU0FBUCxJQUFvQixPQUFPcEIsRUFBUCxJQUFhLFFBQWpDLEdBQTRDQSxFQUE1QyxHQUFpRHltQixPQUFPem1CLEVBQVAsQ0FBeEQ7QUFDRCxDQUZEOztBQUdBLElBQUk2bEIsTUFBTSxTQUFOQSxHQUFNLENBQVVsTCxDQUFWLEVBQWE7QUFDckJ5RyxVQUFRQSxRQUFRa0UsQ0FBaEIsRUFBbUIsU0FBbkIsRUFBOEIzSyxDQUE5QjtBQUNELENBRkQ7O0FBSUFkLE9BQU9wYixPQUFQLEdBQWlCO0FBQ2Z1aUIsU0FBT0EsS0FEUTtBQUVmOWdCLE9BQUs4ckIsc0JBRlU7QUFHZjVwQixPQUFLZ3FCLHNCQUhVO0FBSWZwTSxPQUFLdU0sc0JBSlU7QUFLZnRMLE9BQUt1TCx5QkFMVTtBQU1mcnRCLFFBQU11dEIsdUJBTlM7QUFPZi9zQixPQUFLZ3RCLFNBUFU7QUFRZjlHLE9BQUtBO0FBUlUsQ0FBakIsQzs7Ozs7OztBQ3pDQSxJQUFJem5CLFNBQVMsbUJBQUFELENBQVEsMkNBQVIsQ0FBYjs7QUFDQSxJQUFJeXVCLFlBQVksbUJBQUF6dUIsQ0FBUSx5Q0FBUixFQUFtQjhpQixHQUFuQzs7QUFDQSxJQUFJNEwsV0FBV3p1QixPQUFPMHVCLGdCQUFQLElBQTJCMXVCLE9BQU8ydUIsc0JBQWpEO0FBQ0EsSUFBSXBULFVBQVV2YixPQUFPdWIsT0FBckI7QUFDQSxJQUFJMVcsVUFBVTdFLE9BQU82RSxPQUFyQjtBQUNBLElBQUkrcEIsU0FBUyxtQkFBQTd1QixDQUFRLHdDQUFSLEVBQWtCd2IsT0FBbEIsS0FBOEIsU0FBM0M7O0FBRUFFLE9BQU9wYixPQUFQLEdBQWlCLFlBQVk7QUFDM0IsTUFBSXVDLElBQUosRUFBVUcsSUFBVixFQUFnQjhyQixNQUFoQjs7QUFFQSxNQUFJQyxRQUFRLFNBQVJBLEtBQVEsR0FBWTtBQUN0QixRQUFJQyxNQUFKLEVBQVl0UCxFQUFaO0FBQ0EsUUFBSW1QLFdBQVdHLFNBQVN4VCxRQUFReVQsTUFBNUIsQ0FBSixFQUF5Q0QsT0FBT0UsSUFBUDs7QUFDekMsV0FBT3JzQixJQUFQLEVBQWE7QUFDWDZjLFdBQUs3YyxLQUFLNmMsRUFBVjtBQUNBN2MsYUFBT0EsS0FBS2EsSUFBWjs7QUFDQSxVQUFJO0FBQ0ZnYztBQUNELE9BRkQsQ0FFRSxPQUFPTyxDQUFQLEVBQVU7QUFDVixZQUFJcGQsSUFBSixFQUFVaXNCLFNBQVYsS0FDSzlyQixPQUFPQyxTQUFQO0FBQ0wsY0FBTWdkLENBQU47QUFDRDtBQUNGOztBQUFDamQsV0FBT0MsU0FBUDtBQUNGLFFBQUkrckIsTUFBSixFQUFZQSxPQUFPRyxLQUFQO0FBQ2IsR0FmRCxDQUgyQixDQW9CM0I7OztBQUNBLE1BQUlOLE1BQUosRUFBWTtBQUNWQyxhQUFTLGtCQUFZO0FBQ25CdFQsY0FBUTRULFFBQVIsQ0FBaUJMLEtBQWpCO0FBQ0QsS0FGRCxDQURVLENBSVo7O0FBQ0MsR0FMRCxNQUtPLElBQUlMLFFBQUosRUFBYztBQUNuQixRQUFJVyxTQUFTLElBQWI7QUFDQSxRQUFJQyxPQUFPcFUsU0FBU3FVLGNBQVQsQ0FBd0IsRUFBeEIsQ0FBWDtBQUNBLFFBQUliLFFBQUosQ0FBYUssS0FBYixFQUFvQlMsT0FBcEIsQ0FBNEJGLElBQTVCLEVBQWtDO0FBQUVHLHFCQUFlO0FBQWpCLEtBQWxDLEVBSG1CLENBR3lDOztBQUM1RFgsYUFBUyxrQkFBWTtBQUNuQlEsV0FBSzNOLElBQUwsR0FBWTBOLFNBQVMsQ0FBQ0EsTUFBdEI7QUFDRCxLQUZELENBSm1CLENBT3JCOztBQUNDLEdBUk0sTUFRQSxJQUFJdnFCLFdBQVdBLFFBQVFDLE9BQXZCLEVBQWdDO0FBQ3JDLFFBQUkycUIsVUFBVTVxQixRQUFRQyxPQUFSLEVBQWQ7O0FBQ0ErcEIsYUFBUyxrQkFBWTtBQUNuQlksY0FBUUMsSUFBUixDQUFhWixLQUFiO0FBQ0QsS0FGRCxDQUZxQyxDQUt2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0MsR0FYTSxNQVdBO0FBQ0xELGFBQVMsa0JBQVk7QUFDbkI7QUFDQUwsZ0JBQVU3TyxJQUFWLENBQWUzZixNQUFmLEVBQXVCOHVCLEtBQXZCO0FBQ0QsS0FIRDtBQUlEOztBQUVELFNBQU8sVUFBVXJQLEVBQVYsRUFBYztBQUNuQixRQUFJa1EsT0FBTztBQUFFbFEsVUFBSUEsRUFBTjtBQUFVaGMsWUFBTVQ7QUFBaEIsS0FBWDtBQUNBLFFBQUlELElBQUosRUFBVUEsS0FBS1UsSUFBTCxHQUFZa3NCLElBQVo7O0FBQ1YsUUFBSSxDQUFDL3NCLElBQUwsRUFBVztBQUNUQSxhQUFPK3NCLElBQVA7QUFDQWQ7QUFDRDs7QUFBQzlyQixXQUFPNHNCLElBQVA7QUFDSCxHQVBEO0FBUUQsQ0E1REQsQzs7Ozs7Ozs7Q0NOQTs7QUFDQSxJQUFJcFIsWUFBWSxtQkFBQXhlLENBQVEsK0NBQVIsQ0FBaEI7O0FBRUEsU0FBUzZ2QixpQkFBVCxDQUEyQmhSLENBQTNCLEVBQThCO0FBQzVCLE1BQUk5WixPQUFKLEVBQWEyQixNQUFiO0FBQ0EsT0FBS2dwQixPQUFMLEdBQWUsSUFBSTdRLENBQUosQ0FBTSxVQUFVaVIsU0FBVixFQUFxQkMsUUFBckIsRUFBK0I7QUFDbEQsUUFBSWhyQixZQUFZOUIsU0FBWixJQUF5QnlELFdBQVd6RCxTQUF4QyxFQUFtRCxNQUFNMFksVUFBVSx5QkFBVixDQUFOO0FBQ25ENVcsY0FBVStxQixTQUFWO0FBQ0FwcEIsYUFBU3FwQixRQUFUO0FBQ0QsR0FKYyxDQUFmO0FBS0EsT0FBS2hyQixPQUFMLEdBQWV5WixVQUFVelosT0FBVixDQUFmO0FBQ0EsT0FBSzJCLE1BQUwsR0FBYzhYLFVBQVU5WCxNQUFWLENBQWQ7QUFDRDs7QUFFRGdWLE9BQU9wYixPQUFQLENBQWUrZCxDQUFmLEdBQW1CLFVBQVVRLENBQVYsRUFBYTtBQUM5QixTQUFPLElBQUlnUixpQkFBSixDQUFzQmhSLENBQXRCLENBQVA7QUFDRCxDQUZELEM7Ozs7Ozs7O0NDZEE7O0FBQ0EsSUFBSTBILFVBQVUsbUJBQUF2bUIsQ0FBUSxnREFBUixDQUFkOztBQUNBLElBQUl3bUIsT0FBTyxtQkFBQXhtQixDQUFRLGdEQUFSLENBQVg7O0FBQ0EsSUFBSXltQixNQUFNLG1CQUFBem1CLENBQVEsK0NBQVIsQ0FBVjs7QUFDQSxJQUFJb2MsV0FBVyxtQkFBQXBjLENBQVEsOENBQVIsQ0FBZjs7QUFDQSxJQUFJd2QsVUFBVSxtQkFBQXhkLENBQVEsNENBQVIsQ0FBZDs7QUFDQSxJQUFJZ3dCLFVBQVU1dkIsT0FBT29KLE1BQXJCLEMsQ0FFQTs7QUFDQWtTLE9BQU9wYixPQUFQLEdBQWlCLENBQUMwdkIsT0FBRCxJQUFZLG1CQUFBaHdCLENBQVEsMENBQVIsRUFBb0IsWUFBWTtBQUMzRCxNQUFJaXdCLElBQUksRUFBUjtBQUNBLE1BQUk5UCxJQUFJLEVBQVIsQ0FGMkQsQ0FHM0Q7O0FBQ0EsTUFBSWdILElBQUkrSSxRQUFSO0FBQ0EsTUFBSUMsSUFBSSxzQkFBUjtBQUNBRixJQUFFOUksQ0FBRixJQUFPLENBQVA7QUFDQWdKLElBQUU3SixLQUFGLENBQVEsRUFBUixFQUFZL04sT0FBWixDQUFvQixVQUFVNkksQ0FBVixFQUFhO0FBQUVqQixNQUFFaUIsQ0FBRixJQUFPQSxDQUFQO0FBQVcsR0FBOUM7QUFDQSxTQUFPNE8sUUFBUSxFQUFSLEVBQVlDLENBQVosRUFBZTlJLENBQWYsS0FBcUIsQ0FBckIsSUFBMEIvbUIsT0FBT1ksSUFBUCxDQUFZZ3ZCLFFBQVEsRUFBUixFQUFZN1AsQ0FBWixDQUFaLEVBQTRCWCxJQUE1QixDQUFpQyxFQUFqQyxLQUF3QzJRLENBQXpFO0FBQ0QsQ0FUNEIsQ0FBWixHQVNaLFNBQVMzbUIsTUFBVCxDQUFnQjhPLE1BQWhCLEVBQXdCeU8sTUFBeEIsRUFBZ0M7QUFBRTtBQUNyQyxNQUFJN0csSUFBSTlELFNBQVM5RCxNQUFULENBQVI7QUFDQSxNQUFJdUUsT0FBT0YsVUFBVS9ZLE1BQXJCO0FBQ0EsTUFBSTlCLFFBQVEsQ0FBWjtBQUNBLE1BQUk0a0IsYUFBYUYsS0FBS25JLENBQXRCO0FBQ0EsTUFBSXVJLFNBQVNILElBQUlwSSxDQUFqQjs7QUFDQSxTQUFPeEIsT0FBTy9hLEtBQWQsRUFBcUI7QUFDbkIsUUFBSXFsQixJQUFJM0osUUFBUWIsVUFBVTdhLE9BQVYsQ0FBUixDQUFSO0FBQ0EsUUFBSWQsT0FBTzBsQixhQUFhSCxRQUFRWSxDQUFSLEVBQVdwbUIsTUFBWCxDQUFrQjJsQixXQUFXUyxDQUFYLENBQWxCLENBQWIsR0FBZ0RaLFFBQVFZLENBQVIsQ0FBM0Q7QUFDQSxRQUFJdmpCLFNBQVM1QyxLQUFLNEMsTUFBbEI7QUFDQSxRQUFJd3NCLElBQUksQ0FBUjtBQUNBLFFBQUk1dUIsR0FBSjs7QUFDQSxXQUFPb0MsU0FBU3dzQixDQUFoQjtBQUFtQixVQUFJeEosT0FBT2hILElBQVAsQ0FBWXVILENBQVosRUFBZTNsQixNQUFNUixLQUFLb3ZCLEdBQUwsQ0FBckIsQ0FBSixFQUFxQ2xRLEVBQUUxZSxHQUFGLElBQVMybEIsRUFBRTNsQixHQUFGLENBQVQ7QUFBeEQ7QUFDRDs7QUFBQyxTQUFPMGUsQ0FBUDtBQUNILENBdkJnQixHQXVCYjhQLE9BdkJKLEM7Ozs7Ozs7QUNWQTtBQUNBLElBQUkzTixXQUFXLG1CQUFBcmlCLENBQVEsOENBQVIsQ0FBZjs7QUFDQSxJQUFJcXdCLE1BQU0sbUJBQUFyd0IsQ0FBUSwrQ0FBUixDQUFWOztBQUNBLElBQUlzd0IsY0FBYyxtQkFBQXR3QixDQUFRLGtEQUFSLENBQWxCOztBQUNBLElBQUl1d0IsV0FBVyxtQkFBQXZ3QixDQUFRLCtDQUFSLEVBQXlCLFVBQXpCLENBQWY7O0FBQ0EsSUFBSXd3QixRQUFRLFNBQVJBLEtBQVEsR0FBWTtBQUFFO0FBQWEsQ0FBdkM7O0FBQ0EsSUFBSTFKLFlBQVksV0FBaEIsQyxDQUVBOztBQUNBLElBQUkySixjQUFhLHNCQUFZO0FBQzNCO0FBQ0EsTUFBSUMsU0FBUyxtQkFBQTF3QixDQUFRLCtDQUFSLEVBQXlCLFFBQXpCLENBQWI7O0FBQ0EsTUFBSW9CLElBQUlrdkIsWUFBWTFzQixNQUFwQjtBQUNBLE1BQUkrc0IsS0FBSyxHQUFUO0FBQ0EsTUFBSUMsS0FBSyxHQUFUO0FBQ0EsTUFBSUMsY0FBSjtBQUNBSCxTQUFPSSxLQUFQLENBQWFDLE9BQWIsR0FBdUIsTUFBdkI7O0FBQ0Evd0IsRUFBQSxtQkFBQUEsQ0FBUSx5Q0FBUixFQUFtQmd4QixXQUFuQixDQUErQk4sTUFBL0I7O0FBQ0FBLFNBQU90ckIsR0FBUCxHQUFhLGFBQWIsQ0FUMkIsQ0FTQztBQUM1QjtBQUNBOztBQUNBeXJCLG1CQUFpQkgsT0FBT08sYUFBUCxDQUFxQi9WLFFBQXRDO0FBQ0EyVixpQkFBZUssSUFBZjtBQUNBTCxpQkFBZU0sS0FBZixDQUFxQlIsS0FBSyxRQUFMLEdBQWdCQyxFQUFoQixHQUFxQixtQkFBckIsR0FBMkNELEVBQTNDLEdBQWdELFNBQWhELEdBQTREQyxFQUFqRjtBQUNBQyxpQkFBZU8sS0FBZjtBQUNBWCxnQkFBYUksZUFBZXhSLENBQTVCOztBQUNBLFNBQU9qZSxHQUFQO0FBQVksV0FBT3F2QixZQUFXM0osU0FBWCxFQUFzQndKLFlBQVlsdkIsQ0FBWixDQUF0QixDQUFQO0FBQVo7O0FBQ0EsU0FBT3F2QixhQUFQO0FBQ0QsQ0FuQkQ7O0FBcUJBL1UsT0FBT3BiLE9BQVAsR0FBaUJGLE9BQU91VyxNQUFQLElBQWlCLFNBQVNBLE1BQVQsQ0FBZ0I2RixDQUFoQixFQUFtQjZVLFVBQW5CLEVBQStCO0FBQy9ELE1BQUkvcUIsTUFBSjs7QUFDQSxNQUFJa1csTUFBTSxJQUFWLEVBQWdCO0FBQ2RnVSxVQUFNMUosU0FBTixJQUFtQnpFLFNBQVM3RixDQUFULENBQW5CO0FBQ0FsVyxhQUFTLElBQUlrcUIsS0FBSixFQUFUO0FBQ0FBLFVBQU0xSixTQUFOLElBQW1CLElBQW5CLENBSGMsQ0FJZDs7QUFDQXhnQixXQUFPaXFCLFFBQVAsSUFBbUIvVCxDQUFuQjtBQUNELEdBTkQsTUFNT2xXLFNBQVNtcUIsYUFBVDs7QUFDUCxTQUFPWSxlQUFlcHVCLFNBQWYsR0FBMkJxRCxNQUEzQixHQUFvQytwQixJQUFJL3BCLE1BQUosRUFBWStxQixVQUFaLENBQTNDO0FBQ0QsQ0FWRCxDOzs7Ozs7O0FDOUJBLElBQUloUCxXQUFXLG1CQUFBcmlCLENBQVEsOENBQVIsQ0FBZjs7QUFDQSxJQUFJc3hCLGlCQUFpQixtQkFBQXR4QixDQUFRLG1EQUFSLENBQXJCOztBQUNBLElBQUltbUIsY0FBYyxtQkFBQW5tQixDQUFRLGlEQUFSLENBQWxCOztBQUNBLElBQUlzZ0IsS0FBS2xnQixPQUFPQyxjQUFoQjtBQUVBQyxRQUFRK2QsQ0FBUixHQUFZLG1CQUFBcmUsQ0FBUSxnREFBUixJQUE0QkksT0FBT0MsY0FBbkMsR0FBb0QsU0FBU0EsY0FBVCxDQUF3Qm1jLENBQXhCLEVBQTJCNkssQ0FBM0IsRUFBOEJrSyxVQUE5QixFQUEwQztBQUN4R2xQLFdBQVM3RixDQUFUO0FBQ0E2SyxNQUFJbEIsWUFBWWtCLENBQVosRUFBZSxJQUFmLENBQUo7QUFDQWhGLFdBQVNrUCxVQUFUO0FBQ0EsTUFBSUQsY0FBSixFQUFvQixJQUFJO0FBQ3RCLFdBQU9oUixHQUFHOUQsQ0FBSCxFQUFNNkssQ0FBTixFQUFTa0ssVUFBVCxDQUFQO0FBQ0QsR0FGbUIsQ0FFbEIsT0FBT3RSLENBQVAsRUFBVTtBQUFFO0FBQWE7QUFDM0IsTUFBSSxTQUFTc1IsVUFBVCxJQUF1QixTQUFTQSxVQUFwQyxFQUFnRCxNQUFNNVYsVUFBVSwwQkFBVixDQUFOO0FBQ2hELE1BQUksV0FBVzRWLFVBQWYsRUFBMkIvVSxFQUFFNkssQ0FBRixJQUFPa0ssV0FBV2h4QixLQUFsQjtBQUMzQixTQUFPaWMsQ0FBUDtBQUNELENBVkQsQzs7Ozs7OztBQ0xBLElBQUk4RCxLQUFLLG1CQUFBdGdCLENBQVEsOENBQVIsQ0FBVDs7QUFDQSxJQUFJcWlCLFdBQVcsbUJBQUFyaUIsQ0FBUSw4Q0FBUixDQUFmOztBQUNBLElBQUl1bUIsVUFBVSxtQkFBQXZtQixDQUFRLGdEQUFSLENBQWQ7O0FBRUEwYixPQUFPcGIsT0FBUCxHQUFpQixtQkFBQU4sQ0FBUSxnREFBUixJQUE0QkksT0FBT294QixnQkFBbkMsR0FBc0QsU0FBU0EsZ0JBQVQsQ0FBMEJoVixDQUExQixFQUE2QjZVLFVBQTdCLEVBQXlDO0FBQzlHaFAsV0FBUzdGLENBQVQ7QUFDQSxNQUFJeGIsT0FBT3VsQixRQUFROEssVUFBUixDQUFYO0FBQ0EsTUFBSXp0QixTQUFTNUMsS0FBSzRDLE1BQWxCO0FBQ0EsTUFBSXhDLElBQUksQ0FBUjtBQUNBLE1BQUlpbUIsQ0FBSjs7QUFDQSxTQUFPempCLFNBQVN4QyxDQUFoQjtBQUFtQmtmLE9BQUdqQyxDQUFILENBQUs3QixDQUFMLEVBQVE2SyxJQUFJcm1CLEtBQUtJLEdBQUwsQ0FBWixFQUF1Qml3QixXQUFXaEssQ0FBWCxDQUF2QjtBQUFuQjs7QUFDQSxTQUFPN0ssQ0FBUDtBQUNELENBUkQsQzs7Ozs7Ozs7Q0NIQTs7QUFDQWQsT0FBT3BiLE9BQVAsR0FBaUIsbUJBQUFOLENBQVEsNENBQVIsS0FBeUIsQ0FBQyxtQkFBQUEsQ0FBUSwwQ0FBUixFQUFvQixZQUFZO0FBQ3pFLE1BQUltd0IsSUFBSTVvQixLQUFLa3FCLE1BQUwsRUFBUixDQUR5RSxDQUV6RTtBQUNBOztBQUNBQyxtQkFBaUI5UixJQUFqQixDQUFzQixJQUF0QixFQUE0QnVRLENBQTVCLEVBQStCLFlBQVk7QUFBRTtBQUFhLEdBQTFEOztBQUNBLFNBQU8sbUJBQUFud0IsQ0FBUSwyQ0FBUixFQUFxQm13QixDQUFyQixDQUFQO0FBQ0QsQ0FOMEMsQ0FBM0MsQzs7Ozs7OztBQ0ZBLElBQUkxSixNQUFNLG1CQUFBem1CLENBQVEsK0NBQVIsQ0FBVjs7QUFDQSxJQUFJNmtCLGFBQWEsbUJBQUE3a0IsQ0FBUSxrREFBUixDQUFqQjs7QUFDQSxJQUFJa2QsWUFBWSxtQkFBQWxkLENBQVEsK0NBQVIsQ0FBaEI7O0FBQ0EsSUFBSW1tQixjQUFjLG1CQUFBbm1CLENBQVEsaURBQVIsQ0FBbEI7O0FBQ0EsSUFBSWlFLE1BQU0sbUJBQUFqRSxDQUFRLHdDQUFSLENBQVY7O0FBQ0EsSUFBSXN4QixpQkFBaUIsbUJBQUF0eEIsQ0FBUSxtREFBUixDQUFyQjs7QUFDQSxJQUFJMnhCLE9BQU92eEIsT0FBT3d4Qix3QkFBbEI7QUFFQXR4QixRQUFRK2QsQ0FBUixHQUFZLG1CQUFBcmUsQ0FBUSxnREFBUixJQUE0QjJ4QixJQUE1QixHQUFtQyxTQUFTQyx3QkFBVCxDQUFrQ3BWLENBQWxDLEVBQXFDNkssQ0FBckMsRUFBd0M7QUFDckY3SyxNQUFJVSxVQUFVVixDQUFWLENBQUo7QUFDQTZLLE1BQUlsQixZQUFZa0IsQ0FBWixFQUFlLElBQWYsQ0FBSjtBQUNBLE1BQUlpSyxjQUFKLEVBQW9CLElBQUk7QUFDdEIsV0FBT0ssS0FBS25WLENBQUwsRUFBUTZLLENBQVIsQ0FBUDtBQUNELEdBRm1CLENBRWxCLE9BQU9wSCxDQUFQLEVBQVU7QUFBRTtBQUFhO0FBQzNCLE1BQUloYyxJQUFJdVksQ0FBSixFQUFPNkssQ0FBUCxDQUFKLEVBQWUsT0FBT3hDLFdBQVcsQ0FBQzRCLElBQUlwSSxDQUFKLENBQU11QixJQUFOLENBQVdwRCxDQUFYLEVBQWM2SyxDQUFkLENBQVosRUFBOEI3SyxFQUFFNkssQ0FBRixDQUE5QixDQUFQO0FBQ2hCLENBUEQsQzs7Ozs7OztBQ1JBO0FBQ0EsSUFBSW5LLFlBQVksbUJBQUFsZCxDQUFRLCtDQUFSLENBQWhCOztBQUNBLElBQUk2eEIsT0FBTyxtQkFBQTd4QixDQUFRLGdEQUFSLEVBQTBCcWUsQ0FBckM7O0FBQ0EsSUFBSWdDLFdBQVcsR0FBR0EsUUFBbEI7QUFFQSxJQUFJeVIsY0FBYyxPQUFPeFcsTUFBUCxJQUFpQixRQUFqQixJQUE2QkEsTUFBN0IsSUFBdUNsYixPQUFPMnhCLG1CQUE5QyxHQUNkM3hCLE9BQU8yeEIsbUJBQVAsQ0FBMkJ6VyxNQUEzQixDQURjLEdBQ3VCLEVBRHpDOztBQUdBLElBQUkwVyxpQkFBaUIsU0FBakJBLGNBQWlCLENBQVVud0IsRUFBVixFQUFjO0FBQ2pDLE1BQUk7QUFDRixXQUFPZ3dCLEtBQUtod0IsRUFBTCxDQUFQO0FBQ0QsR0FGRCxDQUVFLE9BQU9vZSxDQUFQLEVBQVU7QUFDVixXQUFPNlIsWUFBWTVTLEtBQVosRUFBUDtBQUNEO0FBQ0YsQ0FORDs7QUFRQXhELE9BQU9wYixPQUFQLENBQWUrZCxDQUFmLEdBQW1CLFNBQVMwVCxtQkFBVCxDQUE2Qmx3QixFQUE3QixFQUFpQztBQUNsRCxTQUFPaXdCLGVBQWV6UixTQUFTVCxJQUFULENBQWMvZCxFQUFkLEtBQXFCLGlCQUFwQyxHQUF3RG13QixlQUFlbndCLEVBQWYsQ0FBeEQsR0FBNkVnd0IsS0FBSzNVLFVBQVVyYixFQUFWLENBQUwsQ0FBcEY7QUFDRCxDQUZELEM7Ozs7Ozs7QUNoQkE7QUFDQSxJQUFJb3dCLFFBQVEsbUJBQUFqeUIsQ0FBUSx5REFBUixDQUFaOztBQUNBLElBQUlreUIsYUFBYSxtQkFBQWx5QixDQUFRLGtEQUFSLEVBQTRCZSxNQUE1QixDQUFtQyxRQUFuQyxFQUE2QyxXQUE3QyxDQUFqQjs7QUFFQVQsUUFBUStkLENBQVIsR0FBWWplLE9BQU8yeEIsbUJBQVAsSUFBOEIsU0FBU0EsbUJBQVQsQ0FBNkJ2VixDQUE3QixFQUFnQztBQUN4RSxTQUFPeVYsTUFBTXpWLENBQU4sRUFBUzBWLFVBQVQsQ0FBUDtBQUNELENBRkQsQzs7Ozs7OztBQ0pBNXhCLFFBQVErZCxDQUFSLEdBQVlqZSxPQUFPK3hCLHFCQUFuQixDOzs7Ozs7O0FDQUE7QUFDQSxJQUFJbHVCLE1BQU0sbUJBQUFqRSxDQUFRLHdDQUFSLENBQVY7O0FBQ0EsSUFBSW9jLFdBQVcsbUJBQUFwYyxDQUFRLDhDQUFSLENBQWY7O0FBQ0EsSUFBSXV3QixXQUFXLG1CQUFBdndCLENBQVEsK0NBQVIsRUFBeUIsVUFBekIsQ0FBZjs7QUFDQSxJQUFJb3lCLGNBQWNoeUIsT0FBTzRiLFNBQXpCOztBQUVBTixPQUFPcGIsT0FBUCxHQUFpQkYsT0FBT3lxQixjQUFQLElBQXlCLFVBQVVyTyxDQUFWLEVBQWE7QUFDckRBLE1BQUlKLFNBQVNJLENBQVQsQ0FBSjtBQUNBLE1BQUl2WSxJQUFJdVksQ0FBSixFQUFPK1QsUUFBUCxDQUFKLEVBQXNCLE9BQU8vVCxFQUFFK1QsUUFBRixDQUFQOztBQUN0QixNQUFJLE9BQU8vVCxFQUFFc0MsV0FBVCxJQUF3QixVQUF4QixJQUFzQ3RDLGFBQWFBLEVBQUVzQyxXQUF6RCxFQUFzRTtBQUNwRSxXQUFPdEMsRUFBRXNDLFdBQUYsQ0FBYzlDLFNBQXJCO0FBQ0Q7O0FBQUMsU0FBT1EsYUFBYXBjLE1BQWIsR0FBc0JneUIsV0FBdEIsR0FBb0MsSUFBM0M7QUFDSCxDQU5ELEM7Ozs7Ozs7QUNOQSxJQUFJbnVCLE1BQU0sbUJBQUFqRSxDQUFRLHdDQUFSLENBQVY7O0FBQ0EsSUFBSWtkLFlBQVksbUJBQUFsZCxDQUFRLCtDQUFSLENBQWhCOztBQUNBLElBQUlxeUIsZUFBZSxtQkFBQXJ5QixDQUFRLG1EQUFSLEVBQTZCLEtBQTdCLENBQW5COztBQUNBLElBQUl1d0IsV0FBVyxtQkFBQXZ3QixDQUFRLCtDQUFSLEVBQXlCLFVBQXpCLENBQWY7O0FBRUEwYixPQUFPcGIsT0FBUCxHQUFpQixVQUFVd2tCLE1BQVYsRUFBa0J3TixLQUFsQixFQUF5QjtBQUN4QyxNQUFJOVYsSUFBSVUsVUFBVTRILE1BQVYsQ0FBUjtBQUNBLE1BQUkxakIsSUFBSSxDQUFSO0FBQ0EsTUFBSWtGLFNBQVMsRUFBYjtBQUNBLE1BQUk5RSxHQUFKOztBQUNBLE9BQUtBLEdBQUwsSUFBWWdiLENBQVo7QUFBZSxRQUFJaGIsT0FBTyt1QixRQUFYLEVBQXFCdHNCLElBQUl1WSxDQUFKLEVBQU9oYixHQUFQLEtBQWU4RSxPQUFPN0MsSUFBUCxDQUFZakMsR0FBWixDQUFmO0FBQXBDLEdBTHdDLENBTXhDOzs7QUFDQSxTQUFPOHdCLE1BQU0xdUIsTUFBTixHQUFleEMsQ0FBdEI7QUFBeUIsUUFBSTZDLElBQUl1WSxDQUFKLEVBQU9oYixNQUFNOHdCLE1BQU1seEIsR0FBTixDQUFiLENBQUosRUFBOEI7QUFDckQsT0FBQ2l4QixhQUFhL3JCLE1BQWIsRUFBcUI5RSxHQUFyQixDQUFELElBQThCOEUsT0FBTzdDLElBQVAsQ0FBWWpDLEdBQVosQ0FBOUI7QUFDRDtBQUZEOztBQUdBLFNBQU84RSxNQUFQO0FBQ0QsQ0FYRCxDOzs7Ozs7O0FDTEE7QUFDQSxJQUFJMnJCLFFBQVEsbUJBQUFqeUIsQ0FBUSx5REFBUixDQUFaOztBQUNBLElBQUlzd0IsY0FBYyxtQkFBQXR3QixDQUFRLGtEQUFSLENBQWxCOztBQUVBMGIsT0FBT3BiLE9BQVAsR0FBaUJGLE9BQU9ZLElBQVAsSUFBZSxTQUFTQSxJQUFULENBQWN3YixDQUFkLEVBQWlCO0FBQy9DLFNBQU95VixNQUFNelYsQ0FBTixFQUFTOFQsV0FBVCxDQUFQO0FBQ0QsQ0FGRCxDOzs7Ozs7O0FDSkFod0IsUUFBUStkLENBQVIsR0FBWSxHQUFHOEwsb0JBQWYsQzs7Ozs7OztBQ0FBO0FBQ0EsSUFBSWxILFVBQVUsbUJBQUFqakIsQ0FBUSwyQ0FBUixDQUFkOztBQUNBLElBQUl5a0IsT0FBTyxtQkFBQXprQixDQUFRLHlDQUFSLENBQVg7O0FBQ0EsSUFBSW9qQixRQUFRLG1CQUFBcGpCLENBQVEsMENBQVIsQ0FBWjs7QUFDQTBiLE9BQU9wYixPQUFQLEdBQWlCLFVBQVV3akIsR0FBVixFQUFlaUUsSUFBZixFQUFxQjtBQUNwQyxNQUFJckksS0FBSyxDQUFDK0UsS0FBS3JrQixNQUFMLElBQWUsRUFBaEIsRUFBb0IwakIsR0FBcEIsS0FBNEIxakIsT0FBTzBqQixHQUFQLENBQXJDO0FBQ0EsTUFBSTRELE1BQU0sRUFBVjtBQUNBQSxNQUFJNUQsR0FBSixJQUFXaUUsS0FBS3JJLEVBQUwsQ0FBWDtBQUNBdUQsVUFBUUEsUUFBUWtFLENBQVIsR0FBWWxFLFFBQVE1RCxDQUFSLEdBQVkrRCxNQUFNLFlBQVk7QUFBRTFELE9BQUcsQ0FBSDtBQUFRLEdBQTVCLENBQWhDLEVBQStELFFBQS9ELEVBQXlFZ0ksR0FBekU7QUFDRCxDQUxELEM7Ozs7Ozs7QUNKQSxJQUFJbkIsVUFBVSxtQkFBQXZtQixDQUFRLGdEQUFSLENBQWQ7O0FBQ0EsSUFBSWtkLFlBQVksbUJBQUFsZCxDQUFRLCtDQUFSLENBQWhCOztBQUNBLElBQUk0bUIsU0FBUyxtQkFBQTVtQixDQUFRLCtDQUFSLEVBQXlCcWUsQ0FBdEM7O0FBQ0EzQyxPQUFPcGIsT0FBUCxHQUFpQixVQUFVaXlCLFNBQVYsRUFBcUI7QUFDcEMsU0FBTyxVQUFVMXdCLEVBQVYsRUFBYztBQUNuQixRQUFJMmEsSUFBSVUsVUFBVXJiLEVBQVYsQ0FBUjtBQUNBLFFBQUliLE9BQU91bEIsUUFBUS9KLENBQVIsQ0FBWDtBQUNBLFFBQUk1WSxTQUFTNUMsS0FBSzRDLE1BQWxCO0FBQ0EsUUFBSXhDLElBQUksQ0FBUjtBQUNBLFFBQUlrRixTQUFTLEVBQWI7QUFDQSxRQUFJOUUsR0FBSjs7QUFDQSxXQUFPb0MsU0FBU3hDLENBQWhCO0FBQW1CLFVBQUl3bEIsT0FBT2hILElBQVAsQ0FBWXBELENBQVosRUFBZWhiLE1BQU1SLEtBQUtJLEdBQUwsQ0FBckIsQ0FBSixFQUFxQztBQUN0RGtGLGVBQU83QyxJQUFQLENBQVk4dUIsWUFBWSxDQUFDL3dCLEdBQUQsRUFBTWdiLEVBQUVoYixHQUFGLENBQU4sQ0FBWixHQUE0QmdiLEVBQUVoYixHQUFGLENBQXhDO0FBQ0Q7QUFGRDs7QUFFRSxXQUFPOEUsTUFBUDtBQUNILEdBVkQ7QUFXRCxDQVpELEM7Ozs7Ozs7QUNIQTtBQUNBLElBQUl1ckIsT0FBTyxtQkFBQTd4QixDQUFRLGdEQUFSLENBQVg7O0FBQ0EsSUFBSXdtQixPQUFPLG1CQUFBeG1CLENBQVEsZ0RBQVIsQ0FBWDs7QUFDQSxJQUFJcWlCLFdBQVcsbUJBQUFyaUIsQ0FBUSw4Q0FBUixDQUFmOztBQUNBLElBQUl3eUIsVUFBVSxtQkFBQXh5QixDQUFRLDJDQUFSLEVBQXFCd3lCLE9BQW5DOztBQUNBOVcsT0FBT3BiLE9BQVAsR0FBaUJreUIsV0FBV0EsUUFBUUMsT0FBbkIsSUFBOEIsU0FBU0EsT0FBVCxDQUFpQjV3QixFQUFqQixFQUFxQjtBQUNsRSxNQUFJYixPQUFPNndCLEtBQUt4VCxDQUFMLENBQU9nRSxTQUFTeGdCLEVBQVQsQ0FBUCxDQUFYO0FBQ0EsTUFBSTZrQixhQUFhRixLQUFLbkksQ0FBdEI7QUFDQSxTQUFPcUksYUFBYTFsQixLQUFLRCxNQUFMLENBQVkybEIsV0FBVzdrQixFQUFYLENBQVosQ0FBYixHQUEyQ2IsSUFBbEQ7QUFDRCxDQUpELEM7Ozs7Ozs7QUNMQSxJQUFJMHhCLGNBQWMsbUJBQUExeUIsQ0FBUSwyQ0FBUixFQUFxQjJ5QixVQUF2Qzs7QUFDQSxJQUFJQyxRQUFRLG1CQUFBNXlCLENBQVEsZ0RBQVIsRUFBMEI2eUIsSUFBdEM7O0FBRUFuWCxPQUFPcGIsT0FBUCxHQUFpQixJQUFJb3lCLFlBQVksbUJBQUExeUIsQ0FBUSw4Q0FBUixJQUEwQixJQUF0QyxDQUFKLEtBQW9ELENBQUM2c0IsUUFBckQsR0FBZ0UsU0FBUzhGLFVBQVQsQ0FBb0JHLEdBQXBCLEVBQXlCO0FBQ3hHLE1BQUl0SyxTQUFTb0ssTUFBTXRLLE9BQU93SyxHQUFQLENBQU4sRUFBbUIsQ0FBbkIsQ0FBYjtBQUNBLE1BQUl4c0IsU0FBU29zQixZQUFZbEssTUFBWixDQUFiO0FBQ0EsU0FBT2xpQixXQUFXLENBQVgsSUFBZ0JraUIsT0FBT3VLLE1BQVAsQ0FBYyxDQUFkLEtBQW9CLEdBQXBDLEdBQTBDLENBQUMsQ0FBM0MsR0FBK0N6c0IsTUFBdEQ7QUFDRCxDQUpnQixHQUlib3NCLFdBSkosQzs7Ozs7OztBQ0hBLElBQUlNLFlBQVksbUJBQUFoekIsQ0FBUSwyQ0FBUixFQUFxQml6QixRQUFyQzs7QUFDQSxJQUFJTCxRQUFRLG1CQUFBNXlCLENBQVEsZ0RBQVIsRUFBMEI2eUIsSUFBdEM7O0FBQ0EsSUFBSUssS0FBSyxtQkFBQWx6QixDQUFRLDhDQUFSLENBQVQ7O0FBQ0EsSUFBSW16QixNQUFNLGFBQVY7QUFFQXpYLE9BQU9wYixPQUFQLEdBQWlCMHlCLFVBQVVFLEtBQUssSUFBZixNQUF5QixDQUF6QixJQUE4QkYsVUFBVUUsS0FBSyxNQUFmLE1BQTJCLEVBQXpELEdBQThELFNBQVNELFFBQVQsQ0FBa0JILEdBQWxCLEVBQXVCTSxLQUF2QixFQUE4QjtBQUMzRyxNQUFJNUssU0FBU29LLE1BQU10SyxPQUFPd0ssR0FBUCxDQUFOLEVBQW1CLENBQW5CLENBQWI7QUFDQSxTQUFPRSxVQUFVeEssTUFBVixFQUFtQjRLLFVBQVUsQ0FBWCxLQUFrQkQsSUFBSUUsSUFBSixDQUFTN0ssTUFBVCxJQUFtQixFQUFuQixHQUF3QixFQUExQyxDQUFsQixDQUFQO0FBQ0QsQ0FIZ0IsR0FHYndLLFNBSEosQzs7Ozs7OztBQ0xBdFgsT0FBT3BiLE9BQVAsR0FBaUIsVUFBVXluQixJQUFWLEVBQWdCO0FBQy9CLE1BQUk7QUFDRixXQUFPO0FBQUU5SCxTQUFHLEtBQUw7QUFBWXJTLFNBQUdtYTtBQUFmLEtBQVA7QUFDRCxHQUZELENBRUUsT0FBTzlILENBQVAsRUFBVTtBQUNWLFdBQU87QUFBRUEsU0FBRyxJQUFMO0FBQVdyUyxTQUFHcVM7QUFBZCxLQUFQO0FBQ0Q7QUFDRixDQU5ELEM7Ozs7Ozs7QUNBQSxJQUFJb0MsV0FBVyxtQkFBQXJpQixDQUFRLDhDQUFSLENBQWY7O0FBQ0EsSUFBSW1jLFdBQVcsbUJBQUFuYyxDQUFRLDhDQUFSLENBQWY7O0FBQ0EsSUFBSXN6Qix1QkFBdUIsbUJBQUF0ekIsQ0FBUSwyREFBUixDQUEzQjs7QUFFQTBiLE9BQU9wYixPQUFQLEdBQWlCLFVBQVV1ZSxDQUFWLEVBQWExYSxDQUFiLEVBQWdCO0FBQy9Ca2UsV0FBU3hELENBQVQ7QUFDQSxNQUFJMUMsU0FBU2hZLENBQVQsS0FBZUEsRUFBRTJhLFdBQUYsS0FBa0JELENBQXJDLEVBQXdDLE9BQU8xYSxDQUFQO0FBQ3hDLE1BQUlvdkIsb0JBQW9CRCxxQkFBcUJqVixDQUFyQixDQUF1QlEsQ0FBdkIsQ0FBeEI7QUFDQSxNQUFJOVosVUFBVXd1QixrQkFBa0J4dUIsT0FBaEM7QUFDQUEsVUFBUVosQ0FBUjtBQUNBLFNBQU9vdkIsa0JBQWtCN0QsT0FBekI7QUFDRCxDQVBELEM7Ozs7Ozs7QUNKQWhVLE9BQU9wYixPQUFQLEdBQWlCLFVBQVVrekIsTUFBVixFQUFrQmp6QixLQUFsQixFQUF5QjtBQUN4QyxTQUFPO0FBQ0xrekIsZ0JBQVksRUFBRUQsU0FBUyxDQUFYLENBRFA7QUFFTEUsa0JBQWMsRUFBRUYsU0FBUyxDQUFYLENBRlQ7QUFHTEcsY0FBVSxFQUFFSCxTQUFTLENBQVgsQ0FITDtBQUlManpCLFdBQU9BO0FBSkYsR0FBUDtBQU1ELENBUEQsQzs7Ozs7OztBQ0FBLElBQUkyaUIsV0FBVyxtQkFBQWxqQixDQUFRLDZDQUFSLENBQWY7O0FBQ0EwYixPQUFPcGIsT0FBUCxHQUFpQixVQUFVZ1ksTUFBVixFQUFrQmxULEdBQWxCLEVBQXVCNG1CLElBQXZCLEVBQTZCO0FBQzVDLE9BQUssSUFBSXhxQixHQUFULElBQWdCNEQsR0FBaEI7QUFBcUI4ZCxhQUFTNUssTUFBVCxFQUFpQjlXLEdBQWpCLEVBQXNCNEQsSUFBSTVELEdBQUosQ0FBdEIsRUFBZ0N3cUIsSUFBaEM7QUFBckI7O0FBQ0EsU0FBTzFULE1BQVA7QUFDRCxDQUhELEM7Ozs7Ozs7QUNEQSxJQUFJclksU0FBUyxtQkFBQUQsQ0FBUSwyQ0FBUixDQUFiOztBQUNBLElBQUk2bUIsT0FBTyxtQkFBQTdtQixDQUFRLHlDQUFSLENBQVg7O0FBQ0EsSUFBSWlFLE1BQU0sbUJBQUFqRSxDQUFRLHdDQUFSLENBQVY7O0FBQ0EsSUFBSTR6QixNQUFNLG1CQUFBNXpCLENBQVEsd0NBQVIsRUFBa0IsS0FBbEIsQ0FBVjs7QUFDQSxJQUFJNnpCLFlBQVksVUFBaEI7QUFDQSxJQUFJQyxZQUFZdlUsU0FBU3NVLFNBQVQsQ0FBaEI7QUFDQSxJQUFJRSxNQUFNLENBQUMsS0FBS0QsU0FBTixFQUFpQnhOLEtBQWpCLENBQXVCdU4sU0FBdkIsQ0FBVjs7QUFFQSxtQkFBQTd6QixDQUFRLHlDQUFSLEVBQW1CZzBCLGFBQW5CLEdBQW1DLFVBQVVueUIsRUFBVixFQUFjO0FBQy9DLFNBQU9peUIsVUFBVWxVLElBQVYsQ0FBZS9kLEVBQWYsQ0FBUDtBQUNELENBRkQ7O0FBSUEsQ0FBQzZaLE9BQU9wYixPQUFQLEdBQWlCLFVBQVVrYyxDQUFWLEVBQWFoYixHQUFiLEVBQWtCOGMsR0FBbEIsRUFBdUIwTixJQUF2QixFQUE2QjtBQUM3QyxNQUFJaUksYUFBYSxPQUFPM1YsR0FBUCxJQUFjLFVBQS9CO0FBQ0EsTUFBSTJWLFVBQUosRUFBZ0Jod0IsSUFBSXFhLEdBQUosRUFBUyxNQUFULEtBQW9CdUksS0FBS3ZJLEdBQUwsRUFBVSxNQUFWLEVBQWtCOWMsR0FBbEIsQ0FBcEI7QUFDaEIsTUFBSWdiLEVBQUVoYixHQUFGLE1BQVc4YyxHQUFmLEVBQW9CO0FBQ3BCLE1BQUkyVixVQUFKLEVBQWdCaHdCLElBQUlxYSxHQUFKLEVBQVNzVixHQUFULEtBQWlCL00sS0FBS3ZJLEdBQUwsRUFBVXNWLEdBQVYsRUFBZXBYLEVBQUVoYixHQUFGLElBQVMsS0FBS2diLEVBQUVoYixHQUFGLENBQWQsR0FBdUJ1eUIsSUFBSXZVLElBQUosQ0FBUzhJLE9BQU85bUIsR0FBUCxDQUFULENBQXRDLENBQWpCOztBQUNoQixNQUFJZ2IsTUFBTXZjLE1BQVYsRUFBa0I7QUFDaEJ1YyxNQUFFaGIsR0FBRixJQUFTOGMsR0FBVDtBQUNELEdBRkQsTUFFTyxJQUFJLENBQUMwTixJQUFMLEVBQVc7QUFDaEIsV0FBT3hQLEVBQUVoYixHQUFGLENBQVA7QUFDQXFsQixTQUFLckssQ0FBTCxFQUFRaGIsR0FBUixFQUFhOGMsR0FBYjtBQUNELEdBSE0sTUFHQSxJQUFJOUIsRUFBRWhiLEdBQUYsQ0FBSixFQUFZO0FBQ2pCZ2IsTUFBRWhiLEdBQUYsSUFBUzhjLEdBQVQ7QUFDRCxHQUZNLE1BRUE7QUFDTHVJLFNBQUtySyxDQUFMLEVBQVFoYixHQUFSLEVBQWE4YyxHQUFiO0FBQ0QsR0FkNEMsQ0FlL0M7O0FBQ0MsQ0FoQkQsRUFnQkdpQixTQUFTdkQsU0FoQlosRUFnQnVCNlgsU0FoQnZCLEVBZ0JrQyxTQUFTeFQsUUFBVCxHQUFvQjtBQUNwRCxTQUFPLE9BQU8sSUFBUCxJQUFlLFVBQWYsSUFBNkIsS0FBS3VULEdBQUwsQ0FBN0IsSUFBMENFLFVBQVVsVSxJQUFWLENBQWUsSUFBZixDQUFqRDtBQUNELENBbEJELEU7Ozs7Ozs7QUNaQTtBQUNBbEUsT0FBT3BiLE9BQVAsR0FBaUJGLE9BQU80SixFQUFQLElBQWEsU0FBU0EsRUFBVCxDQUFZN0YsQ0FBWixFQUFlMkQsQ0FBZixFQUFrQjtBQUM5QztBQUNBLFNBQU8zRCxNQUFNMkQsQ0FBTixHQUFVM0QsTUFBTSxDQUFOLElBQVcsSUFBSUEsQ0FBSixLQUFVLElBQUkyRCxDQUFuQyxHQUF1QzNELEtBQUtBLENBQUwsSUFBVTJELEtBQUtBLENBQTdEO0FBQ0QsQ0FIRCxDOzs7Ozs7OztDQ0FBOztBQUNBLElBQUltYixVQUFVLG1CQUFBampCLENBQVEsMkNBQVIsQ0FBZDs7QUFDQSxJQUFJd2UsWUFBWSxtQkFBQXhlLENBQVEsK0NBQVIsQ0FBaEI7O0FBQ0EsSUFBSXVkLE1BQU0sbUJBQUF2ZCxDQUFRLHdDQUFSLENBQVY7O0FBQ0EsSUFBSStjLFFBQVEsbUJBQUEvYyxDQUFRLDJDQUFSLENBQVo7O0FBRUEwYixPQUFPcGIsT0FBUCxHQUFpQixVQUFVNHpCLFVBQVYsRUFBc0I7QUFDckNqUixVQUFRQSxRQUFRa0UsQ0FBaEIsRUFBbUIrTSxVQUFuQixFQUErQjtBQUFFdHhCLFVBQU0sU0FBU0EsSUFBVCxDQUFjbWtCO0FBQU87QUFBckIsTUFBNkM7QUFDbEYsVUFBSXNDLFFBQVExTSxVQUFVLENBQVYsQ0FBWjtBQUNBLFVBQUl3WCxPQUFKLEVBQWFsRSxDQUFiLEVBQWdCdmtCLENBQWhCLEVBQW1CMG9CLEVBQW5CO0FBQ0E1VixnQkFBVSxJQUFWO0FBQ0EyVixnQkFBVTlLLFVBQVVwbUIsU0FBcEI7QUFDQSxVQUFJa3hCLE9BQUosRUFBYTNWLFVBQVU2SyxLQUFWO0FBQ2IsVUFBSXRDLFVBQVU5akIsU0FBZCxFQUF5QixPQUFPLElBQUksSUFBSixFQUFQO0FBQ3pCZ3RCLFVBQUksRUFBSjs7QUFDQSxVQUFJa0UsT0FBSixFQUFhO0FBQ1h6b0IsWUFBSSxDQUFKO0FBQ0Ewb0IsYUFBSzdXLElBQUk4TCxLQUFKLEVBQVcxTSxVQUFVLENBQVYsQ0FBWCxFQUF5QixDQUF6QixDQUFMO0FBQ0FJLGNBQU1nSyxNQUFOLEVBQWMsS0FBZCxFQUFxQixVQUFVc04sUUFBVixFQUFvQjtBQUN2Q3BFLFlBQUV4c0IsSUFBRixDQUFPMndCLEdBQUdDLFFBQUgsRUFBYTNvQixHQUFiLENBQVA7QUFDRCxTQUZEO0FBR0QsT0FORCxNQU1PO0FBQ0xxUixjQUFNZ0ssTUFBTixFQUFjLEtBQWQsRUFBcUJrSixFQUFFeHNCLElBQXZCLEVBQTZCd3NCLENBQTdCO0FBQ0Q7O0FBQ0QsYUFBTyxJQUFJLElBQUosQ0FBU0EsQ0FBVCxDQUFQO0FBQ0Q7QUFsQjhCLEdBQS9CO0FBbUJELENBcEJELEM7Ozs7Ozs7O0NDTkE7O0FBQ0EsSUFBSWhOLFVBQVUsbUJBQUFqakIsQ0FBUSwyQ0FBUixDQUFkOztBQUVBMGIsT0FBT3BiLE9BQVAsR0FBaUIsVUFBVTR6QixVQUFWLEVBQXNCO0FBQ3JDalIsVUFBUUEsUUFBUWtFLENBQWhCLEVBQW1CK00sVUFBbkIsRUFBK0I7QUFBRUksUUFBSSxTQUFTQSxFQUFULEdBQWM7QUFDakQsVUFBSTF3QixTQUFTK1ksVUFBVS9ZLE1BQXZCO0FBQ0EsVUFBSXFzQixJQUFJdHRCLE1BQU1pQixNQUFOLENBQVI7O0FBQ0EsYUFBT0EsUUFBUDtBQUFpQnFzQixVQUFFcnNCLE1BQUYsSUFBWStZLFVBQVUvWSxNQUFWLENBQVo7QUFBakI7O0FBQ0EsYUFBTyxJQUFJLElBQUosQ0FBU3FzQixDQUFULENBQVA7QUFDRDtBQUw4QixHQUEvQjtBQU1ELENBUEQsQzs7Ozs7OztBQ0pBOztBQUNBO0FBQ0EsSUFBSTlULFdBQVcsbUJBQUFuYyxDQUFRLDhDQUFSLENBQWY7O0FBQ0EsSUFBSXFpQixXQUFXLG1CQUFBcmlCLENBQVEsOENBQVIsQ0FBZjs7QUFDQSxJQUFJdTBCLFFBQVEsU0FBUkEsS0FBUSxDQUFVL1gsQ0FBVixFQUFhb0gsS0FBYixFQUFvQjtBQUM5QnZCLFdBQVM3RixDQUFUO0FBQ0EsTUFBSSxDQUFDTCxTQUFTeUgsS0FBVCxDQUFELElBQW9CQSxVQUFVLElBQWxDLEVBQXdDLE1BQU1qSSxVQUFVaUksUUFBUSwyQkFBbEIsQ0FBTjtBQUN6QyxDQUhEOztBQUlBbEksT0FBT3BiLE9BQVAsR0FBaUI7QUFDZndpQixPQUFLMWlCLE9BQU82cEIsY0FBUCxLQUEwQixlQUFlLEVBQWYsR0FBb0I7QUFDakQsWUFBVW9KLElBQVYsRUFBZ0JtQixLQUFoQixFQUF1QjFSLEdBQXZCLEVBQTRCO0FBQzFCLFFBQUk7QUFDRkEsWUFBTSxtQkFBQTlpQixDQUFRLHdDQUFSLEVBQWtCdWYsU0FBU0ssSUFBM0IsRUFBaUMsbUJBQUE1ZixDQUFRLGdEQUFSLEVBQTBCcWUsQ0FBMUIsQ0FBNEJqZSxPQUFPNGIsU0FBbkMsRUFBOEMsV0FBOUMsRUFBMkQ4RyxHQUE1RixFQUFpRyxDQUFqRyxDQUFOO0FBQ0FBLFVBQUl1USxJQUFKLEVBQVUsRUFBVjtBQUNBbUIsY0FBUSxFQUFFbkIsZ0JBQWdCMXdCLEtBQWxCLENBQVI7QUFDRCxLQUpELENBSUUsT0FBT3NkLENBQVAsRUFBVTtBQUFFdVUsY0FBUSxJQUFSO0FBQWU7O0FBQzdCLFdBQU8sU0FBU3ZLLGNBQVQsQ0FBd0J6TixDQUF4QixFQUEyQm9ILEtBQTNCLEVBQWtDO0FBQ3ZDMlEsWUFBTS9YLENBQU4sRUFBU29ILEtBQVQ7QUFDQSxVQUFJNFEsS0FBSixFQUFXaFksRUFBRWlZLFNBQUYsR0FBYzdRLEtBQWQsQ0FBWCxLQUNLZCxJQUFJdEcsQ0FBSixFQUFPb0gsS0FBUDtBQUNMLGFBQU9wSCxDQUFQO0FBQ0QsS0FMRDtBQU1ELEdBWkQsQ0FZRSxFQVpGLEVBWU0sS0FaTixDQUQ2QixHQWFkdlosU0FiWixDQURVO0FBZWZzeEIsU0FBT0E7QUFmUSxDQUFqQixDOzs7Ozs7OztBQ1JBOztBQUNBLElBQUl0MEIsU0FBUyxtQkFBQUQsQ0FBUSwyQ0FBUixDQUFiOztBQUNBLElBQUlzZ0IsS0FBSyxtQkFBQXRnQixDQUFRLDhDQUFSLENBQVQ7O0FBQ0EsSUFBSTRnQixjQUFjLG1CQUFBNWdCLENBQVEsZ0RBQVIsQ0FBbEI7O0FBQ0EsSUFBSTJlLFVBQVUsbUJBQUEzZSxDQUFRLHdDQUFSLEVBQWtCLFNBQWxCLENBQWQ7O0FBRUEwYixPQUFPcGIsT0FBUCxHQUFpQixVQUFVd2pCLEdBQVYsRUFBZTtBQUM5QixNQUFJakYsSUFBSTVlLE9BQU82akIsR0FBUCxDQUFSO0FBQ0EsTUFBSWxELGVBQWUvQixDQUFmLElBQW9CLENBQUNBLEVBQUVGLE9BQUYsQ0FBekIsRUFBcUMyQixHQUFHakMsQ0FBSCxDQUFLUSxDQUFMLEVBQVFGLE9BQVIsRUFBaUI7QUFDcEQrVSxrQkFBYyxJQURzQztBQUVwRDdSLFNBQUssZUFBWTtBQUFFLGFBQU8sSUFBUDtBQUFjO0FBRm1CLEdBQWpCO0FBSXRDLENBTkQsQzs7Ozs7OztBQ05BLElBQUlDLE1BQU0sbUJBQUE5aEIsQ0FBUSw4Q0FBUixFQUF3QnFlLENBQWxDOztBQUNBLElBQUlwYSxNQUFNLG1CQUFBakUsQ0FBUSx3Q0FBUixDQUFWOztBQUNBLElBQUk4ZixNQUFNLG1CQUFBOWYsQ0FBUSx3Q0FBUixFQUFrQixhQUFsQixDQUFWOztBQUVBMGIsT0FBT3BiLE9BQVAsR0FBaUIsVUFBVXVCLEVBQVYsRUFBYzZ5QixHQUFkLEVBQW1CQyxJQUFuQixFQUF5QjtBQUN4QyxNQUFJOXlCLE1BQU0sQ0FBQ29DLElBQUlwQyxLQUFLOHlCLE9BQU85eUIsRUFBUCxHQUFZQSxHQUFHbWEsU0FBeEIsRUFBbUM4RCxHQUFuQyxDQUFYLEVBQW9EZ0MsSUFBSWpnQixFQUFKLEVBQVFpZSxHQUFSLEVBQWE7QUFBRTRULGtCQUFjLElBQWhCO0FBQXNCbnpCLFdBQU9tMEI7QUFBN0IsR0FBYjtBQUNyRCxDQUZELEM7Ozs7Ozs7QUNKQSxJQUFJOUcsU0FBUyxtQkFBQTV0QixDQUFRLDJDQUFSLEVBQXFCLE1BQXJCLENBQWI7O0FBQ0EsSUFBSTQwQixNQUFNLG1CQUFBNTBCLENBQVEsd0NBQVIsQ0FBVjs7QUFDQTBiLE9BQU9wYixPQUFQLEdBQWlCLFVBQVVrQixHQUFWLEVBQWU7QUFDOUIsU0FBT29zQixPQUFPcHNCLEdBQVAsTUFBZ0Jvc0IsT0FBT3BzQixHQUFQLElBQWNvekIsSUFBSXB6QixHQUFKLENBQTlCLENBQVA7QUFDRCxDQUZELEM7Ozs7Ozs7QUNGQSxJQUFJdkIsU0FBUyxtQkFBQUQsQ0FBUSwyQ0FBUixDQUFiOztBQUNBLElBQUk2MEIsU0FBUyxvQkFBYjtBQUNBLElBQUloUyxRQUFRNWlCLE9BQU80MEIsTUFBUCxNQUFtQjUwQixPQUFPNDBCLE1BQVAsSUFBaUIsRUFBcEMsQ0FBWjs7QUFDQW5aLE9BQU9wYixPQUFQLEdBQWlCLFVBQVVrQixHQUFWLEVBQWU7QUFDOUIsU0FBT3FoQixNQUFNcmhCLEdBQU4sTUFBZXFoQixNQUFNcmhCLEdBQU4sSUFBYSxFQUE1QixDQUFQO0FBQ0QsQ0FGRCxDOzs7Ozs7O0FDSEE7QUFDQSxJQUFJNmdCLFdBQVcsbUJBQUFyaUIsQ0FBUSw4Q0FBUixDQUFmOztBQUNBLElBQUl3ZSxZQUFZLG1CQUFBeGUsQ0FBUSwrQ0FBUixDQUFoQjs7QUFDQSxJQUFJMmUsVUFBVSxtQkFBQTNlLENBQVEsd0NBQVIsRUFBa0IsU0FBbEIsQ0FBZDs7QUFDQTBiLE9BQU9wYixPQUFQLEdBQWlCLFVBQVVrYyxDQUFWLEVBQWFzWSxDQUFiLEVBQWdCO0FBQy9CLE1BQUlqVyxJQUFJd0QsU0FBUzdGLENBQVQsRUFBWXNDLFdBQXBCO0FBQ0EsTUFBSXFJLENBQUo7QUFDQSxTQUFPdEksTUFBTTViLFNBQU4sSUFBbUIsQ0FBQ2trQixJQUFJOUUsU0FBU3hELENBQVQsRUFBWUYsT0FBWixDQUFMLEtBQThCMWIsU0FBakQsR0FBNkQ2eEIsQ0FBN0QsR0FBaUV0VyxVQUFVMkksQ0FBVixDQUF4RTtBQUNELENBSkQsQzs7Ozs7Ozs7QUNKQTs7QUFDQSxJQUFJL0QsUUFBUSxtQkFBQXBqQixDQUFRLDBDQUFSLENBQVo7O0FBRUEwYixPQUFPcGIsT0FBUCxHQUFpQixVQUFVeTBCLE1BQVYsRUFBa0J0TSxHQUFsQixFQUF1QjtBQUN0QyxTQUFPLENBQUMsQ0FBQ3NNLE1BQUYsSUFBWTNSLE1BQU0sWUFBWTtBQUNuQztBQUNBcUYsVUFBTXNNLE9BQU9uVixJQUFQLENBQVksSUFBWixFQUFrQixZQUFZO0FBQUU7QUFBYSxLQUE3QyxFQUErQyxDQUEvQyxDQUFOLEdBQTBEbVYsT0FBT25WLElBQVAsQ0FBWSxJQUFaLENBQTFEO0FBQ0QsR0FIa0IsQ0FBbkI7QUFJRCxDQUxELEM7Ozs7Ozs7QUNIQSxJQUFJb1YsWUFBWSxtQkFBQWgxQixDQUFRLCtDQUFSLENBQWhCOztBQUNBLElBQUlnb0IsVUFBVSxtQkFBQWhvQixDQUFRLDRDQUFSLENBQWQsQyxDQUNBO0FBQ0E7OztBQUNBMGIsT0FBT3BiLE9BQVAsR0FBaUIsVUFBVXV6QixTQUFWLEVBQXFCO0FBQ3BDLFNBQU8sVUFBVTFWLElBQVYsRUFBZ0I4VyxHQUFoQixFQUFxQjtBQUMxQixRQUFJcFAsSUFBSXlDLE9BQU9OLFFBQVE3SixJQUFSLENBQVAsQ0FBUjtBQUNBLFFBQUkvYyxJQUFJNHpCLFVBQVVDLEdBQVYsQ0FBUjtBQUNBLFFBQUl0cEIsSUFBSWthLEVBQUVqaUIsTUFBVjtBQUNBLFFBQUltSCxDQUFKLEVBQU9ELENBQVA7QUFDQSxRQUFJMUosSUFBSSxDQUFKLElBQVNBLEtBQUt1SyxDQUFsQixFQUFxQixPQUFPa29CLFlBQVksRUFBWixHQUFpQjV3QixTQUF4QjtBQUNyQjhILFFBQUk4YSxFQUFFcVAsVUFBRixDQUFhOXpCLENBQWIsQ0FBSjtBQUNBLFdBQU8ySixJQUFJLE1BQUosSUFBY0EsSUFBSSxNQUFsQixJQUE0QjNKLElBQUksQ0FBSixLQUFVdUssQ0FBdEMsSUFBMkMsQ0FBQ2IsSUFBSSthLEVBQUVxUCxVQUFGLENBQWE5ekIsSUFBSSxDQUFqQixDQUFMLElBQTRCLE1BQXZFLElBQWlGMEosSUFBSSxNQUFyRixHQUNIK29CLFlBQVloTyxFQUFFa04sTUFBRixDQUFTM3hCLENBQVQsQ0FBWixHQUEwQjJKLENBRHZCLEdBRUg4b0IsWUFBWWhPLEVBQUUzRyxLQUFGLENBQVE5ZCxDQUFSLEVBQVdBLElBQUksQ0FBZixDQUFaLEdBQWdDLENBQUMySixJQUFJLE1BQUosSUFBYyxFQUFmLEtBQXNCRCxJQUFJLE1BQTFCLElBQW9DLE9BRnhFO0FBR0QsR0FWRDtBQVdELENBWkQsQzs7Ozs7OztBQ0pBO0FBQ0EsSUFBSXlmLFdBQVcsbUJBQUF2cUIsQ0FBUSw4Q0FBUixDQUFmOztBQUNBLElBQUlnb0IsVUFBVSxtQkFBQWhvQixDQUFRLDRDQUFSLENBQWQ7O0FBRUEwYixPQUFPcGIsT0FBUCxHQUFpQixVQUFVNmQsSUFBVixFQUFnQmdYLFlBQWhCLEVBQThCNVQsSUFBOUIsRUFBb0M7QUFDbkQsTUFBSWdKLFNBQVM0SyxZQUFULENBQUosRUFBNEIsTUFBTXhaLFVBQVUsWUFBWTRGLElBQVosR0FBbUIsd0JBQTdCLENBQU47QUFDNUIsU0FBTytHLE9BQU9OLFFBQVE3SixJQUFSLENBQVAsQ0FBUDtBQUNELENBSEQsQzs7Ozs7OztBQ0pBLElBQUk4RSxVQUFVLG1CQUFBampCLENBQVEsMkNBQVIsQ0FBZDs7QUFDQSxJQUFJb2pCLFFBQVEsbUJBQUFwakIsQ0FBUSwwQ0FBUixDQUFaOztBQUNBLElBQUlnb0IsVUFBVSxtQkFBQWhvQixDQUFRLDRDQUFSLENBQWQ7O0FBQ0EsSUFBSW8xQixPQUFPLElBQVgsQyxDQUNBOztBQUNBLElBQUlDLGFBQWEsU0FBYkEsVUFBYSxDQUFVN00sTUFBVixFQUFrQmtNLEdBQWxCLEVBQXVCWSxTQUF2QixFQUFrQy8wQixLQUFsQyxFQUF5QztBQUN4RCxNQUFJNG1CLElBQUltQixPQUFPTixRQUFRUSxNQUFSLENBQVAsQ0FBUjtBQUNBLE1BQUl2UyxLQUFLLE1BQU15ZSxHQUFmO0FBQ0EsTUFBSVksY0FBYyxFQUFsQixFQUFzQnJmLE1BQU0sTUFBTXFmLFNBQU4sR0FBa0IsSUFBbEIsR0FBeUJoTixPQUFPL25CLEtBQVAsRUFBY2cxQixPQUFkLENBQXNCSCxJQUF0QixFQUE0QixRQUE1QixDQUF6QixHQUFpRSxHQUF2RTtBQUN0QixTQUFPbmYsS0FBSyxHQUFMLEdBQVdrUixDQUFYLEdBQWUsSUFBZixHQUFzQnVOLEdBQXRCLEdBQTRCLEdBQW5DO0FBQ0QsQ0FMRDs7QUFNQWhaLE9BQU9wYixPQUFQLEdBQWlCLFVBQVVpaEIsSUFBVixFQUFnQndHLElBQWhCLEVBQXNCO0FBQ3JDLE1BQUl2TCxJQUFJLEVBQVI7QUFDQUEsSUFBRStFLElBQUYsSUFBVXdHLEtBQUtzTixVQUFMLENBQVY7QUFDQXBTLFVBQVFBLFFBQVFvRSxDQUFSLEdBQVlwRSxRQUFRNUQsQ0FBUixHQUFZK0QsTUFBTSxZQUFZO0FBQ2hELFFBQUlpUSxPQUFPLEdBQUc5UixJQUFILEVBQVMsR0FBVCxDQUFYO0FBQ0EsV0FBTzhSLFNBQVNBLEtBQUttQyxXQUFMLEVBQVQsSUFBK0JuQyxLQUFLL00sS0FBTCxDQUFXLEdBQVgsRUFBZ0IxaUIsTUFBaEIsR0FBeUIsQ0FBL0Q7QUFDRCxHQUgrQixDQUFoQyxFQUdJLFFBSEosRUFHYzRZLENBSGQ7QUFJRCxDQVBELEM7Ozs7Ozs7QUNYQTtBQUNBLElBQUlGLFdBQVcsbUJBQUF0YyxDQUFRLDhDQUFSLENBQWY7O0FBQ0EsSUFBSXkxQixTQUFTLG1CQUFBejFCLENBQVEsa0RBQVIsQ0FBYjs7QUFDQSxJQUFJZ29CLFVBQVUsbUJBQUFob0IsQ0FBUSw0Q0FBUixDQUFkOztBQUVBMGIsT0FBT3BiLE9BQVAsR0FBaUIsVUFBVTZkLElBQVYsRUFBZ0J1WCxTQUFoQixFQUEyQkMsVUFBM0IsRUFBdUN2bkIsSUFBdkMsRUFBNkM7QUFDNUQsTUFBSStZLElBQUltQixPQUFPTixRQUFRN0osSUFBUixDQUFQLENBQVI7QUFDQSxNQUFJeVgsZUFBZXpPLEVBQUV2akIsTUFBckI7QUFDQSxNQUFJaXlCLFVBQVVGLGVBQWUxeUIsU0FBZixHQUEyQixHQUEzQixHQUFpQ3FsQixPQUFPcU4sVUFBUCxDQUEvQztBQUNBLE1BQUlHLGVBQWV4WixTQUFTb1osU0FBVCxDQUFuQjtBQUNBLE1BQUlJLGdCQUFnQkYsWUFBaEIsSUFBZ0NDLFdBQVcsRUFBL0MsRUFBbUQsT0FBTzFPLENBQVA7QUFDbkQsTUFBSTRPLFVBQVVELGVBQWVGLFlBQTdCO0FBQ0EsTUFBSUksZUFBZVAsT0FBTzdWLElBQVAsQ0FBWWlXLE9BQVosRUFBcUJ0dUIsS0FBSzB1QixJQUFMLENBQVVGLFVBQVVGLFFBQVFqeUIsTUFBNUIsQ0FBckIsQ0FBbkI7QUFDQSxNQUFJb3lCLGFBQWFweUIsTUFBYixHQUFzQm15QixPQUExQixFQUFtQ0MsZUFBZUEsYUFBYTlXLEtBQWIsQ0FBbUIsQ0FBbkIsRUFBc0I2VyxPQUF0QixDQUFmO0FBQ25DLFNBQU8zbkIsT0FBTzRuQixlQUFlN08sQ0FBdEIsR0FBMEJBLElBQUk2TyxZQUFyQztBQUNELENBVkQsQzs7Ozs7Ozs7QUNMQTs7QUFDQSxJQUFJaEIsWUFBWSxtQkFBQWgxQixDQUFRLCtDQUFSLENBQWhCOztBQUNBLElBQUlnb0IsVUFBVSxtQkFBQWhvQixDQUFRLDRDQUFSLENBQWQ7O0FBRUEwYixPQUFPcGIsT0FBUCxHQUFpQixTQUFTbTFCLE1BQVQsQ0FBZ0J0MEIsS0FBaEIsRUFBdUI7QUFDdEMsTUFBSTJ4QixNQUFNeEssT0FBT04sUUFBUSxJQUFSLENBQVAsQ0FBVjtBQUNBLE1BQUl6SixNQUFNLEVBQVY7QUFDQSxNQUFJN1MsSUFBSXNwQixVQUFVN3pCLEtBQVYsQ0FBUjtBQUNBLE1BQUl1SyxJQUFJLENBQUosSUFBU0EsS0FBS21oQixRQUFsQixFQUE0QixNQUFNckgsV0FBVyx5QkFBWCxDQUFOOztBQUM1QixTQUFNOVosSUFBSSxDQUFWLEVBQWEsQ0FBQ0EsT0FBTyxDQUFSLE1BQWVvbkIsT0FBT0EsR0FBdEIsQ0FBYjtBQUF5QyxRQUFJcG5CLElBQUksQ0FBUixFQUFXNlMsT0FBT3VVLEdBQVA7QUFBcEQ7O0FBQ0EsU0FBT3ZVLEdBQVA7QUFDRCxDQVBELEM7Ozs7Ozs7QUNKQSxJQUFJMEUsVUFBVSxtQkFBQWpqQixDQUFRLDJDQUFSLENBQWQ7O0FBQ0EsSUFBSWdvQixVQUFVLG1CQUFBaG9CLENBQVEsNENBQVIsQ0FBZDs7QUFDQSxJQUFJb2pCLFFBQVEsbUJBQUFwakIsQ0FBUSwwQ0FBUixDQUFaOztBQUNBLElBQUlrMkIsU0FBUyxtQkFBQWwyQixDQUFRLDhDQUFSLENBQWI7O0FBQ0EsSUFBSW0yQixRQUFRLE1BQU1ELE1BQU4sR0FBZSxHQUEzQjtBQUNBLElBQUlFLE1BQU0sWUFBVjtBQUNBLElBQUlDLFFBQVE5TixPQUFPLE1BQU00TixLQUFOLEdBQWNBLEtBQWQsR0FBc0IsR0FBN0IsQ0FBWjtBQUNBLElBQUlHLFFBQVEvTixPQUFPNE4sUUFBUUEsS0FBUixHQUFnQixJQUF2QixDQUFaOztBQUVBLElBQUlJLFdBQVcsU0FBWEEsUUFBVyxDQUFVelMsR0FBVixFQUFlaUUsSUFBZixFQUFxQnlPLEtBQXJCLEVBQTRCO0FBQ3pDLE1BQUk5TyxNQUFNLEVBQVY7QUFDQSxNQUFJK08sUUFBUXJULE1BQU0sWUFBWTtBQUM1QixXQUFPLENBQUMsQ0FBQzhTLE9BQU9wUyxHQUFQLEdBQUYsSUFBbUJzUyxJQUFJdFMsR0FBSixPQUFjc1MsR0FBeEM7QUFDRCxHQUZXLENBQVo7QUFHQSxNQUFJMVcsS0FBS2dJLElBQUk1RCxHQUFKLElBQVcyUyxRQUFRMU8sS0FBSzhLLElBQUwsQ0FBUixHQUFxQnFELE9BQU9wUyxHQUFQLENBQXpDO0FBQ0EsTUFBSTBTLEtBQUosRUFBVzlPLElBQUk4TyxLQUFKLElBQWE5VyxFQUFiO0FBQ1h1RCxVQUFRQSxRQUFRb0UsQ0FBUixHQUFZcEUsUUFBUTVELENBQVIsR0FBWW9YLEtBQWhDLEVBQXVDLFFBQXZDLEVBQWlEL08sR0FBakQ7QUFDRCxDQVJELEMsQ0FVQTtBQUNBO0FBQ0E7OztBQUNBLElBQUltTCxPQUFPMEQsU0FBUzFELElBQVQsR0FBZ0IsVUFBVXJLLE1BQVYsRUFBa0I5SyxJQUFsQixFQUF3QjtBQUNqRDhLLFdBQVNGLE9BQU9OLFFBQVFRLE1BQVIsQ0FBUCxDQUFUO0FBQ0EsTUFBSTlLLE9BQU8sQ0FBWCxFQUFjOEssU0FBU0EsT0FBTytNLE9BQVAsQ0FBZWMsS0FBZixFQUFzQixFQUF0QixDQUFUO0FBQ2QsTUFBSTNZLE9BQU8sQ0FBWCxFQUFjOEssU0FBU0EsT0FBTytNLE9BQVAsQ0FBZWUsS0FBZixFQUFzQixFQUF0QixDQUFUO0FBQ2QsU0FBTzlOLE1BQVA7QUFDRCxDQUxEOztBQU9BOU0sT0FBT3BiLE9BQVAsR0FBaUJpMkIsUUFBakIsQzs7Ozs7OztBQzdCQTdhLE9BQU9wYixPQUFQLEdBQWlCLDBEQUNmLGdGQURGLEM7Ozs7Ozs7QUNBQSxJQUFJaWQsTUFBTSxtQkFBQXZkLENBQVEsd0NBQVIsQ0FBVjs7QUFDQSxJQUFJZ2YsU0FBUyxtQkFBQWhmLENBQVEsMkNBQVIsQ0FBYjs7QUFDQSxJQUFJMDJCLE9BQU8sbUJBQUExMkIsQ0FBUSx5Q0FBUixDQUFYOztBQUNBLElBQUkyMkIsTUFBTSxtQkFBQTMyQixDQUFRLCtDQUFSLENBQVY7O0FBQ0EsSUFBSUMsU0FBUyxtQkFBQUQsQ0FBUSwyQ0FBUixDQUFiOztBQUNBLElBQUl3YixVQUFVdmIsT0FBT3ViLE9BQXJCO0FBQ0EsSUFBSW9iLFVBQVUzMkIsT0FBTzQyQixZQUFyQjtBQUNBLElBQUlDLFlBQVk3MkIsT0FBTzgyQixjQUF2QjtBQUNBLElBQUlDLGlCQUFpQi8yQixPQUFPKzJCLGNBQTVCO0FBQ0EsSUFBSUMsV0FBV2gzQixPQUFPZzNCLFFBQXRCO0FBQ0EsSUFBSUMsVUFBVSxDQUFkO0FBQ0EsSUFBSUMsUUFBUSxFQUFaO0FBQ0EsSUFBSUMscUJBQXFCLG9CQUF6QjtBQUNBLElBQUlDLEtBQUosRUFBV0MsT0FBWCxFQUFvQkMsSUFBcEI7O0FBQ0EsSUFBSUMsTUFBTSxTQUFOQSxHQUFNLEdBQVk7QUFDcEIsTUFBSTV5QixLQUFLLENBQUMsSUFBVixDQURvQixDQUVwQjs7QUFDQSxNQUFJdXlCLE1BQU1wTixjQUFOLENBQXFCbmxCLEVBQXJCLENBQUosRUFBOEI7QUFDNUIsUUFBSThhLEtBQUt5WCxNQUFNdnlCLEVBQU4sQ0FBVDtBQUNBLFdBQU91eUIsTUFBTXZ5QixFQUFOLENBQVA7QUFDQThhO0FBQ0Q7QUFDRixDQVJEOztBQVNBLElBQUkrWCxXQUFXLFNBQVhBLFFBQVcsQ0FBVUMsS0FBVixFQUFpQjtBQUM5QkYsTUFBSTVYLElBQUosQ0FBUzhYLE1BQU0vVixJQUFmO0FBQ0QsQ0FGRCxDLENBR0E7OztBQUNBLElBQUksQ0FBQ2lWLE9BQUQsSUFBWSxDQUFDRSxTQUFqQixFQUE0QjtBQUMxQkYsWUFBVSxTQUFTQyxZQUFULENBQXNCblgsRUFBdEIsRUFBMEI7QUFDbEMsUUFBSUosT0FBTyxFQUFYO0FBQ0EsUUFBSWxlLElBQUksQ0FBUjs7QUFDQSxXQUFPdWIsVUFBVS9ZLE1BQVYsR0FBbUJ4QyxDQUExQjtBQUE2QmtlLFdBQUs3YixJQUFMLENBQVVrWixVQUFVdmIsR0FBVixDQUFWO0FBQTdCOztBQUNBKzFCLFVBQU0sRUFBRUQsT0FBUixJQUFtQixZQUFZO0FBQzdCO0FBQ0FsWSxhQUFPLE9BQU9VLEVBQVAsSUFBYSxVQUFiLEdBQTBCQSxFQUExQixHQUErQkgsU0FBU0csRUFBVCxDQUF0QyxFQUFvREosSUFBcEQ7QUFDRCxLQUhEOztBQUlBK1gsVUFBTUgsT0FBTjtBQUNBLFdBQU9BLE9BQVA7QUFDRCxHQVZEOztBQVdBSixjQUFZLFNBQVNDLGNBQVQsQ0FBd0JueUIsRUFBeEIsRUFBNEI7QUFDdEMsV0FBT3V5QixNQUFNdnlCLEVBQU4sQ0FBUDtBQUNELEdBRkQsQ0FaMEIsQ0FlMUI7OztBQUNBLE1BQUksbUJBQUE1RSxDQUFRLHdDQUFSLEVBQWtCd2IsT0FBbEIsS0FBOEIsU0FBbEMsRUFBNkM7QUFDM0M2YixZQUFRLGVBQVV6eUIsRUFBVixFQUFjO0FBQ3BCNFcsY0FBUTRULFFBQVIsQ0FBaUI3UixJQUFJaWEsR0FBSixFQUFTNXlCLEVBQVQsRUFBYSxDQUFiLENBQWpCO0FBQ0QsS0FGRCxDQUQyQyxDQUk3Qzs7QUFDQyxHQUxELE1BS08sSUFBSXF5QixZQUFZQSxTQUFTVSxHQUF6QixFQUE4QjtBQUNuQ04sWUFBUSxlQUFVenlCLEVBQVYsRUFBYztBQUNwQnF5QixlQUFTVSxHQUFULENBQWFwYSxJQUFJaWEsR0FBSixFQUFTNXlCLEVBQVQsRUFBYSxDQUFiLENBQWI7QUFDRCxLQUZELENBRG1DLENBSXJDOztBQUNDLEdBTE0sTUFLQSxJQUFJb3lCLGNBQUosRUFBb0I7QUFDekJNLGNBQVUsSUFBSU4sY0FBSixFQUFWO0FBQ0FPLFdBQU9ELFFBQVFNLEtBQWY7QUFDQU4sWUFBUU8sS0FBUixDQUFjQyxTQUFkLEdBQTBCTCxRQUExQjtBQUNBSixZQUFROVosSUFBSWdhLEtBQUtRLFdBQVQsRUFBc0JSLElBQXRCLEVBQTRCLENBQTVCLENBQVIsQ0FKeUIsQ0FLM0I7QUFDQTtBQUNDLEdBUE0sTUFPQSxJQUFJdDNCLE9BQU8rM0IsZ0JBQVAsSUFBMkIsT0FBT0QsV0FBUCxJQUFzQixVQUFqRCxJQUErRCxDQUFDOTNCLE9BQU9nNEIsYUFBM0UsRUFBMEY7QUFDL0ZaLFlBQVEsZUFBVXp5QixFQUFWLEVBQWM7QUFDcEIzRSxhQUFPODNCLFdBQVAsQ0FBbUJuekIsS0FBSyxFQUF4QixFQUE0QixHQUE1QjtBQUNELEtBRkQ7O0FBR0EzRSxXQUFPKzNCLGdCQUFQLENBQXdCLFNBQXhCLEVBQW1DUCxRQUFuQyxFQUE2QyxLQUE3QyxFQUorRixDQUtqRztBQUNDLEdBTk0sTUFNQSxJQUFJTCxzQkFBc0JULElBQUksUUFBSixDQUExQixFQUF5QztBQUM5Q1UsWUFBUSxlQUFVenlCLEVBQVYsRUFBYztBQUNwQjh4QixXQUFLMUYsV0FBTCxDQUFpQjJGLElBQUksUUFBSixDQUFqQixFQUFnQ1Msa0JBQWhDLElBQXNELFlBQVk7QUFDaEVWLGFBQUt3QixXQUFMLENBQWlCLElBQWpCO0FBQ0FWLFlBQUk1WCxJQUFKLENBQVNoYixFQUFUO0FBQ0QsT0FIRDtBQUlELEtBTEQsQ0FEOEMsQ0FPaEQ7O0FBQ0MsR0FSTSxNQVFBO0FBQ0x5eUIsWUFBUSxlQUFVenlCLEVBQVYsRUFBYztBQUNwQnV6QixpQkFBVzVhLElBQUlpYSxHQUFKLEVBQVM1eUIsRUFBVCxFQUFhLENBQWIsQ0FBWCxFQUE0QixDQUE1QjtBQUNELEtBRkQ7QUFHRDtBQUNGOztBQUNEOFcsT0FBT3BiLE9BQVAsR0FBaUI7QUFDZndpQixPQUFLOFQsT0FEVTtBQUVmbmMsU0FBT3FjO0FBRlEsQ0FBakIsQzs7Ozs7OztBQ2hGQSxJQUFJOUIsWUFBWSxtQkFBQWgxQixDQUFRLCtDQUFSLENBQWhCOztBQUNBLElBQUlnSixNQUFNekIsS0FBS3lCLEdBQWY7QUFDQSxJQUFJRCxNQUFNeEIsS0FBS3dCLEdBQWY7O0FBQ0EyUyxPQUFPcGIsT0FBUCxHQUFpQixVQUFVd0IsS0FBVixFQUFpQjhCLE1BQWpCLEVBQXlCO0FBQ3hDOUIsVUFBUWt6QixVQUFVbHpCLEtBQVYsQ0FBUjtBQUNBLFNBQU9BLFFBQVEsQ0FBUixHQUFZa0gsSUFBSWxILFFBQVE4QixNQUFaLEVBQW9CLENBQXBCLENBQVosR0FBcUNtRixJQUFJakgsS0FBSixFQUFXOEIsTUFBWCxDQUE1QztBQUNELENBSEQsQzs7Ozs7OztBQ0hBO0FBQ0EsSUFBSW94QixZQUFZLG1CQUFBaDFCLENBQVEsK0NBQVIsQ0FBaEI7O0FBQ0EsSUFBSXNjLFdBQVcsbUJBQUF0YyxDQUFRLDhDQUFSLENBQWY7O0FBQ0EwYixPQUFPcGIsT0FBUCxHQUFpQixVQUFVdUIsRUFBVixFQUFjO0FBQzdCLE1BQUlBLE9BQU9vQixTQUFYLEVBQXNCLE9BQU8sQ0FBUDtBQUN0QixNQUFJbTFCLFNBQVNwRCxVQUFVbnpCLEVBQVYsQ0FBYjtBQUNBLE1BQUkrQixTQUFTMFksU0FBUzhiLE1BQVQsQ0FBYjtBQUNBLE1BQUlBLFdBQVd4MEIsTUFBZixFQUF1QixNQUFNNGhCLFdBQVcsZUFBWCxDQUFOO0FBQ3ZCLFNBQU81aEIsTUFBUDtBQUNELENBTkQsQzs7Ozs7OztBQ0hBO0FBQ0EsSUFBSXF5QixPQUFPMXVCLEtBQUswdUIsSUFBaEI7QUFDQSxJQUFJNUwsUUFBUTlpQixLQUFLOGlCLEtBQWpCOztBQUNBM08sT0FBT3BiLE9BQVAsR0FBaUIsVUFBVXVCLEVBQVYsRUFBYztBQUM3QixTQUFPdzJCLE1BQU14MkIsS0FBSyxDQUFDQSxFQUFaLElBQWtCLENBQWxCLEdBQXNCLENBQUNBLEtBQUssQ0FBTCxHQUFTd29CLEtBQVQsR0FBaUI0TCxJQUFsQixFQUF3QnAwQixFQUF4QixDQUE3QjtBQUNELENBRkQsQzs7Ozs7OztBQ0hBO0FBQ0EsSUFBSTJiLFVBQVUsbUJBQUF4ZCxDQUFRLDRDQUFSLENBQWQ7O0FBQ0EsSUFBSWdvQixVQUFVLG1CQUFBaG9CLENBQVEsNENBQVIsQ0FBZDs7QUFDQTBiLE9BQU9wYixPQUFQLEdBQWlCLFVBQVV1QixFQUFWLEVBQWM7QUFDN0IsU0FBTzJiLFFBQVF3SyxRQUFRbm1CLEVBQVIsQ0FBUixDQUFQO0FBQ0QsQ0FGRCxDOzs7Ozs7O0FDSEE7QUFDQSxJQUFJbXpCLFlBQVksbUJBQUFoMUIsQ0FBUSwrQ0FBUixDQUFoQjs7QUFDQSxJQUFJK0ksTUFBTXhCLEtBQUt3QixHQUFmOztBQUNBMlMsT0FBT3BiLE9BQVAsR0FBaUIsVUFBVXVCLEVBQVYsRUFBYztBQUM3QixTQUFPQSxLQUFLLENBQUwsR0FBU2tILElBQUlpc0IsVUFBVW56QixFQUFWLENBQUosRUFBbUIsZ0JBQW5CLENBQVQsR0FBZ0QsQ0FBdkQsQ0FENkIsQ0FDNkI7QUFDM0QsQ0FGRCxDOzs7Ozs7O0FDSEE7QUFDQSxJQUFJbW1CLFVBQVUsbUJBQUFob0IsQ0FBUSw0Q0FBUixDQUFkOztBQUNBMGIsT0FBT3BiLE9BQVAsR0FBaUIsVUFBVXVCLEVBQVYsRUFBYztBQUM3QixTQUFPekIsT0FBTzRuQixRQUFRbm1CLEVBQVIsQ0FBUCxDQUFQO0FBQ0QsQ0FGRCxDOzs7Ozs7O0FDRkE7QUFDQSxJQUFJc2EsV0FBVyxtQkFBQW5jLENBQVEsOENBQVIsQ0FBZixDLENBQ0E7QUFDQTs7O0FBQ0EwYixPQUFPcGIsT0FBUCxHQUFpQixVQUFVdUIsRUFBVixFQUFjc2xCLENBQWQsRUFBaUI7QUFDaEMsTUFBSSxDQUFDaEwsU0FBU3RhLEVBQVQsQ0FBTCxFQUFtQixPQUFPQSxFQUFQO0FBQ25CLE1BQUk2ZCxFQUFKLEVBQVFwQixHQUFSO0FBQ0EsTUFBSTZJLEtBQUssUUFBUXpILEtBQUs3ZCxHQUFHd2UsUUFBaEIsS0FBNkIsVUFBbEMsSUFBZ0QsQ0FBQ2xFLFNBQVNtQyxNQUFNb0IsR0FBR0UsSUFBSCxDQUFRL2QsRUFBUixDQUFmLENBQXJELEVBQWtGLE9BQU95YyxHQUFQO0FBQ2xGLE1BQUksUUFBUW9CLEtBQUs3ZCxHQUFHeTJCLE9BQWhCLEtBQTRCLFVBQTVCLElBQTBDLENBQUNuYyxTQUFTbUMsTUFBTW9CLEdBQUdFLElBQUgsQ0FBUS9kLEVBQVIsQ0FBZixDQUEvQyxFQUE0RSxPQUFPeWMsR0FBUDtBQUM1RSxNQUFJLENBQUM2SSxDQUFELElBQU0sUUFBUXpILEtBQUs3ZCxHQUFHd2UsUUFBaEIsS0FBNkIsVUFBbkMsSUFBaUQsQ0FBQ2xFLFNBQVNtQyxNQUFNb0IsR0FBR0UsSUFBSCxDQUFRL2QsRUFBUixDQUFmLENBQXRELEVBQW1GLE9BQU95YyxHQUFQO0FBQ25GLFFBQU0zQyxVQUFVLHlDQUFWLENBQU47QUFDRCxDQVBELEM7Ozs7Ozs7O0FDSkE7O0FBQ0EsSUFBSSxtQkFBQTNiLENBQVEsZ0RBQVIsQ0FBSixFQUErQjtBQUM3QixNQUFJMnFCLFVBQVUsbUJBQUEzcUIsQ0FBUSw0Q0FBUixDQUFkOztBQUNBLE1BQUlDLFNBQVMsbUJBQUFELENBQVEsMkNBQVIsQ0FBYjs7QUFDQSxNQUFJb2pCLFFBQVEsbUJBQUFwakIsQ0FBUSwwQ0FBUixDQUFaOztBQUNBLE1BQUlpakIsVUFBVSxtQkFBQWpqQixDQUFRLDJDQUFSLENBQWQ7O0FBQ0EsTUFBSXU0QixTQUFTLG1CQUFBdjRCLENBQVEsMENBQVIsQ0FBYjs7QUFDQSxNQUFJdzRCLFVBQVUsbUJBQUF4NEIsQ0FBUSxpREFBUixDQUFkOztBQUNBLE1BQUl1ZCxNQUFNLG1CQUFBdmQsQ0FBUSx3Q0FBUixDQUFWOztBQUNBLE1BQUl3Z0IsYUFBYSxtQkFBQXhnQixDQUFRLGdEQUFSLENBQWpCOztBQUNBLE1BQUl5NEIsZUFBZSxtQkFBQXo0QixDQUFRLGtEQUFSLENBQW5COztBQUNBLE1BQUk2bUIsT0FBTyxtQkFBQTdtQixDQUFRLHlDQUFSLENBQVg7O0FBQ0EsTUFBSXVnQixjQUFjLG1CQUFBdmdCLENBQVEsaURBQVIsQ0FBbEI7O0FBQ0EsTUFBSWcxQixZQUFZLG1CQUFBaDFCLENBQVEsK0NBQVIsQ0FBaEI7O0FBQ0EsTUFBSXNjLFdBQVcsbUJBQUF0YyxDQUFRLDhDQUFSLENBQWY7O0FBQ0EsTUFBSTA0QixVQUFVLG1CQUFBMTRCLENBQVEsNkNBQVIsQ0FBZDs7QUFDQSxNQUFJcWMsa0JBQWtCLG1CQUFBcmMsQ0FBUSxzREFBUixDQUF0Qjs7QUFDQSxNQUFJbW1CLGNBQWMsbUJBQUFubUIsQ0FBUSxpREFBUixDQUFsQjs7QUFDQSxNQUFJaUUsTUFBTSxtQkFBQWpFLENBQVEsd0NBQVIsQ0FBVjs7QUFDQSxNQUFJbWlCLFVBQVUsbUJBQUFuaUIsQ0FBUSw0Q0FBUixDQUFkOztBQUNBLE1BQUltYyxXQUFXLG1CQUFBbmMsQ0FBUSw4Q0FBUixDQUFmOztBQUNBLE1BQUlvYyxXQUFXLG1CQUFBcGMsQ0FBUSw4Q0FBUixDQUFmOztBQUNBLE1BQUl1cEIsY0FBYyxtQkFBQXZwQixDQUFRLGtEQUFSLENBQWxCOztBQUNBLE1BQUkyVyxTQUFTLG1CQUFBM1csQ0FBUSxrREFBUixDQUFiOztBQUNBLE1BQUk2cUIsaUJBQWlCLG1CQUFBN3FCLENBQVEsK0NBQVIsQ0FBckI7O0FBQ0EsTUFBSTZ4QixPQUFPLG1CQUFBN3hCLENBQVEsZ0RBQVIsRUFBMEJxZSxDQUFyQzs7QUFDQSxNQUFJbUwsWUFBWSxtQkFBQXhwQixDQUFRLDREQUFSLENBQWhCOztBQUNBLE1BQUk0MEIsTUFBTSxtQkFBQTUwQixDQUFRLHdDQUFSLENBQVY7O0FBQ0EsTUFBSWlvQixNQUFNLG1CQUFBam9CLENBQVEsd0NBQVIsQ0FBVjs7QUFDQSxNQUFJc2lCLG9CQUFvQixtQkFBQXRpQixDQUFRLGtEQUFSLENBQXhCOztBQUNBLE1BQUkyNEIsc0JBQXNCLG1CQUFBMzRCLENBQVEsbURBQVIsQ0FBMUI7O0FBQ0EsTUFBSStlLHFCQUFxQixtQkFBQS9lLENBQVEsd0RBQVIsQ0FBekI7O0FBQ0EsTUFBSTQ0QixpQkFBaUIsbUJBQUE1NEIsQ0FBUSxzREFBUixDQUFyQjs7QUFDQSxNQUFJb3FCLFlBQVksbUJBQUFwcUIsQ0FBUSw4Q0FBUixDQUFoQjs7QUFDQSxNQUFJcWpCLGNBQWMsbUJBQUFyakIsQ0FBUSxnREFBUixDQUFsQjs7QUFDQSxNQUFJMmdCLGFBQWEsbUJBQUEzZ0IsQ0FBUSxnREFBUixDQUFqQjs7QUFDQSxNQUFJNjRCLFlBQVksbUJBQUE3NEIsQ0FBUSwrQ0FBUixDQUFoQjs7QUFDQSxNQUFJODRCLGtCQUFrQixtQkFBQTk0QixDQUFRLHNEQUFSLENBQXRCOztBQUNBLE1BQUkrNEIsTUFBTSxtQkFBQS80QixDQUFRLDhDQUFSLENBQVY7O0FBQ0EsTUFBSWc1QixRQUFRLG1CQUFBaDVCLENBQVEsZ0RBQVIsQ0FBWjs7QUFDQSxNQUFJc2dCLEtBQUt5WSxJQUFJMWEsQ0FBYjtBQUNBLE1BQUlzVCxPQUFPcUgsTUFBTTNhLENBQWpCO0FBQ0EsTUFBSW1ILGFBQWF2bEIsT0FBT3VsQixVQUF4QjtBQUNBLE1BQUk3SixZQUFZMWIsT0FBTzBiLFNBQXZCO0FBQ0EsTUFBSXNkLGFBQWFoNUIsT0FBT2c1QixVQUF4QjtBQUNBLE1BQUlDLGVBQWUsYUFBbkI7QUFDQSxNQUFJQyxnQkFBZ0IsV0FBV0QsWUFBL0I7QUFDQSxNQUFJRSxvQkFBb0IsbUJBQXhCO0FBQ0EsTUFBSXRTLFlBQVksV0FBaEI7QUFDQSxNQUFJL0ssYUFBYXBaLE1BQU1ta0IsU0FBTixDQUFqQjtBQUNBLE1BQUl1UyxlQUFlYixRQUFRYyxXQUEzQjtBQUNBLE1BQUlDLFlBQVlmLFFBQVFnQixRQUF4QjtBQUNBLE1BQUlDLGVBQWVuWCxrQkFBa0IsQ0FBbEIsQ0FBbkI7QUFDQSxNQUFJb1gsY0FBY3BYLGtCQUFrQixDQUFsQixDQUFsQjtBQUNBLE1BQUlxWCxZQUFZclgsa0JBQWtCLENBQWxCLENBQWhCO0FBQ0EsTUFBSXNYLGFBQWF0WCxrQkFBa0IsQ0FBbEIsQ0FBakI7QUFDQSxNQUFJRSxZQUFZRixrQkFBa0IsQ0FBbEIsQ0FBaEI7QUFDQSxNQUFJRyxpQkFBaUJILGtCQUFrQixDQUFsQixDQUFyQjtBQUNBLE1BQUl1WCxnQkFBZ0JsQixvQkFBb0IsSUFBcEIsQ0FBcEI7QUFDQSxNQUFJdEcsZUFBZXNHLG9CQUFvQixLQUFwQixDQUFuQjtBQUNBLE1BQUltQixjQUFjbEIsZUFBZTMzQixNQUFqQztBQUNBLE1BQUk4NEIsWUFBWW5CLGVBQWU1M0IsSUFBL0I7QUFDQSxNQUFJZzVCLGVBQWVwQixlQUFlN1UsT0FBbEM7QUFDQSxNQUFJa1csbUJBQW1CbGUsV0FBV21lLFdBQWxDO0FBQ0EsTUFBSUMsY0FBY3BlLFdBQVd6WixNQUE3QjtBQUNBLE1BQUk4M0IsbUJBQW1CcmUsV0FBV3NlLFdBQWxDO0FBQ0EsTUFBSUMsWUFBWXZlLFdBQVd5RCxJQUEzQjtBQUNBLE1BQUkrYSxZQUFZeGUsV0FBV3llLElBQTNCO0FBQ0EsTUFBSXZiLGFBQWFsRCxXQUFXbUQsS0FBNUI7QUFDQSxNQUFJdWIsZ0JBQWdCMWUsV0FBV3NFLFFBQS9CO0FBQ0EsTUFBSXFhLHNCQUFzQjNlLFdBQVc0ZSxjQUFyQztBQUNBLE1BQUkxZCxXQUFXZ0wsSUFBSSxVQUFKLENBQWY7QUFDQSxNQUFJbkksTUFBTW1JLElBQUksYUFBSixDQUFWO0FBQ0EsTUFBSTJTLG9CQUFvQmhHLElBQUksbUJBQUosQ0FBeEI7QUFDQSxNQUFJaUcsa0JBQWtCakcsSUFBSSxpQkFBSixDQUF0QjtBQUNBLE1BQUlrRyxtQkFBbUJ2QyxPQUFPd0MsTUFBOUI7QUFDQSxNQUFJQyxjQUFjekMsT0FBTzBDLEtBQXpCO0FBQ0EsTUFBSUMsT0FBTzNDLE9BQU8yQyxJQUFsQjtBQUNBLE1BQUlDLGVBQWUsZUFBbkI7QUFFQSxNQUFJQyxPQUFPOVksa0JBQWtCLENBQWxCLEVBQXFCLFVBQVU5RixDQUFWLEVBQWE1WSxNQUFiLEVBQXFCO0FBQ25ELFdBQU95M0IsU0FBU3RjLG1CQUFtQnZDLENBQW5CLEVBQXNCQSxFQUFFcWUsZUFBRixDQUF0QixDQUFULEVBQW9EajNCLE1BQXBELENBQVA7QUFDRCxHQUZVLENBQVg7QUFJQSxNQUFJMDNCLGdCQUFnQmxZLE1BQU0sWUFBWTtBQUNwQztBQUNBLFdBQU8sSUFBSTZWLFVBQUosQ0FBZSxJQUFJc0MsV0FBSixDQUFnQixDQUFDLENBQUQsQ0FBaEIsRUFBcUJDLE1BQXBDLEVBQTRDLENBQTVDLE1BQW1ELENBQTFEO0FBQ0QsR0FIbUIsQ0FBcEI7QUFLQSxNQUFJQyxhQUFhLENBQUMsQ0FBQ3hDLFVBQUYsSUFBZ0IsQ0FBQyxDQUFDQSxXQUFXblMsU0FBWCxFQUFzQmhFLEdBQXhDLElBQStDTSxNQUFNLFlBQVk7QUFDaEYsUUFBSTZWLFVBQUosQ0FBZSxDQUFmLEVBQWtCblcsR0FBbEIsQ0FBc0IsRUFBdEI7QUFDRCxHQUYrRCxDQUFoRTs7QUFJQSxNQUFJNFksV0FBVyxTQUFYQSxRQUFXLENBQVU3NUIsRUFBVixFQUFjODVCLEtBQWQsRUFBcUI7QUFDbEMsUUFBSXZ3QixTQUFTNHBCLFVBQVVuekIsRUFBVixDQUFiO0FBQ0EsUUFBSXVKLFNBQVMsQ0FBVCxJQUFjQSxTQUFTdXdCLEtBQTNCLEVBQWtDLE1BQU1uVyxXQUFXLGVBQVgsQ0FBTjtBQUNsQyxXQUFPcGEsTUFBUDtBQUNELEdBSkQ7O0FBTUEsTUFBSTBWLFdBQVcsU0FBWEEsUUFBVyxDQUFVamYsRUFBVixFQUFjO0FBQzNCLFFBQUlzYSxTQUFTdGEsRUFBVCxLQUFnQm01QixlQUFlbjVCLEVBQW5DLEVBQXVDLE9BQU9BLEVBQVA7QUFDdkMsVUFBTThaLFVBQVU5WixLQUFLLHdCQUFmLENBQU47QUFDRCxHQUhEOztBQUtBLE1BQUl3NUIsV0FBVyxTQUFYQSxRQUFXLENBQVV4YyxDQUFWLEVBQWFqYixNQUFiLEVBQXFCO0FBQ2xDLFFBQUksRUFBRXVZLFNBQVMwQyxDQUFULEtBQWUrYixxQkFBcUIvYixDQUF0QyxDQUFKLEVBQThDO0FBQzVDLFlBQU1sRCxVQUFVLHNDQUFWLENBQU47QUFDRDs7QUFBQyxXQUFPLElBQUlrRCxDQUFKLENBQU1qYixNQUFOLENBQVA7QUFDSCxHQUpEOztBQU1BLE1BQUlnNEIsa0JBQWtCLFNBQWxCQSxlQUFrQixDQUFVcGYsQ0FBVixFQUFhcWYsSUFBYixFQUFtQjtBQUN2QyxXQUFPQyxTQUFTL2MsbUJBQW1CdkMsQ0FBbkIsRUFBc0JBLEVBQUVxZSxlQUFGLENBQXRCLENBQVQsRUFBb0RnQixJQUFwRCxDQUFQO0FBQ0QsR0FGRDs7QUFJQSxNQUFJQyxXQUFXLFNBQVhBLFFBQVcsQ0FBVWpkLENBQVYsRUFBYWdkLElBQWIsRUFBbUI7QUFDaEMsUUFBSS81QixRQUFRLENBQVo7QUFDQSxRQUFJOEIsU0FBU2k0QixLQUFLajRCLE1BQWxCO0FBQ0EsUUFBSTBDLFNBQVMrMEIsU0FBU3hjLENBQVQsRUFBWWpiLE1BQVosQ0FBYjs7QUFDQSxXQUFPQSxTQUFTOUIsS0FBaEI7QUFBdUJ3RSxhQUFPeEUsS0FBUCxJQUFnQis1QixLQUFLLzVCLE9BQUwsQ0FBaEI7QUFBdkI7O0FBQ0EsV0FBT3dFLE1BQVA7QUFDRCxHQU5EOztBQVFBLE1BQUl5MUIsWUFBWSxTQUFaQSxTQUFZLENBQVVsNkIsRUFBVixFQUFjTCxHQUFkLEVBQW1CdzZCLFFBQW5CLEVBQTZCO0FBQzNDMWIsT0FBR3plLEVBQUgsRUFBT0wsR0FBUCxFQUFZO0FBQUVxZ0IsV0FBSyxlQUFZO0FBQUUsZUFBTyxLQUFLb2EsRUFBTCxDQUFRRCxRQUFSLENBQVA7QUFBMkI7QUFBaEQsS0FBWjtBQUNELEdBRkQ7O0FBSUEsTUFBSUUsUUFBUSxTQUFTdDVCLElBQVQsQ0FBY21rQjtBQUFPO0FBQXJCLElBQTZDO0FBQ3ZELFFBQUl2SyxJQUFJSixTQUFTMkssTUFBVCxDQUFSO0FBQ0EsUUFBSWxLLE9BQU9GLFVBQVUvWSxNQUFyQjtBQUNBLFFBQUl1NEIsUUFBUXRmLE9BQU8sQ0FBUCxHQUFXRixVQUFVLENBQVYsQ0FBWCxHQUEwQjFaLFNBQXRDO0FBQ0EsUUFBSWt4QixVQUFVZ0ksVUFBVWw1QixTQUF4QjtBQUNBLFFBQUkwbUIsU0FBU0gsVUFBVWhOLENBQVYsQ0FBYjtBQUNBLFFBQUlwYixDQUFKLEVBQU93QyxNQUFQLEVBQWUzQyxNQUFmLEVBQXVCcUYsTUFBdkIsRUFBK0JvYSxJQUEvQixFQUFxQ2tKLFFBQXJDOztBQUNBLFFBQUlELFVBQVUxbUIsU0FBVixJQUF1QixDQUFDc21CLFlBQVlJLE1BQVosQ0FBNUIsRUFBaUQ7QUFDL0MsV0FBS0MsV0FBV0QsT0FBTy9KLElBQVAsQ0FBWXBELENBQVosQ0FBWCxFQUEyQnZiLFNBQVMsRUFBcEMsRUFBd0NHLElBQUksQ0FBakQsRUFBb0QsQ0FBQyxDQUFDc2YsT0FBT2tKLFNBQVNsbUIsSUFBVCxFQUFSLEVBQXlCbW1CLElBQTlFLEVBQW9Gem9CLEdBQXBGLEVBQXlGO0FBQ3ZGSCxlQUFPd0MsSUFBUCxDQUFZaWQsS0FBS25nQixLQUFqQjtBQUNEOztBQUFDaWMsVUFBSXZiLE1BQUo7QUFDSDs7QUFDRCxRQUFJa3pCLFdBQVd0WCxPQUFPLENBQXRCLEVBQXlCc2YsUUFBUTVlLElBQUk0ZSxLQUFKLEVBQVd4ZixVQUFVLENBQVYsQ0FBWCxFQUF5QixDQUF6QixDQUFSOztBQUN6QixTQUFLdmIsSUFBSSxDQUFKLEVBQU93QyxTQUFTMFksU0FBU0UsRUFBRTVZLE1BQVgsQ0FBaEIsRUFBb0MwQyxTQUFTKzBCLFNBQVMsSUFBVCxFQUFlejNCLE1BQWYsQ0FBbEQsRUFBMEVBLFNBQVN4QyxDQUFuRixFQUFzRkEsR0FBdEYsRUFBMkY7QUFDekZrRixhQUFPbEYsQ0FBUCxJQUFZK3lCLFVBQVVnSSxNQUFNM2YsRUFBRXBiLENBQUYsQ0FBTixFQUFZQSxDQUFaLENBQVYsR0FBMkJvYixFQUFFcGIsQ0FBRixDQUF2QztBQUNEOztBQUNELFdBQU9rRixNQUFQO0FBQ0QsR0FqQkQ7O0FBbUJBLE1BQUk4MUIsTUFBTSxTQUFTOUgsRUFBVDtBQUFZO0FBQWdCO0FBQ3BDLFFBQUl4eUIsUUFBUSxDQUFaO0FBQ0EsUUFBSThCLFNBQVMrWSxVQUFVL1ksTUFBdkI7QUFDQSxRQUFJMEMsU0FBUyswQixTQUFTLElBQVQsRUFBZXozQixNQUFmLENBQWI7O0FBQ0EsV0FBT0EsU0FBUzlCLEtBQWhCO0FBQXVCd0UsYUFBT3hFLEtBQVAsSUFBZ0I2YSxVQUFVN2EsT0FBVixDQUFoQjtBQUF2Qjs7QUFDQSxXQUFPd0UsTUFBUDtBQUNELEdBTkQsQ0FoSjZCLENBd0o3Qjs7O0FBQ0EsTUFBSSsxQixnQkFBZ0IsQ0FBQyxDQUFDcEQsVUFBRixJQUFnQjdWLE1BQU0sWUFBWTtBQUFFc1gsd0JBQW9COWEsSUFBcEIsQ0FBeUIsSUFBSXFaLFVBQUosQ0FBZSxDQUFmLENBQXpCO0FBQThDLEdBQWxFLENBQXBDOztBQUVBLE1BQUlxRCxrQkFBa0IsU0FBUzNCLGNBQVQsR0FBMEI7QUFDOUMsV0FBT0Qsb0JBQW9CM1YsS0FBcEIsQ0FBMEJzWCxnQkFBZ0JwZCxXQUFXVyxJQUFYLENBQWdCa0IsU0FBUyxJQUFULENBQWhCLENBQWhCLEdBQWtEQSxTQUFTLElBQVQsQ0FBNUUsRUFBNEZuRSxTQUE1RixDQUFQO0FBQ0QsR0FGRDs7QUFJQSxNQUFJaUgsUUFBUTtBQUNWckgsZ0JBQVksU0FBU0EsVUFBVCxDQUFvQmpFLE1BQXBCLEVBQTRCcFg7QUFBTTtBQUFsQyxNQUErQztBQUN6RCxhQUFPNDNCLGdCQUFnQmxaLElBQWhCLENBQXFCa0IsU0FBUyxJQUFULENBQXJCLEVBQXFDeEksTUFBckMsRUFBNkNwWCxLQUE3QyxFQUFvRHliLFVBQVUvWSxNQUFWLEdBQW1CLENBQW5CLEdBQXVCK1ksVUFBVSxDQUFWLENBQXZCLEdBQXNDMVosU0FBMUYsQ0FBUDtBQUNELEtBSFM7QUFJVmEsV0FBTyxTQUFTQSxLQUFULENBQWVvYTtBQUFXO0FBQTFCLE1BQTJDO0FBQ2hELGFBQU8wYixXQUFXOVksU0FBUyxJQUFULENBQVgsRUFBMkI1QyxVQUEzQixFQUF1Q3ZCLFVBQVUvWSxNQUFWLEdBQW1CLENBQW5CLEdBQXVCK1ksVUFBVSxDQUFWLENBQXZCLEdBQXNDMVosU0FBN0UsQ0FBUDtBQUNELEtBTlM7QUFPVjBXLFVBQU0sU0FBU0EsSUFBVCxDQUFjcFo7QUFBTTtBQUFwQixNQUF3QztBQUFFO0FBQzlDLGFBQU9zNEIsVUFBVTlULEtBQVYsQ0FBZ0JqRSxTQUFTLElBQVQsQ0FBaEIsRUFBZ0NuRSxTQUFoQyxDQUFQO0FBQ0QsS0FUUztBQVVWdmEsWUFBUSxTQUFTQSxNQUFULENBQWdCOGI7QUFBVztBQUEzQixNQUE0QztBQUNsRCxhQUFPMGQsZ0JBQWdCLElBQWhCLEVBQXNCbEMsWUFBWTVZLFNBQVMsSUFBVCxDQUFaLEVBQTRCNUMsVUFBNUIsRUFDM0J2QixVQUFVL1ksTUFBVixHQUFtQixDQUFuQixHQUF1QitZLFVBQVUsQ0FBVixDQUF2QixHQUFzQzFaLFNBRFgsQ0FBdEIsQ0FBUDtBQUVELEtBYlM7QUFjVnM1QixVQUFNLFNBQVNBLElBQVQsQ0FBY2w2QjtBQUFVO0FBQXhCLE1BQXlDO0FBQzdDLGFBQU9tZ0IsVUFBVTFCLFNBQVMsSUFBVCxDQUFWLEVBQTBCemUsU0FBMUIsRUFBcUNzYSxVQUFVL1ksTUFBVixHQUFtQixDQUFuQixHQUF1QitZLFVBQVUsQ0FBVixDQUF2QixHQUFzQzFaLFNBQTNFLENBQVA7QUFDRCxLQWhCUztBQWlCVnU1QixlQUFXLFNBQVNBLFNBQVQsQ0FBbUJuNkI7QUFBVTtBQUE3QixNQUE4QztBQUN2RCxhQUFPb2dCLGVBQWUzQixTQUFTLElBQVQsQ0FBZixFQUErQnplLFNBQS9CLEVBQTBDc2EsVUFBVS9ZLE1BQVYsR0FBbUIsQ0FBbkIsR0FBdUIrWSxVQUFVLENBQVYsQ0FBdkIsR0FBc0MxWixTQUFoRixDQUFQO0FBQ0QsS0FuQlM7QUFvQlZzVixhQUFTLFNBQVNBLE9BQVQsQ0FBaUIyRjtBQUFXO0FBQTVCLE1BQTZDO0FBQ3BEdWIsbUJBQWEzWSxTQUFTLElBQVQsQ0FBYixFQUE2QjVDLFVBQTdCLEVBQXlDdkIsVUFBVS9ZLE1BQVYsR0FBbUIsQ0FBbkIsR0FBdUIrWSxVQUFVLENBQVYsQ0FBdkIsR0FBc0MxWixTQUEvRTtBQUNELEtBdEJTO0FBdUJWdzVCLGFBQVMsU0FBU0EsT0FBVCxDQUFpQkM7QUFBYztBQUEvQixNQUFrRDtBQUN6RCxhQUFPckssYUFBYXZSLFNBQVMsSUFBVCxDQUFiLEVBQTZCNGIsYUFBN0IsRUFBNEMvZixVQUFVL1ksTUFBVixHQUFtQixDQUFuQixHQUF1QitZLFVBQVUsQ0FBVixDQUF2QixHQUFzQzFaLFNBQWxGLENBQVA7QUFDRCxLQXpCUztBQTBCVjA1QixjQUFVLFNBQVNBLFFBQVQsQ0FBa0JEO0FBQWM7QUFBaEMsTUFBbUQ7QUFDM0QsYUFBTzdDLGNBQWMvWSxTQUFTLElBQVQsQ0FBZCxFQUE4QjRiLGFBQTlCLEVBQTZDL2YsVUFBVS9ZLE1BQVYsR0FBbUIsQ0FBbkIsR0FBdUIrWSxVQUFVLENBQVYsQ0FBdkIsR0FBc0MxWixTQUFuRixDQUFQO0FBQ0QsS0E1QlM7QUE2QlZ1YyxVQUFNLFNBQVNBLElBQVQsQ0FBY29kLFNBQWQsRUFBeUI7QUFBRTtBQUMvQixhQUFPdEMsVUFBVXZWLEtBQVYsQ0FBZ0JqRSxTQUFTLElBQVQsQ0FBaEIsRUFBZ0NuRSxTQUFoQyxDQUFQO0FBQ0QsS0EvQlM7QUFnQ1Z1ZCxpQkFBYSxTQUFTQSxXQUFULENBQXFCd0M7QUFBYztBQUFuQyxNQUFzRDtBQUFFO0FBQ25FLGFBQU96QyxpQkFBaUJsVixLQUFqQixDQUF1QmpFLFNBQVMsSUFBVCxDQUF2QixFQUF1Q25FLFNBQXZDLENBQVA7QUFDRCxLQWxDUztBQW1DVjVhLFNBQUssU0FBU0EsR0FBVCxDQUFhbzZCO0FBQU07QUFBbkIsTUFBb0M7QUFDdkMsYUFBT2YsS0FBS3RhLFNBQVMsSUFBVCxDQUFMLEVBQXFCcWIsS0FBckIsRUFBNEJ4ZixVQUFVL1ksTUFBVixHQUFtQixDQUFuQixHQUF1QitZLFVBQVUsQ0FBVixDQUF2QixHQUFzQzFaLFNBQWxFLENBQVA7QUFDRCxLQXJDUztBQXNDVlgsWUFBUSxTQUFTQSxNQUFULENBQWdCNGI7QUFBVztBQUEzQixNQUFpRDtBQUFFO0FBQ3pELGFBQU9pYyxZQUFZcFYsS0FBWixDQUFrQmpFLFNBQVMsSUFBVCxDQUFsQixFQUFrQ25FLFNBQWxDLENBQVA7QUFDRCxLQXhDUztBQXlDVjBkLGlCQUFhLFNBQVNBLFdBQVQsQ0FBcUJuYztBQUFXO0FBQWhDLE1BQXNEO0FBQUU7QUFDbkUsYUFBT2tjLGlCQUFpQnJWLEtBQWpCLENBQXVCakUsU0FBUyxJQUFULENBQXZCLEVBQXVDbkUsU0FBdkMsQ0FBUDtBQUNELEtBM0NTO0FBNENWa2dCLGFBQVMsU0FBU0EsT0FBVCxHQUFtQjtBQUMxQixVQUFJMWUsT0FBTyxJQUFYO0FBQ0EsVUFBSXZhLFNBQVNrZCxTQUFTM0MsSUFBVCxFQUFldmEsTUFBNUI7QUFDQSxVQUFJazVCLFNBQVN2MUIsS0FBSzhpQixLQUFMLENBQVd6bUIsU0FBUyxDQUFwQixDQUFiO0FBQ0EsVUFBSTlCLFFBQVEsQ0FBWjtBQUNBLFVBQUl2QixLQUFKOztBQUNBLGFBQU91QixRQUFRZzdCLE1BQWYsRUFBdUI7QUFDckJ2OEIsZ0JBQVE0ZCxLQUFLcmMsS0FBTCxDQUFSO0FBQ0FxYyxhQUFLcmMsT0FBTCxJQUFnQnFjLEtBQUssRUFBRXZhLE1BQVAsQ0FBaEI7QUFDQXVhLGFBQUt2YSxNQUFMLElBQWVyRCxLQUFmO0FBQ0Q7O0FBQUMsYUFBTzRkLElBQVA7QUFDSCxLQXZEUztBQXdEVnRhLFVBQU0sU0FBU0EsSUFBVCxDQUFjcWE7QUFBVztBQUF6QixNQUEwQztBQUM5QyxhQUFPeWIsVUFBVTdZLFNBQVMsSUFBVCxDQUFWLEVBQTBCNUMsVUFBMUIsRUFBc0N2QixVQUFVL1ksTUFBVixHQUFtQixDQUFuQixHQUF1QitZLFVBQVUsQ0FBVixDQUF2QixHQUFzQzFaLFNBQTVFLENBQVA7QUFDRCxLQTFEUztBQTJEVnUzQixVQUFNLFNBQVNBLElBQVQsQ0FBY3VDLFNBQWQsRUFBeUI7QUFDN0IsYUFBT3hDLFVBQVUzYSxJQUFWLENBQWVrQixTQUFTLElBQVQsQ0FBZixFQUErQmljLFNBQS9CLENBQVA7QUFDRCxLQTdEUztBQThEVkMsY0FBVSxTQUFTQSxRQUFULENBQWtCQyxLQUFsQixFQUF5QjkxQixHQUF6QixFQUE4QjtBQUN0QyxVQUFJcVYsSUFBSXNFLFNBQVMsSUFBVCxDQUFSO0FBQ0EsVUFBSWxkLFNBQVM0WSxFQUFFNVksTUFBZjtBQUNBLFVBQUlzNUIsU0FBUzdnQixnQkFBZ0I0Z0IsS0FBaEIsRUFBdUJyNUIsTUFBdkIsQ0FBYjtBQUNBLGFBQU8sS0FBS21iLG1CQUFtQnZDLENBQW5CLEVBQXNCQSxFQUFFcWUsZUFBRixDQUF0QixDQUFMLEVBQ0xyZSxFQUFFZ2YsTUFERyxFQUVMaGYsRUFBRTJnQixVQUFGLEdBQWVELFNBQVMxZ0IsRUFBRTRjLGlCQUZyQixFQUdMOWMsU0FBUyxDQUFDblYsUUFBUWxFLFNBQVIsR0FBb0JXLE1BQXBCLEdBQTZCeVksZ0JBQWdCbFYsR0FBaEIsRUFBcUJ2RCxNQUFyQixDQUE5QixJQUE4RHM1QixNQUF2RSxDQUhLLENBQVA7QUFLRDtBQXZFUyxHQUFaOztBQTBFQSxNQUFJRSxTQUFTLFNBQVNsZSxLQUFULENBQWVoZSxLQUFmLEVBQXNCaUcsR0FBdEIsRUFBMkI7QUFDdEMsV0FBT3kwQixnQkFBZ0IsSUFBaEIsRUFBc0IzYyxXQUFXVyxJQUFYLENBQWdCa0IsU0FBUyxJQUFULENBQWhCLEVBQWdDNWYsS0FBaEMsRUFBdUNpRyxHQUF2QyxDQUF0QixDQUFQO0FBQ0QsR0FGRDs7QUFJQSxNQUFJazJCLE9BQU8sU0FBU3ZhLEdBQVQsQ0FBYXdhO0FBQVU7QUFBdkIsSUFBdUM7QUFDaER4YyxhQUFTLElBQVQ7QUFDQSxRQUFJMVYsU0FBU3N3QixTQUFTL2UsVUFBVSxDQUFWLENBQVQsRUFBdUIsQ0FBdkIsQ0FBYjtBQUNBLFFBQUkvWSxTQUFTLEtBQUtBLE1BQWxCO0FBQ0EsUUFBSXdCLE1BQU1nWCxTQUFTa2hCLFNBQVQsQ0FBVjtBQUNBLFFBQUk3Z0IsTUFBTUgsU0FBU2xYLElBQUl4QixNQUFiLENBQVY7QUFDQSxRQUFJOUIsUUFBUSxDQUFaO0FBQ0EsUUFBSTJhLE1BQU1yUixNQUFOLEdBQWV4SCxNQUFuQixFQUEyQixNQUFNNGhCLFdBQVcyVixZQUFYLENBQU47O0FBQzNCLFdBQU9yNUIsUUFBUTJhLEdBQWY7QUFBb0IsV0FBS3JSLFNBQVN0SixLQUFkLElBQXVCc0QsSUFBSXRELE9BQUosQ0FBdkI7QUFBcEI7QUFDRCxHQVREOztBQVdBLE1BQUl5N0IsYUFBYTtBQUNmeFosYUFBUyxTQUFTQSxPQUFULEdBQW1CO0FBQzFCLGFBQU9pVyxhQUFhcGEsSUFBYixDQUFrQmtCLFNBQVMsSUFBVCxDQUFsQixDQUFQO0FBQ0QsS0FIYztBQUlmOWYsVUFBTSxTQUFTQSxJQUFULEdBQWdCO0FBQ3BCLGFBQU8rNEIsVUFBVW5hLElBQVYsQ0FBZWtCLFNBQVMsSUFBVCxDQUFmLENBQVA7QUFDRCxLQU5jO0FBT2Y3ZixZQUFRLFNBQVNBLE1BQVQsR0FBa0I7QUFDeEIsYUFBTzY0QixZQUFZbGEsSUFBWixDQUFpQmtCLFNBQVMsSUFBVCxDQUFqQixDQUFQO0FBQ0Q7QUFUYyxHQUFqQjs7QUFZQSxNQUFJMGMsWUFBWSxTQUFaQSxTQUFZLENBQVVsbEIsTUFBVixFQUFrQjlXLEdBQWxCLEVBQXVCO0FBQ3JDLFdBQU8yYSxTQUFTN0QsTUFBVCxLQUNGQSxPQUFPMGlCLFdBQVAsQ0FERSxJQUVGLE9BQU94NUIsR0FBUCxJQUFjLFFBRlosSUFHRkEsT0FBTzhXLE1BSEwsSUFJRmdRLE9BQU8sQ0FBQzltQixHQUFSLEtBQWdCOG1CLE9BQU85bUIsR0FBUCxDQUpyQjtBQUtELEdBTkQ7O0FBT0EsTUFBSWk4QixXQUFXLFNBQVM3TCx3QkFBVCxDQUFrQ3RaLE1BQWxDLEVBQTBDOVcsR0FBMUMsRUFBK0M7QUFDNUQsV0FBT2c4QixVQUFVbGxCLE1BQVYsRUFBa0I5VyxNQUFNMmtCLFlBQVkza0IsR0FBWixFQUFpQixJQUFqQixDQUF4QixJQUNIaTNCLGFBQWEsQ0FBYixFQUFnQm5nQixPQUFPOVcsR0FBUCxDQUFoQixDQURHLEdBRUhtd0IsS0FBS3JaLE1BQUwsRUFBYTlXLEdBQWIsQ0FGSjtBQUdELEdBSkQ7O0FBS0EsTUFBSWs4QixXQUFXLFNBQVNyOUIsY0FBVCxDQUF3QmlZLE1BQXhCLEVBQWdDOVcsR0FBaEMsRUFBcUNtOEIsSUFBckMsRUFBMkM7QUFDeEQsUUFBSUgsVUFBVWxsQixNQUFWLEVBQWtCOVcsTUFBTTJrQixZQUFZM2tCLEdBQVosRUFBaUIsSUFBakIsQ0FBeEIsS0FDQzJhLFNBQVN3aEIsSUFBVCxDQURELElBRUMxNUIsSUFBSTA1QixJQUFKLEVBQVUsT0FBVixDQUZELElBR0MsQ0FBQzE1QixJQUFJMDVCLElBQUosRUFBVSxLQUFWLENBSEYsSUFJQyxDQUFDMTVCLElBQUkwNUIsSUFBSixFQUFVLEtBQVYsQ0FKRixDQUtGO0FBTEUsT0FNQyxDQUFDQSxLQUFLakssWUFOUCxLQU9FLENBQUN6dkIsSUFBSTA1QixJQUFKLEVBQVUsVUFBVixDQUFELElBQTBCQSxLQUFLaEssUUFQakMsTUFRRSxDQUFDMXZCLElBQUkwNUIsSUFBSixFQUFVLFlBQVYsQ0FBRCxJQUE0QkEsS0FBS2xLLFVBUm5DLENBQUosRUFTRTtBQUNBbmIsYUFBTzlXLEdBQVAsSUFBY204QixLQUFLcDlCLEtBQW5CO0FBQ0EsYUFBTytYLE1BQVA7QUFDRDs7QUFBQyxXQUFPZ0ksR0FBR2hJLE1BQUgsRUFBVzlXLEdBQVgsRUFBZ0JtOEIsSUFBaEIsQ0FBUDtBQUNILEdBZEQ7O0FBZ0JBLE1BQUksQ0FBQzdDLGdCQUFMLEVBQXVCO0FBQ3JCOUIsVUFBTTNhLENBQU4sR0FBVW9mLFFBQVY7QUFDQTFFLFFBQUkxYSxDQUFKLEdBQVFxZixRQUFSO0FBQ0Q7O0FBRUR6YSxVQUFRQSxRQUFRa0UsQ0FBUixHQUFZbEUsUUFBUTVELENBQVIsR0FBWSxDQUFDeWIsZ0JBQWpDLEVBQW1ELFFBQW5ELEVBQTZEO0FBQzNEbEosOEJBQTBCNkwsUUFEaUM7QUFFM0RwOUIsb0JBQWdCcTlCO0FBRjJDLEdBQTdEOztBQUtBLE1BQUl0YSxNQUFNLFlBQVk7QUFBRXFYLGtCQUFjN2EsSUFBZCxDQUFtQixFQUFuQjtBQUF5QixHQUE3QyxDQUFKLEVBQW9EO0FBQ2xENmEsb0JBQWdCQyxzQkFBc0IsU0FBU3JhLFFBQVQsR0FBb0I7QUFDeEQsYUFBT2lhLFVBQVUxYSxJQUFWLENBQWUsSUFBZixDQUFQO0FBQ0QsS0FGRDtBQUdEOztBQUVELE1BQUlnZSx3QkFBd0JyZCxZQUFZLEVBQVosRUFBZ0JxRCxLQUFoQixDQUE1QjtBQUNBckQsY0FBWXFkLHFCQUFaLEVBQW1DTCxVQUFuQztBQUNBMVcsT0FBSytXLHFCQUFMLEVBQTRCM2dCLFFBQTVCLEVBQXNDc2dCLFdBQVd0OEIsTUFBakQ7QUFDQXNmLGNBQVlxZCxxQkFBWixFQUFtQztBQUNqQzFlLFdBQU9rZSxNQUQwQjtBQUVqQ3RhLFNBQUt1YSxJQUY0QjtBQUdqQ3ZlLGlCQUFhLHVCQUFZO0FBQUU7QUFBWSxLQUhOO0FBSWpDdUIsY0FBVW9hLGFBSnVCO0FBS2pDRSxvQkFBZ0IyQjtBQUxpQixHQUFuQztBQU9BUCxZQUFVNkIscUJBQVYsRUFBaUMsUUFBakMsRUFBMkMsR0FBM0M7QUFDQTdCLFlBQVU2QixxQkFBVixFQUFpQyxZQUFqQyxFQUErQyxHQUEvQztBQUNBN0IsWUFBVTZCLHFCQUFWLEVBQWlDLFlBQWpDLEVBQStDLEdBQS9DO0FBQ0E3QixZQUFVNkIscUJBQVYsRUFBaUMsUUFBakMsRUFBMkMsR0FBM0M7QUFDQXRkLEtBQUdzZCxxQkFBSCxFQUEwQjlkLEdBQTFCLEVBQStCO0FBQzdCK0IsU0FBSyxlQUFZO0FBQUUsYUFBTyxLQUFLbVosV0FBTCxDQUFQO0FBQTJCO0FBRGpCLEdBQS9CLEVBOVQ2QixDQWtVN0I7O0FBQ0F0ZixTQUFPcGIsT0FBUCxHQUFpQixVQUFVd2pCLEdBQVYsRUFBZTZYLEtBQWYsRUFBc0JyYSxPQUF0QixFQUErQnVjLE9BQS9CLEVBQXdDO0FBQ3ZEQSxjQUFVLENBQUMsQ0FBQ0EsT0FBWjtBQUNBLFFBQUl0YyxPQUFPdUMsT0FBTytaLFVBQVUsU0FBVixHQUFzQixFQUE3QixJQUFtQyxPQUE5QztBQUNBLFFBQUlDLFNBQVMsUUFBUWhhLEdBQXJCO0FBQ0EsUUFBSWlhLFNBQVMsUUFBUWphLEdBQXJCO0FBQ0EsUUFBSWthLGFBQWEvOUIsT0FBT3NoQixJQUFQLENBQWpCO0FBQ0EsUUFBSW9DLE9BQU9xYSxjQUFjLEVBQXpCO0FBQ0EsUUFBSUMsTUFBTUQsY0FBY25ULGVBQWVtVCxVQUFmLENBQXhCO0FBQ0EsUUFBSTNTLFNBQVMsQ0FBQzJTLFVBQUQsSUFBZSxDQUFDekYsT0FBTzJGLEdBQXBDO0FBQ0EsUUFBSTFoQixJQUFJLEVBQVI7QUFDQSxRQUFJMmhCLHNCQUFzQkgsY0FBY0EsV0FBV2xYLFNBQVgsQ0FBeEM7O0FBQ0EsUUFBSXNYLFNBQVMsU0FBVEEsTUFBUyxDQUFVamdCLElBQVYsRUFBZ0JyYyxLQUFoQixFQUF1QjtBQUNsQyxVQUFJNmYsT0FBT3hELEtBQUs4ZCxFQUFoQjtBQUNBLGFBQU90YSxLQUFLL1QsQ0FBTCxDQUFPa3dCLE1BQVAsRUFBZWg4QixRQUFRNjVCLEtBQVIsR0FBZ0JoYSxLQUFLMGMsQ0FBcEMsRUFBdUMvQyxhQUF2QyxDQUFQO0FBQ0QsS0FIRDs7QUFJQSxRQUFJZ0QsU0FBUyxTQUFUQSxNQUFTLENBQVVuZ0IsSUFBVixFQUFnQnJjLEtBQWhCLEVBQXVCdkIsS0FBdkIsRUFBOEI7QUFDekMsVUFBSW9oQixPQUFPeEQsS0FBSzhkLEVBQWhCO0FBQ0EsVUFBSTRCLE9BQUosRUFBYXQ5QixRQUFRLENBQUNBLFFBQVFnSCxLQUFLZzNCLEtBQUwsQ0FBV2grQixLQUFYLENBQVQsSUFBOEIsQ0FBOUIsR0FBa0MsQ0FBbEMsR0FBc0NBLFFBQVEsSUFBUixHQUFlLElBQWYsR0FBc0JBLFFBQVEsSUFBNUU7QUFDYm9oQixXQUFLL1QsQ0FBTCxDQUFPbXdCLE1BQVAsRUFBZWo4QixRQUFRNjVCLEtBQVIsR0FBZ0JoYSxLQUFLMGMsQ0FBcEMsRUFBdUM5OUIsS0FBdkMsRUFBOEMrNkIsYUFBOUM7QUFDRCxLQUpEOztBQUtBLFFBQUlrRCxhQUFhLFNBQWJBLFVBQWEsQ0FBVXJnQixJQUFWLEVBQWdCcmMsS0FBaEIsRUFBdUI7QUFDdEN3ZSxTQUFHbkMsSUFBSCxFQUFTcmMsS0FBVCxFQUFnQjtBQUNkK2YsYUFBSyxlQUFZO0FBQ2YsaUJBQU91YyxPQUFPLElBQVAsRUFBYXQ4QixLQUFiLENBQVA7QUFDRCxTQUhhO0FBSWRnaEIsYUFBSyxhQUFVdmlCLEtBQVYsRUFBaUI7QUFDcEIsaUJBQU8rOUIsT0FBTyxJQUFQLEVBQWF4OEIsS0FBYixFQUFvQnZCLEtBQXBCLENBQVA7QUFDRCxTQU5hO0FBT2RrekIsb0JBQVk7QUFQRSxPQUFoQjtBQVNELEtBVkQ7O0FBV0EsUUFBSXBJLE1BQUosRUFBWTtBQUNWMlMsbUJBQWExYyxRQUFRLFVBQVVuRCxJQUFWLEVBQWdCd0QsSUFBaEIsRUFBc0I4YyxPQUF0QixFQUErQkMsT0FBL0IsRUFBd0M7QUFDM0RsZSxtQkFBV3JDLElBQVgsRUFBaUI2ZixVQUFqQixFQUE2QnpjLElBQTdCLEVBQW1DLElBQW5DO0FBQ0EsWUFBSXpmLFFBQVEsQ0FBWjtBQUNBLFlBQUlzSixTQUFTLENBQWI7QUFDQSxZQUFJb3dCLE1BQUosRUFBWW1ELFVBQVosRUFBd0IvNkIsTUFBeEIsRUFBZ0NnN0IsS0FBaEM7O0FBQ0EsWUFBSSxDQUFDemlCLFNBQVN3RixJQUFULENBQUwsRUFBcUI7QUFDbkIvZCxtQkFBUzgwQixRQUFRL1csSUFBUixDQUFUO0FBQ0FnZCx1QkFBYS82QixTQUFTKzNCLEtBQXRCO0FBQ0FILG1CQUFTLElBQUluQyxZQUFKLENBQWlCc0YsVUFBakIsQ0FBVDtBQUNELFNBSkQsTUFJTyxJQUFJaGQsZ0JBQWdCMFgsWUFBaEIsSUFBZ0MsQ0FBQ3VGLFFBQVF6YyxRQUFRUixJQUFSLENBQVQsS0FBMkJ1WCxZQUEzRCxJQUEyRTBGLFNBQVN6RixhQUF4RixFQUF1RztBQUM1R3FDLG1CQUFTN1osSUFBVDtBQUNBdlcsbUJBQVNzd0IsU0FBUytDLE9BQVQsRUFBa0I5QyxLQUFsQixDQUFUO0FBQ0EsY0FBSWtELE9BQU9sZCxLQUFLZ2QsVUFBaEI7O0FBQ0EsY0FBSUQsWUFBWXo3QixTQUFoQixFQUEyQjtBQUN6QixnQkFBSTQ3QixPQUFPbEQsS0FBWCxFQUFrQixNQUFNblcsV0FBVzJWLFlBQVgsQ0FBTjtBQUNsQndELHlCQUFhRSxPQUFPenpCLE1BQXBCO0FBQ0EsZ0JBQUl1ekIsYUFBYSxDQUFqQixFQUFvQixNQUFNblosV0FBVzJWLFlBQVgsQ0FBTjtBQUNyQixXQUpELE1BSU87QUFDTHdELHlCQUFhcmlCLFNBQVNvaUIsT0FBVCxJQUFvQi9DLEtBQWpDO0FBQ0EsZ0JBQUlnRCxhQUFhdnpCLE1BQWIsR0FBc0J5ekIsSUFBMUIsRUFBZ0MsTUFBTXJaLFdBQVcyVixZQUFYLENBQU47QUFDakM7O0FBQ0R2M0IsbUJBQVMrNkIsYUFBYWhELEtBQXRCO0FBQ0QsU0FiTSxNQWFBLElBQUlYLGVBQWVyWixJQUFuQixFQUF5QjtBQUM5QixpQkFBT21hLFNBQVNrQyxVQUFULEVBQXFCcmMsSUFBckIsQ0FBUDtBQUNELFNBRk0sTUFFQTtBQUNMLGlCQUFPdWEsTUFBTXRjLElBQU4sQ0FBV29lLFVBQVgsRUFBdUJyYyxJQUF2QixDQUFQO0FBQ0Q7O0FBQ0RrRixhQUFLMUksSUFBTCxFQUFXLElBQVgsRUFBaUI7QUFDZnJULGFBQUcwd0IsTUFEWTtBQUVmNkMsYUFBR2p6QixNQUZZO0FBR2ZPLGFBQUdnekIsVUFIWTtBQUlmMWUsYUFBR3JjLE1BSlk7QUFLZmdLLGFBQUcsSUFBSTJyQixTQUFKLENBQWNpQyxNQUFkO0FBTFksU0FBakI7O0FBT0EsZUFBTzE1QixRQUFROEIsTUFBZjtBQUF1QjQ2QixxQkFBV3JnQixJQUFYLEVBQWlCcmMsT0FBakI7QUFBdkI7QUFDRCxPQW5DWSxDQUFiO0FBb0NBcThCLDRCQUFzQkgsV0FBV2xYLFNBQVgsSUFBd0JuUSxPQUFPaW5CLHFCQUFQLENBQTlDO0FBQ0EvVyxXQUFLc1gsbUJBQUwsRUFBMEIsYUFBMUIsRUFBeUNILFVBQXpDO0FBQ0QsS0F2Q0QsTUF1Q08sSUFBSSxDQUFDNWEsTUFBTSxZQUFZO0FBQzVCNGEsaUJBQVcsQ0FBWDtBQUNELEtBRlcsQ0FBRCxJQUVMLENBQUM1YSxNQUFNLFlBQVk7QUFDdkIsVUFBSTRhLFVBQUosQ0FBZSxDQUFDLENBQWhCLEVBRHVCLENBQ0g7QUFDckIsS0FGTSxDQUZJLElBSUwsQ0FBQzNhLFlBQVksVUFBVXJHLElBQVYsRUFBZ0I7QUFDakMsVUFBSWdoQixVQUFKLEdBRGlDLENBQ2Y7O0FBQ2xCLFVBQUlBLFVBQUosQ0FBZSxJQUFmLEVBRmlDLENBRVg7O0FBQ3RCLFVBQUlBLFVBQUosQ0FBZSxHQUFmLEVBSGlDLENBR1o7O0FBQ3JCLFVBQUlBLFVBQUosQ0FBZWhoQixJQUFmLEVBSmlDLENBSVg7QUFDdkIsS0FMTSxFQUtKLElBTEksQ0FKQSxFQVNHO0FBQ1JnaEIsbUJBQWExYyxRQUFRLFVBQVVuRCxJQUFWLEVBQWdCd0QsSUFBaEIsRUFBc0I4YyxPQUF0QixFQUErQkMsT0FBL0IsRUFBd0M7QUFDM0RsZSxtQkFBV3JDLElBQVgsRUFBaUI2ZixVQUFqQixFQUE2QnpjLElBQTdCO0FBQ0EsWUFBSXFkLEtBQUosQ0FGMkQsQ0FHM0Q7QUFDQTs7QUFDQSxZQUFJLENBQUN6aUIsU0FBU3dGLElBQVQsQ0FBTCxFQUFxQixPQUFPLElBQUlnQyxJQUFKLENBQVMrVSxRQUFRL1csSUFBUixDQUFULENBQVA7O0FBQ3JCLFlBQUlBLGdCQUFnQjBYLFlBQWhCLElBQWdDLENBQUN1RixRQUFRemMsUUFBUVIsSUFBUixDQUFULEtBQTJCdVgsWUFBM0QsSUFBMkUwRixTQUFTekYsYUFBeEYsRUFBdUc7QUFDckcsaUJBQU91RixZQUFZejdCLFNBQVosR0FDSCxJQUFJMGdCLElBQUosQ0FBU2hDLElBQVQsRUFBZStaLFNBQVMrQyxPQUFULEVBQWtCOUMsS0FBbEIsQ0FBZixFQUF5QytDLE9BQXpDLENBREcsR0FFSEQsWUFBWXg3QixTQUFaLEdBQ0UsSUFBSTBnQixJQUFKLENBQVNoQyxJQUFULEVBQWUrWixTQUFTK0MsT0FBVCxFQUFrQjlDLEtBQWxCLENBQWYsQ0FERixHQUVFLElBQUloWSxJQUFKLENBQVNoQyxJQUFULENBSk47QUFLRDs7QUFDRCxZQUFJcVosZUFBZXJaLElBQW5CLEVBQXlCLE9BQU9tYSxTQUFTa0MsVUFBVCxFQUFxQnJjLElBQXJCLENBQVA7QUFDekIsZUFBT3VhLE1BQU10YyxJQUFOLENBQVdvZSxVQUFYLEVBQXVCcmMsSUFBdkIsQ0FBUDtBQUNELE9BZlksQ0FBYjtBQWdCQThYLG1CQUFhd0UsUUFBUTFlLFNBQVN2RCxTQUFqQixHQUE2QjZWLEtBQUtsTyxJQUFMLEVBQVc1aUIsTUFBWCxDQUFrQjh3QixLQUFLb00sR0FBTCxDQUFsQixDQUE3QixHQUE0RHBNLEtBQUtsTyxJQUFMLENBQXpFLEVBQXFGLFVBQVVuaUIsR0FBVixFQUFlO0FBQ2xHLFlBQUksRUFBRUEsT0FBT3c4QixVQUFULENBQUosRUFBMEJuWCxLQUFLbVgsVUFBTCxFQUFpQng4QixHQUFqQixFQUFzQm1pQixLQUFLbmlCLEdBQUwsQ0FBdEI7QUFDM0IsT0FGRDtBQUdBdzhCLGlCQUFXbFgsU0FBWCxJQUF3QnFYLG1CQUF4QjtBQUNBLFVBQUksQ0FBQ3hULE9BQUwsRUFBY3dULG9CQUFvQnJmLFdBQXBCLEdBQWtDa2YsVUFBbEM7QUFDZjs7QUFDRCxRQUFJYyxrQkFBa0JYLG9CQUFvQmxoQixRQUFwQixDQUF0QjtBQUNBLFFBQUk4aEIsb0JBQW9CLENBQUMsQ0FBQ0QsZUFBRixLQUNsQkEsZ0JBQWdCejVCLElBQWhCLElBQXdCLFFBQXhCLElBQW9DeTVCLGdCQUFnQno1QixJQUFoQixJQUF3QnBDLFNBRDFDLENBQXhCO0FBRUEsUUFBSSs3QixZQUFZekIsV0FBV3Q4QixNQUEzQjtBQUNBNGxCLFNBQUttWCxVQUFMLEVBQWlCcEQsaUJBQWpCLEVBQW9DLElBQXBDO0FBQ0EvVCxTQUFLc1gsbUJBQUwsRUFBMEJuRCxXQUExQixFQUF1Q3paLElBQXZDO0FBQ0FzRixTQUFLc1gsbUJBQUwsRUFBMEJqRCxJQUExQixFQUFnQyxJQUFoQztBQUNBclUsU0FBS3NYLG1CQUFMLEVBQTBCdEQsZUFBMUIsRUFBMkNtRCxVQUEzQzs7QUFFQSxRQUFJSCxVQUFVLElBQUlHLFVBQUosQ0FBZSxDQUFmLEVBQWtCbGUsR0FBbEIsS0FBMEJ5QixJQUFwQyxHQUEyQyxFQUFFekIsT0FBT3FlLG1CQUFULENBQS9DLEVBQThFO0FBQzVFN2QsU0FBRzZkLG1CQUFILEVBQXdCcmUsR0FBeEIsRUFBNkI7QUFDM0IrQixhQUFLLGVBQVk7QUFBRSxpQkFBT04sSUFBUDtBQUFjO0FBRE4sT0FBN0I7QUFHRDs7QUFFRC9FLE1BQUUrRSxJQUFGLElBQVV5YyxVQUFWO0FBRUEvYSxZQUFRQSxRQUFRc0IsQ0FBUixHQUFZdEIsUUFBUXVCLENBQXBCLEdBQXdCdkIsUUFBUTVELENBQVIsSUFBYTJlLGNBQWNyYSxJQUEzQixDQUFoQyxFQUFrRW5ILENBQWxFO0FBRUF5RyxZQUFRQSxRQUFRa0UsQ0FBaEIsRUFBbUI1RixJQUFuQixFQUF5QjtBQUN2QjZYLHlCQUFtQnVDO0FBREksS0FBekI7QUFJQTFZLFlBQVFBLFFBQVFrRSxDQUFSLEdBQVlsRSxRQUFRNUQsQ0FBUixHQUFZK0QsTUFBTSxZQUFZO0FBQUVPLFdBQUsyUSxFQUFMLENBQVExVSxJQUFSLENBQWFvZSxVQUFiLEVBQXlCLENBQXpCO0FBQThCLEtBQWxELENBQWhDLEVBQXFGemMsSUFBckYsRUFBMkY7QUFDekYzZSxZQUFNczVCLEtBRG1GO0FBRXpGNUgsVUFBSThIO0FBRnFGLEtBQTNGO0FBS0EsUUFBSSxFQUFFaEQscUJBQXFCK0UsbUJBQXZCLENBQUosRUFBaUR0WCxLQUFLc1gsbUJBQUwsRUFBMEIvRSxpQkFBMUIsRUFBNkN1QyxLQUE3QztBQUVqRDFZLFlBQVFBLFFBQVFvRSxDQUFoQixFQUFtQjlGLElBQW5CLEVBQXlCcUMsS0FBekI7QUFFQWpELGVBQVdZLElBQVg7QUFFQTBCLFlBQVFBLFFBQVFvRSxDQUFSLEdBQVlwRSxRQUFRNUQsQ0FBUixHQUFZb2MsVUFBaEMsRUFBNENsYSxJQUE1QyxFQUFrRDtBQUFFdUIsV0FBS3VhO0FBQVAsS0FBbEQ7QUFFQXBhLFlBQVFBLFFBQVFvRSxDQUFSLEdBQVlwRSxRQUFRNUQsQ0FBUixHQUFZLENBQUMwZixpQkFBakMsRUFBb0R4ZCxJQUFwRCxFQUEwRGdjLFVBQTFEO0FBRUEsUUFBSSxDQUFDNVMsT0FBRCxJQUFZd1Qsb0JBQW9COWQsUUFBcEIsSUFBZ0NvYSxhQUFoRCxFQUErRDBELG9CQUFvQjlkLFFBQXBCLEdBQStCb2EsYUFBL0I7QUFFL0R4WCxZQUFRQSxRQUFRb0UsQ0FBUixHQUFZcEUsUUFBUTVELENBQVIsR0FBWStELE1BQU0sWUFBWTtBQUNoRCxVQUFJNGEsVUFBSixDQUFlLENBQWYsRUFBa0I5ZSxLQUFsQjtBQUNELEtBRitCLENBQWhDLEVBRUlxQyxJQUZKLEVBRVU7QUFBRXJDLGFBQU9rZTtBQUFULEtBRlY7QUFJQW5hLFlBQVFBLFFBQVFvRSxDQUFSLEdBQVlwRSxRQUFRNUQsQ0FBUixJQUFhK0QsTUFBTSxZQUFZO0FBQ2pELGFBQU8sQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPdVgsY0FBUCxNQUEyQixJQUFJcUQsVUFBSixDQUFlLENBQUMsQ0FBRCxFQUFJLENBQUosQ0FBZixFQUF1QnJELGNBQXZCLEVBQWxDO0FBQ0QsS0FGZ0MsS0FFM0IsQ0FBQ3ZYLE1BQU0sWUFBWTtBQUN2QithLDBCQUFvQnhELGNBQXBCLENBQW1DL2EsSUFBbkMsQ0FBd0MsQ0FBQyxDQUFELEVBQUksQ0FBSixDQUF4QztBQUNELEtBRk0sQ0FGYSxDQUFwQixFQUlLMkIsSUFKTCxFQUlXO0FBQUVvWixzQkFBZ0IyQjtBQUFsQixLQUpYO0FBTUFsUyxjQUFVN0ksSUFBVixJQUFrQndkLG9CQUFvQkQsZUFBcEIsR0FBc0NFLFNBQXhEO0FBQ0EsUUFBSSxDQUFDclUsT0FBRCxJQUFZLENBQUNvVSxpQkFBakIsRUFBb0NsWSxLQUFLc1gsbUJBQUwsRUFBMEJsaEIsUUFBMUIsRUFBb0MraEIsU0FBcEM7QUFDckMsR0ExSkQ7QUEySkQsQ0E5ZEQsTUE4ZE90akIsT0FBT3BiLE9BQVAsR0FBaUIsWUFBWTtBQUFFO0FBQWEsQ0FBNUMsQzs7Ozs7Ozs7QUMvZFA7O0FBQ0EsSUFBSUwsU0FBUyxtQkFBQUQsQ0FBUSwyQ0FBUixDQUFiOztBQUNBLElBQUk0Z0IsY0FBYyxtQkFBQTVnQixDQUFRLGdEQUFSLENBQWxCOztBQUNBLElBQUkycUIsVUFBVSxtQkFBQTNxQixDQUFRLDRDQUFSLENBQWQ7O0FBQ0EsSUFBSXU0QixTQUFTLG1CQUFBdjRCLENBQVEsMENBQVIsQ0FBYjs7QUFDQSxJQUFJNm1CLE9BQU8sbUJBQUE3bUIsQ0FBUSx5Q0FBUixDQUFYOztBQUNBLElBQUl1Z0IsY0FBYyxtQkFBQXZnQixDQUFRLGlEQUFSLENBQWxCOztBQUNBLElBQUlvakIsUUFBUSxtQkFBQXBqQixDQUFRLDBDQUFSLENBQVo7O0FBQ0EsSUFBSXdnQixhQUFhLG1CQUFBeGdCLENBQVEsZ0RBQVIsQ0FBakI7O0FBQ0EsSUFBSWcxQixZQUFZLG1CQUFBaDFCLENBQVEsK0NBQVIsQ0FBaEI7O0FBQ0EsSUFBSXNjLFdBQVcsbUJBQUF0YyxDQUFRLDhDQUFSLENBQWY7O0FBQ0EsSUFBSTA0QixVQUFVLG1CQUFBMTRCLENBQVEsNkNBQVIsQ0FBZDs7QUFDQSxJQUFJNnhCLE9BQU8sbUJBQUE3eEIsQ0FBUSxnREFBUixFQUEwQnFlLENBQXJDOztBQUNBLElBQUlpQyxLQUFLLG1CQUFBdGdCLENBQVEsOENBQVIsRUFBd0JxZSxDQUFqQzs7QUFDQSxJQUFJd2EsWUFBWSxtQkFBQTc0QixDQUFRLCtDQUFSLENBQWhCOztBQUNBLElBQUlzakIsaUJBQWlCLG1CQUFBdGpCLENBQVEsc0RBQVIsQ0FBckI7O0FBQ0EsSUFBSWs1QixlQUFlLGFBQW5CO0FBQ0EsSUFBSStGLFlBQVksVUFBaEI7QUFDQSxJQUFJblksWUFBWSxXQUFoQjtBQUNBLElBQUlxVSxlQUFlLGVBQW5CO0FBQ0EsSUFBSStELGNBQWMsY0FBbEI7QUFDQSxJQUFJN0YsZUFBZXA1QixPQUFPaTVCLFlBQVAsQ0FBbkI7QUFDQSxJQUFJSyxZQUFZdDVCLE9BQU9nL0IsU0FBUCxDQUFoQjtBQUNBLElBQUkxM0IsT0FBT3RILE9BQU9zSCxJQUFsQjtBQUNBLElBQUlpZSxhQUFhdmxCLE9BQU91bEIsVUFBeEIsQyxDQUNBOztBQUNBLElBQUlxSCxXQUFXNXNCLE9BQU80c0IsUUFBdEI7QUFDQSxJQUFJc1MsYUFBYTlGLFlBQWpCO0FBQ0EsSUFBSXh4QixNQUFNTixLQUFLTSxHQUFmO0FBQ0EsSUFBSXVrQixNQUFNN2tCLEtBQUs2a0IsR0FBZjtBQUNBLElBQUkvQixRQUFROWlCLEtBQUs4aUIsS0FBakI7QUFDQSxJQUFJMEMsTUFBTXhsQixLQUFLd2xCLEdBQWY7QUFDQSxJQUFJcVMsTUFBTTczQixLQUFLNjNCLEdBQWY7QUFDQSxJQUFJQyxTQUFTLFFBQWI7QUFDQSxJQUFJQyxjQUFjLFlBQWxCO0FBQ0EsSUFBSUMsY0FBYyxZQUFsQjtBQUNBLElBQUlDLFVBQVU1ZSxjQUFjLElBQWQsR0FBcUJ5ZSxNQUFuQztBQUNBLElBQUlJLFVBQVU3ZSxjQUFjLElBQWQsR0FBcUIwZSxXQUFuQztBQUNBLElBQUlJLFVBQVU5ZSxjQUFjLElBQWQsR0FBcUIyZSxXQUFuQyxDLENBRUE7O0FBQ0EsU0FBU0ksV0FBVCxDQUFxQnAvQixLQUFyQixFQUE0QnEvQixJQUE1QixFQUFrQ0MsTUFBbEMsRUFBMEM7QUFDeEMsTUFBSXJFLFNBQVM3NEIsTUFBTWs5QixNQUFOLENBQWI7QUFDQSxNQUFJQyxPQUFPRCxTQUFTLENBQVQsR0FBYUQsSUFBYixHQUFvQixDQUEvQjtBQUNBLE1BQUlHLE9BQU8sQ0FBQyxLQUFLRCxJQUFOLElBQWMsQ0FBekI7QUFDQSxNQUFJRSxRQUFRRCxRQUFRLENBQXBCO0FBQ0EsTUFBSUUsS0FBS0wsU0FBUyxFQUFULEdBQWN4VCxJQUFJLENBQUosRUFBTyxDQUFDLEVBQVIsSUFBY0EsSUFBSSxDQUFKLEVBQU8sQ0FBQyxFQUFSLENBQTVCLEdBQTBDLENBQW5EO0FBQ0EsTUFBSWhyQixJQUFJLENBQVI7QUFDQSxNQUFJeWtCLElBQUl0bEIsUUFBUSxDQUFSLElBQWFBLFVBQVUsQ0FBVixJQUFlLElBQUlBLEtBQUosR0FBWSxDQUF4QyxHQUE0QyxDQUE1QyxHQUFnRCxDQUF4RDtBQUNBLE1BQUkwZixDQUFKLEVBQU8wRixDQUFQLEVBQVVyYSxDQUFWO0FBQ0EvSyxVQUFRc0gsSUFBSXRILEtBQUosQ0FBUixDQVR3QyxDQVV4Qzs7QUFDQSxNQUFJQSxTQUFTQSxLQUFULElBQWtCQSxVQUFVc3NCLFFBQWhDLEVBQTBDO0FBQ3hDO0FBQ0FsSCxRQUFJcGxCLFNBQVNBLEtBQVQsR0FBaUIsQ0FBakIsR0FBcUIsQ0FBekI7QUFDQTBmLFFBQUk4ZixJQUFKO0FBQ0QsR0FKRCxNQUlPO0FBQ0w5ZixRQUFJb0ssTUFBTTBDLElBQUl4c0IsS0FBSixJQUFhNitCLEdBQW5CLENBQUo7O0FBQ0EsUUFBSTcrQixTQUFTK0ssSUFBSThnQixJQUFJLENBQUosRUFBTyxDQUFDbk0sQ0FBUixDQUFiLElBQTJCLENBQS9CLEVBQWtDO0FBQ2hDQTtBQUNBM1UsV0FBSyxDQUFMO0FBQ0Q7O0FBQ0QsUUFBSTJVLElBQUkrZixLQUFKLElBQWEsQ0FBakIsRUFBb0I7QUFDbEJ6L0IsZUFBUzAvQixLQUFLMzBCLENBQWQ7QUFDRCxLQUZELE1BRU87QUFDTC9LLGVBQVMwL0IsS0FBSzdULElBQUksQ0FBSixFQUFPLElBQUk0VCxLQUFYLENBQWQ7QUFDRDs7QUFDRCxRQUFJei9CLFFBQVErSyxDQUFSLElBQWEsQ0FBakIsRUFBb0I7QUFDbEIyVTtBQUNBM1UsV0FBSyxDQUFMO0FBQ0Q7O0FBQ0QsUUFBSTJVLElBQUkrZixLQUFKLElBQWFELElBQWpCLEVBQXVCO0FBQ3JCcGEsVUFBSSxDQUFKO0FBQ0ExRixVQUFJOGYsSUFBSjtBQUNELEtBSEQsTUFHTyxJQUFJOWYsSUFBSStmLEtBQUosSUFBYSxDQUFqQixFQUFvQjtBQUN6QnJhLFVBQUksQ0FBQ3BsQixRQUFRK0ssQ0FBUixHQUFZLENBQWIsSUFBa0I4Z0IsSUFBSSxDQUFKLEVBQU93VCxJQUFQLENBQXRCO0FBQ0EzZixVQUFJQSxJQUFJK2YsS0FBUjtBQUNELEtBSE0sTUFHQTtBQUNMcmEsVUFBSXBsQixRQUFRNnJCLElBQUksQ0FBSixFQUFPNFQsUUFBUSxDQUFmLENBQVIsR0FBNEI1VCxJQUFJLENBQUosRUFBT3dULElBQVAsQ0FBaEM7QUFDQTNmLFVBQUksQ0FBSjtBQUNEO0FBQ0Y7O0FBQ0QsU0FBTzJmLFFBQVEsQ0FBZixFQUFrQnBFLE9BQU9wNkIsR0FBUCxJQUFjdWtCLElBQUksR0FBbEIsRUFBdUJBLEtBQUssR0FBNUIsRUFBaUNpYSxRQUFRLENBQTNEO0FBQTZEO0FBQTdEOztBQUNBM2YsTUFBSUEsS0FBSzJmLElBQUwsR0FBWWphLENBQWhCO0FBQ0FtYSxVQUFRRixJQUFSOztBQUNBLFNBQU9FLE9BQU8sQ0FBZCxFQUFpQnRFLE9BQU9wNkIsR0FBUCxJQUFjNmUsSUFBSSxHQUFsQixFQUF1QkEsS0FBSyxHQUE1QixFQUFpQzZmLFFBQVEsQ0FBMUQ7QUFBNEQ7QUFBNUQ7O0FBQ0F0RSxTQUFPLEVBQUVwNkIsQ0FBVCxLQUFleWtCLElBQUksR0FBbkI7QUFDQSxTQUFPMlYsTUFBUDtBQUNEOztBQUNELFNBQVMwRSxhQUFULENBQXVCMUUsTUFBdkIsRUFBK0JvRSxJQUEvQixFQUFxQ0MsTUFBckMsRUFBNkM7QUFDM0MsTUFBSUMsT0FBT0QsU0FBUyxDQUFULEdBQWFELElBQWIsR0FBb0IsQ0FBL0I7QUFDQSxNQUFJRyxPQUFPLENBQUMsS0FBS0QsSUFBTixJQUFjLENBQXpCO0FBQ0EsTUFBSUUsUUFBUUQsUUFBUSxDQUFwQjtBQUNBLE1BQUlJLFFBQVFMLE9BQU8sQ0FBbkI7QUFDQSxNQUFJMStCLElBQUl5K0IsU0FBUyxDQUFqQjtBQUNBLE1BQUloYSxJQUFJMlYsT0FBT3A2QixHQUFQLENBQVI7QUFDQSxNQUFJNmUsSUFBSTRGLElBQUksR0FBWjtBQUNBLE1BQUlGLENBQUo7QUFDQUUsUUFBTSxDQUFOOztBQUNBLFNBQU9zYSxRQUFRLENBQWYsRUFBa0JsZ0IsSUFBSUEsSUFBSSxHQUFKLEdBQVV1YixPQUFPcDZCLENBQVAsQ0FBZCxFQUF5QkEsR0FBekIsRUFBOEIrK0IsU0FBUyxDQUF6RDtBQUEyRDtBQUEzRDs7QUFDQXhhLE1BQUkxRixJQUFJLENBQUMsS0FBSyxDQUFDa2dCLEtBQVAsSUFBZ0IsQ0FBeEI7QUFDQWxnQixRQUFNLENBQUNrZ0IsS0FBUDtBQUNBQSxXQUFTUCxJQUFUOztBQUNBLFNBQU9PLFFBQVEsQ0FBZixFQUFrQnhhLElBQUlBLElBQUksR0FBSixHQUFVNlYsT0FBT3A2QixDQUFQLENBQWQsRUFBeUJBLEdBQXpCLEVBQThCKytCLFNBQVMsQ0FBekQ7QUFBMkQ7QUFBM0Q7O0FBQ0EsTUFBSWxnQixNQUFNLENBQVYsRUFBYTtBQUNYQSxRQUFJLElBQUkrZixLQUFSO0FBQ0QsR0FGRCxNQUVPLElBQUkvZixNQUFNOGYsSUFBVixFQUFnQjtBQUNyQixXQUFPcGEsSUFBSUwsR0FBSixHQUFVTyxJQUFJLENBQUNnSCxRQUFMLEdBQWdCQSxRQUFqQztBQUNELEdBRk0sTUFFQTtBQUNMbEgsUUFBSUEsSUFBSXlHLElBQUksQ0FBSixFQUFPd1QsSUFBUCxDQUFSO0FBQ0EzZixRQUFJQSxJQUFJK2YsS0FBUjtBQUNEOztBQUFDLFNBQU8sQ0FBQ25hLElBQUksQ0FBQyxDQUFMLEdBQVMsQ0FBVixJQUFlRixDQUFmLEdBQW1CeUcsSUFBSSxDQUFKLEVBQU9uTSxJQUFJMmYsSUFBWCxDQUExQjtBQUNIOztBQUVELFNBQVNRLFNBQVQsQ0FBbUJDLEtBQW5CLEVBQTBCO0FBQ3hCLFNBQU9BLE1BQU0sQ0FBTixLQUFZLEVBQVosR0FBaUJBLE1BQU0sQ0FBTixLQUFZLEVBQTdCLEdBQWtDQSxNQUFNLENBQU4sS0FBWSxDQUE5QyxHQUFrREEsTUFBTSxDQUFOLENBQXpEO0FBQ0Q7O0FBQ0QsU0FBU0MsTUFBVCxDQUFnQnorQixFQUFoQixFQUFvQjtBQUNsQixTQUFPLENBQUNBLEtBQUssSUFBTixDQUFQO0FBQ0Q7O0FBQ0QsU0FBUzArQixPQUFULENBQWlCMStCLEVBQWpCLEVBQXFCO0FBQ25CLFNBQU8sQ0FBQ0EsS0FBSyxJQUFOLEVBQVlBLE1BQU0sQ0FBTixHQUFVLElBQXRCLENBQVA7QUFDRDs7QUFDRCxTQUFTMitCLE9BQVQsQ0FBaUIzK0IsRUFBakIsRUFBcUI7QUFDbkIsU0FBTyxDQUFDQSxLQUFLLElBQU4sRUFBWUEsTUFBTSxDQUFOLEdBQVUsSUFBdEIsRUFBNEJBLE1BQU0sRUFBTixHQUFXLElBQXZDLEVBQTZDQSxNQUFNLEVBQU4sR0FBVyxJQUF4RCxDQUFQO0FBQ0Q7O0FBQ0QsU0FBUzQrQixPQUFULENBQWlCNStCLEVBQWpCLEVBQXFCO0FBQ25CLFNBQU84OUIsWUFBWTk5QixFQUFaLEVBQWdCLEVBQWhCLEVBQW9CLENBQXBCLENBQVA7QUFDRDs7QUFDRCxTQUFTNitCLE9BQVQsQ0FBaUI3K0IsRUFBakIsRUFBcUI7QUFDbkIsU0FBTzg5QixZQUFZOTlCLEVBQVosRUFBZ0IsRUFBaEIsRUFBb0IsQ0FBcEIsQ0FBUDtBQUNEOztBQUVELFNBQVNrNkIsU0FBVCxDQUFtQmxkLENBQW5CLEVBQXNCcmQsR0FBdEIsRUFBMkJ3NkIsUUFBM0IsRUFBcUM7QUFDbkMxYixLQUFHekIsRUFBRWlJLFNBQUYsQ0FBSCxFQUFpQnRsQixHQUFqQixFQUFzQjtBQUFFcWdCLFNBQUssZUFBWTtBQUFFLGFBQU8sS0FBS21hLFFBQUwsQ0FBUDtBQUF3QjtBQUE3QyxHQUF0QjtBQUNEOztBQUVELFNBQVNuYSxHQUFULENBQWE4ZSxJQUFiLEVBQW1CTixLQUFuQixFQUEwQnYrQixLQUExQixFQUFpQzgrQixjQUFqQyxFQUFpRDtBQUMvQyxNQUFJQyxXQUFXLENBQUMvK0IsS0FBaEI7QUFDQSxNQUFJZy9CLFdBQVdwSSxRQUFRbUksUUFBUixDQUFmO0FBQ0EsTUFBSUMsV0FBV1QsS0FBWCxHQUFtQk0sS0FBS2xCLE9BQUwsQ0FBdkIsRUFBc0MsTUFBTWphLFdBQVcwWixXQUFYLENBQU47QUFDdEMsTUFBSXJjLFFBQVE4ZCxLQUFLbkIsT0FBTCxFQUFjdUIsRUFBMUI7QUFDQSxNQUFJNy9CLFFBQVE0L0IsV0FBV0gsS0FBS2pCLE9BQUwsQ0FBdkI7QUFDQSxNQUFJc0IsT0FBT25lLE1BQU0zRCxLQUFOLENBQVloZSxLQUFaLEVBQW1CQSxRQUFRbS9CLEtBQTNCLENBQVg7QUFDQSxTQUFPTyxpQkFBaUJJLElBQWpCLEdBQXdCQSxLQUFLbkUsT0FBTCxFQUEvQjtBQUNEOztBQUNELFNBQVMvWixHQUFULENBQWE2ZCxJQUFiLEVBQW1CTixLQUFuQixFQUEwQnYrQixLQUExQixFQUFpQ20vQixVQUFqQyxFQUE2QzFnQyxLQUE3QyxFQUFvRHFnQyxjQUFwRCxFQUFvRTtBQUNsRSxNQUFJQyxXQUFXLENBQUMvK0IsS0FBaEI7QUFDQSxNQUFJZy9CLFdBQVdwSSxRQUFRbUksUUFBUixDQUFmO0FBQ0EsTUFBSUMsV0FBV1QsS0FBWCxHQUFtQk0sS0FBS2xCLE9BQUwsQ0FBdkIsRUFBc0MsTUFBTWphLFdBQVcwWixXQUFYLENBQU47QUFDdEMsTUFBSXJjLFFBQVE4ZCxLQUFLbkIsT0FBTCxFQUFjdUIsRUFBMUI7QUFDQSxNQUFJNy9CLFFBQVE0L0IsV0FBV0gsS0FBS2pCLE9BQUwsQ0FBdkI7QUFDQSxNQUFJc0IsT0FBT0MsV0FBVyxDQUFDMWdDLEtBQVosQ0FBWDs7QUFDQSxPQUFLLElBQUlhLElBQUksQ0FBYixFQUFnQkEsSUFBSWkvQixLQUFwQixFQUEyQmovQixHQUEzQjtBQUFnQ3loQixVQUFNM2hCLFFBQVFFLENBQWQsSUFBbUI0L0IsS0FBS0osaUJBQWlCeC9CLENBQWpCLEdBQXFCaS9CLFFBQVFqL0IsQ0FBUixHQUFZLENBQXRDLENBQW5CO0FBQWhDO0FBQ0Q7O0FBRUQsSUFBSSxDQUFDbTNCLE9BQU8yRixHQUFaLEVBQWlCO0FBQ2Y3RSxpQkFBZSxTQUFTQyxXQUFULENBQXFCMTFCLE1BQXJCLEVBQTZCO0FBQzFDNGMsZUFBVyxJQUFYLEVBQWlCNlksWUFBakIsRUFBK0JILFlBQS9CO0FBQ0EsUUFBSXlGLGFBQWFqRyxRQUFROTBCLE1BQVIsQ0FBakI7QUFDQSxTQUFLbTlCLEVBQUwsR0FBVWxJLFVBQVVqWixJQUFWLENBQWVqZCxNQUFNZzhCLFVBQU4sQ0FBZixFQUFrQyxDQUFsQyxDQUFWO0FBQ0EsU0FBS2MsT0FBTCxJQUFnQmQsVUFBaEI7QUFDRCxHQUxEOztBQU9BcEYsY0FBWSxTQUFTQyxRQUFULENBQWtCZ0MsTUFBbEIsRUFBMEIyQixVQUExQixFQUFzQ3dCLFVBQXRDLEVBQWtEO0FBQzVEbmUsZUFBVyxJQUFYLEVBQWlCK1ksU0FBakIsRUFBNEIwRixTQUE1QjtBQUNBemUsZUFBV2diLE1BQVgsRUFBbUJuQyxZQUFuQixFQUFpQzRGLFNBQWpDO0FBQ0EsUUFBSWlDLGVBQWUxRixPQUFPaUUsT0FBUCxDQUFuQjtBQUNBLFFBQUlyMEIsU0FBUzRwQixVQUFVbUksVUFBVixDQUFiO0FBQ0EsUUFBSS94QixTQUFTLENBQVQsSUFBY0EsU0FBUzgxQixZQUEzQixFQUF5QyxNQUFNMWIsV0FBVyxlQUFYLENBQU47QUFDekNtWixpQkFBYUEsZUFBZTE3QixTQUFmLEdBQTJCaStCLGVBQWU5MUIsTUFBMUMsR0FBbURrUixTQUFTcWlCLFVBQVQsQ0FBaEU7QUFDQSxRQUFJdnpCLFNBQVN1ekIsVUFBVCxHQUFzQnVDLFlBQTFCLEVBQXdDLE1BQU0xYixXQUFXMlYsWUFBWCxDQUFOO0FBQ3hDLFNBQUtxRSxPQUFMLElBQWdCaEUsTUFBaEI7QUFDQSxTQUFLa0UsT0FBTCxJQUFnQnQwQixNQUFoQjtBQUNBLFNBQUtxMEIsT0FBTCxJQUFnQmQsVUFBaEI7QUFDRCxHQVhEOztBQWFBLE1BQUkvZCxXQUFKLEVBQWlCO0FBQ2ZtYixjQUFVMUMsWUFBVixFQUF3QmlHLFdBQXhCLEVBQXFDLElBQXJDO0FBQ0F2RCxjQUFVeEMsU0FBVixFQUFxQjhGLE1BQXJCLEVBQTZCLElBQTdCO0FBQ0F0RCxjQUFVeEMsU0FBVixFQUFxQitGLFdBQXJCLEVBQWtDLElBQWxDO0FBQ0F2RCxjQUFVeEMsU0FBVixFQUFxQmdHLFdBQXJCLEVBQWtDLElBQWxDO0FBQ0Q7O0FBRURoZixjQUFZZ1osVUFBVXpTLFNBQVYsQ0FBWixFQUFrQztBQUNoQ3FhLGFBQVMsU0FBU0EsT0FBVCxDQUFpQmhFLFVBQWpCLEVBQTZCO0FBQ3BDLGFBQU90YixJQUFJLElBQUosRUFBVSxDQUFWLEVBQWFzYixVQUFiLEVBQXlCLENBQXpCLEtBQStCLEVBQS9CLElBQXFDLEVBQTVDO0FBQ0QsS0FIK0I7QUFJaENpRSxjQUFVLFNBQVNBLFFBQVQsQ0FBa0JqRSxVQUFsQixFQUE4QjtBQUN0QyxhQUFPdGIsSUFBSSxJQUFKLEVBQVUsQ0FBVixFQUFhc2IsVUFBYixFQUF5QixDQUF6QixDQUFQO0FBQ0QsS0FOK0I7QUFPaENrRSxjQUFVLFNBQVNBLFFBQVQsQ0FBa0JsRTtBQUFXO0FBQTdCLE1BQW1EO0FBQzNELFVBQUlrRCxRQUFReGUsSUFBSSxJQUFKLEVBQVUsQ0FBVixFQUFhc2IsVUFBYixFQUF5QnhnQixVQUFVLENBQVYsQ0FBekIsQ0FBWjtBQUNBLGFBQU8sQ0FBQzBqQixNQUFNLENBQU4sS0FBWSxDQUFaLEdBQWdCQSxNQUFNLENBQU4sQ0FBakIsS0FBOEIsRUFBOUIsSUFBb0MsRUFBM0M7QUFDRCxLQVYrQjtBQVdoQ2lCLGVBQVcsU0FBU0EsU0FBVCxDQUFtQm5FO0FBQVc7QUFBOUIsTUFBb0Q7QUFDN0QsVUFBSWtELFFBQVF4ZSxJQUFJLElBQUosRUFBVSxDQUFWLEVBQWFzYixVQUFiLEVBQXlCeGdCLFVBQVUsQ0FBVixDQUF6QixDQUFaO0FBQ0EsYUFBTzBqQixNQUFNLENBQU4sS0FBWSxDQUFaLEdBQWdCQSxNQUFNLENBQU4sQ0FBdkI7QUFDRCxLQWQrQjtBQWVoQ2tCLGNBQVUsU0FBU0EsUUFBVCxDQUFrQnBFO0FBQVc7QUFBN0IsTUFBbUQ7QUFDM0QsYUFBT2lELFVBQVV2ZSxJQUFJLElBQUosRUFBVSxDQUFWLEVBQWFzYixVQUFiLEVBQXlCeGdCLFVBQVUsQ0FBVixDQUF6QixDQUFWLENBQVA7QUFDRCxLQWpCK0I7QUFrQmhDNmtCLGVBQVcsU0FBU0EsU0FBVCxDQUFtQnJFO0FBQVc7QUFBOUIsTUFBb0Q7QUFDN0QsYUFBT2lELFVBQVV2ZSxJQUFJLElBQUosRUFBVSxDQUFWLEVBQWFzYixVQUFiLEVBQXlCeGdCLFVBQVUsQ0FBVixDQUF6QixDQUFWLE1BQXNELENBQTdEO0FBQ0QsS0FwQitCO0FBcUJoQzhrQixnQkFBWSxTQUFTQSxVQUFULENBQW9CdEU7QUFBVztBQUEvQixNQUFxRDtBQUMvRCxhQUFPK0MsY0FBY3JlLElBQUksSUFBSixFQUFVLENBQVYsRUFBYXNiLFVBQWIsRUFBeUJ4Z0IsVUFBVSxDQUFWLENBQXpCLENBQWQsRUFBc0QsRUFBdEQsRUFBMEQsQ0FBMUQsQ0FBUDtBQUNELEtBdkIrQjtBQXdCaEMra0IsZ0JBQVksU0FBU0EsVUFBVCxDQUFvQnZFO0FBQVc7QUFBL0IsTUFBcUQ7QUFDL0QsYUFBTytDLGNBQWNyZSxJQUFJLElBQUosRUFBVSxDQUFWLEVBQWFzYixVQUFiLEVBQXlCeGdCLFVBQVUsQ0FBVixDQUF6QixDQUFkLEVBQXNELEVBQXRELEVBQTBELENBQTFELENBQVA7QUFDRCxLQTFCK0I7QUEyQmhDZ2xCLGFBQVMsU0FBU0EsT0FBVCxDQUFpQnhFLFVBQWpCLEVBQTZCNThCLEtBQTdCLEVBQW9DO0FBQzNDdWlCLFVBQUksSUFBSixFQUFVLENBQVYsRUFBYXFhLFVBQWIsRUFBeUJtRCxNQUF6QixFQUFpQy8vQixLQUFqQztBQUNELEtBN0IrQjtBQThCaENxaEMsY0FBVSxTQUFTQSxRQUFULENBQWtCekUsVUFBbEIsRUFBOEI1OEIsS0FBOUIsRUFBcUM7QUFDN0N1aUIsVUFBSSxJQUFKLEVBQVUsQ0FBVixFQUFhcWEsVUFBYixFQUF5Qm1ELE1BQXpCLEVBQWlDLy9CLEtBQWpDO0FBQ0QsS0FoQytCO0FBaUNoQ3NoQyxjQUFVLFNBQVNBLFFBQVQsQ0FBa0IxRSxVQUFsQixFQUE4QjU4QjtBQUFNO0FBQXBDLE1BQTBEO0FBQ2xFdWlCLFVBQUksSUFBSixFQUFVLENBQVYsRUFBYXFhLFVBQWIsRUFBeUJvRCxPQUF6QixFQUFrQ2hnQyxLQUFsQyxFQUF5Q29jLFVBQVUsQ0FBVixDQUF6QztBQUNELEtBbkMrQjtBQW9DaENtbEIsZUFBVyxTQUFTQSxTQUFULENBQW1CM0UsVUFBbkIsRUFBK0I1OEI7QUFBTTtBQUFyQyxNQUEyRDtBQUNwRXVpQixVQUFJLElBQUosRUFBVSxDQUFWLEVBQWFxYSxVQUFiLEVBQXlCb0QsT0FBekIsRUFBa0NoZ0MsS0FBbEMsRUFBeUNvYyxVQUFVLENBQVYsQ0FBekM7QUFDRCxLQXRDK0I7QUF1Q2hDb2xCLGNBQVUsU0FBU0EsUUFBVCxDQUFrQjVFLFVBQWxCLEVBQThCNThCO0FBQU07QUFBcEMsTUFBMEQ7QUFDbEV1aUIsVUFBSSxJQUFKLEVBQVUsQ0FBVixFQUFhcWEsVUFBYixFQUF5QnFELE9BQXpCLEVBQWtDamdDLEtBQWxDLEVBQXlDb2MsVUFBVSxDQUFWLENBQXpDO0FBQ0QsS0F6QytCO0FBMENoQ3FsQixlQUFXLFNBQVNBLFNBQVQsQ0FBbUI3RSxVQUFuQixFQUErQjU4QjtBQUFNO0FBQXJDLE1BQTJEO0FBQ3BFdWlCLFVBQUksSUFBSixFQUFVLENBQVYsRUFBYXFhLFVBQWIsRUFBeUJxRCxPQUF6QixFQUFrQ2pnQyxLQUFsQyxFQUF5Q29jLFVBQVUsQ0FBVixDQUF6QztBQUNELEtBNUMrQjtBQTZDaENzbEIsZ0JBQVksU0FBU0EsVUFBVCxDQUFvQjlFLFVBQXBCLEVBQWdDNThCO0FBQU07QUFBdEMsTUFBNEQ7QUFDdEV1aUIsVUFBSSxJQUFKLEVBQVUsQ0FBVixFQUFhcWEsVUFBYixFQUF5QnVELE9BQXpCLEVBQWtDbmdDLEtBQWxDLEVBQXlDb2MsVUFBVSxDQUFWLENBQXpDO0FBQ0QsS0EvQytCO0FBZ0RoQ3VsQixnQkFBWSxTQUFTQSxVQUFULENBQW9CL0UsVUFBcEIsRUFBZ0M1OEI7QUFBTTtBQUF0QyxNQUE0RDtBQUN0RXVpQixVQUFJLElBQUosRUFBVSxDQUFWLEVBQWFxYSxVQUFiLEVBQXlCc0QsT0FBekIsRUFBa0NsZ0MsS0FBbEMsRUFBeUNvYyxVQUFVLENBQVYsQ0FBekM7QUFDRDtBQWxEK0IsR0FBbEM7QUFvREQsQ0FoRkQsTUFnRk87QUFDTCxNQUFJLENBQUN5RyxNQUFNLFlBQVk7QUFDckJpVyxpQkFBYSxDQUFiO0FBQ0QsR0FGSSxDQUFELElBRUUsQ0FBQ2pXLE1BQU0sWUFBWTtBQUN2QixRQUFJaVcsWUFBSixDQUFpQixDQUFDLENBQWxCLEVBRHVCLENBQ0Q7QUFDdkIsR0FGTSxDQUZILElBSUVqVyxNQUFNLFlBQVk7QUFDdEIsUUFBSWlXLFlBQUosR0FEc0IsQ0FDRjs7QUFDcEIsUUFBSUEsWUFBSixDQUFpQixHQUFqQixFQUZzQixDQUVDOztBQUN2QixRQUFJQSxZQUFKLENBQWlCL1QsR0FBakIsRUFIc0IsQ0FHQzs7QUFDdkIsV0FBTytULGFBQWFoMEIsSUFBYixJQUFxQjZ6QixZQUE1QjtBQUNELEdBTEssQ0FKTixFQVNJO0FBQ0ZHLG1CQUFlLFNBQVNDLFdBQVQsQ0FBcUIxMUIsTUFBckIsRUFBNkI7QUFDMUM0YyxpQkFBVyxJQUFYLEVBQWlCNlksWUFBakI7QUFDQSxhQUFPLElBQUk4RixVQUFKLENBQWV6RyxRQUFROTBCLE1BQVIsQ0FBZixDQUFQO0FBQ0QsS0FIRDs7QUFJQSxRQUFJdStCLG1CQUFtQjlJLGFBQWF2UyxTQUFiLElBQTBCcVksV0FBV3JZLFNBQVgsQ0FBakQ7O0FBQ0EsU0FBSyxJQUFJOWxCLE9BQU82d0IsS0FBS3NOLFVBQUwsQ0FBWCxFQUE2Qi9PLElBQUksQ0FBakMsRUFBb0M1dUIsR0FBekMsRUFBOENSLEtBQUs0QyxNQUFMLEdBQWN3c0IsQ0FBNUQsR0FBZ0U7QUFDOUQsVUFBSSxFQUFFLENBQUM1dUIsTUFBTVIsS0FBS292QixHQUFMLENBQVAsS0FBcUJpSixZQUF2QixDQUFKLEVBQTBDeFMsS0FBS3dTLFlBQUwsRUFBbUI3M0IsR0FBbkIsRUFBd0IyOUIsV0FBVzM5QixHQUFYLENBQXhCO0FBQzNDOztBQUNELFFBQUksQ0FBQ21wQixPQUFMLEVBQWN3WCxpQkFBaUJyakIsV0FBakIsR0FBK0J1YSxZQUEvQjtBQUNmLEdBcEJJLENBcUJMOzs7QUFDQSxNQUFJc0gsT0FBTyxJQUFJcEgsU0FBSixDQUFjLElBQUlGLFlBQUosQ0FBaUIsQ0FBakIsQ0FBZCxDQUFYO0FBQ0EsTUFBSStJLFdBQVc3SSxVQUFVelMsU0FBVixFQUFxQjZhLE9BQXBDO0FBQ0FoQixPQUFLZ0IsT0FBTCxDQUFhLENBQWIsRUFBZ0IsVUFBaEI7QUFDQWhCLE9BQUtnQixPQUFMLENBQWEsQ0FBYixFQUFnQixVQUFoQjtBQUNBLE1BQUloQixLQUFLUSxPQUFMLENBQWEsQ0FBYixLQUFtQixDQUFDUixLQUFLUSxPQUFMLENBQWEsQ0FBYixDQUF4QixFQUF5QzVnQixZQUFZZ1osVUFBVXpTLFNBQVYsQ0FBWixFQUFrQztBQUN6RTZhLGFBQVMsU0FBU0EsT0FBVCxDQUFpQnhFLFVBQWpCLEVBQTZCNThCLEtBQTdCLEVBQW9DO0FBQzNDNmhDLGVBQVN4aUIsSUFBVCxDQUFjLElBQWQsRUFBb0J1ZCxVQUFwQixFQUFnQzU4QixTQUFTLEVBQVQsSUFBZSxFQUEvQztBQUNELEtBSHdFO0FBSXpFcWhDLGNBQVUsU0FBU0EsUUFBVCxDQUFrQnpFLFVBQWxCLEVBQThCNThCLEtBQTlCLEVBQXFDO0FBQzdDNmhDLGVBQVN4aUIsSUFBVCxDQUFjLElBQWQsRUFBb0J1ZCxVQUFwQixFQUFnQzU4QixTQUFTLEVBQVQsSUFBZSxFQUEvQztBQUNEO0FBTndFLEdBQWxDLEVBT3RDLElBUHNDO0FBUTFDOztBQUNEK2lCLGVBQWUrVixZQUFmLEVBQTZCSCxZQUE3QjtBQUNBNVYsZUFBZWlXLFNBQWYsRUFBMEIwRixTQUExQjtBQUNBcFksS0FBSzBTLFVBQVV6UyxTQUFWLENBQUwsRUFBMkJ5UixPQUFPMkMsSUFBbEMsRUFBd0MsSUFBeEM7QUFDQTU2QixRQUFRNDRCLFlBQVIsSUFBd0JHLFlBQXhCO0FBQ0EvNEIsUUFBUTIrQixTQUFSLElBQXFCMUYsU0FBckIsQzs7Ozs7OztBQ25SQSxJQUFJdDVCLFNBQVMsbUJBQUFELENBQVEsMkNBQVIsQ0FBYjs7QUFDQSxJQUFJNm1CLE9BQU8sbUJBQUE3bUIsQ0FBUSx5Q0FBUixDQUFYOztBQUNBLElBQUk0MEIsTUFBTSxtQkFBQTUwQixDQUFRLHdDQUFSLENBQVY7O0FBQ0EsSUFBSWk3QixRQUFRckcsSUFBSSxhQUFKLENBQVo7QUFDQSxJQUFJc0csT0FBT3RHLElBQUksTUFBSixDQUFYO0FBQ0EsSUFBSXNKLE1BQU0sQ0FBQyxFQUFFaitCLE9BQU9xNUIsV0FBUCxJQUFzQnI1QixPQUFPdTVCLFFBQS9CLENBQVg7QUFDQSxJQUFJdUIsU0FBU21ELEdBQWI7QUFDQSxJQUFJOThCLElBQUksQ0FBUjtBQUNBLElBQUl1SyxJQUFJLENBQVI7QUFDQSxJQUFJMDJCLEtBQUo7QUFFQSxJQUFJQyx5QkFDRixnSEFEMkIsQ0FFM0JoYyxLQUYyQixDQUVyQixHQUZxQixDQUE3Qjs7QUFJQSxPQUFPbGxCLElBQUl1SyxDQUFYLEVBQWM7QUFDWixNQUFJMDJCLFFBQVFwaUMsT0FBT3FpQyx1QkFBdUJsaEMsR0FBdkIsQ0FBUCxDQUFaLEVBQWlEO0FBQy9DeWxCLFNBQUt3YixNQUFNcm1CLFNBQVgsRUFBc0JpZixLQUF0QixFQUE2QixJQUE3QjtBQUNBcFUsU0FBS3diLE1BQU1ybUIsU0FBWCxFQUFzQmtmLElBQXRCLEVBQTRCLElBQTVCO0FBQ0QsR0FIRCxNQUdPSCxTQUFTLEtBQVQ7QUFDUjs7QUFFRHJmLE9BQU9wYixPQUFQLEdBQWlCO0FBQ2Y0OUIsT0FBS0EsR0FEVTtBQUVmbkQsVUFBUUEsTUFGTztBQUdmRSxTQUFPQSxLQUhRO0FBSWZDLFFBQU1BO0FBSlMsQ0FBakIsQzs7Ozs7OztBQ3RCQSxJQUFJdDJCLEtBQUssQ0FBVDtBQUNBLElBQUkyOUIsS0FBS2g3QixLQUFLa3FCLE1BQUwsRUFBVDs7QUFDQS9WLE9BQU9wYixPQUFQLEdBQWlCLFVBQVVrQixHQUFWLEVBQWU7QUFDOUIsU0FBTyxVQUFVVCxNQUFWLENBQWlCUyxRQUFReUIsU0FBUixHQUFvQixFQUFwQixHQUF5QnpCLEdBQTFDLEVBQStDLElBQS9DLEVBQXFELENBQUMsRUFBRW9ELEVBQUYsR0FBTzI5QixFQUFSLEVBQVlsaUIsUUFBWixDQUFxQixFQUFyQixDQUFyRCxDQUFQO0FBQ0QsQ0FGRCxDOzs7Ozs7O0FDRkEsSUFBSWxFLFdBQVcsbUJBQUFuYyxDQUFRLDhDQUFSLENBQWY7O0FBQ0EwYixPQUFPcGIsT0FBUCxHQUFpQixVQUFVdUIsRUFBVixFQUFjNmIsSUFBZCxFQUFvQjtBQUNuQyxNQUFJLENBQUN2QixTQUFTdGEsRUFBVCxDQUFELElBQWlCQSxHQUFHNGYsRUFBSCxLQUFVL0QsSUFBL0IsRUFBcUMsTUFBTS9CLFVBQVUsNEJBQTRCK0IsSUFBNUIsR0FBbUMsWUFBN0MsQ0FBTjtBQUNyQyxTQUFPN2IsRUFBUDtBQUNELENBSEQsQzs7Ozs7OztBQ0RBLElBQUk1QixTQUFTLG1CQUFBRCxDQUFRLDJDQUFSLENBQWI7O0FBQ0EsSUFBSXlrQixPQUFPLG1CQUFBemtCLENBQVEseUNBQVIsQ0FBWDs7QUFDQSxJQUFJMnFCLFVBQVUsbUJBQUEzcUIsQ0FBUSw0Q0FBUixDQUFkOztBQUNBLElBQUl3aUMsU0FBUyxtQkFBQXhpQyxDQUFRLDRDQUFSLENBQWI7O0FBQ0EsSUFBSUssaUJBQWlCLG1CQUFBTCxDQUFRLDhDQUFSLEVBQXdCcWUsQ0FBN0M7O0FBQ0EzQyxPQUFPcGIsT0FBUCxHQUFpQixVQUFVK0UsSUFBVixFQUFnQjtBQUMvQixNQUFJbzlCLFVBQVVoZSxLQUFLeUwsTUFBTCxLQUFnQnpMLEtBQUt5TCxNQUFMLEdBQWN2RixVQUFVLEVBQVYsR0FBZTFxQixPQUFPaXdCLE1BQVAsSUFBaUIsRUFBOUQsQ0FBZDtBQUNBLE1BQUk3cUIsS0FBSzB0QixNQUFMLENBQVksQ0FBWixLQUFrQixHQUFsQixJQUF5QixFQUFFMXRCLFFBQVFvOUIsT0FBVixDQUE3QixFQUFpRHBpQyxlQUFlb2lDLE9BQWYsRUFBd0JwOUIsSUFBeEIsRUFBOEI7QUFBRTlFLFdBQU9paUMsT0FBT25rQixDQUFQLENBQVNoWixJQUFUO0FBQVQsR0FBOUI7QUFDbEQsQ0FIRCxDOzs7Ozs7O0FDTEEvRSxRQUFRK2QsQ0FBUixHQUFZLG1CQUFBcmUsQ0FBUSx3Q0FBUixDQUFaLEM7Ozs7Ozs7QUNBQSxJQUFJNmlCLFFBQVEsbUJBQUE3aUIsQ0FBUSwyQ0FBUixFQUFxQixLQUFyQixDQUFaOztBQUNBLElBQUk0MEIsTUFBTSxtQkFBQTUwQixDQUFRLHdDQUFSLENBQVY7O0FBQ0EsSUFBSWt3QixTQUFTLG1CQUFBbHdCLENBQVEsMkNBQVIsRUFBcUJrd0IsTUFBbEM7O0FBQ0EsSUFBSXdTLGFBQWEsT0FBT3hTLE1BQVAsSUFBaUIsVUFBbEM7O0FBRUEsSUFBSXlTLFdBQVdqbkIsT0FBT3BiLE9BQVAsR0FBaUIsVUFBVStFLElBQVYsRUFBZ0I7QUFDOUMsU0FBT3dkLE1BQU14ZCxJQUFOLE1BQWdCd2QsTUFBTXhkLElBQU4sSUFDckJxOUIsY0FBY3hTLE9BQU83cUIsSUFBUCxDQUFkLElBQThCLENBQUNxOUIsYUFBYXhTLE1BQWIsR0FBc0IwRSxHQUF2QixFQUE0QixZQUFZdnZCLElBQXhDLENBRHpCLENBQVA7QUFFRCxDQUhEOztBQUtBczlCLFNBQVM5ZixLQUFULEdBQWlCQSxLQUFqQixDOzs7Ozs7O0FDVkEsSUFBSVYsVUFBVSxtQkFBQW5pQixDQUFRLDRDQUFSLENBQWQ7O0FBQ0EsSUFBSWlkLFdBQVcsbUJBQUFqZCxDQUFRLHdDQUFSLEVBQWtCLFVBQWxCLENBQWY7O0FBQ0EsSUFBSW9xQixZQUFZLG1CQUFBcHFCLENBQVEsOENBQVIsQ0FBaEI7O0FBQ0EwYixPQUFPcGIsT0FBUCxHQUFpQixtQkFBQU4sQ0FBUSx5Q0FBUixFQUFtQjRpQyxpQkFBbkIsR0FBdUMsVUFBVS9nQyxFQUFWLEVBQWM7QUFDcEUsTUFBSUEsTUFBTW9CLFNBQVYsRUFBcUIsT0FBT3BCLEdBQUdvYixRQUFILEtBQ3ZCcGIsR0FBRyxZQUFILENBRHVCLElBRXZCdW9CLFVBQVVqSSxRQUFRdGdCLEVBQVIsQ0FBVixDQUZnQjtBQUd0QixDQUpELEM7Ozs7Ozs7QUNIQTtBQUNBLElBQUlvaEIsVUFBVSxtQkFBQWpqQixDQUFRLDJDQUFSLENBQWQ7O0FBRUFpakIsUUFBUUEsUUFBUW9FLENBQWhCLEVBQW1CLE9BQW5CLEVBQTRCO0FBQUU5SyxjQUFZLG1CQUFBdmMsQ0FBUSxzREFBUjtBQUFkLENBQTVCOztBQUVBLG1CQUFBQSxDQUFRLHVEQUFSLEVBQWlDLFlBQWpDLEU7Ozs7Ozs7O0FDTEE7O0FBQ0EsSUFBSWlqQixVQUFVLG1CQUFBampCLENBQVEsMkNBQVIsQ0FBZDs7QUFDQSxJQUFJNmlDLFNBQVMsbUJBQUE3aUMsQ0FBUSxrREFBUixFQUE0QixDQUE1QixDQUFiOztBQUVBaWpCLFFBQVFBLFFBQVFvRSxDQUFSLEdBQVlwRSxRQUFRNUQsQ0FBUixHQUFZLENBQUMsbUJBQUFyZixDQUFRLGtEQUFSLEVBQTRCLEdBQUc4RCxLQUEvQixFQUFzQyxJQUF0QyxDQUFqQyxFQUE4RSxPQUE5RSxFQUF1RjtBQUNyRjtBQUNBQSxTQUFPLFNBQVNBLEtBQVQsQ0FBZW9hO0FBQVc7QUFBMUIsSUFBMkM7QUFDaEQsV0FBTzJrQixPQUFPLElBQVAsRUFBYTNrQixVQUFiLEVBQXlCdkIsVUFBVSxDQUFWLENBQXpCLENBQVA7QUFDRDtBQUpvRixDQUF2RixFOzs7Ozs7O0FDSkE7QUFDQSxJQUFJc0csVUFBVSxtQkFBQWpqQixDQUFRLDJDQUFSLENBQWQ7O0FBRUFpakIsUUFBUUEsUUFBUW9FLENBQWhCLEVBQW1CLE9BQW5CLEVBQTRCO0FBQUUxTixRQUFNLG1CQUFBM1osQ0FBUSwrQ0FBUjtBQUFSLENBQTVCOztBQUVBLG1CQUFBQSxDQUFRLHVEQUFSLEVBQWlDLE1BQWpDLEU7Ozs7Ozs7O0FDTEE7O0FBQ0EsSUFBSWlqQixVQUFVLG1CQUFBampCLENBQVEsMkNBQVIsQ0FBZDs7QUFDQSxJQUFJOGlDLFVBQVUsbUJBQUE5aUMsQ0FBUSxrREFBUixFQUE0QixDQUE1QixDQUFkOztBQUVBaWpCLFFBQVFBLFFBQVFvRSxDQUFSLEdBQVlwRSxRQUFRNUQsQ0FBUixHQUFZLENBQUMsbUJBQUFyZixDQUFRLGtEQUFSLEVBQTRCLEdBQUdvQyxNQUEvQixFQUF1QyxJQUF2QyxDQUFqQyxFQUErRSxPQUEvRSxFQUF3RjtBQUN0RjtBQUNBQSxVQUFRLFNBQVNBLE1BQVQsQ0FBZ0I4YjtBQUFXO0FBQTNCLElBQTRDO0FBQ2xELFdBQU80a0IsUUFBUSxJQUFSLEVBQWM1a0IsVUFBZCxFQUEwQnZCLFVBQVUsQ0FBVixDQUExQixDQUFQO0FBQ0Q7QUFKcUYsQ0FBeEYsRTs7Ozs7Ozs7Q0NIQTs7QUFDQSxJQUFJc0csVUFBVSxtQkFBQWpqQixDQUFRLDJDQUFSLENBQWQ7O0FBQ0EsSUFBSStpQyxRQUFRLG1CQUFBL2lDLENBQVEsa0RBQVIsRUFBNEIsQ0FBNUIsQ0FBWjs7QUFDQSxJQUFJOGpCLE1BQU0sV0FBVjtBQUNBLElBQUlrZixTQUFTLElBQWIsQyxDQUNBOztBQUNBLElBQUlsZixPQUFPLEVBQVgsRUFBZW5oQixNQUFNLENBQU4sRUFBU21oQixHQUFULEVBQWMsWUFBWTtBQUFFa2YsV0FBUyxLQUFUO0FBQWlCLENBQTdDO0FBQ2YvZixRQUFRQSxRQUFRb0UsQ0FBUixHQUFZcEUsUUFBUTVELENBQVIsR0FBWTJqQixNQUFoQyxFQUF3QyxPQUF4QyxFQUFpRDtBQUMvQ3hHLGFBQVcsU0FBU0EsU0FBVCxDQUFtQnRlO0FBQVc7QUFBOUIsSUFBd0Q7QUFDakUsV0FBTzZrQixNQUFNLElBQU4sRUFBWTdrQixVQUFaLEVBQXdCdkIsVUFBVS9ZLE1BQVYsR0FBbUIsQ0FBbkIsR0FBdUIrWSxVQUFVLENBQVYsQ0FBdkIsR0FBc0MxWixTQUE5RCxDQUFQO0FBQ0Q7QUFIOEMsQ0FBakQ7O0FBS0EsbUJBQUFqRCxDQUFRLHVEQUFSLEVBQWlDOGpCLEdBQWpDLEU7Ozs7Ozs7O0NDWkE7O0FBQ0EsSUFBSWIsVUFBVSxtQkFBQWpqQixDQUFRLDJDQUFSLENBQWQ7O0FBQ0EsSUFBSStpQyxRQUFRLG1CQUFBL2lDLENBQVEsa0RBQVIsRUFBNEIsQ0FBNUIsQ0FBWjs7QUFDQSxJQUFJOGpCLE1BQU0sTUFBVjtBQUNBLElBQUlrZixTQUFTLElBQWIsQyxDQUNBOztBQUNBLElBQUlsZixPQUFPLEVBQVgsRUFBZW5oQixNQUFNLENBQU4sRUFBU21oQixHQUFULEVBQWMsWUFBWTtBQUFFa2YsV0FBUyxLQUFUO0FBQWlCLENBQTdDO0FBQ2YvZixRQUFRQSxRQUFRb0UsQ0FBUixHQUFZcEUsUUFBUTVELENBQVIsR0FBWTJqQixNQUFoQyxFQUF3QyxPQUF4QyxFQUFpRDtBQUMvQ3pHLFFBQU0sU0FBU0EsSUFBVCxDQUFjcmU7QUFBVztBQUF6QixJQUFtRDtBQUN2RCxXQUFPNmtCLE1BQU0sSUFBTixFQUFZN2tCLFVBQVosRUFBd0J2QixVQUFVL1ksTUFBVixHQUFtQixDQUFuQixHQUF1QitZLFVBQVUsQ0FBVixDQUF2QixHQUFzQzFaLFNBQTlELENBQVA7QUFDRDtBQUg4QyxDQUFqRDs7QUFLQSxtQkFBQWpELENBQVEsdURBQVIsRUFBaUM4akIsR0FBakMsRTs7Ozs7Ozs7QUNiQTs7QUFDQSxJQUFJYixVQUFVLG1CQUFBampCLENBQVEsMkNBQVIsQ0FBZDs7QUFDQSxJQUFJaWpDLFdBQVcsbUJBQUFqakMsQ0FBUSxrREFBUixFQUE0QixDQUE1QixDQUFmOztBQUNBLElBQUlrakMsU0FBUyxtQkFBQWxqQyxDQUFRLGtEQUFSLEVBQTRCLEdBQUd1WSxPQUEvQixFQUF3QyxJQUF4QyxDQUFiOztBQUVBMEssUUFBUUEsUUFBUW9FLENBQVIsR0FBWXBFLFFBQVE1RCxDQUFSLEdBQVksQ0FBQzZqQixNQUFqQyxFQUF5QyxPQUF6QyxFQUFrRDtBQUNoRDtBQUNBM3FCLFdBQVMsU0FBU0EsT0FBVCxDQUFpQjJGO0FBQVc7QUFBNUIsSUFBNkM7QUFDcEQsV0FBTytrQixTQUFTLElBQVQsRUFBZS9rQixVQUFmLEVBQTJCdkIsVUFBVSxDQUFWLENBQTNCLENBQVA7QUFDRDtBQUorQyxDQUFsRCxFOzs7Ozs7OztBQ0xBOztBQUNBLElBQUlZLE1BQU0sbUJBQUF2ZCxDQUFRLHdDQUFSLENBQVY7O0FBQ0EsSUFBSWlqQixVQUFVLG1CQUFBampCLENBQVEsMkNBQVIsQ0FBZDs7QUFDQSxJQUFJb2MsV0FBVyxtQkFBQXBjLENBQVEsOENBQVIsQ0FBZjs7QUFDQSxJQUFJNGYsT0FBTyxtQkFBQTVmLENBQVEsOENBQVIsQ0FBWDs7QUFDQSxJQUFJdXBCLGNBQWMsbUJBQUF2cEIsQ0FBUSxrREFBUixDQUFsQjs7QUFDQSxJQUFJc2MsV0FBVyxtQkFBQXRjLENBQVEsOENBQVIsQ0FBZjs7QUFDQSxJQUFJbWpDLGlCQUFpQixtQkFBQW5qQyxDQUFRLG9EQUFSLENBQXJCOztBQUNBLElBQUl3cEIsWUFBWSxtQkFBQXhwQixDQUFRLDREQUFSLENBQWhCOztBQUVBaWpCLFFBQVFBLFFBQVFrRSxDQUFSLEdBQVlsRSxRQUFRNUQsQ0FBUixHQUFZLENBQUMsbUJBQUFyZixDQUFRLGdEQUFSLEVBQTBCLFVBQVVnZCxJQUFWLEVBQWdCO0FBQUVyYSxRQUFNQyxJQUFOLENBQVdvYSxJQUFYO0FBQW1CLENBQS9ELENBQWpDLEVBQW1HLE9BQW5HLEVBQTRHO0FBQzFHO0FBQ0FwYSxRQUFNLFNBQVNBLElBQVQsQ0FBYzA2QjtBQUFVO0FBQXhCLElBQXdFO0FBQzVFLFFBQUk5Z0IsSUFBSUosU0FBU2toQixTQUFULENBQVI7QUFDQSxRQUFJemUsSUFBSSxPQUFPLElBQVAsSUFBZSxVQUFmLEdBQTRCLElBQTVCLEdBQW1DbGMsS0FBM0M7QUFDQSxRQUFJa2EsT0FBT0YsVUFBVS9ZLE1BQXJCO0FBQ0EsUUFBSXU0QixRQUFRdGYsT0FBTyxDQUFQLEdBQVdGLFVBQVUsQ0FBVixDQUFYLEdBQTBCMVosU0FBdEM7QUFDQSxRQUFJa3hCLFVBQVVnSSxVQUFVbDVCLFNBQXhCO0FBQ0EsUUFBSW5CLFFBQVEsQ0FBWjtBQUNBLFFBQUk2bkIsU0FBU0gsVUFBVWhOLENBQVYsQ0FBYjtBQUNBLFFBQUk1WSxNQUFKLEVBQVkwQyxNQUFaLEVBQW9Cb2EsSUFBcEIsRUFBMEJrSixRQUExQjtBQUNBLFFBQUl1SyxPQUFKLEVBQWFnSSxRQUFRNWUsSUFBSTRlLEtBQUosRUFBV3RmLE9BQU8sQ0FBUCxHQUFXRixVQUFVLENBQVYsQ0FBWCxHQUEwQjFaLFNBQXJDLEVBQWdELENBQWhELENBQVIsQ0FUK0QsQ0FVNUU7O0FBQ0EsUUFBSTBtQixVQUFVMW1CLFNBQVYsSUFBdUIsRUFBRTRiLEtBQUtsYyxLQUFMLElBQWM0bUIsWUFBWUksTUFBWixDQUFoQixDQUEzQixFQUFpRTtBQUMvRCxXQUFLQyxXQUFXRCxPQUFPL0osSUFBUCxDQUFZcEQsQ0FBWixDQUFYLEVBQTJCbFcsU0FBUyxJQUFJdVksQ0FBSixFQUF6QyxFQUFrRCxDQUFDLENBQUM2QixPQUFPa0osU0FBU2xtQixJQUFULEVBQVIsRUFBeUJtbUIsSUFBNUUsRUFBa0YvbkIsT0FBbEYsRUFBMkY7QUFDekZxaEMsdUJBQWU3OEIsTUFBZixFQUF1QnhFLEtBQXZCLEVBQThCcXlCLFVBQVV2VSxLQUFLZ0ssUUFBTCxFQUFldVMsS0FBZixFQUFzQixDQUFDemIsS0FBS25nQixLQUFOLEVBQWF1QixLQUFiLENBQXRCLEVBQTJDLElBQTNDLENBQVYsR0FBNkQ0ZSxLQUFLbmdCLEtBQWhHO0FBQ0Q7QUFDRixLQUpELE1BSU87QUFDTHFELGVBQVMwWSxTQUFTRSxFQUFFNVksTUFBWCxDQUFUOztBQUNBLFdBQUswQyxTQUFTLElBQUl1WSxDQUFKLENBQU1qYixNQUFOLENBQWQsRUFBNkJBLFNBQVM5QixLQUF0QyxFQUE2Q0EsT0FBN0MsRUFBc0Q7QUFDcERxaEMsdUJBQWU3OEIsTUFBZixFQUF1QnhFLEtBQXZCLEVBQThCcXlCLFVBQVVnSSxNQUFNM2YsRUFBRTFhLEtBQUYsQ0FBTixFQUFnQkEsS0FBaEIsQ0FBVixHQUFtQzBhLEVBQUUxYSxLQUFGLENBQWpFO0FBQ0Q7QUFDRjs7QUFDRHdFLFdBQU8xQyxNQUFQLEdBQWdCOUIsS0FBaEI7QUFDQSxXQUFPd0UsTUFBUDtBQUNEO0FBekJ5RyxDQUE1RyxFOzs7Ozs7OztBQ1ZBOztBQUNBLElBQUkyYyxVQUFVLG1CQUFBampCLENBQVEsMkNBQVIsQ0FBZDs7QUFDQSxJQUFJb2pDLFdBQVcsbUJBQUFwakMsQ0FBUSxtREFBUixFQUE2QixLQUE3QixDQUFmOztBQUNBLElBQUl5ckIsVUFBVSxHQUFHZ1IsT0FBakI7QUFDQSxJQUFJNEcsZ0JBQWdCLENBQUMsQ0FBQzVYLE9BQUYsSUFBYSxJQUFJLENBQUMsQ0FBRCxFQUFJZ1IsT0FBSixDQUFZLENBQVosRUFBZSxDQUFDLENBQWhCLENBQUosR0FBeUIsQ0FBMUQ7QUFFQXhaLFFBQVFBLFFBQVFvRSxDQUFSLEdBQVlwRSxRQUFRNUQsQ0FBUixJQUFhZ2tCLGlCQUFpQixDQUFDLG1CQUFBcmpDLENBQVEsa0RBQVIsRUFBNEJ5ckIsT0FBNUIsQ0FBL0IsQ0FBcEIsRUFBMEYsT0FBMUYsRUFBbUc7QUFDakc7QUFDQWdSLFdBQVMsU0FBU0EsT0FBVCxDQUFpQkM7QUFBYztBQUEvQixJQUFzRDtBQUM3RCxXQUFPMkcsY0FDTDtBQURLLE1BRUg1WCxRQUFRMUcsS0FBUixDQUFjLElBQWQsRUFBb0JwSSxTQUFwQixLQUFrQyxDQUYvQixHQUdIeW1CLFNBQVMsSUFBVCxFQUFlMUcsYUFBZixFQUE4Qi9mLFVBQVUsQ0FBVixDQUE5QixDQUhKO0FBSUQ7QUFQZ0csQ0FBbkcsRTs7Ozs7OztBQ05BO0FBQ0EsSUFBSXNHLFVBQVUsbUJBQUFqakIsQ0FBUSwyQ0FBUixDQUFkOztBQUVBaWpCLFFBQVFBLFFBQVFrRSxDQUFoQixFQUFtQixPQUFuQixFQUE0QjtBQUFFclgsV0FBUyxtQkFBQTlQLENBQVEsNkNBQVI7QUFBWCxDQUE1QixFOzs7Ozs7OztBQ0hBOztBQUNBLElBQUlzakMsbUJBQW1CLG1CQUFBdGpDLENBQVEsdURBQVIsQ0FBdkI7O0FBQ0EsSUFBSTBnQixPQUFPLG1CQUFBMWdCLENBQVEsOENBQVIsQ0FBWDs7QUFDQSxJQUFJb3FCLFlBQVksbUJBQUFwcUIsQ0FBUSw4Q0FBUixDQUFoQjs7QUFDQSxJQUFJa2QsWUFBWSxtQkFBQWxkLENBQVEsK0NBQVIsQ0FBaEIsQyxDQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTBiLE9BQU9wYixPQUFQLEdBQWlCLG1CQUFBTixDQUFRLGdEQUFSLEVBQTBCMkMsS0FBMUIsRUFBaUMsT0FBakMsRUFBMEMsVUFBVXFmLFFBQVYsRUFBb0JDLElBQXBCLEVBQTBCO0FBQ25GLE9BQUtSLEVBQUwsR0FBVXZFLFVBQVU4RSxRQUFWLENBQVYsQ0FEbUYsQ0FDcEQ7O0FBQy9CLE9BQUtkLEVBQUwsR0FBVSxDQUFWLENBRm1GLENBRXBEOztBQUMvQixPQUFLZ0IsRUFBTCxHQUFVRCxJQUFWLENBSG1GLENBR3BEO0FBQ2pDO0FBQ0MsQ0FMZ0IsRUFLZCxZQUFZO0FBQ2IsTUFBSXpGLElBQUksS0FBS2lGLEVBQWI7QUFDQSxNQUFJUSxPQUFPLEtBQUtDLEVBQWhCO0FBQ0EsTUFBSXBnQixRQUFRLEtBQUtvZixFQUFMLEVBQVo7O0FBQ0EsTUFBSSxDQUFDMUUsQ0FBRCxJQUFNMWEsU0FBUzBhLEVBQUU1WSxNQUFyQixFQUE2QjtBQUMzQixTQUFLNmQsRUFBTCxHQUFVeGUsU0FBVjtBQUNBLFdBQU95ZCxLQUFLLENBQUwsQ0FBUDtBQUNEOztBQUNELE1BQUl1QixRQUFRLE1BQVosRUFBb0IsT0FBT3ZCLEtBQUssQ0FBTCxFQUFRNWUsS0FBUixDQUFQO0FBQ3BCLE1BQUltZ0IsUUFBUSxRQUFaLEVBQXNCLE9BQU92QixLQUFLLENBQUwsRUFBUWxFLEVBQUUxYSxLQUFGLENBQVIsQ0FBUDtBQUN0QixTQUFPNGUsS0FBSyxDQUFMLEVBQVEsQ0FBQzVlLEtBQUQsRUFBUTBhLEVBQUUxYSxLQUFGLENBQVIsQ0FBUixDQUFQO0FBQ0QsQ0FoQmdCLEVBZ0JkLFFBaEJjLENBQWpCLEMsQ0FrQkE7O0FBQ0Fzb0IsVUFBVW1aLFNBQVYsR0FBc0JuWixVQUFVem5CLEtBQWhDO0FBRUEyZ0MsaUJBQWlCLE1BQWpCO0FBQ0FBLGlCQUFpQixRQUFqQjtBQUNBQSxpQkFBaUIsU0FBakIsRTs7Ozs7Ozs7Q0NoQ0E7O0FBQ0EsSUFBSXJnQixVQUFVLG1CQUFBampCLENBQVEsMkNBQVIsQ0FBZDs7QUFDQSxJQUFJa2QsWUFBWSxtQkFBQWxkLENBQVEsK0NBQVIsQ0FBaEI7O0FBQ0EsSUFBSXM2QixZQUFZLEdBQUc5YSxJQUFuQixDLENBRUE7O0FBQ0F5RCxRQUFRQSxRQUFRb0UsQ0FBUixHQUFZcEUsUUFBUTVELENBQVIsSUFBYSxtQkFBQXJmLENBQVEsNENBQVIsS0FBeUJJLE1BQXpCLElBQW1DLENBQUMsbUJBQUFKLENBQVEsa0RBQVIsRUFBNEJzNkIsU0FBNUIsQ0FBakQsQ0FBcEIsRUFBOEcsT0FBOUcsRUFBdUg7QUFDckg5YSxRQUFNLFNBQVNBLElBQVQsQ0FBY29kLFNBQWQsRUFBeUI7QUFDN0IsV0FBT3RDLFVBQVUxYSxJQUFWLENBQWUxQyxVQUFVLElBQVYsQ0FBZixFQUFnQzBmLGNBQWMzNUIsU0FBZCxHQUEwQixHQUExQixHQUFnQzI1QixTQUFoRSxDQUFQO0FBQ0Q7QUFIb0gsQ0FBdkgsRTs7Ozs7Ozs7QUNQQTs7QUFDQSxJQUFJM1osVUFBVSxtQkFBQWpqQixDQUFRLDJDQUFSLENBQWQ7O0FBQ0EsSUFBSWtkLFlBQVksbUJBQUFsZCxDQUFRLCtDQUFSLENBQWhCOztBQUNBLElBQUlnMUIsWUFBWSxtQkFBQWgxQixDQUFRLCtDQUFSLENBQWhCOztBQUNBLElBQUlzYyxXQUFXLG1CQUFBdGMsQ0FBUSw4Q0FBUixDQUFmOztBQUNBLElBQUl5ckIsVUFBVSxHQUFHeU8sV0FBakI7QUFDQSxJQUFJbUosZ0JBQWdCLENBQUMsQ0FBQzVYLE9BQUYsSUFBYSxJQUFJLENBQUMsQ0FBRCxFQUFJeU8sV0FBSixDQUFnQixDQUFoQixFQUFtQixDQUFDLENBQXBCLENBQUosR0FBNkIsQ0FBOUQ7QUFFQWpYLFFBQVFBLFFBQVFvRSxDQUFSLEdBQVlwRSxRQUFRNUQsQ0FBUixJQUFhZ2tCLGlCQUFpQixDQUFDLG1CQUFBcmpDLENBQVEsa0RBQVIsRUFBNEJ5ckIsT0FBNUIsQ0FBL0IsQ0FBcEIsRUFBMEYsT0FBMUYsRUFBbUc7QUFDakc7QUFDQXlPLGVBQWEsU0FBU0EsV0FBVCxDQUFxQndDO0FBQWM7QUFBbkMsSUFBK0Q7QUFDMUU7QUFDQSxRQUFJMkcsYUFBSixFQUFtQixPQUFPNVgsUUFBUTFHLEtBQVIsQ0FBYyxJQUFkLEVBQW9CcEksU0FBcEIsS0FBa0MsQ0FBekM7QUFDbkIsUUFBSUgsSUFBSVUsVUFBVSxJQUFWLENBQVI7QUFDQSxRQUFJdFosU0FBUzBZLFNBQVNFLEVBQUU1WSxNQUFYLENBQWI7QUFDQSxRQUFJOUIsUUFBUThCLFNBQVMsQ0FBckI7QUFDQSxRQUFJK1ksVUFBVS9ZLE1BQVYsR0FBbUIsQ0FBdkIsRUFBMEI5QixRQUFReUYsS0FBS3dCLEdBQUwsQ0FBU2pILEtBQVQsRUFBZ0JrekIsVUFBVXJZLFVBQVUsQ0FBVixDQUFWLENBQWhCLENBQVI7QUFDMUIsUUFBSTdhLFFBQVEsQ0FBWixFQUFlQSxRQUFROEIsU0FBUzlCLEtBQWpCOztBQUNmLFdBQU1BLFNBQVMsQ0FBZixFQUFrQkEsT0FBbEI7QUFBMkIsVUFBSUEsU0FBUzBhLENBQWIsRUFBZ0IsSUFBSUEsRUFBRTFhLEtBQUYsTUFBYTQ2QixhQUFqQixFQUFnQyxPQUFPNTZCLFNBQVMsQ0FBaEI7QUFBM0U7O0FBQ0EsV0FBTyxDQUFDLENBQVI7QUFDRDtBQVpnRyxDQUFuRyxFOzs7Ozs7OztBQ1JBOztBQUNBLElBQUltaEIsVUFBVSxtQkFBQWpqQixDQUFRLDJDQUFSLENBQWQ7O0FBQ0EsSUFBSW83QixPQUFPLG1CQUFBcDdCLENBQVEsa0RBQVIsRUFBNEIsQ0FBNUIsQ0FBWDs7QUFFQWlqQixRQUFRQSxRQUFRb0UsQ0FBUixHQUFZcEUsUUFBUTVELENBQVIsR0FBWSxDQUFDLG1CQUFBcmYsQ0FBUSxrREFBUixFQUE0QixHQUFHK0IsR0FBL0IsRUFBb0MsSUFBcEMsQ0FBakMsRUFBNEUsT0FBNUUsRUFBcUY7QUFDbkY7QUFDQUEsT0FBSyxTQUFTQSxHQUFULENBQWFtYztBQUFXO0FBQXhCLElBQXlDO0FBQzVDLFdBQU9rZCxLQUFLLElBQUwsRUFBV2xkLFVBQVgsRUFBdUJ2QixVQUFVLENBQVYsQ0FBdkIsQ0FBUDtBQUNEO0FBSmtGLENBQXJGLEU7Ozs7Ozs7O0FDSkE7O0FBQ0EsSUFBSXNHLFVBQVUsbUJBQUFqakIsQ0FBUSwyQ0FBUixDQUFkOztBQUNBLElBQUltakMsaUJBQWlCLG1CQUFBbmpDLENBQVEsb0RBQVIsQ0FBckIsQyxDQUVBOzs7QUFDQWlqQixRQUFRQSxRQUFRa0UsQ0FBUixHQUFZbEUsUUFBUTVELENBQVIsR0FBWSxtQkFBQXJmLENBQVEsMENBQVIsRUFBb0IsWUFBWTtBQUM5RCxXQUFTcWYsQ0FBVCxHQUFhO0FBQUU7QUFBYTs7QUFDNUIsU0FBTyxFQUFFMWMsTUFBTTJ4QixFQUFOLENBQVMxVSxJQUFULENBQWNQLENBQWQsYUFBNEJBLENBQTlCLENBQVA7QUFDRCxDQUgrQixDQUFoQyxFQUdJLE9BSEosRUFHYTtBQUNYO0FBQ0FpVixNQUFJLFNBQVNBLEVBQVQ7QUFBWTtBQUFlO0FBQzdCLFFBQUl4eUIsUUFBUSxDQUFaO0FBQ0EsUUFBSSthLE9BQU9GLFVBQVUvWSxNQUFyQjtBQUNBLFFBQUkwQyxTQUFTLEtBQUssT0FBTyxJQUFQLElBQWUsVUFBZixHQUE0QixJQUE1QixHQUFtQzNELEtBQXhDLEVBQStDa2EsSUFBL0MsQ0FBYjs7QUFDQSxXQUFPQSxPQUFPL2EsS0FBZDtBQUFxQnFoQyxxQkFBZTc4QixNQUFmLEVBQXVCeEUsS0FBdkIsRUFBOEI2YSxVQUFVN2EsT0FBVixDQUE5QjtBQUFyQjs7QUFDQXdFLFdBQU8xQyxNQUFQLEdBQWdCaVosSUFBaEI7QUFDQSxXQUFPdlcsTUFBUDtBQUNEO0FBVFUsQ0FIYixFOzs7Ozs7OztBQ0xBOztBQUNBLElBQUkyYyxVQUFVLG1CQUFBampCLENBQVEsMkNBQVIsQ0FBZDs7QUFDQSxJQUFJd2pDLFVBQVUsbUJBQUF4akMsQ0FBUSxpREFBUixDQUFkOztBQUVBaWpCLFFBQVFBLFFBQVFvRSxDQUFSLEdBQVlwRSxRQUFRNUQsQ0FBUixHQUFZLENBQUMsbUJBQUFyZixDQUFRLGtEQUFSLEVBQTRCLEdBQUdxNkIsV0FBL0IsRUFBNEMsSUFBNUMsQ0FBakMsRUFBb0YsT0FBcEYsRUFBNkY7QUFDM0Y7QUFDQUEsZUFBYSxTQUFTQSxXQUFULENBQXFCbmM7QUFBVztBQUFoQyxJQUFzRDtBQUNqRSxXQUFPc2xCLFFBQVEsSUFBUixFQUFjdGxCLFVBQWQsRUFBMEJ2QixVQUFVL1ksTUFBcEMsRUFBNEMrWSxVQUFVLENBQVYsQ0FBNUMsRUFBMEQsSUFBMUQsQ0FBUDtBQUNEO0FBSjBGLENBQTdGLEU7Ozs7Ozs7O0FDSkE7O0FBQ0EsSUFBSXNHLFVBQVUsbUJBQUFqakIsQ0FBUSwyQ0FBUixDQUFkOztBQUNBLElBQUl3akMsVUFBVSxtQkFBQXhqQyxDQUFRLGlEQUFSLENBQWQ7O0FBRUFpakIsUUFBUUEsUUFBUW9FLENBQVIsR0FBWXBFLFFBQVE1RCxDQUFSLEdBQVksQ0FBQyxtQkFBQXJmLENBQVEsa0RBQVIsRUFBNEIsR0FBR3NDLE1BQS9CLEVBQXVDLElBQXZDLENBQWpDLEVBQStFLE9BQS9FLEVBQXdGO0FBQ3RGO0FBQ0FBLFVBQVEsU0FBU0EsTUFBVCxDQUFnQjRiO0FBQVc7QUFBM0IsSUFBaUQ7QUFDdkQsV0FBT3NsQixRQUFRLElBQVIsRUFBY3RsQixVQUFkLEVBQTBCdkIsVUFBVS9ZLE1BQXBDLEVBQTRDK1ksVUFBVSxDQUFWLENBQTVDLEVBQTBELEtBQTFELENBQVA7QUFDRDtBQUpxRixDQUF4RixFOzs7Ozs7OztBQ0pBOztBQUNBLElBQUlzRyxVQUFVLG1CQUFBampCLENBQVEsMkNBQVIsQ0FBZDs7QUFDQSxJQUFJMDJCLE9BQU8sbUJBQUExMkIsQ0FBUSx5Q0FBUixDQUFYOztBQUNBLElBQUk0YixNQUFNLG1CQUFBNWIsQ0FBUSx3Q0FBUixDQUFWOztBQUNBLElBQUlxYyxrQkFBa0IsbUJBQUFyYyxDQUFRLHNEQUFSLENBQXRCOztBQUNBLElBQUlzYyxXQUFXLG1CQUFBdGMsQ0FBUSw4Q0FBUixDQUFmOztBQUNBLElBQUlpZixhQUFhLEdBQUdDLEtBQXBCLEMsQ0FFQTs7QUFDQStELFFBQVFBLFFBQVFvRSxDQUFSLEdBQVlwRSxRQUFRNUQsQ0FBUixHQUFZLG1CQUFBcmYsQ0FBUSwwQ0FBUixFQUFvQixZQUFZO0FBQzlELE1BQUkwMkIsSUFBSixFQUFVelgsV0FBV1csSUFBWCxDQUFnQjhXLElBQWhCO0FBQ1gsQ0FGK0IsQ0FBaEMsRUFFSSxPQUZKLEVBRWE7QUFDWHhYLFNBQU8sU0FBU0EsS0FBVCxDQUFlK2QsS0FBZixFQUFzQjkxQixHQUF0QixFQUEyQjtBQUNoQyxRQUFJc1YsTUFBTUgsU0FBUyxLQUFLMVksTUFBZCxDQUFWO0FBQ0EsUUFBSWc3QixRQUFRaGpCLElBQUksSUFBSixDQUFaO0FBQ0F6VSxVQUFNQSxRQUFRbEUsU0FBUixHQUFvQndaLEdBQXBCLEdBQTBCdFYsR0FBaEM7QUFDQSxRQUFJeTNCLFNBQVMsT0FBYixFQUFzQixPQUFPM2YsV0FBV1csSUFBWCxDQUFnQixJQUFoQixFQUFzQnFkLEtBQXRCLEVBQTZCOTFCLEdBQTdCLENBQVA7QUFDdEIsUUFBSWpHLFFBQVFtYixnQkFBZ0I0Z0IsS0FBaEIsRUFBdUJ4Z0IsR0FBdkIsQ0FBWjtBQUNBLFFBQUlnbkIsT0FBT3BuQixnQkFBZ0JsVixHQUFoQixFQUFxQnNWLEdBQXJCLENBQVg7QUFDQSxRQUFJdEUsT0FBT21FLFNBQVNtbkIsT0FBT3ZpQyxLQUFoQixDQUFYO0FBQ0EsUUFBSXdpQyxTQUFTL2dDLE1BQU13VixJQUFOLENBQWI7QUFDQSxRQUFJL1csSUFBSSxDQUFSOztBQUNBLFdBQU9BLElBQUkrVyxJQUFYLEVBQWlCL1csR0FBakI7QUFBc0JzaUMsYUFBT3RpQyxDQUFQLElBQVl3OUIsU0FBUyxRQUFULEdBQzlCLEtBQUs3TCxNQUFMLENBQVk3eEIsUUFBUUUsQ0FBcEIsQ0FEOEIsR0FFOUIsS0FBS0YsUUFBUUUsQ0FBYixDQUZrQjtBQUF0Qjs7QUFHQSxXQUFPc2lDLE1BQVA7QUFDRDtBQWZVLENBRmIsRTs7Ozs7Ozs7QUNUQTs7QUFDQSxJQUFJemdCLFVBQVUsbUJBQUFqakIsQ0FBUSwyQ0FBUixDQUFkOztBQUNBLElBQUkyakMsUUFBUSxtQkFBQTNqQyxDQUFRLGtEQUFSLEVBQTRCLENBQTVCLENBQVo7O0FBRUFpakIsUUFBUUEsUUFBUW9FLENBQVIsR0FBWXBFLFFBQVE1RCxDQUFSLEdBQVksQ0FBQyxtQkFBQXJmLENBQVEsa0RBQVIsRUFBNEIsR0FBRzZELElBQS9CLEVBQXFDLElBQXJDLENBQWpDLEVBQTZFLE9BQTdFLEVBQXNGO0FBQ3BGO0FBQ0FBLFFBQU0sU0FBU0EsSUFBVCxDQUFjcWE7QUFBVztBQUF6QixJQUEwQztBQUM5QyxXQUFPeWxCLE1BQU0sSUFBTixFQUFZemxCLFVBQVosRUFBd0J2QixVQUFVLENBQVYsQ0FBeEIsQ0FBUDtBQUNEO0FBSm1GLENBQXRGLEU7Ozs7Ozs7O0FDSkE7O0FBQ0EsSUFBSXNHLFVBQVUsbUJBQUFqakIsQ0FBUSwyQ0FBUixDQUFkOztBQUNBLElBQUl3ZSxZQUFZLG1CQUFBeGUsQ0FBUSwrQ0FBUixDQUFoQjs7QUFDQSxJQUFJb2MsV0FBVyxtQkFBQXBjLENBQVEsOENBQVIsQ0FBZjs7QUFDQSxJQUFJb2pCLFFBQVEsbUJBQUFwakIsQ0FBUSwwQ0FBUixDQUFaOztBQUNBLElBQUk0akMsUUFBUSxHQUFHcEosSUFBZjtBQUNBLElBQUluSCxPQUFPLENBQUMsQ0FBRCxFQUFJLENBQUosRUFBTyxDQUFQLENBQVg7QUFFQXBRLFFBQVFBLFFBQVFvRSxDQUFSLEdBQVlwRSxRQUFRNUQsQ0FBUixJQUFhK0QsTUFBTSxZQUFZO0FBQ2pEO0FBQ0FpUSxPQUFLbUgsSUFBTCxDQUFVdjNCLFNBQVY7QUFDRCxDQUhnQyxLQUczQixDQUFDbWdCLE1BQU0sWUFBWTtBQUN2QjtBQUNBaVEsT0FBS21ILElBQUwsQ0FBVSxJQUFWLEVBRnVCLENBR3ZCO0FBQ0QsQ0FKTSxDQUgwQixJQU8zQixDQUFDLG1CQUFBeDZCLENBQVEsa0RBQVIsRUFBNEI0akMsS0FBNUIsQ0FQYSxDQUFwQixFQU80QyxPQVA1QyxFQU9xRDtBQUNuRDtBQUNBcEosUUFBTSxTQUFTQSxJQUFULENBQWN1QyxTQUFkLEVBQXlCO0FBQzdCLFdBQU9BLGNBQWM5NUIsU0FBZCxHQUNIMmdDLE1BQU1oa0IsSUFBTixDQUFXeEQsU0FBUyxJQUFULENBQVgsQ0FERyxHQUVId25CLE1BQU1oa0IsSUFBTixDQUFXeEQsU0FBUyxJQUFULENBQVgsRUFBMkJvQyxVQUFVdWUsU0FBVixDQUEzQixDQUZKO0FBR0Q7QUFOa0QsQ0FQckQsRTs7Ozs7OztBQ1JBLG1CQUFBLzhCLENBQVEsZ0RBQVIsRUFBMEIsT0FBMUIsRTs7Ozs7OztBQ0FBO0FBQ0EsSUFBSWlqQixVQUFVLG1CQUFBampCLENBQVEsMkNBQVIsQ0FBZDs7QUFFQWlqQixRQUFRQSxRQUFRa0UsQ0FBaEIsRUFBbUIsTUFBbkIsRUFBMkI7QUFBRXdRLE9BQUssZUFBWTtBQUFFLFdBQU8sSUFBSTFTLElBQUosR0FBV0QsT0FBWCxFQUFQO0FBQThCO0FBQW5ELENBQTNCLEU7Ozs7Ozs7QUNIQTtBQUNBLElBQUkvQixVQUFVLG1CQUFBampCLENBQVEsMkNBQVIsQ0FBZDs7QUFDQSxJQUFJbWxCLGNBQWMsbUJBQUFubEIsQ0FBUSx1REFBUixDQUFsQixDLENBRUE7OztBQUNBaWpCLFFBQVFBLFFBQVFvRSxDQUFSLEdBQVlwRSxRQUFRNUQsQ0FBUixJQUFhNEYsS0FBS2pKLFNBQUwsQ0FBZW1KLFdBQWYsS0FBK0JBLFdBQTVDLENBQXBCLEVBQThFLE1BQTlFLEVBQXNGO0FBQ3BGQSxlQUFhQTtBQUR1RSxDQUF0RixFOzs7Ozs7OztBQ0xBOztBQUNBLElBQUlsQyxVQUFVLG1CQUFBampCLENBQVEsMkNBQVIsQ0FBZDs7QUFDQSxJQUFJb2MsV0FBVyxtQkFBQXBjLENBQVEsOENBQVIsQ0FBZjs7QUFDQSxJQUFJbW1CLGNBQWMsbUJBQUFubUIsQ0FBUSxpREFBUixDQUFsQjs7QUFFQWlqQixRQUFRQSxRQUFRb0UsQ0FBUixHQUFZcEUsUUFBUTVELENBQVIsR0FBWSxtQkFBQXJmLENBQVEsMENBQVIsRUFBb0IsWUFBWTtBQUM5RCxTQUFPLElBQUlpbEIsSUFBSixDQUFTSyxHQUFULEVBQWN6TyxNQUFkLE9BQTJCLElBQTNCLElBQ0ZvTyxLQUFLakosU0FBTCxDQUFlbkYsTUFBZixDQUFzQitJLElBQXRCLENBQTJCO0FBQUV1RixpQkFBYSx1QkFBWTtBQUFFLGFBQU8sQ0FBUDtBQUFXO0FBQXhDLEdBQTNCLE1BQTJFLENBRGhGO0FBRUQsQ0FIK0IsQ0FBaEMsRUFHSSxNQUhKLEVBR1k7QUFDVjtBQUNBdE8sVUFBUSxTQUFTQSxNQUFULENBQWdCclYsR0FBaEIsRUFBcUI7QUFDM0IsUUFBSWdiLElBQUlKLFNBQVMsSUFBVCxDQUFSO0FBQ0EsUUFBSXluQixLQUFLMWQsWUFBWTNKLENBQVosQ0FBVDtBQUNBLFdBQU8sT0FBT3FuQixFQUFQLElBQWEsUUFBYixJQUF5QixDQUFDdGUsU0FBU3NlLEVBQVQsQ0FBMUIsR0FBeUMsSUFBekMsR0FBZ0RybkIsRUFBRTJJLFdBQUYsRUFBdkQ7QUFDRDtBQU5TLENBSFosRTs7Ozs7OztBQ0xBLElBQUkyZSxlQUFlLG1CQUFBOWpDLENBQVEsd0NBQVIsRUFBa0IsYUFBbEIsQ0FBbkI7O0FBQ0EsSUFBSTRqQixRQUFRcUIsS0FBS2pKLFNBQWpCO0FBRUEsSUFBSSxFQUFFOG5CLGdCQUFnQmxnQixLQUFsQixDQUFKLEVBQThCLG1CQUFBNWpCLENBQVEseUNBQVIsRUFBbUI0akIsS0FBbkIsRUFBMEJrZ0IsWUFBMUIsRUFBd0MsbUJBQUE5akMsQ0FBUSxzREFBUixDQUF4QyxFOzs7Ozs7O0FDSDlCLElBQUkrakMsWUFBWTllLEtBQUtqSixTQUFyQjtBQUNBLElBQUlnb0IsZUFBZSxjQUFuQjtBQUNBLElBQUluUSxZQUFZLFVBQWhCO0FBQ0EsSUFBSUMsWUFBWWlRLFVBQVVsUSxTQUFWLENBQWhCO0FBQ0EsSUFBSTdPLFVBQVUrZSxVQUFVL2UsT0FBeEI7O0FBQ0EsSUFBSSxJQUFJQyxJQUFKLENBQVNLLEdBQVQsSUFBZ0IsRUFBaEIsSUFBc0IwZSxZQUExQixFQUF3QztBQUN0Q2hrQyxFQUFBLG1CQUFBQSxDQUFRLDZDQUFSLEVBQXVCK2pDLFNBQXZCLEVBQWtDbFEsU0FBbEMsRUFBNkMsU0FBU3hULFFBQVQsR0FBb0I7QUFDL0QsUUFBSTlmLFFBQVF5a0IsUUFBUXBGLElBQVIsQ0FBYSxJQUFiLENBQVosQ0FEK0QsQ0FFL0Q7O0FBQ0EsV0FBT3JmLFVBQVVBLEtBQVYsR0FBa0J1ekIsVUFBVWxVLElBQVYsQ0FBZSxJQUFmLENBQWxCLEdBQXlDb2tCLFlBQWhEO0FBQ0QsR0FKRDtBQUtELEM7Ozs7Ozs7QUNYRDtBQUNBLElBQUkvZ0IsVUFBVSxtQkFBQWpqQixDQUFRLDJDQUFSLENBQWQ7O0FBRUFpakIsUUFBUUEsUUFBUW9FLENBQWhCLEVBQW1CLFVBQW5CLEVBQStCO0FBQUU1SCxRQUFNLG1CQUFBemYsQ0FBUSx5Q0FBUjtBQUFSLENBQS9CLEU7Ozs7Ozs7O0FDSEE7O0FBQ0EsSUFBSW1jLFdBQVcsbUJBQUFuYyxDQUFRLDhDQUFSLENBQWY7O0FBQ0EsSUFBSTZxQixpQkFBaUIsbUJBQUE3cUIsQ0FBUSwrQ0FBUixDQUFyQjs7QUFDQSxJQUFJaWtDLGVBQWUsbUJBQUFqa0MsQ0FBUSx3Q0FBUixFQUFrQixhQUFsQixDQUFuQjs7QUFDQSxJQUFJa2tDLGdCQUFnQjNrQixTQUFTdkQsU0FBN0IsQyxDQUNBOztBQUNBLElBQUksRUFBRWlvQixnQkFBZ0JDLGFBQWxCLENBQUosRUFBc0MsbUJBQUFsa0MsQ0FBUSw4Q0FBUixFQUF3QnFlLENBQXhCLENBQTBCNmxCLGFBQTFCLEVBQXlDRCxZQUF6QyxFQUF1RDtBQUFFMWpDLFNBQU8sZUFBVWljLENBQVYsRUFBYTtBQUNqSCxRQUFJLE9BQU8sSUFBUCxJQUFlLFVBQWYsSUFBNkIsQ0FBQ0wsU0FBU0ssQ0FBVCxDQUFsQyxFQUErQyxPQUFPLEtBQVA7QUFDL0MsUUFBSSxDQUFDTCxTQUFTLEtBQUtILFNBQWQsQ0FBTCxFQUErQixPQUFPUSxhQUFhLElBQXBCLENBRmtGLENBR2pIOztBQUNBLFdBQU9BLElBQUlxTyxlQUFlck8sQ0FBZixDQUFYO0FBQThCLFVBQUksS0FBS1IsU0FBTCxLQUFtQlEsQ0FBdkIsRUFBMEIsT0FBTyxJQUFQO0FBQXhEOztBQUNBLFdBQU8sS0FBUDtBQUNEO0FBTjRGLENBQXZELEU7Ozs7Ozs7QUNOdEMsSUFBSThELEtBQUssbUJBQUF0Z0IsQ0FBUSw4Q0FBUixFQUF3QnFlLENBQWpDOztBQUNBLElBQUk4bEIsU0FBUzVrQixTQUFTdkQsU0FBdEI7QUFDQSxJQUFJb29CLFNBQVMsdUJBQWI7QUFDQSxJQUFJN2lCLE9BQU8sTUFBWCxDLENBRUE7O0FBQ0FBLFFBQVE0aUIsTUFBUixJQUFrQixtQkFBQW5rQyxDQUFRLGdEQUFSLEtBQTZCc2dCLEdBQUc2akIsTUFBSCxFQUFXNWlCLElBQVgsRUFBaUI7QUFDOURtUyxnQkFBYyxJQURnRDtBQUU5RDdSLE9BQUssZUFBWTtBQUNmLFFBQUk7QUFDRixhQUFPLENBQUMsS0FBSyxJQUFOLEVBQVl3aUIsS0FBWixDQUFrQkQsTUFBbEIsRUFBMEIsQ0FBMUIsQ0FBUDtBQUNELEtBRkQsQ0FFRSxPQUFPbmtCLENBQVAsRUFBVTtBQUNWLGFBQU8sRUFBUDtBQUNEO0FBQ0Y7QUFSNkQsQ0FBakIsQ0FBL0MsQzs7Ozs7Ozs7QUNOQTs7QUFDQSxJQUFJcWtCLFNBQVMsbUJBQUF0a0MsQ0FBUSxzREFBUixDQUFiOztBQUNBLElBQUk4Z0IsV0FBVyxtQkFBQTlnQixDQUFRLHdEQUFSLENBQWY7O0FBQ0EsSUFBSXVrQyxNQUFNLEtBQVYsQyxDQUVBOztBQUNBN29CLE9BQU9wYixPQUFQLEdBQWlCLG1CQUFBTixDQUFRLCtDQUFSLEVBQXlCdWtDLEdBQXpCLEVBQThCLFVBQVUxaUIsR0FBVixFQUFlO0FBQzVELFNBQU8sU0FBUzhMLEdBQVQsR0FBZTtBQUFFLFdBQU85TCxJQUFJLElBQUosRUFBVWxGLFVBQVUvWSxNQUFWLEdBQW1CLENBQW5CLEdBQXVCK1ksVUFBVSxDQUFWLENBQXZCLEdBQXNDMVosU0FBaEQsQ0FBUDtBQUFvRSxHQUE1RjtBQUNELENBRmdCLEVBRWQ7QUFDRDtBQUNBNGUsT0FBSyxTQUFTQSxHQUFULENBQWFyZ0IsR0FBYixFQUFrQjtBQUNyQixRQUFJeWYsUUFBUXFqQixPQUFPdGpCLFFBQVAsQ0FBZ0JGLFNBQVMsSUFBVCxFQUFleWpCLEdBQWYsQ0FBaEIsRUFBcUMvaUMsR0FBckMsQ0FBWjtBQUNBLFdBQU95ZixTQUFTQSxNQUFNclQsQ0FBdEI7QUFDRCxHQUxBO0FBTUQ7QUFDQWtWLE9BQUssU0FBU0EsR0FBVCxDQUFhdGhCLEdBQWIsRUFBa0JqQixLQUFsQixFQUF5QjtBQUM1QixXQUFPK2pDLE9BQU94aUIsR0FBUCxDQUFXaEIsU0FBUyxJQUFULEVBQWV5akIsR0FBZixDQUFYLEVBQWdDL2lDLFFBQVEsQ0FBUixHQUFZLENBQVosR0FBZ0JBLEdBQWhELEVBQXFEakIsS0FBckQsQ0FBUDtBQUNEO0FBVEEsQ0FGYyxFQVlkK2pDLE1BWmMsRUFZTixJQVpNLENBQWpCLEM7Ozs7Ozs7QUNOQTtBQUNBLElBQUlyaEIsVUFBVSxtQkFBQWpqQixDQUFRLDJDQUFSLENBQWQ7O0FBQ0EsSUFBSThzQixRQUFRLG1CQUFBOXNCLENBQVEsK0NBQVIsQ0FBWjs7QUFDQSxJQUFJd0ksT0FBT2pCLEtBQUtpQixJQUFoQjtBQUNBLElBQUlnOEIsU0FBU2o5QixLQUFLazlCLEtBQWxCO0FBRUF4aEIsUUFBUUEsUUFBUWtFLENBQVIsR0FBWWxFLFFBQVE1RCxDQUFSLEdBQVksRUFBRW1sQixPQUNoQztBQURnQyxHQUU3Qmo5QixLQUFLOGlCLEtBQUwsQ0FBV21hLE9BQU9FLE9BQU9DLFNBQWQsQ0FBWCxLQUF3QyxHQUZYLENBR2hDO0FBSGdDLEdBSTdCSCxPQUFPM1gsUUFBUCxLQUFvQkEsUUFKTyxDQUFoQyxFQUtHLE1BTEgsRUFLVztBQUNUNFgsU0FBTyxTQUFTQSxLQUFULENBQWV0Z0MsQ0FBZixFQUFrQjtBQUN2QixXQUFPLENBQUNBLElBQUksQ0FBQ0EsQ0FBTixJQUFXLENBQVgsR0FBZW1oQixHQUFmLEdBQXFCbmhCLElBQUksaUJBQUosR0FDeEJvRCxLQUFLd2xCLEdBQUwsQ0FBUzVvQixDQUFULElBQWNvRCxLQUFLNjNCLEdBREssR0FFeEJ0UyxNQUFNM29CLElBQUksQ0FBSixHQUFRcUUsS0FBS3JFLElBQUksQ0FBVCxJQUFjcUUsS0FBS3JFLElBQUksQ0FBVCxDQUE1QixDQUZKO0FBR0Q7QUFMUSxDQUxYLEU7Ozs7Ozs7QUNOQTtBQUNBLElBQUk4ZSxVQUFVLG1CQUFBampCLENBQVEsMkNBQVIsQ0FBZDs7QUFDQSxJQUFJNGtDLFNBQVNyOUIsS0FBS3M5QixLQUFsQjs7QUFFQSxTQUFTQSxLQUFULENBQWUxZ0MsQ0FBZixFQUFrQjtBQUNoQixTQUFPLENBQUNvaEIsU0FBU3BoQixJQUFJLENBQUNBLENBQWQsQ0FBRCxJQUFxQkEsS0FBSyxDQUExQixHQUE4QkEsQ0FBOUIsR0FBa0NBLElBQUksQ0FBSixHQUFRLENBQUMwZ0MsTUFBTSxDQUFDMWdDLENBQVAsQ0FBVCxHQUFxQm9ELEtBQUt3bEIsR0FBTCxDQUFTNW9CLElBQUlvRCxLQUFLaUIsSUFBTCxDQUFVckUsSUFBSUEsQ0FBSixHQUFRLENBQWxCLENBQWIsQ0FBOUQ7QUFDRCxDLENBRUQ7OztBQUNBOGUsUUFBUUEsUUFBUWtFLENBQVIsR0FBWWxFLFFBQVE1RCxDQUFSLEdBQVksRUFBRXVsQixVQUFVLElBQUlBLE9BQU8sQ0FBUCxDQUFKLEdBQWdCLENBQTVCLENBQWhDLEVBQWdFLE1BQWhFLEVBQXdFO0FBQUVDLFNBQU9BO0FBQVQsQ0FBeEUsRTs7Ozs7OztBQ1RBO0FBQ0EsSUFBSTVoQixVQUFVLG1CQUFBampCLENBQVEsMkNBQVIsQ0FBZDs7QUFDQSxJQUFJOGtDLFNBQVN2OUIsS0FBS3c5QixLQUFsQixDLENBRUE7O0FBQ0E5aEIsUUFBUUEsUUFBUWtFLENBQVIsR0FBWWxFLFFBQVE1RCxDQUFSLEdBQVksRUFBRXlsQixVQUFVLElBQUlBLE9BQU8sQ0FBQyxDQUFSLENBQUosR0FBaUIsQ0FBN0IsQ0FBaEMsRUFBaUUsTUFBakUsRUFBeUU7QUFDdkVDLFNBQU8sU0FBU0EsS0FBVCxDQUFlNWdDLENBQWYsRUFBa0I7QUFDdkIsV0FBTyxDQUFDQSxJQUFJLENBQUNBLENBQU4sS0FBWSxDQUFaLEdBQWdCQSxDQUFoQixHQUFvQm9ELEtBQUt3bEIsR0FBTCxDQUFTLENBQUMsSUFBSTVvQixDQUFMLEtBQVcsSUFBSUEsQ0FBZixDQUFULElBQThCLENBQXpEO0FBQ0Q7QUFIc0UsQ0FBekUsRTs7Ozs7OztBQ0xBO0FBQ0EsSUFBSThlLFVBQVUsbUJBQUFqakIsQ0FBUSwyQ0FBUixDQUFkOztBQUNBLElBQUlnVyxPQUFPLG1CQUFBaFcsQ0FBUSw4Q0FBUixDQUFYOztBQUVBaWpCLFFBQVFBLFFBQVFrRSxDQUFoQixFQUFtQixNQUFuQixFQUEyQjtBQUN6QjZkLFFBQU0sU0FBU0EsSUFBVCxDQUFjN2dDLENBQWQsRUFBaUI7QUFDckIsV0FBTzZSLEtBQUs3UixJQUFJLENBQUNBLENBQVYsSUFBZW9ELEtBQUs2a0IsR0FBTCxDQUFTN2tCLEtBQUtNLEdBQUwsQ0FBUzFELENBQVQsQ0FBVCxFQUFzQixJQUFJLENBQTFCLENBQXRCO0FBQ0Q7QUFId0IsQ0FBM0IsRTs7Ozs7OztBQ0pBO0FBQ0EsSUFBSThlLFVBQVUsbUJBQUFqakIsQ0FBUSwyQ0FBUixDQUFkOztBQUVBaWpCLFFBQVFBLFFBQVFrRSxDQUFoQixFQUFtQixNQUFuQixFQUEyQjtBQUN6QjhkLFNBQU8sU0FBU0EsS0FBVCxDQUFlOWdDLENBQWYsRUFBa0I7QUFDdkIsV0FBTyxDQUFDQSxPQUFPLENBQVIsSUFBYSxLQUFLb0QsS0FBSzhpQixLQUFMLENBQVc5aUIsS0FBS3dsQixHQUFMLENBQVM1b0IsSUFBSSxHQUFiLElBQW9Cb0QsS0FBSzI5QixLQUFwQyxDQUFsQixHQUErRCxFQUF0RTtBQUNEO0FBSHdCLENBQTNCLEU7Ozs7Ozs7QUNIQTtBQUNBLElBQUlqaUIsVUFBVSxtQkFBQWpqQixDQUFRLDJDQUFSLENBQWQ7O0FBQ0EsSUFBSTBuQixNQUFNbmdCLEtBQUttZ0IsR0FBZjtBQUVBekUsUUFBUUEsUUFBUWtFLENBQWhCLEVBQW1CLE1BQW5CLEVBQTJCO0FBQ3pCZ2UsUUFBTSxTQUFTQSxJQUFULENBQWNoaEMsQ0FBZCxFQUFpQjtBQUNyQixXQUFPLENBQUN1akIsSUFBSXZqQixJQUFJLENBQUNBLENBQVQsSUFBY3VqQixJQUFJLENBQUN2akIsQ0FBTCxDQUFmLElBQTBCLENBQWpDO0FBQ0Q7QUFId0IsQ0FBM0IsRTs7Ozs7OztBQ0pBO0FBQ0EsSUFBSThlLFVBQVUsbUJBQUFqakIsQ0FBUSwyQ0FBUixDQUFkOztBQUNBLElBQUlrc0IsU0FBUyxtQkFBQWxzQixDQUFRLCtDQUFSLENBQWI7O0FBRUFpakIsUUFBUUEsUUFBUWtFLENBQVIsR0FBWWxFLFFBQVE1RCxDQUFSLElBQWE2TSxVQUFVM2tCLEtBQUs0a0IsS0FBNUIsQ0FBcEIsRUFBd0QsTUFBeEQsRUFBZ0U7QUFBRUEsU0FBT0Q7QUFBVCxDQUFoRSxFOzs7Ozs7O0FDSkE7QUFDQSxJQUFJakosVUFBVSxtQkFBQWpqQixDQUFRLDJDQUFSLENBQWQ7O0FBRUFpakIsUUFBUUEsUUFBUWtFLENBQWhCLEVBQW1CLE1BQW5CLEVBQTJCO0FBQUV1RixVQUFRLG1CQUFBMXNCLENBQVEsZ0RBQVI7QUFBVixDQUEzQixFOzs7Ozs7O0FDSEE7QUFDQSxJQUFJaWpCLFVBQVUsbUJBQUFqakIsQ0FBUSwyQ0FBUixDQUFkOztBQUNBLElBQUk2SCxNQUFNTixLQUFLTSxHQUFmO0FBRUFvYixRQUFRQSxRQUFRa0UsQ0FBaEIsRUFBbUIsTUFBbkIsRUFBMkI7QUFDekJpZSxTQUFPLFNBQVNBLEtBQVQsQ0FBZUMsTUFBZixFQUF1QkMsTUFBdkIsRUFBK0I7QUFBRTtBQUN0QyxRQUFJendCLE1BQU0sQ0FBVjtBQUNBLFFBQUl6VCxJQUFJLENBQVI7QUFDQSxRQUFJeWIsT0FBT0YsVUFBVS9ZLE1BQXJCO0FBQ0EsUUFBSTJoQyxPQUFPLENBQVg7QUFDQSxRQUFJOWMsR0FBSixFQUFTK2MsR0FBVDs7QUFDQSxXQUFPcGtDLElBQUl5YixJQUFYLEVBQWlCO0FBQ2Y0TCxZQUFNNWdCLElBQUk4VSxVQUFVdmIsR0FBVixDQUFKLENBQU47O0FBQ0EsVUFBSW1rQyxPQUFPOWMsR0FBWCxFQUFnQjtBQUNkK2MsY0FBTUQsT0FBTzljLEdBQWI7QUFDQTVULGNBQU1BLE1BQU0yd0IsR0FBTixHQUFZQSxHQUFaLEdBQWtCLENBQXhCO0FBQ0FELGVBQU85YyxHQUFQO0FBQ0QsT0FKRCxNQUlPLElBQUlBLE1BQU0sQ0FBVixFQUFhO0FBQ2xCK2MsY0FBTS9jLE1BQU04YyxJQUFaO0FBQ0Exd0IsZUFBTzJ3QixNQUFNQSxHQUFiO0FBQ0QsT0FITSxNQUdBM3dCLE9BQU80VCxHQUFQO0FBQ1I7O0FBQ0QsV0FBTzhjLFNBQVMxWSxRQUFULEdBQW9CQSxRQUFwQixHQUErQjBZLE9BQU9oK0IsS0FBS2lCLElBQUwsQ0FBVXFNLEdBQVYsQ0FBN0M7QUFDRDtBQW5Cd0IsQ0FBM0IsRTs7Ozs7OztBQ0pBO0FBQ0EsSUFBSW9PLFVBQVUsbUJBQUFqakIsQ0FBUSwyQ0FBUixDQUFkOztBQUNBLElBQUl5bEMsUUFBUWwrQixLQUFLbStCLElBQWpCLEMsQ0FFQTs7QUFDQXppQixRQUFRQSxRQUFRa0UsQ0FBUixHQUFZbEUsUUFBUTVELENBQVIsR0FBWSxtQkFBQXJmLENBQVEsMENBQVIsRUFBb0IsWUFBWTtBQUM5RCxTQUFPeWxDLE1BQU0sVUFBTixFQUFrQixDQUFsQixLQUF3QixDQUFDLENBQXpCLElBQThCQSxNQUFNN2hDLE1BQU4sSUFBZ0IsQ0FBckQ7QUFDRCxDQUYrQixDQUFoQyxFQUVJLE1BRkosRUFFWTtBQUNWOGhDLFFBQU0sU0FBU0EsSUFBVCxDQUFjdmhDLENBQWQsRUFBaUIyRCxDQUFqQixFQUFvQjtBQUN4QixRQUFJNjlCLFNBQVMsTUFBYjtBQUNBLFFBQUlDLEtBQUssQ0FBQ3poQyxDQUFWO0FBQ0EsUUFBSTBoQyxLQUFLLENBQUMvOUIsQ0FBVjtBQUNBLFFBQUlnK0IsS0FBS0gsU0FBU0MsRUFBbEI7QUFDQSxRQUFJRyxLQUFLSixTQUFTRSxFQUFsQjtBQUNBLFdBQU8sSUFBSUMsS0FBS0MsRUFBTCxJQUFXLENBQUNKLFNBQVNDLE9BQU8sRUFBakIsSUFBdUJHLEVBQXZCLEdBQTRCRCxNQUFNSCxTQUFTRSxPQUFPLEVBQXRCLENBQTVCLElBQXlELEVBQXpELEtBQWdFLENBQTNFLENBQVg7QUFDRDtBQVJTLENBRlosRTs7Ozs7OztBQ0xBO0FBQ0EsSUFBSTVpQixVQUFVLG1CQUFBampCLENBQVEsMkNBQVIsQ0FBZDs7QUFFQWlqQixRQUFRQSxRQUFRa0UsQ0FBaEIsRUFBbUIsTUFBbkIsRUFBMkI7QUFDekI2ZSxTQUFPLFNBQVNBLEtBQVQsQ0FBZTdoQyxDQUFmLEVBQWtCO0FBQ3ZCLFdBQU9vRCxLQUFLd2xCLEdBQUwsQ0FBUzVvQixDQUFULElBQWNvRCxLQUFLMCtCLE1BQTFCO0FBQ0Q7QUFId0IsQ0FBM0IsRTs7Ozs7OztBQ0hBO0FBQ0EsSUFBSWhqQixVQUFVLG1CQUFBampCLENBQVEsMkNBQVIsQ0FBZDs7QUFFQWlqQixRQUFRQSxRQUFRa0UsQ0FBaEIsRUFBbUIsTUFBbkIsRUFBMkI7QUFBRTJGLFNBQU8sbUJBQUE5c0IsQ0FBUSwrQ0FBUjtBQUFULENBQTNCLEU7Ozs7Ozs7QUNIQTtBQUNBLElBQUlpakIsVUFBVSxtQkFBQWpqQixDQUFRLDJDQUFSLENBQWQ7O0FBRUFpakIsUUFBUUEsUUFBUWtFLENBQWhCLEVBQW1CLE1BQW5CLEVBQTJCO0FBQ3pCK2UsUUFBTSxTQUFTQSxJQUFULENBQWMvaEMsQ0FBZCxFQUFpQjtBQUNyQixXQUFPb0QsS0FBS3dsQixHQUFMLENBQVM1b0IsQ0FBVCxJQUFjb0QsS0FBSzYzQixHQUExQjtBQUNEO0FBSHdCLENBQTNCLEU7Ozs7Ozs7QUNIQTtBQUNBLElBQUluYyxVQUFVLG1CQUFBampCLENBQVEsMkNBQVIsQ0FBZDs7QUFFQWlqQixRQUFRQSxRQUFRa0UsQ0FBaEIsRUFBbUIsTUFBbkIsRUFBMkI7QUFBRW5SLFFBQU0sbUJBQUFoVyxDQUFRLDhDQUFSO0FBQVIsQ0FBM0IsRTs7Ozs7OztBQ0hBO0FBQ0EsSUFBSWlqQixVQUFVLG1CQUFBampCLENBQVEsMkNBQVIsQ0FBZDs7QUFDQSxJQUFJbXNCLFFBQVEsbUJBQUFuc0IsQ0FBUSwrQ0FBUixDQUFaOztBQUNBLElBQUkwbkIsTUFBTW5nQixLQUFLbWdCLEdBQWYsQyxDQUVBOztBQUNBekUsUUFBUUEsUUFBUWtFLENBQVIsR0FBWWxFLFFBQVE1RCxDQUFSLEdBQVksbUJBQUFyZixDQUFRLDBDQUFSLEVBQW9CLFlBQVk7QUFDOUQsU0FBTyxDQUFDdUgsS0FBSzQrQixJQUFMLENBQVUsQ0FBQyxLQUFYLENBQUQsSUFBc0IsQ0FBQyxLQUE5QjtBQUNELENBRitCLENBQWhDLEVBRUksTUFGSixFQUVZO0FBQ1ZBLFFBQU0sU0FBU0EsSUFBVCxDQUFjaGlDLENBQWQsRUFBaUI7QUFDckIsV0FBT29ELEtBQUtNLEdBQUwsQ0FBUzFELElBQUksQ0FBQ0EsQ0FBZCxJQUFtQixDQUFuQixHQUNILENBQUNnb0IsTUFBTWhvQixDQUFOLElBQVdnb0IsTUFBTSxDQUFDaG9CLENBQVAsQ0FBWixJQUF5QixDQUR0QixHQUVILENBQUN1akIsSUFBSXZqQixJQUFJLENBQVIsSUFBYXVqQixJQUFJLENBQUN2akIsQ0FBRCxHQUFLLENBQVQsQ0FBZCxLQUE4Qm9ELEtBQUs2K0IsQ0FBTCxHQUFTLENBQXZDLENBRko7QUFHRDtBQUxTLENBRlosRTs7Ozs7OztBQ05BO0FBQ0EsSUFBSW5qQixVQUFVLG1CQUFBampCLENBQVEsMkNBQVIsQ0FBZDs7QUFDQSxJQUFJbXNCLFFBQVEsbUJBQUFuc0IsQ0FBUSwrQ0FBUixDQUFaOztBQUNBLElBQUkwbkIsTUFBTW5nQixLQUFLbWdCLEdBQWY7QUFFQXpFLFFBQVFBLFFBQVFrRSxDQUFoQixFQUFtQixNQUFuQixFQUEyQjtBQUN6QmtmLFFBQU0sU0FBU0EsSUFBVCxDQUFjbGlDLENBQWQsRUFBaUI7QUFDckIsUUFBSTRHLElBQUlvaEIsTUFBTWhvQixJQUFJLENBQUNBLENBQVgsQ0FBUjtBQUNBLFFBQUkyRyxJQUFJcWhCLE1BQU0sQ0FBQ2hvQixDQUFQLENBQVI7QUFDQSxXQUFPNEcsS0FBSzhoQixRQUFMLEdBQWdCLENBQWhCLEdBQW9CL2hCLEtBQUsraEIsUUFBTCxHQUFnQixDQUFDLENBQWpCLEdBQXFCLENBQUM5aEIsSUFBSUQsQ0FBTCxLQUFXNGMsSUFBSXZqQixDQUFKLElBQVN1akIsSUFBSSxDQUFDdmpCLENBQUwsQ0FBcEIsQ0FBaEQ7QUFDRDtBQUx3QixDQUEzQixFOzs7Ozs7O0FDTEE7QUFDQSxJQUFJOGUsVUFBVSxtQkFBQWpqQixDQUFRLDJDQUFSLENBQWQ7O0FBRUFpakIsUUFBUUEsUUFBUWtFLENBQWhCLEVBQW1CLE1BQW5CLEVBQTJCO0FBQ3pCbWYsU0FBTyxTQUFTQSxLQUFULENBQWV6a0MsRUFBZixFQUFtQjtBQUN4QixXQUFPLENBQUNBLEtBQUssQ0FBTCxHQUFTMEYsS0FBSzhpQixLQUFkLEdBQXNCOWlCLEtBQUswdUIsSUFBNUIsRUFBa0NwMEIsRUFBbEMsQ0FBUDtBQUNEO0FBSHdCLENBQTNCLEU7Ozs7Ozs7O0FDSEE7O0FBQ0EsSUFBSTVCLFNBQVMsbUJBQUFELENBQVEsMkNBQVIsQ0FBYjs7QUFDQSxJQUFJaUUsTUFBTSxtQkFBQWpFLENBQVEsd0NBQVIsQ0FBVjs7QUFDQSxJQUFJNGIsTUFBTSxtQkFBQTViLENBQVEsd0NBQVIsQ0FBVjs7QUFDQSxJQUFJdWpCLG9CQUFvQixtQkFBQXZqQixDQUFRLHdEQUFSLENBQXhCOztBQUNBLElBQUltbUIsY0FBYyxtQkFBQW5tQixDQUFRLGlEQUFSLENBQWxCOztBQUNBLElBQUlvakIsUUFBUSxtQkFBQXBqQixDQUFRLDBDQUFSLENBQVo7O0FBQ0EsSUFBSTZ4QixPQUFPLG1CQUFBN3hCLENBQVEsZ0RBQVIsRUFBMEJxZSxDQUFyQzs7QUFDQSxJQUFJc1QsT0FBTyxtQkFBQTN4QixDQUFRLGdEQUFSLEVBQTBCcWUsQ0FBckM7O0FBQ0EsSUFBSWlDLEtBQUssbUJBQUF0Z0IsQ0FBUSw4Q0FBUixFQUF3QnFlLENBQWpDOztBQUNBLElBQUl1VSxRQUFRLG1CQUFBNXlCLENBQVEsZ0RBQVIsRUFBMEI2eUIsSUFBdEM7O0FBQ0EsSUFBSXpNLFNBQVMsUUFBYjtBQUNBLElBQUltZ0IsVUFBVXRtQyxPQUFPbW1CLE1BQVAsQ0FBZDtBQUNBLElBQUl6QyxPQUFPNGlCLE9BQVg7QUFDQSxJQUFJM2lCLFFBQVEyaUIsUUFBUXZxQixTQUFwQixDLENBQ0E7O0FBQ0EsSUFBSXdxQixhQUFhNXFCLElBQUksbUJBQUE1YixDQUFRLGtEQUFSLEVBQTRCNGpCLEtBQTVCLENBQUosS0FBMkN3QyxNQUE1RDtBQUNBLElBQUlxZ0IsT0FBTyxVQUFVbmUsT0FBT3RNLFNBQTVCLEMsQ0FFQTs7QUFDQSxJQUFJMHFCLFdBQVcsU0FBWEEsUUFBVyxDQUFVQyxRQUFWLEVBQW9CO0FBQ2pDLE1BQUk5a0MsS0FBS3NrQixZQUFZd2dCLFFBQVosRUFBc0IsS0FBdEIsQ0FBVDs7QUFDQSxNQUFJLE9BQU85a0MsRUFBUCxJQUFhLFFBQWIsSUFBeUJBLEdBQUcrQixNQUFILEdBQVksQ0FBekMsRUFBNEM7QUFDMUMvQixTQUFLNGtDLE9BQU81a0MsR0FBR2d4QixJQUFILEVBQVAsR0FBbUJELE1BQU0vd0IsRUFBTixFQUFVLENBQVYsQ0FBeEI7QUFDQSxRQUFJcUIsUUFBUXJCLEdBQUdxekIsVUFBSCxDQUFjLENBQWQsQ0FBWjtBQUNBLFFBQUkwUixLQUFKLEVBQVd4VCxLQUFYLEVBQWtCeVQsT0FBbEI7O0FBQ0EsUUFBSTNqQyxVQUFVLEVBQVYsSUFBZ0JBLFVBQVUsRUFBOUIsRUFBa0M7QUFDaEMwakMsY0FBUS9rQyxHQUFHcXpCLFVBQUgsQ0FBYyxDQUFkLENBQVI7QUFDQSxVQUFJMFIsVUFBVSxFQUFWLElBQWdCQSxVQUFVLEdBQTlCLEVBQW1DLE9BQU90aEIsR0FBUCxDQUZILENBRWU7QUFDaEQsS0FIRCxNQUdPLElBQUlwaUIsVUFBVSxFQUFkLEVBQWtCO0FBQ3ZCLGNBQVFyQixHQUFHcXpCLFVBQUgsQ0FBYyxDQUFkLENBQVI7QUFDRSxhQUFLLEVBQUw7QUFBUyxhQUFLLEVBQUw7QUFBUzlCLGtCQUFRLENBQVI7QUFBV3lULG9CQUFVLEVBQVY7QUFBYztBQUFPOztBQUNsRCxhQUFLLEVBQUw7QUFBUyxhQUFLLEdBQUw7QUFBVXpULGtCQUFRLENBQVI7QUFBV3lULG9CQUFVLEVBQVY7QUFBYztBQUFPOztBQUNuRDtBQUFTLGlCQUFPLENBQUNobEMsRUFBUjtBQUhYOztBQUtBLFdBQUssSUFBSWlsQyxTQUFTamxDLEdBQUdxZCxLQUFILENBQVMsQ0FBVCxDQUFiLEVBQTBCOWQsSUFBSSxDQUE5QixFQUFpQ3VLLElBQUltN0IsT0FBT2xqQyxNQUE1QyxFQUFvRG1qQyxJQUF6RCxFQUErRDNsQyxJQUFJdUssQ0FBbkUsRUFBc0V2SyxHQUF0RSxFQUEyRTtBQUN6RTJsQyxlQUFPRCxPQUFPNVIsVUFBUCxDQUFrQjl6QixDQUFsQixDQUFQLENBRHlFLENBRXpFO0FBQ0E7O0FBQ0EsWUFBSTJsQyxPQUFPLEVBQVAsSUFBYUEsT0FBT0YsT0FBeEIsRUFBaUMsT0FBT3ZoQixHQUFQO0FBQ2xDOztBQUFDLGFBQU8yTixTQUFTNlQsTUFBVCxFQUFpQjFULEtBQWpCLENBQVA7QUFDSDtBQUNGOztBQUFDLFNBQU8sQ0FBQ3Z4QixFQUFSO0FBQ0gsQ0F2QkQ7O0FBeUJBLElBQUksQ0FBQzBrQyxRQUFRLE1BQVIsQ0FBRCxJQUFvQixDQUFDQSxRQUFRLEtBQVIsQ0FBckIsSUFBdUNBLFFBQVEsTUFBUixDQUEzQyxFQUE0RDtBQUMxREEsWUFBVSxTQUFTN0IsTUFBVCxDQUFnQm5rQyxLQUFoQixFQUF1QjtBQUMvQixRQUFJc0IsS0FBSzhhLFVBQVUvWSxNQUFWLEdBQW1CLENBQW5CLEdBQXVCLENBQXZCLEdBQTJCckQsS0FBcEM7QUFDQSxRQUFJNGQsT0FBTyxJQUFYO0FBQ0EsV0FBT0EsZ0JBQWdCb29CLE9BQWhCLENBQ0w7QUFESyxRQUVEQyxhQUFhcGpCLE1BQU0sWUFBWTtBQUFFUSxZQUFNMFUsT0FBTixDQUFjMVksSUFBZCxDQUFtQnpCLElBQW5CO0FBQTJCLEtBQS9DLENBQWIsR0FBZ0V2QyxJQUFJdUMsSUFBSixLQUFhaUksTUFGNUUsSUFHRDdDLGtCQUFrQixJQUFJSSxJQUFKLENBQVMraUIsU0FBUzdrQyxFQUFULENBQVQsQ0FBbEIsRUFBMENzYyxJQUExQyxFQUFnRG9vQixPQUFoRCxDQUhDLEdBRzBERyxTQUFTN2tDLEVBQVQsQ0FIakU7QUFJRCxHQVBEOztBQVFBLE9BQUssSUFBSWIsT0FBTyxtQkFBQWhCLENBQVEsZ0RBQVIsSUFBNEI2eEIsS0FBS2xPLElBQUwsQ0FBNUIsR0FBeUMsRUFDdkQ7QUFDQSxtRUFDQTtBQUNBLG9FQUZBLEdBR0EsZ0RBTHVELEVBTXZEMkMsS0FOdUQsQ0FNakQsR0FOaUQsQ0FBcEQsRUFNUzhKLElBQUksQ0FOYixFQU1nQjV1QixHQU5yQixFQU0wQlIsS0FBSzRDLE1BQUwsR0FBY3dzQixDQU54QyxFQU0yQ0EsR0FOM0MsRUFNZ0Q7QUFDOUMsUUFBSW5zQixJQUFJMGYsSUFBSixFQUFVbmlCLE1BQU1SLEtBQUtvdkIsQ0FBTCxDQUFoQixLQUE0QixDQUFDbnNCLElBQUlzaUMsT0FBSixFQUFhL2tDLEdBQWIsQ0FBakMsRUFBb0Q7QUFDbEQ4ZSxTQUFHaW1CLE9BQUgsRUFBWS9rQyxHQUFaLEVBQWlCbXdCLEtBQUtoTyxJQUFMLEVBQVduaUIsR0FBWCxDQUFqQjtBQUNEO0FBQ0Y7O0FBQ0Qra0MsVUFBUXZxQixTQUFSLEdBQW9CNEgsS0FBcEI7QUFDQUEsUUFBTTlFLFdBQU4sR0FBb0J5bkIsT0FBcEI7O0FBQ0F2bUMsRUFBQSxtQkFBQUEsQ0FBUSw2Q0FBUixFQUF1QkMsTUFBdkIsRUFBK0JtbUIsTUFBL0IsRUFBdUNtZ0IsT0FBdkM7QUFDRCxDOzs7Ozs7O0FDcEVEO0FBQ0EsSUFBSXRqQixVQUFVLG1CQUFBampCLENBQVEsMkNBQVIsQ0FBZDs7QUFFQWlqQixRQUFRQSxRQUFRa0UsQ0FBaEIsRUFBbUIsUUFBbkIsRUFBNkI7QUFBRWtGLFdBQVM5a0IsS0FBSzZrQixHQUFMLENBQVMsQ0FBVCxFQUFZLENBQUMsRUFBYjtBQUFYLENBQTdCLEU7Ozs7Ozs7QUNIQTtBQUNBLElBQUluSixVQUFVLG1CQUFBampCLENBQVEsMkNBQVIsQ0FBZDs7QUFDQSxJQUFJZ25DLFlBQVksbUJBQUFobkMsQ0FBUSwyQ0FBUixFQUFxQnVsQixRQUFyQzs7QUFFQXRDLFFBQVFBLFFBQVFrRSxDQUFoQixFQUFtQixRQUFuQixFQUE2QjtBQUMzQjVCLFlBQVUsU0FBU0EsUUFBVCxDQUFrQjFqQixFQUFsQixFQUFzQjtBQUM5QixXQUFPLE9BQU9BLEVBQVAsSUFBYSxRQUFiLElBQXlCbWxDLFVBQVVubEMsRUFBVixDQUFoQztBQUNEO0FBSDBCLENBQTdCLEU7Ozs7Ozs7QUNKQTtBQUNBLElBQUlvaEIsVUFBVSxtQkFBQWpqQixDQUFRLDJDQUFSLENBQWQ7O0FBRUFpakIsUUFBUUEsUUFBUWtFLENBQWhCLEVBQW1CLFFBQW5CLEVBQTZCO0FBQUVtRCxhQUFXLG1CQUFBdHFCLENBQVEsK0NBQVI7QUFBYixDQUE3QixFOzs7Ozs7O0FDSEE7QUFDQSxJQUFJaWpCLFVBQVUsbUJBQUFqakIsQ0FBUSwyQ0FBUixDQUFkOztBQUVBaWpCLFFBQVFBLFFBQVFrRSxDQUFoQixFQUFtQixRQUFuQixFQUE2QjtBQUMzQmtSLFNBQU8sU0FBU0EsS0FBVCxDQUFlRCxNQUFmLEVBQXVCO0FBQzVCO0FBQ0EsV0FBT0EsVUFBVUEsTUFBakI7QUFDRDtBQUowQixDQUE3QixFOzs7Ozs7O0FDSEE7QUFDQSxJQUFJblYsVUFBVSxtQkFBQWpqQixDQUFRLDJDQUFSLENBQWQ7O0FBQ0EsSUFBSXNxQixZQUFZLG1CQUFBdHFCLENBQVEsK0NBQVIsQ0FBaEI7O0FBQ0EsSUFBSTZILE1BQU1OLEtBQUtNLEdBQWY7QUFFQW9iLFFBQVFBLFFBQVFrRSxDQUFoQixFQUFtQixRQUFuQixFQUE2QjtBQUMzQjhmLGlCQUFlLFNBQVNBLGFBQVQsQ0FBdUI3TyxNQUF2QixFQUErQjtBQUM1QyxXQUFPOU4sVUFBVThOLE1BQVYsS0FBcUJ2d0IsSUFBSXV3QixNQUFKLEtBQWUsZ0JBQTNDO0FBQ0Q7QUFIMEIsQ0FBN0IsRTs7Ozs7OztBQ0xBO0FBQ0EsSUFBSW5WLFVBQVUsbUJBQUFqakIsQ0FBUSwyQ0FBUixDQUFkOztBQUVBaWpCLFFBQVFBLFFBQVFrRSxDQUFoQixFQUFtQixRQUFuQixFQUE2QjtBQUFFK2Ysb0JBQWtCO0FBQXBCLENBQTdCLEU7Ozs7Ozs7QUNIQTtBQUNBLElBQUlqa0IsVUFBVSxtQkFBQWpqQixDQUFRLDJDQUFSLENBQWQ7O0FBRUFpakIsUUFBUUEsUUFBUWtFLENBQWhCLEVBQW1CLFFBQW5CLEVBQTZCO0FBQUVnZ0Isb0JBQWtCLENBQUM7QUFBckIsQ0FBN0IsRTs7Ozs7OztBQ0hBLElBQUlsa0IsVUFBVSxtQkFBQWpqQixDQUFRLDJDQUFSLENBQWQ7O0FBQ0EsSUFBSTB5QixjQUFjLG1CQUFBMXlCLENBQVEsZ0RBQVIsQ0FBbEIsQyxDQUNBOzs7QUFDQWlqQixRQUFRQSxRQUFRa0UsQ0FBUixHQUFZbEUsUUFBUTVELENBQVIsSUFBYXFsQixPQUFPL1IsVUFBUCxJQUFxQkQsV0FBbEMsQ0FBcEIsRUFBb0UsUUFBcEUsRUFBOEU7QUFBRUMsY0FBWUQ7QUFBZCxDQUE5RSxFOzs7Ozs7O0FDSEEsSUFBSXpQLFVBQVUsbUJBQUFqakIsQ0FBUSwyQ0FBUixDQUFkOztBQUNBLElBQUlnekIsWUFBWSxtQkFBQWh6QixDQUFRLDhDQUFSLENBQWhCLEMsQ0FDQTs7O0FBQ0FpakIsUUFBUUEsUUFBUWtFLENBQVIsR0FBWWxFLFFBQVE1RCxDQUFSLElBQWFxbEIsT0FBT3pSLFFBQVAsSUFBbUJELFNBQWhDLENBQXBCLEVBQWdFLFFBQWhFLEVBQTBFO0FBQUVDLFlBQVVEO0FBQVosQ0FBMUUsRTs7Ozs7Ozs7QUNIQTs7QUFDQSxJQUFJL1AsVUFBVSxtQkFBQWpqQixDQUFRLDJDQUFSLENBQWQ7O0FBQ0EsSUFBSWcxQixZQUFZLG1CQUFBaDFCLENBQVEsK0NBQVIsQ0FBaEI7O0FBQ0EsSUFBSW9uQyxlQUFlLG1CQUFBcG5DLENBQVEsbURBQVIsQ0FBbkI7O0FBQ0EsSUFBSXkxQixTQUFTLG1CQUFBejFCLENBQVEsa0RBQVIsQ0FBYjs7QUFDQSxJQUFJcW5DLFdBQVcsSUFBSUMsT0FBbkI7QUFDQSxJQUFJamQsUUFBUTlpQixLQUFLOGlCLEtBQWpCO0FBQ0EsSUFBSTFJLE9BQU8sQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsRUFBVSxDQUFWLEVBQWEsQ0FBYixFQUFnQixDQUFoQixDQUFYO0FBQ0EsSUFBSTRsQixRQUFRLHVDQUFaO0FBQ0EsSUFBSUMsT0FBTyxHQUFYOztBQUVBLElBQUlyL0IsV0FBVyxTQUFYQSxRQUFXLENBQVV1RCxDQUFWLEVBQWFKLENBQWIsRUFBZ0I7QUFDN0IsTUFBSWxLLElBQUksQ0FBQyxDQUFUO0FBQ0EsTUFBSXFtQyxLQUFLbjhCLENBQVQ7O0FBQ0EsU0FBTyxFQUFFbEssQ0FBRixHQUFNLENBQWIsRUFBZ0I7QUFDZHFtQyxVQUFNLzdCLElBQUlpVyxLQUFLdmdCLENBQUwsQ0FBVjtBQUNBdWdCLFNBQUt2Z0IsQ0FBTCxJQUFVcW1DLEtBQUssR0FBZjtBQUNBQSxTQUFLcGQsTUFBTW9kLEtBQUssR0FBWCxDQUFMO0FBQ0Q7QUFDRixDQVJEOztBQVNBLElBQUlwL0IsU0FBUyxTQUFUQSxNQUFTLENBQVVxRCxDQUFWLEVBQWE7QUFDeEIsTUFBSXRLLElBQUksQ0FBUjtBQUNBLE1BQUlrSyxJQUFJLENBQVI7O0FBQ0EsU0FBTyxFQUFFbEssQ0FBRixJQUFPLENBQWQsRUFBaUI7QUFDZmtLLFNBQUtxVyxLQUFLdmdCLENBQUwsQ0FBTDtBQUNBdWdCLFNBQUt2Z0IsQ0FBTCxJQUFVaXBCLE1BQU0vZSxJQUFJSSxDQUFWLENBQVY7QUFDQUosUUFBS0EsSUFBSUksQ0FBTCxHQUFVLEdBQWQ7QUFDRDtBQUNGLENBUkQ7O0FBU0EsSUFBSWc4QixjQUFjLFNBQWRBLFdBQWMsR0FBWTtBQUM1QixNQUFJdG1DLElBQUksQ0FBUjtBQUNBLE1BQUl5a0IsSUFBSSxFQUFSOztBQUNBLFNBQU8sRUFBRXprQixDQUFGLElBQU8sQ0FBZCxFQUFpQjtBQUNmLFFBQUl5a0IsTUFBTSxFQUFOLElBQVl6a0IsTUFBTSxDQUFsQixJQUF1QnVnQixLQUFLdmdCLENBQUwsTUFBWSxDQUF2QyxFQUEwQztBQUN4QyxVQUFJdW1DLElBQUlyZixPQUFPM0csS0FBS3ZnQixDQUFMLENBQVAsQ0FBUjtBQUNBeWtCLFVBQUlBLE1BQU0sRUFBTixHQUFXOGhCLENBQVgsR0FBZTloQixJQUFJNFAsT0FBTzdWLElBQVAsQ0FBWTRuQixJQUFaLEVBQWtCLElBQUlHLEVBQUUvakMsTUFBeEIsQ0FBSixHQUFzQytqQyxDQUF6RDtBQUNEO0FBQ0Y7O0FBQUMsU0FBTzloQixDQUFQO0FBQ0gsQ0FURDs7QUFVQSxJQUFJdUcsTUFBTSxTQUFOQSxHQUFNLENBQVVqb0IsQ0FBVixFQUFhdUgsQ0FBYixFQUFnQms4QixHQUFoQixFQUFxQjtBQUM3QixTQUFPbDhCLE1BQU0sQ0FBTixHQUFVazhCLEdBQVYsR0FBZ0JsOEIsSUFBSSxDQUFKLEtBQVUsQ0FBVixHQUFjMGdCLElBQUlqb0IsQ0FBSixFQUFPdUgsSUFBSSxDQUFYLEVBQWNrOEIsTUFBTXpqQyxDQUFwQixDQUFkLEdBQXVDaW9CLElBQUlqb0IsSUFBSUEsQ0FBUixFQUFXdUgsSUFBSSxDQUFmLEVBQWtCazhCLEdBQWxCLENBQTlEO0FBQ0QsQ0FGRDs7QUFHQSxJQUFJN2EsTUFBTSxTQUFOQSxHQUFNLENBQVU1b0IsQ0FBVixFQUFhO0FBQ3JCLE1BQUl1SCxJQUFJLENBQVI7QUFDQSxNQUFJaUQsS0FBS3hLLENBQVQ7O0FBQ0EsU0FBT3dLLE1BQU0sSUFBYixFQUFtQjtBQUNqQmpELFNBQUssRUFBTDtBQUNBaUQsVUFBTSxJQUFOO0FBQ0Q7O0FBQ0QsU0FBT0EsTUFBTSxDQUFiLEVBQWdCO0FBQ2RqRCxTQUFLLENBQUw7QUFDQWlELFVBQU0sQ0FBTjtBQUNEOztBQUFDLFNBQU9qRCxDQUFQO0FBQ0gsQ0FYRDs7QUFhQXVYLFFBQVFBLFFBQVFvRSxDQUFSLEdBQVlwRSxRQUFRNUQsQ0FBUixJQUFhLENBQUMsQ0FBQ2dvQixRQUFGLEtBQy9CLFFBQVFDLE9BQVIsQ0FBZ0IsQ0FBaEIsTUFBdUIsT0FBdkIsSUFDQSxJQUFJQSxPQUFKLENBQVksQ0FBWixNQUFtQixHQURuQixJQUVBLE1BQU1BLE9BQU4sQ0FBYyxDQUFkLE1BQXFCLE1BRnJCLElBR0Esc0JBQXNCQSxPQUF0QixDQUE4QixDQUE5QixNQUFxQyxxQkFKTixLQUs1QixDQUFDLG1CQUFBdG5DLENBQVEsMENBQVIsRUFBb0IsWUFBWTtBQUNwQztBQUNBcW5DLFdBQVN6bkIsSUFBVCxDQUFjLEVBQWQ7QUFDRCxDQUhLLENBTGMsQ0FBcEIsRUFRSyxRQVJMLEVBUWU7QUFDYjBuQixXQUFTLFNBQVNBLE9BQVQsQ0FBaUJPLGNBQWpCLEVBQWlDO0FBQ3hDLFFBQUkxakMsSUFBSWlqQyxhQUFhLElBQWIsRUFBbUJHLEtBQW5CLENBQVI7QUFDQSxRQUFJbHBCLElBQUkyVyxVQUFVNlMsY0FBVixDQUFSO0FBQ0EsUUFBSWhpQixJQUFJLEVBQVI7QUFDQSxRQUFJRixJQUFJNmhCLElBQVI7QUFDQSxRQUFJdm5CLENBQUosRUFBTzZuQixDQUFQLEVBQVUxWCxDQUFWLEVBQWFoUCxDQUFiO0FBQ0EsUUFBSS9DLElBQUksQ0FBSixJQUFTQSxJQUFJLEVBQWpCLEVBQXFCLE1BQU1tSCxXQUFXK2hCLEtBQVgsQ0FBTixDQU5tQixDQU94Qzs7QUFDQSxRQUFJcGpDLEtBQUtBLENBQVQsRUFBWSxPQUFPLEtBQVA7QUFDWixRQUFJQSxLQUFLLENBQUMsSUFBTixJQUFjQSxLQUFLLElBQXZCLEVBQTZCLE9BQU9ta0IsT0FBT25rQixDQUFQLENBQVA7O0FBQzdCLFFBQUlBLElBQUksQ0FBUixFQUFXO0FBQ1QwaEIsVUFBSSxHQUFKO0FBQ0ExaEIsVUFBSSxDQUFDQSxDQUFMO0FBQ0Q7O0FBQ0QsUUFBSUEsSUFBSSxLQUFSLEVBQWU7QUFDYjhiLFVBQUk4TSxJQUFJNW9CLElBQUlpb0IsSUFBSSxDQUFKLEVBQU8sRUFBUCxFQUFXLENBQVgsQ0FBUixJQUF5QixFQUE3QjtBQUNBMGIsVUFBSTduQixJQUFJLENBQUosR0FBUTliLElBQUlpb0IsSUFBSSxDQUFKLEVBQU8sQ0FBQ25NLENBQVIsRUFBVyxDQUFYLENBQVosR0FBNEI5YixJQUFJaW9CLElBQUksQ0FBSixFQUFPbk0sQ0FBUCxFQUFVLENBQVYsQ0FBcEM7QUFDQTZuQixXQUFLLGdCQUFMO0FBQ0E3bkIsVUFBSSxLQUFLQSxDQUFUOztBQUNBLFVBQUlBLElBQUksQ0FBUixFQUFXO0FBQ1Q5WCxpQkFBUyxDQUFULEVBQVkyL0IsQ0FBWjtBQUNBMVgsWUFBSS9SLENBQUo7O0FBQ0EsZUFBTytSLEtBQUssQ0FBWixFQUFlO0FBQ2Jqb0IsbUJBQVMsR0FBVCxFQUFjLENBQWQ7QUFDQWlvQixlQUFLLENBQUw7QUFDRDs7QUFDRGpvQixpQkFBU2lrQixJQUFJLEVBQUosRUFBUWdFLENBQVIsRUFBVyxDQUFYLENBQVQsRUFBd0IsQ0FBeEI7QUFDQUEsWUFBSW5RLElBQUksQ0FBUjs7QUFDQSxlQUFPbVEsS0FBSyxFQUFaLEVBQWdCO0FBQ2QvbkIsaUJBQU8sS0FBSyxFQUFaO0FBQ0ErbkIsZUFBSyxFQUFMO0FBQ0Q7O0FBQ0QvbkIsZUFBTyxLQUFLK25CLENBQVo7QUFDQWpvQixpQkFBUyxDQUFULEVBQVksQ0FBWjtBQUNBRSxlQUFPLENBQVA7QUFDQXNkLFlBQUkraEIsYUFBSjtBQUNELE9BakJELE1BaUJPO0FBQ0x2L0IsaUJBQVMsQ0FBVCxFQUFZMi9CLENBQVo7QUFDQTMvQixpQkFBUyxLQUFLLENBQUM4WCxDQUFmLEVBQWtCLENBQWxCO0FBQ0EwRixZQUFJK2hCLGdCQUFnQmpTLE9BQU83VixJQUFQLENBQVk0bkIsSUFBWixFQUFrQm5wQixDQUFsQixDQUFwQjtBQUNEO0FBQ0Y7O0FBQ0QsUUFBSUEsSUFBSSxDQUFSLEVBQVc7QUFDVCtDLFVBQUl1RSxFQUFFL2hCLE1BQU47QUFDQStoQixVQUFJRSxLQUFLekUsS0FBSy9DLENBQUwsR0FBUyxPQUFPb1gsT0FBTzdWLElBQVAsQ0FBWTRuQixJQUFaLEVBQWtCbnBCLElBQUkrQyxDQUF0QixDQUFQLEdBQWtDdUUsQ0FBM0MsR0FBK0NBLEVBQUV6RyxLQUFGLENBQVEsQ0FBUixFQUFXa0MsSUFBSS9DLENBQWYsSUFBb0IsR0FBcEIsR0FBMEJzSCxFQUFFekcsS0FBRixDQUFRa0MsSUFBSS9DLENBQVosQ0FBOUUsQ0FBSjtBQUNELEtBSEQsTUFHTztBQUNMc0gsVUFBSUUsSUFBSUYsQ0FBUjtBQUNEOztBQUFDLFdBQU9BLENBQVA7QUFDSDtBQWpEWSxDQVJmLEU7Ozs7Ozs7O0FDdkRBOztBQUNBLElBQUkxQyxVQUFVLG1CQUFBampCLENBQVEsMkNBQVIsQ0FBZDs7QUFDQSxJQUFJK25DLFNBQVMsbUJBQUEvbkMsQ0FBUSwwQ0FBUixDQUFiOztBQUNBLElBQUlvbkMsZUFBZSxtQkFBQXBuQyxDQUFRLG1EQUFSLENBQW5COztBQUNBLElBQUlnb0MsZUFBZSxJQUFJQyxXQUF2QjtBQUVBaGxCLFFBQVFBLFFBQVFvRSxDQUFSLEdBQVlwRSxRQUFRNUQsQ0FBUixJQUFhMG9CLE9BQU8sWUFBWTtBQUNsRDtBQUNBLFNBQU9DLGFBQWFwb0IsSUFBYixDQUFrQixDQUFsQixFQUFxQjNjLFNBQXJCLE1BQW9DLEdBQTNDO0FBQ0QsQ0FIZ0MsS0FHM0IsQ0FBQzhrQyxPQUFPLFlBQVk7QUFDeEI7QUFDQUMsZUFBYXBvQixJQUFiLENBQWtCLEVBQWxCO0FBQ0QsQ0FITSxDQUhhLENBQXBCLEVBTUssUUFOTCxFQU1lO0FBQ2Jxb0IsZUFBYSxTQUFTQSxXQUFULENBQXFCQyxTQUFyQixFQUFnQztBQUMzQyxRQUFJL3BCLE9BQU9pcEIsYUFBYSxJQUFiLEVBQW1CLDJDQUFuQixDQUFYO0FBQ0EsV0FBT2MsY0FBY2psQyxTQUFkLEdBQTBCK2tDLGFBQWFwb0IsSUFBYixDQUFrQnpCLElBQWxCLENBQTFCLEdBQW9ENnBCLGFBQWFwb0IsSUFBYixDQUFrQnpCLElBQWxCLEVBQXdCK3BCLFNBQXhCLENBQTNEO0FBQ0Q7QUFKWSxDQU5mLEU7Ozs7Ozs7QUNOQTtBQUNBLElBQUlqbEIsVUFBVSxtQkFBQWpqQixDQUFRLDJDQUFSLENBQWQ7O0FBRUFpakIsUUFBUUEsUUFBUWtFLENBQVIsR0FBWWxFLFFBQVE1RCxDQUE1QixFQUErQixRQUEvQixFQUF5QztBQUFFN1YsVUFBUSxtQkFBQXhKLENBQVEsa0RBQVI7QUFBVixDQUF6QyxFOzs7Ozs7O0FDSEEsSUFBSWlqQixVQUFVLG1CQUFBampCLENBQVEsMkNBQVIsQ0FBZCxDLENBQ0E7OztBQUNBaWpCLFFBQVFBLFFBQVFrRSxDQUFoQixFQUFtQixRQUFuQixFQUE2QjtBQUFFeFEsVUFBUSxtQkFBQTNXLENBQVEsa0RBQVI7QUFBVixDQUE3QixFOzs7Ozs7O0FDRkEsSUFBSWlqQixVQUFVLG1CQUFBampCLENBQVEsMkNBQVIsQ0FBZCxDLENBQ0E7OztBQUNBaWpCLFFBQVFBLFFBQVFrRSxDQUFSLEdBQVlsRSxRQUFRNUQsQ0FBUixHQUFZLENBQUMsbUJBQUFyZixDQUFRLGdEQUFSLENBQWpDLEVBQTRELFFBQTVELEVBQXNFO0FBQUV3eEIsb0JBQWtCLG1CQUFBeHhCLENBQVEsK0NBQVI7QUFBcEIsQ0FBdEUsRTs7Ozs7OztBQ0ZBLElBQUlpakIsVUFBVSxtQkFBQWpqQixDQUFRLDJDQUFSLENBQWQsQyxDQUNBOzs7QUFDQWlqQixRQUFRQSxRQUFRa0UsQ0FBUixHQUFZbEUsUUFBUTVELENBQVIsR0FBWSxDQUFDLG1CQUFBcmYsQ0FBUSxnREFBUixDQUFqQyxFQUE0RCxRQUE1RCxFQUFzRTtBQUFFSyxrQkFBZ0IsbUJBQUFMLENBQVEsOENBQVIsRUFBd0JxZTtBQUExQyxDQUF0RSxFOzs7Ozs7O0FDRkE7QUFDQSxJQUFJbEMsV0FBVyxtQkFBQW5jLENBQVEsOENBQVIsQ0FBZjs7QUFDQSxJQUFJbWpCLE9BQU8sbUJBQUFuakIsQ0FBUSx5Q0FBUixFQUFtQjB0QixRQUE5Qjs7QUFFQSxtQkFBQTF0QixDQUFRLCtDQUFSLEVBQXlCLFFBQXpCLEVBQW1DLFVBQVVtb0MsT0FBVixFQUFtQjtBQUNwRCxTQUFPLFNBQVNDLE1BQVQsQ0FBZ0J2bUMsRUFBaEIsRUFBb0I7QUFDekIsV0FBT3NtQyxXQUFXaHNCLFNBQVN0YSxFQUFULENBQVgsR0FBMEJzbUMsUUFBUWhsQixLQUFLdGhCLEVBQUwsQ0FBUixDQUExQixHQUE4Q0EsRUFBckQ7QUFDRCxHQUZEO0FBR0QsQ0FKRCxFOzs7Ozs7O0FDSkE7QUFDQSxJQUFJcWIsWUFBWSxtQkFBQWxkLENBQVEsK0NBQVIsQ0FBaEI7O0FBQ0EsSUFBSXFvQyw0QkFBNEIsbUJBQUFyb0MsQ0FBUSxnREFBUixFQUEwQnFlLENBQTFEOztBQUVBLG1CQUFBcmUsQ0FBUSwrQ0FBUixFQUF5QiwwQkFBekIsRUFBcUQsWUFBWTtBQUMvRCxTQUFPLFNBQVM0eEIsd0JBQVQsQ0FBa0MvdkIsRUFBbEMsRUFBc0NMLEdBQXRDLEVBQTJDO0FBQ2hELFdBQU82bUMsMEJBQTBCbnJCLFVBQVVyYixFQUFWLENBQTFCLEVBQXlDTCxHQUF6QyxDQUFQO0FBQ0QsR0FGRDtBQUdELENBSkQsRTs7Ozs7OztBQ0pBO0FBQ0EsbUJBQUF4QixDQUFRLCtDQUFSLEVBQXlCLHFCQUF6QixFQUFnRCxZQUFZO0FBQzFELFNBQU8sbUJBQUFBLENBQVEsb0RBQVIsRUFBOEJxZSxDQUFyQztBQUNELENBRkQsRTs7Ozs7OztBQ0RBO0FBQ0EsSUFBSWpDLFdBQVcsbUJBQUFwYyxDQUFRLDhDQUFSLENBQWY7O0FBQ0EsSUFBSXNvQyxrQkFBa0IsbUJBQUF0b0MsQ0FBUSwrQ0FBUixDQUF0Qjs7QUFFQSxtQkFBQUEsQ0FBUSwrQ0FBUixFQUF5QixnQkFBekIsRUFBMkMsWUFBWTtBQUNyRCxTQUFPLFNBQVM2cUIsY0FBVCxDQUF3QmhwQixFQUF4QixFQUE0QjtBQUNqQyxXQUFPeW1DLGdCQUFnQmxzQixTQUFTdmEsRUFBVCxDQUFoQixDQUFQO0FBQ0QsR0FGRDtBQUdELENBSkQsRTs7Ozs7OztBQ0pBO0FBQ0EsSUFBSXNhLFdBQVcsbUJBQUFuYyxDQUFRLDhDQUFSLENBQWY7O0FBRUEsbUJBQUFBLENBQVEsK0NBQVIsRUFBeUIsY0FBekIsRUFBeUMsVUFBVXVvQyxhQUFWLEVBQXlCO0FBQ2hFLFNBQU8sU0FBU2piLFlBQVQsQ0FBc0J6ckIsRUFBdEIsRUFBMEI7QUFDL0IsV0FBT3NhLFNBQVN0YSxFQUFULElBQWUwbUMsZ0JBQWdCQSxjQUFjMW1DLEVBQWQsQ0FBaEIsR0FBb0MsSUFBbkQsR0FBMEQsS0FBakU7QUFDRCxHQUZEO0FBR0QsQ0FKRCxFOzs7Ozs7O0FDSEE7QUFDQSxJQUFJc2EsV0FBVyxtQkFBQW5jLENBQVEsOENBQVIsQ0FBZjs7QUFFQSxtQkFBQUEsQ0FBUSwrQ0FBUixFQUF5QixVQUF6QixFQUFxQyxVQUFVd29DLFNBQVYsRUFBcUI7QUFDeEQsU0FBTyxTQUFTQyxRQUFULENBQWtCNW1DLEVBQWxCLEVBQXNCO0FBQzNCLFdBQU9zYSxTQUFTdGEsRUFBVCxJQUFlMm1DLFlBQVlBLFVBQVUzbUMsRUFBVixDQUFaLEdBQTRCLEtBQTNDLEdBQW1ELElBQTFEO0FBQ0QsR0FGRDtBQUdELENBSkQsRTs7Ozs7OztBQ0hBO0FBQ0EsSUFBSXNhLFdBQVcsbUJBQUFuYyxDQUFRLDhDQUFSLENBQWY7O0FBRUEsbUJBQUFBLENBQVEsK0NBQVIsRUFBeUIsVUFBekIsRUFBcUMsVUFBVTBvQyxTQUFWLEVBQXFCO0FBQ3hELFNBQU8sU0FBU0MsUUFBVCxDQUFrQjltQyxFQUFsQixFQUFzQjtBQUMzQixXQUFPc2EsU0FBU3RhLEVBQVQsSUFBZTZtQyxZQUFZQSxVQUFVN21DLEVBQVYsQ0FBWixHQUE0QixLQUEzQyxHQUFtRCxJQUExRDtBQUNELEdBRkQ7QUFHRCxDQUpELEU7Ozs7Ozs7QUNIQTtBQUNBLElBQUlvaEIsVUFBVSxtQkFBQWpqQixDQUFRLDJDQUFSLENBQWQ7O0FBQ0FpakIsUUFBUUEsUUFBUWtFLENBQWhCLEVBQW1CLFFBQW5CLEVBQTZCO0FBQUVuZCxNQUFJLG1CQUFBaEssQ0FBUSwrQ0FBUjtBQUFOLENBQTdCLEU7Ozs7Ozs7QUNGQTtBQUNBLElBQUlvYyxXQUFXLG1CQUFBcGMsQ0FBUSw4Q0FBUixDQUFmOztBQUNBLElBQUlpeUIsUUFBUSxtQkFBQWp5QixDQUFRLGdEQUFSLENBQVo7O0FBRUEsbUJBQUFBLENBQVEsK0NBQVIsRUFBeUIsTUFBekIsRUFBaUMsWUFBWTtBQUMzQyxTQUFPLFNBQVNnQixJQUFULENBQWNhLEVBQWQsRUFBa0I7QUFDdkIsV0FBT293QixNQUFNN1YsU0FBU3ZhLEVBQVQsQ0FBTixDQUFQO0FBQ0QsR0FGRDtBQUdELENBSkQsRTs7Ozs7OztBQ0pBO0FBQ0EsSUFBSXNhLFdBQVcsbUJBQUFuYyxDQUFRLDhDQUFSLENBQWY7O0FBQ0EsSUFBSW1qQixPQUFPLG1CQUFBbmpCLENBQVEseUNBQVIsRUFBbUIwdEIsUUFBOUI7O0FBRUEsbUJBQUExdEIsQ0FBUSwrQ0FBUixFQUF5QixtQkFBekIsRUFBOEMsVUFBVTRvQyxrQkFBVixFQUE4QjtBQUMxRSxTQUFPLFNBQVNwYixpQkFBVCxDQUEyQjNyQixFQUEzQixFQUErQjtBQUNwQyxXQUFPK21DLHNCQUFzQnpzQixTQUFTdGEsRUFBVCxDQUF0QixHQUFxQyttQyxtQkFBbUJ6bEIsS0FBS3RoQixFQUFMLENBQW5CLENBQXJDLEdBQW9FQSxFQUEzRTtBQUNELEdBRkQ7QUFHRCxDQUpELEU7Ozs7Ozs7QUNKQTtBQUNBLElBQUlzYSxXQUFXLG1CQUFBbmMsQ0FBUSw4Q0FBUixDQUFmOztBQUNBLElBQUltakIsT0FBTyxtQkFBQW5qQixDQUFRLHlDQUFSLEVBQW1CMHRCLFFBQTlCOztBQUVBLG1CQUFBMXRCLENBQVEsK0NBQVIsRUFBeUIsTUFBekIsRUFBaUMsVUFBVTZvQyxLQUFWLEVBQWlCO0FBQ2hELFNBQU8sU0FBU0MsSUFBVCxDQUFjam5DLEVBQWQsRUFBa0I7QUFDdkIsV0FBT2duQyxTQUFTMXNCLFNBQVN0YSxFQUFULENBQVQsR0FBd0JnbkMsTUFBTTFsQixLQUFLdGhCLEVBQUwsQ0FBTixDQUF4QixHQUEwQ0EsRUFBakQ7QUFDRCxHQUZEO0FBR0QsQ0FKRCxFOzs7Ozs7O0FDSkE7QUFDQSxJQUFJb2hCLFVBQVUsbUJBQUFqakIsQ0FBUSwyQ0FBUixDQUFkOztBQUNBaWpCLFFBQVFBLFFBQVFrRSxDQUFoQixFQUFtQixRQUFuQixFQUE2QjtBQUFFOEMsa0JBQWdCLG1CQUFBanFCLENBQVEsOENBQVIsRUFBd0I4aUI7QUFBMUMsQ0FBN0IsRTs7Ozs7Ozs7Q0NEQTs7QUFDQSxJQUFJWCxVQUFVLG1CQUFBbmlCLENBQVEsNENBQVIsQ0FBZDs7QUFDQSxJQUFJcXpCLE9BQU8sRUFBWDtBQUNBQSxLQUFLLG1CQUFBcnpCLENBQVEsd0NBQVIsRUFBa0IsYUFBbEIsQ0FBTCxJQUF5QyxHQUF6Qzs7QUFDQSxJQUFJcXpCLE9BQU8sRUFBUCxJQUFhLFlBQWpCLEVBQStCO0FBQzdCcnpCLEVBQUEsbUJBQUFBLENBQVEsNkNBQVIsRUFBdUJJLE9BQU80YixTQUE5QixFQUF5QyxVQUF6QyxFQUFxRCxTQUFTcUUsUUFBVCxHQUFvQjtBQUN2RSxXQUFPLGFBQWE4QixRQUFRLElBQVIsQ0FBYixHQUE2QixHQUFwQztBQUNELEdBRkQsRUFFRyxJQUZIO0FBR0QsQzs7Ozs7OztBQ1RELElBQUljLFVBQVUsbUJBQUFqakIsQ0FBUSwyQ0FBUixDQUFkOztBQUNBLElBQUkweUIsY0FBYyxtQkFBQTF5QixDQUFRLGdEQUFSLENBQWxCLEMsQ0FDQTs7O0FBQ0FpakIsUUFBUUEsUUFBUXNCLENBQVIsR0FBWXRCLFFBQVE1RCxDQUFSLElBQWFzVCxjQUFjRCxXQUEzQixDQUFwQixFQUE2RDtBQUFFQyxjQUFZRDtBQUFkLENBQTdELEU7Ozs7Ozs7QUNIQSxJQUFJelAsVUFBVSxtQkFBQWpqQixDQUFRLDJDQUFSLENBQWQ7O0FBQ0EsSUFBSWd6QixZQUFZLG1CQUFBaHpCLENBQVEsOENBQVIsQ0FBaEIsQyxDQUNBOzs7QUFDQWlqQixRQUFRQSxRQUFRc0IsQ0FBUixHQUFZdEIsUUFBUTVELENBQVIsSUFBYTRULFlBQVlELFNBQXpCLENBQXBCLEVBQXlEO0FBQUVDLFlBQVVEO0FBQVosQ0FBekQsRTs7Ozs7Ozs7QUNIQTs7QUFDQSxJQUFJckksVUFBVSxtQkFBQTNxQixDQUFRLDRDQUFSLENBQWQ7O0FBQ0EsSUFBSUMsU0FBUyxtQkFBQUQsQ0FBUSwyQ0FBUixDQUFiOztBQUNBLElBQUl1ZCxNQUFNLG1CQUFBdmQsQ0FBUSx3Q0FBUixDQUFWOztBQUNBLElBQUltaUIsVUFBVSxtQkFBQW5pQixDQUFRLDRDQUFSLENBQWQ7O0FBQ0EsSUFBSWlqQixVQUFVLG1CQUFBampCLENBQVEsMkNBQVIsQ0FBZDs7QUFDQSxJQUFJbWMsV0FBVyxtQkFBQW5jLENBQVEsOENBQVIsQ0FBZjs7QUFDQSxJQUFJd2UsWUFBWSxtQkFBQXhlLENBQVEsK0NBQVIsQ0FBaEI7O0FBQ0EsSUFBSXdnQixhQUFhLG1CQUFBeGdCLENBQVEsZ0RBQVIsQ0FBakI7O0FBQ0EsSUFBSStjLFFBQVEsbUJBQUEvYyxDQUFRLDJDQUFSLENBQVo7O0FBQ0EsSUFBSStlLHFCQUFxQixtQkFBQS9lLENBQVEsd0RBQVIsQ0FBekI7O0FBQ0EsSUFBSTR2QixPQUFPLG1CQUFBNXZCLENBQVEseUNBQVIsRUFBbUI4aUIsR0FBOUI7O0FBQ0EsSUFBSWltQixZQUFZLG1CQUFBL29DLENBQVEsOENBQVIsR0FBaEI7O0FBQ0EsSUFBSWdwQyw2QkFBNkIsbUJBQUFocEMsQ0FBUSwyREFBUixDQUFqQzs7QUFDQSxJQUFJaXBDLFVBQVUsbUJBQUFqcEMsQ0FBUSw0Q0FBUixDQUFkOztBQUNBLElBQUlrcEMsaUJBQWlCLG1CQUFBbHBDLENBQVEsb0RBQVIsQ0FBckI7O0FBQ0EsSUFBSW1wQyxVQUFVLFNBQWQ7QUFDQSxJQUFJeHRCLFlBQVkxYixPQUFPMGIsU0FBdkI7QUFDQSxJQUFJSCxVQUFVdmIsT0FBT3ViLE9BQXJCO0FBQ0EsSUFBSTR0QixXQUFXbnBDLE9BQU9rcEMsT0FBUCxDQUFmO0FBQ0EsSUFBSXRhLFNBQVMxTSxRQUFRM0csT0FBUixLQUFvQixTQUFqQzs7QUFDQSxJQUFJMWEsUUFBUSxTQUFSQSxLQUFRLEdBQVk7QUFBRTtBQUFhLENBQXZDOztBQUNBLElBQUl1b0MsUUFBSixFQUFjQywyQkFBZCxFQUEyQ0Msb0JBQTNDLEVBQWlFQyxPQUFqRTtBQUNBLElBQUlsVyx1QkFBdUJnVyw4QkFBOEJOLDJCQUEyQjNxQixDQUFwRjtBQUVBLElBQUlvckIsYUFBYSxDQUFDLENBQUMsWUFBWTtBQUM3QixNQUFJO0FBQ0Y7QUFDQSxRQUFJL1osVUFBVTBaLFNBQVNya0MsT0FBVCxDQUFpQixDQUFqQixDQUFkOztBQUNBLFFBQUkya0MsY0FBYyxDQUFDaGEsUUFBUTVRLFdBQVIsR0FBc0IsRUFBdkIsRUFBMkIsbUJBQUE5ZSxDQUFRLHdDQUFSLEVBQWtCLFNBQWxCLENBQTNCLElBQTJELFVBQVUrbkIsSUFBVixFQUFnQjtBQUMzRkEsV0FBS2puQixLQUFMLEVBQVlBLEtBQVo7QUFDRCxLQUZELENBSEUsQ0FNRjs7O0FBQ0EsV0FBTyxDQUFDK3RCLFVBQVUsT0FBTzhhLHFCQUFQLElBQWdDLFVBQTNDLEtBQTBEamEsUUFBUUMsSUFBUixDQUFhN3VCLEtBQWIsYUFBK0I0b0MsV0FBaEc7QUFDRCxHQVJELENBUUUsT0FBT3pwQixDQUFQLEVBQVU7QUFBRTtBQUFhO0FBQzVCLENBVmtCLEVBQW5CLEMsQ0FZQTs7QUFDQSxJQUFJMnBCLGFBQWEsU0FBYkEsVUFBYSxDQUFVL25DLEVBQVYsRUFBYztBQUM3QixNQUFJOHRCLElBQUo7QUFDQSxTQUFPeFQsU0FBU3RhLEVBQVQsS0FBZ0IsUUFBUTh0QixPQUFPOXRCLEdBQUc4dEIsSUFBbEIsS0FBMkIsVUFBM0MsR0FBd0RBLElBQXhELEdBQStELEtBQXRFO0FBQ0QsQ0FIRDs7QUFJQSxJQUFJYixTQUFTLFNBQVRBLE1BQVMsQ0FBVVksT0FBVixFQUFtQm1hLFFBQW5CLEVBQTZCO0FBQ3hDLE1BQUluYSxRQUFRb2EsRUFBWixFQUFnQjtBQUNoQnBhLFVBQVFvYSxFQUFSLEdBQWEsSUFBYjtBQUNBLE1BQUlDLFFBQVFyYSxRQUFRc2EsRUFBcEI7QUFDQWpCLFlBQVUsWUFBWTtBQUNwQixRQUFJeG9DLFFBQVFtdkIsUUFBUXVhLEVBQXBCO0FBQ0EsUUFBSUMsS0FBS3hhLFFBQVF5YSxFQUFSLElBQWMsQ0FBdkI7QUFDQSxRQUFJL29DLElBQUksQ0FBUjs7QUFDQSxRQUFJbzJCLE1BQU0sU0FBTkEsR0FBTSxDQUFVNFMsUUFBVixFQUFvQjtBQUM1QixVQUFJQyxVQUFVSCxLQUFLRSxTQUFTRixFQUFkLEdBQW1CRSxTQUFTRSxJQUExQztBQUNBLFVBQUl2bEMsVUFBVXFsQyxTQUFTcmxDLE9BQXZCO0FBQ0EsVUFBSTJCLFNBQVMwakMsU0FBUzFqQyxNQUF0QjtBQUNBLFVBQUl1b0IsU0FBU21iLFNBQVNuYixNQUF0QjtBQUNBLFVBQUkzb0IsTUFBSixFQUFZcXBCLElBQVo7O0FBQ0EsVUFBSTtBQUNGLFlBQUkwYSxPQUFKLEVBQWE7QUFDWCxjQUFJLENBQUNILEVBQUwsRUFBUztBQUNQLGdCQUFJeGEsUUFBUTZhLEVBQVIsSUFBYyxDQUFsQixFQUFxQkMsa0JBQWtCOWEsT0FBbEI7QUFDckJBLG9CQUFRNmEsRUFBUixHQUFhLENBQWI7QUFDRDs7QUFDRCxjQUFJRixZQUFZLElBQWhCLEVBQXNCL2pDLFNBQVMvRixLQUFULENBQXRCLEtBQ0s7QUFDSCxnQkFBSTB1QixNQUFKLEVBQVlBLE9BQU9FLEtBQVA7QUFDWjdvQixxQkFBUytqQyxRQUFROXBDLEtBQVIsQ0FBVDtBQUNBLGdCQUFJMHVCLE1BQUosRUFBWUEsT0FBT0MsSUFBUDtBQUNiOztBQUNELGNBQUk1b0IsV0FBVzhqQyxTQUFTMWEsT0FBeEIsRUFBaUM7QUFDL0JocEIsbUJBQU9pVixVQUFVLHFCQUFWLENBQVA7QUFDRCxXQUZELE1BRU8sSUFBSWdVLE9BQU9pYSxXQUFXdGpDLE1BQVgsQ0FBWCxFQUErQjtBQUNwQ3FwQixpQkFBSy9QLElBQUwsQ0FBVXRaLE1BQVYsRUFBa0J2QixPQUFsQixFQUEyQjJCLE1BQTNCO0FBQ0QsV0FGTSxNQUVBM0IsUUFBUXVCLE1BQVI7QUFDUixTQWhCRCxNQWdCT0ksT0FBT25HLEtBQVA7QUFDUixPQWxCRCxDQWtCRSxPQUFPMGYsQ0FBUCxFQUFVO0FBQ1Z2WixlQUFPdVosQ0FBUDtBQUNEO0FBQ0YsS0EzQkQ7O0FBNEJBLFdBQU84cEIsTUFBTW5tQyxNQUFOLEdBQWV4QyxDQUF0QjtBQUF5Qm8yQixVQUFJdVMsTUFBTTNvQyxHQUFOLENBQUo7QUFBekIsS0FoQ29CLENBZ0NzQjs7O0FBQzFDc3VCLFlBQVFzYSxFQUFSLEdBQWEsRUFBYjtBQUNBdGEsWUFBUW9hLEVBQVIsR0FBYSxLQUFiO0FBQ0EsUUFBSUQsWUFBWSxDQUFDbmEsUUFBUTZhLEVBQXpCLEVBQTZCRSxZQUFZL2EsT0FBWjtBQUM5QixHQXBDRDtBQXFDRCxDQXpDRDs7QUEwQ0EsSUFBSSthLGNBQWMsU0FBZEEsV0FBYyxDQUFVL2EsT0FBVixFQUFtQjtBQUNuQ0UsT0FBS2hRLElBQUwsQ0FBVTNmLE1BQVYsRUFBa0IsWUFBWTtBQUM1QixRQUFJTSxRQUFRbXZCLFFBQVF1YSxFQUFwQjtBQUNBLFFBQUlTLFlBQVlDLFlBQVlqYixPQUFaLENBQWhCO0FBQ0EsUUFBSXBwQixNQUFKLEVBQVkrakMsT0FBWixFQUFxQk8sT0FBckI7O0FBQ0EsUUFBSUYsU0FBSixFQUFlO0FBQ2Jwa0MsZUFBUzJpQyxRQUFRLFlBQVk7QUFDM0IsWUFBSXBhLE1BQUosRUFBWTtBQUNWclQsa0JBQVFxdkIsSUFBUixDQUFhLG9CQUFiLEVBQW1DdHFDLEtBQW5DLEVBQTBDbXZCLE9BQTFDO0FBQ0QsU0FGRCxNQUVPLElBQUkyYSxVQUFVcHFDLE9BQU82cUMsb0JBQXJCLEVBQTJDO0FBQ2hEVCxrQkFBUTtBQUFFM2EscUJBQVNBLE9BQVg7QUFBb0JxYixvQkFBUXhxQztBQUE1QixXQUFSO0FBQ0QsU0FGTSxNQUVBLElBQUksQ0FBQ3FxQyxVQUFVM3FDLE9BQU8ycUMsT0FBbEIsS0FBOEJBLFFBQVFJLEtBQTFDLEVBQWlEO0FBQ3RESixrQkFBUUksS0FBUixDQUFjLDZCQUFkLEVBQTZDenFDLEtBQTdDO0FBQ0Q7QUFDRixPQVJRLENBQVQsQ0FEYSxDQVViOztBQUNBbXZCLGNBQVE2YSxFQUFSLEdBQWExYixVQUFVOGIsWUFBWWpiLE9BQVosQ0FBVixHQUFpQyxDQUFqQyxHQUFxQyxDQUFsRDtBQUNEOztBQUFDQSxZQUFRdWIsRUFBUixHQUFhaG9DLFNBQWI7QUFDRixRQUFJeW5DLGFBQWFwa0MsT0FBTzJaLENBQXhCLEVBQTJCLE1BQU0zWixPQUFPc0gsQ0FBYjtBQUM1QixHQWxCRDtBQW1CRCxDQXBCRDs7QUFxQkEsSUFBSSs4QixjQUFjLFNBQWRBLFdBQWMsQ0FBVWpiLE9BQVYsRUFBbUI7QUFDbkMsTUFBSUEsUUFBUTZhLEVBQVIsSUFBYyxDQUFsQixFQUFxQixPQUFPLEtBQVA7QUFDckIsTUFBSVIsUUFBUXJhLFFBQVF1YixFQUFSLElBQWN2YixRQUFRc2EsRUFBbEM7QUFDQSxNQUFJNW9DLElBQUksQ0FBUjtBQUNBLE1BQUlncEMsUUFBSjs7QUFDQSxTQUFPTCxNQUFNbm1DLE1BQU4sR0FBZXhDLENBQXRCLEVBQXlCO0FBQ3ZCZ3BDLGVBQVdMLE1BQU0zb0MsR0FBTixDQUFYO0FBQ0EsUUFBSWdwQyxTQUFTRSxJQUFULElBQWlCLENBQUNLLFlBQVlQLFNBQVMxYSxPQUFyQixDQUF0QixFQUFxRCxPQUFPLEtBQVA7QUFDdEQ7O0FBQUMsU0FBTyxJQUFQO0FBQ0gsQ0FURDs7QUFVQSxJQUFJOGEsb0JBQW9CLFNBQXBCQSxpQkFBb0IsQ0FBVTlhLE9BQVYsRUFBbUI7QUFDekNFLE9BQUtoUSxJQUFMLENBQVUzZixNQUFWLEVBQWtCLFlBQVk7QUFDNUIsUUFBSW9xQyxPQUFKOztBQUNBLFFBQUl4YixNQUFKLEVBQVk7QUFDVnJULGNBQVFxdkIsSUFBUixDQUFhLGtCQUFiLEVBQWlDbmIsT0FBakM7QUFDRCxLQUZELE1BRU8sSUFBSTJhLFVBQVVwcUMsT0FBT2lyQyxrQkFBckIsRUFBeUM7QUFDOUNiLGNBQVE7QUFBRTNhLGlCQUFTQSxPQUFYO0FBQW9CcWIsZ0JBQVFyYixRQUFRdWE7QUFBcEMsT0FBUjtBQUNEO0FBQ0YsR0FQRDtBQVFELENBVEQ7O0FBVUEsSUFBSWtCLFVBQVUsU0FBVkEsT0FBVSxDQUFVNXFDLEtBQVYsRUFBaUI7QUFDN0IsTUFBSW12QixVQUFVLElBQWQ7QUFDQSxNQUFJQSxRQUFRdU0sRUFBWixFQUFnQjtBQUNoQnZNLFVBQVF1TSxFQUFSLEdBQWEsSUFBYjtBQUNBdk0sWUFBVUEsUUFBUTBiLEVBQVIsSUFBYzFiLE9BQXhCLENBSjZCLENBSUk7O0FBQ2pDQSxVQUFRdWEsRUFBUixHQUFhMXBDLEtBQWI7QUFDQW12QixVQUFReWEsRUFBUixHQUFhLENBQWI7QUFDQSxNQUFJLENBQUN6YSxRQUFRdWIsRUFBYixFQUFpQnZiLFFBQVF1YixFQUFSLEdBQWF2YixRQUFRc2EsRUFBUixDQUFXOXFCLEtBQVgsRUFBYjtBQUNqQjRQLFNBQU9ZLE9BQVAsRUFBZ0IsSUFBaEI7QUFDRCxDQVREOztBQVVBLElBQUkyYixXQUFXLFNBQVhBLFFBQVcsQ0FBVTlxQyxLQUFWLEVBQWlCO0FBQzlCLE1BQUltdkIsVUFBVSxJQUFkO0FBQ0EsTUFBSUMsSUFBSjtBQUNBLE1BQUlELFFBQVF1TSxFQUFaLEVBQWdCO0FBQ2hCdk0sVUFBUXVNLEVBQVIsR0FBYSxJQUFiO0FBQ0F2TSxZQUFVQSxRQUFRMGIsRUFBUixJQUFjMWIsT0FBeEIsQ0FMOEIsQ0FLRzs7QUFDakMsTUFBSTtBQUNGLFFBQUlBLFlBQVludkIsS0FBaEIsRUFBdUIsTUFBTW9iLFVBQVUsa0NBQVYsQ0FBTjs7QUFDdkIsUUFBSWdVLE9BQU9pYSxXQUFXcnBDLEtBQVgsQ0FBWCxFQUE4QjtBQUM1QndvQyxnQkFBVSxZQUFZO0FBQ3BCLFlBQUl6bkIsVUFBVTtBQUFFOHBCLGNBQUkxYixPQUFOO0FBQWV1TSxjQUFJO0FBQW5CLFNBQWQsQ0FEb0IsQ0FDc0I7O0FBQzFDLFlBQUk7QUFDRnRNLGVBQUsvUCxJQUFMLENBQVVyZixLQUFWLEVBQWlCZ2QsSUFBSTh0QixRQUFKLEVBQWMvcEIsT0FBZCxFQUF1QixDQUF2QixDQUFqQixFQUE0Qy9ELElBQUk0dEIsT0FBSixFQUFhN3BCLE9BQWIsRUFBc0IsQ0FBdEIsQ0FBNUM7QUFDRCxTQUZELENBRUUsT0FBT3JCLENBQVAsRUFBVTtBQUNWa3JCLGtCQUFRdnJCLElBQVIsQ0FBYTBCLE9BQWIsRUFBc0JyQixDQUF0QjtBQUNEO0FBQ0YsT0FQRDtBQVFELEtBVEQsTUFTTztBQUNMeVAsY0FBUXVhLEVBQVIsR0FBYTFwQyxLQUFiO0FBQ0FtdkIsY0FBUXlhLEVBQVIsR0FBYSxDQUFiO0FBQ0FyYixhQUFPWSxPQUFQLEVBQWdCLEtBQWhCO0FBQ0Q7QUFDRixHQWhCRCxDQWdCRSxPQUFPelAsQ0FBUCxFQUFVO0FBQ1ZrckIsWUFBUXZyQixJQUFSLENBQWE7QUFBRXdyQixVQUFJMWIsT0FBTjtBQUFldU0sVUFBSTtBQUFuQixLQUFiLEVBQXlDaGMsQ0FBekMsRUFEVSxDQUNtQztBQUM5QztBQUNGLENBekJELEMsQ0EyQkE7OztBQUNBLElBQUksQ0FBQ3dwQixVQUFMLEVBQWlCO0FBQ2Y7QUFDQUwsYUFBVyxTQUFTdGtDLE9BQVQsQ0FBaUJ3bUMsUUFBakIsRUFBMkI7QUFDcEM5cUIsZUFBVyxJQUFYLEVBQWlCNG9CLFFBQWpCLEVBQTJCRCxPQUEzQixFQUFvQyxJQUFwQztBQUNBM3FCLGNBQVU4c0IsUUFBVjtBQUNBakMsYUFBU3pwQixJQUFULENBQWMsSUFBZDs7QUFDQSxRQUFJO0FBQ0YwckIsZUFBUy90QixJQUFJOHRCLFFBQUosRUFBYyxJQUFkLEVBQW9CLENBQXBCLENBQVQsRUFBaUM5dEIsSUFBSTR0QixPQUFKLEVBQWEsSUFBYixFQUFtQixDQUFuQixDQUFqQztBQUNELEtBRkQsQ0FFRSxPQUFPbmtDLEdBQVAsRUFBWTtBQUNabWtDLGNBQVF2ckIsSUFBUixDQUFhLElBQWIsRUFBbUI1WSxHQUFuQjtBQUNEO0FBQ0YsR0FURCxDQUZlLENBWWY7OztBQUNBcWlDLGFBQVcsU0FBU3ZrQyxPQUFULENBQWlCd21DLFFBQWpCLEVBQTJCO0FBQ3BDLFNBQUt0QixFQUFMLEdBQVUsRUFBVixDQURvQyxDQUNWOztBQUMxQixTQUFLaUIsRUFBTCxHQUFVaG9DLFNBQVYsQ0FGb0MsQ0FFVjs7QUFDMUIsU0FBS2tuQyxFQUFMLEdBQVUsQ0FBVixDQUhvQyxDQUdWOztBQUMxQixTQUFLbE8sRUFBTCxHQUFVLEtBQVYsQ0FKb0MsQ0FJVjs7QUFDMUIsU0FBS2dPLEVBQUwsR0FBVWhuQyxTQUFWLENBTG9DLENBS1Y7O0FBQzFCLFNBQUtzbkMsRUFBTCxHQUFVLENBQVYsQ0FOb0MsQ0FNVjs7QUFDMUIsU0FBS1QsRUFBTCxHQUFVLEtBQVYsQ0FQb0MsQ0FPVjtBQUMzQixHQVJEOztBQVNBVCxXQUFTcnRCLFNBQVQsR0FBcUIsbUJBQUFoYyxDQUFRLGlEQUFSLEVBQTJCb3BDLFNBQVNwdEIsU0FBcEMsRUFBK0M7QUFDbEU7QUFDQTJULFVBQU0sU0FBU0EsSUFBVCxDQUFjNGIsV0FBZCxFQUEyQkMsVUFBM0IsRUFBdUM7QUFDM0MsVUFBSXBCLFdBQVc5VyxxQkFBcUJ2VSxtQkFBbUIsSUFBbkIsRUFBeUJxcUIsUUFBekIsQ0FBckIsQ0FBZjtBQUNBZ0IsZUFBU0YsRUFBVCxHQUFjLE9BQU9xQixXQUFQLElBQXNCLFVBQXRCLEdBQW1DQSxXQUFuQyxHQUFpRCxJQUEvRDtBQUNBbkIsZUFBU0UsSUFBVCxHQUFnQixPQUFPa0IsVUFBUCxJQUFxQixVQUFyQixJQUFtQ0EsVUFBbkQ7QUFDQXBCLGVBQVNuYixNQUFULEdBQWtCSixTQUFTclQsUUFBUXlULE1BQWpCLEdBQTBCaHNCLFNBQTVDOztBQUNBLFdBQUsrbUMsRUFBTCxDQUFRdm1DLElBQVIsQ0FBYTJtQyxRQUFiOztBQUNBLFVBQUksS0FBS2EsRUFBVCxFQUFhLEtBQUtBLEVBQUwsQ0FBUXhuQyxJQUFSLENBQWEybUMsUUFBYjtBQUNiLFVBQUksS0FBS0QsRUFBVCxFQUFhcmIsT0FBTyxJQUFQLEVBQWEsS0FBYjtBQUNiLGFBQU9zYixTQUFTMWEsT0FBaEI7QUFDRCxLQVhpRTtBQVlsRTtBQUNBLGFBQVMsZ0JBQVU4YixVQUFWLEVBQXNCO0FBQzdCLGFBQU8sS0FBSzdiLElBQUwsQ0FBVTFzQixTQUFWLEVBQXFCdW9DLFVBQXJCLENBQVA7QUFDRDtBQWZpRSxHQUEvQyxDQUFyQjs7QUFpQkFqQyx5QkFBdUIsZ0NBQVk7QUFDakMsUUFBSTdaLFVBQVUsSUFBSTJaLFFBQUosRUFBZDtBQUNBLFNBQUszWixPQUFMLEdBQWVBLE9BQWY7QUFDQSxTQUFLM3FCLE9BQUwsR0FBZXdZLElBQUk4dEIsUUFBSixFQUFjM2IsT0FBZCxFQUF1QixDQUF2QixDQUFmO0FBQ0EsU0FBS2hwQixNQUFMLEdBQWM2VyxJQUFJNHRCLE9BQUosRUFBYXpiLE9BQWIsRUFBc0IsQ0FBdEIsQ0FBZDtBQUNELEdBTEQ7O0FBTUFzWiw2QkFBMkIzcUIsQ0FBM0IsR0FBK0JpVix1QkFBdUIsOEJBQVV6VSxDQUFWLEVBQWE7QUFDakUsV0FBT0EsTUFBTXVxQixRQUFOLElBQWtCdnFCLE1BQU0ycUIsT0FBeEIsR0FDSCxJQUFJRCxvQkFBSixDQUF5QjFxQixDQUF6QixDQURHLEdBRUh5cUIsNEJBQTRCenFCLENBQTVCLENBRko7QUFHRCxHQUpEO0FBS0Q7O0FBRURvRSxRQUFRQSxRQUFRc0IsQ0FBUixHQUFZdEIsUUFBUXVCLENBQXBCLEdBQXdCdkIsUUFBUTVELENBQVIsR0FBWSxDQUFDb3FCLFVBQTdDLEVBQXlEO0FBQUUza0MsV0FBU3NrQztBQUFYLENBQXpEOztBQUNBLG1CQUFBcHBDLENBQVEsc0RBQVIsRUFBZ0NvcEMsUUFBaEMsRUFBMENELE9BQTFDOztBQUNBLG1CQUFBbnBDLENBQVEsZ0RBQVIsRUFBMEJtcEMsT0FBMUI7O0FBQ0FLLFVBQVUsbUJBQUF4cEMsQ0FBUSx5Q0FBUixFQUFtQm1wQyxPQUFuQixDQUFWLEMsQ0FFQTs7QUFDQWxtQixRQUFRQSxRQUFRa0UsQ0FBUixHQUFZbEUsUUFBUTVELENBQVIsR0FBWSxDQUFDb3FCLFVBQWpDLEVBQTZDTixPQUE3QyxFQUFzRDtBQUNwRDtBQUNBemlDLFVBQVEsU0FBU0EsTUFBVCxDQUFnQmtGLENBQWhCLEVBQW1CO0FBQ3pCLFFBQUk2L0IsYUFBYW5ZLHFCQUFxQixJQUFyQixDQUFqQjtBQUNBLFFBQUl2RCxXQUFXMGIsV0FBVy9rQyxNQUExQjtBQUNBcXBCLGFBQVNua0IsQ0FBVDtBQUNBLFdBQU82L0IsV0FBVy9iLE9BQWxCO0FBQ0Q7QUFQbUQsQ0FBdEQ7QUFTQXpNLFFBQVFBLFFBQVFrRSxDQUFSLEdBQVlsRSxRQUFRNUQsQ0FBUixJQUFhc0wsV0FBVyxDQUFDOGUsVUFBekIsQ0FBcEIsRUFBMEROLE9BQTFELEVBQW1FO0FBQ2pFO0FBQ0Fwa0MsV0FBUyxTQUFTQSxPQUFULENBQWlCWixDQUFqQixFQUFvQjtBQUMzQixXQUFPK2tDLGVBQWV2ZSxXQUFXLFNBQVM2ZSxPQUFwQixHQUE4QkosUUFBOUIsR0FBeUMsSUFBeEQsRUFBOERqbEMsQ0FBOUQsQ0FBUDtBQUNEO0FBSmdFLENBQW5FO0FBTUE4ZSxRQUFRQSxRQUFRa0UsQ0FBUixHQUFZbEUsUUFBUTVELENBQVIsR0FBWSxFQUFFb3FCLGNBQWMsbUJBQUF6cEMsQ0FBUSxnREFBUixFQUEwQixVQUFVZ2QsSUFBVixFQUFnQjtBQUN4Rm9zQixXQUFTc0MsR0FBVCxDQUFhMXVCLElBQWIsRUFBbUIsT0FBbkIsRUFBNEJsYyxLQUE1QjtBQUNELENBRitDLENBQWhCLENBQWhDLEVBRUtxb0MsT0FGTCxFQUVjO0FBQ1o7QUFDQXVDLE9BQUssU0FBU0EsR0FBVCxDQUFhcHFDLFFBQWIsRUFBdUI7QUFDMUIsUUFBSXVkLElBQUksSUFBUjtBQUNBLFFBQUk0c0IsYUFBYW5ZLHFCQUFxQnpVLENBQXJCLENBQWpCO0FBQ0EsUUFBSTlaLFVBQVUwbUMsV0FBVzFtQyxPQUF6QjtBQUNBLFFBQUkyQixTQUFTK2tDLFdBQVcva0MsTUFBeEI7QUFDQSxRQUFJSixTQUFTMmlDLFFBQVEsWUFBWTtBQUMvQixVQUFJaG9DLFNBQVMsRUFBYjtBQUNBLFVBQUlhLFFBQVEsQ0FBWjtBQUNBLFVBQUk2cEMsWUFBWSxDQUFoQjtBQUNBNXVCLFlBQU16YixRQUFOLEVBQWdCLEtBQWhCLEVBQXVCLFVBQVVvdUIsT0FBVixFQUFtQjtBQUN4QyxZQUFJa2MsU0FBUzlwQyxPQUFiO0FBQ0EsWUFBSStwQyxnQkFBZ0IsS0FBcEI7QUFDQTVxQyxlQUFPd0MsSUFBUCxDQUFZUixTQUFaO0FBQ0Ewb0M7QUFDQTlzQixVQUFFOVosT0FBRixDQUFVMnFCLE9BQVYsRUFBbUJDLElBQW5CLENBQXdCLFVBQVVwdkIsS0FBVixFQUFpQjtBQUN2QyxjQUFJc3JDLGFBQUosRUFBbUI7QUFDbkJBLDBCQUFnQixJQUFoQjtBQUNBNXFDLGlCQUFPMnFDLE1BQVAsSUFBaUJyckMsS0FBakI7QUFDQSxZQUFFb3JDLFNBQUYsSUFBZTVtQyxRQUFROUQsTUFBUixDQUFmO0FBQ0QsU0FMRCxFQUtHeUYsTUFMSDtBQU1ELE9BWEQ7QUFZQSxRQUFFaWxDLFNBQUYsSUFBZTVtQyxRQUFROUQsTUFBUixDQUFmO0FBQ0QsS0FqQlksQ0FBYjtBQWtCQSxRQUFJcUYsT0FBTzJaLENBQVgsRUFBY3ZaLE9BQU9KLE9BQU9zSCxDQUFkO0FBQ2QsV0FBTzY5QixXQUFXL2IsT0FBbEI7QUFDRCxHQTNCVztBQTRCWjtBQUNBb2MsUUFBTSxTQUFTQSxJQUFULENBQWN4cUMsUUFBZCxFQUF3QjtBQUM1QixRQUFJdWQsSUFBSSxJQUFSO0FBQ0EsUUFBSTRzQixhQUFhblkscUJBQXFCelUsQ0FBckIsQ0FBakI7QUFDQSxRQUFJblksU0FBUytrQyxXQUFXL2tDLE1BQXhCO0FBQ0EsUUFBSUosU0FBUzJpQyxRQUFRLFlBQVk7QUFDL0Jsc0IsWUFBTXpiLFFBQU4sRUFBZ0IsS0FBaEIsRUFBdUIsVUFBVW91QixPQUFWLEVBQW1CO0FBQ3hDN1EsVUFBRTlaLE9BQUYsQ0FBVTJxQixPQUFWLEVBQW1CQyxJQUFuQixDQUF3QjhiLFdBQVcxbUMsT0FBbkMsRUFBNEMyQixNQUE1QztBQUNELE9BRkQ7QUFHRCxLQUpZLENBQWI7QUFLQSxRQUFJSixPQUFPMlosQ0FBWCxFQUFjdlosT0FBT0osT0FBT3NILENBQWQ7QUFDZCxXQUFPNjlCLFdBQVcvYixPQUFsQjtBQUNEO0FBeENXLENBRmQsRTs7Ozs7OztBQzVPQTtBQUNBLElBQUl6TSxVQUFVLG1CQUFBampCLENBQVEsMkNBQVIsQ0FBZDs7QUFDQSxJQUFJd2UsWUFBWSxtQkFBQXhlLENBQVEsK0NBQVIsQ0FBaEI7O0FBQ0EsSUFBSXFpQixXQUFXLG1CQUFBcmlCLENBQVEsOENBQVIsQ0FBZjs7QUFDQSxJQUFJK3JDLFNBQVMsQ0FBQyxtQkFBQS9yQyxDQUFRLDJDQUFSLEVBQXFCd3lCLE9BQXJCLElBQWdDLEVBQWpDLEVBQXFDek4sS0FBbEQ7QUFDQSxJQUFJaW5CLFNBQVN6c0IsU0FBU3dGLEtBQXRCLEMsQ0FDQTs7QUFDQTlCLFFBQVFBLFFBQVFrRSxDQUFSLEdBQVlsRSxRQUFRNUQsQ0FBUixHQUFZLENBQUMsbUJBQUFyZixDQUFRLDBDQUFSLEVBQW9CLFlBQVk7QUFDL0QrckMsU0FBTyxZQUFZO0FBQUU7QUFBYSxHQUFsQztBQUNELENBRmdDLENBQWpDLEVBRUksU0FGSixFQUVlO0FBQ2JobkIsU0FBTyxTQUFTQSxLQUFULENBQWV6TSxNQUFmLEVBQXVCMnpCLFlBQXZCLEVBQXFDQyxhQUFyQyxFQUFvRDtBQUN6RCxRQUFJaHNCLElBQUkxQixVQUFVbEcsTUFBVixDQUFSO0FBQ0EsUUFBSTZ6QixJQUFJOXBCLFNBQVM2cEIsYUFBVCxDQUFSO0FBQ0EsV0FBT0gsU0FBU0EsT0FBTzdyQixDQUFQLEVBQVUrckIsWUFBVixFQUF3QkUsQ0FBeEIsQ0FBVCxHQUFzQ0gsT0FBT3BzQixJQUFQLENBQVlNLENBQVosRUFBZStyQixZQUFmLEVBQTZCRSxDQUE3QixDQUE3QztBQUNEO0FBTFksQ0FGZixFOzs7Ozs7O0FDUEE7QUFDQSxJQUFJbHBCLFVBQVUsbUJBQUFqakIsQ0FBUSwyQ0FBUixDQUFkOztBQUNBLElBQUkyVyxTQUFTLG1CQUFBM1csQ0FBUSxrREFBUixDQUFiOztBQUNBLElBQUl3ZSxZQUFZLG1CQUFBeGUsQ0FBUSwrQ0FBUixDQUFoQjs7QUFDQSxJQUFJcWlCLFdBQVcsbUJBQUFyaUIsQ0FBUSw4Q0FBUixDQUFmOztBQUNBLElBQUltYyxXQUFXLG1CQUFBbmMsQ0FBUSw4Q0FBUixDQUFmOztBQUNBLElBQUlvakIsUUFBUSxtQkFBQXBqQixDQUFRLDBDQUFSLENBQVo7O0FBQ0EsSUFBSXlmLE9BQU8sbUJBQUF6ZixDQUFRLHlDQUFSLENBQVg7O0FBQ0EsSUFBSW9zQyxhQUFhLENBQUMsbUJBQUFwc0MsQ0FBUSwyQ0FBUixFQUFxQnd5QixPQUFyQixJQUFnQyxFQUFqQyxFQUFxQ3BULFNBQXRELEMsQ0FFQTtBQUNBOztBQUNBLElBQUlpdEIsaUJBQWlCanBCLE1BQU0sWUFBWTtBQUNyQyxXQUFTL0QsQ0FBVCxHQUFhO0FBQUU7QUFBYTs7QUFDNUIsU0FBTyxFQUFFK3NCLFdBQVcsWUFBWTtBQUFFO0FBQWEsR0FBdEMsRUFBd0MsRUFBeEMsRUFBNEMvc0IsQ0FBNUMsYUFBMERBLENBQTVELENBQVA7QUFDRCxDQUhvQixDQUFyQjtBQUlBLElBQUlpdEIsV0FBVyxDQUFDbHBCLE1BQU0sWUFBWTtBQUNoQ2dwQixhQUFXLFlBQVk7QUFBRTtBQUFhLEdBQXRDO0FBQ0QsQ0FGZSxDQUFoQjtBQUlBbnBCLFFBQVFBLFFBQVFrRSxDQUFSLEdBQVlsRSxRQUFRNUQsQ0FBUixJQUFhZ3RCLGtCQUFrQkMsUUFBL0IsQ0FBcEIsRUFBOEQsU0FBOUQsRUFBeUU7QUFDdkVsdEIsYUFBVyxTQUFTQSxTQUFULENBQW1CbXRCLE1BQW5CLEVBQTJCanRCO0FBQUs7QUFBaEMsSUFBbUQ7QUFDNURkLGNBQVUrdEIsTUFBVjtBQUNBbHFCLGFBQVMvQyxJQUFUO0FBQ0EsUUFBSWt0QixZQUFZN3ZCLFVBQVUvWSxNQUFWLEdBQW1CLENBQW5CLEdBQXVCMm9DLE1BQXZCLEdBQWdDL3RCLFVBQVU3QixVQUFVLENBQVYsQ0FBVixDQUFoRDtBQUNBLFFBQUkydkIsWUFBWSxDQUFDRCxjQUFqQixFQUFpQyxPQUFPRCxXQUFXRyxNQUFYLEVBQW1CanRCLElBQW5CLEVBQXlCa3RCLFNBQXpCLENBQVA7O0FBQ2pDLFFBQUlELFVBQVVDLFNBQWQsRUFBeUI7QUFDdkI7QUFDQSxjQUFRbHRCLEtBQUsxYixNQUFiO0FBQ0UsYUFBSyxDQUFMO0FBQVEsaUJBQU8sSUFBSTJvQyxNQUFKLEVBQVA7O0FBQ1IsYUFBSyxDQUFMO0FBQVEsaUJBQU8sSUFBSUEsTUFBSixDQUFXanRCLEtBQUssQ0FBTCxDQUFYLENBQVA7O0FBQ1IsYUFBSyxDQUFMO0FBQVEsaUJBQU8sSUFBSWl0QixNQUFKLENBQVdqdEIsS0FBSyxDQUFMLENBQVgsRUFBb0JBLEtBQUssQ0FBTCxDQUFwQixDQUFQOztBQUNSLGFBQUssQ0FBTDtBQUFRLGlCQUFPLElBQUlpdEIsTUFBSixDQUFXanRCLEtBQUssQ0FBTCxDQUFYLEVBQW9CQSxLQUFLLENBQUwsQ0FBcEIsRUFBNkJBLEtBQUssQ0FBTCxDQUE3QixDQUFQOztBQUNSLGFBQUssQ0FBTDtBQUFRLGlCQUFPLElBQUlpdEIsTUFBSixDQUFXanRCLEtBQUssQ0FBTCxDQUFYLEVBQW9CQSxLQUFLLENBQUwsQ0FBcEIsRUFBNkJBLEtBQUssQ0FBTCxDQUE3QixFQUFzQ0EsS0FBSyxDQUFMLENBQXRDLENBQVA7QUFMVixPQUZ1QixDQVN2Qjs7O0FBQ0EsVUFBSW10QixRQUFRLENBQUMsSUFBRCxDQUFaO0FBQ0FBLFlBQU1ocEMsSUFBTixDQUFXc2hCLEtBQVgsQ0FBaUIwbkIsS0FBakIsRUFBd0JudEIsSUFBeEI7QUFDQSxhQUFPLEtBQUtHLEtBQUtzRixLQUFMLENBQVd3bkIsTUFBWCxFQUFtQkUsS0FBbkIsQ0FBTCxHQUFQO0FBQ0QsS0FsQjJELENBbUI1RDs7O0FBQ0EsUUFBSTdvQixRQUFRNG9CLFVBQVV4d0IsU0FBdEI7QUFDQSxRQUFJaUksV0FBV3ROLE9BQU93RixTQUFTeUgsS0FBVCxJQUFrQkEsS0FBbEIsR0FBMEJ4akIsT0FBTzRiLFNBQXhDLENBQWY7QUFDQSxRQUFJMVYsU0FBU2laLFNBQVN3RixLQUFULENBQWVuRixJQUFmLENBQW9CMnNCLE1BQXBCLEVBQTRCdG9CLFFBQTVCLEVBQXNDM0UsSUFBdEMsQ0FBYjtBQUNBLFdBQU9uRCxTQUFTN1YsTUFBVCxJQUFtQkEsTUFBbkIsR0FBNEIyZCxRQUFuQztBQUNEO0FBekJzRSxDQUF6RSxFOzs7Ozs7O0FDcEJBO0FBQ0EsSUFBSTNELEtBQUssbUJBQUF0Z0IsQ0FBUSw4Q0FBUixDQUFUOztBQUNBLElBQUlpakIsVUFBVSxtQkFBQWpqQixDQUFRLDJDQUFSLENBQWQ7O0FBQ0EsSUFBSXFpQixXQUFXLG1CQUFBcmlCLENBQVEsOENBQVIsQ0FBZjs7QUFDQSxJQUFJbW1CLGNBQWMsbUJBQUFubUIsQ0FBUSxpREFBUixDQUFsQixDLENBRUE7OztBQUNBaWpCLFFBQVFBLFFBQVFrRSxDQUFSLEdBQVlsRSxRQUFRNUQsQ0FBUixHQUFZLG1CQUFBcmYsQ0FBUSwwQ0FBUixFQUFvQixZQUFZO0FBQzlEO0FBQ0F3eUIsVUFBUW55QixjQUFSLENBQXVCaWdCLEdBQUdqQyxDQUFILENBQUssRUFBTCxFQUFTLENBQVQsRUFBWTtBQUFFOWQsV0FBTztBQUFULEdBQVosQ0FBdkIsRUFBa0QsQ0FBbEQsRUFBcUQ7QUFBRUEsV0FBTztBQUFULEdBQXJEO0FBQ0QsQ0FIK0IsQ0FBaEMsRUFHSSxTQUhKLEVBR2U7QUFDYkYsa0JBQWdCLFNBQVNBLGNBQVQsQ0FBd0JpWSxNQUF4QixFQUFnQ28wQixXQUFoQyxFQUE2Q0MsVUFBN0MsRUFBeUQ7QUFDdkV0cUIsYUFBUy9KLE1BQVQ7QUFDQW8wQixrQkFBY3ZtQixZQUFZdW1CLFdBQVosRUFBeUIsSUFBekIsQ0FBZDtBQUNBcnFCLGFBQVNzcUIsVUFBVDs7QUFDQSxRQUFJO0FBQ0Zyc0IsU0FBR2pDLENBQUgsQ0FBSy9GLE1BQUwsRUFBYW8wQixXQUFiLEVBQTBCQyxVQUExQjtBQUNBLGFBQU8sSUFBUDtBQUNELEtBSEQsQ0FHRSxPQUFPMXNCLENBQVAsRUFBVTtBQUNWLGFBQU8sS0FBUDtBQUNEO0FBQ0Y7QUFYWSxDQUhmLEU7Ozs7Ozs7QUNQQTtBQUNBLElBQUlnRCxVQUFVLG1CQUFBampCLENBQVEsMkNBQVIsQ0FBZDs7QUFDQSxJQUFJMnhCLE9BQU8sbUJBQUEzeEIsQ0FBUSxnREFBUixFQUEwQnFlLENBQXJDOztBQUNBLElBQUlnRSxXQUFXLG1CQUFBcmlCLENBQVEsOENBQVIsQ0FBZjs7QUFFQWlqQixRQUFRQSxRQUFRa0UsQ0FBaEIsRUFBbUIsU0FBbkIsRUFBOEI7QUFDNUJ5bEIsa0JBQWdCLFNBQVNBLGNBQVQsQ0FBd0J0MEIsTUFBeEIsRUFBZ0NvMEIsV0FBaEMsRUFBNkM7QUFDM0QsUUFBSS9PLE9BQU9oTSxLQUFLdFAsU0FBUy9KLE1BQVQsQ0FBTCxFQUF1Qm8wQixXQUF2QixDQUFYO0FBQ0EsV0FBTy9PLFFBQVEsQ0FBQ0EsS0FBS2pLLFlBQWQsR0FBNkIsS0FBN0IsR0FBcUMsT0FBT3BiLE9BQU9vMEIsV0FBUCxDQUFuRDtBQUNEO0FBSjJCLENBQTlCLEU7Ozs7Ozs7O0NDSkE7O0FBQ0EsSUFBSXpwQixVQUFVLG1CQUFBampCLENBQVEsMkNBQVIsQ0FBZDs7QUFDQSxJQUFJcWlCLFdBQVcsbUJBQUFyaUIsQ0FBUSw4Q0FBUixDQUFmOztBQUNBLElBQUk2c0MsWUFBWSxTQUFaQSxTQUFZLENBQVU3cUIsUUFBVixFQUFvQjtBQUNsQyxPQUFLUCxFQUFMLEdBQVVZLFNBQVNMLFFBQVQsQ0FBVixDQURrQyxDQUNKOztBQUM5QixPQUFLZCxFQUFMLEdBQVUsQ0FBVixDQUZrQyxDQUVKOztBQUM5QixNQUFJbGdCLE9BQU8sS0FBS2toQixFQUFMLEdBQVUsRUFBckIsQ0FIa0MsQ0FHSjs7QUFDOUIsTUFBSTFnQixHQUFKOztBQUNBLE9BQUtBLEdBQUwsSUFBWXdnQixRQUFaO0FBQXNCaGhCLFNBQUt5QyxJQUFMLENBQVVqQyxHQUFWO0FBQXRCO0FBQ0QsQ0FORDs7QUFPQSxtQkFBQXhCLENBQVEsZ0RBQVIsRUFBMEI2c0MsU0FBMUIsRUFBcUMsUUFBckMsRUFBK0MsWUFBWTtBQUN6RCxNQUFJMXVCLE9BQU8sSUFBWDtBQUNBLE1BQUluZCxPQUFPbWQsS0FBSytELEVBQWhCO0FBQ0EsTUFBSTFnQixHQUFKOztBQUNBLEtBQUc7QUFDRCxRQUFJMmMsS0FBSytDLEVBQUwsSUFBV2xnQixLQUFLNEMsTUFBcEIsRUFBNEIsT0FBTztBQUFFckQsYUFBTzBDLFNBQVQ7QUFBb0I0bUIsWUFBTTtBQUExQixLQUFQO0FBQzdCLEdBRkQsUUFFUyxFQUFFLENBQUNyb0IsTUFBTVIsS0FBS21kLEtBQUsrQyxFQUFMLEVBQUwsQ0FBUCxLQUEyQi9DLEtBQUtzRCxFQUFsQyxDQUZUOztBQUdBLFNBQU87QUFBRWxoQixXQUFPaUIsR0FBVDtBQUFjcW9CLFVBQU07QUFBcEIsR0FBUDtBQUNELENBUkQ7O0FBVUE1RyxRQUFRQSxRQUFRa0UsQ0FBaEIsRUFBbUIsU0FBbkIsRUFBOEI7QUFDNUIybEIsYUFBVyxTQUFTQSxTQUFULENBQW1CeDBCLE1BQW5CLEVBQTJCO0FBQ3BDLFdBQU8sSUFBSXUwQixTQUFKLENBQWN2MEIsTUFBZCxDQUFQO0FBQ0Q7QUFIMkIsQ0FBOUIsRTs7Ozs7OztBQ3JCQTtBQUNBLElBQUlxWixPQUFPLG1CQUFBM3hCLENBQVEsZ0RBQVIsQ0FBWDs7QUFDQSxJQUFJaWpCLFVBQVUsbUJBQUFqakIsQ0FBUSwyQ0FBUixDQUFkOztBQUNBLElBQUlxaUIsV0FBVyxtQkFBQXJpQixDQUFRLDhDQUFSLENBQWY7O0FBRUFpakIsUUFBUUEsUUFBUWtFLENBQWhCLEVBQW1CLFNBQW5CLEVBQThCO0FBQzVCeUssNEJBQTBCLFNBQVNBLHdCQUFULENBQWtDdFosTUFBbEMsRUFBMENvMEIsV0FBMUMsRUFBdUQ7QUFDL0UsV0FBTy9hLEtBQUt0VCxDQUFMLENBQU9nRSxTQUFTL0osTUFBVCxDQUFQLEVBQXlCbzBCLFdBQXpCLENBQVA7QUFDRDtBQUgyQixDQUE5QixFOzs7Ozs7O0FDTEE7QUFDQSxJQUFJenBCLFVBQVUsbUJBQUFqakIsQ0FBUSwyQ0FBUixDQUFkOztBQUNBLElBQUkrc0MsV0FBVyxtQkFBQS9zQyxDQUFRLCtDQUFSLENBQWY7O0FBQ0EsSUFBSXFpQixXQUFXLG1CQUFBcmlCLENBQVEsOENBQVIsQ0FBZjs7QUFFQWlqQixRQUFRQSxRQUFRa0UsQ0FBaEIsRUFBbUIsU0FBbkIsRUFBOEI7QUFDNUIwRCxrQkFBZ0IsU0FBU0EsY0FBVCxDQUF3QnZTLE1BQXhCLEVBQWdDO0FBQzlDLFdBQU95MEIsU0FBUzFxQixTQUFTL0osTUFBVCxDQUFULENBQVA7QUFDRDtBQUgyQixDQUE5QixFOzs7Ozs7O0FDTEE7QUFDQSxJQUFJcVosT0FBTyxtQkFBQTN4QixDQUFRLGdEQUFSLENBQVg7O0FBQ0EsSUFBSTZxQixpQkFBaUIsbUJBQUE3cUIsQ0FBUSwrQ0FBUixDQUFyQjs7QUFDQSxJQUFJaUUsTUFBTSxtQkFBQWpFLENBQVEsd0NBQVIsQ0FBVjs7QUFDQSxJQUFJaWpCLFVBQVUsbUJBQUFqakIsQ0FBUSwyQ0FBUixDQUFkOztBQUNBLElBQUltYyxXQUFXLG1CQUFBbmMsQ0FBUSw4Q0FBUixDQUFmOztBQUNBLElBQUlxaUIsV0FBVyxtQkFBQXJpQixDQUFRLDhDQUFSLENBQWY7O0FBRUEsU0FBUzZoQixHQUFULENBQWF2SixNQUFiLEVBQXFCbzBCO0FBQVk7QUFBakMsRUFBbUQ7QUFDakQsTUFBSU0sV0FBV3J3QixVQUFVL1ksTUFBVixHQUFtQixDQUFuQixHQUF1QjBVLE1BQXZCLEdBQWdDcUUsVUFBVSxDQUFWLENBQS9DO0FBQ0EsTUFBSWdoQixJQUFKLEVBQVUvWixLQUFWO0FBQ0EsTUFBSXZCLFNBQVMvSixNQUFULE1BQXFCMDBCLFFBQXpCLEVBQW1DLE9BQU8xMEIsT0FBT28wQixXQUFQLENBQVA7QUFDbkMsTUFBSS9PLE9BQU9oTSxLQUFLdFQsQ0FBTCxDQUFPL0YsTUFBUCxFQUFlbzBCLFdBQWYsQ0FBWCxFQUF3QyxPQUFPem9DLElBQUkwNUIsSUFBSixFQUFVLE9BQVYsSUFDM0NBLEtBQUtwOUIsS0FEc0MsR0FFM0NvOUIsS0FBSzliLEdBQUwsS0FBYTVlLFNBQWIsR0FDRTA2QixLQUFLOWIsR0FBTCxDQUFTakMsSUFBVCxDQUFjb3RCLFFBQWQsQ0FERixHQUVFL3BDLFNBSmtDO0FBS3hDLE1BQUlrWixTQUFTeUgsUUFBUWlILGVBQWV2UyxNQUFmLENBQWpCLENBQUosRUFBOEMsT0FBT3VKLElBQUkrQixLQUFKLEVBQVc4b0IsV0FBWCxFQUF3Qk0sUUFBeEIsQ0FBUDtBQUMvQzs7QUFFRC9wQixRQUFRQSxRQUFRa0UsQ0FBaEIsRUFBbUIsU0FBbkIsRUFBOEI7QUFBRXRGLE9BQUtBO0FBQVAsQ0FBOUIsRTs7Ozs7OztBQ3BCQTtBQUNBLElBQUlvQixVQUFVLG1CQUFBampCLENBQVEsMkNBQVIsQ0FBZDs7QUFFQWlqQixRQUFRQSxRQUFRa0UsQ0FBaEIsRUFBbUIsU0FBbkIsRUFBOEI7QUFDNUJsakIsT0FBSyxTQUFTQSxHQUFULENBQWFxVSxNQUFiLEVBQXFCbzBCLFdBQXJCLEVBQWtDO0FBQ3JDLFdBQU9BLGVBQWVwMEIsTUFBdEI7QUFDRDtBQUgyQixDQUE5QixFOzs7Ozs7O0FDSEE7QUFDQSxJQUFJMkssVUFBVSxtQkFBQWpqQixDQUFRLDJDQUFSLENBQWQ7O0FBQ0EsSUFBSXFpQixXQUFXLG1CQUFBcmlCLENBQVEsOENBQVIsQ0FBZjs7QUFDQSxJQUFJdW9DLGdCQUFnQm5vQyxPQUFPa3RCLFlBQTNCO0FBRUFySyxRQUFRQSxRQUFRa0UsQ0FBaEIsRUFBbUIsU0FBbkIsRUFBOEI7QUFDNUJtRyxnQkFBYyxTQUFTQSxZQUFULENBQXNCaFYsTUFBdEIsRUFBOEI7QUFDMUMrSixhQUFTL0osTUFBVDtBQUNBLFdBQU9pd0IsZ0JBQWdCQSxjQUFjandCLE1BQWQsQ0FBaEIsR0FBd0MsSUFBL0M7QUFDRDtBQUoyQixDQUE5QixFOzs7Ozs7O0FDTEE7QUFDQSxJQUFJMkssVUFBVSxtQkFBQWpqQixDQUFRLDJDQUFSLENBQWQ7O0FBRUFpakIsUUFBUUEsUUFBUWtFLENBQWhCLEVBQW1CLFNBQW5CLEVBQThCO0FBQUVzTCxXQUFTLG1CQUFBenlCLENBQVEsNkNBQVI7QUFBWCxDQUE5QixFOzs7Ozs7O0FDSEE7QUFDQSxJQUFJaWpCLFVBQVUsbUJBQUFqakIsQ0FBUSwyQ0FBUixDQUFkOztBQUNBLElBQUlxaUIsV0FBVyxtQkFBQXJpQixDQUFRLDhDQUFSLENBQWY7O0FBQ0EsSUFBSTRvQyxxQkFBcUJ4b0MsT0FBT290QixpQkFBaEM7QUFFQXZLLFFBQVFBLFFBQVFrRSxDQUFoQixFQUFtQixTQUFuQixFQUE4QjtBQUM1QnFHLHFCQUFtQixTQUFTQSxpQkFBVCxDQUEyQmxWLE1BQTNCLEVBQW1DO0FBQ3BEK0osYUFBUy9KLE1BQVQ7O0FBQ0EsUUFBSTtBQUNGLFVBQUlzd0Isa0JBQUosRUFBd0JBLG1CQUFtQnR3QixNQUFuQjtBQUN4QixhQUFPLElBQVA7QUFDRCxLQUhELENBR0UsT0FBTzJILENBQVAsRUFBVTtBQUNWLGFBQU8sS0FBUDtBQUNEO0FBQ0Y7QUFUMkIsQ0FBOUIsRTs7Ozs7OztBQ0xBO0FBQ0EsSUFBSWdELFVBQVUsbUJBQUFqakIsQ0FBUSwyQ0FBUixDQUFkOztBQUNBLElBQUlpdEMsV0FBVyxtQkFBQWp0QyxDQUFRLDhDQUFSLENBQWY7O0FBRUEsSUFBSWl0QyxRQUFKLEVBQWNocUIsUUFBUUEsUUFBUWtFLENBQWhCLEVBQW1CLFNBQW5CLEVBQThCO0FBQzFDOEMsa0JBQWdCLFNBQVNBLGNBQVQsQ0FBd0IzUixNQUF4QixFQUFnQ3NMLEtBQWhDLEVBQXVDO0FBQ3JEcXBCLGFBQVMxWSxLQUFULENBQWVqYyxNQUFmLEVBQXVCc0wsS0FBdkI7O0FBQ0EsUUFBSTtBQUNGcXBCLGVBQVNucUIsR0FBVCxDQUFheEssTUFBYixFQUFxQnNMLEtBQXJCO0FBQ0EsYUFBTyxJQUFQO0FBQ0QsS0FIRCxDQUdFLE9BQU8zRCxDQUFQLEVBQVU7QUFDVixhQUFPLEtBQVA7QUFDRDtBQUNGO0FBVHlDLENBQTlCLEU7Ozs7Ozs7QUNKZDtBQUNBLElBQUlLLEtBQUssbUJBQUF0Z0IsQ0FBUSw4Q0FBUixDQUFUOztBQUNBLElBQUkyeEIsT0FBTyxtQkFBQTN4QixDQUFRLGdEQUFSLENBQVg7O0FBQ0EsSUFBSTZxQixpQkFBaUIsbUJBQUE3cUIsQ0FBUSwrQ0FBUixDQUFyQjs7QUFDQSxJQUFJaUUsTUFBTSxtQkFBQWpFLENBQVEsd0NBQVIsQ0FBVjs7QUFDQSxJQUFJaWpCLFVBQVUsbUJBQUFqakIsQ0FBUSwyQ0FBUixDQUFkOztBQUNBLElBQUk2a0IsYUFBYSxtQkFBQTdrQixDQUFRLGtEQUFSLENBQWpCOztBQUNBLElBQUlxaUIsV0FBVyxtQkFBQXJpQixDQUFRLDhDQUFSLENBQWY7O0FBQ0EsSUFBSW1jLFdBQVcsbUJBQUFuYyxDQUFRLDhDQUFSLENBQWY7O0FBRUEsU0FBUzhpQixHQUFULENBQWF4SyxNQUFiLEVBQXFCbzBCLFdBQXJCLEVBQWtDUTtBQUFFO0FBQXBDLEVBQXNEO0FBQ3BELE1BQUlGLFdBQVdyd0IsVUFBVS9ZLE1BQVYsR0FBbUIsQ0FBbkIsR0FBdUIwVSxNQUF2QixHQUFnQ3FFLFVBQVUsQ0FBVixDQUEvQztBQUNBLE1BQUl3d0IsVUFBVXhiLEtBQUt0VCxDQUFMLENBQU9nRSxTQUFTL0osTUFBVCxDQUFQLEVBQXlCbzBCLFdBQXpCLENBQWQ7QUFDQSxNQUFJVSxrQkFBSixFQUF3QnhwQixLQUF4Qjs7QUFDQSxNQUFJLENBQUN1cEIsT0FBTCxFQUFjO0FBQ1osUUFBSWh4QixTQUFTeUgsUUFBUWlILGVBQWV2UyxNQUFmLENBQWpCLENBQUosRUFBOEM7QUFDNUMsYUFBT3dLLElBQUljLEtBQUosRUFBVzhvQixXQUFYLEVBQXdCUSxDQUF4QixFQUEyQkYsUUFBM0IsQ0FBUDtBQUNEOztBQUNERyxjQUFVdG9CLFdBQVcsQ0FBWCxDQUFWO0FBQ0Q7O0FBQ0QsTUFBSTVnQixJQUFJa3BDLE9BQUosRUFBYSxPQUFiLENBQUosRUFBMkI7QUFDekIsUUFBSUEsUUFBUXhaLFFBQVIsS0FBcUIsS0FBckIsSUFBOEIsQ0FBQ3hYLFNBQVM2d0IsUUFBVCxDQUFuQyxFQUF1RCxPQUFPLEtBQVA7QUFDdkRJLHlCQUFxQnpiLEtBQUt0VCxDQUFMLENBQU8ydUIsUUFBUCxFQUFpQk4sV0FBakIsS0FBaUM3bkIsV0FBVyxDQUFYLENBQXREO0FBQ0F1b0IsdUJBQW1CN3NDLEtBQW5CLEdBQTJCMnNDLENBQTNCO0FBQ0E1c0IsT0FBR2pDLENBQUgsQ0FBSzJ1QixRQUFMLEVBQWVOLFdBQWYsRUFBNEJVLGtCQUE1QjtBQUNBLFdBQU8sSUFBUDtBQUNEOztBQUNELFNBQU9ELFFBQVFycUIsR0FBUixLQUFnQjdmLFNBQWhCLEdBQTRCLEtBQTVCLElBQXFDa3FDLFFBQVFycUIsR0FBUixDQUFZbEQsSUFBWixDQUFpQm90QixRQUFqQixFQUEyQkUsQ0FBM0IsR0FBK0IsSUFBcEUsQ0FBUDtBQUNEOztBQUVEanFCLFFBQVFBLFFBQVFrRSxDQUFoQixFQUFtQixTQUFuQixFQUE4QjtBQUFFckUsT0FBS0E7QUFBUCxDQUE5QixFOzs7Ozs7O0FDOUJBLElBQUk3aUIsU0FBUyxtQkFBQUQsQ0FBUSwyQ0FBUixDQUFiOztBQUNBLElBQUl1akIsb0JBQW9CLG1CQUFBdmpCLENBQVEsd0RBQVIsQ0FBeEI7O0FBQ0EsSUFBSXNnQixLQUFLLG1CQUFBdGdCLENBQVEsOENBQVIsRUFBd0JxZSxDQUFqQzs7QUFDQSxJQUFJd1QsT0FBTyxtQkFBQTd4QixDQUFRLGdEQUFSLEVBQTBCcWUsQ0FBckM7O0FBQ0EsSUFBSWtNLFdBQVcsbUJBQUF2cUIsQ0FBUSw4Q0FBUixDQUFmOztBQUNBLElBQUlxdEMsU0FBUyxtQkFBQXJ0QyxDQUFRLDBDQUFSLENBQWI7O0FBQ0EsSUFBSXN0QyxVQUFVcnRDLE9BQU9zb0IsTUFBckI7QUFDQSxJQUFJNUUsT0FBTzJwQixPQUFYO0FBQ0EsSUFBSTFwQixRQUFRMHBCLFFBQVF0eEIsU0FBcEI7QUFDQSxJQUFJdXhCLE1BQU0sSUFBVjtBQUNBLElBQUlDLE1BQU0sSUFBVixDLENBQ0E7O0FBQ0EsSUFBSUMsY0FBYyxJQUFJSCxPQUFKLENBQVlDLEdBQVosTUFBcUJBLEdBQXZDOztBQUVBLElBQUksbUJBQUF2dEMsQ0FBUSxnREFBUixNQUE4QixDQUFDeXRDLFdBQUQsSUFBZ0IsbUJBQUF6dEMsQ0FBUSwwQ0FBUixFQUFvQixZQUFZO0FBQ2hGd3RDLE1BQUksbUJBQUF4dEMsQ0FBUSx3Q0FBUixFQUFrQixPQUFsQixDQUFKLElBQWtDLEtBQWxDLENBRGdGLENBRWhGOztBQUNBLFNBQU9zdEMsUUFBUUMsR0FBUixLQUFnQkEsR0FBaEIsSUFBdUJELFFBQVFFLEdBQVIsS0FBZ0JBLEdBQXZDLElBQThDRixRQUFRQyxHQUFSLEVBQWEsR0FBYixLQUFxQixNQUExRTtBQUNELENBSmlELENBQTlDLENBQUosRUFJSztBQUNIRCxZQUFVLFNBQVMva0IsTUFBVCxDQUFnQjNHLENBQWhCLEVBQW1CdkQsQ0FBbkIsRUFBc0I7QUFDOUIsUUFBSXF2QixPQUFPLGdCQUFnQkosT0FBM0I7QUFDQSxRQUFJSyxPQUFPcGpCLFNBQVMzSSxDQUFULENBQVg7QUFDQSxRQUFJZ3NCLE1BQU12dkIsTUFBTXBiLFNBQWhCO0FBQ0EsV0FBTyxDQUFDeXFDLElBQUQsSUFBU0MsSUFBVCxJQUFpQi9yQixFQUFFOUMsV0FBRixLQUFrQnd1QixPQUFuQyxJQUE4Q00sR0FBOUMsR0FBb0Roc0IsQ0FBcEQsR0FDSDJCLGtCQUFrQmtxQixjQUNoQixJQUFJOXBCLElBQUosQ0FBU2dxQixRQUFRLENBQUNDLEdBQVQsR0FBZWhzQixFQUFFbUYsTUFBakIsR0FBMEJuRixDQUFuQyxFQUFzQ3ZELENBQXRDLENBRGdCLEdBRWhCc0YsS0FBSyxDQUFDZ3FCLE9BQU8vckIsYUFBYTByQixPQUFyQixJQUFnQzFyQixFQUFFbUYsTUFBbEMsR0FBMkNuRixDQUFoRCxFQUFtRCtyQixRQUFRQyxHQUFSLEdBQWNQLE9BQU96dEIsSUFBUCxDQUFZZ0MsQ0FBWixDQUFkLEdBQStCdkQsQ0FBbEYsQ0FGRixFQUdBcXZCLE9BQU8sSUFBUCxHQUFjOXBCLEtBSGQsRUFHcUIwcEIsT0FIckIsQ0FESjtBQUtELEdBVEQ7O0FBVUEsTUFBSU8sUUFBUSxTQUFSQSxLQUFRLENBQVVyc0MsR0FBVixFQUFlO0FBQ3pCQSxXQUFPOHJDLE9BQVAsSUFBa0JodEIsR0FBR2d0QixPQUFILEVBQVk5ckMsR0FBWixFQUFpQjtBQUNqQ2t5QixvQkFBYyxJQURtQjtBQUVqQzdSLFdBQUssZUFBWTtBQUFFLGVBQU84QixLQUFLbmlCLEdBQUwsQ0FBUDtBQUFtQixPQUZMO0FBR2pDc2hCLFdBQUssYUFBVWpoQixFQUFWLEVBQWM7QUFBRThoQixhQUFLbmlCLEdBQUwsSUFBWUssRUFBWjtBQUFpQjtBQUhMLEtBQWpCLENBQWxCO0FBS0QsR0FORDs7QUFPQSxPQUFLLElBQUliLE9BQU82d0IsS0FBS2xPLElBQUwsQ0FBWCxFQUF1QnZpQixJQUFJLENBQWhDLEVBQW1DSixLQUFLNEMsTUFBTCxHQUFjeEMsQ0FBakQ7QUFBcUR5c0MsVUFBTTdzQyxLQUFLSSxHQUFMLENBQU47QUFBckQ7O0FBQ0F3aUIsUUFBTTlFLFdBQU4sR0FBb0J3dUIsT0FBcEI7QUFDQUEsVUFBUXR4QixTQUFSLEdBQW9CNEgsS0FBcEI7O0FBQ0E1akIsRUFBQSxtQkFBQUEsQ0FBUSw2Q0FBUixFQUF1QkMsTUFBdkIsRUFBK0IsUUFBL0IsRUFBeUNxdEMsT0FBekM7QUFDRDs7QUFFRCxtQkFBQXR0QyxDQUFRLGdEQUFSLEVBQTBCLFFBQTFCLEU7Ozs7Ozs7QUMxQ0E7QUFDQSxJQUFJLG1CQUFBQSxDQUFRLGdEQUFSLEtBQTZCLEtBQUs4dEMsS0FBTCxJQUFjLEdBQS9DLEVBQW9ELG1CQUFBOXRDLENBQVEsOENBQVIsRUFBd0JxZSxDQUF4QixDQUEwQmtLLE9BQU92TSxTQUFqQyxFQUE0QyxPQUE1QyxFQUFxRDtBQUN2RzBYLGdCQUFjLElBRHlGO0FBRXZHN1IsT0FBSyxtQkFBQTdoQixDQUFRLDBDQUFSO0FBRmtHLENBQXJELEU7Ozs7Ozs7QUNEcEQ7QUFDQSxtQkFBQUEsQ0FBUSwrQ0FBUixFQUF5QixPQUF6QixFQUFrQyxDQUFsQyxFQUFxQyxVQUFVZ29CLE9BQVYsRUFBbUJILEtBQW5CLEVBQTBCa21CLE1BQTFCLEVBQWtDO0FBQ3JFO0FBQ0EsU0FBTyxDQUFDLFNBQVMxSixLQUFULENBQWUySixNQUFmLEVBQXVCO0FBQzdCOztBQUNBLFFBQUl4eEIsSUFBSXdMLFFBQVEsSUFBUixDQUFSO0FBQ0EsUUFBSXRJLEtBQUtzdUIsVUFBVS9xQyxTQUFWLEdBQXNCQSxTQUF0QixHQUFrQytxQyxPQUFPbm1CLEtBQVAsQ0FBM0M7QUFDQSxXQUFPbkksT0FBT3pjLFNBQVAsR0FBbUJ5YyxHQUFHRSxJQUFILENBQVFvdUIsTUFBUixFQUFnQnh4QixDQUFoQixDQUFuQixHQUF3QyxJQUFJK0wsTUFBSixDQUFXeWxCLE1BQVgsRUFBbUJubUIsS0FBbkIsRUFBMEJTLE9BQU85TCxDQUFQLENBQTFCLENBQS9DO0FBQ0QsR0FMTSxFQUtKdXhCLE1BTEksQ0FBUDtBQU1ELENBUkQsRTs7Ozs7OztBQ0RBO0FBQ0EsbUJBQUEvdEMsQ0FBUSwrQ0FBUixFQUF5QixTQUF6QixFQUFvQyxDQUFwQyxFQUF1QyxVQUFVZ29CLE9BQVYsRUFBbUJpbUIsT0FBbkIsRUFBNEJDLFFBQTVCLEVBQXNDO0FBQzNFO0FBQ0EsU0FBTyxDQUFDLFNBQVMzWSxPQUFULENBQWlCNFksV0FBakIsRUFBOEJDLFlBQTlCLEVBQTRDO0FBQ2xEOztBQUNBLFFBQUk1eEIsSUFBSXdMLFFBQVEsSUFBUixDQUFSO0FBQ0EsUUFBSXRJLEtBQUt5dUIsZUFBZWxyQyxTQUFmLEdBQTJCQSxTQUEzQixHQUF1Q2tyQyxZQUFZRixPQUFaLENBQWhEO0FBQ0EsV0FBT3Z1QixPQUFPemMsU0FBUCxHQUNIeWMsR0FBR0UsSUFBSCxDQUFRdXVCLFdBQVIsRUFBcUIzeEIsQ0FBckIsRUFBd0I0eEIsWUFBeEIsQ0FERyxHQUVIRixTQUFTdHVCLElBQVQsQ0FBYzBJLE9BQU85TCxDQUFQLENBQWQsRUFBeUIyeEIsV0FBekIsRUFBc0NDLFlBQXRDLENBRko7QUFHRCxHQVBNLEVBT0pGLFFBUEksQ0FBUDtBQVFELENBVkQsRTs7Ozs7OztBQ0RBO0FBQ0EsbUJBQUFsdUMsQ0FBUSwrQ0FBUixFQUF5QixRQUF6QixFQUFtQyxDQUFuQyxFQUFzQyxVQUFVZ29CLE9BQVYsRUFBbUJxbUIsTUFBbkIsRUFBMkJDLE9BQTNCLEVBQW9DO0FBQ3hFO0FBQ0EsU0FBTyxDQUFDLFNBQVNDLE1BQVQsQ0FBZ0JQLE1BQWhCLEVBQXdCO0FBQzlCOztBQUNBLFFBQUl4eEIsSUFBSXdMLFFBQVEsSUFBUixDQUFSO0FBQ0EsUUFBSXRJLEtBQUtzdUIsVUFBVS9xQyxTQUFWLEdBQXNCQSxTQUF0QixHQUFrQytxQyxPQUFPSyxNQUFQLENBQTNDO0FBQ0EsV0FBTzN1QixPQUFPemMsU0FBUCxHQUFtQnljLEdBQUdFLElBQUgsQ0FBUW91QixNQUFSLEVBQWdCeHhCLENBQWhCLENBQW5CLEdBQXdDLElBQUkrTCxNQUFKLENBQVd5bEIsTUFBWCxFQUFtQkssTUFBbkIsRUFBMkIvbEIsT0FBTzlMLENBQVAsQ0FBM0IsQ0FBL0M7QUFDRCxHQUxNLEVBS0o4eEIsT0FMSSxDQUFQO0FBTUQsQ0FSRCxFOzs7Ozs7O0FDREE7QUFDQSxtQkFBQXR1QyxDQUFRLCtDQUFSLEVBQXlCLE9BQXpCLEVBQWtDLENBQWxDLEVBQXFDLFVBQVVnb0IsT0FBVixFQUFtQndtQixLQUFuQixFQUEwQkMsTUFBMUIsRUFBa0M7QUFDckU7O0FBQ0EsTUFBSWxrQixXQUFXLG1CQUFBdnFCLENBQVEsOENBQVIsQ0FBZjs7QUFDQSxNQUFJMHVDLFNBQVNELE1BQWI7QUFDQSxNQUFJRSxRQUFRLEdBQUdsckMsSUFBZjtBQUNBLE1BQUltckMsU0FBUyxPQUFiO0FBQ0EsTUFBSUMsU0FBUyxRQUFiO0FBQ0EsTUFBSUMsYUFBYSxXQUFqQjs7QUFDQSxNQUNFLE9BQU9GLE1BQVAsRUFBZSxNQUFmLEVBQXVCLENBQXZCLEtBQTZCLEdBQTdCLElBQ0EsT0FBT0EsTUFBUCxFQUFlLE1BQWYsRUFBdUIsQ0FBQyxDQUF4QixFQUEyQkMsTUFBM0IsS0FBc0MsQ0FEdEMsSUFFQSxLQUFLRCxNQUFMLEVBQWEsU0FBYixFQUF3QkMsTUFBeEIsS0FBbUMsQ0FGbkMsSUFHQSxJQUFJRCxNQUFKLEVBQVksVUFBWixFQUF3QkMsTUFBeEIsS0FBbUMsQ0FIbkMsSUFJQSxJQUFJRCxNQUFKLEVBQVksTUFBWixFQUFvQkMsTUFBcEIsSUFBOEIsQ0FKOUIsSUFLQSxHQUFHRCxNQUFILEVBQVcsSUFBWCxFQUFpQkMsTUFBakIsQ0FORixFQU9FO0FBQ0EsUUFBSUUsT0FBTyxPQUFPaG5CLElBQVAsQ0FBWSxFQUFaLEVBQWdCLENBQWhCLE1BQXVCOWtCLFNBQWxDLENBREEsQ0FDNkM7QUFDN0M7O0FBQ0F3ckMsYUFBUyxnQkFBVTdSLFNBQVYsRUFBcUJvUyxLQUFyQixFQUE0QjtBQUNuQyxVQUFJeG1CLFNBQVNGLE9BQU8sSUFBUCxDQUFiO0FBQ0EsVUFBSXNVLGNBQWMzNUIsU0FBZCxJQUEyQityQyxVQUFVLENBQXpDLEVBQTRDLE9BQU8sRUFBUCxDQUZULENBR25DOztBQUNBLFVBQUksQ0FBQ3prQixTQUFTcVMsU0FBVCxDQUFMLEVBQTBCLE9BQU84UixPQUFPOXVCLElBQVAsQ0FBWTRJLE1BQVosRUFBb0JvVSxTQUFwQixFQUErQm9TLEtBQS9CLENBQVA7QUFDMUIsVUFBSUMsU0FBUyxFQUFiO0FBQ0EsVUFBSW5CLFFBQVEsQ0FBQ2xSLFVBQVVsVSxVQUFWLEdBQXVCLEdBQXZCLEdBQTZCLEVBQTlCLEtBQ0NrVSxVQUFValUsU0FBVixHQUFzQixHQUF0QixHQUE0QixFQUQ3QixLQUVDaVUsVUFBVWhVLE9BQVYsR0FBb0IsR0FBcEIsR0FBMEIsRUFGM0IsS0FHQ2dVLFVBQVUvVCxNQUFWLEdBQW1CLEdBQW5CLEdBQXlCLEVBSDFCLENBQVo7QUFJQSxVQUFJcW1CLGdCQUFnQixDQUFwQjtBQUNBLFVBQUlDLGFBQWFILFVBQVUvckMsU0FBVixHQUFzQixVQUF0QixHQUFtQytyQyxVQUFVLENBQTlELENBWG1DLENBWW5DOztBQUNBLFVBQUlJLGdCQUFnQixJQUFJN21CLE1BQUosQ0FBV3FVLFVBQVU3VixNQUFyQixFQUE2QittQixRQUFRLEdBQXJDLENBQXBCO0FBQ0EsVUFBSXVCLFVBQUosRUFBZ0JoTCxLQUFoQixFQUF1QmlMLFNBQXZCLEVBQWtDQyxVQUFsQyxFQUE4Q251QyxDQUE5QyxDQWRtQyxDQWVuQzs7QUFDQSxVQUFJLENBQUMydEMsSUFBTCxFQUFXTSxhQUFhLElBQUk5bUIsTUFBSixDQUFXLE1BQU02bUIsY0FBY3JvQixNQUFwQixHQUE2QixVQUF4QyxFQUFvRCttQixLQUFwRCxDQUFiOztBQUNYLGFBQU96SixRQUFRK0ssY0FBY3JuQixJQUFkLENBQW1CUyxNQUFuQixDQUFmLEVBQTJDO0FBQ3pDO0FBQ0E4bUIsb0JBQVlqTCxNQUFNdmlDLEtBQU4sR0FBY3VpQyxNQUFNLENBQU4sRUFBU3dLLE1BQVQsQ0FBMUI7O0FBQ0EsWUFBSVMsWUFBWUosYUFBaEIsRUFBK0I7QUFDN0JELGlCQUFPeHJDLElBQVAsQ0FBWStrQixPQUFPdEosS0FBUCxDQUFhZ3dCLGFBQWIsRUFBNEI3SyxNQUFNdmlDLEtBQWxDLENBQVosRUFENkIsQ0FFN0I7QUFDQTs7QUFDQSxjQUFJLENBQUNpdEMsSUFBRCxJQUFTMUssTUFBTXdLLE1BQU4sSUFBZ0IsQ0FBN0IsRUFBZ0N4SyxNQUFNLENBQU4sRUFBUzlPLE9BQVQsQ0FBaUI4WixVQUFqQixFQUE2QixZQUFZO0FBQ3ZFLGlCQUFLanVDLElBQUksQ0FBVCxFQUFZQSxJQUFJdWIsVUFBVWt5QixNQUFWLElBQW9CLENBQXBDLEVBQXVDenRDLEdBQXZDO0FBQTRDLGtCQUFJdWIsVUFBVXZiLENBQVYsTUFBaUI2QixTQUFyQixFQUFnQ29oQyxNQUFNampDLENBQU4sSUFBVzZCLFNBQVg7QUFBNUU7QUFDRCxXQUYrQjtBQUdoQyxjQUFJb2hDLE1BQU13SyxNQUFOLElBQWdCLENBQWhCLElBQXFCeEssTUFBTXZpQyxLQUFOLEdBQWMwbUIsT0FBT3FtQixNQUFQLENBQXZDLEVBQXVERixNQUFNNXBCLEtBQU4sQ0FBWWtxQixNQUFaLEVBQW9CNUssTUFBTW5sQixLQUFOLENBQVksQ0FBWixDQUFwQjtBQUN2RHF3Qix1QkFBYWxMLE1BQU0sQ0FBTixFQUFTd0ssTUFBVCxDQUFiO0FBQ0FLLDBCQUFnQkksU0FBaEI7QUFDQSxjQUFJTCxPQUFPSixNQUFQLEtBQWtCTSxVQUF0QixFQUFrQztBQUNuQzs7QUFDRCxZQUFJQyxjQUFjTixVQUFkLE1BQThCekssTUFBTXZpQyxLQUF4QyxFQUErQ3N0QyxjQUFjTixVQUFkLElBZk4sQ0FlbUM7QUFDN0U7O0FBQ0QsVUFBSUksa0JBQWtCMW1CLE9BQU9xbUIsTUFBUCxDQUF0QixFQUFzQztBQUNwQyxZQUFJVSxjQUFjLENBQUNILGNBQWMvYixJQUFkLENBQW1CLEVBQW5CLENBQW5CLEVBQTJDNGIsT0FBT3hyQyxJQUFQLENBQVksRUFBWjtBQUM1QyxPQUZELE1BRU93ckMsT0FBT3hyQyxJQUFQLENBQVkra0IsT0FBT3RKLEtBQVAsQ0FBYWd3QixhQUFiLENBQVo7O0FBQ1AsYUFBT0QsT0FBT0osTUFBUCxJQUFpQk0sVUFBakIsR0FBOEJGLE9BQU8vdkIsS0FBUCxDQUFhLENBQWIsRUFBZ0Jpd0IsVUFBaEIsQ0FBOUIsR0FBNERGLE1BQW5FO0FBQ0QsS0F0Q0QsQ0FIQSxDQTBDRjs7QUFDQyxHQWxERCxNQWtETyxJQUFJLElBQUlMLE1BQUosRUFBWTNyQyxTQUFaLEVBQXVCLENBQXZCLEVBQTBCNHJDLE1BQTFCLENBQUosRUFBdUM7QUFDNUNKLGFBQVMsZ0JBQVU3UixTQUFWLEVBQXFCb1MsS0FBckIsRUFBNEI7QUFDbkMsYUFBT3BTLGNBQWMzNUIsU0FBZCxJQUEyQityQyxVQUFVLENBQXJDLEdBQXlDLEVBQXpDLEdBQThDTixPQUFPOXVCLElBQVAsQ0FBWSxJQUFaLEVBQWtCZ2QsU0FBbEIsRUFBNkJvUyxLQUE3QixDQUFyRDtBQUNELEtBRkQ7QUFHRCxHQTlEb0UsQ0ErRHJFOzs7QUFDQSxTQUFPLENBQUMsU0FBUzFvQixLQUFULENBQWVzVyxTQUFmLEVBQTBCb1MsS0FBMUIsRUFBaUM7QUFDdkMsUUFBSXh5QixJQUFJd0wsUUFBUSxJQUFSLENBQVI7QUFDQSxRQUFJdEksS0FBS2tkLGFBQWEzNUIsU0FBYixHQUF5QkEsU0FBekIsR0FBcUMyNUIsVUFBVTRSLEtBQVYsQ0FBOUM7QUFDQSxXQUFPOXVCLE9BQU96YyxTQUFQLEdBQW1CeWMsR0FBR0UsSUFBSCxDQUFRZ2QsU0FBUixFQUFtQnBnQixDQUFuQixFQUFzQnd5QixLQUF0QixDQUFuQixHQUFrRFAsT0FBTzd1QixJQUFQLENBQVkwSSxPQUFPOUwsQ0FBUCxDQUFaLEVBQXVCb2dCLFNBQXZCLEVBQWtDb1MsS0FBbEMsQ0FBekQ7QUFDRCxHQUpNLEVBSUpQLE1BSkksQ0FBUDtBQUtELENBckVELEU7Ozs7Ozs7O0FDREE7O0FBQ0EsbUJBQUF6dUMsQ0FBUSxvREFBUjs7QUFDQSxJQUFJcWlCLFdBQVcsbUJBQUFyaUIsQ0FBUSw4Q0FBUixDQUFmOztBQUNBLElBQUlxdEMsU0FBUyxtQkFBQXJ0QyxDQUFRLDBDQUFSLENBQWI7O0FBQ0EsSUFBSTRnQixjQUFjLG1CQUFBNWdCLENBQVEsZ0RBQVIsQ0FBbEI7O0FBQ0EsSUFBSTZ6QixZQUFZLFVBQWhCO0FBQ0EsSUFBSUMsWUFBWSxJQUFJRCxTQUFKLENBQWhCOztBQUVBLElBQUkyYixTQUFTLFNBQVRBLE1BQVMsQ0FBVTl2QixFQUFWLEVBQWM7QUFDekIxZixFQUFBLG1CQUFBQSxDQUFRLDZDQUFSLEVBQXVCdW9CLE9BQU92TSxTQUE5QixFQUF5QzZYLFNBQXpDLEVBQW9EblUsRUFBcEQsRUFBd0QsSUFBeEQ7QUFDRCxDQUZELEMsQ0FJQTs7O0FBQ0EsSUFBSSxtQkFBQTFmLENBQVEsMENBQVIsRUFBb0IsWUFBWTtBQUFFLFNBQU84ekIsVUFBVWxVLElBQVYsQ0FBZTtBQUFFbUgsWUFBUSxHQUFWO0FBQWUrbUIsV0FBTztBQUF0QixHQUFmLEtBQStDLE1BQXREO0FBQStELENBQWpHLENBQUosRUFBd0c7QUFDdEcwQixTQUFPLFNBQVNudkIsUUFBVCxHQUFvQjtBQUN6QixRQUFJdUgsSUFBSXZGLFNBQVMsSUFBVCxDQUFSO0FBQ0EsV0FBTyxJQUFJdGhCLE1BQUosQ0FBVzZtQixFQUFFYixNQUFiLEVBQXFCLEdBQXJCLEVBQ0wsV0FBV2EsQ0FBWCxHQUFlQSxFQUFFa21CLEtBQWpCLEdBQXlCLENBQUNsdEIsV0FBRCxJQUFnQmdILGFBQWFXLE1BQTdCLEdBQXNDOGtCLE9BQU96dEIsSUFBUCxDQUFZZ0ksQ0FBWixDQUF0QyxHQUF1RDNrQixTQUQzRSxDQUFQO0FBRUQsR0FKRCxFQURzRyxDQU14RztBQUNDLENBUEQsTUFPTyxJQUFJNndCLFVBQVV6dUIsSUFBVixJQUFrQnd1QixTQUF0QixFQUFpQztBQUN0QzJiLFNBQU8sU0FBU252QixRQUFULEdBQW9CO0FBQ3pCLFdBQU95VCxVQUFVbFUsSUFBVixDQUFlLElBQWYsQ0FBUDtBQUNELEdBRkQ7QUFHRCxDOzs7Ozs7OztBQ3hCRDs7QUFDQSxJQUFJMGtCLFNBQVMsbUJBQUF0a0MsQ0FBUSxzREFBUixDQUFiOztBQUNBLElBQUk4Z0IsV0FBVyxtQkFBQTlnQixDQUFRLHdEQUFSLENBQWY7O0FBQ0EsSUFBSXl2QyxNQUFNLEtBQVYsQyxDQUVBOztBQUNBL3pCLE9BQU9wYixPQUFQLEdBQWlCLG1CQUFBTixDQUFRLCtDQUFSLEVBQXlCeXZDLEdBQXpCLEVBQThCLFVBQVU1dEIsR0FBVixFQUFlO0FBQzVELFNBQU8sU0FBUzdkLEdBQVQsR0FBZTtBQUFFLFdBQU82ZCxJQUFJLElBQUosRUFBVWxGLFVBQVUvWSxNQUFWLEdBQW1CLENBQW5CLEdBQXVCK1ksVUFBVSxDQUFWLENBQXZCLEdBQXNDMVosU0FBaEQsQ0FBUDtBQUFvRSxHQUE1RjtBQUNELENBRmdCLEVBRWQ7QUFDRDtBQUNBaUIsT0FBSyxTQUFTQSxHQUFULENBQWEzRCxLQUFiLEVBQW9CO0FBQ3ZCLFdBQU8rakMsT0FBT3hpQixHQUFQLENBQVdoQixTQUFTLElBQVQsRUFBZTJ1QixHQUFmLENBQVgsRUFBZ0NsdkMsUUFBUUEsVUFBVSxDQUFWLEdBQWMsQ0FBZCxHQUFrQkEsS0FBMUQsRUFBaUVBLEtBQWpFLENBQVA7QUFDRDtBQUpBLENBRmMsRUFPZCtqQyxNQVBjLENBQWpCLEM7Ozs7Ozs7O0NDTEE7O0FBQ0EsbUJBQUF0a0MsQ0FBUSxnREFBUixFQUEwQixRQUExQixFQUFvQyxVQUFVcTFCLFVBQVYsRUFBc0I7QUFDeEQsU0FBTyxTQUFTcWEsTUFBVCxDQUFnQnJxQyxJQUFoQixFQUFzQjtBQUMzQixXQUFPZ3dCLFdBQVcsSUFBWCxFQUFpQixHQUFqQixFQUFzQixNQUF0QixFQUE4Qmh3QixJQUE5QixDQUFQO0FBQ0QsR0FGRDtBQUdELENBSkQsRTs7Ozs7Ozs7Q0NEQTs7QUFDQSxtQkFBQXJGLENBQVEsZ0RBQVIsRUFBMEIsS0FBMUIsRUFBaUMsVUFBVXExQixVQUFWLEVBQXNCO0FBQ3JELFNBQU8sU0FBU3NhLEdBQVQsR0FBZTtBQUNwQixXQUFPdGEsV0FBVyxJQUFYLEVBQWlCLEtBQWpCLEVBQXdCLEVBQXhCLEVBQTRCLEVBQTVCLENBQVA7QUFDRCxHQUZEO0FBR0QsQ0FKRCxFOzs7Ozs7OztDQ0RBOztBQUNBLG1CQUFBcjFCLENBQVEsZ0RBQVIsRUFBMEIsT0FBMUIsRUFBbUMsVUFBVXExQixVQUFWLEVBQXNCO0FBQ3ZELFNBQU8sU0FBU3VhLEtBQVQsR0FBaUI7QUFDdEIsV0FBT3ZhLFdBQVcsSUFBWCxFQUFpQixPQUFqQixFQUEwQixFQUExQixFQUE4QixFQUE5QixDQUFQO0FBQ0QsR0FGRDtBQUdELENBSkQsRTs7Ozs7Ozs7Q0NEQTs7QUFDQSxtQkFBQXIxQixDQUFRLGdEQUFSLEVBQTBCLE1BQTFCLEVBQWtDLFVBQVVxMUIsVUFBVixFQUFzQjtBQUN0RCxTQUFPLFNBQVN3YSxJQUFULEdBQWdCO0FBQ3JCLFdBQU94YSxXQUFXLElBQVgsRUFBaUIsR0FBakIsRUFBc0IsRUFBdEIsRUFBMEIsRUFBMUIsQ0FBUDtBQUNELEdBRkQ7QUFHRCxDQUpELEU7Ozs7Ozs7O0FDRkE7O0FBQ0EsSUFBSXBTLFVBQVUsbUJBQUFqakIsQ0FBUSwyQ0FBUixDQUFkOztBQUNBLElBQUk4dkMsTUFBTSxtQkFBQTl2QyxDQUFRLDhDQUFSLEVBQXdCLEtBQXhCLENBQVY7O0FBQ0FpakIsUUFBUUEsUUFBUW9FLENBQWhCLEVBQW1CLFFBQW5CLEVBQTZCO0FBQzNCO0FBQ0Ewb0IsZUFBYSxTQUFTQSxXQUFULENBQXFCOWEsR0FBckIsRUFBMEI7QUFDckMsV0FBTzZhLElBQUksSUFBSixFQUFVN2EsR0FBVixDQUFQO0FBQ0Q7QUFKMEIsQ0FBN0IsRTs7Ozs7Ozs7QUNIQTtBQUNBOztBQUNBLElBQUloUyxVQUFVLG1CQUFBampCLENBQVEsMkNBQVIsQ0FBZDs7QUFDQSxJQUFJc2MsV0FBVyxtQkFBQXRjLENBQVEsOENBQVIsQ0FBZjs7QUFDQSxJQUFJb1osVUFBVSxtQkFBQXBaLENBQVEsbURBQVIsQ0FBZDs7QUFDQSxJQUFJZ3dDLFlBQVksVUFBaEI7QUFDQSxJQUFJQyxZQUFZLEdBQUdELFNBQUgsQ0FBaEI7QUFFQS9zQixRQUFRQSxRQUFRb0UsQ0FBUixHQUFZcEUsUUFBUTVELENBQVIsR0FBWSxtQkFBQXJmLENBQVEsb0RBQVIsRUFBOEJnd0MsU0FBOUIsQ0FBaEMsRUFBMEUsUUFBMUUsRUFBb0Y7QUFDbEZFLFlBQVUsU0FBU0EsUUFBVCxDQUFrQi9hO0FBQWE7QUFBL0IsSUFBOEQ7QUFDdEUsUUFBSWhYLE9BQU8vRSxRQUFRLElBQVIsRUFBYytiLFlBQWQsRUFBNEI2YSxTQUE1QixDQUFYO0FBQ0EsUUFBSUcsY0FBY3h6QixVQUFVL1ksTUFBVixHQUFtQixDQUFuQixHQUF1QitZLFVBQVUsQ0FBVixDQUF2QixHQUFzQzFaLFNBQXhEO0FBQ0EsUUFBSXdaLE1BQU1ILFNBQVM2QixLQUFLdmEsTUFBZCxDQUFWO0FBQ0EsUUFBSXVELE1BQU1ncEMsZ0JBQWdCbHRDLFNBQWhCLEdBQTRCd1osR0FBNUIsR0FBa0NsVixLQUFLd0IsR0FBTCxDQUFTdVQsU0FBUzZ6QixXQUFULENBQVQsRUFBZ0MxekIsR0FBaEMsQ0FBNUM7QUFDQSxRQUFJOHhCLFNBQVNqbUIsT0FBTzZNLFlBQVAsQ0FBYjtBQUNBLFdBQU84YSxZQUNIQSxVQUFVcndCLElBQVYsQ0FBZXpCLElBQWYsRUFBcUJvd0IsTUFBckIsRUFBNkJwbkMsR0FBN0IsQ0FERyxHQUVIZ1gsS0FBS2UsS0FBTCxDQUFXL1gsTUFBTW9uQyxPQUFPM3FDLE1BQXhCLEVBQWdDdUQsR0FBaEMsTUFBeUNvbkMsTUFGN0M7QUFHRDtBQVZpRixDQUFwRixFOzs7Ozs7OztDQ1BBOztBQUNBLG1CQUFBdnVDLENBQVEsZ0RBQVIsRUFBMEIsT0FBMUIsRUFBbUMsVUFBVXExQixVQUFWLEVBQXNCO0FBQ3ZELFNBQU8sU0FBUythLEtBQVQsR0FBaUI7QUFDdEIsV0FBTy9hLFdBQVcsSUFBWCxFQUFpQixJQUFqQixFQUF1QixFQUF2QixFQUEyQixFQUEzQixDQUFQO0FBQ0QsR0FGRDtBQUdELENBSkQsRTs7Ozs7Ozs7Q0NEQTs7QUFDQSxtQkFBQXIxQixDQUFRLGdEQUFSLEVBQTBCLFdBQTFCLEVBQXVDLFVBQVVxMUIsVUFBVixFQUFzQjtBQUMzRCxTQUFPLFNBQVNnYixTQUFULENBQW1CQyxLQUFuQixFQUEwQjtBQUMvQixXQUFPamIsV0FBVyxJQUFYLEVBQWlCLE1BQWpCLEVBQXlCLE9BQXpCLEVBQWtDaWIsS0FBbEMsQ0FBUDtBQUNELEdBRkQ7QUFHRCxDQUpELEU7Ozs7Ozs7O0NDREE7O0FBQ0EsbUJBQUF0d0MsQ0FBUSxnREFBUixFQUEwQixVQUExQixFQUFzQyxVQUFVcTFCLFVBQVYsRUFBc0I7QUFDMUQsU0FBTyxTQUFTa2IsUUFBVCxDQUFrQnA0QixJQUFsQixFQUF3QjtBQUM3QixXQUFPa2QsV0FBVyxJQUFYLEVBQWlCLE1BQWpCLEVBQXlCLE1BQXpCLEVBQWlDbGQsSUFBakMsQ0FBUDtBQUNELEdBRkQ7QUFHRCxDQUpELEU7Ozs7Ozs7QUNGQSxJQUFJOEssVUFBVSxtQkFBQWpqQixDQUFRLDJDQUFSLENBQWQ7O0FBQ0EsSUFBSXFjLGtCQUFrQixtQkFBQXJjLENBQVEsc0RBQVIsQ0FBdEI7O0FBQ0EsSUFBSXd3QyxlQUFlbG9CLE9BQU9rb0IsWUFBMUI7QUFDQSxJQUFJQyxpQkFBaUJub0IsT0FBT29vQixhQUE1QixDLENBRUE7O0FBQ0F6dEIsUUFBUUEsUUFBUWtFLENBQVIsR0FBWWxFLFFBQVE1RCxDQUFSLElBQWEsQ0FBQyxDQUFDb3hCLGNBQUYsSUFBb0JBLGVBQWU3c0MsTUFBZixJQUF5QixDQUExRCxDQUFwQixFQUFrRixRQUFsRixFQUE0RjtBQUMxRjtBQUNBOHNDLGlCQUFlLFNBQVNBLGFBQVQsQ0FBdUJ2c0MsQ0FBdkIsRUFBMEI7QUFBRTtBQUN6QyxRQUFJb2EsTUFBTSxFQUFWO0FBQ0EsUUFBSTFCLE9BQU9GLFVBQVUvWSxNQUFyQjtBQUNBLFFBQUl4QyxJQUFJLENBQVI7QUFDQSxRQUFJMmxDLElBQUo7O0FBQ0EsV0FBT2xxQixPQUFPemIsQ0FBZCxFQUFpQjtBQUNmMmxDLGFBQU8sQ0FBQ3BxQixVQUFVdmIsR0FBVixDQUFSO0FBQ0EsVUFBSWliLGdCQUFnQjBxQixJQUFoQixFQUFzQixRQUF0QixNQUFvQ0EsSUFBeEMsRUFBOEMsTUFBTXZoQixXQUFXdWhCLE9BQU8sNEJBQWxCLENBQU47QUFDOUN4b0IsVUFBSTlhLElBQUosQ0FBU3NqQyxPQUFPLE9BQVAsR0FDTHlKLGFBQWF6SixJQUFiLENBREssR0FFTHlKLGFBQWEsQ0FBQyxDQUFDekosUUFBUSxPQUFULEtBQXFCLEVBQXRCLElBQTRCLE1BQXpDLEVBQWlEQSxPQUFPLEtBQVAsR0FBZSxNQUFoRSxDQUZKO0FBSUQ7O0FBQUMsV0FBT3hvQixJQUFJaUIsSUFBSixDQUFTLEVBQVQsQ0FBUDtBQUNIO0FBZnlGLENBQTVGLEU7Ozs7Ozs7O0FDTkE7QUFDQTs7QUFDQSxJQUFJeUQsVUFBVSxtQkFBQWpqQixDQUFRLDJDQUFSLENBQWQ7O0FBQ0EsSUFBSW9aLFVBQVUsbUJBQUFwWixDQUFRLG1EQUFSLENBQWQ7O0FBQ0EsSUFBSTJ3QyxXQUFXLFVBQWY7QUFFQTF0QixRQUFRQSxRQUFRb0UsQ0FBUixHQUFZcEUsUUFBUTVELENBQVIsR0FBWSxtQkFBQXJmLENBQVEsb0RBQVIsRUFBOEIyd0MsUUFBOUIsQ0FBaEMsRUFBeUUsUUFBekUsRUFBbUY7QUFDakZoVSxZQUFVLFNBQVNBLFFBQVQsQ0FBa0J4SDtBQUFhO0FBQS9CLElBQXFEO0FBQzdELFdBQU8sQ0FBQyxDQUFDLENBQUMvYixRQUFRLElBQVIsRUFBYytiLFlBQWQsRUFBNEJ3YixRQUE1QixFQUNQbFUsT0FETyxDQUNDdEgsWUFERCxFQUNleFksVUFBVS9ZLE1BQVYsR0FBbUIsQ0FBbkIsR0FBdUIrWSxVQUFVLENBQVYsQ0FBdkIsR0FBc0MxWixTQURyRCxDQUFWO0FBRUQ7QUFKZ0YsQ0FBbkYsRTs7Ozs7Ozs7Q0NMQTs7QUFDQSxtQkFBQWpELENBQVEsZ0RBQVIsRUFBMEIsU0FBMUIsRUFBcUMsVUFBVXExQixVQUFWLEVBQXNCO0FBQ3pELFNBQU8sU0FBU3ViLE9BQVQsR0FBbUI7QUFDeEIsV0FBT3ZiLFdBQVcsSUFBWCxFQUFpQixHQUFqQixFQUFzQixFQUF0QixFQUEwQixFQUExQixDQUFQO0FBQ0QsR0FGRDtBQUdELENBSkQsRTs7Ozs7Ozs7QUNGQTs7QUFDQSxJQUFJeWEsTUFBTSxtQkFBQTl2QyxDQUFRLDhDQUFSLEVBQXdCLElBQXhCLENBQVYsQyxDQUVBOzs7QUFDQSxtQkFBQUEsQ0FBUSxnREFBUixFQUEwQnNvQixNQUExQixFQUFrQyxRQUFsQyxFQUE0QyxVQUFVdEcsUUFBVixFQUFvQjtBQUM5RCxPQUFLUCxFQUFMLEdBQVU2RyxPQUFPdEcsUUFBUCxDQUFWLENBRDhELENBQ2xDOztBQUM1QixPQUFLZCxFQUFMLEdBQVUsQ0FBVixDQUY4RCxDQUVsQztBQUM5QjtBQUNDLENBSkQsRUFJRyxZQUFZO0FBQ2IsTUFBSTFFLElBQUksS0FBS2lGLEVBQWI7QUFDQSxNQUFJM2YsUUFBUSxLQUFLb2YsRUFBakI7QUFDQSxNQUFJdFAsS0FBSjtBQUNBLE1BQUk5UCxTQUFTMGEsRUFBRTVZLE1BQWYsRUFBdUIsT0FBTztBQUFFckQsV0FBTzBDLFNBQVQ7QUFBb0I0bUIsVUFBTTtBQUExQixHQUFQO0FBQ3ZCalksVUFBUWsrQixJQUFJdHpCLENBQUosRUFBTzFhLEtBQVAsQ0FBUjtBQUNBLE9BQUtvZixFQUFMLElBQVd0UCxNQUFNaE8sTUFBakI7QUFDQSxTQUFPO0FBQUVyRCxXQUFPcVIsS0FBVDtBQUFnQmlZLFVBQU07QUFBdEIsR0FBUDtBQUNELENBWkQsRTs7Ozs7Ozs7Q0NIQTs7QUFDQSxtQkFBQTdwQixDQUFRLGdEQUFSLEVBQTBCLE1BQTFCLEVBQWtDLFVBQVVxMUIsVUFBVixFQUFzQjtBQUN0RCxTQUFPLFNBQVN3YixJQUFULENBQWNDLEdBQWQsRUFBbUI7QUFDeEIsV0FBT3piLFdBQVcsSUFBWCxFQUFpQixHQUFqQixFQUFzQixNQUF0QixFQUE4QnliLEdBQTlCLENBQVA7QUFDRCxHQUZEO0FBR0QsQ0FKRCxFOzs7Ozs7O0FDRkEsSUFBSTd0QixVQUFVLG1CQUFBampCLENBQVEsMkNBQVIsQ0FBZDs7QUFDQSxJQUFJa2QsWUFBWSxtQkFBQWxkLENBQVEsK0NBQVIsQ0FBaEI7O0FBQ0EsSUFBSXNjLFdBQVcsbUJBQUF0YyxDQUFRLDhDQUFSLENBQWY7O0FBRUFpakIsUUFBUUEsUUFBUWtFLENBQWhCLEVBQW1CLFFBQW5CLEVBQTZCO0FBQzNCO0FBQ0E0cEIsT0FBSyxTQUFTQSxHQUFULENBQWFDLFFBQWIsRUFBdUI7QUFDMUIsUUFBSUMsTUFBTS96QixVQUFVOHpCLFNBQVNELEdBQW5CLENBQVY7QUFDQSxRQUFJdDBCLE1BQU1ILFNBQVMyMEIsSUFBSXJ0QyxNQUFiLENBQVY7QUFDQSxRQUFJaVosT0FBT0YsVUFBVS9ZLE1BQXJCO0FBQ0EsUUFBSTJhLE1BQU0sRUFBVjtBQUNBLFFBQUluZCxJQUFJLENBQVI7O0FBQ0EsV0FBT3FiLE1BQU1yYixDQUFiLEVBQWdCO0FBQ2RtZCxVQUFJOWEsSUFBSixDQUFTNmtCLE9BQU8yb0IsSUFBSTd2QyxHQUFKLENBQVAsQ0FBVDtBQUNBLFVBQUlBLElBQUl5YixJQUFSLEVBQWMwQixJQUFJOWEsSUFBSixDQUFTNmtCLE9BQU8zTCxVQUFVdmIsQ0FBVixDQUFQLENBQVQ7QUFDZjs7QUFBQyxXQUFPbWQsSUFBSWlCLElBQUosQ0FBUyxFQUFULENBQVA7QUFDSDtBQVowQixDQUE3QixFOzs7Ozs7O0FDSkEsSUFBSXlELFVBQVUsbUJBQUFqakIsQ0FBUSwyQ0FBUixDQUFkOztBQUVBaWpCLFFBQVFBLFFBQVFvRSxDQUFoQixFQUFtQixRQUFuQixFQUE2QjtBQUMzQjtBQUNBb08sVUFBUSxtQkFBQXoxQixDQUFRLGtEQUFSO0FBRm1CLENBQTdCLEU7Ozs7Ozs7O0NDREE7O0FBQ0EsbUJBQUFBLENBQVEsZ0RBQVIsRUFBMEIsT0FBMUIsRUFBbUMsVUFBVXExQixVQUFWLEVBQXNCO0FBQ3ZELFNBQU8sU0FBUzZiLEtBQVQsR0FBaUI7QUFDdEIsV0FBTzdiLFdBQVcsSUFBWCxFQUFpQixPQUFqQixFQUEwQixFQUExQixFQUE4QixFQUE5QixDQUFQO0FBQ0QsR0FGRDtBQUdELENBSkQsRTs7Ozs7Ozs7QUNGQTtBQUNBOztBQUNBLElBQUlwUyxVQUFVLG1CQUFBampCLENBQVEsMkNBQVIsQ0FBZDs7QUFDQSxJQUFJc2MsV0FBVyxtQkFBQXRjLENBQVEsOENBQVIsQ0FBZjs7QUFDQSxJQUFJb1osVUFBVSxtQkFBQXBaLENBQVEsbURBQVIsQ0FBZDs7QUFDQSxJQUFJbXhDLGNBQWMsWUFBbEI7QUFDQSxJQUFJQyxjQUFjLEdBQUdELFdBQUgsQ0FBbEI7QUFFQWx1QixRQUFRQSxRQUFRb0UsQ0FBUixHQUFZcEUsUUFBUTVELENBQVIsR0FBWSxtQkFBQXJmLENBQVEsb0RBQVIsRUFBOEJteEMsV0FBOUIsQ0FBaEMsRUFBNEUsUUFBNUUsRUFBc0Y7QUFDcEZFLGNBQVksU0FBU0EsVUFBVCxDQUFvQmxjO0FBQWE7QUFBakMsSUFBdUQ7QUFDakUsUUFBSWhYLE9BQU8vRSxRQUFRLElBQVIsRUFBYytiLFlBQWQsRUFBNEJnYyxXQUE1QixDQUFYO0FBQ0EsUUFBSXJ2QyxRQUFRd2EsU0FBUy9VLEtBQUt3QixHQUFMLENBQVM0VCxVQUFVL1ksTUFBVixHQUFtQixDQUFuQixHQUF1QitZLFVBQVUsQ0FBVixDQUF2QixHQUFzQzFaLFNBQS9DLEVBQTBEa2IsS0FBS3ZhLE1BQS9ELENBQVQsQ0FBWjtBQUNBLFFBQUkycUMsU0FBU2ptQixPQUFPNk0sWUFBUCxDQUFiO0FBQ0EsV0FBT2ljLGNBQ0hBLFlBQVl4eEIsSUFBWixDQUFpQnpCLElBQWpCLEVBQXVCb3dCLE1BQXZCLEVBQStCenNDLEtBQS9CLENBREcsR0FFSHFjLEtBQUtlLEtBQUwsQ0FBV3BkLEtBQVgsRUFBa0JBLFFBQVF5c0MsT0FBTzNxQyxNQUFqQyxNQUE2QzJxQyxNQUZqRDtBQUdEO0FBUm1GLENBQXRGLEU7Ozs7Ozs7O0NDUEE7O0FBQ0EsbUJBQUF2dUMsQ0FBUSxnREFBUixFQUEwQixRQUExQixFQUFvQyxVQUFVcTFCLFVBQVYsRUFBc0I7QUFDeEQsU0FBTyxTQUFTaWMsTUFBVCxHQUFrQjtBQUN2QixXQUFPamMsV0FBVyxJQUFYLEVBQWlCLFFBQWpCLEVBQTJCLEVBQTNCLEVBQStCLEVBQS9CLENBQVA7QUFDRCxHQUZEO0FBR0QsQ0FKRCxFOzs7Ozs7OztDQ0RBOztBQUNBLG1CQUFBcjFCLENBQVEsZ0RBQVIsRUFBMEIsS0FBMUIsRUFBaUMsVUFBVXExQixVQUFWLEVBQXNCO0FBQ3JELFNBQU8sU0FBU2tjLEdBQVQsR0FBZTtBQUNwQixXQUFPbGMsV0FBVyxJQUFYLEVBQWlCLEtBQWpCLEVBQXdCLEVBQXhCLEVBQTRCLEVBQTVCLENBQVA7QUFDRCxHQUZEO0FBR0QsQ0FKRCxFOzs7Ozs7OztDQ0RBOztBQUNBLG1CQUFBcjFCLENBQVEsZ0RBQVIsRUFBMEIsS0FBMUIsRUFBaUMsVUFBVXExQixVQUFWLEVBQXNCO0FBQ3JELFNBQU8sU0FBU21jLEdBQVQsR0FBZTtBQUNwQixXQUFPbmMsV0FBVyxJQUFYLEVBQWlCLEtBQWpCLEVBQXdCLEVBQXhCLEVBQTRCLEVBQTVCLENBQVA7QUFDRCxHQUZEO0FBR0QsQ0FKRCxFOzs7Ozs7OztDQ0RBOztBQUNBLG1CQUFBcjFCLENBQVEsZ0RBQVIsRUFBMEIsTUFBMUIsRUFBa0MsVUFBVTR5QixLQUFWLEVBQWlCO0FBQ2pELFNBQU8sU0FBU0MsSUFBVCxHQUFnQjtBQUNyQixXQUFPRCxNQUFNLElBQU4sRUFBWSxDQUFaLENBQVA7QUFDRCxHQUZEO0FBR0QsQ0FKRCxFOzs7Ozs7OztDQ0RBOztBQUNBLElBQUkzeUIsU0FBUyxtQkFBQUQsQ0FBUSwyQ0FBUixDQUFiOztBQUNBLElBQUlpRSxNQUFNLG1CQUFBakUsQ0FBUSx3Q0FBUixDQUFWOztBQUNBLElBQUk0Z0IsY0FBYyxtQkFBQTVnQixDQUFRLGdEQUFSLENBQWxCOztBQUNBLElBQUlpakIsVUFBVSxtQkFBQWpqQixDQUFRLDJDQUFSLENBQWQ7O0FBQ0EsSUFBSWtqQixXQUFXLG1CQUFBbGpCLENBQVEsNkNBQVIsQ0FBZjs7QUFDQSxJQUFJb3RCLE9BQU8sbUJBQUFwdEIsQ0FBUSx5Q0FBUixFQUFtQjhqQixHQUE5Qjs7QUFDQSxJQUFJaWtCLFNBQVMsbUJBQUEvbkMsQ0FBUSwwQ0FBUixDQUFiOztBQUNBLElBQUk0dEIsU0FBUyxtQkFBQTV0QixDQUFRLDJDQUFSLENBQWI7O0FBQ0EsSUFBSXNqQixpQkFBaUIsbUJBQUF0akIsQ0FBUSxzREFBUixDQUFyQjs7QUFDQSxJQUFJNDBCLE1BQU0sbUJBQUE1MEIsQ0FBUSx3Q0FBUixDQUFWOztBQUNBLElBQUlpb0IsTUFBTSxtQkFBQWpvQixDQUFRLHdDQUFSLENBQVY7O0FBQ0EsSUFBSXdpQyxTQUFTLG1CQUFBeGlDLENBQVEsNENBQVIsQ0FBYjs7QUFDQSxJQUFJeXhDLFlBQVksbUJBQUF6eEMsQ0FBUSwrQ0FBUixDQUFoQjs7QUFDQSxJQUFJMHhDLFdBQVcsbUJBQUExeEMsQ0FBUSw4Q0FBUixDQUFmOztBQUNBLElBQUk4UCxVQUFVLG1CQUFBOVAsQ0FBUSw2Q0FBUixDQUFkOztBQUNBLElBQUlxaUIsV0FBVyxtQkFBQXJpQixDQUFRLDhDQUFSLENBQWY7O0FBQ0EsSUFBSWtkLFlBQVksbUJBQUFsZCxDQUFRLCtDQUFSLENBQWhCOztBQUNBLElBQUltbUIsY0FBYyxtQkFBQW5tQixDQUFRLGlEQUFSLENBQWxCOztBQUNBLElBQUk2a0IsYUFBYSxtQkFBQTdrQixDQUFRLGtEQUFSLENBQWpCOztBQUNBLElBQUkyeEMsVUFBVSxtQkFBQTN4QyxDQUFRLGtEQUFSLENBQWQ7O0FBQ0EsSUFBSTR4QyxVQUFVLG1CQUFBNXhDLENBQVEsb0RBQVIsQ0FBZDs7QUFDQSxJQUFJZzVCLFFBQVEsbUJBQUFoNUIsQ0FBUSxnREFBUixDQUFaOztBQUNBLElBQUkrNEIsTUFBTSxtQkFBQS80QixDQUFRLDhDQUFSLENBQVY7O0FBQ0EsSUFBSWl5QixRQUFRLG1CQUFBanlCLENBQVEsZ0RBQVIsQ0FBWjs7QUFDQSxJQUFJMnhCLE9BQU9xSCxNQUFNM2EsQ0FBakI7QUFDQSxJQUFJaUMsS0FBS3lZLElBQUkxYSxDQUFiO0FBQ0EsSUFBSXdULE9BQU8rZixRQUFRdnpCLENBQW5CO0FBQ0EsSUFBSW9rQixVQUFVeGlDLE9BQU9pd0IsTUFBckI7QUFDQSxJQUFJMmhCLFFBQVE1eEMsT0FBTzZ4QyxJQUFuQjs7QUFDQSxJQUFJQyxhQUFhRixTQUFTQSxNQUFNRyxTQUFoQzs7QUFDQSxJQUFJbHJCLFlBQVksV0FBaEI7QUFDQSxJQUFJbXJCLFNBQVNocUIsSUFBSSxTQUFKLENBQWI7QUFDQSxJQUFJNmIsZUFBZTdiLElBQUksYUFBSixDQUFuQjtBQUNBLElBQUlyQixTQUFTLEdBQUd1RCxvQkFBaEI7QUFDQSxJQUFJK25CLGlCQUFpQnRrQixPQUFPLGlCQUFQLENBQXJCO0FBQ0EsSUFBSXVrQixhQUFhdmtCLE9BQU8sU0FBUCxDQUFqQjtBQUNBLElBQUl3a0IsWUFBWXhrQixPQUFPLFlBQVAsQ0FBaEI7QUFDQSxJQUFJd0UsY0FBY2h5QixPQUFPMG1CLFNBQVAsQ0FBbEI7QUFDQSxJQUFJMmlCLGFBQWEsT0FBT2hILE9BQVAsSUFBa0IsVUFBbkM7QUFDQSxJQUFJNFAsVUFBVXB5QyxPQUFPb3lDLE9BQXJCLEMsQ0FDQTs7QUFDQSxJQUFJL1QsU0FBUyxDQUFDK1QsT0FBRCxJQUFZLENBQUNBLFFBQVF2ckIsU0FBUixDQUFiLElBQW1DLENBQUN1ckIsUUFBUXZyQixTQUFSLEVBQW1Cd3JCLFNBQXBFLEMsQ0FFQTs7QUFDQSxJQUFJQyxnQkFBZ0IzeEIsZUFBZW1uQixPQUFPLFlBQVk7QUFDcEQsU0FBTzRKLFFBQVFyeEIsR0FBRyxFQUFILEVBQU8sR0FBUCxFQUFZO0FBQ3pCdUIsU0FBSyxlQUFZO0FBQUUsYUFBT3ZCLEdBQUcsSUFBSCxFQUFTLEdBQVQsRUFBYztBQUFFL2YsZUFBTztBQUFULE9BQWQsRUFBNEJ3SyxDQUFuQztBQUF1QztBQURqQyxHQUFaLENBQVIsRUFFSEEsQ0FGRyxJQUVFLENBRlQ7QUFHRCxDQUprQyxDQUFmLEdBSWYsVUFBVWxKLEVBQVYsRUFBY0wsR0FBZCxFQUFtQnN6QixDQUFuQixFQUFzQjtBQUN6QixNQUFJMGQsWUFBWTdnQixLQUFLUyxXQUFMLEVBQWtCNXdCLEdBQWxCLENBQWhCO0FBQ0EsTUFBSWd4QyxTQUFKLEVBQWUsT0FBT3BnQixZQUFZNXdCLEdBQVosQ0FBUDtBQUNmOGUsS0FBR3plLEVBQUgsRUFBT0wsR0FBUCxFQUFZc3pCLENBQVo7QUFDQSxNQUFJMGQsYUFBYTN3QyxPQUFPdXdCLFdBQXhCLEVBQXFDOVIsR0FBRzhSLFdBQUgsRUFBZ0I1d0IsR0FBaEIsRUFBcUJneEMsU0FBckI7QUFDdEMsQ0FUbUIsR0FTaEJseUIsRUFUSjs7QUFXQSxJQUFJbXlCLE9BQU8sU0FBUEEsSUFBTyxDQUFVL2QsR0FBVixFQUFlO0FBQ3hCLE1BQUlnZSxNQUFNUCxXQUFXemQsR0FBWCxJQUFrQmlkLFFBQVFsUCxRQUFRM2IsU0FBUixDQUFSLENBQTVCOztBQUNBNHJCLE1BQUl4d0IsRUFBSixHQUFTd1MsR0FBVDtBQUNBLFNBQU9nZSxHQUFQO0FBQ0QsQ0FKRDs7QUFNQSxJQUFJQyxXQUFXbEosY0FBYyxPQUFPaEgsUUFBUTdZLFFBQWYsSUFBMkIsUUFBekMsR0FBb0QsVUFBVS9uQixFQUFWLEVBQWM7QUFDL0UsU0FBTyxPQUFPQSxFQUFQLElBQWEsUUFBcEI7QUFDRCxDQUZjLEdBRVgsVUFBVUEsRUFBVixFQUFjO0FBQ2hCLFNBQU9BLGNBQWM0Z0MsT0FBckI7QUFDRCxDQUpEOztBQU1BLElBQUk3ZCxrQkFBa0IsU0FBU3ZrQixjQUFULENBQXdCd0IsRUFBeEIsRUFBNEJMLEdBQTVCLEVBQWlDc3pCLENBQWpDLEVBQW9DO0FBQ3hELE1BQUlqekIsT0FBT3V3QixXQUFYLEVBQXdCeE4sZ0JBQWdCd3RCLFNBQWhCLEVBQTJCNXdDLEdBQTNCLEVBQWdDc3pCLENBQWhDO0FBQ3hCelMsV0FBU3hnQixFQUFUO0FBQ0FMLFFBQU0ya0IsWUFBWTNrQixHQUFaLEVBQWlCLElBQWpCLENBQU47QUFDQTZnQixXQUFTeVMsQ0FBVDs7QUFDQSxNQUFJN3dCLElBQUlrdUMsVUFBSixFQUFnQjN3QyxHQUFoQixDQUFKLEVBQTBCO0FBQ3hCLFFBQUksQ0FBQ3N6QixFQUFFckIsVUFBUCxFQUFtQjtBQUNqQixVQUFJLENBQUN4dkIsSUFBSXBDLEVBQUosRUFBUW93QyxNQUFSLENBQUwsRUFBc0IzeEIsR0FBR3plLEVBQUgsRUFBT293QyxNQUFQLEVBQWVwdEIsV0FBVyxDQUFYLEVBQWMsRUFBZCxDQUFmO0FBQ3RCaGpCLFNBQUdvd0MsTUFBSCxFQUFXendDLEdBQVgsSUFBa0IsSUFBbEI7QUFDRCxLQUhELE1BR087QUFDTCxVQUFJeUMsSUFBSXBDLEVBQUosRUFBUW93QyxNQUFSLEtBQW1CcHdDLEdBQUdvd0MsTUFBSCxFQUFXendDLEdBQVgsQ0FBdkIsRUFBd0NLLEdBQUdvd0MsTUFBSCxFQUFXendDLEdBQVgsSUFBa0IsS0FBbEI7QUFDeENzekIsVUFBSTZjLFFBQVE3YyxDQUFSLEVBQVc7QUFBRXJCLG9CQUFZNU8sV0FBVyxDQUFYLEVBQWMsS0FBZDtBQUFkLE9BQVgsQ0FBSjtBQUNEOztBQUFDLFdBQU8wdEIsY0FBYzF3QyxFQUFkLEVBQWtCTCxHQUFsQixFQUF1QnN6QixDQUF2QixDQUFQO0FBQ0g7O0FBQUMsU0FBT3hVLEdBQUd6ZSxFQUFILEVBQU9MLEdBQVAsRUFBWXN6QixDQUFaLENBQVA7QUFDSCxDQWREOztBQWVBLElBQUk4ZCxvQkFBb0IsU0FBU3BoQixnQkFBVCxDQUEwQjN2QixFQUExQixFQUE4QndsQixDQUE5QixFQUFpQztBQUN2RGhGLFdBQVN4Z0IsRUFBVDtBQUNBLE1BQUliLE9BQU8wd0MsU0FBU3JxQixJQUFJbkssVUFBVW1LLENBQVYsQ0FBYixDQUFYO0FBQ0EsTUFBSWptQixJQUFJLENBQVI7QUFDQSxNQUFJdUssSUFBSTNLLEtBQUs0QyxNQUFiO0FBQ0EsTUFBSXBDLEdBQUo7O0FBQ0EsU0FBT21LLElBQUl2SyxDQUFYO0FBQWN3akIsb0JBQWdCL2lCLEVBQWhCLEVBQW9CTCxNQUFNUixLQUFLSSxHQUFMLENBQTFCLEVBQXFDaW1CLEVBQUU3bEIsR0FBRixDQUFyQztBQUFkOztBQUNBLFNBQU9LLEVBQVA7QUFDRCxDQVJEOztBQVNBLElBQUk4YixVQUFVLFNBQVNoSCxNQUFULENBQWdCOVUsRUFBaEIsRUFBb0J3bEIsQ0FBcEIsRUFBdUI7QUFDbkMsU0FBT0EsTUFBTXBrQixTQUFOLEdBQWtCMHVDLFFBQVE5dkMsRUFBUixDQUFsQixHQUFnQyt3QyxrQkFBa0JqQixRQUFROXZDLEVBQVIsQ0FBbEIsRUFBK0J3bEIsQ0FBL0IsQ0FBdkM7QUFDRCxDQUZEOztBQUdBLElBQUl3ckIsd0JBQXdCLFNBQVMxb0Isb0JBQVQsQ0FBOEIzb0IsR0FBOUIsRUFBbUM7QUFDN0QsTUFBSTRrQyxJQUFJeGYsT0FBT2hILElBQVAsQ0FBWSxJQUFaLEVBQWtCcGUsTUFBTTJrQixZQUFZM2tCLEdBQVosRUFBaUIsSUFBakIsQ0FBeEIsQ0FBUjtBQUNBLE1BQUksU0FBUzR3QixXQUFULElBQXdCbnVCLElBQUlrdUMsVUFBSixFQUFnQjN3QyxHQUFoQixDQUF4QixJQUFnRCxDQUFDeUMsSUFBSW11QyxTQUFKLEVBQWU1d0MsR0FBZixDQUFyRCxFQUEwRSxPQUFPLEtBQVA7QUFDMUUsU0FBTzRrQyxLQUFLLENBQUNuaUMsSUFBSSxJQUFKLEVBQVV6QyxHQUFWLENBQU4sSUFBd0IsQ0FBQ3lDLElBQUlrdUMsVUFBSixFQUFnQjN3QyxHQUFoQixDQUF6QixJQUFpRHlDLElBQUksSUFBSixFQUFVZ3VDLE1BQVYsS0FBcUIsS0FBS0EsTUFBTCxFQUFhendDLEdBQWIsQ0FBdEUsR0FBMEY0a0MsQ0FBMUYsR0FBOEYsSUFBckc7QUFDRCxDQUpEOztBQUtBLElBQUlpQyw0QkFBNEIsU0FBU3pXLHdCQUFULENBQWtDL3ZCLEVBQWxDLEVBQXNDTCxHQUF0QyxFQUEyQztBQUN6RUssT0FBS3FiLFVBQVVyYixFQUFWLENBQUw7QUFDQUwsUUFBTTJrQixZQUFZM2tCLEdBQVosRUFBaUIsSUFBakIsQ0FBTjtBQUNBLE1BQUlLLE9BQU91d0IsV0FBUCxJQUFzQm51QixJQUFJa3VDLFVBQUosRUFBZ0Izd0MsR0FBaEIsQ0FBdEIsSUFBOEMsQ0FBQ3lDLElBQUltdUMsU0FBSixFQUFlNXdDLEdBQWYsQ0FBbkQsRUFBd0U7QUFDeEUsTUFBSXN6QixJQUFJbkQsS0FBSzl2QixFQUFMLEVBQVNMLEdBQVQsQ0FBUjtBQUNBLE1BQUlzekIsS0FBSzd3QixJQUFJa3VDLFVBQUosRUFBZ0Izd0MsR0FBaEIsQ0FBTCxJQUE2QixFQUFFeUMsSUFBSXBDLEVBQUosRUFBUW93QyxNQUFSLEtBQW1CcHdDLEdBQUdvd0MsTUFBSCxFQUFXendDLEdBQVgsQ0FBckIsQ0FBakMsRUFBd0VzekIsRUFBRXJCLFVBQUYsR0FBZSxJQUFmO0FBQ3hFLFNBQU9xQixDQUFQO0FBQ0QsQ0FQRDs7QUFRQSxJQUFJZ2UsdUJBQXVCLFNBQVMvZ0IsbUJBQVQsQ0FBNkJsd0IsRUFBN0IsRUFBaUM7QUFDMUQsTUFBSXl3QixRQUFRVCxLQUFLM1UsVUFBVXJiLEVBQVYsQ0FBTCxDQUFaO0FBQ0EsTUFBSXlFLFNBQVMsRUFBYjtBQUNBLE1BQUlsRixJQUFJLENBQVI7QUFDQSxNQUFJSSxHQUFKOztBQUNBLFNBQU84d0IsTUFBTTF1QixNQUFOLEdBQWV4QyxDQUF0QixFQUF5QjtBQUN2QixRQUFJLENBQUM2QyxJQUFJa3VDLFVBQUosRUFBZ0Izd0MsTUFBTTh3QixNQUFNbHhCLEdBQU4sQ0FBdEIsQ0FBRCxJQUFzQ0ksT0FBT3l3QyxNQUE3QyxJQUF1RHp3QyxPQUFPNHJCLElBQWxFLEVBQXdFOW1CLE9BQU83QyxJQUFQLENBQVlqQyxHQUFaO0FBQ3pFOztBQUFDLFNBQU84RSxNQUFQO0FBQ0gsQ0FSRDs7QUFTQSxJQUFJeXNDLHlCQUF5QixTQUFTNWdCLHFCQUFULENBQStCdHdCLEVBQS9CLEVBQW1DO0FBQzlELE1BQUlteEMsUUFBUW54QyxPQUFPdXdCLFdBQW5CO0FBQ0EsTUFBSUUsUUFBUVQsS0FBS21oQixRQUFRWixTQUFSLEdBQW9CbDFCLFVBQVVyYixFQUFWLENBQXpCLENBQVo7QUFDQSxNQUFJeUUsU0FBUyxFQUFiO0FBQ0EsTUFBSWxGLElBQUksQ0FBUjtBQUNBLE1BQUlJLEdBQUo7O0FBQ0EsU0FBTzh3QixNQUFNMXVCLE1BQU4sR0FBZXhDLENBQXRCLEVBQXlCO0FBQ3ZCLFFBQUk2QyxJQUFJa3VDLFVBQUosRUFBZ0Izd0MsTUFBTTh3QixNQUFNbHhCLEdBQU4sQ0FBdEIsTUFBc0M0eEMsUUFBUS91QyxJQUFJbXVCLFdBQUosRUFBaUI1d0IsR0FBakIsQ0FBUixHQUFnQyxJQUF0RSxDQUFKLEVBQWlGOEUsT0FBTzdDLElBQVAsQ0FBWTB1QyxXQUFXM3dDLEdBQVgsQ0FBWjtBQUNsRjs7QUFBQyxTQUFPOEUsTUFBUDtBQUNILENBVEQsQyxDQVdBOzs7QUFDQSxJQUFJLENBQUNtakMsVUFBTCxFQUFpQjtBQUNmaEgsWUFBVSxTQUFTdlMsTUFBVCxHQUFrQjtBQUMxQixRQUFJLGdCQUFnQnVTLE9BQXBCLEVBQTZCLE1BQU05bUIsVUFBVSw4QkFBVixDQUFOO0FBQzdCLFFBQUkrWSxNQUFNRSxJQUFJalksVUFBVS9ZLE1BQVYsR0FBbUIsQ0FBbkIsR0FBdUIrWSxVQUFVLENBQVYsQ0FBdkIsR0FBc0MxWixTQUExQyxDQUFWOztBQUNBLFFBQUlvNkIsT0FBTyxTQUFQQSxJQUFPLENBQVU5OEIsS0FBVixFQUFpQjtBQUMxQixVQUFJLFNBQVM2eEIsV0FBYixFQUEwQmlMLEtBQUt6ZCxJQUFMLENBQVV3eUIsU0FBVixFQUFxQjd4QyxLQUFyQjtBQUMxQixVQUFJMEQsSUFBSSxJQUFKLEVBQVVndUMsTUFBVixLQUFxQmh1QyxJQUFJLEtBQUtndUMsTUFBTCxDQUFKLEVBQWtCdmQsR0FBbEIsQ0FBekIsRUFBaUQsS0FBS3VkLE1BQUwsRUFBYXZkLEdBQWIsSUFBb0IsS0FBcEI7QUFDakQ2ZCxvQkFBYyxJQUFkLEVBQW9CN2QsR0FBcEIsRUFBeUI3UCxXQUFXLENBQVgsRUFBY3RrQixLQUFkLENBQXpCO0FBQ0QsS0FKRDs7QUFLQSxRQUFJcWdCLGVBQWUwZCxNQUFuQixFQUEyQmlVLGNBQWNuZ0IsV0FBZCxFQUEyQnNDLEdBQTNCLEVBQWdDO0FBQUVoQixvQkFBYyxJQUFoQjtBQUFzQjVRLFdBQUt1YTtBQUEzQixLQUFoQztBQUMzQixXQUFPb1YsS0FBSy9kLEdBQUwsQ0FBUDtBQUNELEdBVkQ7O0FBV0F4UixXQUFTdWYsUUFBUTNiLFNBQVIsQ0FBVCxFQUE2QixVQUE3QixFQUF5QyxTQUFTekcsUUFBVCxHQUFvQjtBQUMzRCxXQUFPLEtBQUs2QixFQUFaO0FBQ0QsR0FGRDtBQUlBOFcsUUFBTTNhLENBQU4sR0FBVWdxQix5QkFBVjtBQUNBdFAsTUFBSTFhLENBQUosR0FBUXVHLGVBQVI7QUFDQTVrQixFQUFBLG1CQUFBQSxDQUFRLGdEQUFSLEVBQTBCcWUsQ0FBMUIsR0FBOEJ1ekIsUUFBUXZ6QixDQUFSLEdBQVl5MEIsb0JBQTFDO0FBQ0E5eUMsRUFBQSxtQkFBQUEsQ0FBUSwrQ0FBUixFQUF5QnFlLENBQXpCLEdBQTZCdzBCLHFCQUE3QjtBQUNBN3lDLEVBQUEsbUJBQUFBLENBQVEsZ0RBQVIsRUFBMEJxZSxDQUExQixHQUE4QjAwQixzQkFBOUI7O0FBRUEsTUFBSW55QixlQUFlLENBQUMsbUJBQUE1Z0IsQ0FBUSw0Q0FBUixDQUFwQixFQUEyQztBQUN6Q2tqQixhQUFTa1AsV0FBVCxFQUFzQixzQkFBdEIsRUFBOEN5Z0IscUJBQTlDLEVBQXFFLElBQXJFO0FBQ0Q7O0FBRURyUSxTQUFPbmtCLENBQVAsR0FBVyxVQUFVaFosSUFBVixFQUFnQjtBQUN6QixXQUFPb3RDLEtBQUt4cUIsSUFBSTVpQixJQUFKLENBQUwsQ0FBUDtBQUNELEdBRkQ7QUFHRDs7QUFFRDRkLFFBQVFBLFFBQVFzQixDQUFSLEdBQVl0QixRQUFRdUIsQ0FBcEIsR0FBd0J2QixRQUFRNUQsQ0FBUixHQUFZLENBQUNvcUIsVUFBN0MsRUFBeUQ7QUFBRXZaLFVBQVF1UztBQUFWLENBQXpEOztBQUVBLEtBQUssSUFBSXdRLGFBQ1A7QUFDQSxnSEFGb0IsQ0FHcEIzc0IsS0FIb0IsQ0FHZCxHQUhjLENBQWpCLEVBR1M4SixJQUFJLENBSGxCLEVBR3FCNmlCLFdBQVdydkMsTUFBWCxHQUFvQndzQixDQUh6QztBQUc0Q25JLE1BQUlnckIsV0FBVzdpQixHQUFYLENBQUo7QUFINUM7O0FBS0EsS0FBSyxJQUFJOGlCLG1CQUFtQmpoQixNQUFNaEssSUFBSXBGLEtBQVYsQ0FBdkIsRUFBeUN6QixJQUFJLENBQWxELEVBQXFEOHhCLGlCQUFpQnR2QyxNQUFqQixHQUEwQndkLENBQS9FO0FBQW1GcXdCLFlBQVV5QixpQkFBaUI5eEIsR0FBakIsQ0FBVjtBQUFuRjs7QUFFQTZCLFFBQVFBLFFBQVFrRSxDQUFSLEdBQVlsRSxRQUFRNUQsQ0FBUixHQUFZLENBQUNvcUIsVUFBakMsRUFBNkMsUUFBN0MsRUFBdUQ7QUFDckQ7QUFDQSxTQUFPLGNBQVVqb0MsR0FBVixFQUFlO0FBQ3BCLFdBQU95QyxJQUFJaXVDLGNBQUosRUFBb0Ixd0MsT0FBTyxFQUEzQixJQUNIMHdDLGVBQWUxd0MsR0FBZixDQURHLEdBRUgwd0MsZUFBZTF3QyxHQUFmLElBQXNCaWhDLFFBQVFqaEMsR0FBUixDQUYxQjtBQUdELEdBTm9EO0FBT3JEO0FBQ0EyeEMsVUFBUSxTQUFTQSxNQUFULENBQWdCVCxHQUFoQixFQUFxQjtBQUMzQixRQUFJLENBQUNDLFNBQVNELEdBQVQsQ0FBTCxFQUFvQixNQUFNLzJCLFVBQVUrMkIsTUFBTSxtQkFBaEIsQ0FBTjs7QUFDcEIsU0FBSyxJQUFJbHhDLEdBQVQsSUFBZ0Iwd0MsY0FBaEI7QUFBZ0MsVUFBSUEsZUFBZTF3QyxHQUFmLE1BQXdCa3hDLEdBQTVCLEVBQWlDLE9BQU9seEMsR0FBUDtBQUFqRTtBQUNELEdBWG9EO0FBWXJENHhDLGFBQVcscUJBQVk7QUFBRTlVLGFBQVMsSUFBVDtBQUFnQixHQVpZO0FBYXJEK1UsYUFBVyxxQkFBWTtBQUFFL1UsYUFBUyxLQUFUO0FBQWlCO0FBYlcsQ0FBdkQ7QUFnQkFyYixRQUFRQSxRQUFRa0UsQ0FBUixHQUFZbEUsUUFBUTVELENBQVIsR0FBWSxDQUFDb3FCLFVBQWpDLEVBQTZDLFFBQTdDLEVBQXVEO0FBQ3JEO0FBQ0E5eUIsVUFBUWdILE9BRjZDO0FBR3JEO0FBQ0F0ZCxrQkFBZ0J1a0IsZUFKcUM7QUFLckQ7QUFDQTRNLG9CQUFrQm9oQixpQkFObUM7QUFPckQ7QUFDQWhoQiw0QkFBMEJ5Vyx5QkFSMkI7QUFTckQ7QUFDQXRXLHVCQUFxQitnQixvQkFWZ0M7QUFXckQ7QUFDQTNnQix5QkFBdUI0Z0I7QUFaOEIsQ0FBdkQsRSxDQWVBOztBQUNBbEIsU0FBUzV1QixRQUFRQSxRQUFRa0UsQ0FBUixHQUFZbEUsUUFBUTVELENBQVIsSUFBYSxDQUFDb3FCLFVBQUQsSUFBZTFCLE9BQU8sWUFBWTtBQUMxRSxNQUFJNWdCLElBQUlzYixTQUFSLENBRDBFLENBRTFFO0FBQ0E7QUFDQTs7QUFDQSxTQUFPc1AsV0FBVyxDQUFDNXFCLENBQUQsQ0FBWCxLQUFtQixRQUFuQixJQUErQjRxQixXQUFXO0FBQUVobkMsT0FBR29jO0FBQUwsR0FBWCxLQUF3QixJQUF2RCxJQUErRDRxQixXQUFXM3hDLE9BQU8rbUIsQ0FBUCxDQUFYLEtBQXlCLElBQS9GO0FBQ0QsQ0FOd0QsQ0FBNUIsQ0FBcEIsRUFNSixNQU5JLEVBTUk7QUFDWDZxQixhQUFXLFNBQVNBLFNBQVQsQ0FBbUJud0MsRUFBbkIsRUFBdUI7QUFDaEMsUUFBSUEsT0FBT29CLFNBQVAsSUFBb0IwdkMsU0FBUzl3QyxFQUFULENBQXhCLEVBQXNDLE9BRE4sQ0FDYzs7QUFDOUMsUUFBSXlkLE9BQU8sQ0FBQ3pkLEVBQUQsQ0FBWDtBQUNBLFFBQUlULElBQUksQ0FBUjtBQUNBLFFBQUlreUMsUUFBSixFQUFjQyxTQUFkOztBQUNBLFdBQU81MkIsVUFBVS9ZLE1BQVYsR0FBbUJ4QyxDQUExQjtBQUE2QmtlLFdBQUs3YixJQUFMLENBQVVrWixVQUFVdmIsR0FBVixDQUFWO0FBQTdCOztBQUNBa3lDLGVBQVdoMEIsS0FBSyxDQUFMLENBQVg7QUFDQSxRQUFJLE9BQU9nMEIsUUFBUCxJQUFtQixVQUF2QixFQUFtQ0MsWUFBWUQsUUFBWjtBQUNuQyxRQUFJQyxhQUFhLENBQUN6akMsUUFBUXdqQyxRQUFSLENBQWxCLEVBQXFDQSxXQUFXLGtCQUFVOXhDLEdBQVYsRUFBZWpCLEtBQWYsRUFBc0I7QUFDcEUsVUFBSWd6QyxTQUFKLEVBQWVoekMsUUFBUWd6QyxVQUFVM3pCLElBQVYsQ0FBZSxJQUFmLEVBQXFCcGUsR0FBckIsRUFBMEJqQixLQUExQixDQUFSO0FBQ2YsVUFBSSxDQUFDb3lDLFNBQVNweUMsS0FBVCxDQUFMLEVBQXNCLE9BQU9BLEtBQVA7QUFDdkIsS0FIb0M7QUFJckMrZSxTQUFLLENBQUwsSUFBVWcwQixRQUFWO0FBQ0EsV0FBT3ZCLFdBQVdodEIsS0FBWCxDQUFpQjhzQixLQUFqQixFQUF3QnZ5QixJQUF4QixDQUFQO0FBQ0Q7QUFmVSxDQU5KLENBQVQsQyxDQXdCQTs7QUFDQW1qQixRQUFRM2IsU0FBUixFQUFtQmdkLFlBQW5CLEtBQW9DLG1CQUFBOWpDLENBQVEseUNBQVIsRUFBbUJ5aUMsUUFBUTNiLFNBQVIsQ0FBbkIsRUFBdUNnZCxZQUF2QyxFQUFxRHJCLFFBQVEzYixTQUFSLEVBQW1Cd1IsT0FBeEUsQ0FBcEMsQyxDQUNBOztBQUNBaFYsZUFBZW1mLE9BQWYsRUFBd0IsUUFBeEIsRSxDQUNBOztBQUNBbmYsZUFBZS9iLElBQWYsRUFBcUIsTUFBckIsRUFBNkIsSUFBN0IsRSxDQUNBOztBQUNBK2IsZUFBZXJqQixPQUFPNnhDLElBQXRCLEVBQTRCLE1BQTVCLEVBQW9DLElBQXBDLEU7Ozs7Ozs7O0FDek9BOztBQUNBLElBQUk3dUIsVUFBVSxtQkFBQWpqQixDQUFRLDJDQUFSLENBQWQ7O0FBQ0EsSUFBSXU0QixTQUFTLG1CQUFBdjRCLENBQVEsMENBQVIsQ0FBYjs7QUFDQSxJQUFJdzdCLFNBQVMsbUJBQUF4N0IsQ0FBUSxpREFBUixDQUFiOztBQUNBLElBQUlxaUIsV0FBVyxtQkFBQXJpQixDQUFRLDhDQUFSLENBQWY7O0FBQ0EsSUFBSXFjLGtCQUFrQixtQkFBQXJjLENBQVEsc0RBQVIsQ0FBdEI7O0FBQ0EsSUFBSXNjLFdBQVcsbUJBQUF0YyxDQUFRLDhDQUFSLENBQWY7O0FBQ0EsSUFBSW1jLFdBQVcsbUJBQUFuYyxDQUFRLDhDQUFSLENBQWY7O0FBQ0EsSUFBSXM1QixjQUFjLG1CQUFBdDVCLENBQVEsMkNBQVIsRUFBcUJzNUIsV0FBdkM7O0FBQ0EsSUFBSXZhLHFCQUFxQixtQkFBQS9lLENBQVEsd0RBQVIsQ0FBekI7O0FBQ0EsSUFBSXE1QixlQUFlbUMsT0FBT2xDLFdBQTFCO0FBQ0EsSUFBSUMsWUFBWWlDLE9BQU9oQyxRQUF2QjtBQUNBLElBQUlnYSxVQUFVamIsT0FBTzJGLEdBQVAsSUFBYzVFLFlBQVltYSxNQUF4QztBQUNBLElBQUlyVyxTQUFTL0QsYUFBYXJkLFNBQWIsQ0FBdUJrRCxLQUFwQztBQUNBLElBQUlnYyxPQUFPM0MsT0FBTzJDLElBQWxCO0FBQ0EsSUFBSWhDLGVBQWUsYUFBbkI7QUFFQWpXLFFBQVFBLFFBQVFzQixDQUFSLEdBQVl0QixRQUFRdUIsQ0FBcEIsR0FBd0J2QixRQUFRNUQsQ0FBUixJQUFhaWEsZ0JBQWdCRCxZQUE3QixDQUFoQyxFQUE0RTtBQUFFQyxlQUFhRDtBQUFmLENBQTVFO0FBRUFwVyxRQUFRQSxRQUFRa0UsQ0FBUixHQUFZbEUsUUFBUTVELENBQVIsR0FBWSxDQUFDa1osT0FBT3dDLE1BQXhDLEVBQWdEN0IsWUFBaEQsRUFBOEQ7QUFDNUQ7QUFDQXVhLFVBQVEsU0FBU0EsTUFBVCxDQUFnQjV4QyxFQUFoQixFQUFvQjtBQUMxQixXQUFPMnhDLFdBQVdBLFFBQVEzeEMsRUFBUixDQUFYLElBQTBCc2EsU0FBU3RhLEVBQVQsS0FBZ0JxNUIsUUFBUXI1QixFQUF6RDtBQUNEO0FBSjJELENBQTlEO0FBT0FvaEIsUUFBUUEsUUFBUW9FLENBQVIsR0FBWXBFLFFBQVEwRSxDQUFwQixHQUF3QjFFLFFBQVE1RCxDQUFSLEdBQVksbUJBQUFyZixDQUFRLDBDQUFSLEVBQW9CLFlBQVk7QUFDMUUsU0FBTyxDQUFDLElBQUlxNUIsWUFBSixDQUFpQixDQUFqQixFQUFvQm5hLEtBQXBCLENBQTBCLENBQTFCLEVBQTZCamMsU0FBN0IsRUFBd0MwN0IsVUFBaEQ7QUFDRCxDQUYyQyxDQUE1QyxFQUVJekYsWUFGSixFQUVrQjtBQUNoQjtBQUNBaGEsU0FBTyxTQUFTQSxLQUFULENBQWVoZSxLQUFmLEVBQXNCaUcsR0FBdEIsRUFBMkI7QUFDaEMsUUFBSWkyQixXQUFXbjZCLFNBQVgsSUFBd0JrRSxRQUFRbEUsU0FBcEMsRUFBK0MsT0FBT202QixPQUFPeGQsSUFBUCxDQUFZeUMsU0FBUyxJQUFULENBQVosRUFBNEJuaEIsS0FBNUIsQ0FBUCxDQURmLENBQzBEOztBQUMxRixRQUFJdWIsTUFBTTRGLFNBQVMsSUFBVCxFQUFlc2MsVUFBekI7QUFDQSxRQUFJejdCLFFBQVFtWixnQkFBZ0JuYixLQUFoQixFQUF1QnViLEdBQXZCLENBQVo7QUFDQSxRQUFJaTNCLFFBQVFyM0IsZ0JBQWdCbFYsUUFBUWxFLFNBQVIsR0FBb0J3WixHQUFwQixHQUEwQnRWLEdBQTFDLEVBQStDc1YsR0FBL0MsQ0FBWjtBQUNBLFFBQUluVyxTQUFTLEtBQUt5WSxtQkFBbUIsSUFBbkIsRUFBeUJzYSxZQUF6QixDQUFMLEVBQTZDL2MsU0FBU28zQixRQUFReHdDLEtBQWpCLENBQTdDLENBQWI7QUFDQSxRQUFJeXdDLFFBQVEsSUFBSXBhLFNBQUosQ0FBYyxJQUFkLENBQVo7QUFDQSxRQUFJcWEsUUFBUSxJQUFJcmEsU0FBSixDQUFjanpCLE1BQWQsQ0FBWjtBQUNBLFFBQUl4RSxRQUFRLENBQVo7O0FBQ0EsV0FBT29CLFFBQVF3d0MsS0FBZixFQUFzQjtBQUNwQkUsWUFBTWhTLFFBQU4sQ0FBZTkvQixPQUFmLEVBQXdCNnhDLE1BQU12UyxRQUFOLENBQWVsK0IsT0FBZixDQUF4QjtBQUNEOztBQUFDLFdBQU9vRCxNQUFQO0FBQ0g7QUFkZSxDQUZsQjs7QUFtQkEsbUJBQUF0RyxDQUFRLGdEQUFSLEVBQTBCazVCLFlBQTFCLEU7Ozs7Ozs7QUM3Q0EsSUFBSWpXLFVBQVUsbUJBQUFqakIsQ0FBUSwyQ0FBUixDQUFkOztBQUNBaWpCLFFBQVFBLFFBQVFzQixDQUFSLEdBQVl0QixRQUFRdUIsQ0FBcEIsR0FBd0J2QixRQUFRNUQsQ0FBUixHQUFZLENBQUMsbUJBQUFyZixDQUFRLDBDQUFSLEVBQW9CaytCLEdBQWpFLEVBQXNFO0FBQ3BFMUUsWUFBVSxtQkFBQXg1QixDQUFRLGlEQUFSLEVBQTJCdzVCO0FBRCtCLENBQXRFLEU7Ozs7Ozs7QUNEQSxtQkFBQXg1QixDQUFRLGdEQUFSLEVBQTBCLFNBQTFCLEVBQXFDLENBQXJDLEVBQXdDLFVBQVU2ekMsSUFBVixFQUFnQjtBQUN0RCxTQUFPLFNBQVNDLFlBQVQsQ0FBc0JueUIsSUFBdEIsRUFBNEJ3YixVQUE1QixFQUF3Q3Y1QixNQUF4QyxFQUFnRDtBQUNyRCxXQUFPaXdDLEtBQUssSUFBTCxFQUFXbHlCLElBQVgsRUFBaUJ3YixVQUFqQixFQUE2QnY1QixNQUE3QixDQUFQO0FBQ0QsR0FGRDtBQUdELENBSkQsRTs7Ozs7OztBQ0FBLG1CQUFBNUQsQ0FBUSxnREFBUixFQUEwQixTQUExQixFQUFxQyxDQUFyQyxFQUF3QyxVQUFVNnpDLElBQVYsRUFBZ0I7QUFDdEQsU0FBTyxTQUFTRSxZQUFULENBQXNCcHlCLElBQXRCLEVBQTRCd2IsVUFBNUIsRUFBd0N2NUIsTUFBeEMsRUFBZ0Q7QUFDckQsV0FBT2l3QyxLQUFLLElBQUwsRUFBV2x5QixJQUFYLEVBQWlCd2IsVUFBakIsRUFBNkJ2NUIsTUFBN0IsQ0FBUDtBQUNELEdBRkQ7QUFHRCxDQUpELEU7Ozs7Ozs7QUNBQSxtQkFBQTVELENBQVEsZ0RBQVIsRUFBMEIsT0FBMUIsRUFBbUMsQ0FBbkMsRUFBc0MsVUFBVTZ6QyxJQUFWLEVBQWdCO0FBQ3BELFNBQU8sU0FBU0csVUFBVCxDQUFvQnJ5QixJQUFwQixFQUEwQndiLFVBQTFCLEVBQXNDdjVCLE1BQXRDLEVBQThDO0FBQ25ELFdBQU9pd0MsS0FBSyxJQUFMLEVBQVdseUIsSUFBWCxFQUFpQndiLFVBQWpCLEVBQTZCdjVCLE1BQTdCLENBQVA7QUFDRCxHQUZEO0FBR0QsQ0FKRCxFOzs7Ozs7O0FDQUEsbUJBQUE1RCxDQUFRLGdEQUFSLEVBQTBCLE9BQTFCLEVBQW1DLENBQW5DLEVBQXNDLFVBQVU2ekMsSUFBVixFQUFnQjtBQUNwRCxTQUFPLFNBQVNJLFVBQVQsQ0FBb0J0eUIsSUFBcEIsRUFBMEJ3YixVQUExQixFQUFzQ3Y1QixNQUF0QyxFQUE4QztBQUNuRCxXQUFPaXdDLEtBQUssSUFBTCxFQUFXbHlCLElBQVgsRUFBaUJ3YixVQUFqQixFQUE2QnY1QixNQUE3QixDQUFQO0FBQ0QsR0FGRDtBQUdELENBSkQsRTs7Ozs7OztBQ0FBLG1CQUFBNUQsQ0FBUSxnREFBUixFQUEwQixNQUExQixFQUFrQyxDQUFsQyxFQUFxQyxVQUFVNnpDLElBQVYsRUFBZ0I7QUFDbkQsU0FBTyxTQUFTSyxTQUFULENBQW1CdnlCLElBQW5CLEVBQXlCd2IsVUFBekIsRUFBcUN2NUIsTUFBckMsRUFBNkM7QUFDbEQsV0FBT2l3QyxLQUFLLElBQUwsRUFBV2x5QixJQUFYLEVBQWlCd2IsVUFBakIsRUFBNkJ2NUIsTUFBN0IsQ0FBUDtBQUNELEdBRkQ7QUFHRCxDQUpELEU7Ozs7Ozs7QUNBQSxtQkFBQTVELENBQVEsZ0RBQVIsRUFBMEIsUUFBMUIsRUFBb0MsQ0FBcEMsRUFBdUMsVUFBVTZ6QyxJQUFWLEVBQWdCO0FBQ3JELFNBQU8sU0FBU3RZLFdBQVQsQ0FBcUI1WixJQUFyQixFQUEyQndiLFVBQTNCLEVBQXVDdjVCLE1BQXZDLEVBQStDO0FBQ3BELFdBQU9pd0MsS0FBSyxJQUFMLEVBQVdseUIsSUFBWCxFQUFpQndiLFVBQWpCLEVBQTZCdjVCLE1BQTdCLENBQVA7QUFDRCxHQUZEO0FBR0QsQ0FKRCxFOzs7Ozs7O0FDQUEsbUJBQUE1RCxDQUFRLGdEQUFSLEVBQTBCLFFBQTFCLEVBQW9DLENBQXBDLEVBQXVDLFVBQVU2ekMsSUFBVixFQUFnQjtBQUNyRCxTQUFPLFNBQVNNLFdBQVQsQ0FBcUJ4eUIsSUFBckIsRUFBMkJ3YixVQUEzQixFQUF1Q3Y1QixNQUF2QyxFQUErQztBQUNwRCxXQUFPaXdDLEtBQUssSUFBTCxFQUFXbHlCLElBQVgsRUFBaUJ3YixVQUFqQixFQUE2QnY1QixNQUE3QixDQUFQO0FBQ0QsR0FGRDtBQUdELENBSkQsRTs7Ozs7OztBQ0FBLG1CQUFBNUQsQ0FBUSxnREFBUixFQUEwQixPQUExQixFQUFtQyxDQUFuQyxFQUFzQyxVQUFVNnpDLElBQVYsRUFBZ0I7QUFDcEQsU0FBTyxTQUFTNWEsVUFBVCxDQUFvQnRYLElBQXBCLEVBQTBCd2IsVUFBMUIsRUFBc0N2NUIsTUFBdEMsRUFBOEM7QUFDbkQsV0FBT2l3QyxLQUFLLElBQUwsRUFBV2x5QixJQUFYLEVBQWlCd2IsVUFBakIsRUFBNkJ2NUIsTUFBN0IsQ0FBUDtBQUNELEdBRkQ7QUFHRCxDQUpELEU7Ozs7Ozs7QUNBQSxtQkFBQTVELENBQVEsZ0RBQVIsRUFBMEIsT0FBMUIsRUFBbUMsQ0FBbkMsRUFBc0MsVUFBVTZ6QyxJQUFWLEVBQWdCO0FBQ3BELFNBQU8sU0FBU08saUJBQVQsQ0FBMkJ6eUIsSUFBM0IsRUFBaUN3YixVQUFqQyxFQUE2Q3Y1QixNQUE3QyxFQUFxRDtBQUMxRCxXQUFPaXdDLEtBQUssSUFBTCxFQUFXbHlCLElBQVgsRUFBaUJ3YixVQUFqQixFQUE2QnY1QixNQUE3QixDQUFQO0FBQ0QsR0FGRDtBQUdELENBSkQsRUFJRyxJQUpILEU7Ozs7Ozs7O0FDQUE7O0FBQ0EsSUFBSXl3QyxPQUFPLG1CQUFBcjBDLENBQVEsa0RBQVIsRUFBNEIsQ0FBNUIsQ0FBWDs7QUFDQSxJQUFJa2pCLFdBQVcsbUJBQUFsakIsQ0FBUSw2Q0FBUixDQUFmOztBQUNBLElBQUltakIsT0FBTyxtQkFBQW5qQixDQUFRLHlDQUFSLENBQVg7O0FBQ0EsSUFBSXdKLFNBQVMsbUJBQUF4SixDQUFRLGtEQUFSLENBQWI7O0FBQ0EsSUFBSXMwQyxPQUFPLG1CQUFBdDBDLENBQVEsb0RBQVIsQ0FBWDs7QUFDQSxJQUFJbWMsV0FBVyxtQkFBQW5jLENBQVEsOENBQVIsQ0FBZjs7QUFDQSxJQUFJb2pCLFFBQVEsbUJBQUFwakIsQ0FBUSwwQ0FBUixDQUFaOztBQUNBLElBQUk4Z0IsV0FBVyxtQkFBQTlnQixDQUFRLHdEQUFSLENBQWY7O0FBQ0EsSUFBSXUwQyxXQUFXLFNBQWY7QUFDQSxJQUFJbnlCLFVBQVVlLEtBQUtmLE9BQW5CO0FBQ0EsSUFBSWtMLGVBQWVsdEIsT0FBT2t0QixZQUExQjtBQUNBLElBQUk1SyxzQkFBc0I0eEIsS0FBS3R4QixPQUEvQjtBQUNBLElBQUl3eEIsTUFBTSxFQUFWO0FBQ0EsSUFBSUMsV0FBSjs7QUFFQSxJQUFJbnpCLFVBQVUsU0FBVkEsT0FBVSxDQUFVTyxHQUFWLEVBQWU7QUFDM0IsU0FBTyxTQUFTNnlCLE9BQVQsR0FBbUI7QUFDeEIsV0FBTzd5QixJQUFJLElBQUosRUFBVWxGLFVBQVUvWSxNQUFWLEdBQW1CLENBQW5CLEdBQXVCK1ksVUFBVSxDQUFWLENBQXZCLEdBQXNDMVosU0FBaEQsQ0FBUDtBQUNELEdBRkQ7QUFHRCxDQUpEOztBQU1BLElBQUl1Z0IsVUFBVTtBQUNaO0FBQ0EzQixPQUFLLFNBQVNBLEdBQVQsQ0FBYXJnQixHQUFiLEVBQWtCO0FBQ3JCLFFBQUkyYSxTQUFTM2EsR0FBVCxDQUFKLEVBQW1CO0FBQ2pCLFVBQUltZ0IsT0FBT1MsUUFBUTVnQixHQUFSLENBQVg7QUFDQSxVQUFJbWdCLFNBQVMsSUFBYixFQUFtQixPQUFPZSxvQkFBb0I1QixTQUFTLElBQVQsRUFBZXl6QixRQUFmLENBQXBCLEVBQThDMXlCLEdBQTlDLENBQWtEcmdCLEdBQWxELENBQVA7QUFDbkIsYUFBT21nQixPQUFPQSxLQUFLLEtBQUtULEVBQVYsQ0FBUCxHQUF1QmplLFNBQTlCO0FBQ0Q7QUFDRixHQVJXO0FBU1o7QUFDQTZmLE9BQUssU0FBU0EsR0FBVCxDQUFhdGhCLEdBQWIsRUFBa0JqQixLQUFsQixFQUF5QjtBQUM1QixXQUFPK3pDLEtBQUt4eUIsR0FBTCxDQUFTaEIsU0FBUyxJQUFULEVBQWV5ekIsUUFBZixDQUFULEVBQW1DL3lDLEdBQW5DLEVBQXdDakIsS0FBeEMsQ0FBUDtBQUNEO0FBWlcsQ0FBZCxDLENBZUE7O0FBQ0EsSUFBSW8wQyxXQUFXajVCLE9BQU9wYixPQUFQLEdBQWlCLG1CQUFBTixDQUFRLCtDQUFSLEVBQXlCdTBDLFFBQXpCLEVBQW1DanpCLE9BQW5DLEVBQTRDa0MsT0FBNUMsRUFBcUQ4d0IsSUFBckQsRUFBMkQsSUFBM0QsRUFBaUUsSUFBakUsQ0FBaEMsQyxDQUVBOzs7QUFDQSxJQUFJbHhCLE1BQU0sWUFBWTtBQUFFLFNBQU8sSUFBSXV4QixRQUFKLEdBQWU3eEIsR0FBZixDQUFtQixDQUFDMWlCLE9BQU9nb0MsTUFBUCxJQUFpQmhvQyxNQUFsQixFQUEwQm8wQyxHQUExQixDQUFuQixFQUFtRCxDQUFuRCxFQUFzRDN5QixHQUF0RCxDQUEwRDJ5QixHQUExRCxLQUFrRSxDQUF6RTtBQUE2RSxDQUFqRyxDQUFKLEVBQXdHO0FBQ3RHQyxnQkFBY0gsS0FBS2p6QixjQUFMLENBQW9CQyxPQUFwQixFQUE2Qml6QixRQUE3QixDQUFkO0FBQ0EvcUMsU0FBT2lyQyxZQUFZejRCLFNBQW5CLEVBQThCd0gsT0FBOUI7QUFDQUwsT0FBS2EsSUFBTCxHQUFZLElBQVo7QUFDQXF3QixPQUFLLENBQUMsUUFBRCxFQUFXLEtBQVgsRUFBa0IsS0FBbEIsRUFBeUIsS0FBekIsQ0FBTCxFQUFzQyxVQUFVN3lDLEdBQVYsRUFBZTtBQUNuRCxRQUFJb2lCLFFBQVErd0IsU0FBUzM0QixTQUFyQjtBQUNBLFFBQUkrWSxTQUFTblIsTUFBTXBpQixHQUFOLENBQWI7QUFDQTBoQixhQUFTVSxLQUFULEVBQWdCcGlCLEdBQWhCLEVBQXFCLFVBQVV1SixDQUFWLEVBQWFELENBQWIsRUFBZ0I7QUFDbkM7QUFDQSxVQUFJcVIsU0FBU3BSLENBQVQsS0FBZSxDQUFDdWlCLGFBQWF2aUIsQ0FBYixDQUFwQixFQUFxQztBQUNuQyxZQUFJLENBQUMsS0FBS29XLEVBQVYsRUFBYyxLQUFLQSxFQUFMLEdBQVUsSUFBSXN6QixXQUFKLEVBQVY7O0FBQ2QsWUFBSW51QyxTQUFTLEtBQUs2YSxFQUFMLENBQVEzZixHQUFSLEVBQWF1SixDQUFiLEVBQWdCRCxDQUFoQixDQUFiOztBQUNBLGVBQU90SixPQUFPLEtBQVAsR0FBZSxJQUFmLEdBQXNCOEUsTUFBN0IsQ0FIbUMsQ0FJckM7QUFDQzs7QUFBQyxhQUFPeXVCLE9BQU9uVixJQUFQLENBQVksSUFBWixFQUFrQjdVLENBQWxCLEVBQXFCRCxDQUFyQixDQUFQO0FBQ0gsS0FSRDtBQVNELEdBWkQ7QUFhRCxDOzs7Ozs7OztBQzFERDs7QUFDQSxJQUFJd3BDLE9BQU8sbUJBQUF0MEMsQ0FBUSxvREFBUixDQUFYOztBQUNBLElBQUk4Z0IsV0FBVyxtQkFBQTlnQixDQUFRLHdEQUFSLENBQWY7O0FBQ0EsSUFBSTQwQyxXQUFXLFNBQWYsQyxDQUVBOztBQUNBLG1CQUFBNTBDLENBQVEsK0NBQVIsRUFBeUI0MEMsUUFBekIsRUFBbUMsVUFBVS95QixHQUFWLEVBQWU7QUFDaEQsU0FBTyxTQUFTZ3pCLE9BQVQsR0FBbUI7QUFBRSxXQUFPaHpCLElBQUksSUFBSixFQUFVbEYsVUFBVS9ZLE1BQVYsR0FBbUIsQ0FBbkIsR0FBdUIrWSxVQUFVLENBQVYsQ0FBdkIsR0FBc0MxWixTQUFoRCxDQUFQO0FBQW9FLEdBQWhHO0FBQ0QsQ0FGRCxFQUVHO0FBQ0Q7QUFDQWlCLE9BQUssU0FBU0EsR0FBVCxDQUFhM0QsS0FBYixFQUFvQjtBQUN2QixXQUFPK3pDLEtBQUt4eUIsR0FBTCxDQUFTaEIsU0FBUyxJQUFULEVBQWU4ekIsUUFBZixDQUFULEVBQW1DcjBDLEtBQW5DLEVBQTBDLElBQTFDLENBQVA7QUFDRDtBQUpBLENBRkgsRUFPRyt6QyxJQVBILEVBT1MsS0FQVCxFQU9nQixJQVBoQixFOzs7Ozs7OztDQ0xBOztBQUNBLElBQUlyeEIsVUFBVSxtQkFBQWpqQixDQUFRLDJDQUFSLENBQWQ7O0FBQ0EsSUFBSStvQixtQkFBbUIsbUJBQUEvb0IsQ0FBUSx1REFBUixDQUF2Qjs7QUFDQSxJQUFJb2MsV0FBVyxtQkFBQXBjLENBQVEsOENBQVIsQ0FBZjs7QUFDQSxJQUFJc2MsV0FBVyxtQkFBQXRjLENBQVEsOENBQVIsQ0FBZjs7QUFDQSxJQUFJd2UsWUFBWSxtQkFBQXhlLENBQVEsK0NBQVIsQ0FBaEI7O0FBQ0EsSUFBSTgwQyxxQkFBcUIsbUJBQUE5MEMsQ0FBUSx5REFBUixDQUF6Qjs7QUFFQWlqQixRQUFRQSxRQUFRb0UsQ0FBaEIsRUFBbUIsT0FBbkIsRUFBNEI7QUFDMUJwbEIsV0FBUyxTQUFTQSxPQUFULENBQWlCaWM7QUFBVztBQUE1QixJQUE2QztBQUNwRCxRQUFJMUIsSUFBSUosU0FBUyxJQUFULENBQVI7QUFDQSxRQUFJNE0sU0FBSixFQUFlaUgsQ0FBZjtBQUNBelIsY0FBVU4sVUFBVjtBQUNBOEssZ0JBQVkxTSxTQUFTRSxFQUFFNVksTUFBWCxDQUFaO0FBQ0Fxc0IsUUFBSTZrQixtQkFBbUJ0NEIsQ0FBbkIsRUFBc0IsQ0FBdEIsQ0FBSjtBQUNBdU0scUJBQWlCa0gsQ0FBakIsRUFBb0J6VCxDQUFwQixFQUF1QkEsQ0FBdkIsRUFBMEJ3TSxTQUExQixFQUFxQyxDQUFyQyxFQUF3QyxDQUF4QyxFQUEyQzlLLFVBQTNDLEVBQXVEdkIsVUFBVSxDQUFWLENBQXZEO0FBQ0EsV0FBT3NULENBQVA7QUFDRDtBQVR5QixDQUE1Qjs7QUFZQSxtQkFBQWp3QixDQUFRLHVEQUFSLEVBQWlDLFNBQWpDLEU7Ozs7Ozs7O0NDcEJBOztBQUNBLElBQUlpakIsVUFBVSxtQkFBQWpqQixDQUFRLDJDQUFSLENBQWQ7O0FBQ0EsSUFBSStvQixtQkFBbUIsbUJBQUEvb0IsQ0FBUSx1REFBUixDQUF2Qjs7QUFDQSxJQUFJb2MsV0FBVyxtQkFBQXBjLENBQVEsOENBQVIsQ0FBZjs7QUFDQSxJQUFJc2MsV0FBVyxtQkFBQXRjLENBQVEsOENBQVIsQ0FBZjs7QUFDQSxJQUFJZzFCLFlBQVksbUJBQUFoMUIsQ0FBUSwrQ0FBUixDQUFoQjs7QUFDQSxJQUFJODBDLHFCQUFxQixtQkFBQTkwQyxDQUFRLHlEQUFSLENBQXpCOztBQUVBaWpCLFFBQVFBLFFBQVFvRSxDQUFoQixFQUFtQixPQUFuQixFQUE0QjtBQUMxQjB0QixXQUFTLFNBQVNBLE9BQVQ7QUFBaUI7QUFBb0I7QUFDNUMsUUFBSUMsV0FBV3I0QixVQUFVLENBQVYsQ0FBZjtBQUNBLFFBQUlILElBQUlKLFNBQVMsSUFBVCxDQUFSO0FBQ0EsUUFBSTRNLFlBQVkxTSxTQUFTRSxFQUFFNVksTUFBWCxDQUFoQjtBQUNBLFFBQUlxc0IsSUFBSTZrQixtQkFBbUJ0NEIsQ0FBbkIsRUFBc0IsQ0FBdEIsQ0FBUjtBQUNBdU0scUJBQWlCa0gsQ0FBakIsRUFBb0J6VCxDQUFwQixFQUF1QkEsQ0FBdkIsRUFBMEJ3TSxTQUExQixFQUFxQyxDQUFyQyxFQUF3Q2dzQixhQUFhL3hDLFNBQWIsR0FBeUIsQ0FBekIsR0FBNkIreEIsVUFBVWdnQixRQUFWLENBQXJFO0FBQ0EsV0FBTy9rQixDQUFQO0FBQ0Q7QUFSeUIsQ0FBNUI7O0FBV0EsbUJBQUFqd0IsQ0FBUSx1REFBUixFQUFpQyxTQUFqQyxFOzs7Ozs7OztDQ25CQTs7QUFDQSxJQUFJaWpCLFVBQVUsbUJBQUFqakIsQ0FBUSwyQ0FBUixDQUFkOztBQUNBLElBQUlpMUMsWUFBWSxtQkFBQWoxQyxDQUFRLG1EQUFSLEVBQTZCLElBQTdCLENBQWhCOztBQUVBaWpCLFFBQVFBLFFBQVFvRSxDQUFoQixFQUFtQixPQUFuQixFQUE0QjtBQUMxQnNWLFlBQVUsU0FBU0EsUUFBVCxDQUFrQnRmO0FBQUc7QUFBckIsSUFBNEM7QUFDcEQsV0FBTzQzQixVQUFVLElBQVYsRUFBZ0I1M0IsRUFBaEIsRUFBb0JWLFVBQVUvWSxNQUFWLEdBQW1CLENBQW5CLEdBQXVCK1ksVUFBVSxDQUFWLENBQXZCLEdBQXNDMVosU0FBMUQsQ0FBUDtBQUNEO0FBSHlCLENBQTVCOztBQU1BLG1CQUFBakQsQ0FBUSx1REFBUixFQUFpQyxVQUFqQyxFOzs7Ozs7O0FDWEE7QUFDQSxJQUFJaWpCLFVBQVUsbUJBQUFqakIsQ0FBUSwyQ0FBUixDQUFkOztBQUNBLElBQUkrb0MsWUFBWSxtQkFBQS9vQyxDQUFRLDhDQUFSLEdBQWhCOztBQUNBLElBQUl3YixVQUFVLG1CQUFBeGIsQ0FBUSwyQ0FBUixFQUFxQndiLE9BQW5DOztBQUNBLElBQUlxVCxTQUFTLG1CQUFBN3VCLENBQVEsd0NBQVIsRUFBa0J3YixPQUFsQixLQUE4QixTQUEzQztBQUVBeUgsUUFBUUEsUUFBUXNCLENBQWhCLEVBQW1CO0FBQ2pCMndCLFFBQU0sU0FBU0EsSUFBVCxDQUFjeDFCLEVBQWQsRUFBa0I7QUFDdEIsUUFBSXVQLFNBQVNKLFVBQVVyVCxRQUFReVQsTUFBL0I7QUFDQThaLGNBQVU5WixTQUFTQSxPQUFPeFAsSUFBUCxDQUFZQyxFQUFaLENBQVQsR0FBMkJBLEVBQXJDO0FBQ0Q7QUFKZ0IsQ0FBbkIsRTs7Ozs7OztBQ05BO0FBQ0EsSUFBSXVELFVBQVUsbUJBQUFqakIsQ0FBUSwyQ0FBUixDQUFkOztBQUNBLElBQUk0YixNQUFNLG1CQUFBNWIsQ0FBUSx3Q0FBUixDQUFWOztBQUVBaWpCLFFBQVFBLFFBQVFrRSxDQUFoQixFQUFtQixPQUFuQixFQUE0QjtBQUMxQmd1QixXQUFTLFNBQVNBLE9BQVQsQ0FBaUJ0ekMsRUFBakIsRUFBcUI7QUFDNUIsV0FBTytaLElBQUkvWixFQUFKLE1BQVksT0FBbkI7QUFDRDtBQUh5QixDQUE1QixFOzs7Ozs7O0FDSkE7QUFDQSxJQUFJb2hCLFVBQVUsbUJBQUFqakIsQ0FBUSwyQ0FBUixDQUFkOztBQUVBaWpCLFFBQVFBLFFBQVFzQixDQUFoQixFQUFtQjtBQUFFdGtCLFVBQVEsbUJBQUFELENBQVEsMkNBQVI7QUFBVixDQUFuQixFOzs7Ozs7O0FDSEE7QUFDQSxtQkFBQUEsQ0FBUSx3REFBUixFQUFrQyxLQUFsQyxFOzs7Ozs7O0FDREE7QUFDQSxtQkFBQUEsQ0FBUSxzREFBUixFQUFnQyxLQUFoQyxFOzs7Ozs7O0FDREE7QUFDQSxJQUFJaWpCLFVBQVUsbUJBQUFqakIsQ0FBUSwyQ0FBUixDQUFkOztBQUVBaWpCLFFBQVFBLFFBQVFvRSxDQUFSLEdBQVlwRSxRQUFRMkUsQ0FBNUIsRUFBK0IsS0FBL0IsRUFBc0M7QUFBRS9RLFVBQVEsbUJBQUE3VyxDQUFRLHVEQUFSLEVBQWlDLEtBQWpDO0FBQVYsQ0FBdEMsRTs7Ozs7OztBQ0hBO0FBQ0EsSUFBSWlqQixVQUFVLG1CQUFBampCLENBQVEsMkNBQVIsQ0FBZDs7QUFFQWlqQixRQUFRQSxRQUFRa0UsQ0FBaEIsRUFBbUIsTUFBbkIsRUFBMkI7QUFDekJpdUIsU0FBTyxTQUFTQSxLQUFULENBQWVqeEMsQ0FBZixFQUFrQmt4QyxLQUFsQixFQUF5QkMsS0FBekIsRUFBZ0M7QUFDckMsV0FBTy90QyxLQUFLd0IsR0FBTCxDQUFTdXNDLEtBQVQsRUFBZ0IvdEMsS0FBS3lCLEdBQUwsQ0FBU3FzQyxLQUFULEVBQWdCbHhDLENBQWhCLENBQWhCLENBQVA7QUFDRDtBQUh3QixDQUEzQixFOzs7Ozs7O0FDSEE7QUFDQSxJQUFJOGUsVUFBVSxtQkFBQWpqQixDQUFRLDJDQUFSLENBQWQ7O0FBRUFpakIsUUFBUUEsUUFBUWtFLENBQWhCLEVBQW1CLE1BQW5CLEVBQTJCO0FBQUVvdUIsZUFBYWh1QyxLQUFLRSxFQUFMLEdBQVU7QUFBekIsQ0FBM0IsRTs7Ozs7OztBQ0hBO0FBQ0EsSUFBSXdiLFVBQVUsbUJBQUFqakIsQ0FBUSwyQ0FBUixDQUFkOztBQUNBLElBQUl3MUMsY0FBYyxNQUFNanVDLEtBQUtFLEVBQTdCO0FBRUF3YixRQUFRQSxRQUFRa0UsQ0FBaEIsRUFBbUIsTUFBbkIsRUFBMkI7QUFDekJzdUIsV0FBUyxTQUFTQSxPQUFULENBQWlCQyxPQUFqQixFQUEwQjtBQUNqQyxXQUFPQSxVQUFVRixXQUFqQjtBQUNEO0FBSHdCLENBQTNCLEU7Ozs7Ozs7QUNKQTtBQUNBLElBQUl2eUIsVUFBVSxtQkFBQWpqQixDQUFRLDJDQUFSLENBQWQ7O0FBQ0EsSUFBSWlZLFFBQVEsbUJBQUFqWSxDQUFRLCtDQUFSLENBQVo7O0FBQ0EsSUFBSTBzQixTQUFTLG1CQUFBMXNCLENBQVEsZ0RBQVIsQ0FBYjs7QUFFQWlqQixRQUFRQSxRQUFRa0UsQ0FBaEIsRUFBbUIsTUFBbkIsRUFBMkI7QUFDekJ3dUIsVUFBUSxTQUFTQSxNQUFULENBQWdCeHhDLENBQWhCLEVBQW1CNm9CLEtBQW5CLEVBQTBCQyxNQUExQixFQUFrQ0MsTUFBbEMsRUFBMENDLE9BQTFDLEVBQW1EO0FBQ3pELFdBQU9ULE9BQU96VSxNQUFNOVQsQ0FBTixFQUFTNm9CLEtBQVQsRUFBZ0JDLE1BQWhCLEVBQXdCQyxNQUF4QixFQUFnQ0MsT0FBaEMsQ0FBUCxDQUFQO0FBQ0Q7QUFId0IsQ0FBM0IsRTs7Ozs7OztBQ0xBO0FBQ0EsSUFBSWxLLFVBQVUsbUJBQUFqakIsQ0FBUSwyQ0FBUixDQUFkOztBQUVBaWpCLFFBQVFBLFFBQVFrRSxDQUFoQixFQUFtQixNQUFuQixFQUEyQjtBQUN6Qnl1QixTQUFPLFNBQVNBLEtBQVQsQ0FBZUMsRUFBZixFQUFtQnBuQyxFQUFuQixFQUF1QnFuQyxFQUF2QixFQUEyQnBuQyxFQUEzQixFQUErQjtBQUNwQyxRQUFJcW5DLE1BQU1GLE9BQU8sQ0FBakI7QUFDQSxRQUFJRyxNQUFNdm5DLE9BQU8sQ0FBakI7QUFDQSxRQUFJd25DLE1BQU1ILE9BQU8sQ0FBakI7QUFDQSxXQUFPRSxPQUFPdG5DLE9BQU8sQ0FBZCxLQUFvQixDQUFDcW5DLE1BQU1FLEdBQU4sR0FBWSxDQUFDRixNQUFNRSxHQUFQLElBQWMsRUFBRUYsTUFBTUUsR0FBTixLQUFjLENBQWhCLENBQTNCLE1BQW1ELEVBQXZFLElBQTZFLENBQXBGO0FBQ0Q7QUFOd0IsQ0FBM0IsRTs7Ozs7OztBQ0hBO0FBQ0EsSUFBSWh6QixVQUFVLG1CQUFBampCLENBQVEsMkNBQVIsQ0FBZDs7QUFFQWlqQixRQUFRQSxRQUFRa0UsQ0FBaEIsRUFBbUIsTUFBbkIsRUFBMkI7QUFDekIrdUIsU0FBTyxTQUFTQSxLQUFULENBQWVDLENBQWYsRUFBa0J2b0MsQ0FBbEIsRUFBcUI7QUFDMUIsUUFBSSszQixTQUFTLE1BQWI7QUFDQSxRQUFJeVEsS0FBSyxDQUFDRCxDQUFWO0FBQ0EsUUFBSUUsS0FBSyxDQUFDem9DLENBQVY7QUFDQSxRQUFJMG9DLEtBQUtGLEtBQUt6USxNQUFkO0FBQ0EsUUFBSTRRLEtBQUtGLEtBQUsxUSxNQUFkO0FBQ0EsUUFBSXgyQixLQUFLaW5DLE1BQU0sRUFBZjtBQUNBLFFBQUk5b0MsS0FBSytvQyxNQUFNLEVBQWY7QUFDQSxRQUFJMU8sSUFBSSxDQUFDeDRCLEtBQUtvbkMsRUFBTCxLQUFZLENBQWIsS0FBbUJELEtBQUtDLEVBQUwsS0FBWSxFQUEvQixDQUFSO0FBQ0EsV0FBT3BuQyxLQUFLN0IsRUFBTCxJQUFXcTZCLEtBQUssRUFBaEIsS0FBdUIsQ0FBQzJPLEtBQUtocEMsRUFBTCxLQUFZLENBQWIsS0FBbUJxNkIsSUFBSWhDLE1BQXZCLEtBQWtDLEVBQXpELENBQVA7QUFDRDtBQVh3QixDQUEzQixFOzs7Ozs7O0FDSEE7QUFDQSxJQUFJMWlCLFVBQVUsbUJBQUFqakIsQ0FBUSwyQ0FBUixDQUFkOztBQUVBaWpCLFFBQVFBLFFBQVFrRSxDQUFoQixFQUFtQixNQUFuQixFQUEyQjtBQUN6QnF2QixTQUFPLFNBQVNBLEtBQVQsQ0FBZVgsRUFBZixFQUFtQnBuQyxFQUFuQixFQUF1QnFuQyxFQUF2QixFQUEyQnBuQyxFQUEzQixFQUErQjtBQUNwQyxRQUFJcW5DLE1BQU1GLE9BQU8sQ0FBakI7QUFDQSxRQUFJRyxNQUFNdm5DLE9BQU8sQ0FBakI7QUFDQSxRQUFJd25DLE1BQU1ILE9BQU8sQ0FBakI7QUFDQSxXQUFPRSxPQUFPdG5DLE9BQU8sQ0FBZCxLQUFvQixDQUFDLENBQUNxbkMsR0FBRCxHQUFPRSxHQUFQLEdBQWEsRUFBRUYsTUFBTUUsR0FBUixJQUFlRixNQUFNRSxHQUFOLEtBQWMsQ0FBM0MsTUFBa0QsRUFBdEUsSUFBNEUsQ0FBbkY7QUFDRDtBQU53QixDQUEzQixFOzs7Ozs7O0FDSEE7QUFDQSxJQUFJaHpCLFVBQVUsbUJBQUFqakIsQ0FBUSwyQ0FBUixDQUFkOztBQUVBaWpCLFFBQVFBLFFBQVFrRSxDQUFoQixFQUFtQixNQUFuQixFQUEyQjtBQUFFcXVCLGVBQWEsTUFBTWp1QyxLQUFLRTtBQUExQixDQUEzQixFOzs7Ozs7O0FDSEE7QUFDQSxJQUFJd2IsVUFBVSxtQkFBQWpqQixDQUFRLDJDQUFSLENBQWQ7O0FBQ0EsSUFBSXUxQyxjQUFjaHVDLEtBQUtFLEVBQUwsR0FBVSxHQUE1QjtBQUVBd2IsUUFBUUEsUUFBUWtFLENBQWhCLEVBQW1CLE1BQW5CLEVBQTJCO0FBQ3pCdXVCLFdBQVMsU0FBU0EsT0FBVCxDQUFpQkQsT0FBakIsRUFBMEI7QUFDakMsV0FBT0EsVUFBVUYsV0FBakI7QUFDRDtBQUh3QixDQUEzQixFOzs7Ozs7O0FDSkE7QUFDQSxJQUFJdHlCLFVBQVUsbUJBQUFqakIsQ0FBUSwyQ0FBUixDQUFkOztBQUVBaWpCLFFBQVFBLFFBQVFrRSxDQUFoQixFQUFtQixNQUFuQixFQUEyQjtBQUFFbFAsU0FBTyxtQkFBQWpZLENBQVEsK0NBQVI7QUFBVCxDQUEzQixFOzs7Ozs7O0FDSEE7QUFDQSxJQUFJaWpCLFVBQVUsbUJBQUFqakIsQ0FBUSwyQ0FBUixDQUFkOztBQUVBaWpCLFFBQVFBLFFBQVFrRSxDQUFoQixFQUFtQixNQUFuQixFQUEyQjtBQUFFc3ZCLFdBQVMsU0FBU0EsT0FBVCxDQUFpQnR5QyxDQUFqQixFQUFvQjtBQUN4RDtBQUNBLFdBQU8sQ0FBQ0EsSUFBSSxDQUFDQSxDQUFOLEtBQVlBLENBQVosR0FBZ0JBLENBQWhCLEdBQW9CQSxLQUFLLENBQUwsR0FBUyxJQUFJQSxDQUFKLElBQVMwb0IsUUFBbEIsR0FBNkIxb0IsSUFBSSxDQUE1RDtBQUNEO0FBSDBCLENBQTNCLEU7Ozs7Ozs7QUNIQTtBQUNBLElBQUk4ZSxVQUFVLG1CQUFBampCLENBQVEsMkNBQVIsQ0FBZDs7QUFFQWlqQixRQUFRQSxRQUFRa0UsQ0FBaEIsRUFBbUIsTUFBbkIsRUFBMkI7QUFDekJ1dkIsU0FBTyxTQUFTQSxLQUFULENBQWVQLENBQWYsRUFBa0J2b0MsQ0FBbEIsRUFBcUI7QUFDMUIsUUFBSSszQixTQUFTLE1BQWI7QUFDQSxRQUFJeVEsS0FBSyxDQUFDRCxDQUFWO0FBQ0EsUUFBSUUsS0FBSyxDQUFDem9DLENBQVY7QUFDQSxRQUFJMG9DLEtBQUtGLEtBQUt6USxNQUFkO0FBQ0EsUUFBSTRRLEtBQUtGLEtBQUsxUSxNQUFkO0FBQ0EsUUFBSXgyQixLQUFLaW5DLE9BQU8sRUFBaEI7QUFDQSxRQUFJOW9DLEtBQUsrb0MsT0FBTyxFQUFoQjtBQUNBLFFBQUkxTyxJQUFJLENBQUN4NEIsS0FBS29uQyxFQUFMLEtBQVksQ0FBYixLQUFtQkQsS0FBS0MsRUFBTCxLQUFZLEVBQS9CLENBQVI7QUFDQSxXQUFPcG5DLEtBQUs3QixFQUFMLElBQVdxNkIsTUFBTSxFQUFqQixLQUF3QixDQUFDMk8sS0FBS2hwQyxFQUFMLEtBQVksQ0FBYixLQUFtQnE2QixJQUFJaEMsTUFBdkIsTUFBbUMsRUFBM0QsQ0FBUDtBQUNEO0FBWHdCLENBQTNCLEU7Ozs7Ozs7O0FDSEE7O0FBQ0EsSUFBSTFpQixVQUFVLG1CQUFBampCLENBQVEsMkNBQVIsQ0FBZDs7QUFDQSxJQUFJb2MsV0FBVyxtQkFBQXBjLENBQVEsOENBQVIsQ0FBZjs7QUFDQSxJQUFJd2UsWUFBWSxtQkFBQXhlLENBQVEsK0NBQVIsQ0FBaEI7O0FBQ0EsSUFBSTRrQixrQkFBa0IsbUJBQUE1a0IsQ0FBUSw4Q0FBUixDQUF0QixDLENBRUE7OztBQUNBLG1CQUFBQSxDQUFRLGdEQUFSLEtBQTZCaWpCLFFBQVFBLFFBQVFvRSxDQUFSLEdBQVksbUJBQUFybkIsQ0FBUSxzREFBUixDQUFwQixFQUFxRCxRQUFyRCxFQUErRDtBQUMxRjIyQyxvQkFBa0IsU0FBU0EsZ0JBQVQsQ0FBMEJ0dkIsQ0FBMUIsRUFBNkIrVyxNQUE3QixFQUFxQztBQUNyRHhaLG9CQUFnQnZHLENBQWhCLENBQWtCakMsU0FBUyxJQUFULENBQWxCLEVBQWtDaUwsQ0FBbEMsRUFBcUM7QUFBRXhGLFdBQUtyRCxVQUFVNGYsTUFBVixDQUFQO0FBQTBCM0ssa0JBQVksSUFBdEM7QUFBNENDLG9CQUFjO0FBQTFELEtBQXJDO0FBQ0Q7QUFIeUYsQ0FBL0QsQ0FBN0IsQzs7Ozs7Ozs7QUNQQTs7QUFDQSxJQUFJelEsVUFBVSxtQkFBQWpqQixDQUFRLDJDQUFSLENBQWQ7O0FBQ0EsSUFBSW9jLFdBQVcsbUJBQUFwYyxDQUFRLDhDQUFSLENBQWY7O0FBQ0EsSUFBSXdlLFlBQVksbUJBQUF4ZSxDQUFRLCtDQUFSLENBQWhCOztBQUNBLElBQUk0a0Isa0JBQWtCLG1CQUFBNWtCLENBQVEsOENBQVIsQ0FBdEIsQyxDQUVBOzs7QUFDQSxtQkFBQUEsQ0FBUSxnREFBUixLQUE2QmlqQixRQUFRQSxRQUFRb0UsQ0FBUixHQUFZLG1CQUFBcm5CLENBQVEsc0RBQVIsQ0FBcEIsRUFBcUQsUUFBckQsRUFBK0Q7QUFDMUYweEIsb0JBQWtCLFNBQVNBLGdCQUFULENBQTBCckssQ0FBMUIsRUFBNkJpWCxNQUE3QixFQUFxQztBQUNyRDFaLG9CQUFnQnZHLENBQWhCLENBQWtCakMsU0FBUyxJQUFULENBQWxCLEVBQWtDaUwsQ0FBbEMsRUFBcUM7QUFBRXZFLFdBQUt0RSxVQUFVOGYsTUFBVixDQUFQO0FBQTBCN0ssa0JBQVksSUFBdEM7QUFBNENDLG9CQUFjO0FBQTFELEtBQXJDO0FBQ0Q7QUFIeUYsQ0FBL0QsQ0FBN0IsQzs7Ozs7OztBQ1BBO0FBQ0EsSUFBSXpRLFVBQVUsbUJBQUFqakIsQ0FBUSwyQ0FBUixDQUFkOztBQUNBLElBQUkyckIsV0FBVyxtQkFBQTNyQixDQUFRLG9EQUFSLEVBQThCLElBQTlCLENBQWY7O0FBRUFpakIsUUFBUUEsUUFBUWtFLENBQWhCLEVBQW1CLFFBQW5CLEVBQTZCO0FBQzNCcEQsV0FBUyxTQUFTQSxPQUFULENBQWlCbGlCLEVBQWpCLEVBQXFCO0FBQzVCLFdBQU84cEIsU0FBUzlwQixFQUFULENBQVA7QUFDRDtBQUgwQixDQUE3QixFOzs7Ozs7O0FDSkE7QUFDQSxJQUFJb2hCLFVBQVUsbUJBQUFqakIsQ0FBUSwyQ0FBUixDQUFkOztBQUNBLElBQUl5eUIsVUFBVSxtQkFBQXp5QixDQUFRLDZDQUFSLENBQWQ7O0FBQ0EsSUFBSWtkLFlBQVksbUJBQUFsZCxDQUFRLCtDQUFSLENBQWhCOztBQUNBLElBQUkyeEIsT0FBTyxtQkFBQTN4QixDQUFRLGdEQUFSLENBQVg7O0FBQ0EsSUFBSW1qQyxpQkFBaUIsbUJBQUFuakMsQ0FBUSxvREFBUixDQUFyQjs7QUFFQWlqQixRQUFRQSxRQUFRa0UsQ0FBaEIsRUFBbUIsUUFBbkIsRUFBNkI7QUFDM0J5dkIsNkJBQTJCLFNBQVNBLHlCQUFULENBQW1DOXhCLE1BQW5DLEVBQTJDO0FBQ3BFLFFBQUl0SSxJQUFJVSxVQUFVNEgsTUFBVixDQUFSO0FBQ0EsUUFBSSt4QixVQUFVbGxCLEtBQUt0VCxDQUFuQjtBQUNBLFFBQUlyZCxPQUFPeXhCLFFBQVFqVyxDQUFSLENBQVg7QUFDQSxRQUFJbFcsU0FBUyxFQUFiO0FBQ0EsUUFBSWxGLElBQUksQ0FBUjtBQUNBLFFBQUlJLEdBQUosRUFBU204QixJQUFUOztBQUNBLFdBQU8zOEIsS0FBSzRDLE1BQUwsR0FBY3hDLENBQXJCLEVBQXdCO0FBQ3RCdThCLGFBQU9rWixRQUFRcjZCLENBQVIsRUFBV2hiLE1BQU1SLEtBQUtJLEdBQUwsQ0FBakIsQ0FBUDtBQUNBLFVBQUl1OEIsU0FBUzE2QixTQUFiLEVBQXdCa2dDLGVBQWU3OEIsTUFBZixFQUF1QjlFLEdBQXZCLEVBQTRCbThCLElBQTVCO0FBQ3pCOztBQUNELFdBQU9yM0IsTUFBUDtBQUNEO0FBYjBCLENBQTdCLEU7Ozs7Ozs7O0FDUEE7O0FBQ0EsSUFBSTJjLFVBQVUsbUJBQUFqakIsQ0FBUSwyQ0FBUixDQUFkOztBQUNBLElBQUlvYyxXQUFXLG1CQUFBcGMsQ0FBUSw4Q0FBUixDQUFmOztBQUNBLElBQUltbUIsY0FBYyxtQkFBQW5tQixDQUFRLGlEQUFSLENBQWxCOztBQUNBLElBQUk2cUIsaUJBQWlCLG1CQUFBN3FCLENBQVEsK0NBQVIsQ0FBckI7O0FBQ0EsSUFBSTR4QiwyQkFBMkIsbUJBQUE1eEIsQ0FBUSxnREFBUixFQUEwQnFlLENBQXpELEMsQ0FFQTs7O0FBQ0EsbUJBQUFyZSxDQUFRLGdEQUFSLEtBQTZCaWpCLFFBQVFBLFFBQVFvRSxDQUFSLEdBQVksbUJBQUFybkIsQ0FBUSxzREFBUixDQUFwQixFQUFxRCxRQUFyRCxFQUErRDtBQUMxRjgyQyxvQkFBa0IsU0FBU0EsZ0JBQVQsQ0FBMEJ6dkIsQ0FBMUIsRUFBNkI7QUFDN0MsUUFBSTdLLElBQUlKLFNBQVMsSUFBVCxDQUFSO0FBQ0EsUUFBSStULElBQUloSyxZQUFZa0IsQ0FBWixFQUFlLElBQWYsQ0FBUjtBQUNBLFFBQUl5TixDQUFKOztBQUNBLE9BQUc7QUFDRCxVQUFJQSxJQUFJbEQseUJBQXlCcFYsQ0FBekIsRUFBNEIyVCxDQUE1QixDQUFSLEVBQXdDLE9BQU8yRSxFQUFFalQsR0FBVDtBQUN6QyxLQUZELFFBRVNyRixJQUFJcU8sZUFBZXJPLENBQWYsQ0FGYjtBQUdEO0FBUnlGLENBQS9ELENBQTdCLEM7Ozs7Ozs7O0FDUkE7O0FBQ0EsSUFBSXlHLFVBQVUsbUJBQUFqakIsQ0FBUSwyQ0FBUixDQUFkOztBQUNBLElBQUlvYyxXQUFXLG1CQUFBcGMsQ0FBUSw4Q0FBUixDQUFmOztBQUNBLElBQUltbUIsY0FBYyxtQkFBQW5tQixDQUFRLGlEQUFSLENBQWxCOztBQUNBLElBQUk2cUIsaUJBQWlCLG1CQUFBN3FCLENBQVEsK0NBQVIsQ0FBckI7O0FBQ0EsSUFBSTR4QiwyQkFBMkIsbUJBQUE1eEIsQ0FBUSxnREFBUixFQUEwQnFlLENBQXpELEMsQ0FFQTs7O0FBQ0EsbUJBQUFyZSxDQUFRLGdEQUFSLEtBQTZCaWpCLFFBQVFBLFFBQVFvRSxDQUFSLEdBQVksbUJBQUFybkIsQ0FBUSxzREFBUixDQUFwQixFQUFxRCxRQUFyRCxFQUErRDtBQUMxRisyQyxvQkFBa0IsU0FBU0EsZ0JBQVQsQ0FBMEIxdkIsQ0FBMUIsRUFBNkI7QUFDN0MsUUFBSTdLLElBQUlKLFNBQVMsSUFBVCxDQUFSO0FBQ0EsUUFBSStULElBQUloSyxZQUFZa0IsQ0FBWixFQUFlLElBQWYsQ0FBUjtBQUNBLFFBQUl5TixDQUFKOztBQUNBLE9BQUc7QUFDRCxVQUFJQSxJQUFJbEQseUJBQXlCcFYsQ0FBekIsRUFBNEIyVCxDQUE1QixDQUFSLEVBQXdDLE9BQU8yRSxFQUFFaFMsR0FBVDtBQUN6QyxLQUZELFFBRVN0RyxJQUFJcU8sZUFBZXJPLENBQWYsQ0FGYjtBQUdEO0FBUnlGLENBQS9ELENBQTdCLEM7Ozs7Ozs7QUNSQTtBQUNBLElBQUl5RyxVQUFVLG1CQUFBampCLENBQVEsMkNBQVIsQ0FBZDs7QUFDQSxJQUFJZzNDLFVBQVUsbUJBQUFoM0MsQ0FBUSxvREFBUixFQUE4QixLQUE5QixDQUFkOztBQUVBaWpCLFFBQVFBLFFBQVFrRSxDQUFoQixFQUFtQixRQUFuQixFQUE2QjtBQUMzQmxtQixVQUFRLFNBQVNBLE1BQVQsQ0FBZ0JZLEVBQWhCLEVBQW9CO0FBQzFCLFdBQU9tMUMsUUFBUW4xQyxFQUFSLENBQVA7QUFDRDtBQUgwQixDQUE3QixFOzs7Ozs7OztDQ0hBOztBQUNBLElBQUlvaEIsVUFBVSxtQkFBQWpqQixDQUFRLDJDQUFSLENBQWQ7O0FBQ0EsSUFBSUMsU0FBUyxtQkFBQUQsQ0FBUSwyQ0FBUixDQUFiOztBQUNBLElBQUl5a0IsT0FBTyxtQkFBQXprQixDQUFRLHlDQUFSLENBQVg7O0FBQ0EsSUFBSStvQyxZQUFZLG1CQUFBL29DLENBQVEsOENBQVIsR0FBaEI7O0FBQ0EsSUFBSWkzQyxhQUFhLG1CQUFBajNDLENBQVEsd0NBQVIsRUFBa0IsWUFBbEIsQ0FBakI7O0FBQ0EsSUFBSXdlLFlBQVksbUJBQUF4ZSxDQUFRLCtDQUFSLENBQWhCOztBQUNBLElBQUlxaUIsV0FBVyxtQkFBQXJpQixDQUFRLDhDQUFSLENBQWY7O0FBQ0EsSUFBSXdnQixhQUFhLG1CQUFBeGdCLENBQVEsZ0RBQVIsQ0FBakI7O0FBQ0EsSUFBSXVnQixjQUFjLG1CQUFBdmdCLENBQVEsaURBQVIsQ0FBbEI7O0FBQ0EsSUFBSTZtQixPQUFPLG1CQUFBN21CLENBQVEseUNBQVIsQ0FBWDs7QUFDQSxJQUFJK2MsUUFBUSxtQkFBQS9jLENBQVEsMkNBQVIsQ0FBWjs7QUFDQSxJQUFJMHBCLFNBQVMzTSxNQUFNMk0sTUFBbkI7O0FBRUEsSUFBSTRCLFlBQVksU0FBWkEsU0FBWSxDQUFVNUwsRUFBVixFQUFjO0FBQzVCLFNBQU9BLE1BQU0sSUFBTixHQUFhemMsU0FBYixHQUF5QnViLFVBQVVrQixFQUFWLENBQWhDO0FBQ0QsQ0FGRDs7QUFJQSxJQUFJdzNCLHNCQUFzQixTQUF0QkEsbUJBQXNCLENBQVVDLFlBQVYsRUFBd0I7QUFDaEQsTUFBSUMsVUFBVUQsYUFBYW5OLEVBQTNCOztBQUNBLE1BQUlvTixPQUFKLEVBQWE7QUFDWEQsaUJBQWFuTixFQUFiLEdBQWtCL21DLFNBQWxCO0FBQ0FtMEM7QUFDRDtBQUNGLENBTkQ7O0FBUUEsSUFBSUMscUJBQXFCLFNBQXJCQSxrQkFBcUIsQ0FBVUYsWUFBVixFQUF3QjtBQUMvQyxTQUFPQSxhQUFhRyxFQUFiLEtBQW9CcjBDLFNBQTNCO0FBQ0QsQ0FGRDs7QUFJQSxJQUFJczBDLG9CQUFvQixTQUFwQkEsaUJBQW9CLENBQVVKLFlBQVYsRUFBd0I7QUFDOUMsTUFBSSxDQUFDRSxtQkFBbUJGLFlBQW5CLENBQUwsRUFBdUM7QUFDckNBLGlCQUFhRyxFQUFiLEdBQWtCcjBDLFNBQWxCO0FBQ0FpMEMsd0JBQW9CQyxZQUFwQjtBQUNEO0FBQ0YsQ0FMRDs7QUFPQSxJQUFJSyxlQUFlLFNBQWZBLFlBQWUsQ0FBVUMsUUFBVixFQUFvQkMsVUFBcEIsRUFBZ0M7QUFDakRyMUIsV0FBU28xQixRQUFUO0FBQ0EsT0FBS3pOLEVBQUwsR0FBVS9tQyxTQUFWO0FBQ0EsT0FBS3EwQyxFQUFMLEdBQVVHLFFBQVY7QUFDQUEsYUFBVyxJQUFJRSxvQkFBSixDQUF5QixJQUF6QixDQUFYOztBQUNBLE1BQUk7QUFDRixRQUFJUCxVQUFVTSxXQUFXRCxRQUFYLENBQWQ7QUFDQSxRQUFJTixlQUFlQyxPQUFuQjs7QUFDQSxRQUFJQSxXQUFXLElBQWYsRUFBcUI7QUFDbkIsVUFBSSxPQUFPQSxRQUFRUSxXQUFmLEtBQStCLFVBQW5DLEVBQStDUixVQUFVLG1CQUFZO0FBQUVELHFCQUFhUyxXQUFiO0FBQTZCLE9BQXJELENBQS9DLEtBQ0twNUIsVUFBVTQ0QixPQUFWO0FBQ0wsV0FBS3BOLEVBQUwsR0FBVW9OLE9BQVY7QUFDRDtBQUNGLEdBUkQsQ0FRRSxPQUFPbjNCLENBQVAsRUFBVTtBQUNWdzNCLGFBQVN6TSxLQUFULENBQWUvcUIsQ0FBZjtBQUNBO0FBQ0Q7O0FBQUMsTUFBSW8zQixtQkFBbUIsSUFBbkIsQ0FBSixFQUE4Qkgsb0JBQW9CLElBQXBCO0FBQ2pDLENBakJEOztBQW1CQU0sYUFBYXg3QixTQUFiLEdBQXlCdUUsWUFBWSxFQUFaLEVBQWdCO0FBQ3ZDcTNCLGVBQWEsU0FBU0EsV0FBVCxHQUF1QjtBQUFFTCxzQkFBa0IsSUFBbEI7QUFBMEI7QUFEekIsQ0FBaEIsQ0FBekI7O0FBSUEsSUFBSUksdUJBQXVCLFNBQXZCQSxvQkFBdUIsQ0FBVVIsWUFBVixFQUF3QjtBQUNqRCxPQUFLaE4sRUFBTCxHQUFVZ04sWUFBVjtBQUNELENBRkQ7O0FBSUFRLHFCQUFxQjM3QixTQUFyQixHQUFpQ3VFLFlBQVksRUFBWixFQUFnQjtBQUMvQzdjLFFBQU0sU0FBU0EsSUFBVCxDQUFjbkQsS0FBZCxFQUFxQjtBQUN6QixRQUFJNDJDLGVBQWUsS0FBS2hOLEVBQXhCOztBQUNBLFFBQUksQ0FBQ2tOLG1CQUFtQkYsWUFBbkIsQ0FBTCxFQUF1QztBQUNyQyxVQUFJTSxXQUFXTixhQUFhRyxFQUE1Qjs7QUFDQSxVQUFJO0FBQ0YsWUFBSTN4QixJQUFJMkYsVUFBVW1zQixTQUFTL3pDLElBQW5CLENBQVI7QUFDQSxZQUFJaWlCLENBQUosRUFBTyxPQUFPQSxFQUFFL0YsSUFBRixDQUFPNjNCLFFBQVAsRUFBaUJsM0MsS0FBakIsQ0FBUDtBQUNSLE9BSEQsQ0FHRSxPQUFPMGYsQ0FBUCxFQUFVO0FBQ1YsWUFBSTtBQUNGczNCLDRCQUFrQkosWUFBbEI7QUFDRCxTQUZELFNBRVU7QUFDUixnQkFBTWwzQixDQUFOO0FBQ0Q7QUFDRjtBQUNGO0FBQ0YsR0FoQjhDO0FBaUIvQytxQixTQUFPLFNBQVNBLEtBQVQsQ0FBZXpxQyxLQUFmLEVBQXNCO0FBQzNCLFFBQUk0MkMsZUFBZSxLQUFLaE4sRUFBeEI7QUFDQSxRQUFJa04sbUJBQW1CRixZQUFuQixDQUFKLEVBQXNDLE1BQU01MkMsS0FBTjtBQUN0QyxRQUFJazNDLFdBQVdOLGFBQWFHLEVBQTVCO0FBQ0FILGlCQUFhRyxFQUFiLEdBQWtCcjBDLFNBQWxCOztBQUNBLFFBQUk7QUFDRixVQUFJMGlCLElBQUkyRixVQUFVbXNCLFNBQVN6TSxLQUFuQixDQUFSO0FBQ0EsVUFBSSxDQUFDcmxCLENBQUwsRUFBUSxNQUFNcGxCLEtBQU47QUFDUkEsY0FBUW9sQixFQUFFL0YsSUFBRixDQUFPNjNCLFFBQVAsRUFBaUJsM0MsS0FBakIsQ0FBUjtBQUNELEtBSkQsQ0FJRSxPQUFPMGYsQ0FBUCxFQUFVO0FBQ1YsVUFBSTtBQUNGaTNCLDRCQUFvQkMsWUFBcEI7QUFDRCxPQUZELFNBRVU7QUFDUixjQUFNbDNCLENBQU47QUFDRDtBQUNGOztBQUFDaTNCLHdCQUFvQkMsWUFBcEI7QUFDRixXQUFPNTJDLEtBQVA7QUFDRCxHQWxDOEM7QUFtQy9DczNDLFlBQVUsU0FBU0EsUUFBVCxDQUFrQnQzQyxLQUFsQixFQUF5QjtBQUNqQyxRQUFJNDJDLGVBQWUsS0FBS2hOLEVBQXhCOztBQUNBLFFBQUksQ0FBQ2tOLG1CQUFtQkYsWUFBbkIsQ0FBTCxFQUF1QztBQUNyQyxVQUFJTSxXQUFXTixhQUFhRyxFQUE1QjtBQUNBSCxtQkFBYUcsRUFBYixHQUFrQnIwQyxTQUFsQjs7QUFDQSxVQUFJO0FBQ0YsWUFBSTBpQixJQUFJMkYsVUFBVW1zQixTQUFTSSxRQUFuQixDQUFSO0FBQ0F0M0MsZ0JBQVFvbEIsSUFBSUEsRUFBRS9GLElBQUYsQ0FBTzYzQixRQUFQLEVBQWlCbDNDLEtBQWpCLENBQUosR0FBOEIwQyxTQUF0QztBQUNELE9BSEQsQ0FHRSxPQUFPZ2QsQ0FBUCxFQUFVO0FBQ1YsWUFBSTtBQUNGaTNCLDhCQUFvQkMsWUFBcEI7QUFDRCxTQUZELFNBRVU7QUFDUixnQkFBTWwzQixDQUFOO0FBQ0Q7QUFDRjs7QUFBQ2kzQiwwQkFBb0JDLFlBQXBCO0FBQ0YsYUFBTzUyQyxLQUFQO0FBQ0Q7QUFDRjtBQXBEOEMsQ0FBaEIsQ0FBakM7O0FBdURBLElBQUl1M0MsY0FBYyxTQUFTQyxVQUFULENBQW9CTCxVQUFwQixFQUFnQztBQUNoRGwzQixhQUFXLElBQVgsRUFBaUJzM0IsV0FBakIsRUFBOEIsWUFBOUIsRUFBNEMsSUFBNUMsRUFBa0QzMkIsRUFBbEQsR0FBdUQzQyxVQUFVazVCLFVBQVYsQ0FBdkQ7QUFDRCxDQUZEOztBQUlBbjNCLFlBQVl1M0IsWUFBWTk3QixTQUF4QixFQUFtQztBQUNqQ2c4QixhQUFXLFNBQVNBLFNBQVQsQ0FBbUJQLFFBQW5CLEVBQTZCO0FBQ3RDLFdBQU8sSUFBSUQsWUFBSixDQUFpQkMsUUFBakIsRUFBMkIsS0FBS3QyQixFQUFoQyxDQUFQO0FBQ0QsR0FIZ0M7QUFJakM1SSxXQUFTLFNBQVNBLE9BQVQsQ0FBaUJtSCxFQUFqQixFQUFxQjtBQUM1QixRQUFJdkIsT0FBTyxJQUFYO0FBQ0EsV0FBTyxLQUFLc0csS0FBSzNmLE9BQUwsSUFBZ0I3RSxPQUFPNkUsT0FBNUIsRUFBcUMsVUFBVUMsT0FBVixFQUFtQjJCLE1BQW5CLEVBQTJCO0FBQ3JFOFgsZ0JBQVVrQixFQUFWO0FBQ0EsVUFBSXkzQixlQUFlaDVCLEtBQUs2NUIsU0FBTCxDQUFlO0FBQ2hDdDBDLGNBQU0sY0FBVW5ELEtBQVYsRUFBaUI7QUFDckIsY0FBSTtBQUNGLG1CQUFPbWYsR0FBR25mLEtBQUgsQ0FBUDtBQUNELFdBRkQsQ0FFRSxPQUFPMGYsQ0FBUCxFQUFVO0FBQ1Z2WixtQkFBT3VaLENBQVA7QUFDQWszQix5QkFBYVMsV0FBYjtBQUNEO0FBQ0YsU0FSK0I7QUFTaEM1TSxlQUFPdGtDLE1BVHlCO0FBVWhDbXhDLGtCQUFVOXlDO0FBVnNCLE9BQWYsQ0FBbkI7QUFZRCxLQWRNLENBQVA7QUFlRDtBQXJCZ0MsQ0FBbkM7QUF3QkF3YixZQUFZdTNCLFdBQVosRUFBeUI7QUFDdkJsMUMsUUFBTSxTQUFTQSxJQUFULENBQWN1QixDQUFkLEVBQWlCO0FBQ3JCLFFBQUkwYSxJQUFJLE9BQU8sSUFBUCxLQUFnQixVQUFoQixHQUE2QixJQUE3QixHQUFvQ2k1QixXQUE1QztBQUNBLFFBQUkvaUIsU0FBU3pKLFVBQVVqSixTQUFTbGUsQ0FBVCxFQUFZOHlDLFVBQVosQ0FBVixDQUFiOztBQUNBLFFBQUlsaUIsTUFBSixFQUFZO0FBQ1YsVUFBSWtqQixhQUFhNTFCLFNBQVMwUyxPQUFPblYsSUFBUCxDQUFZemIsQ0FBWixDQUFULENBQWpCO0FBQ0EsYUFBTzh6QyxXQUFXbjVCLFdBQVgsS0FBMkJELENBQTNCLEdBQStCbzVCLFVBQS9CLEdBQTRDLElBQUlwNUIsQ0FBSixDQUFNLFVBQVU0NEIsUUFBVixFQUFvQjtBQUMzRSxlQUFPUSxXQUFXRCxTQUFYLENBQXFCUCxRQUFyQixDQUFQO0FBQ0QsT0FGa0QsQ0FBbkQ7QUFHRDs7QUFDRCxXQUFPLElBQUk1NEIsQ0FBSixDQUFNLFVBQVU0NEIsUUFBVixFQUFvQjtBQUMvQixVQUFJNXRCLE9BQU8sS0FBWDtBQUNBa2YsZ0JBQVUsWUFBWTtBQUNwQixZQUFJLENBQUNsZixJQUFMLEVBQVc7QUFDVCxjQUFJO0FBQ0YsZ0JBQUk5TSxNQUFNNVksQ0FBTixFQUFTLEtBQVQsRUFBZ0IsVUFBVXRDLEVBQVYsRUFBYztBQUNoQzQxQyx1QkFBUy96QyxJQUFULENBQWM3QixFQUFkO0FBQ0Esa0JBQUlnb0IsSUFBSixFQUFVLE9BQU9ILE1BQVA7QUFDWCxhQUhHLE1BR0dBLE1BSFAsRUFHZTtBQUNoQixXQUxELENBS0UsT0FBT3pKLENBQVAsRUFBVTtBQUNWLGdCQUFJNEosSUFBSixFQUFVLE1BQU01SixDQUFOO0FBQ1Z3M0IscUJBQVN6TSxLQUFULENBQWUvcUIsQ0FBZjtBQUNBO0FBQ0Q7O0FBQUN3M0IsbUJBQVNJLFFBQVQ7QUFDSDtBQUNGLE9BYkQ7QUFjQSxhQUFPLFlBQVk7QUFBRWh1QixlQUFPLElBQVA7QUFBYyxPQUFuQztBQUNELEtBakJNLENBQVA7QUFrQkQsR0E1QnNCO0FBNkJ2QnlLLE1BQUksU0FBU0EsRUFBVCxHQUFjO0FBQ2hCLFNBQUssSUFBSWx6QixJQUFJLENBQVIsRUFBV3VLLElBQUlnUixVQUFVL1ksTUFBekIsRUFBaUNzMEMsUUFBUXYxQyxNQUFNZ0osQ0FBTixDQUE5QyxFQUF3RHZLLElBQUl1SyxDQUE1RDtBQUFnRXVzQyxZQUFNOTJDLENBQU4sSUFBV3ViLFVBQVV2YixHQUFWLENBQVg7QUFBaEU7O0FBQ0EsV0FBTyxLQUFLLE9BQU8sSUFBUCxLQUFnQixVQUFoQixHQUE2QixJQUE3QixHQUFvQzAyQyxXQUF6QyxFQUFzRCxVQUFVTCxRQUFWLEVBQW9CO0FBQy9FLFVBQUk1dEIsT0FBTyxLQUFYO0FBQ0FrZixnQkFBVSxZQUFZO0FBQ3BCLFlBQUksQ0FBQ2xmLElBQUwsRUFBVztBQUNULGVBQUssSUFBSXVHLElBQUksQ0FBYixFQUFnQkEsSUFBSThuQixNQUFNdDBDLE1BQTFCLEVBQWtDLEVBQUV3c0IsQ0FBcEMsRUFBdUM7QUFDckNxbkIscUJBQVMvekMsSUFBVCxDQUFjdzBDLE1BQU05bkIsQ0FBTixDQUFkO0FBQ0EsZ0JBQUl2RyxJQUFKLEVBQVU7QUFDWDs7QUFBQzR0QixtQkFBU0ksUUFBVDtBQUNIO0FBQ0YsT0FQRDtBQVFBLGFBQU8sWUFBWTtBQUFFaHVCLGVBQU8sSUFBUDtBQUFjLE9BQW5DO0FBQ0QsS0FYTSxDQUFQO0FBWUQ7QUEzQ3NCLENBQXpCO0FBOENBaEQsS0FBS2l4QixZQUFZOTdCLFNBQWpCLEVBQTRCaTdCLFVBQTVCLEVBQXdDLFlBQVk7QUFBRSxTQUFPLElBQVA7QUFBYyxDQUFwRTtBQUVBaDBCLFFBQVFBLFFBQVFzQixDQUFoQixFQUFtQjtBQUFFd3pCLGNBQVlEO0FBQWQsQ0FBbkI7O0FBRUEsbUJBQUE5M0MsQ0FBUSxnREFBUixFQUEwQixZQUExQixFOzs7Ozs7OztBQ3RNQTtBQUNBOztBQUNBLElBQUlpakIsVUFBVSxtQkFBQWpqQixDQUFRLDJDQUFSLENBQWQ7O0FBQ0EsSUFBSXlrQixPQUFPLG1CQUFBemtCLENBQVEseUNBQVIsQ0FBWDs7QUFDQSxJQUFJQyxTQUFTLG1CQUFBRCxDQUFRLDJDQUFSLENBQWI7O0FBQ0EsSUFBSStlLHFCQUFxQixtQkFBQS9lLENBQVEsd0RBQVIsQ0FBekI7O0FBQ0EsSUFBSWtwQyxpQkFBaUIsbUJBQUFscEMsQ0FBUSxvREFBUixDQUFyQjs7QUFFQWlqQixRQUFRQSxRQUFRb0UsQ0FBUixHQUFZcEUsUUFBUTJFLENBQTVCLEVBQStCLFNBQS9CLEVBQTBDO0FBQUUsYUFBVyxrQkFBVXV3QixTQUFWLEVBQXFCO0FBQzFFLFFBQUl0NUIsSUFBSUUsbUJBQW1CLElBQW5CLEVBQXlCMEYsS0FBSzNmLE9BQUwsSUFBZ0I3RSxPQUFPNkUsT0FBaEQsQ0FBUjtBQUNBLFFBQUltdkIsYUFBYSxPQUFPa2tCLFNBQVAsSUFBb0IsVUFBckM7QUFDQSxXQUFPLEtBQUt4b0IsSUFBTCxDQUNMc0UsYUFBYSxVQUFVOXZCLENBQVYsRUFBYTtBQUN4QixhQUFPK2tDLGVBQWVycUIsQ0FBZixFQUFrQnM1QixXQUFsQixFQUErQnhvQixJQUEvQixDQUFvQyxZQUFZO0FBQUUsZUFBT3hyQixDQUFQO0FBQVcsT0FBN0QsQ0FBUDtBQUNELEtBRkQsR0FFSWcwQyxTQUhDLEVBSUxsa0IsYUFBYSxVQUFVaFUsQ0FBVixFQUFhO0FBQ3hCLGFBQU9pcEIsZUFBZXJxQixDQUFmLEVBQWtCczVCLFdBQWxCLEVBQStCeG9CLElBQS9CLENBQW9DLFlBQVk7QUFBRSxjQUFNMVAsQ0FBTjtBQUFVLE9BQTVELENBQVA7QUFDRCxLQUZELEdBRUlrNEIsU0FOQyxDQUFQO0FBUUQ7QUFYeUMsQ0FBMUMsRTs7Ozs7Ozs7Q0NQQTs7QUFDQSxJQUFJbDFCLFVBQVUsbUJBQUFqakIsQ0FBUSwyQ0FBUixDQUFkOztBQUNBLElBQUlzekIsdUJBQXVCLG1CQUFBdHpCLENBQVEsMkRBQVIsQ0FBM0I7O0FBQ0EsSUFBSWlwQyxVQUFVLG1CQUFBanBDLENBQVEsNENBQVIsQ0FBZDs7QUFFQWlqQixRQUFRQSxRQUFRa0UsQ0FBaEIsRUFBbUIsU0FBbkIsRUFBOEI7QUFBRSxTQUFPLGNBQVVqSixVQUFWLEVBQXNCO0FBQzNELFFBQUlxVixvQkFBb0JELHFCQUFxQmpWLENBQXJCLENBQXVCLElBQXZCLENBQXhCO0FBQ0EsUUFBSS9YLFNBQVMyaUMsUUFBUS9xQixVQUFSLENBQWI7QUFDQSxLQUFDNVgsT0FBTzJaLENBQVAsR0FBV3NULGtCQUFrQjdzQixNQUE3QixHQUFzQzZzQixrQkFBa0J4dUIsT0FBekQsRUFBa0V1QixPQUFPc0gsQ0FBekU7QUFDQSxXQUFPMmxCLGtCQUFrQjdELE9BQXpCO0FBQ0Q7QUFMNkIsQ0FBOUIsRTs7Ozs7OztBQ05BLElBQUkwb0IsV0FBVyxtQkFBQXA0QyxDQUFRLDZDQUFSLENBQWY7O0FBQ0EsSUFBSXFpQixXQUFXLG1CQUFBcmlCLENBQVEsOENBQVIsQ0FBZjs7QUFDQSxJQUFJd3VCLFlBQVk0cEIsU0FBUzUyQyxHQUF6QjtBQUNBLElBQUk2c0IsNEJBQTRCK3BCLFNBQVN0MUIsR0FBekM7QUFFQXMxQixTQUFTMXdCLEdBQVQsQ0FBYTtBQUFFMndCLGtCQUFnQixTQUFTQSxjQUFULENBQXdCQyxXQUF4QixFQUFxQ0MsYUFBckMsRUFBb0RqZ0MsTUFBcEQsRUFBNER3VixTQUE1RCxFQUF1RTtBQUNwR08sOEJBQTBCaXFCLFdBQTFCLEVBQXVDQyxhQUF2QyxFQUFzRGwyQixTQUFTL0osTUFBVCxDQUF0RCxFQUF3RWtXLFVBQVVWLFNBQVYsQ0FBeEU7QUFDRDtBQUZZLENBQWIsRTs7Ozs7OztBQ0xBLElBQUlzcUIsV0FBVyxtQkFBQXA0QyxDQUFRLDZDQUFSLENBQWY7O0FBQ0EsSUFBSXFpQixXQUFXLG1CQUFBcmlCLENBQVEsOENBQVIsQ0FBZjs7QUFDQSxJQUFJd3VCLFlBQVk0cEIsU0FBUzUyQyxHQUF6QjtBQUNBLElBQUlxc0IseUJBQXlCdXFCLFNBQVNyMkMsR0FBdEM7QUFDQSxJQUFJOGdCLFFBQVF1MUIsU0FBU3YxQixLQUFyQjtBQUVBdTFCLFNBQVMxd0IsR0FBVCxDQUFhO0FBQUU4d0Isa0JBQWdCLFNBQVNBLGNBQVQsQ0FBd0JGLFdBQXhCLEVBQXFDaGdDO0FBQU87QUFBNUMsSUFBK0Q7QUFDNUYsUUFBSXdWLFlBQVluUixVQUFVL1ksTUFBVixHQUFtQixDQUFuQixHQUF1QlgsU0FBdkIsR0FBbUN1ckIsVUFBVTdSLFVBQVUsQ0FBVixDQUFWLENBQW5EO0FBQ0EsUUFBSXdSLGNBQWNOLHVCQUF1QnhMLFNBQVMvSixNQUFULENBQXZCLEVBQXlDd1YsU0FBekMsRUFBb0QsS0FBcEQsQ0FBbEI7QUFDQSxRQUFJSyxnQkFBZ0JsckIsU0FBaEIsSUFBNkIsQ0FBQ2tyQixZQUFZLFFBQVosRUFBc0JtcUIsV0FBdEIsQ0FBbEMsRUFBc0UsT0FBTyxLQUFQO0FBQ3RFLFFBQUlucUIsWUFBWWhXLElBQWhCLEVBQXNCLE9BQU8sSUFBUDtBQUN0QixRQUFJNFYsaUJBQWlCbEwsTUFBTWhCLEdBQU4sQ0FBVXZKLE1BQVYsQ0FBckI7QUFDQXlWLG1CQUFlLFFBQWYsRUFBeUJELFNBQXpCO0FBQ0EsV0FBTyxDQUFDLENBQUNDLGVBQWU1VixJQUFqQixJQUF5QjBLLE1BQU0sUUFBTixFQUFnQnZLLE1BQWhCLENBQWhDO0FBQ0Q7QUFSWSxDQUFiLEU7Ozs7Ozs7QUNOQSxJQUFJdFUsTUFBTSxtQkFBQWhFLENBQVEsMkNBQVIsQ0FBVjs7QUFDQSxJQUFJNEMsT0FBTyxtQkFBQTVDLENBQVEsd0RBQVIsQ0FBWDs7QUFDQSxJQUFJbzRDLFdBQVcsbUJBQUFwNEMsQ0FBUSw2Q0FBUixDQUFmOztBQUNBLElBQUlxaUIsV0FBVyxtQkFBQXJpQixDQUFRLDhDQUFSLENBQWY7O0FBQ0EsSUFBSTZxQixpQkFBaUIsbUJBQUE3cUIsQ0FBUSwrQ0FBUixDQUFyQjs7QUFDQSxJQUFJdXVCLDBCQUEwQjZwQixTQUFTcDNDLElBQXZDO0FBQ0EsSUFBSXd0QixZQUFZNHBCLFNBQVM1MkMsR0FBekI7O0FBRUEsSUFBSWkzQyx1QkFBdUIsU0FBdkJBLG9CQUF1QixDQUFVajhCLENBQVYsRUFBYTZLLENBQWIsRUFBZ0I7QUFDekMsTUFBSXF4QixRQUFRbnFCLHdCQUF3Qi9SLENBQXhCLEVBQTJCNkssQ0FBM0IsQ0FBWjtBQUNBLE1BQUkySCxTQUFTbkUsZUFBZXJPLENBQWYsQ0FBYjtBQUNBLE1BQUl3UyxXQUFXLElBQWYsRUFBcUIsT0FBTzBwQixLQUFQO0FBQ3JCLE1BQUlDLFFBQVFGLHFCQUFxQnpwQixNQUFyQixFQUE2QjNILENBQTdCLENBQVo7QUFDQSxTQUFPc3hCLE1BQU0vMEMsTUFBTixHQUFlODBDLE1BQU05MEMsTUFBTixHQUFlaEIsS0FBSyxJQUFJb0IsR0FBSixDQUFRMDBDLE1BQU0zM0MsTUFBTixDQUFhNDNDLEtBQWIsQ0FBUixDQUFMLENBQWYsR0FBb0RBLEtBQW5FLEdBQTJFRCxLQUFsRjtBQUNELENBTkQ7O0FBUUFOLFNBQVMxd0IsR0FBVCxDQUFhO0FBQUVreEIsbUJBQWlCLFNBQVNBLGVBQVQsQ0FBeUJ0Z0M7QUFBTztBQUFoQyxJQUFtRDtBQUNqRixXQUFPbWdDLHFCQUFxQnAyQixTQUFTL0osTUFBVCxDQUFyQixFQUF1Q3FFLFVBQVUvWSxNQUFWLEdBQW1CLENBQW5CLEdBQXVCWCxTQUF2QixHQUFtQ3VyQixVQUFVN1IsVUFBVSxDQUFWLENBQVYsQ0FBMUUsQ0FBUDtBQUNEO0FBRlksQ0FBYixFOzs7Ozs7O0FDaEJBLElBQUl5N0IsV0FBVyxtQkFBQXA0QyxDQUFRLDZDQUFSLENBQWY7O0FBQ0EsSUFBSXFpQixXQUFXLG1CQUFBcmlCLENBQVEsOENBQVIsQ0FBZjs7QUFDQSxJQUFJNnFCLGlCQUFpQixtQkFBQTdxQixDQUFRLCtDQUFSLENBQXJCOztBQUNBLElBQUlpdUIseUJBQXlCbXFCLFNBQVNuMEMsR0FBdEM7QUFDQSxJQUFJbXFCLHlCQUF5QmdxQixTQUFTdjJCLEdBQXRDO0FBQ0EsSUFBSTJNLFlBQVk0cEIsU0FBUzUyQyxHQUF6Qjs7QUFFQSxJQUFJcTNDLHNCQUFzQixTQUF0QkEsbUJBQXNCLENBQVUzcUIsV0FBVixFQUF1QjFSLENBQXZCLEVBQTBCNkssQ0FBMUIsRUFBNkI7QUFDckQsTUFBSXl4QixTQUFTN3FCLHVCQUF1QkMsV0FBdkIsRUFBb0MxUixDQUFwQyxFQUF1QzZLLENBQXZDLENBQWI7QUFDQSxNQUFJeXhCLE1BQUosRUFBWSxPQUFPMXFCLHVCQUF1QkYsV0FBdkIsRUFBb0MxUixDQUFwQyxFQUF1QzZLLENBQXZDLENBQVA7QUFDWixNQUFJMkgsU0FBU25FLGVBQWVyTyxDQUFmLENBQWI7QUFDQSxTQUFPd1MsV0FBVyxJQUFYLEdBQWtCNnBCLG9CQUFvQjNxQixXQUFwQixFQUFpQ2MsTUFBakMsRUFBeUMzSCxDQUF6QyxDQUFsQixHQUFnRXBrQixTQUF2RTtBQUNELENBTEQ7O0FBT0FtMUMsU0FBUzF3QixHQUFULENBQWE7QUFBRXF4QixlQUFhLFNBQVNBLFdBQVQsQ0FBcUJULFdBQXJCLEVBQWtDaGdDO0FBQU87QUFBekMsSUFBNEQ7QUFDdEYsV0FBT3VnQyxvQkFBb0JQLFdBQXBCLEVBQWlDajJCLFNBQVMvSixNQUFULENBQWpDLEVBQW1EcUUsVUFBVS9ZLE1BQVYsR0FBbUIsQ0FBbkIsR0FBdUJYLFNBQXZCLEdBQW1DdXJCLFVBQVU3UixVQUFVLENBQVYsQ0FBVixDQUF0RixDQUFQO0FBQ0Q7QUFGWSxDQUFiLEU7Ozs7Ozs7QUNkQSxJQUFJeTdCLFdBQVcsbUJBQUFwNEMsQ0FBUSw2Q0FBUixDQUFmOztBQUNBLElBQUlxaUIsV0FBVyxtQkFBQXJpQixDQUFRLDhDQUFSLENBQWY7O0FBQ0EsSUFBSXV1QiwwQkFBMEI2cEIsU0FBU3AzQyxJQUF2QztBQUNBLElBQUl3dEIsWUFBWTRwQixTQUFTNTJDLEdBQXpCO0FBRUE0MkMsU0FBUzF3QixHQUFULENBQWE7QUFBRXN4QixzQkFBb0IsU0FBU0Esa0JBQVQsQ0FBNEIxZ0M7QUFBTztBQUFuQyxJQUFzRDtBQUN2RixXQUFPaVcsd0JBQXdCbE0sU0FBUy9KLE1BQVQsQ0FBeEIsRUFBMENxRSxVQUFVL1ksTUFBVixHQUFtQixDQUFuQixHQUF1QlgsU0FBdkIsR0FBbUN1ckIsVUFBVTdSLFVBQVUsQ0FBVixDQUFWLENBQTdFLENBQVA7QUFDRDtBQUZZLENBQWIsRTs7Ozs7OztBQ0xBLElBQUl5N0IsV0FBVyxtQkFBQXA0QyxDQUFRLDZDQUFSLENBQWY7O0FBQ0EsSUFBSXFpQixXQUFXLG1CQUFBcmlCLENBQVEsOENBQVIsQ0FBZjs7QUFDQSxJQUFJb3VCLHlCQUF5QmdxQixTQUFTdjJCLEdBQXRDO0FBQ0EsSUFBSTJNLFlBQVk0cEIsU0FBUzUyQyxHQUF6QjtBQUVBNDJDLFNBQVMxd0IsR0FBVCxDQUFhO0FBQUV1eEIsa0JBQWdCLFNBQVNBLGNBQVQsQ0FBd0JYLFdBQXhCLEVBQXFDaGdDO0FBQU87QUFBNUMsSUFBK0Q7QUFDNUYsV0FBTzhWLHVCQUF1QmtxQixXQUF2QixFQUFvQ2oyQixTQUFTL0osTUFBVCxDQUFwQyxFQUNIcUUsVUFBVS9ZLE1BQVYsR0FBbUIsQ0FBbkIsR0FBdUJYLFNBQXZCLEdBQW1DdXJCLFVBQVU3UixVQUFVLENBQVYsQ0FBVixDQURoQyxDQUFQO0FBRUQ7QUFIWSxDQUFiLEU7Ozs7Ozs7QUNMQSxJQUFJeTdCLFdBQVcsbUJBQUFwNEMsQ0FBUSw2Q0FBUixDQUFmOztBQUNBLElBQUlxaUIsV0FBVyxtQkFBQXJpQixDQUFRLDhDQUFSLENBQWY7O0FBQ0EsSUFBSTZxQixpQkFBaUIsbUJBQUE3cUIsQ0FBUSwrQ0FBUixDQUFyQjs7QUFDQSxJQUFJaXVCLHlCQUF5Qm1xQixTQUFTbjBDLEdBQXRDO0FBQ0EsSUFBSXVxQixZQUFZNHBCLFNBQVM1MkMsR0FBekI7O0FBRUEsSUFBSTAzQyxzQkFBc0IsU0FBdEJBLG1CQUFzQixDQUFVaHJCLFdBQVYsRUFBdUIxUixDQUF2QixFQUEwQjZLLENBQTFCLEVBQTZCO0FBQ3JELE1BQUl5eEIsU0FBUzdxQix1QkFBdUJDLFdBQXZCLEVBQW9DMVIsQ0FBcEMsRUFBdUM2SyxDQUF2QyxDQUFiO0FBQ0EsTUFBSXl4QixNQUFKLEVBQVksT0FBTyxJQUFQO0FBQ1osTUFBSTlwQixTQUFTbkUsZUFBZXJPLENBQWYsQ0FBYjtBQUNBLFNBQU93UyxXQUFXLElBQVgsR0FBa0JrcUIsb0JBQW9CaHJCLFdBQXBCLEVBQWlDYyxNQUFqQyxFQUF5QzNILENBQXpDLENBQWxCLEdBQWdFLEtBQXZFO0FBQ0QsQ0FMRDs7QUFPQSt3QixTQUFTMXdCLEdBQVQsQ0FBYTtBQUFFeXhCLGVBQWEsU0FBU0EsV0FBVCxDQUFxQmIsV0FBckIsRUFBa0NoZ0M7QUFBTztBQUF6QyxJQUE0RDtBQUN0RixXQUFPNGdDLG9CQUFvQlosV0FBcEIsRUFBaUNqMkIsU0FBUy9KLE1BQVQsQ0FBakMsRUFBbURxRSxVQUFVL1ksTUFBVixHQUFtQixDQUFuQixHQUF1QlgsU0FBdkIsR0FBbUN1ckIsVUFBVTdSLFVBQVUsQ0FBVixDQUFWLENBQXRGLENBQVA7QUFDRDtBQUZZLENBQWIsRTs7Ozs7OztBQ2JBLElBQUl5N0IsV0FBVyxtQkFBQXA0QyxDQUFRLDZDQUFSLENBQWY7O0FBQ0EsSUFBSXFpQixXQUFXLG1CQUFBcmlCLENBQVEsOENBQVIsQ0FBZjs7QUFDQSxJQUFJaXVCLHlCQUF5Qm1xQixTQUFTbjBDLEdBQXRDO0FBQ0EsSUFBSXVxQixZQUFZNHBCLFNBQVM1MkMsR0FBekI7QUFFQTQyQyxTQUFTMXdCLEdBQVQsQ0FBYTtBQUFFMHhCLGtCQUFnQixTQUFTQSxjQUFULENBQXdCZCxXQUF4QixFQUFxQ2hnQztBQUFPO0FBQTVDLElBQStEO0FBQzVGLFdBQU8yVix1QkFBdUJxcUIsV0FBdkIsRUFBb0NqMkIsU0FBUy9KLE1BQVQsQ0FBcEMsRUFDSHFFLFVBQVUvWSxNQUFWLEdBQW1CLENBQW5CLEdBQXVCWCxTQUF2QixHQUFtQ3VyQixVQUFVN1IsVUFBVSxDQUFWLENBQVYsQ0FEaEMsQ0FBUDtBQUVEO0FBSFksQ0FBYixFOzs7Ozs7O0FDTEEsSUFBSTA4QixZQUFZLG1CQUFBcjVDLENBQVEsNkNBQVIsQ0FBaEI7O0FBQ0EsSUFBSXFpQixXQUFXLG1CQUFBcmlCLENBQVEsOENBQVIsQ0FBZjs7QUFDQSxJQUFJd2UsWUFBWSxtQkFBQXhlLENBQVEsK0NBQVIsQ0FBaEI7O0FBQ0EsSUFBSXd1QixZQUFZNnFCLFVBQVU3M0MsR0FBMUI7QUFDQSxJQUFJNnNCLDRCQUE0QmdyQixVQUFVdjJCLEdBQTFDO0FBRUF1MkIsVUFBVTN4QixHQUFWLENBQWM7QUFBRTB3QixZQUFVLFNBQVNBLFFBQVQsQ0FBa0JFLFdBQWxCLEVBQStCQyxhQUEvQixFQUE4QztBQUN0RSxXQUFPLFNBQVNlLFNBQVQsQ0FBbUJoaEMsTUFBbkIsRUFBMkJ3VixTQUEzQixFQUFzQztBQUMzQ08sZ0NBQ0VpcUIsV0FERixFQUNlQyxhQURmLEVBRUUsQ0FBQ3pxQixjQUFjN3FCLFNBQWQsR0FBMEJvZixRQUExQixHQUFxQzdELFNBQXRDLEVBQWlEbEcsTUFBakQsQ0FGRixFQUdFa1csVUFBVVYsU0FBVixDQUhGO0FBS0QsS0FORDtBQU9EO0FBUmEsQ0FBZCxFOzs7Ozs7O0FDTkE7QUFDQSxtQkFBQTl0QixDQUFRLHdEQUFSLEVBQWtDLEtBQWxDLEU7Ozs7Ozs7QUNEQTtBQUNBLG1CQUFBQSxDQUFRLHNEQUFSLEVBQWdDLEtBQWhDLEU7Ozs7Ozs7QUNEQTtBQUNBLElBQUlpakIsVUFBVSxtQkFBQWpqQixDQUFRLDJDQUFSLENBQWQ7O0FBRUFpakIsUUFBUUEsUUFBUW9FLENBQVIsR0FBWXBFLFFBQVEyRSxDQUE1QixFQUErQixLQUEvQixFQUFzQztBQUFFL1EsVUFBUSxtQkFBQTdXLENBQVEsdURBQVIsRUFBaUMsS0FBakM7QUFBVixDQUF0QyxFOzs7Ozs7OztDQ0ZBOztBQUNBLElBQUlpakIsVUFBVSxtQkFBQWpqQixDQUFRLDJDQUFSLENBQWQ7O0FBQ0EsSUFBSTh2QyxNQUFNLG1CQUFBOXZDLENBQVEsOENBQVIsRUFBd0IsSUFBeEIsQ0FBVjs7QUFFQWlqQixRQUFRQSxRQUFRb0UsQ0FBaEIsRUFBbUIsUUFBbkIsRUFBNkI7QUFDM0JreUIsTUFBSSxTQUFTQSxFQUFULENBQVl0a0IsR0FBWixFQUFpQjtBQUNuQixXQUFPNmEsSUFBSSxJQUFKLEVBQVU3YSxHQUFWLENBQVA7QUFDRDtBQUgwQixDQUE3QixFOzs7Ozs7OztDQ0pBOztBQUNBLElBQUloUyxVQUFVLG1CQUFBampCLENBQVEsMkNBQVIsQ0FBZDs7QUFDQSxJQUFJZ29CLFVBQVUsbUJBQUFob0IsQ0FBUSw0Q0FBUixDQUFkOztBQUNBLElBQUlzYyxXQUFXLG1CQUFBdGMsQ0FBUSw4Q0FBUixDQUFmOztBQUNBLElBQUl1cUIsV0FBVyxtQkFBQXZxQixDQUFRLDhDQUFSLENBQWY7O0FBQ0EsSUFBSXc1QyxXQUFXLG1CQUFBeDVDLENBQVEsMENBQVIsQ0FBZjs7QUFDQSxJQUFJeTVDLGNBQWNseEIsT0FBT3ZNLFNBQXpCOztBQUVBLElBQUkwOUIsd0JBQXdCLFNBQXhCQSxxQkFBd0IsQ0FBVTFMLE1BQVYsRUFBa0J4bEIsTUFBbEIsRUFBMEI7QUFDcEQsT0FBS214QixFQUFMLEdBQVUzTCxNQUFWO0FBQ0EsT0FBSzdELEVBQUwsR0FBVTNoQixNQUFWO0FBQ0QsQ0FIRDs7QUFLQSxtQkFBQXhvQixDQUFRLGdEQUFSLEVBQTBCMDVDLHFCQUExQixFQUFpRCxlQUFqRCxFQUFrRSxTQUFTaDJDLElBQVQsR0FBZ0I7QUFDaEYsTUFBSTJnQyxRQUFRLEtBQUtzVixFQUFMLENBQVE1eEIsSUFBUixDQUFhLEtBQUtvaUIsRUFBbEIsQ0FBWjs7QUFDQSxTQUFPO0FBQUU1cEMsV0FBTzhqQyxLQUFUO0FBQWdCeGEsVUFBTXdhLFVBQVU7QUFBaEMsR0FBUDtBQUNELENBSEQ7O0FBS0FwaEIsUUFBUUEsUUFBUW9FLENBQWhCLEVBQW1CLFFBQW5CLEVBQTZCO0FBQzNCdXlCLFlBQVUsU0FBU0EsUUFBVCxDQUFrQjVMLE1BQWxCLEVBQTBCO0FBQ2xDaG1CLFlBQVEsSUFBUjtBQUNBLFFBQUksQ0FBQ3VDLFNBQVN5akIsTUFBVCxDQUFMLEVBQXVCLE1BQU1yeUIsVUFBVXF5QixTQUFTLG1CQUFuQixDQUFOO0FBQ3ZCLFFBQUk3bUIsSUFBSW1CLE9BQU8sSUFBUCxDQUFSO0FBQ0EsUUFBSXdsQixRQUFRLFdBQVcyTCxXQUFYLEdBQXlCbnhCLE9BQU8wbEIsT0FBT0YsS0FBZCxDQUF6QixHQUFnRDBMLFNBQVM1NUIsSUFBVCxDQUFjb3VCLE1BQWQsQ0FBNUQ7QUFDQSxRQUFJNkwsS0FBSyxJQUFJdHhCLE1BQUosQ0FBV3lsQixPQUFPam5CLE1BQWxCLEVBQTBCLENBQUMrbUIsTUFBTXJSLE9BQU4sQ0FBYyxHQUFkLENBQUQsR0FBc0JxUixLQUF0QixHQUE4QixNQUFNQSxLQUE5RCxDQUFUO0FBQ0ErTCxPQUFHdkssU0FBSCxHQUFlaHpCLFNBQVMweEIsT0FBT3NCLFNBQWhCLENBQWY7QUFDQSxXQUFPLElBQUlvSyxxQkFBSixDQUEwQkcsRUFBMUIsRUFBOEIxeUIsQ0FBOUIsQ0FBUDtBQUNEO0FBVDBCLENBQTdCLEU7Ozs7Ozs7O0NDbEJBOztBQUNBLElBQUlsRSxVQUFVLG1CQUFBampCLENBQVEsMkNBQVIsQ0FBZDs7QUFDQSxJQUFJODVDLE9BQU8sbUJBQUE5NUMsQ0FBUSwrQ0FBUixDQUFYOztBQUVBaWpCLFFBQVFBLFFBQVFvRSxDQUFoQixFQUFtQixRQUFuQixFQUE2QjtBQUMzQjB5QixVQUFRLFNBQVNBLE1BQVQsQ0FBZ0Jya0I7QUFBVTtBQUExQixJQUFvRDtBQUMxRCxXQUFPb2tCLEtBQUssSUFBTCxFQUFXcGtCLFNBQVgsRUFBc0IvWSxVQUFVL1ksTUFBVixHQUFtQixDQUFuQixHQUF1QitZLFVBQVUsQ0FBVixDQUF2QixHQUFzQzFaLFNBQTVELEVBQXVFLEtBQXZFLENBQVA7QUFDRDtBQUgwQixDQUE3QixFOzs7Ozs7OztDQ0pBOztBQUNBLElBQUlnZ0IsVUFBVSxtQkFBQWpqQixDQUFRLDJDQUFSLENBQWQ7O0FBQ0EsSUFBSTg1QyxPQUFPLG1CQUFBOTVDLENBQVEsK0NBQVIsQ0FBWDs7QUFFQWlqQixRQUFRQSxRQUFRb0UsQ0FBaEIsRUFBbUIsUUFBbkIsRUFBNkI7QUFDM0IyeUIsWUFBVSxTQUFTQSxRQUFULENBQWtCdGtCO0FBQVU7QUFBNUIsSUFBc0Q7QUFDOUQsV0FBT29rQixLQUFLLElBQUwsRUFBV3BrQixTQUFYLEVBQXNCL1ksVUFBVS9ZLE1BQVYsR0FBbUIsQ0FBbkIsR0FBdUIrWSxVQUFVLENBQVYsQ0FBdkIsR0FBc0MxWixTQUE1RCxFQUF1RSxJQUF2RSxDQUFQO0FBQ0Q7QUFIMEIsQ0FBN0IsRTs7Ozs7Ozs7Q0NKQTs7QUFDQSxtQkFBQWpELENBQVEsZ0RBQVIsRUFBMEIsVUFBMUIsRUFBc0MsVUFBVTR5QixLQUFWLEVBQWlCO0FBQ3JELFNBQU8sU0FBU3FuQixRQUFULEdBQW9CO0FBQ3pCLFdBQU9ybkIsTUFBTSxJQUFOLEVBQVksQ0FBWixDQUFQO0FBQ0QsR0FGRDtBQUdELENBSkQsRUFJRyxXQUpILEU7Ozs7Ozs7O0NDREE7O0FBQ0EsbUJBQUE1eUIsQ0FBUSxnREFBUixFQUEwQixXQUExQixFQUF1QyxVQUFVNHlCLEtBQVYsRUFBaUI7QUFDdEQsU0FBTyxTQUFTc25CLFNBQVQsR0FBcUI7QUFDMUIsV0FBT3RuQixNQUFNLElBQU4sRUFBWSxDQUFaLENBQVA7QUFDRCxHQUZEO0FBR0QsQ0FKRCxFQUlHLFNBSkgsRTs7Ozs7OztBQ0ZBLG1CQUFBNXlCLENBQVEsK0NBQVIsRUFBeUIsZUFBekIsRTs7Ozs7OztBQ0FBLG1CQUFBQSxDQUFRLCtDQUFSLEVBQXlCLFlBQXpCLEU7Ozs7Ozs7QUNBQTtBQUNBLElBQUlpakIsVUFBVSxtQkFBQWpqQixDQUFRLDJDQUFSLENBQWQ7O0FBRUFpakIsUUFBUUEsUUFBUWtFLENBQWhCLEVBQW1CLFFBQW5CLEVBQTZCO0FBQUVsbkIsVUFBUSxtQkFBQUQsQ0FBUSwyQ0FBUjtBQUFWLENBQTdCLEU7Ozs7Ozs7QUNIQTtBQUNBLG1CQUFBQSxDQUFRLHdEQUFSLEVBQWtDLFNBQWxDLEU7Ozs7Ozs7QUNEQTtBQUNBLG1CQUFBQSxDQUFRLHNEQUFSLEVBQWdDLFNBQWhDLEU7Ozs7Ozs7QUNEQTtBQUNBLG1CQUFBQSxDQUFRLHdEQUFSLEVBQWtDLFNBQWxDLEU7Ozs7Ozs7QUNEQTtBQUNBLG1CQUFBQSxDQUFRLHNEQUFSLEVBQWdDLFNBQWhDLEU7Ozs7Ozs7QUNEQSxJQUFJdTlCLGFBQWEsbUJBQUF2OUIsQ0FBUSxzREFBUixDQUFqQjs7QUFDQSxJQUFJdW1CLFVBQVUsbUJBQUF2bUIsQ0FBUSxnREFBUixDQUFkOztBQUNBLElBQUlrakIsV0FBVyxtQkFBQWxqQixDQUFRLDZDQUFSLENBQWY7O0FBQ0EsSUFBSUMsU0FBUyxtQkFBQUQsQ0FBUSwyQ0FBUixDQUFiOztBQUNBLElBQUk2bUIsT0FBTyxtQkFBQTdtQixDQUFRLHlDQUFSLENBQVg7O0FBQ0EsSUFBSW9xQixZQUFZLG1CQUFBcHFCLENBQVEsOENBQVIsQ0FBaEI7O0FBQ0EsSUFBSWlvQixNQUFNLG1CQUFBam9CLENBQVEsd0NBQVIsQ0FBVjs7QUFDQSxJQUFJaWQsV0FBV2dMLElBQUksVUFBSixDQUFmO0FBQ0EsSUFBSWt5QixnQkFBZ0JseUIsSUFBSSxhQUFKLENBQXBCO0FBQ0EsSUFBSW15QixjQUFjaHdCLFVBQVV6bkIsS0FBNUI7QUFFQSxJQUFJMDNDLGVBQWU7QUFDakJDLGVBQWEsSUFESTtBQUNFO0FBQ25CQyx1QkFBcUIsS0FGSjtBQUdqQkMsZ0JBQWMsS0FIRztBQUlqQkMsa0JBQWdCLEtBSkM7QUFLakJDLGVBQWEsS0FMSTtBQU1qQkMsaUJBQWUsS0FORTtBQU9qQkMsZ0JBQWMsSUFQRztBQVFqQkMsd0JBQXNCLEtBUkw7QUFTakJDLFlBQVUsS0FUTztBQVVqQkMscUJBQW1CLEtBVkY7QUFXakJDLGtCQUFnQixLQVhDO0FBWWpCQyxtQkFBaUIsS0FaQTtBQWFqQkMscUJBQW1CLEtBYkY7QUFjakJDLGFBQVcsSUFkTTtBQWNBO0FBQ2pCQyxpQkFBZSxLQWZFO0FBZ0JqQkMsZ0JBQWMsS0FoQkc7QUFpQmpCQyxZQUFVLElBakJPO0FBa0JqQkMsb0JBQWtCLEtBbEJEO0FBbUJqQkMsVUFBUSxLQW5CUztBQW9CakJDLGVBQWEsS0FwQkk7QUFxQmpCQyxpQkFBZSxLQXJCRTtBQXNCakJDLGlCQUFlLEtBdEJFO0FBdUJqQkMsa0JBQWdCLEtBdkJDO0FBd0JqQkMsZ0JBQWMsS0F4Qkc7QUF5QmpCQyxpQkFBZSxLQXpCRTtBQTBCakJDLG9CQUFrQixLQTFCRDtBQTJCakJDLG9CQUFrQixLQTNCRDtBQTRCakJDLGtCQUFnQixJQTVCQztBQTRCSztBQUN0QkMsb0JBQWtCLEtBN0JEO0FBOEJqQkMsaUJBQWUsS0E5QkU7QUErQmpCQyxhQUFXO0FBL0JNLENBQW5COztBQWtDQSxLQUFLLElBQUlDLGNBQWM5MUIsUUFBUTh6QixZQUFSLENBQWxCLEVBQXlDajVDLElBQUksQ0FBbEQsRUFBcURBLElBQUlpN0MsWUFBWXo0QyxNQUFyRSxFQUE2RXhDLEdBQTdFLEVBQWtGO0FBQ2hGLE1BQUltZ0IsT0FBTzg2QixZQUFZajdDLENBQVosQ0FBWDtBQUNBLE1BQUlrN0MsV0FBV2pDLGFBQWE5NEIsSUFBYixDQUFmO0FBQ0EsTUFBSWc3QixhQUFhdDhDLE9BQU9zaEIsSUFBUCxDQUFqQjtBQUNBLE1BQUlxQyxRQUFRMjRCLGNBQWNBLFdBQVd2Z0MsU0FBckM7QUFDQSxNQUFJeGEsR0FBSjs7QUFDQSxNQUFJb2lCLEtBQUosRUFBVztBQUNULFFBQUksQ0FBQ0EsTUFBTTNHLFFBQU4sQ0FBTCxFQUFzQjRKLEtBQUtqRCxLQUFMLEVBQVkzRyxRQUFaLEVBQXNCbTlCLFdBQXRCO0FBQ3RCLFFBQUksQ0FBQ3gyQixNQUFNdTJCLGFBQU4sQ0FBTCxFQUEyQnR6QixLQUFLakQsS0FBTCxFQUFZdTJCLGFBQVosRUFBMkI1NEIsSUFBM0I7QUFDM0I2SSxjQUFVN0ksSUFBVixJQUFrQjY0QixXQUFsQjtBQUNBLFFBQUlrQyxRQUFKLEVBQWMsS0FBSzk2QyxHQUFMLElBQVkrN0IsVUFBWjtBQUF3QixVQUFJLENBQUMzWixNQUFNcGlCLEdBQU4sQ0FBTCxFQUFpQjBoQixTQUFTVSxLQUFULEVBQWdCcGlCLEdBQWhCLEVBQXFCKzdCLFdBQVcvN0IsR0FBWCxDQUFyQixFQUFzQyxJQUF0QztBQUF6QztBQUNmO0FBQ0YsQzs7Ozs7OztBQ3pERCxJQUFJeWhCLFVBQVUsbUJBQUFqakIsQ0FBUSwyQ0FBUixDQUFkOztBQUNBLElBQUl3OEMsUUFBUSxtQkFBQXg4QyxDQUFRLHlDQUFSLENBQVo7O0FBQ0FpakIsUUFBUUEsUUFBUXNCLENBQVIsR0FBWXRCLFFBQVE5QyxDQUE1QixFQUErQjtBQUM3QjBXLGdCQUFjMmxCLE1BQU0xNUIsR0FEUztBQUU3QmlVLGtCQUFnQnlsQixNQUFNL2hDO0FBRk8sQ0FBL0IsRTs7Ozs7OztBQ0ZBO0FBQ0EsSUFBSXhhLFNBQVMsbUJBQUFELENBQVEsMkNBQVIsQ0FBYjs7QUFDQSxJQUFJaWpCLFVBQVUsbUJBQUFqakIsQ0FBUSwyQ0FBUixDQUFkOztBQUNBLElBQUl5OEMsWUFBWXg4QyxPQUFPdzhDLFNBQXZCO0FBQ0EsSUFBSXY5QixRQUFRLEdBQUdBLEtBQWY7QUFDQSxJQUFJdzlCLE9BQU8sQ0FBQyxDQUFDRCxTQUFGLElBQWUsV0FBV3BwQixJQUFYLENBQWdCb3BCLFVBQVVFLFNBQTFCLENBQTFCLEMsQ0FBZ0U7O0FBQ2hFLElBQUlsSyxPQUFPLFNBQVBBLElBQU8sQ0FBVTN2QixHQUFWLEVBQWU7QUFDeEIsU0FBTyxVQUFVcEQsRUFBVixFQUFjazlCO0FBQUs7QUFBbkIsSUFBb0M7QUFDekMsUUFBSUMsWUFBWWxnQyxVQUFVL1ksTUFBVixHQUFtQixDQUFuQztBQUNBLFFBQUkwYixPQUFPdTlCLFlBQVkzOUIsTUFBTVUsSUFBTixDQUFXakQsU0FBWCxFQUFzQixDQUF0QixDQUFaLEdBQXVDLEtBQWxEO0FBQ0EsV0FBT21HLElBQUkrNUIsWUFBWSxZQUFZO0FBQ2pDO0FBQ0EsT0FBQyxPQUFPbjlCLEVBQVAsSUFBYSxVQUFiLEdBQTBCQSxFQUExQixHQUErQkgsU0FBU0csRUFBVCxDQUFoQyxFQUE4Q3FGLEtBQTlDLENBQW9ELElBQXBELEVBQTBEekYsSUFBMUQ7QUFDRCxLQUhVLEdBR1BJLEVBSEcsRUFHQ2s5QixJQUhELENBQVA7QUFJRCxHQVBEO0FBUUQsQ0FURDs7QUFVQTM1QixRQUFRQSxRQUFRc0IsQ0FBUixHQUFZdEIsUUFBUTlDLENBQXBCLEdBQXdCOEMsUUFBUTVELENBQVIsR0FBWXE5QixJQUE1QyxFQUFrRDtBQUNoRHZrQixjQUFZc2EsS0FBS3h5QyxPQUFPazRCLFVBQVosQ0FEb0M7QUFFaEQya0IsZUFBYXJLLEtBQUt4eUMsT0FBTzY4QyxXQUFaO0FBRm1DLENBQWxELEU7Ozs7Ozs7QUNoQkEsbUJBQUE5OEMsQ0FBUSw4Q0FBUjs7QUFDQSxtQkFBQUEsQ0FBUSxxREFBUjs7QUFDQSxtQkFBQUEsQ0FBUSw4REFBUjs7QUFDQSxtQkFBQUEsQ0FBUSxnRUFBUjs7QUFDQSxtQkFBQUEsQ0FBUSwwRUFBUjs7QUFDQSxtQkFBQUEsQ0FBUSwrREFBUjs7QUFDQSxtQkFBQUEsQ0FBUSxtREFBUjs7QUFDQSxtQkFBQUEsQ0FBUSxxRUFBUjs7QUFDQSxtQkFBQUEsQ0FBUSxxREFBUjs7QUFDQSxtQkFBQUEsQ0FBUSxtREFBUjs7QUFDQSxtQkFBQUEsQ0FBUSxpRUFBUjs7QUFDQSxtQkFBQUEsQ0FBUSx3REFBUjs7QUFDQSxtQkFBQUEsQ0FBUSx3REFBUjs7QUFDQSxtQkFBQUEsQ0FBUSw0REFBUjs7QUFDQSxtQkFBQUEsQ0FBUSxxREFBUjs7QUFDQSxtQkFBQUEsQ0FBUSxpREFBUjs7QUFDQSxtQkFBQUEsQ0FBUSwrREFBUjs7QUFDQSxtQkFBQUEsQ0FBUSx3REFBUjs7QUFDQSxtQkFBQUEsQ0FBUSxxREFBUjs7QUFDQSxtQkFBQUEsQ0FBUSxxREFBUjs7QUFDQSxtQkFBQUEsQ0FBUSw2REFBUjs7QUFDQSxtQkFBQUEsQ0FBUSxpREFBUjs7QUFDQSxtQkFBQUEsQ0FBUSxtREFBUjs7QUFDQSxtQkFBQUEsQ0FBUSwwREFBUjs7QUFDQSxtQkFBQUEsQ0FBUSx1REFBUjs7QUFDQSxtQkFBQUEsQ0FBUSwyREFBUjs7QUFDQSxtQkFBQUEsQ0FBUSxzREFBUjs7QUFDQSxtQkFBQUEsQ0FBUSx3REFBUjs7QUFDQSxtQkFBQUEsQ0FBUSx5REFBUjs7QUFDQSxtQkFBQUEsQ0FBUSxxREFBUjs7QUFDQSxtQkFBQUEsQ0FBUSw4REFBUjs7QUFDQSxtQkFBQUEsQ0FBUSwrREFBUjs7QUFDQSxtQkFBQUEsQ0FBUSwrREFBUjs7QUFDQSxtQkFBQUEsQ0FBUSwwREFBUjs7QUFDQSxtQkFBQUEsQ0FBUSx3REFBUjs7QUFDQSxtQkFBQUEsQ0FBUSxrREFBUjs7QUFDQSxtQkFBQUEsQ0FBUSxrREFBUjs7QUFDQSxtQkFBQUEsQ0FBUSxrREFBUjs7QUFDQSxtQkFBQUEsQ0FBUSxpREFBUjs7QUFDQSxtQkFBQUEsQ0FBUSxrREFBUjs7QUFDQSxtQkFBQUEsQ0FBUSxpREFBUjs7QUFDQSxtQkFBQUEsQ0FBUSxrREFBUjs7QUFDQSxtQkFBQUEsQ0FBUSxtREFBUjs7QUFDQSxtQkFBQUEsQ0FBUSxrREFBUjs7QUFDQSxtQkFBQUEsQ0FBUSxpREFBUjs7QUFDQSxtQkFBQUEsQ0FBUSxrREFBUjs7QUFDQSxtQkFBQUEsQ0FBUSxrREFBUjs7QUFDQSxtQkFBQUEsQ0FBUSxpREFBUjs7QUFDQSxtQkFBQUEsQ0FBUSxpREFBUjs7QUFDQSxtQkFBQUEsQ0FBUSxpREFBUjs7QUFDQSxtQkFBQUEsQ0FBUSxpREFBUjs7QUFDQSxtQkFBQUEsQ0FBUSxrREFBUjs7QUFDQSxtQkFBQUEsQ0FBUSw4REFBUjs7QUFDQSxtQkFBQUEsQ0FBUSxrREFBUjs7QUFDQSxtQkFBQUEsQ0FBUSxtREFBUjs7QUFDQSxtQkFBQUEsQ0FBUSx1REFBUjs7QUFDQSxtQkFBQUEsQ0FBUSw0REFBUjs7QUFDQSxtQkFBQUEsQ0FBUSx3REFBUjs7QUFDQSxtQkFBQUEsQ0FBUSx1REFBUjs7QUFDQSxtQkFBQUEsQ0FBUSxxREFBUjs7QUFDQSxtQkFBQUEsQ0FBUSwwREFBUjs7QUFDQSxtQkFBQUEsQ0FBUSxxREFBUjs7QUFDQSxtQkFBQUEsQ0FBUSxrREFBUjs7QUFDQSxtQkFBQUEsQ0FBUSxvREFBUjs7QUFDQSxtQkFBQUEsQ0FBUSxtREFBUjs7QUFDQSxtQkFBQUEsQ0FBUSxvREFBUjs7QUFDQSxtQkFBQUEsQ0FBUSx3REFBUjs7QUFDQSxtQkFBQUEsQ0FBUSx1REFBUjs7QUFDQSxtQkFBQUEsQ0FBUSxzREFBUjs7QUFDQSxtQkFBQUEsQ0FBUSxtREFBUjs7QUFDQSxtQkFBQUEsQ0FBUSxvREFBUjs7QUFDQSxtQkFBQUEsQ0FBUSxxREFBUjs7QUFDQSxtQkFBQUEsQ0FBUSxrREFBUjs7QUFDQSxtQkFBQUEsQ0FBUSxrREFBUjs7QUFDQSxtQkFBQUEsQ0FBUSxnREFBUjs7QUFDQSxtQkFBQUEsQ0FBUSxvREFBUjs7QUFDQSxtQkFBQUEsQ0FBUSwwREFBUjs7QUFDQSxtQkFBQUEsQ0FBUSxzREFBUjs7QUFDQSxtQkFBQUEsQ0FBUSx5REFBUjs7QUFDQSxtQkFBQUEsQ0FBUSxzREFBUjs7QUFDQSxtQkFBQUEsQ0FBUSxrREFBUjs7QUFDQSxtQkFBQUEsQ0FBUSxnREFBUjs7QUFDQSxtQkFBQUEsQ0FBUSxrREFBUjs7QUFDQSxtQkFBQUEsQ0FBUSxtREFBUjs7QUFDQSxtQkFBQUEsQ0FBUSxrREFBUjs7QUFDQSxtQkFBQUEsQ0FBUSxzREFBUjs7QUFDQSxtQkFBQUEsQ0FBUSxpREFBUjs7QUFDQSxtQkFBQUEsQ0FBUSxvREFBUjs7QUFDQSxtQkFBQUEsQ0FBUSxrREFBUjs7QUFDQSxtQkFBQUEsQ0FBUSxtREFBUjs7QUFDQSxtQkFBQUEsQ0FBUSxvREFBUjs7QUFDQSxtQkFBQUEsQ0FBUSwwREFBUjs7QUFDQSxtQkFBQUEsQ0FBUSxzREFBUjs7QUFDQSxtQkFBQUEsQ0FBUSwyREFBUjs7QUFDQSxtQkFBQUEsQ0FBUSx5REFBUjs7QUFDQSxtQkFBQUEsQ0FBUSxrREFBUjs7QUFDQSxtQkFBQUEsQ0FBUSxrREFBUjs7QUFDQSxtQkFBQUEsQ0FBUSx3REFBUjs7QUFDQSxtQkFBQUEsQ0FBUSxxREFBUjs7QUFDQSxtQkFBQUEsQ0FBUSxzREFBUjs7QUFDQSxtQkFBQUEsQ0FBUSwwREFBUjs7QUFDQSxtQkFBQUEsQ0FBUSx3REFBUjs7QUFDQSxtQkFBQUEsQ0FBUSxvREFBUjs7QUFDQSxtQkFBQUEsQ0FBUSxvREFBUjs7QUFDQSxtQkFBQUEsQ0FBUSxzREFBUjs7QUFDQSxtQkFBQUEsQ0FBUSxxREFBUjs7QUFDQSxtQkFBQUEsQ0FBUSxvREFBUjs7QUFDQSxtQkFBQUEsQ0FBUSwrQ0FBUjs7QUFDQSxtQkFBQUEsQ0FBUSwyQ0FBUjs7QUFDQSxtQkFBQUEsQ0FBUSwyQ0FBUjs7QUFDQSxtQkFBQUEsQ0FBUSxnREFBUjs7QUFDQSxtQkFBQUEsQ0FBUSxnREFBUjs7QUFDQSxtQkFBQUEsQ0FBUSwwREFBUjs7QUFDQSxtQkFBQUEsQ0FBUSx1REFBUjs7QUFDQSxtQkFBQUEsQ0FBUSx3REFBUjs7QUFDQSxtQkFBQUEsQ0FBUSx5REFBUjs7QUFDQSxtQkFBQUEsQ0FBUSxpRUFBUjs7QUFDQSxtQkFBQUEsQ0FBUSx5REFBUjs7QUFDQSxtQkFBQUEsQ0FBUSwwREFBUjs7QUFDQSxtQkFBQUEsQ0FBUSx5REFBUjs7QUFDQSxtQkFBQUEsQ0FBUSwwREFBUjs7QUFDQSxtQkFBQUEsQ0FBUSwyREFBUjs7QUFDQSxtQkFBQUEsQ0FBUSwyREFBUjs7QUFDQSxtQkFBQUEsQ0FBUSxxREFBUjs7QUFDQSxtQkFBQUEsQ0FBUSx5REFBUjs7QUFDQSxtQkFBQUEsQ0FBUSwrREFBUjs7QUFDQSxtQkFBQUEsQ0FBUSwrREFBUjs7QUFDQSxtQkFBQUEsQ0FBUSx5REFBUjs7QUFDQSxtQkFBQUEsQ0FBUSxtREFBUjs7QUFDQSxtQkFBQUEsQ0FBUSwyRUFBUjs7QUFDQSxtQkFBQUEsQ0FBUSxnRUFBUjs7QUFDQSxtQkFBQUEsQ0FBUSxtREFBUjs7QUFDQSxtQkFBQUEsQ0FBUSw2REFBUjs7QUFDQSxtQkFBQUEsQ0FBUSx3REFBUjs7QUFDQSxtQkFBQUEsQ0FBUSxrRUFBUjs7QUFDQSxtQkFBQUEsQ0FBUSxtREFBUjs7QUFDQSxtQkFBQUEsQ0FBUSxnRUFBUjs7QUFDQSxtQkFBQUEsQ0FBUSxzREFBUjs7QUFDQSxtQkFBQUEsQ0FBUSxzREFBUjs7QUFDQSxtQkFBQUEsQ0FBUSxxREFBUjs7QUFDQSxtQkFBQUEsQ0FBUSxpREFBUjs7QUFDQSxtQkFBQUEsQ0FBUSx3REFBUjs7QUFDQSxtQkFBQUEsQ0FBUSxzREFBUjs7QUFDQSxtQkFBQUEsQ0FBUSx3REFBUjs7QUFDQSxtQkFBQUEsQ0FBUSx5REFBUjs7QUFDQSxtQkFBQUEsQ0FBUSx3REFBUjs7QUFDQSxtQkFBQUEsQ0FBUSw2REFBUjs7QUFDQSxtQkFBQUEsQ0FBUSx5REFBUjs7QUFDQSxtQkFBQUEsQ0FBUSwyRUFBUjs7QUFDQSxtQkFBQUEsQ0FBUSxxREFBUjs7QUFDQSxtQkFBQUEsQ0FBUSxzREFBUjs7QUFDQSxtQkFBQUEsQ0FBUSw0REFBUjs7QUFDQSxtQkFBQUEsQ0FBUSw0REFBUjs7QUFDQSxtQkFBQUEsQ0FBUSw0REFBUjs7QUFDQSxtQkFBQUEsQ0FBUSw0REFBUjs7QUFDQSxtQkFBQUEsQ0FBUSxtREFBUjs7QUFDQSxtQkFBQUEsQ0FBUSxtREFBUjs7QUFDQSxtQkFBQUEsQ0FBUSw4Q0FBUjs7QUFDQSxtQkFBQUEsQ0FBUSw4Q0FBUjs7QUFDQSxtQkFBQUEsQ0FBUSxtREFBUjs7QUFDQSxtQkFBQUEsQ0FBUSxtREFBUjs7QUFDQSxtQkFBQUEsQ0FBUSxnREFBUjs7QUFDQSxtQkFBQUEsQ0FBUSxnREFBUjs7QUFDQSxtQkFBQUEsQ0FBUSxxREFBUjs7QUFDQSxtQkFBQUEsQ0FBUSxxREFBUjs7QUFDQSxtQkFBQUEsQ0FBUSw4Q0FBUjs7QUFDQSxtQkFBQUEsQ0FBUSxxREFBUjs7QUFDQSxtQkFBQUEsQ0FBUSxzREFBUjs7QUFDQSxtQkFBQUEsQ0FBUSxrREFBUjs7QUFDQSxtQkFBQUEsQ0FBUSx3REFBUjs7QUFDQSxtQkFBQUEsQ0FBUSxvREFBUjs7QUFDQSxtQkFBQUEsQ0FBUSxtREFBUjs7QUFDQSxtQkFBQUEsQ0FBUSxrREFBUjs7QUFDQSxtQkFBQUEsQ0FBUSxrREFBUjs7QUFDQSxtQkFBQUEsQ0FBUSxrREFBUjs7QUFDQSxtQkFBQUEsQ0FBUSx3REFBUjs7QUFDQSxtQkFBQUEsQ0FBUSxvREFBUjs7QUFDQSxtQkFBQUEsQ0FBUSxrREFBUjs7QUFDQSxtQkFBQUEsQ0FBUSxrREFBUjs7QUFDQSxtQkFBQUEsQ0FBUSxvREFBUjs7QUFDQSxtQkFBQUEsQ0FBUSx1REFBUjs7QUFDQSxtQkFBQUEsQ0FBUSxtREFBUjs7QUFDQSxtQkFBQUEs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LE9BQUssS0FBRTtBQUNuQyx3QkFDUjtBQUFNLFNBQUU7QUFDQSx3QkFDUjtBQUNEO0FBQU0sT0FDTixDQUFDLEM7Ozs7Ozs7Ozs7Ozs7QUNaNEM7O0FBRWQ7O0FBRXdDOztBQVNqRTs7Ozs7O0FBQUMsSUFBVSxxQkFBK0I7QUFBNUI7QUFDTixZQUFLLGlCQUFFLEdBQUcsR0FBSTtHQUEzQjtBQUNlLFlBQVEsb0JBQUksS0FBTTtHQUFoQyxFQUNDLG9CQUFnQixpQkFLbkI7Ozs7O0FBWXdEOztBQUFTLFlBQU0sa0JBQUssS0FBUyxXQUFNLEtBQU0sS0FBUyxXQUFNLEtBQU0sS0FBUyxXQUFNLEtBQVE7QUFBcEY7Ozs7OztBQUFuRCxPQUFNO0FBQW9CLFdBQUssT0FBUztHQUFwQixFQUN6QjtBQUFDOzs7QUFHYSxnQkFBSyxLQUNuQjtBQUFDOzs7QUFHTyxVQUFJLElBQUssS0FBTSxNQUFRO0FBQ3hCO0FBQVksV0FBUSxvQkFBRSxHQUFHLEdBQUs7QUFBUSxZQUFNLEtBQU0sTUFDekQ7R0FEUTtBQUVSOztJQXZCcUI7Ozs7O0FBSXJCLDJCQUFtRDs7O0FBQzdDLHdDQUFRO0FBSk4sVUFBVyxjQUFjO0FBQ3pCLFVBQUssUUFBYTtBQUlyQixVQUFNO0FBQ0gsY0FBTSxrQkFBRSxHQUFHLEdBQUcsR0FFdEI7QUFIYzs7QUFHYjs7O1NBRXdCO1NBSUU7U0FJZDs7RUFuQnFCLE1BQWdDLFciLCJmaWxlIjoiZGlzdC9pbmRleC5qcyIsInNvdXJjZXNDb250ZW50IjpbIiBcdGZ1bmN0aW9uIGhvdERpc3Bvc2VDaHVuayhjaHVua0lkKSB7XG4gXHRcdGRlbGV0ZSBpbnN0YWxsZWRDaHVua3NbY2h1bmtJZF07XG4gXHR9XG4gXHR2YXIgcGFyZW50SG90VXBkYXRlQ2FsbGJhY2sgPSB3aW5kb3dbXCJ3ZWJwYWNrSG90VXBkYXRlXCJdO1xuIFx0d2luZG93W1wid2VicGFja0hvdFVwZGF0ZVwiXSA9IFxyXG4gXHRmdW5jdGlvbiB3ZWJwYWNrSG90VXBkYXRlQ2FsbGJhY2soY2h1bmtJZCwgbW9yZU1vZHVsZXMpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xyXG4gXHRcdGhvdEFkZFVwZGF0ZUNodW5rKGNodW5rSWQsIG1vcmVNb2R1bGVzKTtcclxuIFx0XHRpZihwYXJlbnRIb3RVcGRhdGVDYWxsYmFjaykgcGFyZW50SG90VXBkYXRlQ2FsbGJhY2soY2h1bmtJZCwgbW9yZU1vZHVsZXMpO1xyXG4gXHR9IDtcclxuIFx0XHJcbiBcdGZ1bmN0aW9uIGhvdERvd25sb2FkVXBkYXRlQ2h1bmsoY2h1bmtJZCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXHJcbiBcdFx0dmFyIGhlYWQgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImhlYWRcIilbMF07XHJcbiBcdFx0dmFyIHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIik7XHJcbiBcdFx0c2NyaXB0LnR5cGUgPSBcInRleHQvamF2YXNjcmlwdFwiO1xyXG4gXHRcdHNjcmlwdC5jaGFyc2V0ID0gXCJ1dGYtOFwiO1xyXG4gXHRcdHNjcmlwdC5zcmMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fLnAgKyBcIlwiICsgY2h1bmtJZCArIFwiLlwiICsgaG90Q3VycmVudEhhc2ggKyBcIi5ob3QtdXBkYXRlLmpzXCI7XHJcbiBcdFx0O1xyXG4gXHRcdGhlYWQuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcclxuIFx0fVxyXG4gXHRcclxuIFx0ZnVuY3Rpb24gaG90RG93bmxvYWRNYW5pZmVzdChyZXF1ZXN0VGltZW91dCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXHJcbiBcdFx0cmVxdWVzdFRpbWVvdXQgPSByZXF1ZXN0VGltZW91dCB8fCAxMDAwMDtcclxuIFx0XHRyZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiBcdFx0XHRpZih0eXBlb2YgWE1MSHR0cFJlcXVlc3QgPT09IFwidW5kZWZpbmVkXCIpXHJcbiBcdFx0XHRcdHJldHVybiByZWplY3QobmV3IEVycm9yKFwiTm8gYnJvd3NlciBzdXBwb3J0XCIpKTtcclxuIFx0XHRcdHRyeSB7XHJcbiBcdFx0XHRcdHZhciByZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XHJcbiBcdFx0XHRcdHZhciByZXF1ZXN0UGF0aCA9IF9fd2VicGFja19yZXF1aXJlX18ucCArIFwiXCIgKyBob3RDdXJyZW50SGFzaCArIFwiLmhvdC11cGRhdGUuanNvblwiO1xyXG4gXHRcdFx0XHRyZXF1ZXN0Lm9wZW4oXCJHRVRcIiwgcmVxdWVzdFBhdGgsIHRydWUpO1xyXG4gXHRcdFx0XHRyZXF1ZXN0LnRpbWVvdXQgPSByZXF1ZXN0VGltZW91dDtcclxuIFx0XHRcdFx0cmVxdWVzdC5zZW5kKG51bGwpO1xyXG4gXHRcdFx0fSBjYXRjaChlcnIpIHtcclxuIFx0XHRcdFx0cmV0dXJuIHJlamVjdChlcnIpO1xyXG4gXHRcdFx0fVxyXG4gXHRcdFx0cmVxdWVzdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcclxuIFx0XHRcdFx0aWYocmVxdWVzdC5yZWFkeVN0YXRlICE9PSA0KSByZXR1cm47XHJcbiBcdFx0XHRcdGlmKHJlcXVlc3Quc3RhdHVzID09PSAwKSB7XHJcbiBcdFx0XHRcdFx0Ly8gdGltZW91dFxyXG4gXHRcdFx0XHRcdHJlamVjdChuZXcgRXJyb3IoXCJNYW5pZmVzdCByZXF1ZXN0IHRvIFwiICsgcmVxdWVzdFBhdGggKyBcIiB0aW1lZCBvdXQuXCIpKTtcclxuIFx0XHRcdFx0fSBlbHNlIGlmKHJlcXVlc3Quc3RhdHVzID09PSA0MDQpIHtcclxuIFx0XHRcdFx0XHQvLyBubyB1cGRhdGUgYXZhaWxhYmxlXHJcbiBcdFx0XHRcdFx0cmVzb2x2ZSgpO1xyXG4gXHRcdFx0XHR9IGVsc2UgaWYocmVxdWVzdC5zdGF0dXMgIT09IDIwMCAmJiByZXF1ZXN0LnN0YXR1cyAhPT0gMzA0KSB7XHJcbiBcdFx0XHRcdFx0Ly8gb3RoZXIgZmFpbHVyZVxyXG4gXHRcdFx0XHRcdHJlamVjdChuZXcgRXJyb3IoXCJNYW5pZmVzdCByZXF1ZXN0IHRvIFwiICsgcmVxdWVzdFBhdGggKyBcIiBmYWlsZWQuXCIpKTtcclxuIFx0XHRcdFx0fSBlbHNlIHtcclxuIFx0XHRcdFx0XHQvLyBzdWNjZXNzXHJcbiBcdFx0XHRcdFx0dHJ5IHtcclxuIFx0XHRcdFx0XHRcdHZhciB1cGRhdGUgPSBKU09OLnBhcnNlKHJlcXVlc3QucmVzcG9uc2VUZXh0KTtcclxuIFx0XHRcdFx0XHR9IGNhdGNoKGUpIHtcclxuIFx0XHRcdFx0XHRcdHJlamVjdChlKTtcclxuIFx0XHRcdFx0XHRcdHJldHVybjtcclxuIFx0XHRcdFx0XHR9XHJcbiBcdFx0XHRcdFx0cmVzb2x2ZSh1cGRhdGUpO1xyXG4gXHRcdFx0XHR9XHJcbiBcdFx0XHR9O1xyXG4gXHRcdH0pO1xyXG4gXHR9XHJcblxuIFx0XHJcbiBcdFxyXG4gXHR2YXIgaG90QXBwbHlPblVwZGF0ZSA9IHRydWU7XHJcbiBcdHZhciBob3RDdXJyZW50SGFzaCA9IFwiOTI0MDZiOGIxMzAxNmNjMTRmNTZcIjsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xyXG4gXHR2YXIgaG90UmVxdWVzdFRpbWVvdXQgPSAxMDAwMDtcclxuIFx0dmFyIGhvdEN1cnJlbnRNb2R1bGVEYXRhID0ge307XHJcbiBcdHZhciBob3RDdXJyZW50Q2hpbGRNb2R1bGU7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcclxuIFx0dmFyIGhvdEN1cnJlbnRQYXJlbnRzID0gW107IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcclxuIFx0dmFyIGhvdEN1cnJlbnRQYXJlbnRzVGVtcCA9IFtdOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXHJcbiBcdFxyXG4gXHRmdW5jdGlvbiBob3RDcmVhdGVSZXF1aXJlKG1vZHVsZUlkKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcclxuIFx0XHR2YXIgbWUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXTtcclxuIFx0XHRpZighbWUpIHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fO1xyXG4gXHRcdHZhciBmbiA9IGZ1bmN0aW9uKHJlcXVlc3QpIHtcclxuIFx0XHRcdGlmKG1lLmhvdC5hY3RpdmUpIHtcclxuIFx0XHRcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1tyZXF1ZXN0XSkge1xyXG4gXHRcdFx0XHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbcmVxdWVzdF0ucGFyZW50cy5pbmRleE9mKG1vZHVsZUlkKSA8IDApXHJcbiBcdFx0XHRcdFx0XHRpbnN0YWxsZWRNb2R1bGVzW3JlcXVlc3RdLnBhcmVudHMucHVzaChtb2R1bGVJZCk7XHJcbiBcdFx0XHRcdH0gZWxzZSB7XHJcbiBcdFx0XHRcdFx0aG90Q3VycmVudFBhcmVudHMgPSBbbW9kdWxlSWRdO1xyXG4gXHRcdFx0XHRcdGhvdEN1cnJlbnRDaGlsZE1vZHVsZSA9IHJlcXVlc3Q7XHJcbiBcdFx0XHRcdH1cclxuIFx0XHRcdFx0aWYobWUuY2hpbGRyZW4uaW5kZXhPZihyZXF1ZXN0KSA8IDApXHJcbiBcdFx0XHRcdFx0bWUuY2hpbGRyZW4ucHVzaChyZXF1ZXN0KTtcclxuIFx0XHRcdH0gZWxzZSB7XHJcbiBcdFx0XHRcdGNvbnNvbGUud2FybihcIltITVJdIHVuZXhwZWN0ZWQgcmVxdWlyZShcIiArIHJlcXVlc3QgKyBcIikgZnJvbSBkaXNwb3NlZCBtb2R1bGUgXCIgKyBtb2R1bGVJZCk7XHJcbiBcdFx0XHRcdGhvdEN1cnJlbnRQYXJlbnRzID0gW107XHJcbiBcdFx0XHR9XHJcbiBcdFx0XHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhyZXF1ZXN0KTtcclxuIFx0XHR9O1xyXG4gXHRcdHZhciBPYmplY3RGYWN0b3J5ID0gZnVuY3Rpb24gT2JqZWN0RmFjdG9yeShuYW1lKSB7XHJcbiBcdFx0XHRyZXR1cm4ge1xyXG4gXHRcdFx0XHRjb25maWd1cmFibGU6IHRydWUsXHJcbiBcdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXHJcbiBcdFx0XHRcdGdldDogZnVuY3Rpb24oKSB7XHJcbiBcdFx0XHRcdFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX19bbmFtZV07XHJcbiBcdFx0XHRcdH0sXHJcbiBcdFx0XHRcdHNldDogZnVuY3Rpb24odmFsdWUpIHtcclxuIFx0XHRcdFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fW25hbWVdID0gdmFsdWU7XHJcbiBcdFx0XHRcdH1cclxuIFx0XHRcdH07XHJcbiBcdFx0fTtcclxuIFx0XHRmb3IodmFyIG5hbWUgaW4gX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG4gXHRcdFx0aWYoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKF9fd2VicGFja19yZXF1aXJlX18sIG5hbWUpICYmIG5hbWUgIT09IFwiZVwiKSB7XHJcbiBcdFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmbiwgbmFtZSwgT2JqZWN0RmFjdG9yeShuYW1lKSk7XHJcbiBcdFx0XHR9XHJcbiBcdFx0fVxyXG4gXHRcdGZuLmUgPSBmdW5jdGlvbihjaHVua0lkKSB7XHJcbiBcdFx0XHRpZihob3RTdGF0dXMgPT09IFwicmVhZHlcIilcclxuIFx0XHRcdFx0aG90U2V0U3RhdHVzKFwicHJlcGFyZVwiKTtcclxuIFx0XHRcdGhvdENodW5rc0xvYWRpbmcrKztcclxuIFx0XHRcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fLmUoY2h1bmtJZCkudGhlbihmaW5pc2hDaHVua0xvYWRpbmcsIGZ1bmN0aW9uKGVycikge1xyXG4gXHRcdFx0XHRmaW5pc2hDaHVua0xvYWRpbmcoKTtcclxuIFx0XHRcdFx0dGhyb3cgZXJyO1xyXG4gXHRcdFx0fSk7XHJcbiBcdFxyXG4gXHRcdFx0ZnVuY3Rpb24gZmluaXNoQ2h1bmtMb2FkaW5nKCkge1xyXG4gXHRcdFx0XHRob3RDaHVua3NMb2FkaW5nLS07XHJcbiBcdFx0XHRcdGlmKGhvdFN0YXR1cyA9PT0gXCJwcmVwYXJlXCIpIHtcclxuIFx0XHRcdFx0XHRpZighaG90V2FpdGluZ0ZpbGVzTWFwW2NodW5rSWRdKSB7XHJcbiBcdFx0XHRcdFx0XHRob3RFbnN1cmVVcGRhdGVDaHVuayhjaHVua0lkKTtcclxuIFx0XHRcdFx0XHR9XHJcbiBcdFx0XHRcdFx0aWYoaG90Q2h1bmtzTG9hZGluZyA9PT0gMCAmJiBob3RXYWl0aW5nRmlsZXMgPT09IDApIHtcclxuIFx0XHRcdFx0XHRcdGhvdFVwZGF0ZURvd25sb2FkZWQoKTtcclxuIFx0XHRcdFx0XHR9XHJcbiBcdFx0XHRcdH1cclxuIFx0XHRcdH1cclxuIFx0XHR9O1xyXG4gXHRcdHJldHVybiBmbjtcclxuIFx0fVxyXG4gXHRcclxuIFx0ZnVuY3Rpb24gaG90Q3JlYXRlTW9kdWxlKG1vZHVsZUlkKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcclxuIFx0XHR2YXIgaG90ID0ge1xyXG4gXHRcdFx0Ly8gcHJpdmF0ZSBzdHVmZlxyXG4gXHRcdFx0X2FjY2VwdGVkRGVwZW5kZW5jaWVzOiB7fSxcclxuIFx0XHRcdF9kZWNsaW5lZERlcGVuZGVuY2llczoge30sXHJcbiBcdFx0XHRfc2VsZkFjY2VwdGVkOiBmYWxzZSxcclxuIFx0XHRcdF9zZWxmRGVjbGluZWQ6IGZhbHNlLFxyXG4gXHRcdFx0X2Rpc3Bvc2VIYW5kbGVyczogW10sXHJcbiBcdFx0XHRfbWFpbjogaG90Q3VycmVudENoaWxkTW9kdWxlICE9PSBtb2R1bGVJZCxcclxuIFx0XHJcbiBcdFx0XHQvLyBNb2R1bGUgQVBJXHJcbiBcdFx0XHRhY3RpdmU6IHRydWUsXHJcbiBcdFx0XHRhY2NlcHQ6IGZ1bmN0aW9uKGRlcCwgY2FsbGJhY2spIHtcclxuIFx0XHRcdFx0aWYodHlwZW9mIGRlcCA9PT0gXCJ1bmRlZmluZWRcIilcclxuIFx0XHRcdFx0XHRob3QuX3NlbGZBY2NlcHRlZCA9IHRydWU7XHJcbiBcdFx0XHRcdGVsc2UgaWYodHlwZW9mIGRlcCA9PT0gXCJmdW5jdGlvblwiKVxyXG4gXHRcdFx0XHRcdGhvdC5fc2VsZkFjY2VwdGVkID0gZGVwO1xyXG4gXHRcdFx0XHRlbHNlIGlmKHR5cGVvZiBkZXAgPT09IFwib2JqZWN0XCIpXHJcbiBcdFx0XHRcdFx0Zm9yKHZhciBpID0gMDsgaSA8IGRlcC5sZW5ndGg7IGkrKylcclxuIFx0XHRcdFx0XHRcdGhvdC5fYWNjZXB0ZWREZXBlbmRlbmNpZXNbZGVwW2ldXSA9IGNhbGxiYWNrIHx8IGZ1bmN0aW9uKCkge307XHJcbiBcdFx0XHRcdGVsc2VcclxuIFx0XHRcdFx0XHRob3QuX2FjY2VwdGVkRGVwZW5kZW5jaWVzW2RlcF0gPSBjYWxsYmFjayB8fCBmdW5jdGlvbigpIHt9O1xyXG4gXHRcdFx0fSxcclxuIFx0XHRcdGRlY2xpbmU6IGZ1bmN0aW9uKGRlcCkge1xyXG4gXHRcdFx0XHRpZih0eXBlb2YgZGVwID09PSBcInVuZGVmaW5lZFwiKVxyXG4gXHRcdFx0XHRcdGhvdC5fc2VsZkRlY2xpbmVkID0gdHJ1ZTtcclxuIFx0XHRcdFx0ZWxzZSBpZih0eXBlb2YgZGVwID09PSBcIm9iamVjdFwiKVxyXG4gXHRcdFx0XHRcdGZvcih2YXIgaSA9IDA7IGkgPCBkZXAubGVuZ3RoOyBpKyspXHJcbiBcdFx0XHRcdFx0XHRob3QuX2RlY2xpbmVkRGVwZW5kZW5jaWVzW2RlcFtpXV0gPSB0cnVlO1xyXG4gXHRcdFx0XHRlbHNlXHJcbiBcdFx0XHRcdFx0aG90Ll9kZWNsaW5lZERlcGVuZGVuY2llc1tkZXBdID0gdHJ1ZTtcclxuIFx0XHRcdH0sXHJcbiBcdFx0XHRkaXNwb3NlOiBmdW5jdGlvbihjYWxsYmFjaykge1xyXG4gXHRcdFx0XHRob3QuX2Rpc3Bvc2VIYW5kbGVycy5wdXNoKGNhbGxiYWNrKTtcclxuIFx0XHRcdH0sXHJcbiBcdFx0XHRhZGREaXNwb3NlSGFuZGxlcjogZnVuY3Rpb24oY2FsbGJhY2spIHtcclxuIFx0XHRcdFx0aG90Ll9kaXNwb3NlSGFuZGxlcnMucHVzaChjYWxsYmFjayk7XHJcbiBcdFx0XHR9LFxyXG4gXHRcdFx0cmVtb3ZlRGlzcG9zZUhhbmRsZXI6IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XHJcbiBcdFx0XHRcdHZhciBpZHggPSBob3QuX2Rpc3Bvc2VIYW5kbGVycy5pbmRleE9mKGNhbGxiYWNrKTtcclxuIFx0XHRcdFx0aWYoaWR4ID49IDApIGhvdC5fZGlzcG9zZUhhbmRsZXJzLnNwbGljZShpZHgsIDEpO1xyXG4gXHRcdFx0fSxcclxuIFx0XHJcbiBcdFx0XHQvLyBNYW5hZ2VtZW50IEFQSVxyXG4gXHRcdFx0Y2hlY2s6IGhvdENoZWNrLFxyXG4gXHRcdFx0YXBwbHk6IGhvdEFwcGx5LFxyXG4gXHRcdFx0c3RhdHVzOiBmdW5jdGlvbihsKSB7XHJcbiBcdFx0XHRcdGlmKCFsKSByZXR1cm4gaG90U3RhdHVzO1xyXG4gXHRcdFx0XHRob3RTdGF0dXNIYW5kbGVycy5wdXNoKGwpO1xyXG4gXHRcdFx0fSxcclxuIFx0XHRcdGFkZFN0YXR1c0hhbmRsZXI6IGZ1bmN0aW9uKGwpIHtcclxuIFx0XHRcdFx0aG90U3RhdHVzSGFuZGxlcnMucHVzaChsKTtcclxuIFx0XHRcdH0sXHJcbiBcdFx0XHRyZW1vdmVTdGF0dXNIYW5kbGVyOiBmdW5jdGlvbihsKSB7XHJcbiBcdFx0XHRcdHZhciBpZHggPSBob3RTdGF0dXNIYW5kbGVycy5pbmRleE9mKGwpO1xyXG4gXHRcdFx0XHRpZihpZHggPj0gMCkgaG90U3RhdHVzSGFuZGxlcnMuc3BsaWNlKGlkeCwgMSk7XHJcbiBcdFx0XHR9LFxyXG4gXHRcclxuIFx0XHRcdC8vaW5oZXJpdCBmcm9tIHByZXZpb3VzIGRpc3Bvc2UgY2FsbFxyXG4gXHRcdFx0ZGF0YTogaG90Q3VycmVudE1vZHVsZURhdGFbbW9kdWxlSWRdXHJcbiBcdFx0fTtcclxuIFx0XHRob3RDdXJyZW50Q2hpbGRNb2R1bGUgPSB1bmRlZmluZWQ7XHJcbiBcdFx0cmV0dXJuIGhvdDtcclxuIFx0fVxyXG4gXHRcclxuIFx0dmFyIGhvdFN0YXR1c0hhbmRsZXJzID0gW107XHJcbiBcdHZhciBob3RTdGF0dXMgPSBcImlkbGVcIjtcclxuIFx0XHJcbiBcdGZ1bmN0aW9uIGhvdFNldFN0YXR1cyhuZXdTdGF0dXMpIHtcclxuIFx0XHRob3RTdGF0dXMgPSBuZXdTdGF0dXM7XHJcbiBcdFx0Zm9yKHZhciBpID0gMDsgaSA8IGhvdFN0YXR1c0hhbmRsZXJzLmxlbmd0aDsgaSsrKVxyXG4gXHRcdFx0aG90U3RhdHVzSGFuZGxlcnNbaV0uY2FsbChudWxsLCBuZXdTdGF0dXMpO1xyXG4gXHR9XHJcbiBcdFxyXG4gXHQvLyB3aGlsZSBkb3dubG9hZGluZ1xyXG4gXHR2YXIgaG90V2FpdGluZ0ZpbGVzID0gMDtcclxuIFx0dmFyIGhvdENodW5rc0xvYWRpbmcgPSAwO1xyXG4gXHR2YXIgaG90V2FpdGluZ0ZpbGVzTWFwID0ge307XHJcbiBcdHZhciBob3RSZXF1ZXN0ZWRGaWxlc01hcCA9IHt9O1xyXG4gXHR2YXIgaG90QXZhaWxhYmxlRmlsZXNNYXAgPSB7fTtcclxuIFx0dmFyIGhvdERlZmVycmVkO1xyXG4gXHRcclxuIFx0Ly8gVGhlIHVwZGF0ZSBpbmZvXHJcbiBcdHZhciBob3RVcGRhdGUsIGhvdFVwZGF0ZU5ld0hhc2g7XHJcbiBcdFxyXG4gXHRmdW5jdGlvbiB0b01vZHVsZUlkKGlkKSB7XHJcbiBcdFx0dmFyIGlzTnVtYmVyID0gKCtpZCkgKyBcIlwiID09PSBpZDtcclxuIFx0XHRyZXR1cm4gaXNOdW1iZXIgPyAraWQgOiBpZDtcclxuIFx0fVxyXG4gXHRcclxuIFx0ZnVuY3Rpb24gaG90Q2hlY2soYXBwbHkpIHtcclxuIFx0XHRpZihob3RTdGF0dXMgIT09IFwiaWRsZVwiKSB0aHJvdyBuZXcgRXJyb3IoXCJjaGVjaygpIGlzIG9ubHkgYWxsb3dlZCBpbiBpZGxlIHN0YXR1c1wiKTtcclxuIFx0XHRob3RBcHBseU9uVXBkYXRlID0gYXBwbHk7XHJcbiBcdFx0aG90U2V0U3RhdHVzKFwiY2hlY2tcIik7XHJcbiBcdFx0cmV0dXJuIGhvdERvd25sb2FkTWFuaWZlc3QoaG90UmVxdWVzdFRpbWVvdXQpLnRoZW4oZnVuY3Rpb24odXBkYXRlKSB7XHJcbiBcdFx0XHRpZighdXBkYXRlKSB7XHJcbiBcdFx0XHRcdGhvdFNldFN0YXR1cyhcImlkbGVcIik7XHJcbiBcdFx0XHRcdHJldHVybiBudWxsO1xyXG4gXHRcdFx0fVxyXG4gXHRcdFx0aG90UmVxdWVzdGVkRmlsZXNNYXAgPSB7fTtcclxuIFx0XHRcdGhvdFdhaXRpbmdGaWxlc01hcCA9IHt9O1xyXG4gXHRcdFx0aG90QXZhaWxhYmxlRmlsZXNNYXAgPSB1cGRhdGUuYztcclxuIFx0XHRcdGhvdFVwZGF0ZU5ld0hhc2ggPSB1cGRhdGUuaDtcclxuIFx0XHJcbiBcdFx0XHRob3RTZXRTdGF0dXMoXCJwcmVwYXJlXCIpO1xyXG4gXHRcdFx0dmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcclxuIFx0XHRcdFx0aG90RGVmZXJyZWQgPSB7XHJcbiBcdFx0XHRcdFx0cmVzb2x2ZTogcmVzb2x2ZSxcclxuIFx0XHRcdFx0XHRyZWplY3Q6IHJlamVjdFxyXG4gXHRcdFx0XHR9O1xyXG4gXHRcdFx0fSk7XHJcbiBcdFx0XHRob3RVcGRhdGUgPSB7fTtcclxuIFx0XHRcdHZhciBjaHVua0lkID0gMjtcclxuIFx0XHRcdHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1sb25lLWJsb2Nrc1xyXG4gXHRcdFx0XHQvKmdsb2JhbHMgY2h1bmtJZCAqL1xyXG4gXHRcdFx0XHRob3RFbnN1cmVVcGRhdGVDaHVuayhjaHVua0lkKTtcclxuIFx0XHRcdH1cclxuIFx0XHRcdGlmKGhvdFN0YXR1cyA9PT0gXCJwcmVwYXJlXCIgJiYgaG90Q2h1bmtzTG9hZGluZyA9PT0gMCAmJiBob3RXYWl0aW5nRmlsZXMgPT09IDApIHtcclxuIFx0XHRcdFx0aG90VXBkYXRlRG93bmxvYWRlZCgpO1xyXG4gXHRcdFx0fVxyXG4gXHRcdFx0cmV0dXJuIHByb21pc2U7XHJcbiBcdFx0fSk7XHJcbiBcdH1cclxuIFx0XHJcbiBcdGZ1bmN0aW9uIGhvdEFkZFVwZGF0ZUNodW5rKGNodW5rSWQsIG1vcmVNb2R1bGVzKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcclxuIFx0XHRpZighaG90QXZhaWxhYmxlRmlsZXNNYXBbY2h1bmtJZF0gfHwgIWhvdFJlcXVlc3RlZEZpbGVzTWFwW2NodW5rSWRdKVxyXG4gXHRcdFx0cmV0dXJuO1xyXG4gXHRcdGhvdFJlcXVlc3RlZEZpbGVzTWFwW2NodW5rSWRdID0gZmFsc2U7XHJcbiBcdFx0Zm9yKHZhciBtb2R1bGVJZCBpbiBtb3JlTW9kdWxlcykge1xyXG4gXHRcdFx0aWYoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vcmVNb2R1bGVzLCBtb2R1bGVJZCkpIHtcclxuIFx0XHRcdFx0aG90VXBkYXRlW21vZHVsZUlkXSA9IG1vcmVNb2R1bGVzW21vZHVsZUlkXTtcclxuIFx0XHRcdH1cclxuIFx0XHR9XHJcbiBcdFx0aWYoLS1ob3RXYWl0aW5nRmlsZXMgPT09IDAgJiYgaG90Q2h1bmtzTG9hZGluZyA9PT0gMCkge1xyXG4gXHRcdFx0aG90VXBkYXRlRG93bmxvYWRlZCgpO1xyXG4gXHRcdH1cclxuIFx0fVxyXG4gXHRcclxuIFx0ZnVuY3Rpb24gaG90RW5zdXJlVXBkYXRlQ2h1bmsoY2h1bmtJZCkge1xyXG4gXHRcdGlmKCFob3RBdmFpbGFibGVGaWxlc01hcFtjaHVua0lkXSkge1xyXG4gXHRcdFx0aG90V2FpdGluZ0ZpbGVzTWFwW2NodW5rSWRdID0gdHJ1ZTtcclxuIFx0XHR9IGVsc2Uge1xyXG4gXHRcdFx0aG90UmVxdWVzdGVkRmlsZXNNYXBbY2h1bmtJZF0gPSB0cnVlO1xyXG4gXHRcdFx0aG90V2FpdGluZ0ZpbGVzKys7XHJcbiBcdFx0XHRob3REb3dubG9hZFVwZGF0ZUNodW5rKGNodW5rSWQpO1xyXG4gXHRcdH1cclxuIFx0fVxyXG4gXHRcclxuIFx0ZnVuY3Rpb24gaG90VXBkYXRlRG93bmxvYWRlZCgpIHtcclxuIFx0XHRob3RTZXRTdGF0dXMoXCJyZWFkeVwiKTtcclxuIFx0XHR2YXIgZGVmZXJyZWQgPSBob3REZWZlcnJlZDtcclxuIFx0XHRob3REZWZlcnJlZCA9IG51bGw7XHJcbiBcdFx0aWYoIWRlZmVycmVkKSByZXR1cm47XHJcbiBcdFx0aWYoaG90QXBwbHlPblVwZGF0ZSkge1xyXG4gXHRcdFx0Ly8gV3JhcCBkZWZlcnJlZCBvYmplY3QgaW4gUHJvbWlzZSB0byBtYXJrIGl0IGFzIGEgd2VsbC1oYW5kbGVkIFByb21pc2UgdG9cclxuIFx0XHRcdC8vIGF2b2lkIHRyaWdnZXJpbmcgdW5jYXVnaHQgZXhjZXB0aW9uIHdhcm5pbmcgaW4gQ2hyb21lLlxyXG4gXHRcdFx0Ly8gU2VlIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTQ2NTY2NlxyXG4gXHRcdFx0UHJvbWlzZS5yZXNvbHZlKCkudGhlbihmdW5jdGlvbigpIHtcclxuIFx0XHRcdFx0cmV0dXJuIGhvdEFwcGx5KGhvdEFwcGx5T25VcGRhdGUpO1xyXG4gXHRcdFx0fSkudGhlbihcclxuIFx0XHRcdFx0ZnVuY3Rpb24ocmVzdWx0KSB7XHJcbiBcdFx0XHRcdFx0ZGVmZXJyZWQucmVzb2x2ZShyZXN1bHQpO1xyXG4gXHRcdFx0XHR9LFxyXG4gXHRcdFx0XHRmdW5jdGlvbihlcnIpIHtcclxuIFx0XHRcdFx0XHRkZWZlcnJlZC5yZWplY3QoZXJyKTtcclxuIFx0XHRcdFx0fVxyXG4gXHRcdFx0KTtcclxuIFx0XHR9IGVsc2Uge1xyXG4gXHRcdFx0dmFyIG91dGRhdGVkTW9kdWxlcyA9IFtdO1xyXG4gXHRcdFx0Zm9yKHZhciBpZCBpbiBob3RVcGRhdGUpIHtcclxuIFx0XHRcdFx0aWYoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGhvdFVwZGF0ZSwgaWQpKSB7XHJcbiBcdFx0XHRcdFx0b3V0ZGF0ZWRNb2R1bGVzLnB1c2godG9Nb2R1bGVJZChpZCkpO1xyXG4gXHRcdFx0XHR9XHJcbiBcdFx0XHR9XHJcbiBcdFx0XHRkZWZlcnJlZC5yZXNvbHZlKG91dGRhdGVkTW9kdWxlcyk7XHJcbiBcdFx0fVxyXG4gXHR9XHJcbiBcdFxyXG4gXHRmdW5jdGlvbiBob3RBcHBseShvcHRpb25zKSB7XHJcbiBcdFx0aWYoaG90U3RhdHVzICE9PSBcInJlYWR5XCIpIHRocm93IG5ldyBFcnJvcihcImFwcGx5KCkgaXMgb25seSBhbGxvd2VkIGluIHJlYWR5IHN0YXR1c1wiKTtcclxuIFx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuIFx0XHJcbiBcdFx0dmFyIGNiO1xyXG4gXHRcdHZhciBpO1xyXG4gXHRcdHZhciBqO1xyXG4gXHRcdHZhciBtb2R1bGU7XHJcbiBcdFx0dmFyIG1vZHVsZUlkO1xyXG4gXHRcclxuIFx0XHRmdW5jdGlvbiBnZXRBZmZlY3RlZFN0dWZmKHVwZGF0ZU1vZHVsZUlkKSB7XHJcbiBcdFx0XHR2YXIgb3V0ZGF0ZWRNb2R1bGVzID0gW3VwZGF0ZU1vZHVsZUlkXTtcclxuIFx0XHRcdHZhciBvdXRkYXRlZERlcGVuZGVuY2llcyA9IHt9O1xyXG4gXHRcclxuIFx0XHRcdHZhciBxdWV1ZSA9IG91dGRhdGVkTW9kdWxlcy5zbGljZSgpLm1hcChmdW5jdGlvbihpZCkge1xyXG4gXHRcdFx0XHRyZXR1cm4ge1xyXG4gXHRcdFx0XHRcdGNoYWluOiBbaWRdLFxyXG4gXHRcdFx0XHRcdGlkOiBpZFxyXG4gXHRcdFx0XHR9O1xyXG4gXHRcdFx0fSk7XHJcbiBcdFx0XHR3aGlsZShxdWV1ZS5sZW5ndGggPiAwKSB7XHJcbiBcdFx0XHRcdHZhciBxdWV1ZUl0ZW0gPSBxdWV1ZS5wb3AoKTtcclxuIFx0XHRcdFx0dmFyIG1vZHVsZUlkID0gcXVldWVJdGVtLmlkO1xyXG4gXHRcdFx0XHR2YXIgY2hhaW4gPSBxdWV1ZUl0ZW0uY2hhaW47XHJcbiBcdFx0XHRcdG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdO1xyXG4gXHRcdFx0XHRpZighbW9kdWxlIHx8IG1vZHVsZS5ob3QuX3NlbGZBY2NlcHRlZClcclxuIFx0XHRcdFx0XHRjb250aW51ZTtcclxuIFx0XHRcdFx0aWYobW9kdWxlLmhvdC5fc2VsZkRlY2xpbmVkKSB7XHJcbiBcdFx0XHRcdFx0cmV0dXJuIHtcclxuIFx0XHRcdFx0XHRcdHR5cGU6IFwic2VsZi1kZWNsaW5lZFwiLFxyXG4gXHRcdFx0XHRcdFx0Y2hhaW46IGNoYWluLFxyXG4gXHRcdFx0XHRcdFx0bW9kdWxlSWQ6IG1vZHVsZUlkXHJcbiBcdFx0XHRcdFx0fTtcclxuIFx0XHRcdFx0fVxyXG4gXHRcdFx0XHRpZihtb2R1bGUuaG90Ll9tYWluKSB7XHJcbiBcdFx0XHRcdFx0cmV0dXJuIHtcclxuIFx0XHRcdFx0XHRcdHR5cGU6IFwidW5hY2NlcHRlZFwiLFxyXG4gXHRcdFx0XHRcdFx0Y2hhaW46IGNoYWluLFxyXG4gXHRcdFx0XHRcdFx0bW9kdWxlSWQ6IG1vZHVsZUlkXHJcbiBcdFx0XHRcdFx0fTtcclxuIFx0XHRcdFx0fVxyXG4gXHRcdFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgbW9kdWxlLnBhcmVudHMubGVuZ3RoOyBpKyspIHtcclxuIFx0XHRcdFx0XHR2YXIgcGFyZW50SWQgPSBtb2R1bGUucGFyZW50c1tpXTtcclxuIFx0XHRcdFx0XHR2YXIgcGFyZW50ID0gaW5zdGFsbGVkTW9kdWxlc1twYXJlbnRJZF07XHJcbiBcdFx0XHRcdFx0aWYoIXBhcmVudCkgY29udGludWU7XHJcbiBcdFx0XHRcdFx0aWYocGFyZW50LmhvdC5fZGVjbGluZWREZXBlbmRlbmNpZXNbbW9kdWxlSWRdKSB7XHJcbiBcdFx0XHRcdFx0XHRyZXR1cm4ge1xyXG4gXHRcdFx0XHRcdFx0XHR0eXBlOiBcImRlY2xpbmVkXCIsXHJcbiBcdFx0XHRcdFx0XHRcdGNoYWluOiBjaGFpbi5jb25jYXQoW3BhcmVudElkXSksXHJcbiBcdFx0XHRcdFx0XHRcdG1vZHVsZUlkOiBtb2R1bGVJZCxcclxuIFx0XHRcdFx0XHRcdFx0cGFyZW50SWQ6IHBhcmVudElkXHJcbiBcdFx0XHRcdFx0XHR9O1xyXG4gXHRcdFx0XHRcdH1cclxuIFx0XHRcdFx0XHRpZihvdXRkYXRlZE1vZHVsZXMuaW5kZXhPZihwYXJlbnRJZCkgPj0gMCkgY29udGludWU7XHJcbiBcdFx0XHRcdFx0aWYocGFyZW50LmhvdC5fYWNjZXB0ZWREZXBlbmRlbmNpZXNbbW9kdWxlSWRdKSB7XHJcbiBcdFx0XHRcdFx0XHRpZighb3V0ZGF0ZWREZXBlbmRlbmNpZXNbcGFyZW50SWRdKVxyXG4gXHRcdFx0XHRcdFx0XHRvdXRkYXRlZERlcGVuZGVuY2llc1twYXJlbnRJZF0gPSBbXTtcclxuIFx0XHRcdFx0XHRcdGFkZEFsbFRvU2V0KG91dGRhdGVkRGVwZW5kZW5jaWVzW3BhcmVudElkXSwgW21vZHVsZUlkXSk7XHJcbiBcdFx0XHRcdFx0XHRjb250aW51ZTtcclxuIFx0XHRcdFx0XHR9XHJcbiBcdFx0XHRcdFx0ZGVsZXRlIG91dGRhdGVkRGVwZW5kZW5jaWVzW3BhcmVudElkXTtcclxuIFx0XHRcdFx0XHRvdXRkYXRlZE1vZHVsZXMucHVzaChwYXJlbnRJZCk7XHJcbiBcdFx0XHRcdFx0cXVldWUucHVzaCh7XHJcbiBcdFx0XHRcdFx0XHRjaGFpbjogY2hhaW4uY29uY2F0KFtwYXJlbnRJZF0pLFxyXG4gXHRcdFx0XHRcdFx0aWQ6IHBhcmVudElkXHJcbiBcdFx0XHRcdFx0fSk7XHJcbiBcdFx0XHRcdH1cclxuIFx0XHRcdH1cclxuIFx0XHJcbiBcdFx0XHRyZXR1cm4ge1xyXG4gXHRcdFx0XHR0eXBlOiBcImFjY2VwdGVkXCIsXHJcbiBcdFx0XHRcdG1vZHVsZUlkOiB1cGRhdGVNb2R1bGVJZCxcclxuIFx0XHRcdFx0b3V0ZGF0ZWRNb2R1bGVzOiBvdXRkYXRlZE1vZHVsZXMsXHJcbiBcdFx0XHRcdG91dGRhdGVkRGVwZW5kZW5jaWVzOiBvdXRkYXRlZERlcGVuZGVuY2llc1xyXG4gXHRcdFx0fTtcclxuIFx0XHR9XHJcbiBcdFxyXG4gXHRcdGZ1bmN0aW9uIGFkZEFsbFRvU2V0KGEsIGIpIHtcclxuIFx0XHRcdGZvcih2YXIgaSA9IDA7IGkgPCBiLmxlbmd0aDsgaSsrKSB7XHJcbiBcdFx0XHRcdHZhciBpdGVtID0gYltpXTtcclxuIFx0XHRcdFx0aWYoYS5pbmRleE9mKGl0ZW0pIDwgMClcclxuIFx0XHRcdFx0XHRhLnB1c2goaXRlbSk7XHJcbiBcdFx0XHR9XHJcbiBcdFx0fVxyXG4gXHRcclxuIFx0XHQvLyBhdCBiZWdpbiBhbGwgdXBkYXRlcyBtb2R1bGVzIGFyZSBvdXRkYXRlZFxyXG4gXHRcdC8vIHRoZSBcIm91dGRhdGVkXCIgc3RhdHVzIGNhbiBwcm9wYWdhdGUgdG8gcGFyZW50cyBpZiB0aGV5IGRvbid0IGFjY2VwdCB0aGUgY2hpbGRyZW5cclxuIFx0XHR2YXIgb3V0ZGF0ZWREZXBlbmRlbmNpZXMgPSB7fTtcclxuIFx0XHR2YXIgb3V0ZGF0ZWRNb2R1bGVzID0gW107XHJcbiBcdFx0dmFyIGFwcGxpZWRVcGRhdGUgPSB7fTtcclxuIFx0XHJcbiBcdFx0dmFyIHdhcm5VbmV4cGVjdGVkUmVxdWlyZSA9IGZ1bmN0aW9uIHdhcm5VbmV4cGVjdGVkUmVxdWlyZSgpIHtcclxuIFx0XHRcdGNvbnNvbGUud2FybihcIltITVJdIHVuZXhwZWN0ZWQgcmVxdWlyZShcIiArIHJlc3VsdC5tb2R1bGVJZCArIFwiKSB0byBkaXNwb3NlZCBtb2R1bGVcIik7XHJcbiBcdFx0fTtcclxuIFx0XHJcbiBcdFx0Zm9yKHZhciBpZCBpbiBob3RVcGRhdGUpIHtcclxuIFx0XHRcdGlmKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChob3RVcGRhdGUsIGlkKSkge1xyXG4gXHRcdFx0XHRtb2R1bGVJZCA9IHRvTW9kdWxlSWQoaWQpO1xyXG4gXHRcdFx0XHR2YXIgcmVzdWx0O1xyXG4gXHRcdFx0XHRpZihob3RVcGRhdGVbaWRdKSB7XHJcbiBcdFx0XHRcdFx0cmVzdWx0ID0gZ2V0QWZmZWN0ZWRTdHVmZihtb2R1bGVJZCk7XHJcbiBcdFx0XHRcdH0gZWxzZSB7XHJcbiBcdFx0XHRcdFx0cmVzdWx0ID0ge1xyXG4gXHRcdFx0XHRcdFx0dHlwZTogXCJkaXNwb3NlZFwiLFxyXG4gXHRcdFx0XHRcdFx0bW9kdWxlSWQ6IGlkXHJcbiBcdFx0XHRcdFx0fTtcclxuIFx0XHRcdFx0fVxyXG4gXHRcdFx0XHR2YXIgYWJvcnRFcnJvciA9IGZhbHNlO1xyXG4gXHRcdFx0XHR2YXIgZG9BcHBseSA9IGZhbHNlO1xyXG4gXHRcdFx0XHR2YXIgZG9EaXNwb3NlID0gZmFsc2U7XHJcbiBcdFx0XHRcdHZhciBjaGFpbkluZm8gPSBcIlwiO1xyXG4gXHRcdFx0XHRpZihyZXN1bHQuY2hhaW4pIHtcclxuIFx0XHRcdFx0XHRjaGFpbkluZm8gPSBcIlxcblVwZGF0ZSBwcm9wYWdhdGlvbjogXCIgKyByZXN1bHQuY2hhaW4uam9pbihcIiAtPiBcIik7XHJcbiBcdFx0XHRcdH1cclxuIFx0XHRcdFx0c3dpdGNoKHJlc3VsdC50eXBlKSB7XHJcbiBcdFx0XHRcdFx0Y2FzZSBcInNlbGYtZGVjbGluZWRcIjpcclxuIFx0XHRcdFx0XHRcdGlmKG9wdGlvbnMub25EZWNsaW5lZClcclxuIFx0XHRcdFx0XHRcdFx0b3B0aW9ucy5vbkRlY2xpbmVkKHJlc3VsdCk7XHJcbiBcdFx0XHRcdFx0XHRpZighb3B0aW9ucy5pZ25vcmVEZWNsaW5lZClcclxuIFx0XHRcdFx0XHRcdFx0YWJvcnRFcnJvciA9IG5ldyBFcnJvcihcIkFib3J0ZWQgYmVjYXVzZSBvZiBzZWxmIGRlY2xpbmU6IFwiICsgcmVzdWx0Lm1vZHVsZUlkICsgY2hhaW5JbmZvKTtcclxuIFx0XHRcdFx0XHRcdGJyZWFrO1xyXG4gXHRcdFx0XHRcdGNhc2UgXCJkZWNsaW5lZFwiOlxyXG4gXHRcdFx0XHRcdFx0aWYob3B0aW9ucy5vbkRlY2xpbmVkKVxyXG4gXHRcdFx0XHRcdFx0XHRvcHRpb25zLm9uRGVjbGluZWQocmVzdWx0KTtcclxuIFx0XHRcdFx0XHRcdGlmKCFvcHRpb25zLmlnbm9yZURlY2xpbmVkKVxyXG4gXHRcdFx0XHRcdFx0XHRhYm9ydEVycm9yID0gbmV3IEVycm9yKFwiQWJvcnRlZCBiZWNhdXNlIG9mIGRlY2xpbmVkIGRlcGVuZGVuY3k6IFwiICsgcmVzdWx0Lm1vZHVsZUlkICsgXCIgaW4gXCIgKyByZXN1bHQucGFyZW50SWQgKyBjaGFpbkluZm8pO1xyXG4gXHRcdFx0XHRcdFx0YnJlYWs7XHJcbiBcdFx0XHRcdFx0Y2FzZSBcInVuYWNjZXB0ZWRcIjpcclxuIFx0XHRcdFx0XHRcdGlmKG9wdGlvbnMub25VbmFjY2VwdGVkKVxyXG4gXHRcdFx0XHRcdFx0XHRvcHRpb25zLm9uVW5hY2NlcHRlZChyZXN1bHQpO1xyXG4gXHRcdFx0XHRcdFx0aWYoIW9wdGlvbnMuaWdub3JlVW5hY2NlcHRlZClcclxuIFx0XHRcdFx0XHRcdFx0YWJvcnRFcnJvciA9IG5ldyBFcnJvcihcIkFib3J0ZWQgYmVjYXVzZSBcIiArIG1vZHVsZUlkICsgXCIgaXMgbm90IGFjY2VwdGVkXCIgKyBjaGFpbkluZm8pO1xyXG4gXHRcdFx0XHRcdFx0YnJlYWs7XHJcbiBcdFx0XHRcdFx0Y2FzZSBcImFjY2VwdGVkXCI6XHJcbiBcdFx0XHRcdFx0XHRpZihvcHRpb25zLm9uQWNjZXB0ZWQpXHJcbiBcdFx0XHRcdFx0XHRcdG9wdGlvbnMub25BY2NlcHRlZChyZXN1bHQpO1xyXG4gXHRcdFx0XHRcdFx0ZG9BcHBseSA9IHRydWU7XHJcbiBcdFx0XHRcdFx0XHRicmVhaztcclxuIFx0XHRcdFx0XHRjYXNlIFwiZGlzcG9zZWRcIjpcclxuIFx0XHRcdFx0XHRcdGlmKG9wdGlvbnMub25EaXNwb3NlZClcclxuIFx0XHRcdFx0XHRcdFx0b3B0aW9ucy5vbkRpc3Bvc2VkKHJlc3VsdCk7XHJcbiBcdFx0XHRcdFx0XHRkb0Rpc3Bvc2UgPSB0cnVlO1xyXG4gXHRcdFx0XHRcdFx0YnJlYWs7XHJcbiBcdFx0XHRcdFx0ZGVmYXVsdDpcclxuIFx0XHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihcIlVuZXhjZXB0aW9uIHR5cGUgXCIgKyByZXN1bHQudHlwZSk7XHJcbiBcdFx0XHRcdH1cclxuIFx0XHRcdFx0aWYoYWJvcnRFcnJvcikge1xyXG4gXHRcdFx0XHRcdGhvdFNldFN0YXR1cyhcImFib3J0XCIpO1xyXG4gXHRcdFx0XHRcdHJldHVybiBQcm9taXNlLnJlamVjdChhYm9ydEVycm9yKTtcclxuIFx0XHRcdFx0fVxyXG4gXHRcdFx0XHRpZihkb0FwcGx5KSB7XHJcbiBcdFx0XHRcdFx0YXBwbGllZFVwZGF0ZVttb2R1bGVJZF0gPSBob3RVcGRhdGVbbW9kdWxlSWRdO1xyXG4gXHRcdFx0XHRcdGFkZEFsbFRvU2V0KG91dGRhdGVkTW9kdWxlcywgcmVzdWx0Lm91dGRhdGVkTW9kdWxlcyk7XHJcbiBcdFx0XHRcdFx0Zm9yKG1vZHVsZUlkIGluIHJlc3VsdC5vdXRkYXRlZERlcGVuZGVuY2llcykge1xyXG4gXHRcdFx0XHRcdFx0aWYoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHJlc3VsdC5vdXRkYXRlZERlcGVuZGVuY2llcywgbW9kdWxlSWQpKSB7XHJcbiBcdFx0XHRcdFx0XHRcdGlmKCFvdXRkYXRlZERlcGVuZGVuY2llc1ttb2R1bGVJZF0pXHJcbiBcdFx0XHRcdFx0XHRcdFx0b3V0ZGF0ZWREZXBlbmRlbmNpZXNbbW9kdWxlSWRdID0gW107XHJcbiBcdFx0XHRcdFx0XHRcdGFkZEFsbFRvU2V0KG91dGRhdGVkRGVwZW5kZW5jaWVzW21vZHVsZUlkXSwgcmVzdWx0Lm91dGRhdGVkRGVwZW5kZW5jaWVzW21vZHVsZUlkXSk7XHJcbiBcdFx0XHRcdFx0XHR9XHJcbiBcdFx0XHRcdFx0fVxyXG4gXHRcdFx0XHR9XHJcbiBcdFx0XHRcdGlmKGRvRGlzcG9zZSkge1xyXG4gXHRcdFx0XHRcdGFkZEFsbFRvU2V0KG91dGRhdGVkTW9kdWxlcywgW3Jlc3VsdC5tb2R1bGVJZF0pO1xyXG4gXHRcdFx0XHRcdGFwcGxpZWRVcGRhdGVbbW9kdWxlSWRdID0gd2FyblVuZXhwZWN0ZWRSZXF1aXJlO1xyXG4gXHRcdFx0XHR9XHJcbiBcdFx0XHR9XHJcbiBcdFx0fVxyXG4gXHRcclxuIFx0XHQvLyBTdG9yZSBzZWxmIGFjY2VwdGVkIG91dGRhdGVkIG1vZHVsZXMgdG8gcmVxdWlyZSB0aGVtIGxhdGVyIGJ5IHRoZSBtb2R1bGUgc3lzdGVtXHJcbiBcdFx0dmFyIG91dGRhdGVkU2VsZkFjY2VwdGVkTW9kdWxlcyA9IFtdO1xyXG4gXHRcdGZvcihpID0gMDsgaSA8IG91dGRhdGVkTW9kdWxlcy5sZW5ndGg7IGkrKykge1xyXG4gXHRcdFx0bW9kdWxlSWQgPSBvdXRkYXRlZE1vZHVsZXNbaV07XHJcbiBcdFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSAmJiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5ob3QuX3NlbGZBY2NlcHRlZClcclxuIFx0XHRcdFx0b3V0ZGF0ZWRTZWxmQWNjZXB0ZWRNb2R1bGVzLnB1c2goe1xyXG4gXHRcdFx0XHRcdG1vZHVsZTogbW9kdWxlSWQsXHJcbiBcdFx0XHRcdFx0ZXJyb3JIYW5kbGVyOiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5ob3QuX3NlbGZBY2NlcHRlZFxyXG4gXHRcdFx0XHR9KTtcclxuIFx0XHR9XHJcbiBcdFxyXG4gXHRcdC8vIE5vdyBpbiBcImRpc3Bvc2VcIiBwaGFzZVxyXG4gXHRcdGhvdFNldFN0YXR1cyhcImRpc3Bvc2VcIik7XHJcbiBcdFx0T2JqZWN0LmtleXMoaG90QXZhaWxhYmxlRmlsZXNNYXApLmZvckVhY2goZnVuY3Rpb24oY2h1bmtJZCkge1xyXG4gXHRcdFx0aWYoaG90QXZhaWxhYmxlRmlsZXNNYXBbY2h1bmtJZF0gPT09IGZhbHNlKSB7XHJcbiBcdFx0XHRcdGhvdERpc3Bvc2VDaHVuayhjaHVua0lkKTtcclxuIFx0XHRcdH1cclxuIFx0XHR9KTtcclxuIFx0XHJcbiBcdFx0dmFyIGlkeDtcclxuIFx0XHR2YXIgcXVldWUgPSBvdXRkYXRlZE1vZHVsZXMuc2xpY2UoKTtcclxuIFx0XHR3aGlsZShxdWV1ZS5sZW5ndGggPiAwKSB7XHJcbiBcdFx0XHRtb2R1bGVJZCA9IHF1ZXVlLnBvcCgpO1xyXG4gXHRcdFx0bW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF07XHJcbiBcdFx0XHRpZighbW9kdWxlKSBjb250aW51ZTtcclxuIFx0XHJcbiBcdFx0XHR2YXIgZGF0YSA9IHt9O1xyXG4gXHRcclxuIFx0XHRcdC8vIENhbGwgZGlzcG9zZSBoYW5kbGVyc1xyXG4gXHRcdFx0dmFyIGRpc3Bvc2VIYW5kbGVycyA9IG1vZHVsZS5ob3QuX2Rpc3Bvc2VIYW5kbGVycztcclxuIFx0XHRcdGZvcihqID0gMDsgaiA8IGRpc3Bvc2VIYW5kbGVycy5sZW5ndGg7IGorKykge1xyXG4gXHRcdFx0XHRjYiA9IGRpc3Bvc2VIYW5kbGVyc1tqXTtcclxuIFx0XHRcdFx0Y2IoZGF0YSk7XHJcbiBcdFx0XHR9XHJcbiBcdFx0XHRob3RDdXJyZW50TW9kdWxlRGF0YVttb2R1bGVJZF0gPSBkYXRhO1xyXG4gXHRcclxuIFx0XHRcdC8vIGRpc2FibGUgbW9kdWxlICh0aGlzIGRpc2FibGVzIHJlcXVpcmVzIGZyb20gdGhpcyBtb2R1bGUpXHJcbiBcdFx0XHRtb2R1bGUuaG90LmFjdGl2ZSA9IGZhbHNlO1xyXG4gXHRcclxuIFx0XHRcdC8vIHJlbW92ZSBtb2R1bGUgZnJvbSBjYWNoZVxyXG4gXHRcdFx0ZGVsZXRlIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdO1xyXG4gXHRcclxuIFx0XHRcdC8vIHdoZW4gZGlzcG9zaW5nIHRoZXJlIGlzIG5vIG5lZWQgdG8gY2FsbCBkaXNwb3NlIGhhbmRsZXJcclxuIFx0XHRcdGRlbGV0ZSBvdXRkYXRlZERlcGVuZGVuY2llc1ttb2R1bGVJZF07XHJcbiBcdFxyXG4gXHRcdFx0Ly8gcmVtb3ZlIFwicGFyZW50c1wiIHJlZmVyZW5jZXMgZnJvbSBhbGwgY2hpbGRyZW5cclxuIFx0XHRcdGZvcihqID0gMDsgaiA8IG1vZHVsZS5jaGlsZHJlbi5sZW5ndGg7IGorKykge1xyXG4gXHRcdFx0XHR2YXIgY2hpbGQgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZS5jaGlsZHJlbltqXV07XHJcbiBcdFx0XHRcdGlmKCFjaGlsZCkgY29udGludWU7XHJcbiBcdFx0XHRcdGlkeCA9IGNoaWxkLnBhcmVudHMuaW5kZXhPZihtb2R1bGVJZCk7XHJcbiBcdFx0XHRcdGlmKGlkeCA+PSAwKSB7XHJcbiBcdFx0XHRcdFx0Y2hpbGQucGFyZW50cy5zcGxpY2UoaWR4LCAxKTtcclxuIFx0XHRcdFx0fVxyXG4gXHRcdFx0fVxyXG4gXHRcdH1cclxuIFx0XHJcbiBcdFx0Ly8gcmVtb3ZlIG91dGRhdGVkIGRlcGVuZGVuY3kgZnJvbSBtb2R1bGUgY2hpbGRyZW5cclxuIFx0XHR2YXIgZGVwZW5kZW5jeTtcclxuIFx0XHR2YXIgbW9kdWxlT3V0ZGF0ZWREZXBlbmRlbmNpZXM7XHJcbiBcdFx0Zm9yKG1vZHVsZUlkIGluIG91dGRhdGVkRGVwZW5kZW5jaWVzKSB7XHJcbiBcdFx0XHRpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob3V0ZGF0ZWREZXBlbmRlbmNpZXMsIG1vZHVsZUlkKSkge1xyXG4gXHRcdFx0XHRtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXTtcclxuIFx0XHRcdFx0aWYobW9kdWxlKSB7XHJcbiBcdFx0XHRcdFx0bW9kdWxlT3V0ZGF0ZWREZXBlbmRlbmNpZXMgPSBvdXRkYXRlZERlcGVuZGVuY2llc1ttb2R1bGVJZF07XHJcbiBcdFx0XHRcdFx0Zm9yKGogPSAwOyBqIDwgbW9kdWxlT3V0ZGF0ZWREZXBlbmRlbmNpZXMubGVuZ3RoOyBqKyspIHtcclxuIFx0XHRcdFx0XHRcdGRlcGVuZGVuY3kgPSBtb2R1bGVPdXRkYXRlZERlcGVuZGVuY2llc1tqXTtcclxuIFx0XHRcdFx0XHRcdGlkeCA9IG1vZHVsZS5jaGlsZHJlbi5pbmRleE9mKGRlcGVuZGVuY3kpO1xyXG4gXHRcdFx0XHRcdFx0aWYoaWR4ID49IDApIG1vZHVsZS5jaGlsZHJlbi5zcGxpY2UoaWR4LCAxKTtcclxuIFx0XHRcdFx0XHR9XHJcbiBcdFx0XHRcdH1cclxuIFx0XHRcdH1cclxuIFx0XHR9XHJcbiBcdFxyXG4gXHRcdC8vIE5vdCBpbiBcImFwcGx5XCIgcGhhc2VcclxuIFx0XHRob3RTZXRTdGF0dXMoXCJhcHBseVwiKTtcclxuIFx0XHJcbiBcdFx0aG90Q3VycmVudEhhc2ggPSBob3RVcGRhdGVOZXdIYXNoO1xyXG4gXHRcclxuIFx0XHQvLyBpbnNlcnQgbmV3IGNvZGVcclxuIFx0XHRmb3IobW9kdWxlSWQgaW4gYXBwbGllZFVwZGF0ZSkge1xyXG4gXHRcdFx0aWYoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGFwcGxpZWRVcGRhdGUsIG1vZHVsZUlkKSkge1xyXG4gXHRcdFx0XHRtb2R1bGVzW21vZHVsZUlkXSA9IGFwcGxpZWRVcGRhdGVbbW9kdWxlSWRdO1xyXG4gXHRcdFx0fVxyXG4gXHRcdH1cclxuIFx0XHJcbiBcdFx0Ly8gY2FsbCBhY2NlcHQgaGFuZGxlcnNcclxuIFx0XHR2YXIgZXJyb3IgPSBudWxsO1xyXG4gXHRcdGZvcihtb2R1bGVJZCBpbiBvdXRkYXRlZERlcGVuZGVuY2llcykge1xyXG4gXHRcdFx0aWYoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG91dGRhdGVkRGVwZW5kZW5jaWVzLCBtb2R1bGVJZCkpIHtcclxuIFx0XHRcdFx0bW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF07XHJcbiBcdFx0XHRcdGlmKG1vZHVsZSkge1xyXG4gXHRcdFx0XHRcdG1vZHVsZU91dGRhdGVkRGVwZW5kZW5jaWVzID0gb3V0ZGF0ZWREZXBlbmRlbmNpZXNbbW9kdWxlSWRdO1xyXG4gXHRcdFx0XHRcdHZhciBjYWxsYmFja3MgPSBbXTtcclxuIFx0XHRcdFx0XHRmb3IoaSA9IDA7IGkgPCBtb2R1bGVPdXRkYXRlZERlcGVuZGVuY2llcy5sZW5ndGg7IGkrKykge1xyXG4gXHRcdFx0XHRcdFx0ZGVwZW5kZW5jeSA9IG1vZHVsZU91dGRhdGVkRGVwZW5kZW5jaWVzW2ldO1xyXG4gXHRcdFx0XHRcdFx0Y2IgPSBtb2R1bGUuaG90Ll9hY2NlcHRlZERlcGVuZGVuY2llc1tkZXBlbmRlbmN5XTtcclxuIFx0XHRcdFx0XHRcdGlmKGNiKSB7XHJcbiBcdFx0XHRcdFx0XHRcdGlmKGNhbGxiYWNrcy5pbmRleE9mKGNiKSA+PSAwKSBjb250aW51ZTtcclxuIFx0XHRcdFx0XHRcdFx0Y2FsbGJhY2tzLnB1c2goY2IpO1xyXG4gXHRcdFx0XHRcdFx0fVxyXG4gXHRcdFx0XHRcdH1cclxuIFx0XHRcdFx0XHRmb3IoaSA9IDA7IGkgPCBjYWxsYmFja3MubGVuZ3RoOyBpKyspIHtcclxuIFx0XHRcdFx0XHRcdGNiID0gY2FsbGJhY2tzW2ldO1xyXG4gXHRcdFx0XHRcdFx0dHJ5IHtcclxuIFx0XHRcdFx0XHRcdFx0Y2IobW9kdWxlT3V0ZGF0ZWREZXBlbmRlbmNpZXMpO1xyXG4gXHRcdFx0XHRcdFx0fSBjYXRjaChlcnIpIHtcclxuIFx0XHRcdFx0XHRcdFx0aWYob3B0aW9ucy5vbkVycm9yZWQpIHtcclxuIFx0XHRcdFx0XHRcdFx0XHRvcHRpb25zLm9uRXJyb3JlZCh7XHJcbiBcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImFjY2VwdC1lcnJvcmVkXCIsXHJcbiBcdFx0XHRcdFx0XHRcdFx0XHRtb2R1bGVJZDogbW9kdWxlSWQsXHJcbiBcdFx0XHRcdFx0XHRcdFx0XHRkZXBlbmRlbmN5SWQ6IG1vZHVsZU91dGRhdGVkRGVwZW5kZW5jaWVzW2ldLFxyXG4gXHRcdFx0XHRcdFx0XHRcdFx0ZXJyb3I6IGVyclxyXG4gXHRcdFx0XHRcdFx0XHRcdH0pO1xyXG4gXHRcdFx0XHRcdFx0XHR9XHJcbiBcdFx0XHRcdFx0XHRcdGlmKCFvcHRpb25zLmlnbm9yZUVycm9yZWQpIHtcclxuIFx0XHRcdFx0XHRcdFx0XHRpZighZXJyb3IpXHJcbiBcdFx0XHRcdFx0XHRcdFx0XHRlcnJvciA9IGVycjtcclxuIFx0XHRcdFx0XHRcdFx0fVxyXG4gXHRcdFx0XHRcdFx0fVxyXG4gXHRcdFx0XHRcdH1cclxuIFx0XHRcdFx0fVxyXG4gXHRcdFx0fVxyXG4gXHRcdH1cclxuIFx0XHJcbiBcdFx0Ly8gTG9hZCBzZWxmIGFjY2VwdGVkIG1vZHVsZXNcclxuIFx0XHRmb3IoaSA9IDA7IGkgPCBvdXRkYXRlZFNlbGZBY2NlcHRlZE1vZHVsZXMubGVuZ3RoOyBpKyspIHtcclxuIFx0XHRcdHZhciBpdGVtID0gb3V0ZGF0ZWRTZWxmQWNjZXB0ZWRNb2R1bGVzW2ldO1xyXG4gXHRcdFx0bW9kdWxlSWQgPSBpdGVtLm1vZHVsZTtcclxuIFx0XHRcdGhvdEN1cnJlbnRQYXJlbnRzID0gW21vZHVsZUlkXTtcclxuIFx0XHRcdHRyeSB7XHJcbiBcdFx0XHRcdF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpO1xyXG4gXHRcdFx0fSBjYXRjaChlcnIpIHtcclxuIFx0XHRcdFx0aWYodHlwZW9mIGl0ZW0uZXJyb3JIYW5kbGVyID09PSBcImZ1bmN0aW9uXCIpIHtcclxuIFx0XHRcdFx0XHR0cnkge1xyXG4gXHRcdFx0XHRcdFx0aXRlbS5lcnJvckhhbmRsZXIoZXJyKTtcclxuIFx0XHRcdFx0XHR9IGNhdGNoKGVycjIpIHtcclxuIFx0XHRcdFx0XHRcdGlmKG9wdGlvbnMub25FcnJvcmVkKSB7XHJcbiBcdFx0XHRcdFx0XHRcdG9wdGlvbnMub25FcnJvcmVkKHtcclxuIFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInNlbGYtYWNjZXB0LWVycm9yLWhhbmRsZXItZXJyb3JlZFwiLFxyXG4gXHRcdFx0XHRcdFx0XHRcdG1vZHVsZUlkOiBtb2R1bGVJZCxcclxuIFx0XHRcdFx0XHRcdFx0XHRlcnJvcjogZXJyMixcclxuIFx0XHRcdFx0XHRcdFx0XHRvcmdpbmFsRXJyb3I6IGVyciwgLy8gVE9ETyByZW1vdmUgaW4gd2VicGFjayA0XHJcbiBcdFx0XHRcdFx0XHRcdFx0b3JpZ2luYWxFcnJvcjogZXJyXHJcbiBcdFx0XHRcdFx0XHRcdH0pO1xyXG4gXHRcdFx0XHRcdFx0fVxyXG4gXHRcdFx0XHRcdFx0aWYoIW9wdGlvbnMuaWdub3JlRXJyb3JlZCkge1xyXG4gXHRcdFx0XHRcdFx0XHRpZighZXJyb3IpXHJcbiBcdFx0XHRcdFx0XHRcdFx0ZXJyb3IgPSBlcnIyO1xyXG4gXHRcdFx0XHRcdFx0fVxyXG4gXHRcdFx0XHRcdFx0aWYoIWVycm9yKVxyXG4gXHRcdFx0XHRcdFx0XHRlcnJvciA9IGVycjtcclxuIFx0XHRcdFx0XHR9XHJcbiBcdFx0XHRcdH0gZWxzZSB7XHJcbiBcdFx0XHRcdFx0aWYob3B0aW9ucy5vbkVycm9yZWQpIHtcclxuIFx0XHRcdFx0XHRcdG9wdGlvbnMub25FcnJvcmVkKHtcclxuIFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzZWxmLWFjY2VwdC1lcnJvcmVkXCIsXHJcbiBcdFx0XHRcdFx0XHRcdG1vZHVsZUlkOiBtb2R1bGVJZCxcclxuIFx0XHRcdFx0XHRcdFx0ZXJyb3I6IGVyclxyXG4gXHRcdFx0XHRcdFx0fSk7XHJcbiBcdFx0XHRcdFx0fVxyXG4gXHRcdFx0XHRcdGlmKCFvcHRpb25zLmlnbm9yZUVycm9yZWQpIHtcclxuIFx0XHRcdFx0XHRcdGlmKCFlcnJvcilcclxuIFx0XHRcdFx0XHRcdFx0ZXJyb3IgPSBlcnI7XHJcbiBcdFx0XHRcdFx0fVxyXG4gXHRcdFx0XHR9XHJcbiBcdFx0XHR9XHJcbiBcdFx0fVxyXG4gXHRcclxuIFx0XHQvLyBoYW5kbGUgZXJyb3JzIGluIGFjY2VwdCBoYW5kbGVycyBhbmQgc2VsZiBhY2NlcHRlZCBtb2R1bGUgbG9hZFxyXG4gXHRcdGlmKGVycm9yKSB7XHJcbiBcdFx0XHRob3RTZXRTdGF0dXMoXCJmYWlsXCIpO1xyXG4gXHRcdFx0cmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcclxuIFx0XHR9XHJcbiBcdFxyXG4gXHRcdGhvdFNldFN0YXR1cyhcImlkbGVcIik7XHJcbiBcdFx0cmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUpIHtcclxuIFx0XHRcdHJlc29sdmUob3V0ZGF0ZWRNb2R1bGVzKTtcclxuIFx0XHR9KTtcclxuIFx0fVxyXG5cbiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4gXHRcdH1cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGk6IG1vZHVsZUlkLFxuIFx0XHRcdGw6IGZhbHNlLFxuIFx0XHRcdGV4cG9ydHM6IHt9LFxuIFx0XHRcdGhvdDogaG90Q3JlYXRlTW9kdWxlKG1vZHVsZUlkKSxcbiBcdFx0XHRwYXJlbnRzOiAoaG90Q3VycmVudFBhcmVudHNUZW1wID0gaG90Q3VycmVudFBhcmVudHMsIGhvdEN1cnJlbnRQYXJlbnRzID0gW10sIGhvdEN1cnJlbnRQYXJlbnRzVGVtcCksXG4gXHRcdFx0Y2hpbGRyZW46IFtdXG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIGhvdENyZWF0ZVJlcXVpcmUobW9kdWxlSWQpKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHtcbiBcdFx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gXHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuIFx0XHRcdFx0Z2V0OiBnZXR0ZXJcbiBcdFx0XHR9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuIFx0Ly8gX193ZWJwYWNrX2hhc2hfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5oID0gZnVuY3Rpb24oKSB7IHJldHVybiBob3RDdXJyZW50SGFzaDsgfTtcblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gaG90Q3JlYXRlUmVxdWlyZShcIi4vc3JjL2luZGV4LnRzXCIpKF9fd2VicGFja19yZXF1aXJlX18ucyA9IFwiLi9zcmMvaW5kZXgudHNcIik7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjay9ib290c3RyYXAgOTI0MDZiOGIxMzAxNmNjMTRmNTYiLCJcInVzZSBzdHJpY3RcIjtcblxucmVxdWlyZShcImNvcmUtanMvc2hpbVwiKTtcblxucmVxdWlyZShcInJlZ2VuZXJhdG9yLXJ1bnRpbWUvcnVudGltZVwiKTtcblxuaWYgKGdsb2JhbC5fYmFiZWxQb2x5ZmlsbCkge1xuICB0aHJvdyBuZXcgRXJyb3IoXCJvbmx5IG9uZSBpbnN0YW5jZSBvZiBAYmFiZWwvcG9seWZpbGwgaXMgYWxsb3dlZFwiKTtcbn1cblxuZ2xvYmFsLl9iYWJlbFBvbHlmaWxsID0gdHJ1ZTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvQGJhYmVsL3BvbHlmaWxsL2xpYi9pbmRleC5qcyIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IEl0ZXJhYmxlcyA9IHJlcXVpcmUoXCIuL2l0ZXJhYmxlL29wZXJhdG9yc1wiKTtcclxuZXhwb3J0cy5JdGVyYWJsZXMgPSBJdGVyYWJsZXM7XHJcbmNvbnN0IEdlbmVyYXRvcnMgPSByZXF1aXJlKFwiLi9pdGVyYWJsZS9nZW5lcmF0b3JzXCIpO1xyXG5leHBvcnRzLkdlbmVyYXRvcnMgPSBHZW5lcmF0b3JzO1xyXG5jb25zdCBwaXBlXzEgPSByZXF1aXJlKFwiLi9waXBlXCIpO1xyXG5leHBvcnRzLiQkID0gcGlwZV8xLiQkO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvQG1vcmxleWRldi9mdW5jdGlvbmFsLXBpcGUvaW5kZXguanMiLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5mdW5jdGlvbiogcmFuZ2Uoc3RhcnQsIGNvdW50KSB7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50OyArK2kpIHtcclxuICAgICAgICB5aWVsZCBzdGFydCArIGk7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5yYW5nZSA9IHJhbmdlO1xyXG5mdW5jdGlvbiogaW5maW5pdGUoKSB7XHJcbiAgICBmb3IgKGxldCBpID0gMDs7ICsraSkge1xyXG4gICAgICAgIHlpZWxkIGk7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5pbmZpbml0ZSA9IGluZmluaXRlO1xyXG5mdW5jdGlvbiogZW1wdHkoKSB7IH1cclxuZXhwb3J0cy5lbXB0eSA9IGVtcHR5O1xyXG5mdW5jdGlvbiogY29uY2F0KC4uLml0ZXJhYmxlcykge1xyXG4gICAgZm9yIChjb25zdCBpdGVyYWJsZSBvZiBpdGVyYWJsZXMpIHtcclxuICAgICAgICB5aWVsZCogaXRlcmFibGU7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5jb25jYXQgPSBjb25jYXQ7XHJcbmZ1bmN0aW9uKiBrZXlzKGl0ZW0pIHtcclxuICAgIGZvciAoY29uc3Qga2V5IGluIGl0ZW0pIHtcclxuICAgICAgICB5aWVsZCBrZXk7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5rZXlzID0ga2V5cztcclxuZnVuY3Rpb24qIHZhbHVlcyhpdGVtKSB7XHJcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBpdGVtKSB7XHJcbiAgICAgICAgeWllbGQgaXRlbVtrZXldO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMudmFsdWVzID0gdmFsdWVzO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1nZW5lcmF0b3JzLmpzLm1hcFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9AbW9ybGV5ZGV2L2Z1bmN0aW9uYWwtcGlwZS9pdGVyYWJsZS9nZW5lcmF0b3JzLmpzIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuZnVuY3Rpb24qIHVuaXQoaXRlcmFibGUpIHtcclxuICAgIHJldHVybiB5aWVsZCogaXRlcmFibGU7XHJcbn1cclxuZXhwb3J0cy51bml0ID0gdW5pdDtcclxuZnVuY3Rpb24gdGFwKHRhcHBlcikge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uKiAoaXQpIHtcclxuICAgICAgICBsZXQgaW5kZXggPSAwO1xyXG4gICAgICAgIGZvciAoY29uc3QgdmFsdWUgb2YgaXQpIHtcclxuICAgICAgICAgICAgdGFwcGVyKHZhbHVlLCBpbmRleCk7XHJcbiAgICAgICAgICAgIHlpZWxkIHZhbHVlO1xyXG4gICAgICAgICAgICBpbmRleCA9IGluZGV4ICsgMTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59XHJcbmV4cG9ydHMudGFwID0gdGFwO1xyXG5mdW5jdGlvbiBtYXAobWFwcGVyKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24qIChpdGVyYWJsZSkge1xyXG4gICAgICAgIGxldCBpbmRleCA9IDA7XHJcbiAgICAgICAgZm9yIChjb25zdCB2YWx1ZSBvZiBpdGVyYWJsZSkge1xyXG4gICAgICAgICAgICB5aWVsZCBtYXBwZXIodmFsdWUsIGluZGV4KTtcclxuICAgICAgICAgICAgaW5kZXggPSBpbmRleCArIDE7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufVxyXG5leHBvcnRzLm1hcCA9IG1hcDtcclxuZnVuY3Rpb24gZmxhdE1hcChtYXBwZXIpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiogKGl0ZXJhYmxlKSB7XHJcbiAgICAgICAgbGV0IGluZGV4ID0gMDtcclxuICAgICAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIGl0ZXJhYmxlKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGlubmVySXRlcmFibGUgPSBtYXBwZXIodmFsdWUsIGluZGV4KTtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBpbm5lciBvZiBpbm5lckl0ZXJhYmxlKSB7XHJcbiAgICAgICAgICAgICAgICB5aWVsZCBpbm5lcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpbmRleCA9IGluZGV4ICsgMTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59XHJcbmV4cG9ydHMuZmxhdE1hcCA9IGZsYXRNYXA7XHJcbmZ1bmN0aW9uIGZpbHRlcihwcmVkaWNhdGUpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiogKGl0ZXJhYmxlKSB7XHJcbiAgICAgICAgbGV0IGluZGV4ID0gMDtcclxuICAgICAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIGl0ZXJhYmxlKSB7XHJcbiAgICAgICAgICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIGluZGV4KSkge1xyXG4gICAgICAgICAgICAgICAgeWllbGQgdmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaW5kZXggPSBpbmRleCArIDE7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufVxyXG5leHBvcnRzLmZpbHRlciA9IGZpbHRlcjtcclxuZnVuY3Rpb24gcmVkdWNlKHByZWRpY2F0ZSwgaW5pdGlhbCkge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChpdGVyYWJsZSkge1xyXG4gICAgICAgIGxldCBpbmRleCA9IDA7XHJcbiAgICAgICAgbGV0IHByZXZTdGF0ZSA9IGluaXRpYWw7XHJcbiAgICAgICAgZm9yIChjb25zdCB2YWx1ZSBvZiBpdGVyYWJsZSkge1xyXG4gICAgICAgICAgICBwcmV2U3RhdGUgPSBwcmVkaWNhdGUocHJldlN0YXRlLCB2YWx1ZSwgaW5kZXgpO1xyXG4gICAgICAgICAgICBpbmRleCA9IGluZGV4ICsgMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHByZXZTdGF0ZTtcclxuICAgIH07XHJcbn1cclxuZXhwb3J0cy5yZWR1Y2UgPSByZWR1Y2U7XHJcbmZ1bmN0aW9uIHNjYW4ocHJlZGljYXRlLCBpbml0aWFsKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24qIChpdGVyYWJsZSkge1xyXG4gICAgICAgIGxldCBpbmRleCA9IDA7XHJcbiAgICAgICAgbGV0IHByZXZTdGF0ZSA9IGluaXRpYWw7XHJcbiAgICAgICAgZm9yIChjb25zdCB2YWx1ZSBvZiBpdGVyYWJsZSkge1xyXG4gICAgICAgICAgICBwcmV2U3RhdGUgPSBwcmVkaWNhdGUocHJldlN0YXRlLCB2YWx1ZSwgaW5kZXgpO1xyXG4gICAgICAgICAgICB5aWVsZCBwcmV2U3RhdGU7XHJcbiAgICAgICAgICAgIGluZGV4ID0gaW5kZXggKyAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcHJldlN0YXRlO1xyXG4gICAgfTtcclxufVxyXG5leHBvcnRzLnNjYW4gPSBzY2FuO1xyXG5mdW5jdGlvbiBmb2xkKHByZWRpY2F0ZSkge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChpdGVyYWJsZSkge1xyXG4gICAgICAgIGNvbnN0IFtoZWFkLCAuLi50YWlsXSA9IEFycmF5LmZyb20oaXRlcmFibGUpO1xyXG4gICAgICAgIHJldHVybiByZWR1Y2UocHJlZGljYXRlLCBoZWFkKSh0YWlsKTtcclxuICAgIH07XHJcbn1cclxuZXhwb3J0cy5mb2xkID0gZm9sZDtcclxuZnVuY3Rpb24gdGFrZShjb3VudCkge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uKiAoaXRlcmFibGUpIHtcclxuICAgICAgICBsZXQgaSA9IDA7XHJcbiAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIGl0ZXJhYmxlKSB7XHJcbiAgICAgICAgICAgIGlmIChpID49IGNvdW50KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgeWllbGQgaXRlbTtcclxuICAgICAgICAgICAgaSA9IGkgKyAxO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn1cclxuZXhwb3J0cy50YWtlID0gdGFrZTtcclxuZnVuY3Rpb24gbGFzdChpdGVyYWJsZSkge1xyXG4gICAgbGV0IGxhc3QgPSB1bmRlZmluZWQ7XHJcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgaXRlcmFibGUpIHtcclxuICAgICAgICBsYXN0ID0gaXRlbTtcclxuICAgIH1cclxuICAgIHJldHVybiBsYXN0O1xyXG59XHJcbmV4cG9ydHMubGFzdCA9IGxhc3Q7XHJcbmZ1bmN0aW9uIGZpcnN0KGl0ZXJhYmxlKSB7XHJcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgaXRlcmFibGUpIHtcclxuICAgICAgICByZXR1cm4gaXRlbTtcclxuICAgIH1cclxuICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbn1cclxuZXhwb3J0cy5maXJzdCA9IGZpcnN0O1xyXG5mdW5jdGlvbiBza2lwKGNvdW50KSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24qIChpdGVyYWJsZSkge1xyXG4gICAgICAgIGxldCBpID0gMDtcclxuICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgaXRlcmFibGUpIHtcclxuICAgICAgICAgICAgaWYgKGkgPj0gY291bnQpIHtcclxuICAgICAgICAgICAgICAgIHlpZWxkIGl0ZW07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaSA9IGkgKyAxO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn1cclxuZXhwb3J0cy5za2lwID0gc2tpcDtcclxuZnVuY3Rpb24gdGFrZVdoaWxlKHByZWRpY2F0ZSkge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uKiAoaXRlcmFibGUpIHtcclxuICAgICAgICBsZXQgaSA9IDA7XHJcbiAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIGl0ZXJhYmxlKSB7XHJcbiAgICAgICAgICAgIGlmICghcHJlZGljYXRlKGl0ZW0sIGkpKSB7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB5aWVsZCBpdGVtO1xyXG4gICAgICAgICAgICBpID0gaSArIDE7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufVxyXG5leHBvcnRzLnRha2VXaGlsZSA9IHRha2VXaGlsZTtcclxuZnVuY3Rpb24gdGFrZVVudGlsKHByZWRpY2F0ZSkge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uKiAoaXRlcmFibGUpIHtcclxuICAgICAgICBsZXQgaSA9IDA7XHJcbiAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIGl0ZXJhYmxlKSB7XHJcbiAgICAgICAgICAgIGlmIChwcmVkaWNhdGUoaXRlbSwgaSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB5aWVsZCBpdGVtO1xyXG4gICAgICAgICAgICBpID0gaSArIDE7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufVxyXG5leHBvcnRzLnRha2VVbnRpbCA9IHRha2VVbnRpbDtcclxuZnVuY3Rpb24gc2tpcFdoaWxlKHByZWRpY2F0ZSkge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uKiAoaXRlcmFibGUpIHtcclxuICAgICAgICBsZXQgaSA9IDA7XHJcbiAgICAgICAgbGV0IGNhblJldHVybiA9IGZhbHNlO1xyXG4gICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBpdGVyYWJsZSkge1xyXG4gICAgICAgICAgICBpZiAoIWNhblJldHVybikge1xyXG4gICAgICAgICAgICAgICAgY2FuUmV0dXJuID0gIXByZWRpY2F0ZShpdGVtLCBpKTtcclxuICAgICAgICAgICAgICAgIGlmIChjYW5SZXR1cm4pIHtcclxuICAgICAgICAgICAgICAgICAgICB5aWVsZCBpdGVtO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaSA9IGkgKyAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgeWllbGQgaXRlbTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn1cclxuZXhwb3J0cy5za2lwV2hpbGUgPSBza2lwV2hpbGU7XHJcbmZ1bmN0aW9uIHNraXBVbnRpbChwcmVkaWNhdGUpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiogKGl0ZXJhYmxlKSB7XHJcbiAgICAgICAgbGV0IGkgPSAwO1xyXG4gICAgICAgIGxldCBjYW5SZXR1cm4gPSBmYWxzZTtcclxuICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgaXRlcmFibGUpIHtcclxuICAgICAgICAgICAgaWYgKCFjYW5SZXR1cm4pIHtcclxuICAgICAgICAgICAgICAgIGNhblJldHVybiA9IHByZWRpY2F0ZShpdGVtLCBpKTtcclxuICAgICAgICAgICAgICAgIGlmIChjYW5SZXR1cm4pIHtcclxuICAgICAgICAgICAgICAgICAgICB5aWVsZCBpdGVtO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaSA9IGkgKyAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgeWllbGQgaXRlbTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn1cclxuZXhwb3J0cy5za2lwVW50aWwgPSBza2lwVW50aWw7XHJcbmZ1bmN0aW9uIGNvbmNhdCguLi5pdGVyYWJsZXMpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiogKGl0KSB7XHJcbiAgICAgICAgeWllbGQqIGl0O1xyXG4gICAgICAgIGZvciAoY29uc3QgaXRlcmFibGUgb2YgaXRlcmFibGVzKVxyXG4gICAgICAgICAgICB5aWVsZCogaXRlcmFibGU7XHJcbiAgICB9O1xyXG59XHJcbmV4cG9ydHMuY29uY2F0ID0gY29uY2F0O1xyXG5mdW5jdGlvbiBwdXNoKC4uLm5leHQpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiogKGl0KSB7XHJcbiAgICAgICAgeWllbGQqIGl0O1xyXG4gICAgICAgIGZvciAoY29uc3QgaXRlcmFibGUgb2YgbmV4dClcclxuICAgICAgICAgICAgeWllbGQgaXRlcmFibGU7XHJcbiAgICB9O1xyXG59XHJcbmV4cG9ydHMucHVzaCA9IHB1c2g7XHJcbmZ1bmN0aW9uIHVuc2hpZnQoLi4ubmV4dCkge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uKiAoaXQpIHtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5leHQubGVuZ3RoOyArK2kpXHJcbiAgICAgICAgICAgIHlpZWxkIG5leHRbbmV4dC5sZW5ndGggLSBpIC0gMV07XHJcbiAgICAgICAgeWllbGQqIGl0O1xyXG4gICAgfTtcclxufVxyXG5leHBvcnRzLnVuc2hpZnQgPSB1bnNoaWZ0O1xyXG5mdW5jdGlvbiBzb21lKHByZWRpY2F0ZSkge1xyXG4gICAgcmV0dXJuIGl0ID0+IHtcclxuICAgICAgICBsZXQgaSA9IDA7XHJcbiAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIGl0KSB7XHJcbiAgICAgICAgICAgIGlmIChwcmVkaWNhdGUoaXRlbSwgaSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGkgPSBpICsgMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfTtcclxufVxyXG5leHBvcnRzLnNvbWUgPSBzb21lO1xyXG5mdW5jdGlvbiBldmVyeShwcmVkaWNhdGUpIHtcclxuICAgIHJldHVybiBpdCA9PiB7XHJcbiAgICAgICAgbGV0IGkgPSAwO1xyXG4gICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBpdCkge1xyXG4gICAgICAgICAgICBpZiAoIXByZWRpY2F0ZShpdGVtLCBpKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGkgPSBpICsgMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9O1xyXG59XHJcbmV4cG9ydHMuZXZlcnkgPSBldmVyeTtcclxuZnVuY3Rpb24qIGRpc3RpbmN0KGl0KSB7XHJcbiAgICBjb25zdCByZXN1bHRTZXQgPSBuZXcgU2V0KCk7XHJcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgaXQpIHtcclxuICAgICAgICBpZiAoIXJlc3VsdFNldC5oYXMoaXRlbSkpIHtcclxuICAgICAgICAgICAgcmVzdWx0U2V0LmFkZChpdGVtKTtcclxuICAgICAgICAgICAgeWllbGQgaXRlbTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5kaXN0aW5jdCA9IGRpc3RpbmN0O1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1vcGVyYXRvcnMuanMubWFwXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL0Btb3JsZXlkZXYvZnVuY3Rpb25hbC1waXBlL2l0ZXJhYmxlL29wZXJhdG9ycy5qcyIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmV4cG9ydHMuJCQgPSAoeCkgPT4gKHtcclxuICAgICQ6IChtYXApID0+IGV4cG9ydHMuJCQobWFwKHgpKSxcclxuICAgICQkOiAobWFwKSA9PiBtYXAoeCksXHJcbn0pO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1waXBlLmpzLm1hcFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9AbW9ybGV5ZGV2L2Z1bmN0aW9uYWwtcGlwZS9waXBlLmpzIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3QgaG93bGVyXzEgPSByZXF1aXJlKFwiaG93bGVyXCIpO1xyXG5jbGFzcyBXZWJBc3NldExvYWRlciB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLmltYWdlcyA9IHt9O1xyXG4gICAgICAgIHRoaXMuc291bmRlZmZlY3RzID0ge307XHJcbiAgICAgICAgdGhpcy5tdXNpYyA9IHt9O1xyXG4gICAgICAgIHRoaXMuanNvbnMgPSB7fTtcclxuICAgIH1cclxuICAgIGxvYWRGb250KGlkLCBwYXRoKSB7XHJcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgfVxyXG4gICAgZ2V0U291bmRFZmZlY3QoaWQsIHBhdGgpIHtcclxuICAgICAgICBjb25zdCBhdWRpbyA9IHRoaXMuc291bmRlZmZlY3RzW2lkXTtcclxuICAgICAgICBpZiAoYXVkaW8pIHtcclxuICAgICAgICAgICAgcmV0dXJuIGF1ZGlvO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgaG93bCA9IG5ldyBob3dsZXJfMS5Ib3dsKHsgc3JjOiBwYXRoIHx8IFtgLi9hc3NldHMvJHtpZH0ub2dnYCwgYC4vYXNzZXRzLyR7aWR9LmZsYWNgLCBgLi9hc3NldHMvJHtpZH0ubXAzYCwgYC4vYXNzZXRzLyR7aWR9LndhdmBdIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zb3VuZGVmZmVjdHNbaWRdID0geyBob3dsLCBuYW1lOiBpZCB9O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGFzeW5jIGxvYWRTb3VuZEVmZmVjdChpZCwgcGF0aCkge1xyXG4gICAgICAgIGNvbnN0IGF1ZGlvID0gdGhpcy5zb3VuZGVmZmVjdHNbaWRdO1xyXG4gICAgICAgIGlmIChhdWRpbykge1xyXG4gICAgICAgICAgICByZXR1cm4gYXVkaW87XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCBob3dsID0gYXdhaXQgbG9hZEF1ZGlvRnJvbVVybChwYXRoKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc291bmRlZmZlY3RzW2lkXSA9IHsgaG93bCwgbmFtZTogaWQgfTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBnZXRJbWFnZShpZCwgcGF0aCkge1xyXG4gICAgICAgIGNvbnN0IGltYWdlID0gdGhpcy5pbWFnZXNbaWRdO1xyXG4gICAgICAgIGlmIChpbWFnZSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpbWFnZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGltZyA9IG5ldyBJbWFnZSgpO1xyXG4gICAgICAgICAgICBpbWcuc3JjID0gcGF0aCB8fCBgLi9hc3NldHMvJHtpZH0ucG5nYDtcclxuICAgICAgICAgICAgdGhpcy5pbWFnZXNbaWRdID0gaW1nO1xyXG4gICAgICAgICAgICByZXR1cm4gaW1nO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGFzeW5jIGxvYWRJbWFnZShpZCwgcGF0aCkge1xyXG4gICAgICAgIGNvbnN0IGltYWdlQWxyZWFkeUxvYWRlZCA9IHRoaXMuaW1hZ2VzW2lkXTtcclxuICAgICAgICBpZiAoaW1hZ2VBbHJlYWR5TG9hZGVkICE9IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGltYWdlQWxyZWFkeUxvYWRlZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGltYWdlID0gYXdhaXQgbG9hZEltYWdlRnJvbVVybChwYXRoKTtcclxuICAgICAgICAgICAgdGhpcy5pbWFnZXNbaWRdID0gaW1hZ2U7XHJcbiAgICAgICAgICAgIHJldHVybiBpbWFnZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBnZXRNdXNpYyhpZCwgcGF0aCkge1xyXG4gICAgICAgIGNvbnN0IGF1ZGlvID0gdGhpcy5tdXNpY1tpZF07XHJcbiAgICAgICAgaWYgKGF1ZGlvKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBhdWRpbztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGhvd2wgPSBuZXcgaG93bGVyXzEuSG93bCh7IHNyYzogcGF0aCB8fCBbYC4vYXNzZXRzLyR7aWR9Lm9nZ2AsIGAuL2Fzc2V0cy8ke2lkfS5mbGFjYCwgYC4vYXNzZXRzLyR7aWR9Lm1wM2AsIGAuL2Fzc2V0cy8ke2lkfS53YXZgXSB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubXVzaWNbaWRdID0geyBob3dsLCBuYW1lOiBpZCB9O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGFzeW5jIGxvYWRNdXNpYyhpZCwgcGF0aCkge1xyXG4gICAgICAgIGNvbnN0IGF1ZGlvID0gdGhpcy5tdXNpY1tpZF07XHJcbiAgICAgICAgaWYgKGF1ZGlvKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBhdWRpbztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGhvd2wgPSBhd2FpdCBsb2FkQXVkaW9Gcm9tVXJsKHBhdGgpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tdXNpY1tpZF0gPSB7IGhvd2wsIG5hbWU6IGlkIH07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZ2V0SnNvbihpZCwgcGF0aCwgbm90Rm91bmQpIHtcclxuICAgICAgICBjb25zdCBhc3NldCA9IHRoaXMuanNvbnNbaWRdO1xyXG4gICAgICAgIGlmIChhc3NldCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBhc3NldDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChub3RGb3VuZCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmpzb25zW2lkXSA9IG5vdEZvdW5kO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBub3RGb3VuZDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBhc3luYyBsb2FkSnNvbihpZCwgcGF0aCwgbm90Rm91bmQpIHtcclxuICAgICAgICBjb25zdCBhc3NldCA9IHRoaXMuanNvbnNbaWRdO1xyXG4gICAgICAgIGlmIChhc3NldCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBhc3NldDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZmV0Y2gocGF0aCk7XHJcbiAgICAgICAgaWYgKHJlc3VsdC5zdGF0dXMgPCAyMDAgfHwgcmVzdWx0LnN0YXR1cyA+PSAzMDApIHtcclxuICAgICAgICAgICAgaWYgKG5vdEZvdW5kICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuanNvbnNbaWRdID0gbm90Rm91bmQ7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbm90Rm91bmQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvdWxkIG5vdCBmaW5kIGpzb24gb2JqZWN0ICR7aWR9ICgke3BhdGh9KWApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCBib2R5ID0gYXdhaXQgcmVzdWx0Lmpzb24oKTtcclxuICAgICAgICAgICAgdGhpcy5qc29uc1tpZF0gPSBib2R5O1xyXG4gICAgICAgICAgICByZXR1cm4gYm9keTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5XZWJBc3NldExvYWRlciA9IFdlYkFzc2V0TG9hZGVyO1xyXG5mdW5jdGlvbiBsb2FkSW1hZ2VGcm9tVXJsKHBhdGgpIHtcclxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgY29uc3QgaW1nID0gbmV3IEltYWdlKCk7XHJcbiAgICAgICAgaW1nLm9ubG9hZCA9ICgpID0+IHJlc29sdmUoaW1nKTtcclxuICAgICAgICBpbWcub25lcnJvciA9ICgpID0+IHJlamVjdCgpO1xyXG4gICAgICAgIGltZy5zcmMgPSBwYXRoO1xyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gbG9hZEF1ZGlvRnJvbVVybChwYXRoKSB7XHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGhvd2wgPSBuZXcgaG93bGVyXzEuSG93bCh7IHNyYzogW3BhdGhdLCBodG1sNTogdHJ1ZSB9KTtcclxuICAgICAgICBpZiAoaG93bC5zdGF0ZSgpID09PSBcImxvYWRlZFwiKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBob3dsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaG93bC5vbmNlKFwibG9hZFwiLCAoKSA9PiByZXNvbHZlKGhvd2wpKTtcclxuICAgICAgICAgICAgaG93bC5vbmNlKFwibG9hZGVycm9yXCIsIChpZCwgZXJyKSA9PiByZWplY3QoZXJyKSk7XHJcbiAgICAgICAgICAgIGhvd2wubG9hZCgpO1xyXG4gICAgICAgICAgICByZXR1cm4gaG93bDtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxufVxyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvQG1vcmxleWRldi9wYXVwZXIvYXNzZXRzL3dlYi1hc3NldC1sb2FkZXIuc2VydmljZS5qcyIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmV4cG9ydHMubGluZWFySW50ZXJwb2xhdGlvbiA9IChzdGFydCwgZW5kKSA9PiBwZXJjZW50YWdlID0+IHN0YXJ0ICsgKGVuZCAtIHN0YXJ0KSAqIHBlcmNlbnRhZ2U7XHJcbmV4cG9ydHMuY29zaW5lSW50ZXJwb2xhdGlvbiA9IChzdGFydCwgZW5kKSA9PiBwZXJjZW50YWdlID0+IHtcclxuICAgIGNvbnN0IG11MiA9ICgxIC0gTWF0aC5jb3MocGVyY2VudGFnZSAqIE1hdGguUEkpKSAvIDI7XHJcbiAgICByZXR1cm4gKHN0YXJ0ICogKDEgLSBtdTIpICsgZW5kICogbXUyKTtcclxufTtcclxuZXhwb3J0cy5leHBvbmVudGlhbEludGVycG9sYXRpb24gPSBwb3dlciA9PiAoc3RhcnQsIGVuZCkgPT4gcGVyY2VudGFnZSA9PiBleHBvcnRzLmxpbmVhckludGVycG9sYXRpb24oc3RhcnQsIGVuZCkocGVyY2VudGFnZSAqKiBwb3dlcik7XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9AbW9ybGV5ZGV2L3BhdXBlci9tYXRocy9pbnRlcnBvbGF0aW9uLm1hdGhzLmpzIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3QgaW50ZXJwb2xhdGlvbl9tYXRoc18xID0gcmVxdWlyZShcIi4vaW50ZXJwb2xhdGlvbi5tYXRoc1wiKTtcclxuZnVuY3Rpb24gYWJzKHsgeCwgeSB9KSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHg6IE1hdGguYWJzKHgpLFxyXG4gICAgICAgIHk6IE1hdGguYWJzKHkpXHJcbiAgICB9O1xyXG59XHJcbmV4cG9ydHMuYWJzID0gYWJzO1xyXG5mdW5jdGlvbiBpbnZlcnQoeyB4LCB5IH0pIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgeDogLXgsXHJcbiAgICAgICAgeTogLXlcclxuICAgIH07XHJcbn1cclxuZXhwb3J0cy5pbnZlcnQgPSBpbnZlcnQ7XHJcbmZ1bmN0aW9uIGFkZChsaHMsIHJocykge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB4OiBsaHMueCArIHJocy54LFxyXG4gICAgICAgIHk6IGxocy55ICsgcmhzLnlcclxuICAgIH07XHJcbn1cclxuZXhwb3J0cy5hZGQgPSBhZGQ7XHJcbmZ1bmN0aW9uIHN1YnRyYWN0KGxocywgcmhzKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHg6IGxocy54IC0gcmhzLngsXHJcbiAgICAgICAgeTogbGhzLnkgLSByaHMueVxyXG4gICAgfTtcclxufVxyXG5leHBvcnRzLnN1YnRyYWN0ID0gc3VidHJhY3Q7XHJcbmZ1bmN0aW9uIG11bHRpcGx5KGxocywgcmhzKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHg6IGxocy54ICogcmhzLFxyXG4gICAgICAgIHk6IGxocy55ICogcmhzXHJcbiAgICB9O1xyXG59XHJcbmV4cG9ydHMubXVsdGlwbHkgPSBtdWx0aXBseTtcclxuZnVuY3Rpb24gZG90KGxocywgcmhzKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHg6IGxocy54ICogcmhzLngsXHJcbiAgICAgICAgeTogbGhzLnkgKiByaHMueVxyXG4gICAgfTtcclxufVxyXG5leHBvcnRzLmRvdCA9IGRvdDtcclxuZnVuY3Rpb24gZGl2aWRlKGxocywgcmhzKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHg6IGxocy54IC8gcmhzLFxyXG4gICAgICAgIHk6IGxocy55IC8gcmhzXHJcbiAgICB9O1xyXG59XHJcbmV4cG9ydHMuZGl2aWRlID0gZGl2aWRlO1xyXG5mdW5jdGlvbiBtYWduaXR1ZGVTcXVhcmVkKGxocykge1xyXG4gICAgcmV0dXJuIGxocy54ICogbGhzLnggKyBsaHMueSAqIGxocy55O1xyXG59XHJcbmV4cG9ydHMubWFnbml0dWRlU3F1YXJlZCA9IG1hZ25pdHVkZVNxdWFyZWQ7XHJcbmZ1bmN0aW9uIG1hZ25pdHVkZShsaHMpIHtcclxuICAgIHJldHVybiBNYXRoLnNxcnQobWFnbml0dWRlU3F1YXJlZChsaHMpKTtcclxufVxyXG5leHBvcnRzLm1hZ25pdHVkZSA9IG1hZ25pdHVkZTtcclxuZnVuY3Rpb24gbm9ybWFsaXNlKGxocykge1xyXG4gICAgcmV0dXJuIGRpdmlkZShsaHMsIG1hZ25pdHVkZShsaHMpKTtcclxufVxyXG5leHBvcnRzLm5vcm1hbGlzZSA9IG5vcm1hbGlzZTtcclxuZnVuY3Rpb24gZG90UHJvZHVjdChsaHMsIHJocykge1xyXG4gICAgcmV0dXJuIGxocy54ICogcmhzLnggKyBsaHMueSAqIHJocy55O1xyXG59XHJcbmV4cG9ydHMuZG90UHJvZHVjdCA9IGRvdFByb2R1Y3Q7XHJcbmZ1bmN0aW9uIG5vcm1hbChsaHMpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgeDogLWxocy55LFxyXG4gICAgICAgIHk6IGxocy54XHJcbiAgICB9O1xyXG59XHJcbmV4cG9ydHMubm9ybWFsID0gbm9ybWFsO1xyXG5mdW5jdGlvbiBjb25zdHJhaW50KHRvcExlZnQsIGJvdHRvbVJpZ2h0KSB7XHJcbiAgICByZXR1cm4gbGhzID0+ICh7XHJcbiAgICAgICAgeDogTWF0aC5taW4oTWF0aC5tYXgodG9wTGVmdC54LCBsaHMueCksIGJvdHRvbVJpZ2h0LngpLFxyXG4gICAgICAgIHk6IE1hdGgubWluKE1hdGgubWF4KHRvcExlZnQueSwgbGhzLnkpLCBib3R0b21SaWdodC55KVxyXG4gICAgfSk7XHJcbn1cclxuZXhwb3J0cy5jb25zdHJhaW50ID0gY29uc3RyYWludDtcclxuZnVuY3Rpb24gY3Jvc3NQcm9kdWN0KGxocywgcmhzKSB7XHJcbiAgICByZXR1cm4gbGhzLnggKiByaHMueSAtIGxocy55ICogcmhzLng7XHJcbn1cclxuZXhwb3J0cy5jcm9zc1Byb2R1Y3QgPSBjcm9zc1Byb2R1Y3Q7XHJcbmZ1bmN0aW9uIGxpbmVhckludGVycG9sYXRpb24obGhzLCByaHMpIHtcclxuICAgIGNvbnN0IGludGVycG9sYXRlWCA9IGludGVycG9sYXRpb25fbWF0aHNfMS5saW5lYXJJbnRlcnBvbGF0aW9uKGxocy54LCByaHMueCk7XHJcbiAgICBjb25zdCBpbnRlcnBvbGF0ZVkgPSBpbnRlcnBvbGF0aW9uX21hdGhzXzEubGluZWFySW50ZXJwb2xhdGlvbihsaHMueSwgcmhzLnkpO1xyXG4gICAgcmV0dXJuIHBlcmNlbnRhZ2UgPT4gKHsgeDogaW50ZXJwb2xhdGVYKHBlcmNlbnRhZ2UpLCB5OiBpbnRlcnBvbGF0ZVkocGVyY2VudGFnZSkgfSk7XHJcbn1cclxuZXhwb3J0cy5saW5lYXJJbnRlcnBvbGF0aW9uID0gbGluZWFySW50ZXJwb2xhdGlvbjtcclxuZnVuY3Rpb24gY29zaW5lSW50ZXJwb2xhdGlvbihsaHMsIHJocykge1xyXG4gICAgY29uc3QgaW50ZXJwb2xhdGVYID0gaW50ZXJwb2xhdGlvbl9tYXRoc18xLmNvc2luZUludGVycG9sYXRpb24obGhzLngsIHJocy54KTtcclxuICAgIGNvbnN0IGludGVycG9sYXRlWSA9IGludGVycG9sYXRpb25fbWF0aHNfMS5jb3NpbmVJbnRlcnBvbGF0aW9uKGxocy55LCByaHMueSk7XHJcbiAgICByZXR1cm4gcGVyY2VudGFnZSA9PiAoeyB4OiBpbnRlcnBvbGF0ZVgocGVyY2VudGFnZSksIHk6IGludGVycG9sYXRlWShwZXJjZW50YWdlKSB9KTtcclxufVxyXG5leHBvcnRzLmNvc2luZUludGVycG9sYXRpb24gPSBjb3NpbmVJbnRlcnBvbGF0aW9uO1xyXG5mdW5jdGlvbiBleHBvbmVudGlhbEludGVycG9sYXRpb24oZXhwb25lbnQpIHtcclxuICAgIGNvbnN0IGV4cG9uZW50aWFsSW50ZXJwb2xhdG9yID0gaW50ZXJwb2xhdGlvbl9tYXRoc18xLmV4cG9uZW50aWFsSW50ZXJwb2xhdGlvbihleHBvbmVudCk7XHJcbiAgICByZXR1cm4gKGxocywgcmhzKSA9PiB7XHJcbiAgICAgICAgY29uc3QgaW50ZXJwb2xhdGVYID0gZXhwb25lbnRpYWxJbnRlcnBvbGF0b3IobGhzLngsIHJocy54KTtcclxuICAgICAgICBjb25zdCBpbnRlcnBvbGF0ZVkgPSBleHBvbmVudGlhbEludGVycG9sYXRvcihsaHMueSwgcmhzLnkpO1xyXG4gICAgICAgIHJldHVybiBwZXJjZW50YWdlID0+ICh7IHg6IGludGVycG9sYXRlWChwZXJjZW50YWdlKSwgeTogaW50ZXJwb2xhdGVZKHBlcmNlbnRhZ2UpIH0pO1xyXG4gICAgfTtcclxufVxyXG5leHBvcnRzLmV4cG9uZW50aWFsSW50ZXJwb2xhdGlvbiA9IGV4cG9uZW50aWFsSW50ZXJwb2xhdGlvbjtcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL0Btb3JsZXlkZXYvcGF1cGVyL21hdGhzL3ZlY3Rvci5tYXRocy5mdW5jLmpzIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3QgZnVuYyA9IHJlcXVpcmUoXCIuL3ZlY3Rvci5tYXRocy5mdW5jXCIpO1xyXG5jb25zdCB2YWx1ZXMgPSByZXF1aXJlKFwiLi92ZWN0b3IubWF0aHMudmFsdWVzXCIpO1xyXG5leHBvcnRzLlZlY3RvcjIgPSBPYmplY3QuYXNzaWduKCh4LCB5KSA9PiAoeyB4LCB5IH0pLCBPYmplY3QuYXNzaWduKHt9LCBmdW5jLCB2YWx1ZXMpKTtcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL0Btb3JsZXlkZXYvcGF1cGVyL21hdGhzL3ZlY3Rvci5tYXRocy5qcyIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmV4cG9ydHMuWmVybyA9IHsgeDogMCwgeTogMCB9O1xyXG5leHBvcnRzLlVuaXQgPSB7IHg6IE1hdGguc3FydCgwLjUpLCB5OiBNYXRoLnNxcnQoMC41KSB9O1xyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvQG1vcmxleWRldi9wYXVwZXIvbWF0aHMvdmVjdG9yLm1hdGhzLnZhbHVlcy5qcyIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmZ1bmN0aW9uIGJvdW5kaW5nQm94KGNpcmNsZSkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB4OiBjaXJjbGUueCAtIGNpcmNsZS5yYWRpdXMsXHJcbiAgICAgICAgeTogY2lyY2xlLnkgLSBjaXJjbGUucmFkaXVzLFxyXG4gICAgICAgIHdpZHRoOiBjaXJjbGUucmFkaXVzICogMixcclxuICAgICAgICBoZWlnaHQ6IGNpcmNsZS5yYWRpdXMgKiAyXHJcbiAgICB9O1xyXG59XHJcbmV4cG9ydHMuYm91bmRpbmdCb3ggPSBib3VuZGluZ0JveDtcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL0Btb3JsZXlkZXYvcGF1cGVyL21vZGVscy9jaXJjbGUvY2lyY2xlLm1vZGVsLmJvdW5kaW5nLmpzIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuZnVuY3Rpb24gaXMocG9zc2libGUpIHtcclxuICAgIHJldHVybiBwb3NzaWJsZS5yYWRpdXMgIT0gbnVsbCAmJiBwb3NzaWJsZS54ICE9IG51bGwgJiYgcG9zc2libGUueSAhPSBudWxsO1xyXG59XHJcbmV4cG9ydHMuaXMgPSBpcztcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL0Btb3JsZXlkZXYvcGF1cGVyL21vZGVscy9jaXJjbGUvY2lyY2xlLm1vZGVsLmlzLmpzIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3QgYm91bmRpbmcgPSByZXF1aXJlKFwiLi9jaXJjbGUubW9kZWwuYm91bmRpbmdcIik7XHJcbmNvbnN0IGlzID0gcmVxdWlyZShcIi4vY2lyY2xlLm1vZGVsLmlzXCIpO1xyXG5jb25zdCBsaW5lVG8gPSByZXF1aXJlKFwiLi9jaXJjbGUubW9kZWwubGluZVRvXCIpO1xyXG5jb25zdCBvdmVybGFwID0gcmVxdWlyZShcIi4vY2lyY2xlLm1vZGVsLm92ZXJsYXBcIik7XHJcbmV4cG9ydHMuQ2lyY2xlID0gT2JqZWN0LmFzc2lnbigoeCwgeSwgcmFkaXVzKSA9PiAoeyB4LCB5LCByYWRpdXMgfSksIE9iamVjdC5hc3NpZ24oe30sIGJvdW5kaW5nLCBpcywgb3ZlcmxhcCwgbGluZVRvKSk7XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9AbW9ybGV5ZGV2L3BhdXBlci9tb2RlbHMvY2lyY2xlL2NpcmNsZS5tb2RlbC5qcyIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IHZlY3Rvcl9tYXRoc19mdW5jXzEgPSByZXF1aXJlKFwiLi4vLi4vbWF0aHMvdmVjdG9yLm1hdGhzLmZ1bmNcIik7XHJcbmNvbnN0IGxpbmVfbW9kZWxfaXNfMSA9IHJlcXVpcmUoXCIuLi9saW5lL2xpbmUubW9kZWwuaXNcIik7XHJcbmNvbnN0IGxpbmVfbW9kZWxfbGluZVRvXzEgPSByZXF1aXJlKFwiLi4vbGluZS9saW5lLm1vZGVsLmxpbmVUb1wiKTtcclxuY29uc3QgcmVjdGFuZ2xlX21vZGVsX2lzXzEgPSByZXF1aXJlKFwiLi4vcmVjdGFuZ2xlL3JlY3RhbmdsZS5tb2RlbC5pc1wiKTtcclxuY29uc3QgcmVjdGFuZ2xlX21vZGVsX2xpbmVUb18xID0gcmVxdWlyZShcIi4uL3JlY3RhbmdsZS9yZWN0YW5nbGUubW9kZWwubGluZVRvXCIpO1xyXG5jb25zdCB0cmlhbmdsZV9tb2RlbF9pc18xID0gcmVxdWlyZShcIi4uL3RyaWFuZ2xlL3RyaWFuZ2xlLm1vZGVsLmlzXCIpO1xyXG5jb25zdCBjaXJjbGVfbW9kZWxfaXNfMSA9IHJlcXVpcmUoXCIuL2NpcmNsZS5tb2RlbC5pc1wiKTtcclxuZnVuY3Rpb24gbGluZVRvKGxocywgcmhzKSB7XHJcbiAgICBpZiAobGluZV9tb2RlbF9pc18xLmlzKHJocykpIHtcclxuICAgICAgICBjb25zdCBbYiwgYV0gPSBsaW5lX21vZGVsX2xpbmVUb18xLmxpbmVMaW5lMlRvQ2lyY2xlKHJocywgbGhzKTtcclxuICAgICAgICByZXR1cm4gW2EsIGJdO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodHJpYW5nbGVfbW9kZWxfaXNfMS5pcyhyaHMpKSB7XHJcbiAgICAgICAgcmV0dXJuIGxpbmVDaXJjbGVUb1RyaWFuZ2xlMihsaHMsIHJocyk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChjaXJjbGVfbW9kZWxfaXNfMS5pcyhyaHMpKSB7XHJcbiAgICAgICAgcmV0dXJuIGxpbmVDaXJjbGVUb0NpcmNsZShsaHMsIHJocyk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChyZWN0YW5nbGVfbW9kZWxfaXNfMS5pcyhyaHMpKSB7XHJcbiAgICAgICAgY29uc3QgW2IsIGFdID0gcmVjdGFuZ2xlX21vZGVsX2xpbmVUb18xLmxpbmVSZWN0YW5nbGVUb0NpcmNsZShyaHMsIGxocyk7XHJcbiAgICAgICAgcmV0dXJuIFthLCBiXTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBsaW5lQ2lyY2xlVG9Qb2ludDIobGhzLCByaHMpO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMubGluZVRvID0gbGluZVRvO1xyXG5mdW5jdGlvbiBsaW5lQ2lyY2xlVG9Qb2ludDIobGhzLCByaHMpIHtcclxuICAgIGNvbnN0IG9mZnNldCA9IHZlY3Rvcl9tYXRoc19mdW5jXzEuc3VidHJhY3QocmhzLCBsaHMpO1xyXG4gICAgY29uc3Qgbm9ybWFsaXNlZCA9IHZlY3Rvcl9tYXRoc19mdW5jXzEuYWRkKHZlY3Rvcl9tYXRoc19mdW5jXzEubXVsdGlwbHkodmVjdG9yX21hdGhzX2Z1bmNfMS5ub3JtYWxpc2Uob2Zmc2V0KSwgbGhzLnJhZGl1cyksIGxocyk7XHJcbiAgICByZXR1cm4gW25vcm1hbGlzZWQsIHJoc107XHJcbn1cclxuZXhwb3J0cy5saW5lQ2lyY2xlVG9Qb2ludDIgPSBsaW5lQ2lyY2xlVG9Qb2ludDI7XHJcbmZ1bmN0aW9uIGxpbmVDaXJjbGVUb1RyaWFuZ2xlMihsaHMsIHJocykge1xyXG4gICAgY29uc3QgYSA9IGxpbmVfbW9kZWxfbGluZVRvXzEubGluZUxpbmUyVG9DaXJjbGUoW3Joc1swXSwgcmhzWzFdXSwgbGhzKTtcclxuICAgIGNvbnN0IGIgPSBsaW5lX21vZGVsX2xpbmVUb18xLmxpbmVMaW5lMlRvQ2lyY2xlKFtyaHNbMV0sIHJoc1swXV0sIGxocyk7XHJcbiAgICBjb25zdCBjID0gbGluZV9tb2RlbF9saW5lVG9fMS5saW5lTGluZTJUb0NpcmNsZShbcmhzWzJdLCByaHNbMF1dLCBsaHMpO1xyXG4gICAgY29uc3QgbWFnQSA9IHZlY3Rvcl9tYXRoc19mdW5jXzEubWFnbml0dWRlU3F1YXJlZCh2ZWN0b3JfbWF0aHNfZnVuY18xLnN1YnRyYWN0KGFbMF0sIGxocykpO1xyXG4gICAgY29uc3QgbWFnQiA9IHZlY3Rvcl9tYXRoc19mdW5jXzEubWFnbml0dWRlU3F1YXJlZCh2ZWN0b3JfbWF0aHNfZnVuY18xLnN1YnRyYWN0KGJbMF0sIGxocykpO1xyXG4gICAgY29uc3QgbWFnQyA9IHZlY3Rvcl9tYXRoc19mdW5jXzEubWFnbml0dWRlU3F1YXJlZCh2ZWN0b3JfbWF0aHNfZnVuY18xLnN1YnRyYWN0KGNbMF0sIGxocykpO1xyXG4gICAgaWYgKG1hZ0EgPCBtYWdCKSB7XHJcbiAgICAgICAgcmV0dXJuIG1hZ0EgPCBtYWdDID8gYSA6IGM7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gbWFnQiA8IG1hZ0MgPyBiIDogYztcclxuICAgIH1cclxufVxyXG5leHBvcnRzLmxpbmVDaXJjbGVUb1RyaWFuZ2xlMiA9IGxpbmVDaXJjbGVUb1RyaWFuZ2xlMjtcclxuZnVuY3Rpb24gbGluZUNpcmNsZVRvQ2lyY2xlKGxocywgcmhzKSB7XHJcbiAgICBjb25zdCBvZmZzZXQgPSB2ZWN0b3JfbWF0aHNfZnVuY18xLnN1YnRyYWN0KHJocywgbGhzKTtcclxuICAgIGNvbnN0IG4gPSB2ZWN0b3JfbWF0aHNfZnVuY18xLm5vcm1hbGlzZShvZmZzZXQpO1xyXG4gICAgY29uc3QgbCA9IHZlY3Rvcl9tYXRoc19mdW5jXzEuYWRkKHZlY3Rvcl9tYXRoc19mdW5jXzEubXVsdGlwbHkobiwgbGhzLnJhZGl1cyksIGxocyk7XHJcbiAgICBjb25zdCByID0gdmVjdG9yX21hdGhzX2Z1bmNfMS5zdWJ0cmFjdChyaHMsIHZlY3Rvcl9tYXRoc19mdW5jXzEubXVsdGlwbHkobiwgcmhzLnJhZGl1cykpO1xyXG4gICAgcmV0dXJuIFtsLCByXTtcclxufVxyXG5leHBvcnRzLmxpbmVDaXJjbGVUb0NpcmNsZSA9IGxpbmVDaXJjbGVUb0NpcmNsZTtcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL0Btb3JsZXlkZXYvcGF1cGVyL21vZGVscy9jaXJjbGUvY2lyY2xlLm1vZGVsLmxpbmVUby5qcyIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IHZlY3Rvcl9tYXRoc19mdW5jXzEgPSByZXF1aXJlKFwiLi4vLi4vbWF0aHMvdmVjdG9yLm1hdGhzLmZ1bmNcIik7XHJcbmNvbnN0IGxpbmVfbW9kZWxfaW50ZXJzZWN0XzEgPSByZXF1aXJlKFwiLi4vbGluZS9saW5lLm1vZGVsLmludGVyc2VjdFwiKTtcclxuY29uc3QgbGluZV9tb2RlbF9pc18xID0gcmVxdWlyZShcIi4uL2xpbmUvbGluZS5tb2RlbC5pc1wiKTtcclxuY29uc3QgbGluZV9tb2RlbF9sZW5ndGhfMSA9IHJlcXVpcmUoXCIuLi9saW5lL2xpbmUubW9kZWwubGVuZ3RoXCIpO1xyXG5jb25zdCByZWN0YW5nbGVfbW9kZWxfaXNfMSA9IHJlcXVpcmUoXCIuLi9yZWN0YW5nbGUvcmVjdGFuZ2xlLm1vZGVsLmlzXCIpO1xyXG5jb25zdCByZWN0YW5nbGVfbW9kZWxfbGluZVRvXzEgPSByZXF1aXJlKFwiLi4vcmVjdGFuZ2xlL3JlY3RhbmdsZS5tb2RlbC5saW5lVG9cIik7XHJcbmNvbnN0IHRyaWFuZ2xlX21vZGVsX2lzXzEgPSByZXF1aXJlKFwiLi4vdHJpYW5nbGUvdHJpYW5nbGUubW9kZWwuaXNcIik7XHJcbmNvbnN0IHRyaWFuZ2xlX21vZGVsX292ZXJsYXBfMSA9IHJlcXVpcmUoXCIuLi90cmlhbmdsZS90cmlhbmdsZS5tb2RlbC5vdmVybGFwXCIpO1xyXG5jb25zdCBjaXJjbGVfbW9kZWxfaXNfMSA9IHJlcXVpcmUoXCIuL2NpcmNsZS5tb2RlbC5pc1wiKTtcclxuZnVuY3Rpb24gb3ZlcmxhcHMobGhzLCByaHMpIHtcclxuICAgIGlmIChsaW5lX21vZGVsX2lzXzEuaXMocmhzKSkge1xyXG4gICAgICAgIHJldHVybiBjaXJjbGVPdmVybGFwc0xpbmUyKGxocywgcmhzKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHRyaWFuZ2xlX21vZGVsX2lzXzEuaXMocmhzKSkge1xyXG4gICAgICAgIHJldHVybiBjaXJjbGVPdmVybGFwc1RyaWFuZ2xlMihsaHMsIHJocyk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChjaXJjbGVfbW9kZWxfaXNfMS5pcyhyaHMpKSB7XHJcbiAgICAgICAgcmV0dXJuIGNpcmNsZU92ZXJsYXBzQ2lyY2xlKGxocywgcmhzKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHJlY3RhbmdsZV9tb2RlbF9pc18xLmlzKHJocykpIHtcclxuICAgICAgICByZXR1cm4gY2lyY2xlT3ZlcmxhcHNSZWN0YW5nbGUobGhzLCByaHMpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIGNpcmNsZU92ZXJsYXBzUG9pbnQyKGxocywgcmhzKTtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLm92ZXJsYXBzID0gb3ZlcmxhcHM7XHJcbmZ1bmN0aW9uIGNpcmNsZU92ZXJsYXBzTGluZTIobGhzLCByaHMpIHtcclxuICAgIHJldHVybiBsaW5lX21vZGVsX2ludGVyc2VjdF8xLmxpbmUySW50ZXJzZWN0c0NpcmNsZShyaHMsIGxocyk7XHJcbn1cclxuZXhwb3J0cy5jaXJjbGVPdmVybGFwc0xpbmUyID0gY2lyY2xlT3ZlcmxhcHNMaW5lMjtcclxuZnVuY3Rpb24gY2lyY2xlT3ZlcmxhcHNUcmlhbmdsZTIobGhzLCByaHMpIHtcclxuICAgIHJldHVybiB0cmlhbmdsZV9tb2RlbF9vdmVybGFwXzEudHJpYW5nbGUyT3ZlcmxhcHNDaXJjbGUocmhzLCBsaHMpO1xyXG59XHJcbmV4cG9ydHMuY2lyY2xlT3ZlcmxhcHNUcmlhbmdsZTIgPSBjaXJjbGVPdmVybGFwc1RyaWFuZ2xlMjtcclxuZnVuY3Rpb24gY2lyY2xlT3ZlcmxhcHNDaXJjbGUoYSwgYikge1xyXG4gICAgcmV0dXJuIHZlY3Rvcl9tYXRoc19mdW5jXzEubWFnbml0dWRlU3F1YXJlZCh2ZWN0b3JfbWF0aHNfZnVuY18xLnN1YnRyYWN0KGEsIGIpKSA8PSAoYS5yYWRpdXMgKyBiLnJhZGl1cykgKiAoYS5yYWRpdXMgKyBiLnJhZGl1cyk7XHJcbn1cclxuZXhwb3J0cy5jaXJjbGVPdmVybGFwc0NpcmNsZSA9IGNpcmNsZU92ZXJsYXBzQ2lyY2xlO1xyXG5mdW5jdGlvbiBjaXJjbGVPdmVybGFwc1BvaW50MihhLCBiKSB7XHJcbiAgICByZXR1cm4gdmVjdG9yX21hdGhzX2Z1bmNfMS5tYWduaXR1ZGVTcXVhcmVkKHZlY3Rvcl9tYXRoc19mdW5jXzEuc3VidHJhY3QoYSwgYikpIDw9IGEucmFkaXVzICogYS5yYWRpdXM7XHJcbn1cclxuZXhwb3J0cy5jaXJjbGVPdmVybGFwc1BvaW50MiA9IGNpcmNsZU92ZXJsYXBzUG9pbnQyO1xyXG5mdW5jdGlvbiBjaXJjbGVPdmVybGFwc1JlY3RhbmdsZShsaHMsIHJocykge1xyXG4gICAgcmV0dXJuIGNpcmNsZU92ZXJsYXBzUG9pbnQyKGxocywgcmhzKSB8fCAobGluZV9tb2RlbF9sZW5ndGhfMS5sZW5ndGhPZihyZWN0YW5nbGVfbW9kZWxfbGluZVRvXzEubGluZVRvKHJocywgeyB4OiBsaHMueCwgeTogbGhzLnkgfSkpIDw9IGxocy5yYWRpdXMpO1xyXG59XHJcbmV4cG9ydHMuY2lyY2xlT3ZlcmxhcHNSZWN0YW5nbGUgPSBjaXJjbGVPdmVybGFwc1JlY3RhbmdsZTtcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL0Btb3JsZXlkZXYvcGF1cGVyL21vZGVscy9jaXJjbGUvY2lyY2xlLm1vZGVsLm92ZXJsYXAuanMiLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5leHBvcnRzLlJHQkEgPSAociwgZywgYiwgYSA9IDEpID0+ICh7IHIsIGcsIGIsIGEgfSk7XHJcbmV4cG9ydHMuUkdCID0gKHIsIGcsIGIpID0+ICh7IHIsIGcsIGIgfSk7XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9AbW9ybGV5ZGV2L3BhdXBlci9tb2RlbHMvY29sb3VyLm1vZGVsLmpzIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3QgY2lyY2xlX21vZGVsX2lzXzEgPSByZXF1aXJlKFwiLi4vY2lyY2xlL2NpcmNsZS5tb2RlbC5pc1wiKTtcclxuY29uc3QgcG9pbnRfbW9kZWxfYm91bmRpbmdfMSA9IHJlcXVpcmUoXCIuLi9wb2ludC9wb2ludC5tb2RlbC5ib3VuZGluZ1wiKTtcclxuY29uc3QgcmVjdGFuZ2xlX21vZGVsX2lzXzEgPSByZXF1aXJlKFwiLi4vcmVjdGFuZ2xlL3JlY3RhbmdsZS5tb2RlbC5pc1wiKTtcclxuY29uc3QgcmVjdGFuZ2xlX21vZGVsX2xpbmVzXzEgPSByZXF1aXJlKFwiLi4vcmVjdGFuZ2xlL3JlY3RhbmdsZS5tb2RlbC5saW5lc1wiKTtcclxuY29uc3QgdHJpYW5nbGVfbW9kZWxfaXNfMSA9IHJlcXVpcmUoXCIuLi90cmlhbmdsZS90cmlhbmdsZS5tb2RlbC5pc1wiKTtcclxuY29uc3QgbGluZV9tb2RlbF9pc18xID0gcmVxdWlyZShcIi4vbGluZS5tb2RlbC5pc1wiKTtcclxuZnVuY3Rpb24gaW50ZXJzZWN0cyhsaHMsIHJocywgdG9sZXJhbmNlID0gMC4wMDEpIHtcclxuICAgIGlmIChsaW5lX21vZGVsX2lzXzEuaXMocmhzKSkge1xyXG4gICAgICAgIHJldHVybiBsaW5lMkludGVyc2VjdHNMaW5lMihsaHMsIHJocyk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0cmlhbmdsZV9tb2RlbF9pc18xLmlzKHJocykpIHtcclxuICAgICAgICByZXR1cm4gbGluZTJJbnRlcnNlY3RzVHJpYW5nbGUyKGxocywgcmhzKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGNpcmNsZV9tb2RlbF9pc18xLmlzKHJocykpIHtcclxuICAgICAgICByZXR1cm4gbGluZTJJbnRlcnNlY3RzQ2lyY2xlKGxocywgcmhzKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHJlY3RhbmdsZV9tb2RlbF9pc18xLmlzKHJocykpIHtcclxuICAgICAgICByZXR1cm4gbGluZTJJbnRlcnNlY3RzUmVjdGFuZ2xlKGxocywgcmhzKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBsaW5lMkludGVyc2VjdHNQb2ludDIobGhzLCByaHMsIHRvbGVyYW5jZSk7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5pbnRlcnNlY3RzID0gaW50ZXJzZWN0cztcclxuZnVuY3Rpb24gbGluZTJJbnRlcnNlY3RzVHJpYW5nbGUyKFthMSwgYTJdLCBbdjEsIHYyLCB2M10pIHtcclxuICAgIHJldHVybiBsaW5lMkludGVyc2VjdHNMaW5lMihbdjEsIHYyXSwgW2ExLCBhMl0pXHJcbiAgICAgICAgfHwgbGluZTJJbnRlcnNlY3RzTGluZTIoW3YyLCB2M10sIFthMSwgYTJdKVxyXG4gICAgICAgIHx8IGxpbmUySW50ZXJzZWN0c0xpbmUyKFt2MywgdjFdLCBbYTEsIGEyXSk7XHJcbn1cclxuZXhwb3J0cy5saW5lMkludGVyc2VjdHNUcmlhbmdsZTIgPSBsaW5lMkludGVyc2VjdHNUcmlhbmdsZTI7XHJcbmZ1bmN0aW9uIGxpbmUySW50ZXJzZWN0c0NpcmNsZShsaHMsIHJocykge1xyXG4gICAgcmV0dXJuIGxpbmUySW50ZXJzZWN0c1BvaW50MihsaHMsIHJocywgcmhzLnJhZGl1cyk7XHJcbn1cclxuZXhwb3J0cy5saW5lMkludGVyc2VjdHNDaXJjbGUgPSBsaW5lMkludGVyc2VjdHNDaXJjbGU7XHJcbmZ1bmN0aW9uIGxpbmUySW50ZXJzZWN0c1BvaW50MihbYTEsIGEyXSwgYTAsIHRvbGVyYW5jZSkge1xyXG4gICAgZnVuY3Rpb24gZGlzdFRvU2VnbWVudFNxdWFyZWQoYTAsIGExLCBhMikge1xyXG4gICAgICAgIGZ1bmN0aW9uIG1hZ25pdHVkZUJldHdlZW5Qb2ludHNTcXVhcmVkKHYsIHcpIHtcclxuICAgICAgICAgICAgcmV0dXJuICh2LnggLSB3LngpICoqIDIgKyAodi55IC0gdy55KSAqKiAyO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBsZW5ndGhTcXVhcmVkT2ZMaW5lID0gbWFnbml0dWRlQmV0d2VlblBvaW50c1NxdWFyZWQoYTEsIGEyKTtcclxuICAgICAgICBpZiAobGVuZ3RoU3F1YXJlZE9mTGluZSA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbWFnbml0dWRlQmV0d2VlblBvaW50c1NxdWFyZWQoYTAsIGExKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgYW5nbGVPZkF0dGFjayA9ICgoYTAueCAtIGExLngpICogKGEyLnggLSBhMS54KSArIChhMC55IC0gYTEueSkgKiAoYTIueSAtIGExLnkpKSAvIGxlbmd0aFNxdWFyZWRPZkxpbmU7XHJcbiAgICAgICAgaWYgKGFuZ2xlT2ZBdHRhY2sgPCAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBtYWduaXR1ZGVCZXR3ZWVuUG9pbnRzU3F1YXJlZChhMCwgYTEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChhbmdsZU9mQXR0YWNrID4gMSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbWFnbml0dWRlQmV0d2VlblBvaW50c1NxdWFyZWQoYTAsIGEyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHBvaW50T25MaW5lID0ge1xyXG4gICAgICAgICAgICAgICAgeDogYTEueCArIGFuZ2xlT2ZBdHRhY2sgKiAoYTIueCAtIGExLngpLFxyXG4gICAgICAgICAgICAgICAgeTogYTEueSArIGFuZ2xlT2ZBdHRhY2sgKiAoYTIueSAtIGExLnkpXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHJldHVybiBtYWduaXR1ZGVCZXR3ZWVuUG9pbnRzU3F1YXJlZChhMCwgcG9pbnRPbkxpbmUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBkaXN0VG9TZWdtZW50U3F1YXJlZChhMCwgYTEsIGEyKSA8PSAodG9sZXJhbmNlICogdG9sZXJhbmNlKTtcclxufVxyXG5leHBvcnRzLmxpbmUySW50ZXJzZWN0c1BvaW50MiA9IGxpbmUySW50ZXJzZWN0c1BvaW50MjtcclxuZnVuY3Rpb24gbGluZTJJbnRlcnNlY3RzUmVjdGFuZ2xlKGxocywgcmhzKSB7XHJcbiAgICBjb25zdCB7IGJvdHRvbSwgdG9wLCBsZWZ0LCByaWdodCB9ID0gcmVjdGFuZ2xlX21vZGVsX2xpbmVzXzEubGluZXMocmhzKTtcclxuICAgIHJldHVybiBsaW5lMkludGVyc2VjdHNMaW5lMihsaHMsIHRvcClcclxuICAgICAgICB8fCBsaW5lMkludGVyc2VjdHNMaW5lMihsaHMsIGJvdHRvbSlcclxuICAgICAgICB8fCBsaW5lMkludGVyc2VjdHNMaW5lMihsaHMsIGxlZnQpXHJcbiAgICAgICAgfHwgbGluZTJJbnRlcnNlY3RzTGluZTIobGhzLCByaWdodCk7XHJcbn1cclxuZXhwb3J0cy5saW5lMkludGVyc2VjdHNSZWN0YW5nbGUgPSBsaW5lMkludGVyc2VjdHNSZWN0YW5nbGU7XHJcbmZ1bmN0aW9uIGxpbmUySW50ZXJzZWN0c0xpbmUyKFthMSwgYTJdLCBbYjEsIGIyXSkge1xyXG4gICAgY29uc3Qgc2FtZVNpZ24gPSAoeCwgeSkgPT4geCA+PSAwICYmIHkgPj0gMCB8fCB4IDw9IDAgJiYgeSA8PSAwO1xyXG4gICAgY29uc3QgeDEgPSBhMS54O1xyXG4gICAgY29uc3QgeTEgPSBhMS55O1xyXG4gICAgY29uc3QgeDIgPSBhMi54O1xyXG4gICAgY29uc3QgeTIgPSBhMi55O1xyXG4gICAgY29uc3QgeDMgPSBiMS54O1xyXG4gICAgY29uc3QgeTMgPSBiMS55O1xyXG4gICAgY29uc3QgeDQgPSBiMi54O1xyXG4gICAgY29uc3QgeTQgPSBiMi55O1xyXG4gICAgY29uc3QgczEgPSB5MiAtIHkxO1xyXG4gICAgY29uc3QgdDEgPSB4MSAtIHgyO1xyXG4gICAgY29uc3QgdTEgPSAoeDIgKiB5MSkgLSAoeDEgKiB5Mik7XHJcbiAgICBjb25zdCByMyA9ICgoczEgKiB4MykgKyAodDEgKiB5MykgKyB1MSk7XHJcbiAgICBjb25zdCByNCA9ICgoczEgKiB4NCkgKyAodDEgKiB5NCkgKyB1MSk7XHJcbiAgICBpZiAoKHIzICE9PSAwKSAmJiAocjQgIT09IDApICYmIHNhbWVTaWduKHIzLCByNCkpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBjb25zdCBzMiA9IHk0IC0geTM7XHJcbiAgICBjb25zdCB0MiA9IHgzIC0geDQ7XHJcbiAgICBjb25zdCB1MiA9ICh4NCAqIHkzKSAtICh4MyAqIHk0KTtcclxuICAgIGNvbnN0IHIxID0gKHMyICogeDEpICsgKHQyICogeTEpICsgdTI7XHJcbiAgICBjb25zdCByMiA9IChzMiAqIHgyKSArICh0MiAqIHkyKSArIHUyO1xyXG4gICAgaWYgKChyMSAhPT0gMCkgJiYgKHIyICE9PSAwKSAmJiAoc2FtZVNpZ24ocjEsIHIyKSkpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBjb25zdCBhID0gcG9pbnRfbW9kZWxfYm91bmRpbmdfMS5ib3VuZGluZ1RMQlIoYTEsIGEyKTtcclxuICAgIGNvbnN0IGIgPSBwb2ludF9tb2RlbF9ib3VuZGluZ18xLmJvdW5kaW5nVExCUihiMSwgYjIpO1xyXG4gICAgcmV0dXJuICEoYS50b3BMZWZ0LnggPiBiLmJvdHRvbVJpZ2h0LnhcclxuICAgICAgICB8fCBhLnRvcExlZnQueSA+IGIuYm90dG9tUmlnaHQueVxyXG4gICAgICAgIHx8IGEuYm90dG9tUmlnaHQueCA8IGIudG9wTGVmdC54XHJcbiAgICAgICAgfHwgYS5ib3R0b21SaWdodC55IDwgYi50b3BMZWZ0LnkpO1xyXG59XHJcbmV4cG9ydHMubGluZTJJbnRlcnNlY3RzTGluZTIgPSBsaW5lMkludGVyc2VjdHNMaW5lMjtcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL0Btb3JsZXlkZXYvcGF1cGVyL21vZGVscy9saW5lL2xpbmUubW9kZWwuaW50ZXJzZWN0LmpzIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3QgcG9pbnRfbW9kZWxfaXNfMSA9IHJlcXVpcmUoXCIuLi9wb2ludC9wb2ludC5tb2RlbC5pc1wiKTtcclxuZnVuY3Rpb24gaXMocG9zc2libHkpIHtcclxuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHBvc3NpYmx5KSAmJiBwb3NzaWJseS5sZW5ndGggPT09IDIgJiYgcG9zc2libHkuZXZlcnkocG9pbnRfbW9kZWxfaXNfMS5pcyk7XHJcbn1cclxuZXhwb3J0cy5pcyA9IGlzO1xyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvQG1vcmxleWRldi9wYXVwZXIvbW9kZWxzL2xpbmUvbGluZS5tb2RlbC5pcy5qcyIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IGludGVyc2VjdCA9IHJlcXVpcmUoXCIuL2xpbmUubW9kZWwuaW50ZXJzZWN0XCIpO1xyXG5jb25zdCBpcyA9IHJlcXVpcmUoXCIuL2xpbmUubW9kZWwuaXNcIik7XHJcbmNvbnN0IGxlbmd0aCA9IHJlcXVpcmUoXCIuL2xpbmUubW9kZWwubGVuZ3RoXCIpO1xyXG5jb25zdCBsaW5lVG8gPSByZXF1aXJlKFwiLi9saW5lLm1vZGVsLmxpbmVUb1wiKTtcclxuZXhwb3J0cy5MaW5lMiA9IE9iamVjdC5hc3NpZ24oKGEsIGIpID0+IFthLCBiXSwgT2JqZWN0LmFzc2lnbih7fSwgaW50ZXJzZWN0LCBpcywgbGVuZ3RoLCBsaW5lVG8pKTtcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL0Btb3JsZXlkZXYvcGF1cGVyL21vZGVscy9saW5lL2xpbmUubW9kZWwuanMiLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCB2ZWN0b3JfbWF0aHNfMSA9IHJlcXVpcmUoXCIuLi8uLi9tYXRocy92ZWN0b3IubWF0aHNcIik7XHJcbmZ1bmN0aW9uIGxlbmd0aE9mKGxpbmUpIHtcclxuICAgIHJldHVybiB2ZWN0b3JfbWF0aHNfMS5WZWN0b3IyLm1hZ25pdHVkZSh2ZWN0b3JfbWF0aHNfMS5WZWN0b3IyLnN1YnRyYWN0KGxpbmVbMV0sIGxpbmVbMF0pKTtcclxufVxyXG5leHBvcnRzLmxlbmd0aE9mID0gbGVuZ3RoT2Y7XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9AbW9ybGV5ZGV2L3BhdXBlci9tb2RlbHMvbGluZS9saW5lLm1vZGVsLmxlbmd0aC5qcyIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IGZ1bmN0aW9uYWxfcGlwZV8xID0gcmVxdWlyZShcIkBtb3JsZXlkZXYvZnVuY3Rpb25hbC1waXBlXCIpO1xyXG5jb25zdCBvcGVyYXRvcnNfMSA9IHJlcXVpcmUoXCJAbW9ybGV5ZGV2L2Z1bmN0aW9uYWwtcGlwZS9pdGVyYWJsZS9vcGVyYXRvcnNcIik7XHJcbmNvbnN0IHZlY3Rvcl9tYXRoc19mdW5jXzEgPSByZXF1aXJlKFwiLi4vLi4vbWF0aHMvdmVjdG9yLm1hdGhzLmZ1bmNcIik7XHJcbmNvbnN0IGNpcmNsZV9tb2RlbF9pc18xID0gcmVxdWlyZShcIi4uL2NpcmNsZS9jaXJjbGUubW9kZWwuaXNcIik7XHJcbmNvbnN0IHJlY3RhbmdsZV9tb2RlbF9pc18xID0gcmVxdWlyZShcIi4uL3JlY3RhbmdsZS9yZWN0YW5nbGUubW9kZWwuaXNcIik7XHJcbmNvbnN0IHJlY3RhbmdsZV9tb2RlbF9saW5lc18xID0gcmVxdWlyZShcIi4uL3JlY3RhbmdsZS9yZWN0YW5nbGUubW9kZWwubGluZXNcIik7XHJcbmNvbnN0IHRyaWFuZ2xlX21vZGVsX2lzXzEgPSByZXF1aXJlKFwiLi4vdHJpYW5nbGUvdHJpYW5nbGUubW9kZWwuaXNcIik7XHJcbmNvbnN0IGxpbmVfbW9kZWxfaXNfMSA9IHJlcXVpcmUoXCIuL2xpbmUubW9kZWwuaXNcIik7XHJcbmZ1bmN0aW9uIGxpbmVUbyhsaHMsIHJocykge1xyXG4gICAgaWYgKGxpbmVfbW9kZWxfaXNfMS5pcyhyaHMpKSB7XHJcbiAgICAgICAgcmV0dXJuIGxpbmVMaW5lMlRvTGluZTIobGhzLCByaHMpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodHJpYW5nbGVfbW9kZWxfaXNfMS5pcyhyaHMpKSB7XHJcbiAgICAgICAgcmV0dXJuIGxpbmVMaW5lMlRvVHJpYW5nbGUyKGxocywgcmhzKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGNpcmNsZV9tb2RlbF9pc18xLmlzKHJocykpIHtcclxuICAgICAgICByZXR1cm4gbGluZUxpbmUyVG9DaXJjbGUobGhzLCByaHMpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAocmVjdGFuZ2xlX21vZGVsX2lzXzEuaXMocmhzKSkge1xyXG4gICAgICAgIHJldHVybiBsaW5lTGluZTJUb1JlY3RhbmdsZShsaHMsIHJocyk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gbGluZUxpbmUyVG9Qb2ludDIobGhzLCByaHMpO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMubGluZVRvID0gbGluZVRvO1xyXG5mdW5jdGlvbiBsaW5lTGluZTJUb1RyaWFuZ2xlMihsaHMsIHJocykge1xyXG4gICAgcmV0dXJuIGZpbmRTaG9ydGVzdExpbmUoW1xyXG4gICAgICAgIGxpbmVMaW5lMlRvTGluZTIobGhzLCBbcmhzWzBdLCByaHNbMV1dKSxcclxuICAgICAgICBsaW5lTGluZTJUb0xpbmUyKGxocywgW3Joc1sxXSwgcmhzWzBdXSksXHJcbiAgICAgICAgbGluZUxpbmUyVG9MaW5lMihsaHMsIFtyaHNbMl0sIHJoc1swXV0pXHJcbiAgICBdKTtcclxufVxyXG5leHBvcnRzLmxpbmVMaW5lMlRvVHJpYW5nbGUyID0gbGluZUxpbmUyVG9UcmlhbmdsZTI7XHJcbmZ1bmN0aW9uIGZpbmRTaG9ydGVzdExpbmUobGluZXMpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbmFsX3BpcGVfMS4kJChsaW5lcylcclxuICAgICAgICAuJChvcGVyYXRvcnNfMS5tYXAobGluZSA9PiAoeyBzZWdtZW50OiBsaW5lLCBsZW5ndGgyOiB2ZWN0b3JfbWF0aHNfZnVuY18xLm1hZ25pdHVkZVNxdWFyZWQodmVjdG9yX21hdGhzX2Z1bmNfMS5zdWJ0cmFjdChsaW5lWzFdLCBsaW5lWzBdKSkgfSkpKVxyXG4gICAgICAgIC4kKG9wZXJhdG9yc18xLmZvbGQoKHByZXYsIGN1cnIpID0+IHByZXYubGVuZ3RoMiA8IGN1cnIubGVuZ3RoMiA/IHByZXYgOiBjdXJyKSlcclxuICAgICAgICAuJCQobGluZSA9PiBsaW5lLnNlZ21lbnQpO1xyXG59XHJcbmV4cG9ydHMuZmluZFNob3J0ZXN0TGluZSA9IGZpbmRTaG9ydGVzdExpbmU7XHJcbmZ1bmN0aW9uIGxpbmVMaW5lMlRvUmVjdGFuZ2xlKGxocywgcmhzKSB7XHJcbiAgICBjb25zdCBsaW5lU2V0ID0gcmVjdGFuZ2xlX21vZGVsX2xpbmVzXzEubGluZXMocmhzKTtcclxuICAgIHJldHVybiBmaW5kU2hvcnRlc3RMaW5lKFtcclxuICAgICAgICBsaW5lTGluZTJUb0xpbmUyKGxocywgbGluZVNldC50b3ApLFxyXG4gICAgICAgIGxpbmVMaW5lMlRvTGluZTIobGhzLCBsaW5lU2V0LmJvdHRvbSksXHJcbiAgICAgICAgbGluZUxpbmUyVG9MaW5lMihsaHMsIGxpbmVTZXQubGVmdCksXHJcbiAgICAgICAgbGluZUxpbmUyVG9MaW5lMihsaHMsIGxpbmVTZXQucmlnaHQpXHJcbiAgICBdKTtcclxufVxyXG5leHBvcnRzLmxpbmVMaW5lMlRvUmVjdGFuZ2xlID0gbGluZUxpbmUyVG9SZWN0YW5nbGU7XHJcbmZ1bmN0aW9uIGxpbmVMaW5lMlRvTGluZTIobGhzLCByaHMpIHtcclxuICAgIC8vIFRPRE86IGxpbmVUbyBMaW5lMiAtPiBMaW5lMiBub3QgcHJvcGVybHkgaW1wbGVtZW50ZWQsIHByb2R1Y2VzIHN1Yi1vcHRpbWFsIHJlc3VsdHNcclxuICAgIHJldHVybiBbZ2V0Q2VudHJlT2ZMaW5lKGxocyksIGdldENlbnRyZU9mTGluZShyaHMpXTtcclxufVxyXG5leHBvcnRzLmxpbmVMaW5lMlRvTGluZTIgPSBsaW5lTGluZTJUb0xpbmUyO1xyXG5mdW5jdGlvbiBsaW5lTGluZTJUb0NpcmNsZShsaHMsIHJocykge1xyXG4gICAgY29uc3QgW2wwXSA9IGxpbmVMaW5lMlRvUG9pbnQyKGxocywgcmhzKTtcclxuICAgIGNvbnN0IHJhZGl1cyA9IHJocy5yYWRpdXM7XHJcbiAgICBjb25zdCBsZW5ndGhPZkxpbmUgPSB2ZWN0b3JfbWF0aHNfZnVuY18xLnN1YnRyYWN0KHJocywgbDApO1xyXG4gICAgY29uc3QgYW5nbGVPZkxpbmUgPSB2ZWN0b3JfbWF0aHNfZnVuY18xLm5vcm1hbGlzZShsZW5ndGhPZkxpbmUpO1xyXG4gICAgY29uc3QgcmFkaXVzT2ZMaW5lID0gdmVjdG9yX21hdGhzX2Z1bmNfMS5tdWx0aXBseShhbmdsZU9mTGluZSwgcmhzLnJhZGl1cyk7XHJcbiAgICBjb25zdCByaHNQb3NpdGlvbiA9IHZlY3Rvcl9tYXRoc19mdW5jXzEuYWRkKHJocywgcmFkaXVzT2ZMaW5lKTtcclxuICAgIHJldHVybiBbbDAsIHJoc1Bvc2l0aW9uXTtcclxufVxyXG5leHBvcnRzLmxpbmVMaW5lMlRvQ2lyY2xlID0gbGluZUxpbmUyVG9DaXJjbGU7XHJcbmZ1bmN0aW9uIGxpbmVMaW5lMlRvUG9pbnQyKGxocywgcmhzKSB7XHJcbiAgICBjb25zdCBhMCA9IHJocztcclxuICAgIGNvbnN0IFthMSwgYTJdID0gbGhzO1xyXG4gICAgZnVuY3Rpb24gbWFnbml0dWRlQmV0d2VlblBvaW50c1NxdWFyZWQodiwgdykge1xyXG4gICAgICAgIHJldHVybiAodi54IC0gdy54KSAqKiAyICsgKHYueSAtIHcueSkgKiogMjtcclxuICAgIH1cclxuICAgIGNvbnN0IGxlbmd0aFNxdWFyZWRPZkxpbmUgPSBtYWduaXR1ZGVCZXR3ZWVuUG9pbnRzU3F1YXJlZChhMSwgYTIpO1xyXG4gICAgaWYgKGxlbmd0aFNxdWFyZWRPZkxpbmUgPT09IDApIHtcclxuICAgICAgICByZXR1cm4gW2ExLCBhMF07XHJcbiAgICB9XHJcbiAgICBjb25zdCBwb3NpdGlvbk9uTGluZSA9ICgoYTAueCAtIGExLngpICogKGEyLnggLSBhMS54KSArIChhMC55IC0gYTEueSkgKiAoYTIueSAtIGExLnkpKSAvIGxlbmd0aFNxdWFyZWRPZkxpbmU7XHJcbiAgICBpZiAocG9zaXRpb25PbkxpbmUgPCAwKSB7XHJcbiAgICAgICAgcmV0dXJuIFthMSwgYTBdO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAocG9zaXRpb25PbkxpbmUgPiAxKSB7XHJcbiAgICAgICAgcmV0dXJuIFthMiwgYTBdO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgY29uc3QgcG9pbnRPbkxpbmUgPSB7XHJcbiAgICAgICAgICAgIHg6IGExLnggKyBwb3NpdGlvbk9uTGluZSAqIChhMi54IC0gYTEueCksXHJcbiAgICAgICAgICAgIHk6IGExLnkgKyBwb3NpdGlvbk9uTGluZSAqIChhMi55IC0gYTEueSlcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBbcG9pbnRPbkxpbmUsIGEwXTtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLmxpbmVMaW5lMlRvUG9pbnQyID0gbGluZUxpbmUyVG9Qb2ludDI7XHJcbmZ1bmN0aW9uIGdldENlbnRyZU9mTGluZShsaHMpIHtcclxuICAgIHJldHVybiB2ZWN0b3JfbWF0aHNfZnVuY18xLmFkZChsaHNbMF0sIHZlY3Rvcl9tYXRoc19mdW5jXzEuZGl2aWRlKHZlY3Rvcl9tYXRoc19mdW5jXzEuc3VidHJhY3QobGhzWzFdLCBsaHNbMF0pLCAyKSk7XHJcbn1cclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL0Btb3JsZXlkZXYvcGF1cGVyL21vZGVscy9saW5lL2xpbmUubW9kZWwubGluZVRvLmpzIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3QgcG9pbnRfbW9kZWxfdGxicl8xID0gcmVxdWlyZShcIi4vcG9pbnQubW9kZWwudGxiclwiKTtcclxuZnVuY3Rpb24gYm91bmRpbmdUTEJSKC4uLl9wb2ludHMpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdG9wTGVmdDogcG9pbnRfbW9kZWxfdGxicl8xLmdldFRvcExlZnQoLi4uX3BvaW50cyksXHJcbiAgICAgICAgYm90dG9tUmlnaHQ6IHBvaW50X21vZGVsX3RsYnJfMS5nZXRCb3R0b21SaWdodCguLi5fcG9pbnRzKVxyXG4gICAgfTtcclxufVxyXG5leHBvcnRzLmJvdW5kaW5nVExCUiA9IGJvdW5kaW5nVExCUjtcclxuZnVuY3Rpb24gYm91bmRpbmcoLi4uX3BvaW50cykge1xyXG4gICAgY29uc3QgeyB0b3BMZWZ0LCBib3R0b21SaWdodCB9ID0gYm91bmRpbmdUTEJSKC4uLl9wb2ludHMpO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB4OiB0b3BMZWZ0LngsXHJcbiAgICAgICAgeTogdG9wTGVmdC55LFxyXG4gICAgICAgIHdpZHRoOiBib3R0b21SaWdodC54IC0gdG9wTGVmdC54LFxyXG4gICAgICAgIGhlaWdodDogYm90dG9tUmlnaHQueSAtIHRvcExlZnQueVxyXG4gICAgfTtcclxufVxyXG5leHBvcnRzLmJvdW5kaW5nID0gYm91bmRpbmc7XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9AbW9ybGV5ZGV2L3BhdXBlci9tb2RlbHMvcG9pbnQvcG9pbnQubW9kZWwuYm91bmRpbmcuanMiLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5mdW5jdGlvbiBpcyhwb3NzaWJseSkge1xyXG4gICAgcmV0dXJuIHBvc3NpYmx5LnggIT0gbnVsbCAmJiBwb3NzaWJseS55ICE9IG51bGw7XHJcbn1cclxuZXhwb3J0cy5pcyA9IGlzO1xyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvQG1vcmxleWRldi9wYXVwZXIvbW9kZWxzL3BvaW50L3BvaW50Lm1vZGVsLmlzLmpzIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3QgYm91bmRpbmcgPSByZXF1aXJlKFwiLi9wb2ludC5tb2RlbC5ib3VuZGluZ1wiKTtcclxuY29uc3QgaXMgPSByZXF1aXJlKFwiLi9wb2ludC5tb2RlbC5pc1wiKTtcclxuY29uc3QgdGxiciA9IHJlcXVpcmUoXCIuL3BvaW50Lm1vZGVsLnRsYnJcIik7XHJcbmV4cG9ydHMuUG9pbnQyID0gT2JqZWN0LmFzc2lnbigoeCwgeSkgPT4gKHsgeCwgeSB9KSwgT2JqZWN0LmFzc2lnbih7fSwgdGxiciwgYm91bmRpbmcsIGlzKSk7XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9AbW9ybGV5ZGV2L3BhdXBlci9tb2RlbHMvcG9pbnQvcG9pbnQubW9kZWwuanMiLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCBvcGVyYXRvcnNfMSA9IHJlcXVpcmUoXCJAbW9ybGV5ZGV2L2Z1bmN0aW9uYWwtcGlwZS9pdGVyYWJsZS9vcGVyYXRvcnNcIik7XHJcbmZ1bmN0aW9uIGdldFRvcExlZnQoLi4uX3BvaW50cykge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB4OiBNYXRoLm1pbiguLi5vcGVyYXRvcnNfMS5tYXAoKHBvaW50KSA9PiBwb2ludC54KShfcG9pbnRzKSksXHJcbiAgICAgICAgeTogTWF0aC5taW4oLi4ub3BlcmF0b3JzXzEubWFwKChwb2ludCkgPT4gcG9pbnQueSkoX3BvaW50cykpLFxyXG4gICAgfTtcclxufVxyXG5leHBvcnRzLmdldFRvcExlZnQgPSBnZXRUb3BMZWZ0O1xyXG5mdW5jdGlvbiBnZXRUb3BSaWdodCguLi5fcG9pbnRzKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHg6IE1hdGgubWF4KC4uLm9wZXJhdG9yc18xLm1hcCgocG9pbnQpID0+IHBvaW50LngpKF9wb2ludHMpKSxcclxuICAgICAgICB5OiBNYXRoLm1pbiguLi5vcGVyYXRvcnNfMS5tYXAoKHBvaW50KSA9PiBwb2ludC55KShfcG9pbnRzKSksXHJcbiAgICB9O1xyXG59XHJcbmV4cG9ydHMuZ2V0VG9wUmlnaHQgPSBnZXRUb3BSaWdodDtcclxuZnVuY3Rpb24gZ2V0Qm90dG9tTGVmdCguLi5fcG9pbnRzKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHg6IE1hdGgubWF4KC4uLm9wZXJhdG9yc18xLm1hcCgocG9pbnQpID0+IHBvaW50LngpKF9wb2ludHMpKSxcclxuICAgICAgICB5OiBNYXRoLm1pbiguLi5vcGVyYXRvcnNfMS5tYXAoKHBvaW50KSA9PiBwb2ludC55KShfcG9pbnRzKSksXHJcbiAgICB9O1xyXG59XHJcbmV4cG9ydHMuZ2V0Qm90dG9tTGVmdCA9IGdldEJvdHRvbUxlZnQ7XHJcbmZ1bmN0aW9uIGdldEJvdHRvbVJpZ2h0KC4uLl9wb2ludHMpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgeDogTWF0aC5tYXgoLi4ub3BlcmF0b3JzXzEubWFwKChwb2ludCkgPT4gcG9pbnQueCkoX3BvaW50cykpLFxyXG4gICAgICAgIHk6IE1hdGgubWF4KC4uLm9wZXJhdG9yc18xLm1hcCgocG9pbnQpID0+IHBvaW50LnkpKF9wb2ludHMpKSxcclxuICAgIH07XHJcbn1cclxuZXhwb3J0cy5nZXRCb3R0b21SaWdodCA9IGdldEJvdHRvbVJpZ2h0O1xyXG5mdW5jdGlvbiBnZXRDZW50cmUoLi4uX3BvaW50cykge1xyXG4gICAgY29uc3QgdGwgPSBnZXRUb3BMZWZ0KC4uLl9wb2ludHMpO1xyXG4gICAgY29uc3QgYnIgPSBnZXRCb3R0b21SaWdodCguLi5fcG9pbnRzKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgeDogdGwueCArIChici54IC0gdGwueCkgLyAyLFxyXG4gICAgICAgIHk6IHRsLnkgKyAoYnIueSAtIHRsLnkpIC8gMlxyXG4gICAgfTtcclxufVxyXG5leHBvcnRzLmdldENlbnRyZSA9IGdldENlbnRyZTtcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL0Btb3JsZXlkZXYvcGF1cGVyL21vZGVscy9wb2ludC9wb2ludC5tb2RlbC50bGJyLmpzIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3QgcG9pbnRfbW9kZWxfYm91bmRpbmdfMSA9IHJlcXVpcmUoXCIuLi9wb2ludC9wb2ludC5tb2RlbC5ib3VuZGluZ1wiKTtcclxuZnVuY3Rpb24gYm91bmRpbmdUTEJSKC4uLl9yZWN0cykge1xyXG4gICAgcmV0dXJuIHBvaW50X21vZGVsX2JvdW5kaW5nXzEuYm91bmRpbmdUTEJSKC4uLl9yZWN0cywgLi4uX3JlY3RzLm1hcChyZWN0ID0+ICh7IHg6IHJlY3QueCArIHJlY3Qud2lkdGgsIHk6IHJlY3QueSArIHJlY3QuaGVpZ2h0IH0pKSk7XHJcbn1cclxuZXhwb3J0cy5ib3VuZGluZ1RMQlIgPSBib3VuZGluZ1RMQlI7XHJcbmZ1bmN0aW9uIGJvdW5kaW5nKC4uLl9yZWN0cykge1xyXG4gICAgcmV0dXJuIHBvaW50X21vZGVsX2JvdW5kaW5nXzEuYm91bmRpbmcoLi4uX3JlY3RzLCAuLi5fcmVjdHMubWFwKHJlY3QgPT4gKHsgeDogcmVjdC54ICsgcmVjdC53aWR0aCwgeTogcmVjdC55ICsgcmVjdC5oZWlnaHQgfSkpKTtcclxufVxyXG5leHBvcnRzLmJvdW5kaW5nID0gYm91bmRpbmc7XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9AbW9ybGV5ZGV2L3BhdXBlci9tb2RlbHMvcmVjdGFuZ2xlL3JlY3RhbmdsZS5tb2RlbC5ib3VuZGluZy5qcyIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmZ1bmN0aW9uIGlzKHBvc3NpYmxlKSB7XHJcbiAgICByZXR1cm4gcG9zc2libGUueCAhPSBudWxsICYmIHBvc3NpYmxlLnkgIT0gbnVsbCAmJiBwb3NzaWJsZS53aWR0aCAhPSBudWxsICYmIHBvc3NpYmxlLmhlaWdodCAhPSBudWxsO1xyXG59XHJcbmV4cG9ydHMuaXMgPSBpcztcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL0Btb3JsZXlkZXYvcGF1cGVyL21vZGVscy9yZWN0YW5nbGUvcmVjdGFuZ2xlLm1vZGVsLmlzLmpzIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3QgYm91bmRpbmcgPSByZXF1aXJlKFwiLi9yZWN0YW5nbGUubW9kZWwuYm91bmRpbmdcIik7XHJcbmNvbnN0IGlzID0gcmVxdWlyZShcIi4vcmVjdGFuZ2xlLm1vZGVsLmlzXCIpO1xyXG5jb25zdCBsaW5lcyA9IHJlcXVpcmUoXCIuL3JlY3RhbmdsZS5tb2RlbC5saW5lc1wiKTtcclxuY29uc3QgbGluZVRvID0gcmVxdWlyZShcIi4vcmVjdGFuZ2xlLm1vZGVsLmxpbmVUb1wiKTtcclxuY29uc3Qgb3ZlcmxhcHMgPSByZXF1aXJlKFwiLi9yZWN0YW5nbGUubW9kZWwub3ZlcmxhcFwiKTtcclxuY29uc3QgdGxiciA9IHJlcXVpcmUoXCIuL3JlY3RhbmdsZS5tb2RlbC50bGJyXCIpO1xyXG5leHBvcnRzLlJlY3RhbmdsZSA9IE9iamVjdC5hc3NpZ24oKHgsIHksIHdpZHRoLCBoZWlnaHQpID0+ICh7IHgsIHksIHdpZHRoLCBoZWlnaHQgfSksIE9iamVjdC5hc3NpZ24oe30sIGJvdW5kaW5nLCB0bGJyLCBpcywgb3ZlcmxhcHMsIGxpbmVUbywgbGluZXMpKTtcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL0Btb3JsZXlkZXYvcGF1cGVyL21vZGVscy9yZWN0YW5nbGUvcmVjdGFuZ2xlLm1vZGVsLmpzIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3QgdmVjdG9yX21hdGhzX2Z1bmNfMSA9IHJlcXVpcmUoXCIuLi8uLi9tYXRocy92ZWN0b3IubWF0aHMuZnVuY1wiKTtcclxuY29uc3QgY2lyY2xlX21vZGVsX2lzXzEgPSByZXF1aXJlKFwiLi4vY2lyY2xlL2NpcmNsZS5tb2RlbC5pc1wiKTtcclxuY29uc3QgbGluZV9tb2RlbF9pc18xID0gcmVxdWlyZShcIi4uL2xpbmUvbGluZS5tb2RlbC5pc1wiKTtcclxuY29uc3QgbGluZV9tb2RlbF9saW5lVG9fMSA9IHJlcXVpcmUoXCIuLi9saW5lL2xpbmUubW9kZWwubGluZVRvXCIpO1xyXG5jb25zdCB0cmlhbmdsZV9tb2RlbF9pc18xID0gcmVxdWlyZShcIi4uL3RyaWFuZ2xlL3RyaWFuZ2xlLm1vZGVsLmlzXCIpO1xyXG5jb25zdCByZWN0YW5nbGVfbW9kZWxfaXNfMSA9IHJlcXVpcmUoXCIuL3JlY3RhbmdsZS5tb2RlbC5pc1wiKTtcclxuY29uc3QgcmVjdGFuZ2xlX21vZGVsX2xpbmVzXzEgPSByZXF1aXJlKFwiLi9yZWN0YW5nbGUubW9kZWwubGluZXNcIik7XHJcbmNvbnN0IHJlY3RhbmdsZV9tb2RlbF90bGJyXzEgPSByZXF1aXJlKFwiLi9yZWN0YW5nbGUubW9kZWwudGxiclwiKTtcclxuZnVuY3Rpb24gbGluZVRvKGxocywgcmhzKSB7XHJcbiAgICBpZiAobGluZV9tb2RlbF9pc18xLmlzKHJocykpIHtcclxuICAgICAgICBjb25zdCBbYiwgYV0gPSBsaW5lX21vZGVsX2xpbmVUb18xLmxpbmVMaW5lMlRvUmVjdGFuZ2xlKHJocywgbGhzKTtcclxuICAgICAgICByZXR1cm4gW2EsIGJdO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodHJpYW5nbGVfbW9kZWxfaXNfMS5pcyhyaHMpKSB7XHJcbiAgICAgICAgcmV0dXJuIGxpbmVSZWN0YW5nbGVUb1RyaWFuZ2xlKGxocywgcmhzKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGNpcmNsZV9tb2RlbF9pc18xLmlzKHJocykpIHtcclxuICAgICAgICByZXR1cm4gbGluZVJlY3RhbmdsZVRvQ2lyY2xlKGxocywgcmhzKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHJlY3RhbmdsZV9tb2RlbF9pc18xLmlzKHJocykpIHtcclxuICAgICAgICByZXR1cm4gbGluZVJlY3RhbmdsZVRvUmVjdGFuZ2xlKGxocywgcmhzKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBsaW5lUmVjdGFuZ2xlVG9Qb2ludDIobGhzLCByaHMpO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMubGluZVRvID0gbGluZVRvO1xyXG5mdW5jdGlvbiBsaW5lUmVjdGFuZ2xlVG9UcmlhbmdsZShsaHMsIHJocykge1xyXG4gICAgY29uc3QgeyBsZWZ0LCByaWdodCwgdG9wLCBib3R0b20gfSA9IHJlY3RhbmdsZV9tb2RlbF9saW5lc18xLmxpbmVzKGxocyk7XHJcbiAgICByZXR1cm4gbGluZV9tb2RlbF9saW5lVG9fMS5maW5kU2hvcnRlc3RMaW5lKFtcclxuICAgICAgICBsaW5lX21vZGVsX2xpbmVUb18xLmxpbmVMaW5lMlRvVHJpYW5nbGUyKGxlZnQsIHJocyksXHJcbiAgICAgICAgbGluZV9tb2RlbF9saW5lVG9fMS5saW5lTGluZTJUb1RyaWFuZ2xlMihyaWdodCwgcmhzKSxcclxuICAgICAgICBsaW5lX21vZGVsX2xpbmVUb18xLmxpbmVMaW5lMlRvVHJpYW5nbGUyKHRvcCwgcmhzKSxcclxuICAgICAgICBsaW5lX21vZGVsX2xpbmVUb18xLmxpbmVMaW5lMlRvVHJpYW5nbGUyKGJvdHRvbSwgcmhzKVxyXG4gICAgXSk7XHJcbn1cclxuZXhwb3J0cy5saW5lUmVjdGFuZ2xlVG9UcmlhbmdsZSA9IGxpbmVSZWN0YW5nbGVUb1RyaWFuZ2xlO1xyXG5mdW5jdGlvbiBsaW5lUmVjdGFuZ2xlVG9SZWN0YW5nbGUobGhzLCByaHMpIHtcclxuICAgIC8vIFdBUk5JTkc6IERvZXMgbm90IHByb2R1Y2UgdGhlIG9wdGltYWwgc29sdXRpb25cclxuICAgIGNvbnN0IGxoc0NlbnRyZSA9IHJlY3RhbmdsZV9tb2RlbF90bGJyXzEuZ2V0Q2VudHJlKGxocyk7XHJcbiAgICBjb25zdCByaHNDZW50cmUgPSByZWN0YW5nbGVfbW9kZWxfdGxicl8xLmdldENlbnRyZShyaHMpO1xyXG4gICAgY29uc3QgW2xoc0VkZ2VdID0gbGluZVRvKGxocywgcmhzQ2VudHJlKTtcclxuICAgIGNvbnN0IFtyaHNFZGdlXSA9IGxpbmVUbyhyaHMsIGxoc0NlbnRyZSk7XHJcbiAgICByZXR1cm4gW2xoc0VkZ2UsIHJoc0VkZ2VdO1xyXG59XHJcbmV4cG9ydHMubGluZVJlY3RhbmdsZVRvUmVjdGFuZ2xlID0gbGluZVJlY3RhbmdsZVRvUmVjdGFuZ2xlO1xyXG5mdW5jdGlvbiBsaW5lUmVjdGFuZ2xlVG9DaXJjbGUobGhzLCByaHMpIHtcclxuICAgIGNvbnN0IFtwb2ludE9uUmVjdGFuZ2xlLCBjZW50cmVPZkNpcmNsZV0gPSBsaW5lUmVjdGFuZ2xlVG9Qb2ludDIobGhzLCByaHMpO1xyXG4gICAgY29uc3QgdmVjdG9yT2ZMaW5lID0gdmVjdG9yX21hdGhzX2Z1bmNfMS5zdWJ0cmFjdChwb2ludE9uUmVjdGFuZ2xlLCBjZW50cmVPZkNpcmNsZSk7XHJcbiAgICBjb25zdCBub3JtYWxpc2VkTGluZSA9IHZlY3Rvcl9tYXRoc19mdW5jXzEubm9ybWFsaXNlKHZlY3Rvck9mTGluZSk7XHJcbiAgICBjb25zdCBsaW5lT2ZSYWRpdXNMZW5ndGggPSB2ZWN0b3JfbWF0aHNfZnVuY18xLm11bHRpcGx5KG5vcm1hbGlzZWRMaW5lLCByaHMucmFkaXVzKTtcclxuICAgIGNvbnN0IHBvaW50T25DaXJjbGUgPSB2ZWN0b3JfbWF0aHNfZnVuY18xLmFkZChsaW5lT2ZSYWRpdXNMZW5ndGgsIGNlbnRyZU9mQ2lyY2xlKTtcclxuICAgIHJldHVybiBbcG9pbnRPblJlY3RhbmdsZSwgcG9pbnRPbkNpcmNsZV07XHJcbn1cclxuZXhwb3J0cy5saW5lUmVjdGFuZ2xlVG9DaXJjbGUgPSBsaW5lUmVjdGFuZ2xlVG9DaXJjbGU7XHJcbmZ1bmN0aW9uIGxpbmVSZWN0YW5nbGVUb1BvaW50MihsaHMsIHJocykge1xyXG4gICAgaWYgKHJocy54IDw9IGxocy54KSB7XHJcbiAgICAgICAgaWYgKHJocy55IDw9IGxocy55KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbbGhzLCByaHNdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChyaHMueSA+IGxocy55ICsgbGhzLmhlaWdodCkge1xyXG4gICAgICAgICAgICByZXR1cm4gW3JlY3RhbmdsZV9tb2RlbF90bGJyXzEuZ2V0Qm90dG9tTGVmdChsaHMpLCByaHNdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIFt7IHg6IGxocy54LCB5OiByaHMueSB9LCByaHNdO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHJocy54ID49IGxocy54ICsgbGhzLndpZHRoKSB7XHJcbiAgICAgICAgaWYgKHJocy55IDwgbGhzLnkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFtyZWN0YW5nbGVfbW9kZWxfdGxicl8xLmdldFRvcFJpZ2h0KGxocyksIHJoc107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHJocy55ID4gbGhzLnkgKyBsaHMuaGVpZ2h0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbcmVjdGFuZ2xlX21vZGVsX3RsYnJfMS5nZXRCb3R0b21SaWdodChsaHMpLCByaHNdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIFt7IHg6IGxocy54ICsgbGhzLndpZHRoLCB5OiByaHMueSB9LCByaHNdO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHJocy55IDw9IGxocy55KSB7XHJcbiAgICAgICAgcmV0dXJuIFt7IHg6IHJocy54LCB5OiBsaHMueSB9LCByaHNdO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAocmhzLnkgPj0gbGhzLnkgKyBsaHMuaGVpZ2h0KSB7XHJcbiAgICAgICAgcmV0dXJuIFt7IHg6IHJocy54LCB5OiBsaHMueSArIGxocy5oZWlnaHQgfSwgcmhzXTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBbcmVjdGFuZ2xlX21vZGVsX3RsYnJfMS5nZXRDZW50cmUobGhzKSwgcmhzXTtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLmxpbmVSZWN0YW5nbGVUb1BvaW50MiA9IGxpbmVSZWN0YW5nbGVUb1BvaW50MjtcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL0Btb3JsZXlkZXYvcGF1cGVyL21vZGVscy9yZWN0YW5nbGUvcmVjdGFuZ2xlLm1vZGVsLmxpbmVUby5qcyIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IHJlY3RhbmdsZV9tb2RlbF9ib3VuZGluZ18xID0gcmVxdWlyZShcIi4vcmVjdGFuZ2xlLm1vZGVsLmJvdW5kaW5nXCIpO1xyXG5mdW5jdGlvbiBsaW5lcyhyZWN0YW5nbGUpIHtcclxuICAgIGNvbnN0IGJvdW5kaW5nID0gcmVjdGFuZ2xlX21vZGVsX2JvdW5kaW5nXzEuYm91bmRpbmdUTEJSKHJlY3RhbmdsZSk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHRvcDogW2JvdW5kaW5nLnRvcExlZnQsIHsgeDogYm91bmRpbmcuYm90dG9tUmlnaHQueCwgeTogYm91bmRpbmcudG9wTGVmdC55IH1dLFxyXG4gICAgICAgIGxlZnQ6IFtib3VuZGluZy50b3BMZWZ0LCB7IHg6IGJvdW5kaW5nLnRvcExlZnQueCwgeTogYm91bmRpbmcuYm90dG9tUmlnaHQueSB9XSxcclxuICAgICAgICBib3R0b206IFt7IHg6IGJvdW5kaW5nLnRvcExlZnQueCwgeTogYm91bmRpbmcuYm90dG9tUmlnaHQueSB9LCBib3VuZGluZy5ib3R0b21SaWdodF0sXHJcbiAgICAgICAgcmlnaHQ6IFt7IHg6IGJvdW5kaW5nLmJvdHRvbVJpZ2h0LngsIHk6IGJvdW5kaW5nLnRvcExlZnQueSB9LCBib3VuZGluZy5ib3R0b21SaWdodF1cclxuICAgIH07XHJcbn1cclxuZXhwb3J0cy5saW5lcyA9IGxpbmVzO1xyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvQG1vcmxleWRldi9wYXVwZXIvbW9kZWxzL3JlY3RhbmdsZS9yZWN0YW5nbGUubW9kZWwubGluZXMuanMiLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCBjaXJjbGVfbW9kZWxfaXNfMSA9IHJlcXVpcmUoXCIuLi9jaXJjbGUvY2lyY2xlLm1vZGVsLmlzXCIpO1xyXG5jb25zdCBsaW5lX21vZGVsX2ludGVyc2VjdF8xID0gcmVxdWlyZShcIi4uL2xpbmUvbGluZS5tb2RlbC5pbnRlcnNlY3RcIik7XHJcbmNvbnN0IGxpbmVfbW9kZWxfaXNfMSA9IHJlcXVpcmUoXCIuLi9saW5lL2xpbmUubW9kZWwuaXNcIik7XHJcbmNvbnN0IGxpbmVfbW9kZWxfbGVuZ3RoXzEgPSByZXF1aXJlKFwiLi4vbGluZS9saW5lLm1vZGVsLmxlbmd0aFwiKTtcclxuY29uc3QgdHJpYW5nbGVfbW9kZWxfaXNfMSA9IHJlcXVpcmUoXCIuLi90cmlhbmdsZS90cmlhbmdsZS5tb2RlbC5pc1wiKTtcclxuY29uc3QgdHJpYW5nbGVfbW9kZWxfb3ZlcmxhcF8xID0gcmVxdWlyZShcIi4uL3RyaWFuZ2xlL3RyaWFuZ2xlLm1vZGVsLm92ZXJsYXBcIik7XHJcbmNvbnN0IHJlY3RhbmdsZV9tb2RlbF9pc18xID0gcmVxdWlyZShcIi4vcmVjdGFuZ2xlLm1vZGVsLmlzXCIpO1xyXG5jb25zdCByZWN0YW5nbGVfbW9kZWxfbGluZVRvXzEgPSByZXF1aXJlKFwiLi9yZWN0YW5nbGUubW9kZWwubGluZVRvXCIpO1xyXG5mdW5jdGlvbiBvdmVybGFwcyhsaHMsIHJocykge1xyXG4gICAgaWYgKGxpbmVfbW9kZWxfaXNfMS5pcyhyaHMpKSB7XHJcbiAgICAgICAgcmV0dXJuIHJlY3RhbmdsZU92ZXJsYXBzTGluZTIobGhzLCByaHMpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodHJpYW5nbGVfbW9kZWxfaXNfMS5pcyhyaHMpKSB7XHJcbiAgICAgICAgcmV0dXJuIHJlY3RhbmdsZU92ZXJsYXBzVHJpYW5nbGUyKGxocywgcmhzKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHJlY3RhbmdsZV9tb2RlbF9pc18xLmlzKHJocykpIHtcclxuICAgICAgICByZXR1cm4gcmVjdGFuZ2xlT3ZlcmxhcHNSZWN0YW5nbGUobGhzLCByaHMpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoY2lyY2xlX21vZGVsX2lzXzEuaXMocmhzKSkge1xyXG4gICAgICAgIHJldHVybiByZWN0YW5nbGVPdmVybGFwc0NpcmNsZShsaHMsIHJocyk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gcmVjdGFuZ2xlT3ZlcmxhcHNQb2ludDIobGhzLCByaHMpO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMub3ZlcmxhcHMgPSBvdmVybGFwcztcclxuZnVuY3Rpb24gcmVjdGFuZ2xlT3ZlcmxhcHNMaW5lMihsaHMsIHJocykge1xyXG4gICAgaWYgKHJlY3RhbmdsZU92ZXJsYXBzUG9pbnQyKGxocywgcmhzWzBdKSB8fCByZWN0YW5nbGVPdmVybGFwc1BvaW50MihsaHMsIHJoc1sxXSkpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIHJldHVybiBsaW5lX21vZGVsX2ludGVyc2VjdF8xLmxpbmUySW50ZXJzZWN0c1JlY3RhbmdsZShyaHMsIGxocyk7XHJcbn1cclxuZXhwb3J0cy5yZWN0YW5nbGVPdmVybGFwc0xpbmUyID0gcmVjdGFuZ2xlT3ZlcmxhcHNMaW5lMjtcclxuZnVuY3Rpb24gcmVjdGFuZ2xlT3ZlcmxhcHNUcmlhbmdsZTIobGhzLCByaHMpIHtcclxuICAgIHJldHVybiB0cmlhbmdsZV9tb2RlbF9vdmVybGFwXzEudHJpYW5nbGUyT3ZlcmxhcHNSZWN0YW5nbGUocmhzLCBsaHMpO1xyXG59XHJcbmV4cG9ydHMucmVjdGFuZ2xlT3ZlcmxhcHNUcmlhbmdsZTIgPSByZWN0YW5nbGVPdmVybGFwc1RyaWFuZ2xlMjtcclxuZnVuY3Rpb24gcmVjdGFuZ2xlT3ZlcmxhcHNSZWN0YW5nbGUobGhzLCByaHMpIHtcclxuICAgIHJldHVybiAhKGxocy54ID4gcmhzLnggKyByaHMud2lkdGhcclxuICAgICAgICB8fCBsaHMueSA+IHJocy55ICsgcmhzLmhlaWdodFxyXG4gICAgICAgIHx8IGxocy54ICsgbGhzLndpZHRoIDwgcmhzLnhcclxuICAgICAgICB8fCBsaHMueSArIGxocy5oZWlnaHQgPCByaHMueSk7XHJcbn1cclxuZXhwb3J0cy5yZWN0YW5nbGVPdmVybGFwc1JlY3RhbmdsZSA9IHJlY3RhbmdsZU92ZXJsYXBzUmVjdGFuZ2xlO1xyXG5mdW5jdGlvbiByZWN0YW5nbGVPdmVybGFwc0NpcmNsZShsaHMsIHJocykge1xyXG4gICAgcmV0dXJuIHJlY3RhbmdsZU92ZXJsYXBzUG9pbnQyKGxocywgcmhzKSB8fCBsaW5lX21vZGVsX2xlbmd0aF8xLmxlbmd0aE9mKHJlY3RhbmdsZV9tb2RlbF9saW5lVG9fMS5saW5lVG8obGhzLCB7IHg6IHJocy54LCB5OiByaHMueSB9KSkgPD0gcmhzLnJhZGl1cztcclxufVxyXG5leHBvcnRzLnJlY3RhbmdsZU92ZXJsYXBzQ2lyY2xlID0gcmVjdGFuZ2xlT3ZlcmxhcHNDaXJjbGU7XHJcbmZ1bmN0aW9uIHJlY3RhbmdsZU92ZXJsYXBzUG9pbnQyKGxocywgcmhzKSB7XHJcbiAgICByZXR1cm4gcmhzLnggPj0gbGhzLnggJiYgcmhzLnggPD0gbGhzLnggKyBsaHMud2lkdGggJiYgcmhzLnkgPj0gbGhzLnkgJiYgcmhzLnkgPD0gbGhzLnkgKyBsaHMuaGVpZ2h0O1xyXG59XHJcbmV4cG9ydHMucmVjdGFuZ2xlT3ZlcmxhcHNQb2ludDIgPSByZWN0YW5nbGVPdmVybGFwc1BvaW50MjtcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL0Btb3JsZXlkZXYvcGF1cGVyL21vZGVscy9yZWN0YW5nbGUvcmVjdGFuZ2xlLm1vZGVsLm92ZXJsYXAuanMiLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5mdW5jdGlvbiBnZXRDZW50cmUocmVjdGFuZ2xlKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHg6IHJlY3RhbmdsZS54ICsgcmVjdGFuZ2xlLndpZHRoIC8gMixcclxuICAgICAgICB5OiByZWN0YW5nbGUueSArIHJlY3RhbmdsZS5oZWlnaHQgLyAyXHJcbiAgICB9O1xyXG59XHJcbmV4cG9ydHMuZ2V0Q2VudHJlID0gZ2V0Q2VudHJlO1xyXG5mdW5jdGlvbiBnZXRUb3BMZWZ0KHJlY3RhbmdsZSkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB4OiByZWN0YW5nbGUueCxcclxuICAgICAgICB5OiByZWN0YW5nbGUueVxyXG4gICAgfTtcclxufVxyXG5leHBvcnRzLmdldFRvcExlZnQgPSBnZXRUb3BMZWZ0O1xyXG5mdW5jdGlvbiBnZXRUb3BSaWdodChyZWN0YW5nbGUpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgeDogcmVjdGFuZ2xlLnggKyByZWN0YW5nbGUud2lkdGgsXHJcbiAgICAgICAgeTogcmVjdGFuZ2xlLnlcclxuICAgIH07XHJcbn1cclxuZXhwb3J0cy5nZXRUb3BSaWdodCA9IGdldFRvcFJpZ2h0O1xyXG5mdW5jdGlvbiBnZXRCb3R0b21MZWZ0KHJlY3RhbmdsZSkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB4OiByZWN0YW5nbGUueCxcclxuICAgICAgICB5OiByZWN0YW5nbGUueSArIHJlY3RhbmdsZS5oZWlnaHRcclxuICAgIH07XHJcbn1cclxuZXhwb3J0cy5nZXRCb3R0b21MZWZ0ID0gZ2V0Qm90dG9tTGVmdDtcclxuZnVuY3Rpb24gZ2V0Qm90dG9tUmlnaHQocmVjdGFuZ2xlKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHg6IHJlY3RhbmdsZS54ICsgcmVjdGFuZ2xlLndpZHRoLFxyXG4gICAgICAgIHk6IHJlY3RhbmdsZS55ICsgcmVjdGFuZ2xlLmhlaWdodFxyXG4gICAgfTtcclxufVxyXG5leHBvcnRzLmdldEJvdHRvbVJpZ2h0ID0gZ2V0Qm90dG9tUmlnaHQ7XHJcbmZ1bmN0aW9uIGZyb21Ub3BMZWZ0Qm90dG9tUmlnaHQodGwsIGJyKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHg6IHRsLngsXHJcbiAgICAgICAgeTogdGwueSxcclxuICAgICAgICB3aWR0aDogYnIueCAtIHRsLngsXHJcbiAgICAgICAgaGVpZ2h0OiBici55IC0gdGwueVxyXG4gICAgfTtcclxufVxyXG5leHBvcnRzLmZyb21Ub3BMZWZ0Qm90dG9tUmlnaHQgPSBmcm9tVG9wTGVmdEJvdHRvbVJpZ2h0O1xyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvQG1vcmxleWRldi9wYXVwZXIvbW9kZWxzL3JlY3RhbmdsZS9yZWN0YW5nbGUubW9kZWwudGxici5qcyIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IHZlY3Rvcl9tYXRoc18xID0gcmVxdWlyZShcIi4uL21hdGhzL3ZlY3Rvci5tYXRoc1wiKTtcclxuY29uc3QgY2lyY2xlX21vZGVsXzEgPSByZXF1aXJlKFwiLi9jaXJjbGUvY2lyY2xlLm1vZGVsXCIpO1xyXG5jb25zdCBsaW5lX21vZGVsXzEgPSByZXF1aXJlKFwiLi9saW5lL2xpbmUubW9kZWxcIik7XHJcbmNvbnN0IHBvaW50X21vZGVsXzEgPSByZXF1aXJlKFwiLi9wb2ludC9wb2ludC5tb2RlbFwiKTtcclxuY29uc3QgcmVjdGFuZ2xlX21vZGVsXzEgPSByZXF1aXJlKFwiLi9yZWN0YW5nbGUvcmVjdGFuZ2xlLm1vZGVsXCIpO1xyXG5jb25zdCByZWN0YW5nbGVfbW9kZWxfdGxicl8xID0gcmVxdWlyZShcIi4vcmVjdGFuZ2xlL3JlY3RhbmdsZS5tb2RlbC50bGJyXCIpO1xyXG5jb25zdCB0cmlhbmdsZV9tb2RlbF8xID0gcmVxdWlyZShcIi4vdHJpYW5nbGUvdHJpYW5nbGUubW9kZWxcIik7XHJcbnZhciBjaXJjbGVfbW9kZWxfMiA9IHJlcXVpcmUoXCIuL2NpcmNsZS9jaXJjbGUubW9kZWxcIik7XHJcbmV4cG9ydHMuQ2lyY2xlID0gY2lyY2xlX21vZGVsXzIuQ2lyY2xlO1xyXG52YXIgcG9pbnRfbW9kZWxfMiA9IHJlcXVpcmUoXCIuL3BvaW50L3BvaW50Lm1vZGVsXCIpO1xyXG5leHBvcnRzLlBvaW50MiA9IHBvaW50X21vZGVsXzIuUG9pbnQyO1xyXG52YXIgbGluZV9tb2RlbF8yID0gcmVxdWlyZShcIi4vbGluZS9saW5lLm1vZGVsXCIpO1xyXG5leHBvcnRzLkxpbmUyID0gbGluZV9tb2RlbF8yLkxpbmUyO1xyXG52YXIgcmVjdGFuZ2xlX21vZGVsXzIgPSByZXF1aXJlKFwiLi9yZWN0YW5nbGUvcmVjdGFuZ2xlLm1vZGVsXCIpO1xyXG5leHBvcnRzLlJlY3RhbmdsZSA9IHJlY3RhbmdsZV9tb2RlbF8yLlJlY3RhbmdsZTtcclxudmFyIHRleHRfbW9kZWxfMSA9IHJlcXVpcmUoXCIuL3RleHQvdGV4dC5tb2RlbFwiKTtcclxuZXhwb3J0cy5UZXh0MiA9IHRleHRfbW9kZWxfMS5UZXh0MjtcclxudmFyIHRyaWFuZ2xlX21vZGVsXzIgPSByZXF1aXJlKFwiLi90cmlhbmdsZS90cmlhbmdsZS5tb2RlbFwiKTtcclxuZXhwb3J0cy5UcmlhbmdsZTIgPSB0cmlhbmdsZV9tb2RlbF8yLlRyaWFuZ2xlMjtcclxuZXhwb3J0cy5TaGFwZTIgPSB7XHJcbiAgICBjb2xsaXNpb24obGhzLCByaHMpIHtcclxuICAgICAgICBpZiAobGluZV9tb2RlbF8xLkxpbmUyLmlzKGxocykpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGxpbmVfbW9kZWxfMS5MaW5lMi5pbnRlcnNlY3RzKGxocywgcmhzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodHJpYW5nbGVfbW9kZWxfMS5UcmlhbmdsZTIuaXMobGhzKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJpYW5nbGVfbW9kZWxfMS5UcmlhbmdsZTIub3ZlcmxhcHMobGhzLCByaHMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChjaXJjbGVfbW9kZWxfMS5DaXJjbGUuaXMobGhzKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gY2lyY2xlX21vZGVsXzEuQ2lyY2xlLm92ZXJsYXBzKGxocywgcmhzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAocmVjdGFuZ2xlX21vZGVsXzEuUmVjdGFuZ2xlLmlzKGxocykpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHJlY3RhbmdsZV9tb2RlbF8xLlJlY3RhbmdsZS5vdmVybGFwcyhsaHMsIHJocyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIGFkZChsaHMsIHJocykge1xyXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGxocykpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGxocy5tYXAodmVydCA9PiB2ZWN0b3JfbWF0aHNfMS5WZWN0b3IyLmFkZCh2ZXJ0LCByaHMpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBsaHMsIHZlY3Rvcl9tYXRoc18xLlZlY3RvcjIuYWRkKGxocywgcmhzKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIGdldENlbnRyZShzaGFwZSkge1xyXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHNoYXBlKSkge1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgeDogc2hhcGUubWFwKGEgPT4gYS54KS5yZWR1Y2UoKHN1bSwgY3VycikgPT4gc3VtICsgY3VycikgLyBzaGFwZS5sZW5ndGgsXHJcbiAgICAgICAgICAgICAgICB5OiBzaGFwZS5tYXAoYSA9PiBhLnkpLnJlZHVjZSgoc3VtLCBjdXJyKSA9PiBzdW0gKyBjdXJyKSAvIHNoYXBlLmxlbmd0aFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChyZWN0YW5nbGVfbW9kZWxfMS5SZWN0YW5nbGUuaXMoc2hhcGUpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiByZWN0YW5nbGVfbW9kZWxfdGxicl8xLmdldENlbnRyZShzaGFwZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4geyB4OiBzaGFwZS54LCB5OiBzaGFwZS55IH07XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIGJvdW5kaW5nKGxocykge1xyXG4gICAgICAgIGlmIChsaW5lX21vZGVsXzEuTGluZTIuaXMobGhzKSkge1xyXG4gICAgICAgICAgICBjb25zdCB0b3BMZWZ0ID0geyB4OiBNYXRoLm1pbihsaHNbMF0ueCwgbGhzWzFdLngpLCB5OiBNYXRoLm1pbihsaHNbMF0ueSwgbGhzWzFdLnkpIH07XHJcbiAgICAgICAgICAgIGNvbnN0IGJvdHRvbVJpZ2h0ID0geyB4OiBNYXRoLm1heChsaHNbMF0ueCwgbGhzWzFdLngpLCB5OiBNYXRoLm1heChsaHNbMF0ueSwgbGhzWzFdLnkpIH07XHJcbiAgICAgICAgICAgIHJldHVybiByZWN0YW5nbGVfbW9kZWxfMS5SZWN0YW5nbGUuZnJvbVRvcExlZnRCb3R0b21SaWdodCh0b3BMZWZ0LCBib3R0b21SaWdodCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRyaWFuZ2xlX21vZGVsXzEuVHJpYW5nbGUyLmlzKGxocykpIHtcclxuICAgICAgICAgICAgY29uc3QgdG9wTGVmdCA9IHsgeDogTWF0aC5taW4obGhzWzBdLngsIGxoc1sxXS54LCBsaHNbMl0ueCksIHk6IE1hdGgubWluKGxoc1swXS55LCBsaHNbMV0ueSwgbGhzWzFdLnkpIH07XHJcbiAgICAgICAgICAgIGNvbnN0IGJvdHRvbVJpZ2h0ID0geyB4OiBNYXRoLm1heChsaHNbMF0ueCwgbGhzWzFdLngsIGxoc1syXS54KSwgeTogTWF0aC5tYXgobGhzWzBdLnksIGxoc1sxXS55LCBsaHNbMl0ueSkgfTtcclxuICAgICAgICAgICAgcmV0dXJuIHJlY3RhbmdsZV9tb2RlbF8xLlJlY3RhbmdsZS5mcm9tVG9wTGVmdEJvdHRvbVJpZ2h0KHRvcExlZnQsIGJvdHRvbVJpZ2h0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoY2lyY2xlX21vZGVsXzEuQ2lyY2xlLmlzKGxocykpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHJlY3RhbmdsZV9tb2RlbF8xLlJlY3RhbmdsZShsaHMueCAtIGxocy5yYWRpdXMsIGxocy55IC0gbGhzLnJhZGl1cywgbGhzLnJhZGl1cyAqIDIsIGxocy5yYWRpdXMgKiAyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAocmVjdGFuZ2xlX21vZGVsXzEuUmVjdGFuZ2xlLmlzKGxocykpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGxocztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAocG9pbnRfbW9kZWxfMS5Qb2ludDIuaXMobGhzKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gcmVjdGFuZ2xlX21vZGVsXzEuUmVjdGFuZ2xlKGxocy54LCBsaHMueSwgMCwgMCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gcmVjdGFuZ2xlX21vZGVsXzEuUmVjdGFuZ2xlKDAsIDAsIDAsIDApO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBsaW5lVG8obGhzLCByaHMpIHtcclxuICAgICAgICBpZiAobGluZV9tb2RlbF8xLkxpbmUyLmlzKGxocykpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGxpbmVfbW9kZWxfMS5MaW5lMi5saW5lVG8obGhzLCByaHMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0cmlhbmdsZV9tb2RlbF8xLlRyaWFuZ2xlMi5pcyhsaHMpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cmlhbmdsZV9tb2RlbF8xLlRyaWFuZ2xlMi5saW5lVG8obGhzLCByaHMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChjaXJjbGVfbW9kZWxfMS5DaXJjbGUuaXMobGhzKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gY2lyY2xlX21vZGVsXzEuQ2lyY2xlLmxpbmVUbyhsaHMsIHJocyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHJlY3RhbmdsZV9tb2RlbF8xLlJlY3RhbmdsZS5pcyhsaHMpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiByZWN0YW5nbGVfbW9kZWxfMS5SZWN0YW5nbGUubGluZVRvKGxocywgcmhzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAocG9pbnRfbW9kZWxfMS5Qb2ludDIuaXMobGhzKSkge1xyXG4gICAgICAgICAgICBjb25zdCBmbGlwID0gKFthLCBiXSkgPT4gW2IsIGFdO1xyXG4gICAgICAgICAgICBpZiAobGluZV9tb2RlbF8xLkxpbmUyLmlzKHJocykpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmbGlwKGV4cG9ydHMuU2hhcGUyLmxpbmVUbyhyaHMsIGxocykpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHRyaWFuZ2xlX21vZGVsXzEuVHJpYW5nbGUyLmlzKHJocykpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmbGlwKHRyaWFuZ2xlX21vZGVsXzEuVHJpYW5nbGUyLmxpbmVUbyhyaHMsIGxocykpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGNpcmNsZV9tb2RlbF8xLkNpcmNsZS5pcyhyaHMpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmxpcChjaXJjbGVfbW9kZWxfMS5DaXJjbGUubGluZVRvKHJocywgbGhzKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAocmVjdGFuZ2xlX21vZGVsXzEuUmVjdGFuZ2xlLmlzKHJocykpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmbGlwKHJlY3RhbmdsZV9tb2RlbF8xLlJlY3RhbmdsZS5saW5lVG8ocmhzLCBsaHMpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChwb2ludF9tb2RlbF8xLlBvaW50Mi5pcyhyaHMpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gW2xocywgcmhzXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBbcG9pbnRfbW9kZWxfMS5Qb2ludDIoMCwgMCksIHBvaW50X21vZGVsXzEuUG9pbnQyKDAsIDApXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIFtwb2ludF9tb2RlbF8xLlBvaW50MigwLCAwKSwgcG9pbnRfbW9kZWxfMS5Qb2ludDIoMCwgMCldO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL0Btb3JsZXlkZXYvcGF1cGVyL21vZGVscy9zaGFwZXMubW9kZWwuanMiLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5mdW5jdGlvbiBpcyhwb3NzaWJsZSkge1xyXG4gICAgcmV0dXJuIHBvc3NpYmxlLnRleHQgIT0gbnVsbCAmJiBwb3NzaWJsZS54ICE9IG51bGwgJiYgcG9zc2libGUueSAhPSBudWxsO1xyXG59XHJcbmV4cG9ydHMuaXMgPSBpcztcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL0Btb3JsZXlkZXYvcGF1cGVyL21vZGVscy90ZXh0L3RleHQubW9kZWwuaXMuanMiLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCBpcyA9IHJlcXVpcmUoXCIuL3RleHQubW9kZWwuaXNcIik7XHJcbmV4cG9ydHMuVGV4dDIgPSBPYmplY3QuYXNzaWduKCh0ZXh0LCB4LCB5LCBmb250U2l6ZSwgZm9udEZhbWlseSkgPT4gKHsgdGV4dCwgeCwgeSwgZm9udFNpemUsIGZvbnRGYW1pbHkgfSksIE9iamVjdC5hc3NpZ24oe30sIGlzKSk7XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9AbW9ybGV5ZGV2L3BhdXBlci9tb2RlbHMvdGV4dC90ZXh0Lm1vZGVsLmpzIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuZnVuY3Rpb24gaXMocG9zc2libGUpIHtcclxuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHBvc3NpYmxlKSAmJiBwb3NzaWJsZS5sZW5ndGggPT09IDM7XHJcbn1cclxuZXhwb3J0cy5pcyA9IGlzO1xyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvQG1vcmxleWRldi9wYXVwZXIvbW9kZWxzL3RyaWFuZ2xlL3RyaWFuZ2xlLm1vZGVsLmlzLmpzIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3QgaXMgPSByZXF1aXJlKFwiLi90cmlhbmdsZS5tb2RlbC5pc1wiKTtcclxuY29uc3QgbGluZXMgPSByZXF1aXJlKFwiLi90cmlhbmdsZS5tb2RlbC5saW5lc1wiKTtcclxuY29uc3Qgb3ZlcmxhcHMgPSByZXF1aXJlKFwiLi90cmlhbmdsZS5tb2RlbC5vdmVybGFwXCIpO1xyXG5jb25zdCBsaW5lVG8gPSByZXF1aXJlKFwiLi90cmlhbmdsZS5tb2RlbC5saW5lVG9cIik7XHJcbmV4cG9ydHMuVHJpYW5nbGUyID0gT2JqZWN0LmFzc2lnbigoYSwgYiwgYykgPT4gW2EsIGIsIGNdLCBPYmplY3QuYXNzaWduKHt9LCBpcywgb3ZlcmxhcHMsIGxpbmVzLCBsaW5lVG8pKTtcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL0Btb3JsZXlkZXYvcGF1cGVyL21vZGVscy90cmlhbmdsZS90cmlhbmdsZS5tb2RlbC5qcyIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IGZ1bmN0aW9uYWxfcGlwZV8xID0gcmVxdWlyZShcIkBtb3JsZXlkZXYvZnVuY3Rpb25hbC1waXBlXCIpO1xyXG5jb25zdCBvcGVyYXRvcnNfMSA9IHJlcXVpcmUoXCJAbW9ybGV5ZGV2L2Z1bmN0aW9uYWwtcGlwZS9pdGVyYWJsZS9vcGVyYXRvcnNcIik7XHJcbmNvbnN0IGNpcmNsZV9tb2RlbF9pc18xID0gcmVxdWlyZShcIi4uL2NpcmNsZS9jaXJjbGUubW9kZWwuaXNcIik7XHJcbmNvbnN0IGNpcmNsZV9tb2RlbF9saW5lVG9fMSA9IHJlcXVpcmUoXCIuLi9jaXJjbGUvY2lyY2xlLm1vZGVsLmxpbmVUb1wiKTtcclxuY29uc3QgbGluZV9tb2RlbF9pc18xID0gcmVxdWlyZShcIi4uL2xpbmUvbGluZS5tb2RlbC5pc1wiKTtcclxuY29uc3QgbGluZV9tb2RlbF9saW5lVG9fMSA9IHJlcXVpcmUoXCIuLi9saW5lL2xpbmUubW9kZWwubGluZVRvXCIpO1xyXG5jb25zdCByZWN0YW5nbGVfbW9kZWxfaXNfMSA9IHJlcXVpcmUoXCIuLi9yZWN0YW5nbGUvcmVjdGFuZ2xlLm1vZGVsLmlzXCIpO1xyXG5jb25zdCByZWN0YW5nbGVfbW9kZWxfbGluZVRvXzEgPSByZXF1aXJlKFwiLi4vcmVjdGFuZ2xlL3JlY3RhbmdsZS5tb2RlbC5saW5lVG9cIik7XHJcbmNvbnN0IHRyaWFuZ2xlX21vZGVsX2lzXzEgPSByZXF1aXJlKFwiLi90cmlhbmdsZS5tb2RlbC5pc1wiKTtcclxuY29uc3QgdHJpYW5nbGVfbW9kZWxfbGluZXNfMSA9IHJlcXVpcmUoXCIuL3RyaWFuZ2xlLm1vZGVsLmxpbmVzXCIpO1xyXG5mdW5jdGlvbiBsaW5lVG8obGhzLCByaHMpIHtcclxuICAgIGlmIChsaW5lX21vZGVsX2lzXzEuaXMocmhzKSkge1xyXG4gICAgICAgIHJldHVybiBmbGlwKGxpbmVfbW9kZWxfbGluZVRvXzEubGluZUxpbmUyVG9UcmlhbmdsZTIocmhzLCBsaHMpKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHRyaWFuZ2xlX21vZGVsX2lzXzEuaXMocmhzKSkge1xyXG4gICAgICAgIHJldHVybiBsaW5lVHJpYW5nbGUyVG9UcmlhbmdsZTIobGhzLCByaHMpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoY2lyY2xlX21vZGVsX2lzXzEuaXMocmhzKSkge1xyXG4gICAgICAgIHJldHVybiBmbGlwKGNpcmNsZV9tb2RlbF9saW5lVG9fMS5saW5lQ2lyY2xlVG9UcmlhbmdsZTIocmhzLCBsaHMpKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHJlY3RhbmdsZV9tb2RlbF9pc18xLmlzKHJocykpIHtcclxuICAgICAgICByZXR1cm4gZmxpcChyZWN0YW5nbGVfbW9kZWxfbGluZVRvXzEubGluZVJlY3RhbmdsZVRvVHJpYW5nbGUocmhzLCBsaHMpKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBsaW5lVHJpYW5nbGVUb1BvaW50MihsaHMsIHJocyk7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5saW5lVG8gPSBsaW5lVG87XHJcbmNvbnN0IGZsaXAgPSAoW2EsIGJdKSA9PiBbYiwgYV07XHJcbmZ1bmN0aW9uIGxpbmVUcmlhbmdsZTJUb1RyaWFuZ2xlMihsaHMsIHJocykge1xyXG4gICAgY29uc3QgbGVmdExpbmVzID0gdHJpYW5nbGVfbW9kZWxfbGluZXNfMS5saW5lcyhsaHMpO1xyXG4gICAgY29uc3QgcmlnaHRMaW5lcyA9IHRyaWFuZ2xlX21vZGVsX2xpbmVzXzEubGluZXMocmhzKTtcclxuICAgIHJldHVybiBmdW5jdGlvbmFsX3BpcGVfMS4kJChsZWZ0TGluZXMpXHJcbiAgICAgICAgLiQob3BlcmF0b3JzXzEuZmxhdE1hcCgobGxpbmUpID0+IG9wZXJhdG9yc18xLm1hcCgocmxpbmUpID0+IGxpbmVfbW9kZWxfbGluZVRvXzEubGluZUxpbmUyVG9MaW5lMihsbGluZSwgcmxpbmUpKShyaWdodExpbmVzKSkpXHJcbiAgICAgICAgLiQkKGxpbmVfbW9kZWxfbGluZVRvXzEuZmluZFNob3J0ZXN0TGluZSk7XHJcbn1cclxuZXhwb3J0cy5saW5lVHJpYW5nbGUyVG9UcmlhbmdsZTIgPSBsaW5lVHJpYW5nbGUyVG9UcmlhbmdsZTI7XHJcbmZ1bmN0aW9uIGxpbmVUcmlhbmdsZVRvUG9pbnQyKGxocywgcmhzKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb25hbF9waXBlXzEuJCQobGhzKVxyXG4gICAgICAgIC4kKHRyaWFuZ2xlX21vZGVsX2xpbmVzXzEubGluZXMpXHJcbiAgICAgICAgLiQob3BlcmF0b3JzXzEubWFwKGxpbmUgPT4gbGluZV9tb2RlbF9saW5lVG9fMS5saW5lTGluZTJUb1BvaW50MihsaW5lLCByaHMpKSlcclxuICAgICAgICAuJCQobGluZV9tb2RlbF9saW5lVG9fMS5maW5kU2hvcnRlc3RMaW5lKTtcclxufVxyXG5leHBvcnRzLmxpbmVUcmlhbmdsZVRvUG9pbnQyID0gbGluZVRyaWFuZ2xlVG9Qb2ludDI7XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9AbW9ybGV5ZGV2L3BhdXBlci9tb2RlbHMvdHJpYW5nbGUvdHJpYW5nbGUubW9kZWwubGluZVRvLmpzIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuZnVuY3Rpb24gbGluZXMobGhzKSB7XHJcbiAgICByZXR1cm4gW1xyXG4gICAgICAgIFtsaHNbMF0sIGxoc1sxXV0sXHJcbiAgICAgICAgW2xoc1sxXSwgbGhzWzJdXSxcclxuICAgICAgICBbbGhzWzJdLCBsaHNbMF1dXHJcbiAgICBdO1xyXG59XHJcbmV4cG9ydHMubGluZXMgPSBsaW5lcztcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL0Btb3JsZXlkZXYvcGF1cGVyL21vZGVscy90cmlhbmdsZS90cmlhbmdsZS5tb2RlbC5saW5lcy5qcyIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IGNpcmNsZV9tb2RlbF9pc18xID0gcmVxdWlyZShcIi4uL2NpcmNsZS9jaXJjbGUubW9kZWwuaXNcIik7XHJcbmNvbnN0IGxpbmVfbW9kZWxfaW50ZXJzZWN0XzEgPSByZXF1aXJlKFwiLi4vbGluZS9saW5lLm1vZGVsLmludGVyc2VjdFwiKTtcclxuY29uc3QgbGluZV9tb2RlbF9pc18xID0gcmVxdWlyZShcIi4uL2xpbmUvbGluZS5tb2RlbC5pc1wiKTtcclxuY29uc3QgcmVjdGFuZ2xlX21vZGVsX2lzXzEgPSByZXF1aXJlKFwiLi4vcmVjdGFuZ2xlL3JlY3RhbmdsZS5tb2RlbC5pc1wiKTtcclxuY29uc3QgcmVjdGFuZ2xlX21vZGVsX2xpbmVzXzEgPSByZXF1aXJlKFwiLi4vcmVjdGFuZ2xlL3JlY3RhbmdsZS5tb2RlbC5saW5lc1wiKTtcclxuY29uc3QgdHJpYW5nbGVfbW9kZWxfaXNfMSA9IHJlcXVpcmUoXCIuL3RyaWFuZ2xlLm1vZGVsLmlzXCIpO1xyXG5jb25zdCB0cmlhbmdsZV9tb2RlbF9saW5lc18xID0gcmVxdWlyZShcIi4vdHJpYW5nbGUubW9kZWwubGluZXNcIik7XHJcbmZ1bmN0aW9uIG92ZXJsYXBzKGxocywgcmhzKSB7XHJcbiAgICBpZiAodHJpYW5nbGVfbW9kZWxfaXNfMS5pcyhyaHMpKSB7XHJcbiAgICAgICAgcmV0dXJuIHRyaWFuZ2xlMk92ZXJsYXBzVHJpYW5nbGUyKGxocywgcmhzKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGxpbmVfbW9kZWxfaXNfMS5pcyhyaHMpKSB7XHJcbiAgICAgICAgcmV0dXJuIHRyaWFuZ2xlMk92ZXJsYXBzTGluZTIobGhzLCByaHMpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAocmVjdGFuZ2xlX21vZGVsX2lzXzEuaXMocmhzKSkge1xyXG4gICAgICAgIHJldHVybiB0cmlhbmdsZTJPdmVybGFwc1JlY3RhbmdsZShsaHMsIHJocyk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChjaXJjbGVfbW9kZWxfaXNfMS5pcyhyaHMpKSB7XHJcbiAgICAgICAgcmV0dXJuIHRyaWFuZ2xlMk92ZXJsYXBzQ2lyY2xlKGxocywgcmhzKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiB0cmlhbmdsZTJPdmVybGFwc1BvaW50MihsaHMsIHJocyk7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5vdmVybGFwcyA9IG92ZXJsYXBzO1xyXG5mdW5jdGlvbiB0cmlhbmdsZTJPdmVybGFwc0NpcmNsZShsaHMsIHJocykge1xyXG4gICAgaWYgKHRyaWFuZ2xlMk92ZXJsYXBzUG9pbnQyKGxocywgcmhzKSkge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRyaWFuZ2xlX21vZGVsX2xpbmVzXzEubGluZXMobGhzKS5zb21lKGxpbmUgPT4gbGluZV9tb2RlbF9pbnRlcnNlY3RfMS5saW5lMkludGVyc2VjdHNDaXJjbGUobGluZSwgcmhzKSk7XHJcbn1cclxuZXhwb3J0cy50cmlhbmdsZTJPdmVybGFwc0NpcmNsZSA9IHRyaWFuZ2xlMk92ZXJsYXBzQ2lyY2xlO1xyXG5mdW5jdGlvbiB0cmlhbmdsZTJPdmVybGFwc1JlY3RhbmdsZShsaHMsIHJocykge1xyXG4gICAgY29uc3QgeyBib3R0b20sIHRvcCwgbGVmdCwgcmlnaHQgfSA9IHJlY3RhbmdsZV9tb2RlbF9saW5lc18xLmxpbmVzKHJocyk7XHJcbiAgICBjb25zdCByZWN0TGluZVNldCA9IFtib3R0b20sIHRvcCwgbGVmdCwgcmlnaHRdO1xyXG4gICAgcmV0dXJuIHJlY3RMaW5lU2V0LnNvbWUobGluZSA9PiB0cmlhbmdsZTJPdmVybGFwc0xpbmUyKGxocywgbGluZSkpO1xyXG59XHJcbmV4cG9ydHMudHJpYW5nbGUyT3ZlcmxhcHNSZWN0YW5nbGUgPSB0cmlhbmdsZTJPdmVybGFwc1JlY3RhbmdsZTtcclxuZnVuY3Rpb24gdHJpYW5nbGUyT3ZlcmxhcHNUcmlhbmdsZTIobGhzLCByaHMpIHtcclxuICAgIGlmICh0cmlhbmdsZTJPdmVybGFwc1BvaW50MihsaHMsIHJoc1swXSkgfHwgdHJpYW5nbGUyT3ZlcmxhcHNQb2ludDIobGhzLCByaHNbMV0pIHx8IHRyaWFuZ2xlMk92ZXJsYXBzUG9pbnQyKGxocywgcmhzWzJdKSkge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgY29uc3QgbGhzTGluZXMgPSB0cmlhbmdsZV9tb2RlbF9saW5lc18xLmxpbmVzKGxocyk7XHJcbiAgICByZXR1cm4gdHJpYW5nbGVfbW9kZWxfbGluZXNfMS5saW5lcyhyaHMpLnNvbWUocmhzTGluZSA9PiB0cmlhbmdsZTJPdmVybGFwc0xpbmUyKGxocywgcmhzTGluZSkpO1xyXG59XHJcbmV4cG9ydHMudHJpYW5nbGUyT3ZlcmxhcHNUcmlhbmdsZTIgPSB0cmlhbmdsZTJPdmVybGFwc1RyaWFuZ2xlMjtcclxuZnVuY3Rpb24gdHJpYW5nbGUyT3ZlcmxhcHNMaW5lMihbdjEsIHYyLCB2M10sIFthLCBiXSkge1xyXG4gICAgaWYgKHRyaWFuZ2xlMk92ZXJsYXBzUG9pbnQyKFt2MSwgdjIsIHYzXSwgYSkgfHwgdHJpYW5nbGUyT3ZlcmxhcHNQb2ludDIoW3YxLCB2MiwgdjNdLCBiKSkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIHJldHVybiBsaW5lX21vZGVsX2ludGVyc2VjdF8xLmxpbmUySW50ZXJzZWN0c1RyaWFuZ2xlMihbYSwgYl0sIFt2MSwgdjIsIHYzXSk7XHJcbn1cclxuZXhwb3J0cy50cmlhbmdsZTJPdmVybGFwc0xpbmUyID0gdHJpYW5nbGUyT3ZlcmxhcHNMaW5lMjtcclxuZnVuY3Rpb24gdHJpYW5nbGUyT3ZlcmxhcHNQb2ludDIoW3YxLCB2MiwgdjNdLCByaHMpIHtcclxuICAgIGNvbnN0IHNpZ24gPSAocDEsIHAyLCBwMykgPT4gKHAxLnggLSBwMy54KSAqIChwMi55IC0gcDMueSkgLSAocDIueCAtIHAzLngpICogKHAxLnkgLSBwMy55KTtcclxuICAgIGNvbnN0IGIxID0gc2lnbihyaHMsIHYxLCB2MikgPCAwLjA7XHJcbiAgICBjb25zdCBiMiA9IHNpZ24ocmhzLCB2MiwgdjMpIDwgMC4wO1xyXG4gICAgY29uc3QgYjMgPSBzaWduKHJocywgdjMsIHYxKSA8IDAuMDtcclxuICAgIHJldHVybiAoKGIxID09PSBiMikgJiYgKGIyID09PSBiMykpO1xyXG59XHJcbmV4cG9ydHMudHJpYW5nbGUyT3ZlcmxhcHNQb2ludDIgPSB0cmlhbmdsZTJPdmVybGFwc1BvaW50MjtcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL0Btb3JsZXlkZXYvcGF1cGVyL21vZGVscy90cmlhbmdsZS90cmlhbmdsZS5tb2RlbC5vdmVybGFwLmpzIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3QgcmVuZGVyX2ZyYW1lX21vZGVsXzEgPSByZXF1aXJlKFwiLi4vcmVuZGVyLWZyYW1lLm1vZGVsXCIpO1xyXG5jb25zdCBjb2xvdXJfbW9kZWxfMSA9IHJlcXVpcmUoXCIuLi8uLi9tb2RlbHMvY29sb3VyLm1vZGVsXCIpO1xyXG5jb25zdCByZWFjdF90ZXN0X3JlbmRlcmVyXzEgPSByZXF1aXJlKFwicmVhY3QtdGVzdC1yZW5kZXJlclwiKTtcclxuY2xhc3MgUmVhY3RSZW5kZXJlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50KSB7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJlciA9IHJlYWN0X3Rlc3RfcmVuZGVyZXJfMS5jcmVhdGUoZWxlbWVudCk7XHJcbiAgICB9XHJcbiAgICBmcmFtZSgpIHtcclxuICAgICAgICBjb25zdCBqc29uID0gdGhpcy5yZW5kZXJlci50b0pTT04oKTtcclxuICAgICAgICByZXR1cm4ganNvbiAhPSBudWxsID8ganNvblRvRnJhbWUoanNvbikgOiBbXTtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLlJlYWN0UmVuZGVyZXIgPSBSZWFjdFJlbmRlcmVyO1xyXG5mdW5jdGlvbiBqc29uVG9GcmFtZShqc29uKSB7XHJcbiAgICBzd2l0Y2ggKGpzb24udHlwZSkge1xyXG4gICAgICAgIGNhc2UgXCJjbGVhclwiOlxyXG4gICAgICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICAgICAgcmVuZGVyX2ZyYW1lX21vZGVsXzEuQ2xlYXIoanNvbi5wcm9wc1tcImNvbG91clwiXSB8fCBjb2xvdXJfbW9kZWxfMS5SR0IoMCwgMCwgMCkpLFxyXG4gICAgICAgICAgICAgICAgKGpzb24uY2hpbGRyZW4gfHwgW10pLm1hcChqc29uVG9GcmFtZSlcclxuICAgICAgICAgICAgXTtcclxuICAgICAgICBjYXNlIFwib3JpZ2luXCI6XHJcbiAgICAgICAgICAgIHJldHVybiByZW5kZXJfZnJhbWVfbW9kZWxfMS5PcmlnaW4oanNvbi5wcm9wc1tcImNvb3Jkc1wiXSwgKGpzb24uY2hpbGRyZW4gfHwgW10pLm1hcChqc29uVG9GcmFtZSkpO1xyXG4gICAgICAgIGNhc2UgXCJyb3RhdGVcIjpcclxuICAgICAgICAgICAgcmV0dXJuIHJlbmRlcl9mcmFtZV9tb2RlbF8xLlJvdGF0ZShqc29uLnByb3BzW1wicmFkaWFuc1wiXSwgKGpzb24uY2hpbGRyZW4gfHwgW10pLm1hcChqc29uVG9GcmFtZSkpO1xyXG4gICAgICAgIGNhc2UgXCJzY2FsZVwiOlxyXG4gICAgICAgICAgICByZXR1cm4gcmVuZGVyX2ZyYW1lX21vZGVsXzEuU2NhbGUoanNvbi5wcm9wc1tcImJ5XCJdLCAoanNvbi5jaGlsZHJlbiB8fCBbXSkubWFwKGpzb25Ub0ZyYW1lKSk7XHJcbiAgICAgICAgY2FzZSBcImZpbGxcIjpcclxuICAgICAgICAgICAgcmV0dXJuIHJlbmRlcl9mcmFtZV9tb2RlbF8xLkZpbGwoanNvbi5wcm9wc1tcInNoYXBlXCJdLCBqc29uLnByb3BzW1wiY29sb3VyXCJdKTtcclxuICAgICAgICBjYXNlIFwic3Ryb2tlXCI6XHJcbiAgICAgICAgICAgIHJldHVybiByZW5kZXJfZnJhbWVfbW9kZWxfMS5TdHJva2UoanNvbi5wcm9wc1tcInNoYXBlXCJdLCBqc29uLnByb3BzW1wiY29sb3VyXCJdKTtcclxuICAgICAgICBjYXNlIFwiYmxpdFwiOlxyXG4gICAgICAgICAgICByZXR1cm4gcmVuZGVyX2ZyYW1lX21vZGVsXzEuQmxpdChqc29uLnByb3BzW1wiaW1hZ2VcIl0sIGpzb24ucHJvcHNbXCJkc3RcIl0sIGpzb24ucHJvcHNbXCJzcmNcIl0pO1xyXG4gICAgICAgIGNhc2UgXCJyZW5kZXJUYXJnZXRcIjpcclxuICAgICAgICAgICAgcmV0dXJuIHJlbmRlcl9mcmFtZV9tb2RlbF8xLlJlbmRlclRhcmdldChqc29uLnByb3BzW1wiZHN0XCJdLCAoanNvbi5jaGlsZHJlbiB8fCBbXSkubWFwKGpzb25Ub0ZyYW1lKSwganNvbi5wcm9wc1tcInNpemVcIl0pO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIHJldHVybiAoanNvbi5jaGlsZHJlbiB8fCBbXSkubWFwKGpzb25Ub0ZyYW1lKTtcclxuICAgIH1cclxufVxyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvQG1vcmxleWRldi9wYXVwZXIvcmVuZGVyL2pzeC9yZW5kZXIuanMiLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5leHBvcnRzLkZyYW1lID0gKC4uLl9jb21tYW5kcykgPT4gX2NvbW1hbmRzO1xyXG52YXIgRnJhbWVDb21tYW5kVHlwZTtcclxuKGZ1bmN0aW9uIChGcmFtZUNvbW1hbmRUeXBlKSB7XHJcbiAgICBGcmFtZUNvbW1hbmRUeXBlW0ZyYW1lQ29tbWFuZFR5cGVbXCJDbGVhclwiXSA9IDBdID0gXCJDbGVhclwiO1xyXG4gICAgRnJhbWVDb21tYW5kVHlwZVtGcmFtZUNvbW1hbmRUeXBlW1wiT3JpZ2luXCJdID0gMV0gPSBcIk9yaWdpblwiO1xyXG4gICAgRnJhbWVDb21tYW5kVHlwZVtGcmFtZUNvbW1hbmRUeXBlW1wiUm90YXRlXCJdID0gMl0gPSBcIlJvdGF0ZVwiO1xyXG4gICAgRnJhbWVDb21tYW5kVHlwZVtGcmFtZUNvbW1hbmRUeXBlW1wiU2NhbGVcIl0gPSAzXSA9IFwiU2NhbGVcIjtcclxuICAgIEZyYW1lQ29tbWFuZFR5cGVbRnJhbWVDb21tYW5kVHlwZVtcIkZpbGxcIl0gPSA0XSA9IFwiRmlsbFwiO1xyXG4gICAgRnJhbWVDb21tYW5kVHlwZVtGcmFtZUNvbW1hbmRUeXBlW1wiU3Ryb2tlXCJdID0gNV0gPSBcIlN0cm9rZVwiO1xyXG4gICAgRnJhbWVDb21tYW5kVHlwZVtGcmFtZUNvbW1hbmRUeXBlW1wiQmxpdFwiXSA9IDZdID0gXCJCbGl0XCI7XHJcbiAgICBGcmFtZUNvbW1hbmRUeXBlW0ZyYW1lQ29tbWFuZFR5cGVbXCJSZW5kZXJUYXJnZXRcIl0gPSA3XSA9IFwiUmVuZGVyVGFyZ2V0XCI7XHJcbn0pKEZyYW1lQ29tbWFuZFR5cGUgPSBleHBvcnRzLkZyYW1lQ29tbWFuZFR5cGUgfHwgKGV4cG9ydHMuRnJhbWVDb21tYW5kVHlwZSA9IHt9KSk7XHJcbmV4cG9ydHMuQ2xlYXIgPSAoY29sb3VyKSA9PiBjb2xvdXIgIT0gbnVsbCA/IFtGcmFtZUNvbW1hbmRUeXBlLkNsZWFyLCBjb2xvdXJdIDogW0ZyYW1lQ29tbWFuZFR5cGUuQ2xlYXJdO1xyXG5leHBvcnRzLk9yaWdpbiA9IChvcmlnaW4sIGNoaWxkKSA9PiBbRnJhbWVDb21tYW5kVHlwZS5PcmlnaW4sIG9yaWdpbiwgY2hpbGRdO1xyXG5leHBvcnRzLlJvdGF0ZSA9IChyYWRpYW4sIGNoaWxkKSA9PiBbRnJhbWVDb21tYW5kVHlwZS5Sb3RhdGUsIHJhZGlhbiwgY2hpbGRdO1xyXG5leHBvcnRzLlNjYWxlID0gKHNjYWxlLCBjaGlsZCkgPT4gW0ZyYW1lQ29tbWFuZFR5cGUuU2NhbGUsIHNjYWxlLCBjaGlsZF07XHJcbmV4cG9ydHMuRmlsbCA9IChkc3QsIGNvbG91cikgPT4gW0ZyYW1lQ29tbWFuZFR5cGUuRmlsbCwgZHN0LCBjb2xvdXJdO1xyXG5leHBvcnRzLlN0cm9rZSA9IChkc3QsIGNvbG91cikgPT4gW0ZyYW1lQ29tbWFuZFR5cGUuU3Ryb2tlLCBkc3QsIGNvbG91cl07XHJcbmV4cG9ydHMuQmxpdCA9IChpbWFnZSwgZHN0LCBzcmMpID0+IHNyYyAhPSBudWxsID8gW0ZyYW1lQ29tbWFuZFR5cGUuQmxpdCwgaW1hZ2UsIGRzdCwgc3JjXSA6IFtGcmFtZUNvbW1hbmRUeXBlLkJsaXQsIGltYWdlLCBkc3RdO1xyXG5leHBvcnRzLlJlbmRlclRhcmdldCA9IChkc3QsIGZyYW1lLCBzaXplKSA9PiBbRnJhbWVDb21tYW5kVHlwZS5SZW5kZXJUYXJnZXQsIGRzdCwgZnJhbWUsIHNpemVdO1xyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvQG1vcmxleWRldi9wYXVwZXIvcmVuZGVyL3JlbmRlci1mcmFtZS5tb2RlbC5qcyIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IHNoYXBlc19tb2RlbF8xID0gcmVxdWlyZShcIi4uL21vZGVscy9zaGFwZXMubW9kZWxcIik7XHJcbmNvbnN0IHJlbmRlcl9mcmFtZV9tb2RlbF8xID0gcmVxdWlyZShcIi4vcmVuZGVyLWZyYW1lLm1vZGVsXCIpO1xyXG5mdW5jdGlvbiByZW5kZXJUb0NhbnZhcyh0YXJnZXQsIGZyYW1lKSB7XHJcbiAgICByZXR1cm4gZnJhbWUuZm9yRWFjaCgoY29tbWFuZCkgPT4gUmVuZGVyQ29tbWFuZCh0YXJnZXQsIGNvbW1hbmQpKTtcclxufVxyXG5leHBvcnRzLnJlbmRlclRvQ2FudmFzID0gcmVuZGVyVG9DYW52YXM7XHJcbmZ1bmN0aW9uIFJlbmRlckNvbW1hbmQodGFyZ2V0LCBjb21tYW5kKSB7XHJcbiAgICBjb25zdCBjb21tYW5kVHlwZSA9IGNvbW1hbmRbMF07XHJcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoY29tbWFuZFR5cGUpKSB7XHJcbiAgICAgICAgc3dpdGNoIChjb21tYW5kVHlwZSkge1xyXG4gICAgICAgICAgICBjYXNlIHJlbmRlcl9mcmFtZV9tb2RlbF8xLkZyYW1lQ29tbWFuZFR5cGUuQ2xlYXI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVuZGVyQ2xlYXIodGFyZ2V0LCBjb21tYW5kKTtcclxuICAgICAgICAgICAgY2FzZSByZW5kZXJfZnJhbWVfbW9kZWxfMS5GcmFtZUNvbW1hbmRUeXBlLk9yaWdpbjpcclxuICAgICAgICAgICAgICAgIHJldHVybiByZW5kZXJPcmlnaW4odGFyZ2V0LCBjb21tYW5kKTtcclxuICAgICAgICAgICAgY2FzZSByZW5kZXJfZnJhbWVfbW9kZWxfMS5GcmFtZUNvbW1hbmRUeXBlLlJlbmRlclRhcmdldDpcclxuICAgICAgICAgICAgICAgIHJldHVybiByZW5kZXJSZW5kZXJUYXJnZXQodGFyZ2V0LCBjb21tYW5kKTtcclxuICAgICAgICAgICAgY2FzZSByZW5kZXJfZnJhbWVfbW9kZWxfMS5GcmFtZUNvbW1hbmRUeXBlLlJvdGF0ZTpcclxuICAgICAgICAgICAgICAgIHJldHVybiByZW5kZXJSb3RhdGUodGFyZ2V0LCBjb21tYW5kKTtcclxuICAgICAgICAgICAgY2FzZSByZW5kZXJfZnJhbWVfbW9kZWxfMS5GcmFtZUNvbW1hbmRUeXBlLlNjYWxlOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlbmRlclNjYWxlKHRhcmdldCwgY29tbWFuZCk7XHJcbiAgICAgICAgICAgIGNhc2UgcmVuZGVyX2ZyYW1lX21vZGVsXzEuRnJhbWVDb21tYW5kVHlwZS5GaWxsOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlbmRlckZpbGwodGFyZ2V0LCBjb21tYW5kKTtcclxuICAgICAgICAgICAgY2FzZSByZW5kZXJfZnJhbWVfbW9kZWxfMS5GcmFtZUNvbW1hbmRUeXBlLlN0cm9rZTpcclxuICAgICAgICAgICAgICAgIHJldHVybiByZW5kZXJTdHJva2UodGFyZ2V0LCBjb21tYW5kKTtcclxuICAgICAgICAgICAgY2FzZSByZW5kZXJfZnJhbWVfbW9kZWxfMS5GcmFtZUNvbW1hbmRUeXBlLkJsaXQ6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVuZGVyQmxpdCh0YXJnZXQsIGNvbW1hbmQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBjb21tYW5kLmZvckVhY2goYyA9PiBSZW5kZXJDb21tYW5kKHRhcmdldCwgYykpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHJlbmRlck9yaWdpbih7IGNhbnZhcywgY29udGV4dCwgYXNzZXRzIH0sIGNvbW1hbmQpIHtcclxuICAgIGNvbnN0IG9yaWdpbiA9IGNvbW1hbmRbMV07XHJcbiAgICBjb250ZXh0LnRyYW5zbGF0ZShvcmlnaW4ueCB8IDAsIG9yaWdpbi55IHwgMCk7XHJcbiAgICByZW5kZXJUb0NhbnZhcyh7IGNhbnZhcywgY29udGV4dCwgYXNzZXRzIH0sIGNvbW1hbmRbMl0pO1xyXG4gICAgY29udGV4dC50cmFuc2xhdGUoLW9yaWdpbi54IHwgMCwgLW9yaWdpbi55IHwgMCk7XHJcbn1cclxuZnVuY3Rpb24gcmVuZGVyUm90YXRlKHsgY2FudmFzLCBjb250ZXh0LCBhc3NldHMgfSwgY29tbWFuZCkge1xyXG4gICAgY29uc3Qgcm90YXRpb24gPSBjb21tYW5kWzFdO1xyXG4gICAgY29udGV4dC5yb3RhdGUocm90YXRpb24pO1xyXG4gICAgcmVuZGVyVG9DYW52YXMoeyBjYW52YXMsIGNvbnRleHQsIGFzc2V0cyB9LCBjb21tYW5kWzJdKTtcclxuICAgIGNvbnRleHQucm90YXRlKC1yb3RhdGlvbik7XHJcbn1cclxuZnVuY3Rpb24gcmVuZGVyU2NhbGUoeyBjYW52YXMsIGNvbnRleHQsIGFzc2V0cyB9LCBjb21tYW5kKSB7XHJcbiAgICBjb25zdCBzY2FsZSA9IGNvbW1hbmRbMV07XHJcbiAgICBjb250ZXh0LnNjYWxlKHNjYWxlLngsIHNjYWxlLnkpO1xyXG4gICAgcmVuZGVyVG9DYW52YXMoeyBjYW52YXMsIGNvbnRleHQsIGFzc2V0cyB9LCBjb21tYW5kWzJdKTtcclxuICAgIGNvbnRleHQuc2NhbGUoMSAvIHNjYWxlLngsIDEgLyBzY2FsZS55KTtcclxufVxyXG5mdW5jdGlvbiByZW5kZXJCbGl0KHsgY2FudmFzLCBjb250ZXh0LCBhc3NldHMgfSwgY29tbWFuZCkge1xyXG4gICAgY29uc3QgaW1hZ2UgPSBjb21tYW5kWzFdO1xyXG4gICAgY29uc3QgZHN0ID0gY29tbWFuZFsyXTtcclxuICAgIGNvbnN0IHNyYyA9IGNvbW1hbmRbM107XHJcbiAgICBjb25zdCBpbWdBc3NldCA9IGFzc2V0cy5nZXRJbWFnZShpbWFnZSk7XHJcbiAgICBpZiAoc2hhcGVzX21vZGVsXzEuUmVjdGFuZ2xlLmlzKGRzdCkpIHtcclxuICAgICAgICBpZiAoc3JjICE9IG51bGwpIHtcclxuICAgICAgICAgICAgY29udGV4dC5kcmF3SW1hZ2UoaW1nQXNzZXQsIHNyYy54IHwgMCwgc3JjLnkgfCAwLCBzcmMud2lkdGggfCAwLCBzcmMuaGVpZ2h0IHwgMCwgZHN0LnggfCAwLCBkc3QueSB8IDAsIGRzdC53aWR0aCB8IDAsIGRzdC5oZWlnaHQgfCAwKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnRleHQuZHJhd0ltYWdlKGltZ0Fzc2V0LCBkc3QueCB8IDAsIGRzdC55IHwgMCwgZHN0LndpZHRoIHwgMCwgZHN0LmhlaWdodCB8IDApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGNvbnRleHQuZHJhd0ltYWdlKGltZ0Fzc2V0LCBkc3QueCB8IDAsIGRzdC55IHwgMCk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gcmVuZGVyRmlsbCh7IGNhbnZhcywgY29udGV4dCwgYXNzZXRzIH0sIGZpbGwpIHtcclxuICAgIGNvbnN0IHNoYXBlID0gZmlsbFsxXTtcclxuICAgIGNvbnN0IGNvbG91ciA9IGZpbGxbMl07XHJcbiAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xyXG4gICAgY29udGV4dC5maWxsU3R5bGUgPSBnZXRSR0JBKGNvbG91cik7XHJcbiAgICBpZiAoQXJyYXkuaXNBcnJheShzaGFwZSkpIHtcclxuICAgICAgICBjb250ZXh0Lm1vdmVUbyhzaGFwZVswXS54IHwgMCwgc2hhcGVbMF0ueSB8IDApO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgc2hhcGUubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgY29udGV4dC5saW5lVG8oc2hhcGVbaV0ueCB8IDAsIHNoYXBlW2ldLnkgfCAwKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29udGV4dC5maWxsKCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChzaGFwZXNfbW9kZWxfMS5UZXh0Mi5pcyhzaGFwZSkpIHtcclxuICAgICAgICBjb25zdCBzaXplID0gc2hhcGUuZm9udFNpemUgfHwgMTA7XHJcbiAgICAgICAgY29udGV4dC5mb250ID0gYCR7c2l6ZX1weCAke3NoYXBlLmZvbnRGYW1pbHkgfHwgXCJzZXJpZlwifWA7XHJcbiAgICAgICAgY29udGV4dC5maWxsVGV4dChzaGFwZS50ZXh0LCBzaGFwZS54IHwgMCwgKHNoYXBlLnkgKyAoc2l6ZSkpIHwgMCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChzaGFwZXNfbW9kZWxfMS5SZWN0YW5nbGUuaXMoc2hhcGUpKSB7XHJcbiAgICAgICAgY29udGV4dC5maWxsUmVjdChzaGFwZS54IHwgMCwgc2hhcGUueSB8IDAsIHNoYXBlLndpZHRoIHwgMCwgc2hhcGUuaGVpZ2h0IHwgMCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChzaGFwZXNfbW9kZWxfMS5DaXJjbGUuaXMoc2hhcGUpKSB7XHJcbiAgICAgICAgY29udGV4dC5hcmMoc2hhcGUueCB8IDAsIHNoYXBlLnkgfCAwLCBzaGFwZS5yYWRpdXMgfCAwLCAwLCAyICogTWF0aC5QSSk7XHJcbiAgICAgICAgY29udGV4dC5maWxsKCk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gcmVuZGVyU3Ryb2tlKHsgY2FudmFzLCBjb250ZXh0LCBhc3NldHMgfSwgZmlsbCkge1xyXG4gICAgY29uc3Qgc2hhcGUgPSBmaWxsWzFdO1xyXG4gICAgY29uc3QgY29sb3VyID0gZmlsbFsyXTtcclxuICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XHJcbiAgICBjb250ZXh0LnN0cm9rZVN0eWxlID0gZ2V0UkdCQShjb2xvdXIpO1xyXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoc2hhcGUpKSB7XHJcbiAgICAgICAgY29udGV4dC5tb3ZlVG8oc2hhcGVbMF0ueCB8IDAsIHNoYXBlWzBdLnkgfCAwKTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHNoYXBlLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKHNoYXBlW2ldLnggfCAwLCBzaGFwZVtpXS55IHwgMCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnRleHQuc3Ryb2tlKCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChzaGFwZXNfbW9kZWxfMS5UZXh0Mi5pcyhzaGFwZSkpIHtcclxuICAgICAgICBjb25zdCBzaXplID0gc2hhcGUuZm9udFNpemUgfHwgMTA7XHJcbiAgICAgICAgY29udGV4dC5mb250ID0gYCR7c2l6ZX1weCAke3NoYXBlLmZvbnRGYW1pbHkgfHwgXCJzZXJpZlwifWA7XHJcbiAgICAgICAgY29udGV4dC5zdHJva2VUZXh0KHNoYXBlLnRleHQsIHNoYXBlLnggfCAwLCAoc2hhcGUueSArIChzaXplIC8gMikpIHwgMCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChzaGFwZXNfbW9kZWxfMS5SZWN0YW5nbGUuaXMoc2hhcGUpKSB7XHJcbiAgICAgICAgY29udGV4dC5zdHJva2VSZWN0KHNoYXBlLnggfCAwLCBzaGFwZS55IHwgMCwgc2hhcGUud2lkdGggfCAwLCBzaGFwZS5oZWlnaHQgfCAwKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHNoYXBlc19tb2RlbF8xLkNpcmNsZS5pcyhzaGFwZSkpIHtcclxuICAgICAgICBjb250ZXh0LmFyYyhzaGFwZS54IHwgMCwgc2hhcGUueSB8IDAsIHNoYXBlLnJhZGl1cyB8IDAsIDAsIDIgKiBNYXRoLlBJKTtcclxuICAgICAgICBjb250ZXh0LnN0cm9rZSgpO1xyXG4gICAgfVxyXG4gICAgY29udGV4dC5jbG9zZVBhdGgoKTtcclxufVxyXG5mdW5jdGlvbiByZW5kZXJDbGVhcih7IGNhbnZhcywgY29udGV4dCwgYXNzZXRzIH0sIGNsZWFyKSB7XHJcbiAgICBjb250ZXh0LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcclxuICAgIGNvbnRleHQuY2xlYXJSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCB8IDAsIGNhbnZhcy5oZWlnaHQgfCAwKTtcclxuICAgIGNvbnN0IGNvbG91ciA9IGNsZWFyWzFdO1xyXG4gICAgY29udGV4dC5maWxsU3R5bGUgPSBjb2xvdXIgPyBnZXRSR0IoY29sb3VyKSA6IFwiYmxhY2tcIjtcclxuICAgIGNvbnRleHQuZmlsbFJlY3QoMCwgMCwgY2FudmFzLndpZHRoIHwgMCwgY2FudmFzLmhlaWdodCB8IDApO1xyXG59XHJcbi8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpyZWFkb25seS1rZXl3b3JkXHJcbmNvbnN0IGNhbnZhc0NhY2hlID0ge307XHJcbmZ1bmN0aW9uIHJlbmRlclJlbmRlclRhcmdldCh7IGNhbnZhcywgY29udGV4dCwgYXNzZXRzIH0sIFtfLCBkc3QsIGZyYW1lcywgc2l6ZV0pIHtcclxuICAgIGNvbnN0IHdpZHRoID0gKHNpemUgPT0gbnVsbCA/IGRzdC53aWR0aCA6IHNpemUueCkgfCAwO1xyXG4gICAgY29uc3QgaGVpZ2h0ID0gKHNpemUgPT0gbnVsbCA/IGRzdC5oZWlnaHQgOiBzaXplLnkpIHwgMDtcclxuICAgIGNvbnN0IGtleSA9IGAke3dpZHRofSR7aGVpZ2h0fWA7XHJcbiAgICBsZXQgdGFyZ2V0Q2FudmFzID0gY2FudmFzQ2FjaGVba2V5XTtcclxuICAgIGNhbnZhc0NhY2hlW2tleV0gPSBudWxsO1xyXG4gICAgaWYgKHRhcmdldENhbnZhcyA9PSBudWxsKSB7XHJcbiAgICAgICAgY29uc3QgbmV3Q2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcclxuICAgICAgICBuZXdDYW52YXMud2lkdGggPSAoc2l6ZSA9PSBudWxsID8gZHN0LndpZHRoIDogc2l6ZS54KSB8IDA7XHJcbiAgICAgICAgbmV3Q2FudmFzLmhlaWdodCA9IChzaXplID09IG51bGwgPyBkc3QuaGVpZ2h0IDogc2l6ZS55KSB8IDA7XHJcbiAgICAgICAgdGFyZ2V0Q2FudmFzID0geyBjYW52YXM6IG5ld0NhbnZhcywgY29udGV4dDogbmV3Q2FudmFzLmdldENvbnRleHQoXCIyZFwiKSwgYXNzZXRzIH07XHJcbiAgICB9XHJcbiAgICByZW5kZXJUb0NhbnZhcyh0YXJnZXRDYW52YXMsIGZyYW1lcyk7XHJcbiAgICBjb250ZXh0LmRyYXdJbWFnZSh0YXJnZXRDYW52YXMuY2FudmFzLCBkc3QueCB8IDAsIGRzdC55IHwgMCwgZHN0LndpZHRoIHwgMCwgZHN0LmhlaWdodCB8IDApO1xyXG4gICAgY2FudmFzQ2FjaGVba2V5XSA9IHRhcmdldENhbnZhcztcclxufVxyXG5mdW5jdGlvbiBnZXRSR0JBKGNvbG91cikge1xyXG4gICAgcmV0dXJuIGNvbG91ci5hICE9IG51bGwgPyBgcmdiYSgke2NvbG91ci5yIHwgMH0sICR7Y29sb3VyLmcgfCAwfSwgJHtjb2xvdXIuYiB8IDB9LCAke2NvbG91ci5hfSlgIDogZ2V0UkdCKGNvbG91cik7XHJcbn1cclxuZnVuY3Rpb24gZ2V0UkdCKGNvbG91cikge1xyXG4gICAgcmV0dXJuIGByZ2IoJHtjb2xvdXIuciB8IDB9LCAke2NvbG91ci5nIHwgMH0sICR7Y29sb3VyLmIgfCAwfSlgO1xyXG59XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9AbW9ybGV5ZGV2L3BhdXBlci9yZW5kZXIvcmVuZGVyLXRvLWNhbnZhcy5mdW5jLmpzIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuZXhwb3J0cy5pc0Jyb3dzZXIgPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiO1xyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvQG1vcmxleWRldi9wYXVwZXIvdXRpbGl0eS9pcy1icm93c2VyLmpzIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuZXhwb3J0cy5pc1Byb2R1Y3Rpb24gPSBwcm9jZXNzICYmIHByb2Nlc3MuZW52ICYmIHByb2Nlc3MuZW52W1wiTk9ERV9FTlZcIl0gPT09IFwiUHJvZHVjdGlvblwiO1xyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvQG1vcmxleWRldi9wYXVwZXIvdXRpbGl0eS9pcy1wcm9kdWN0aW9uLmpzIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKHR5cGVvZiBpdCAhPSAnZnVuY3Rpb24nKSB0aHJvdyBUeXBlRXJyb3IoaXQgKyAnIGlzIG5vdCBhIGZ1bmN0aW9uIScpO1xuICByZXR1cm4gaXQ7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYS1mdW5jdGlvbi5qcyIsInZhciBjb2YgPSByZXF1aXJlKCcuL19jb2YnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0LCBtc2cpIHtcbiAgaWYgKHR5cGVvZiBpdCAhPSAnbnVtYmVyJyAmJiBjb2YoaXQpICE9ICdOdW1iZXInKSB0aHJvdyBUeXBlRXJyb3IobXNnKTtcbiAgcmV0dXJuICtpdDtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hLW51bWJlci12YWx1ZS5qcyIsIi8vIDIyLjEuMy4zMSBBcnJheS5wcm90b3R5cGVbQEB1bnNjb3BhYmxlc11cbnZhciBVTlNDT1BBQkxFUyA9IHJlcXVpcmUoJy4vX3drcycpKCd1bnNjb3BhYmxlcycpO1xudmFyIEFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGU7XG5pZiAoQXJyYXlQcm90b1tVTlNDT1BBQkxFU10gPT0gdW5kZWZpbmVkKSByZXF1aXJlKCcuL19oaWRlJykoQXJyYXlQcm90bywgVU5TQ09QQUJMRVMsIHt9KTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSkge1xuICBBcnJheVByb3RvW1VOU0NPUEFCTEVTXVtrZXldID0gdHJ1ZTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hZGQtdG8tdW5zY29wYWJsZXMuanMiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCwgQ29uc3RydWN0b3IsIG5hbWUsIGZvcmJpZGRlbkZpZWxkKSB7XG4gIGlmICghKGl0IGluc3RhbmNlb2YgQ29uc3RydWN0b3IpIHx8IChmb3JiaWRkZW5GaWVsZCAhPT0gdW5kZWZpbmVkICYmIGZvcmJpZGRlbkZpZWxkIGluIGl0KSkge1xuICAgIHRocm93IFR5cGVFcnJvcihuYW1lICsgJzogaW5jb3JyZWN0IGludm9jYXRpb24hJyk7XG4gIH0gcmV0dXJuIGl0O1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2FuLWluc3RhbmNlLmpzIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoIWlzT2JqZWN0KGl0KSkgdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgYW4gb2JqZWN0IScpO1xuICByZXR1cm4gaXQ7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYW4tb2JqZWN0LmpzIiwiLy8gMjIuMS4zLjMgQXJyYXkucHJvdG90eXBlLmNvcHlXaXRoaW4odGFyZ2V0LCBzdGFydCwgZW5kID0gdGhpcy5sZW5ndGgpXG4ndXNlIHN0cmljdCc7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcbnZhciB0b0Fic29sdXRlSW5kZXggPSByZXF1aXJlKCcuL190by1hYnNvbHV0ZS1pbmRleCcpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gW10uY29weVdpdGhpbiB8fCBmdW5jdGlvbiBjb3B5V2l0aGluKHRhcmdldCAvKiA9IDAgKi8sIHN0YXJ0IC8qID0gMCwgZW5kID0gQGxlbmd0aCAqLykge1xuICB2YXIgTyA9IHRvT2JqZWN0KHRoaXMpO1xuICB2YXIgbGVuID0gdG9MZW5ndGgoTy5sZW5ndGgpO1xuICB2YXIgdG8gPSB0b0Fic29sdXRlSW5kZXgodGFyZ2V0LCBsZW4pO1xuICB2YXIgZnJvbSA9IHRvQWJzb2x1dGVJbmRleChzdGFydCwgbGVuKTtcbiAgdmFyIGVuZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkO1xuICB2YXIgY291bnQgPSBNYXRoLm1pbigoZW5kID09PSB1bmRlZmluZWQgPyBsZW4gOiB0b0Fic29sdXRlSW5kZXgoZW5kLCBsZW4pKSAtIGZyb20sIGxlbiAtIHRvKTtcbiAgdmFyIGluYyA9IDE7XG4gIGlmIChmcm9tIDwgdG8gJiYgdG8gPCBmcm9tICsgY291bnQpIHtcbiAgICBpbmMgPSAtMTtcbiAgICBmcm9tICs9IGNvdW50IC0gMTtcbiAgICB0byArPSBjb3VudCAtIDE7XG4gIH1cbiAgd2hpbGUgKGNvdW50LS0gPiAwKSB7XG4gICAgaWYgKGZyb20gaW4gTykgT1t0b10gPSBPW2Zyb21dO1xuICAgIGVsc2UgZGVsZXRlIE9bdG9dO1xuICAgIHRvICs9IGluYztcbiAgICBmcm9tICs9IGluYztcbiAgfSByZXR1cm4gTztcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hcnJheS1jb3B5LXdpdGhpbi5qcyIsIi8vIDIyLjEuMy42IEFycmF5LnByb3RvdHlwZS5maWxsKHZhbHVlLCBzdGFydCA9IDAsIGVuZCA9IHRoaXMubGVuZ3RoKVxuJ3VzZSBzdHJpY3QnO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG52YXIgdG9BYnNvbHV0ZUluZGV4ID0gcmVxdWlyZSgnLi9fdG8tYWJzb2x1dGUtaW5kZXgnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBmaWxsKHZhbHVlIC8qICwgc3RhcnQgPSAwLCBlbmQgPSBAbGVuZ3RoICovKSB7XG4gIHZhciBPID0gdG9PYmplY3QodGhpcyk7XG4gIHZhciBsZW5ndGggPSB0b0xlbmd0aChPLmxlbmd0aCk7XG4gIHZhciBhTGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgdmFyIGluZGV4ID0gdG9BYnNvbHV0ZUluZGV4KGFMZW4gPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkLCBsZW5ndGgpO1xuICB2YXIgZW5kID0gYUxlbiA+IDIgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQ7XG4gIHZhciBlbmRQb3MgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbmd0aCA6IHRvQWJzb2x1dGVJbmRleChlbmQsIGxlbmd0aCk7XG4gIHdoaWxlIChlbmRQb3MgPiBpbmRleCkgT1tpbmRleCsrXSA9IHZhbHVlO1xuICByZXR1cm4gTztcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hcnJheS1maWxsLmpzIiwidmFyIGZvck9mID0gcmVxdWlyZSgnLi9fZm9yLW9mJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0ZXIsIElURVJBVE9SKSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgZm9yT2YoaXRlciwgZmFsc2UsIHJlc3VsdC5wdXNoLCByZXN1bHQsIElURVJBVE9SKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hcnJheS1mcm9tLWl0ZXJhYmxlLmpzIiwiLy8gZmFsc2UgLT4gQXJyYXkjaW5kZXhPZlxuLy8gdHJ1ZSAgLT4gQXJyYXkjaW5jbHVkZXNcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcbnZhciB0b0Fic29sdXRlSW5kZXggPSByZXF1aXJlKCcuL190by1hYnNvbHV0ZS1pbmRleCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoSVNfSU5DTFVERVMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgkdGhpcywgZWwsIGZyb21JbmRleCkge1xuICAgIHZhciBPID0gdG9JT2JqZWN0KCR0aGlzKTtcbiAgICB2YXIgbGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpO1xuICAgIHZhciBpbmRleCA9IHRvQWJzb2x1dGVJbmRleChmcm9tSW5kZXgsIGxlbmd0aCk7XG4gICAgdmFyIHZhbHVlO1xuICAgIC8vIEFycmF5I2luY2x1ZGVzIHVzZXMgU2FtZVZhbHVlWmVybyBlcXVhbGl0eSBhbGdvcml0aG1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gICAgaWYgKElTX0lOQ0xVREVTICYmIGVsICE9IGVsKSB3aGlsZSAobGVuZ3RoID4gaW5kZXgpIHtcbiAgICAgIHZhbHVlID0gT1tpbmRleCsrXTtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgICAgIGlmICh2YWx1ZSAhPSB2YWx1ZSkgcmV0dXJuIHRydWU7XG4gICAgLy8gQXJyYXkjaW5kZXhPZiBpZ25vcmVzIGhvbGVzLCBBcnJheSNpbmNsdWRlcyAtIG5vdFxuICAgIH0gZWxzZSBmb3IgKDtsZW5ndGggPiBpbmRleDsgaW5kZXgrKykgaWYgKElTX0lOQ0xVREVTIHx8IGluZGV4IGluIE8pIHtcbiAgICAgIGlmIChPW2luZGV4XSA9PT0gZWwpIHJldHVybiBJU19JTkNMVURFUyB8fCBpbmRleCB8fCAwO1xuICAgIH0gcmV0dXJuICFJU19JTkNMVURFUyAmJiAtMTtcbiAgfTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hcnJheS1pbmNsdWRlcy5qcyIsIi8vIDAgLT4gQXJyYXkjZm9yRWFjaFxuLy8gMSAtPiBBcnJheSNtYXBcbi8vIDIgLT4gQXJyYXkjZmlsdGVyXG4vLyAzIC0+IEFycmF5I3NvbWVcbi8vIDQgLT4gQXJyYXkjZXZlcnlcbi8vIDUgLT4gQXJyYXkjZmluZFxuLy8gNiAtPiBBcnJheSNmaW5kSW5kZXhcbnZhciBjdHggPSByZXF1aXJlKCcuL19jdHgnKTtcbnZhciBJT2JqZWN0ID0gcmVxdWlyZSgnLi9faW9iamVjdCcpO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcbnZhciBhc2MgPSByZXF1aXJlKCcuL19hcnJheS1zcGVjaWVzLWNyZWF0ZScpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoVFlQRSwgJGNyZWF0ZSkge1xuICB2YXIgSVNfTUFQID0gVFlQRSA9PSAxO1xuICB2YXIgSVNfRklMVEVSID0gVFlQRSA9PSAyO1xuICB2YXIgSVNfU09NRSA9IFRZUEUgPT0gMztcbiAgdmFyIElTX0VWRVJZID0gVFlQRSA9PSA0O1xuICB2YXIgSVNfRklORF9JTkRFWCA9IFRZUEUgPT0gNjtcbiAgdmFyIE5PX0hPTEVTID0gVFlQRSA9PSA1IHx8IElTX0ZJTkRfSU5ERVg7XG4gIHZhciBjcmVhdGUgPSAkY3JlYXRlIHx8IGFzYztcbiAgcmV0dXJuIGZ1bmN0aW9uICgkdGhpcywgY2FsbGJhY2tmbiwgdGhhdCkge1xuICAgIHZhciBPID0gdG9PYmplY3QoJHRoaXMpO1xuICAgIHZhciBzZWxmID0gSU9iamVjdChPKTtcbiAgICB2YXIgZiA9IGN0eChjYWxsYmFja2ZuLCB0aGF0LCAzKTtcbiAgICB2YXIgbGVuZ3RoID0gdG9MZW5ndGgoc2VsZi5sZW5ndGgpO1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgdmFyIHJlc3VsdCA9IElTX01BUCA/IGNyZWF0ZSgkdGhpcywgbGVuZ3RoKSA6IElTX0ZJTFRFUiA/IGNyZWF0ZSgkdGhpcywgMCkgOiB1bmRlZmluZWQ7XG4gICAgdmFyIHZhbCwgcmVzO1xuICAgIGZvciAoO2xlbmd0aCA+IGluZGV4OyBpbmRleCsrKSBpZiAoTk9fSE9MRVMgfHwgaW5kZXggaW4gc2VsZikge1xuICAgICAgdmFsID0gc2VsZltpbmRleF07XG4gICAgICByZXMgPSBmKHZhbCwgaW5kZXgsIE8pO1xuICAgICAgaWYgKFRZUEUpIHtcbiAgICAgICAgaWYgKElTX01BUCkgcmVzdWx0W2luZGV4XSA9IHJlczsgICAvLyBtYXBcbiAgICAgICAgZWxzZSBpZiAocmVzKSBzd2l0Y2ggKFRZUEUpIHtcbiAgICAgICAgICBjYXNlIDM6IHJldHVybiB0cnVlOyAgICAgICAgICAgICAvLyBzb21lXG4gICAgICAgICAgY2FzZSA1OiByZXR1cm4gdmFsOyAgICAgICAgICAgICAgLy8gZmluZFxuICAgICAgICAgIGNhc2UgNjogcmV0dXJuIGluZGV4OyAgICAgICAgICAgIC8vIGZpbmRJbmRleFxuICAgICAgICAgIGNhc2UgMjogcmVzdWx0LnB1c2godmFsKTsgICAgICAgIC8vIGZpbHRlclxuICAgICAgICB9IGVsc2UgaWYgKElTX0VWRVJZKSByZXR1cm4gZmFsc2U7IC8vIGV2ZXJ5XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBJU19GSU5EX0lOREVYID8gLTEgOiBJU19TT01FIHx8IElTX0VWRVJZID8gSVNfRVZFUlkgOiByZXN1bHQ7XG4gIH07XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYXJyYXktbWV0aG9kcy5qcyIsInZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcbnZhciBJT2JqZWN0ID0gcmVxdWlyZSgnLi9faW9iamVjdCcpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHRoYXQsIGNhbGxiYWNrZm4sIGFMZW4sIG1lbW8sIGlzUmlnaHQpIHtcbiAgYUZ1bmN0aW9uKGNhbGxiYWNrZm4pO1xuICB2YXIgTyA9IHRvT2JqZWN0KHRoYXQpO1xuICB2YXIgc2VsZiA9IElPYmplY3QoTyk7XG4gIHZhciBsZW5ndGggPSB0b0xlbmd0aChPLmxlbmd0aCk7XG4gIHZhciBpbmRleCA9IGlzUmlnaHQgPyBsZW5ndGggLSAxIDogMDtcbiAgdmFyIGkgPSBpc1JpZ2h0ID8gLTEgOiAxO1xuICBpZiAoYUxlbiA8IDIpIGZvciAoOzspIHtcbiAgICBpZiAoaW5kZXggaW4gc2VsZikge1xuICAgICAgbWVtbyA9IHNlbGZbaW5kZXhdO1xuICAgICAgaW5kZXggKz0gaTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpbmRleCArPSBpO1xuICAgIGlmIChpc1JpZ2h0ID8gaW5kZXggPCAwIDogbGVuZ3RoIDw9IGluZGV4KSB7XG4gICAgICB0aHJvdyBUeXBlRXJyb3IoJ1JlZHVjZSBvZiBlbXB0eSBhcnJheSB3aXRoIG5vIGluaXRpYWwgdmFsdWUnKTtcbiAgICB9XG4gIH1cbiAgZm9yICg7aXNSaWdodCA/IGluZGV4ID49IDAgOiBsZW5ndGggPiBpbmRleDsgaW5kZXggKz0gaSkgaWYgKGluZGV4IGluIHNlbGYpIHtcbiAgICBtZW1vID0gY2FsbGJhY2tmbihtZW1vLCBzZWxmW2luZGV4XSwgaW5kZXgsIE8pO1xuICB9XG4gIHJldHVybiBtZW1vO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2FycmF5LXJlZHVjZS5qcyIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIGlzQXJyYXkgPSByZXF1aXJlKCcuL19pcy1hcnJheScpO1xudmFyIFNQRUNJRVMgPSByZXF1aXJlKCcuL193a3MnKSgnc3BlY2llcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvcmlnaW5hbCkge1xuICB2YXIgQztcbiAgaWYgKGlzQXJyYXkob3JpZ2luYWwpKSB7XG4gICAgQyA9IG9yaWdpbmFsLmNvbnN0cnVjdG9yO1xuICAgIC8vIGNyb3NzLXJlYWxtIGZhbGxiYWNrXG4gICAgaWYgKHR5cGVvZiBDID09ICdmdW5jdGlvbicgJiYgKEMgPT09IEFycmF5IHx8IGlzQXJyYXkoQy5wcm90b3R5cGUpKSkgQyA9IHVuZGVmaW5lZDtcbiAgICBpZiAoaXNPYmplY3QoQykpIHtcbiAgICAgIEMgPSBDW1NQRUNJRVNdO1xuICAgICAgaWYgKEMgPT09IG51bGwpIEMgPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9IHJldHVybiBDID09PSB1bmRlZmluZWQgPyBBcnJheSA6IEM7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYXJyYXktc3BlY2llcy1jb25zdHJ1Y3Rvci5qcyIsIi8vIDkuNC4yLjMgQXJyYXlTcGVjaWVzQ3JlYXRlKG9yaWdpbmFsQXJyYXksIGxlbmd0aClcbnZhciBzcGVjaWVzQ29uc3RydWN0b3IgPSByZXF1aXJlKCcuL19hcnJheS1zcGVjaWVzLWNvbnN0cnVjdG9yJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9yaWdpbmFsLCBsZW5ndGgpIHtcbiAgcmV0dXJuIG5ldyAoc3BlY2llc0NvbnN0cnVjdG9yKG9yaWdpbmFsKSkobGVuZ3RoKTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hcnJheS1zcGVjaWVzLWNyZWF0ZS5qcyIsIid1c2Ugc3RyaWN0JztcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBpbnZva2UgPSByZXF1aXJlKCcuL19pbnZva2UnKTtcbnZhciBhcnJheVNsaWNlID0gW10uc2xpY2U7XG52YXIgZmFjdG9yaWVzID0ge307XG5cbnZhciBjb25zdHJ1Y3QgPSBmdW5jdGlvbiAoRiwgbGVuLCBhcmdzKSB7XG4gIGlmICghKGxlbiBpbiBmYWN0b3JpZXMpKSB7XG4gICAgZm9yICh2YXIgbiA9IFtdLCBpID0gMDsgaSA8IGxlbjsgaSsrKSBuW2ldID0gJ2FbJyArIGkgKyAnXSc7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5ldy1mdW5jXG4gICAgZmFjdG9yaWVzW2xlbl0gPSBGdW5jdGlvbignRixhJywgJ3JldHVybiBuZXcgRignICsgbi5qb2luKCcsJykgKyAnKScpO1xuICB9IHJldHVybiBmYWN0b3JpZXNbbGVuXShGLCBhcmdzKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRnVuY3Rpb24uYmluZCB8fCBmdW5jdGlvbiBiaW5kKHRoYXQgLyogLCAuLi5hcmdzICovKSB7XG4gIHZhciBmbiA9IGFGdW5jdGlvbih0aGlzKTtcbiAgdmFyIHBhcnRBcmdzID0gYXJyYXlTbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gIHZhciBib3VuZCA9IGZ1bmN0aW9uICgvKiBhcmdzLi4uICovKSB7XG4gICAgdmFyIGFyZ3MgPSBwYXJ0QXJncy5jb25jYXQoYXJyYXlTbGljZS5jYWxsKGFyZ3VtZW50cykpO1xuICAgIHJldHVybiB0aGlzIGluc3RhbmNlb2YgYm91bmQgPyBjb25zdHJ1Y3QoZm4sIGFyZ3MubGVuZ3RoLCBhcmdzKSA6IGludm9rZShmbiwgYXJncywgdGhhdCk7XG4gIH07XG4gIGlmIChpc09iamVjdChmbi5wcm90b3R5cGUpKSBib3VuZC5wcm90b3R5cGUgPSBmbi5wcm90b3R5cGU7XG4gIHJldHVybiBib3VuZDtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19iaW5kLmpzIiwiLy8gZ2V0dGluZyB0YWcgZnJvbSAxOS4xLjMuNiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nKClcbnZhciBjb2YgPSByZXF1aXJlKCcuL19jb2YnKTtcbnZhciBUQUcgPSByZXF1aXJlKCcuL193a3MnKSgndG9TdHJpbmdUYWcnKTtcbi8vIEVTMyB3cm9uZyBoZXJlXG52YXIgQVJHID0gY29mKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKSA9PSAnQXJndW1lbnRzJztcblxuLy8gZmFsbGJhY2sgZm9yIElFMTEgU2NyaXB0IEFjY2VzcyBEZW5pZWQgZXJyb3JcbnZhciB0cnlHZXQgPSBmdW5jdGlvbiAoaXQsIGtleSkge1xuICB0cnkge1xuICAgIHJldHVybiBpdFtrZXldO1xuICB9IGNhdGNoIChlKSB7IC8qIGVtcHR5ICovIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHZhciBPLCBULCBCO1xuICByZXR1cm4gaXQgPT09IHVuZGVmaW5lZCA/ICdVbmRlZmluZWQnIDogaXQgPT09IG51bGwgPyAnTnVsbCdcbiAgICAvLyBAQHRvU3RyaW5nVGFnIGNhc2VcbiAgICA6IHR5cGVvZiAoVCA9IHRyeUdldChPID0gT2JqZWN0KGl0KSwgVEFHKSkgPT0gJ3N0cmluZycgPyBUXG4gICAgLy8gYnVpbHRpblRhZyBjYXNlXG4gICAgOiBBUkcgPyBjb2YoTylcbiAgICAvLyBFUzMgYXJndW1lbnRzIGZhbGxiYWNrXG4gICAgOiAoQiA9IGNvZihPKSkgPT0gJ09iamVjdCcgJiYgdHlwZW9mIE8uY2FsbGVlID09ICdmdW5jdGlvbicgPyAnQXJndW1lbnRzJyA6IEI7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fY2xhc3NvZi5qcyIsInZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChpdCkuc2xpY2UoOCwgLTEpO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2NvZi5qcyIsIid1c2Ugc3RyaWN0JztcbnZhciBkUCA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmY7XG52YXIgY3JlYXRlID0gcmVxdWlyZSgnLi9fb2JqZWN0LWNyZWF0ZScpO1xudmFyIHJlZGVmaW5lQWxsID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUtYWxsJyk7XG52YXIgY3R4ID0gcmVxdWlyZSgnLi9fY3R4Jyk7XG52YXIgYW5JbnN0YW5jZSA9IHJlcXVpcmUoJy4vX2FuLWluc3RhbmNlJyk7XG52YXIgZm9yT2YgPSByZXF1aXJlKCcuL19mb3Itb2YnKTtcbnZhciAkaXRlckRlZmluZSA9IHJlcXVpcmUoJy4vX2l0ZXItZGVmaW5lJyk7XG52YXIgc3RlcCA9IHJlcXVpcmUoJy4vX2l0ZXItc3RlcCcpO1xudmFyIHNldFNwZWNpZXMgPSByZXF1aXJlKCcuL19zZXQtc3BlY2llcycpO1xudmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKTtcbnZhciBmYXN0S2V5ID0gcmVxdWlyZSgnLi9fbWV0YScpLmZhc3RLZXk7XG52YXIgdmFsaWRhdGUgPSByZXF1aXJlKCcuL192YWxpZGF0ZS1jb2xsZWN0aW9uJyk7XG52YXIgU0laRSA9IERFU0NSSVBUT1JTID8gJ19zJyA6ICdzaXplJztcblxudmFyIGdldEVudHJ5ID0gZnVuY3Rpb24gKHRoYXQsIGtleSkge1xuICAvLyBmYXN0IGNhc2VcbiAgdmFyIGluZGV4ID0gZmFzdEtleShrZXkpO1xuICB2YXIgZW50cnk7XG4gIGlmIChpbmRleCAhPT0gJ0YnKSByZXR1cm4gdGhhdC5faVtpbmRleF07XG4gIC8vIGZyb3plbiBvYmplY3QgY2FzZVxuICBmb3IgKGVudHJ5ID0gdGhhdC5fZjsgZW50cnk7IGVudHJ5ID0gZW50cnkubikge1xuICAgIGlmIChlbnRyeS5rID09IGtleSkgcmV0dXJuIGVudHJ5O1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZ2V0Q29uc3RydWN0b3I6IGZ1bmN0aW9uICh3cmFwcGVyLCBOQU1FLCBJU19NQVAsIEFEREVSKSB7XG4gICAgdmFyIEMgPSB3cmFwcGVyKGZ1bmN0aW9uICh0aGF0LCBpdGVyYWJsZSkge1xuICAgICAgYW5JbnN0YW5jZSh0aGF0LCBDLCBOQU1FLCAnX2knKTtcbiAgICAgIHRoYXQuX3QgPSBOQU1FOyAgICAgICAgIC8vIGNvbGxlY3Rpb24gdHlwZVxuICAgICAgdGhhdC5faSA9IGNyZWF0ZShudWxsKTsgLy8gaW5kZXhcbiAgICAgIHRoYXQuX2YgPSB1bmRlZmluZWQ7ICAgIC8vIGZpcnN0IGVudHJ5XG4gICAgICB0aGF0Ll9sID0gdW5kZWZpbmVkOyAgICAvLyBsYXN0IGVudHJ5XG4gICAgICB0aGF0W1NJWkVdID0gMDsgICAgICAgICAvLyBzaXplXG4gICAgICBpZiAoaXRlcmFibGUgIT0gdW5kZWZpbmVkKSBmb3JPZihpdGVyYWJsZSwgSVNfTUFQLCB0aGF0W0FEREVSXSwgdGhhdCk7XG4gICAgfSk7XG4gICAgcmVkZWZpbmVBbGwoQy5wcm90b3R5cGUsIHtcbiAgICAgIC8vIDIzLjEuMy4xIE1hcC5wcm90b3R5cGUuY2xlYXIoKVxuICAgICAgLy8gMjMuMi4zLjIgU2V0LnByb3RvdHlwZS5jbGVhcigpXG4gICAgICBjbGVhcjogZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgICAgIGZvciAodmFyIHRoYXQgPSB2YWxpZGF0ZSh0aGlzLCBOQU1FKSwgZGF0YSA9IHRoYXQuX2ksIGVudHJ5ID0gdGhhdC5fZjsgZW50cnk7IGVudHJ5ID0gZW50cnkubikge1xuICAgICAgICAgIGVudHJ5LnIgPSB0cnVlO1xuICAgICAgICAgIGlmIChlbnRyeS5wKSBlbnRyeS5wID0gZW50cnkucC5uID0gdW5kZWZpbmVkO1xuICAgICAgICAgIGRlbGV0ZSBkYXRhW2VudHJ5LmldO1xuICAgICAgICB9XG4gICAgICAgIHRoYXQuX2YgPSB0aGF0Ll9sID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGF0W1NJWkVdID0gMDtcbiAgICAgIH0sXG4gICAgICAvLyAyMy4xLjMuMyBNYXAucHJvdG90eXBlLmRlbGV0ZShrZXkpXG4gICAgICAvLyAyMy4yLjMuNCBTZXQucHJvdG90eXBlLmRlbGV0ZSh2YWx1ZSlcbiAgICAgICdkZWxldGUnOiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHZhciB0aGF0ID0gdmFsaWRhdGUodGhpcywgTkFNRSk7XG4gICAgICAgIHZhciBlbnRyeSA9IGdldEVudHJ5KHRoYXQsIGtleSk7XG4gICAgICAgIGlmIChlbnRyeSkge1xuICAgICAgICAgIHZhciBuZXh0ID0gZW50cnkubjtcbiAgICAgICAgICB2YXIgcHJldiA9IGVudHJ5LnA7XG4gICAgICAgICAgZGVsZXRlIHRoYXQuX2lbZW50cnkuaV07XG4gICAgICAgICAgZW50cnkuciA9IHRydWU7XG4gICAgICAgICAgaWYgKHByZXYpIHByZXYubiA9IG5leHQ7XG4gICAgICAgICAgaWYgKG5leHQpIG5leHQucCA9IHByZXY7XG4gICAgICAgICAgaWYgKHRoYXQuX2YgPT0gZW50cnkpIHRoYXQuX2YgPSBuZXh0O1xuICAgICAgICAgIGlmICh0aGF0Ll9sID09IGVudHJ5KSB0aGF0Ll9sID0gcHJldjtcbiAgICAgICAgICB0aGF0W1NJWkVdLS07XG4gICAgICAgIH0gcmV0dXJuICEhZW50cnk7XG4gICAgICB9LFxuICAgICAgLy8gMjMuMi4zLjYgU2V0LnByb3RvdHlwZS5mb3JFYWNoKGNhbGxiYWNrZm4sIHRoaXNBcmcgPSB1bmRlZmluZWQpXG4gICAgICAvLyAyMy4xLjMuNSBNYXAucHJvdG90eXBlLmZvckVhY2goY2FsbGJhY2tmbiwgdGhpc0FyZyA9IHVuZGVmaW5lZClcbiAgICAgIGZvckVhY2g6IGZ1bmN0aW9uIGZvckVhY2goY2FsbGJhY2tmbiAvKiAsIHRoYXQgPSB1bmRlZmluZWQgKi8pIHtcbiAgICAgICAgdmFsaWRhdGUodGhpcywgTkFNRSk7XG4gICAgICAgIHZhciBmID0gY3R4KGNhbGxiYWNrZm4sIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkLCAzKTtcbiAgICAgICAgdmFyIGVudHJ5O1xuICAgICAgICB3aGlsZSAoZW50cnkgPSBlbnRyeSA/IGVudHJ5Lm4gOiB0aGlzLl9mKSB7XG4gICAgICAgICAgZihlbnRyeS52LCBlbnRyeS5rLCB0aGlzKTtcbiAgICAgICAgICAvLyByZXZlcnQgdG8gdGhlIGxhc3QgZXhpc3RpbmcgZW50cnlcbiAgICAgICAgICB3aGlsZSAoZW50cnkgJiYgZW50cnkucikgZW50cnkgPSBlbnRyeS5wO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgLy8gMjMuMS4zLjcgTWFwLnByb3RvdHlwZS5oYXMoa2V5KVxuICAgICAgLy8gMjMuMi4zLjcgU2V0LnByb3RvdHlwZS5oYXModmFsdWUpXG4gICAgICBoYXM6IGZ1bmN0aW9uIGhhcyhrZXkpIHtcbiAgICAgICAgcmV0dXJuICEhZ2V0RW50cnkodmFsaWRhdGUodGhpcywgTkFNRSksIGtleSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKERFU0NSSVBUT1JTKSBkUChDLnByb3RvdHlwZSwgJ3NpemUnLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHZhbGlkYXRlKHRoaXMsIE5BTUUpW1NJWkVdO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBDO1xuICB9LFxuICBkZWY6IGZ1bmN0aW9uICh0aGF0LCBrZXksIHZhbHVlKSB7XG4gICAgdmFyIGVudHJ5ID0gZ2V0RW50cnkodGhhdCwga2V5KTtcbiAgICB2YXIgcHJldiwgaW5kZXg7XG4gICAgLy8gY2hhbmdlIGV4aXN0aW5nIGVudHJ5XG4gICAgaWYgKGVudHJ5KSB7XG4gICAgICBlbnRyeS52ID0gdmFsdWU7XG4gICAgLy8gY3JlYXRlIG5ldyBlbnRyeVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGF0Ll9sID0gZW50cnkgPSB7XG4gICAgICAgIGk6IGluZGV4ID0gZmFzdEtleShrZXksIHRydWUpLCAvLyA8LSBpbmRleFxuICAgICAgICBrOiBrZXksICAgICAgICAgICAgICAgICAgICAgICAgLy8gPC0ga2V5XG4gICAgICAgIHY6IHZhbHVlLCAgICAgICAgICAgICAgICAgICAgICAvLyA8LSB2YWx1ZVxuICAgICAgICBwOiBwcmV2ID0gdGhhdC5fbCwgICAgICAgICAgICAgLy8gPC0gcHJldmlvdXMgZW50cnlcbiAgICAgICAgbjogdW5kZWZpbmVkLCAgICAgICAgICAgICAgICAgIC8vIDwtIG5leHQgZW50cnlcbiAgICAgICAgcjogZmFsc2UgICAgICAgICAgICAgICAgICAgICAgIC8vIDwtIHJlbW92ZWRcbiAgICAgIH07XG4gICAgICBpZiAoIXRoYXQuX2YpIHRoYXQuX2YgPSBlbnRyeTtcbiAgICAgIGlmIChwcmV2KSBwcmV2Lm4gPSBlbnRyeTtcbiAgICAgIHRoYXRbU0laRV0rKztcbiAgICAgIC8vIGFkZCB0byBpbmRleFxuICAgICAgaWYgKGluZGV4ICE9PSAnRicpIHRoYXQuX2lbaW5kZXhdID0gZW50cnk7XG4gICAgfSByZXR1cm4gdGhhdDtcbiAgfSxcbiAgZ2V0RW50cnk6IGdldEVudHJ5LFxuICBzZXRTdHJvbmc6IGZ1bmN0aW9uIChDLCBOQU1FLCBJU19NQVApIHtcbiAgICAvLyBhZGQgLmtleXMsIC52YWx1ZXMsIC5lbnRyaWVzLCBbQEBpdGVyYXRvcl1cbiAgICAvLyAyMy4xLjMuNCwgMjMuMS4zLjgsIDIzLjEuMy4xMSwgMjMuMS4zLjEyLCAyMy4yLjMuNSwgMjMuMi4zLjgsIDIzLjIuMy4xMCwgMjMuMi4zLjExXG4gICAgJGl0ZXJEZWZpbmUoQywgTkFNRSwgZnVuY3Rpb24gKGl0ZXJhdGVkLCBraW5kKSB7XG4gICAgICB0aGlzLl90ID0gdmFsaWRhdGUoaXRlcmF0ZWQsIE5BTUUpOyAvLyB0YXJnZXRcbiAgICAgIHRoaXMuX2sgPSBraW5kOyAgICAgICAgICAgICAgICAgICAgIC8vIGtpbmRcbiAgICAgIHRoaXMuX2wgPSB1bmRlZmluZWQ7ICAgICAgICAgICAgICAgIC8vIHByZXZpb3VzXG4gICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgdmFyIGtpbmQgPSB0aGF0Ll9rO1xuICAgICAgdmFyIGVudHJ5ID0gdGhhdC5fbDtcbiAgICAgIC8vIHJldmVydCB0byB0aGUgbGFzdCBleGlzdGluZyBlbnRyeVxuICAgICAgd2hpbGUgKGVudHJ5ICYmIGVudHJ5LnIpIGVudHJ5ID0gZW50cnkucDtcbiAgICAgIC8vIGdldCBuZXh0IGVudHJ5XG4gICAgICBpZiAoIXRoYXQuX3QgfHwgISh0aGF0Ll9sID0gZW50cnkgPSBlbnRyeSA/IGVudHJ5Lm4gOiB0aGF0Ll90Ll9mKSkge1xuICAgICAgICAvLyBvciBmaW5pc2ggdGhlIGl0ZXJhdGlvblxuICAgICAgICB0aGF0Ll90ID0gdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gc3RlcCgxKTtcbiAgICAgIH1cbiAgICAgIC8vIHJldHVybiBzdGVwIGJ5IGtpbmRcbiAgICAgIGlmIChraW5kID09ICdrZXlzJykgcmV0dXJuIHN0ZXAoMCwgZW50cnkuayk7XG4gICAgICBpZiAoa2luZCA9PSAndmFsdWVzJykgcmV0dXJuIHN0ZXAoMCwgZW50cnkudik7XG4gICAgICByZXR1cm4gc3RlcCgwLCBbZW50cnkuaywgZW50cnkudl0pO1xuICAgIH0sIElTX01BUCA/ICdlbnRyaWVzJyA6ICd2YWx1ZXMnLCAhSVNfTUFQLCB0cnVlKTtcblxuICAgIC8vIGFkZCBbQEBzcGVjaWVzXSwgMjMuMS4yLjIsIDIzLjIuMi4yXG4gICAgc2V0U3BlY2llcyhOQU1FKTtcbiAgfVxufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2NvbGxlY3Rpb24tc3Ryb25nLmpzIiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL0RhdmlkQnJ1YW50L01hcC1TZXQucHJvdG90eXBlLnRvSlNPTlxudmFyIGNsYXNzb2YgPSByZXF1aXJlKCcuL19jbGFzc29mJyk7XG52YXIgZnJvbSA9IHJlcXVpcmUoJy4vX2FycmF5LWZyb20taXRlcmFibGUnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKE5BTUUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICBpZiAoY2xhc3NvZih0aGlzKSAhPSBOQU1FKSB0aHJvdyBUeXBlRXJyb3IoTkFNRSArIFwiI3RvSlNPTiBpc24ndCBnZW5lcmljXCIpO1xuICAgIHJldHVybiBmcm9tKHRoaXMpO1xuICB9O1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2NvbGxlY3Rpb24tdG8tanNvbi5qcyIsIid1c2Ugc3RyaWN0JztcbnZhciByZWRlZmluZUFsbCA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lLWFsbCcpO1xudmFyIGdldFdlYWsgPSByZXF1aXJlKCcuL19tZXRhJykuZ2V0V2VhaztcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgYW5JbnN0YW5jZSA9IHJlcXVpcmUoJy4vX2FuLWluc3RhbmNlJyk7XG52YXIgZm9yT2YgPSByZXF1aXJlKCcuL19mb3Itb2YnKTtcbnZhciBjcmVhdGVBcnJheU1ldGhvZCA9IHJlcXVpcmUoJy4vX2FycmF5LW1ldGhvZHMnKTtcbnZhciAkaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgdmFsaWRhdGUgPSByZXF1aXJlKCcuL192YWxpZGF0ZS1jb2xsZWN0aW9uJyk7XG52YXIgYXJyYXlGaW5kID0gY3JlYXRlQXJyYXlNZXRob2QoNSk7XG52YXIgYXJyYXlGaW5kSW5kZXggPSBjcmVhdGVBcnJheU1ldGhvZCg2KTtcbnZhciBpZCA9IDA7XG5cbi8vIGZhbGxiYWNrIGZvciB1bmNhdWdodCBmcm96ZW4ga2V5c1xudmFyIHVuY2F1Z2h0RnJvemVuU3RvcmUgPSBmdW5jdGlvbiAodGhhdCkge1xuICByZXR1cm4gdGhhdC5fbCB8fCAodGhhdC5fbCA9IG5ldyBVbmNhdWdodEZyb3plblN0b3JlKCkpO1xufTtcbnZhciBVbmNhdWdodEZyb3plblN0b3JlID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmEgPSBbXTtcbn07XG52YXIgZmluZFVuY2F1Z2h0RnJvemVuID0gZnVuY3Rpb24gKHN0b3JlLCBrZXkpIHtcbiAgcmV0dXJuIGFycmF5RmluZChzdG9yZS5hLCBmdW5jdGlvbiAoaXQpIHtcbiAgICByZXR1cm4gaXRbMF0gPT09IGtleTtcbiAgfSk7XG59O1xuVW5jYXVnaHRGcm96ZW5TdG9yZS5wcm90b3R5cGUgPSB7XG4gIGdldDogZnVuY3Rpb24gKGtleSkge1xuICAgIHZhciBlbnRyeSA9IGZpbmRVbmNhdWdodEZyb3plbih0aGlzLCBrZXkpO1xuICAgIGlmIChlbnRyeSkgcmV0dXJuIGVudHJ5WzFdO1xuICB9LFxuICBoYXM6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gISFmaW5kVW5jYXVnaHRGcm96ZW4odGhpcywga2V5KTtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgIHZhciBlbnRyeSA9IGZpbmRVbmNhdWdodEZyb3plbih0aGlzLCBrZXkpO1xuICAgIGlmIChlbnRyeSkgZW50cnlbMV0gPSB2YWx1ZTtcbiAgICBlbHNlIHRoaXMuYS5wdXNoKFtrZXksIHZhbHVlXSk7XG4gIH0sXG4gICdkZWxldGUnOiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgdmFyIGluZGV4ID0gYXJyYXlGaW5kSW5kZXgodGhpcy5hLCBmdW5jdGlvbiAoaXQpIHtcbiAgICAgIHJldHVybiBpdFswXSA9PT0ga2V5O1xuICAgIH0pO1xuICAgIGlmICh+aW5kZXgpIHRoaXMuYS5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIHJldHVybiAhIX5pbmRleDtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGdldENvbnN0cnVjdG9yOiBmdW5jdGlvbiAod3JhcHBlciwgTkFNRSwgSVNfTUFQLCBBRERFUikge1xuICAgIHZhciBDID0gd3JhcHBlcihmdW5jdGlvbiAodGhhdCwgaXRlcmFibGUpIHtcbiAgICAgIGFuSW5zdGFuY2UodGhhdCwgQywgTkFNRSwgJ19pJyk7XG4gICAgICB0aGF0Ll90ID0gTkFNRTsgICAgICAvLyBjb2xsZWN0aW9uIHR5cGVcbiAgICAgIHRoYXQuX2kgPSBpZCsrOyAgICAgIC8vIGNvbGxlY3Rpb24gaWRcbiAgICAgIHRoYXQuX2wgPSB1bmRlZmluZWQ7IC8vIGxlYWsgc3RvcmUgZm9yIHVuY2F1Z2h0IGZyb3plbiBvYmplY3RzXG4gICAgICBpZiAoaXRlcmFibGUgIT0gdW5kZWZpbmVkKSBmb3JPZihpdGVyYWJsZSwgSVNfTUFQLCB0aGF0W0FEREVSXSwgdGhhdCk7XG4gICAgfSk7XG4gICAgcmVkZWZpbmVBbGwoQy5wcm90b3R5cGUsIHtcbiAgICAgIC8vIDIzLjMuMy4yIFdlYWtNYXAucHJvdG90eXBlLmRlbGV0ZShrZXkpXG4gICAgICAvLyAyMy40LjMuMyBXZWFrU2V0LnByb3RvdHlwZS5kZWxldGUodmFsdWUpXG4gICAgICAnZGVsZXRlJzogZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBpZiAoIWlzT2JqZWN0KGtleSkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgdmFyIGRhdGEgPSBnZXRXZWFrKGtleSk7XG4gICAgICAgIGlmIChkYXRhID09PSB0cnVlKSByZXR1cm4gdW5jYXVnaHRGcm96ZW5TdG9yZSh2YWxpZGF0ZSh0aGlzLCBOQU1FKSlbJ2RlbGV0ZSddKGtleSk7XG4gICAgICAgIHJldHVybiBkYXRhICYmICRoYXMoZGF0YSwgdGhpcy5faSkgJiYgZGVsZXRlIGRhdGFbdGhpcy5faV07XG4gICAgICB9LFxuICAgICAgLy8gMjMuMy4zLjQgV2Vha01hcC5wcm90b3R5cGUuaGFzKGtleSlcbiAgICAgIC8vIDIzLjQuMy40IFdlYWtTZXQucHJvdG90eXBlLmhhcyh2YWx1ZSlcbiAgICAgIGhhczogZnVuY3Rpb24gaGFzKGtleSkge1xuICAgICAgICBpZiAoIWlzT2JqZWN0KGtleSkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgdmFyIGRhdGEgPSBnZXRXZWFrKGtleSk7XG4gICAgICAgIGlmIChkYXRhID09PSB0cnVlKSByZXR1cm4gdW5jYXVnaHRGcm96ZW5TdG9yZSh2YWxpZGF0ZSh0aGlzLCBOQU1FKSkuaGFzKGtleSk7XG4gICAgICAgIHJldHVybiBkYXRhICYmICRoYXMoZGF0YSwgdGhpcy5faSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIEM7XG4gIH0sXG4gIGRlZjogZnVuY3Rpb24gKHRoYXQsIGtleSwgdmFsdWUpIHtcbiAgICB2YXIgZGF0YSA9IGdldFdlYWsoYW5PYmplY3Qoa2V5KSwgdHJ1ZSk7XG4gICAgaWYgKGRhdGEgPT09IHRydWUpIHVuY2F1Z2h0RnJvemVuU3RvcmUodGhhdCkuc2V0KGtleSwgdmFsdWUpO1xuICAgIGVsc2UgZGF0YVt0aGF0Ll9pXSA9IHZhbHVlO1xuICAgIHJldHVybiB0aGF0O1xuICB9LFxuICB1ZnN0b3JlOiB1bmNhdWdodEZyb3plblN0b3JlXG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fY29sbGVjdGlvbi13ZWFrLmpzIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciByZWRlZmluZSA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lJyk7XG52YXIgcmVkZWZpbmVBbGwgPSByZXF1aXJlKCcuL19yZWRlZmluZS1hbGwnKTtcbnZhciBtZXRhID0gcmVxdWlyZSgnLi9fbWV0YScpO1xudmFyIGZvck9mID0gcmVxdWlyZSgnLi9fZm9yLW9mJyk7XG52YXIgYW5JbnN0YW5jZSA9IHJlcXVpcmUoJy4vX2FuLWluc3RhbmNlJyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4vX2ZhaWxzJyk7XG52YXIgJGl0ZXJEZXRlY3QgPSByZXF1aXJlKCcuL19pdGVyLWRldGVjdCcpO1xudmFyIHNldFRvU3RyaW5nVGFnID0gcmVxdWlyZSgnLi9fc2V0LXRvLXN0cmluZy10YWcnKTtcbnZhciBpbmhlcml0SWZSZXF1aXJlZCA9IHJlcXVpcmUoJy4vX2luaGVyaXQtaWYtcmVxdWlyZWQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoTkFNRSwgd3JhcHBlciwgbWV0aG9kcywgY29tbW9uLCBJU19NQVAsIElTX1dFQUspIHtcbiAgdmFyIEJhc2UgPSBnbG9iYWxbTkFNRV07XG4gIHZhciBDID0gQmFzZTtcbiAgdmFyIEFEREVSID0gSVNfTUFQID8gJ3NldCcgOiAnYWRkJztcbiAgdmFyIHByb3RvID0gQyAmJiBDLnByb3RvdHlwZTtcbiAgdmFyIE8gPSB7fTtcbiAgdmFyIGZpeE1ldGhvZCA9IGZ1bmN0aW9uIChLRVkpIHtcbiAgICB2YXIgZm4gPSBwcm90b1tLRVldO1xuICAgIHJlZGVmaW5lKHByb3RvLCBLRVksXG4gICAgICBLRVkgPT0gJ2RlbGV0ZScgPyBmdW5jdGlvbiAoYSkge1xuICAgICAgICByZXR1cm4gSVNfV0VBSyAmJiAhaXNPYmplY3QoYSkgPyBmYWxzZSA6IGZuLmNhbGwodGhpcywgYSA9PT0gMCA/IDAgOiBhKTtcbiAgICAgIH0gOiBLRVkgPT0gJ2hhcycgPyBmdW5jdGlvbiBoYXMoYSkge1xuICAgICAgICByZXR1cm4gSVNfV0VBSyAmJiAhaXNPYmplY3QoYSkgPyBmYWxzZSA6IGZuLmNhbGwodGhpcywgYSA9PT0gMCA/IDAgOiBhKTtcbiAgICAgIH0gOiBLRVkgPT0gJ2dldCcgPyBmdW5jdGlvbiBnZXQoYSkge1xuICAgICAgICByZXR1cm4gSVNfV0VBSyAmJiAhaXNPYmplY3QoYSkgPyB1bmRlZmluZWQgOiBmbi5jYWxsKHRoaXMsIGEgPT09IDAgPyAwIDogYSk7XG4gICAgICB9IDogS0VZID09ICdhZGQnID8gZnVuY3Rpb24gYWRkKGEpIHsgZm4uY2FsbCh0aGlzLCBhID09PSAwID8gMCA6IGEpOyByZXR1cm4gdGhpczsgfVxuICAgICAgICA6IGZ1bmN0aW9uIHNldChhLCBiKSB7IGZuLmNhbGwodGhpcywgYSA9PT0gMCA/IDAgOiBhLCBiKTsgcmV0dXJuIHRoaXM7IH1cbiAgICApO1xuICB9O1xuICBpZiAodHlwZW9mIEMgIT0gJ2Z1bmN0aW9uJyB8fCAhKElTX1dFQUsgfHwgcHJvdG8uZm9yRWFjaCAmJiAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgIG5ldyBDKCkuZW50cmllcygpLm5leHQoKTtcbiAgfSkpKSB7XG4gICAgLy8gY3JlYXRlIGNvbGxlY3Rpb24gY29uc3RydWN0b3JcbiAgICBDID0gY29tbW9uLmdldENvbnN0cnVjdG9yKHdyYXBwZXIsIE5BTUUsIElTX01BUCwgQURERVIpO1xuICAgIHJlZGVmaW5lQWxsKEMucHJvdG90eXBlLCBtZXRob2RzKTtcbiAgICBtZXRhLk5FRUQgPSB0cnVlO1xuICB9IGVsc2Uge1xuICAgIHZhciBpbnN0YW5jZSA9IG5ldyBDKCk7XG4gICAgLy8gZWFybHkgaW1wbGVtZW50YXRpb25zIG5vdCBzdXBwb3J0cyBjaGFpbmluZ1xuICAgIHZhciBIQVNOVF9DSEFJTklORyA9IGluc3RhbmNlW0FEREVSXShJU19XRUFLID8ge30gOiAtMCwgMSkgIT0gaW5zdGFuY2U7XG4gICAgLy8gVjggfiAgQ2hyb21pdW0gNDAtIHdlYWstY29sbGVjdGlvbnMgdGhyb3dzIG9uIHByaW1pdGl2ZXMsIGJ1dCBzaG91bGQgcmV0dXJuIGZhbHNlXG4gICAgdmFyIFRIUk9XU19PTl9QUklNSVRJVkVTID0gZmFpbHMoZnVuY3Rpb24gKCkgeyBpbnN0YW5jZS5oYXMoMSk7IH0pO1xuICAgIC8vIG1vc3QgZWFybHkgaW1wbGVtZW50YXRpb25zIGRvZXNuJ3Qgc3VwcG9ydHMgaXRlcmFibGVzLCBtb3N0IG1vZGVybiAtIG5vdCBjbG9zZSBpdCBjb3JyZWN0bHlcbiAgICB2YXIgQUNDRVBUX0lURVJBQkxFUyA9ICRpdGVyRGV0ZWN0KGZ1bmN0aW9uIChpdGVyKSB7IG5ldyBDKGl0ZXIpOyB9KTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXdcbiAgICAvLyBmb3IgZWFybHkgaW1wbGVtZW50YXRpb25zIC0wIGFuZCArMCBub3QgdGhlIHNhbWVcbiAgICB2YXIgQlVHR1lfWkVSTyA9ICFJU19XRUFLICYmIGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIFY4IH4gQ2hyb21pdW0gNDItIGZhaWxzIG9ubHkgd2l0aCA1KyBlbGVtZW50c1xuICAgICAgdmFyICRpbnN0YW5jZSA9IG5ldyBDKCk7XG4gICAgICB2YXIgaW5kZXggPSA1O1xuICAgICAgd2hpbGUgKGluZGV4LS0pICRpbnN0YW5jZVtBRERFUl0oaW5kZXgsIGluZGV4KTtcbiAgICAgIHJldHVybiAhJGluc3RhbmNlLmhhcygtMCk7XG4gICAgfSk7XG4gICAgaWYgKCFBQ0NFUFRfSVRFUkFCTEVTKSB7XG4gICAgICBDID0gd3JhcHBlcihmdW5jdGlvbiAodGFyZ2V0LCBpdGVyYWJsZSkge1xuICAgICAgICBhbkluc3RhbmNlKHRhcmdldCwgQywgTkFNRSk7XG4gICAgICAgIHZhciB0aGF0ID0gaW5oZXJpdElmUmVxdWlyZWQobmV3IEJhc2UoKSwgdGFyZ2V0LCBDKTtcbiAgICAgICAgaWYgKGl0ZXJhYmxlICE9IHVuZGVmaW5lZCkgZm9yT2YoaXRlcmFibGUsIElTX01BUCwgdGhhdFtBRERFUl0sIHRoYXQpO1xuICAgICAgICByZXR1cm4gdGhhdDtcbiAgICAgIH0pO1xuICAgICAgQy5wcm90b3R5cGUgPSBwcm90bztcbiAgICAgIHByb3RvLmNvbnN0cnVjdG9yID0gQztcbiAgICB9XG4gICAgaWYgKFRIUk9XU19PTl9QUklNSVRJVkVTIHx8IEJVR0dZX1pFUk8pIHtcbiAgICAgIGZpeE1ldGhvZCgnZGVsZXRlJyk7XG4gICAgICBmaXhNZXRob2QoJ2hhcycpO1xuICAgICAgSVNfTUFQICYmIGZpeE1ldGhvZCgnZ2V0Jyk7XG4gICAgfVxuICAgIGlmIChCVUdHWV9aRVJPIHx8IEhBU05UX0NIQUlOSU5HKSBmaXhNZXRob2QoQURERVIpO1xuICAgIC8vIHdlYWsgY29sbGVjdGlvbnMgc2hvdWxkIG5vdCBjb250YWlucyAuY2xlYXIgbWV0aG9kXG4gICAgaWYgKElTX1dFQUsgJiYgcHJvdG8uY2xlYXIpIGRlbGV0ZSBwcm90by5jbGVhcjtcbiAgfVxuXG4gIHNldFRvU3RyaW5nVGFnKEMsIE5BTUUpO1xuXG4gIE9bTkFNRV0gPSBDO1xuICAkZXhwb3J0KCRleHBvcnQuRyArICRleHBvcnQuVyArICRleHBvcnQuRiAqIChDICE9IEJhc2UpLCBPKTtcblxuICBpZiAoIUlTX1dFQUspIGNvbW1vbi5zZXRTdHJvbmcoQywgTkFNRSwgSVNfTUFQKTtcblxuICByZXR1cm4gQztcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19jb2xsZWN0aW9uLmpzIiwidmFyIGNvcmUgPSBtb2R1bGUuZXhwb3J0cyA9IHsgdmVyc2lvbjogJzIuNS4xJyB9O1xuaWYgKHR5cGVvZiBfX2UgPT0gJ251bWJlcicpIF9fZSA9IGNvcmU7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2NvcmUuanMiLCIndXNlIHN0cmljdCc7XG52YXIgJGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJyk7XG52YXIgY3JlYXRlRGVzYyA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqZWN0LCBpbmRleCwgdmFsdWUpIHtcbiAgaWYgKGluZGV4IGluIG9iamVjdCkgJGRlZmluZVByb3BlcnR5LmYob2JqZWN0LCBpbmRleCwgY3JlYXRlRGVzYygwLCB2YWx1ZSkpO1xuICBlbHNlIG9iamVjdFtpbmRleF0gPSB2YWx1ZTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19jcmVhdGUtcHJvcGVydHkuanMiLCIvLyBvcHRpb25hbCAvIHNpbXBsZSBjb250ZXh0IGJpbmRpbmdcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChmbiwgdGhhdCwgbGVuZ3RoKSB7XG4gIGFGdW5jdGlvbihmbik7XG4gIGlmICh0aGF0ID09PSB1bmRlZmluZWQpIHJldHVybiBmbjtcbiAgc3dpdGNoIChsZW5ndGgpIHtcbiAgICBjYXNlIDE6IHJldHVybiBmdW5jdGlvbiAoYSkge1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSk7XG4gICAgfTtcbiAgICBjYXNlIDI6IHJldHVybiBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSwgYik7XG4gICAgfTtcbiAgICBjYXNlIDM6IHJldHVybiBmdW5jdGlvbiAoYSwgYiwgYykge1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSwgYiwgYyk7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24gKC8qIC4uLmFyZ3MgKi8pIHtcbiAgICByZXR1cm4gZm4uYXBwbHkodGhhdCwgYXJndW1lbnRzKTtcbiAgfTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19jdHguanMiLCIndXNlIHN0cmljdCc7XG4vLyAyMC4zLjQuMzYgLyAxNS45LjUuNDMgRGF0ZS5wcm90b3R5cGUudG9JU09TdHJpbmcoKVxudmFyIGZhaWxzID0gcmVxdWlyZSgnLi9fZmFpbHMnKTtcbnZhciBnZXRUaW1lID0gRGF0ZS5wcm90b3R5cGUuZ2V0VGltZTtcbnZhciAkdG9JU09TdHJpbmcgPSBEYXRlLnByb3RvdHlwZS50b0lTT1N0cmluZztcblxudmFyIGx6ID0gZnVuY3Rpb24gKG51bSkge1xuICByZXR1cm4gbnVtID4gOSA/IG51bSA6ICcwJyArIG51bTtcbn07XG5cbi8vIFBoYW50b21KUyAvIG9sZCBXZWJLaXQgaGFzIGEgYnJva2VuIGltcGxlbWVudGF0aW9uc1xubW9kdWxlLmV4cG9ydHMgPSAoZmFpbHMoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gJHRvSVNPU3RyaW5nLmNhbGwobmV3IERhdGUoLTVlMTMgLSAxKSkgIT0gJzAzODUtMDctMjVUMDc6MDY6MzkuOTk5Wic7XG59KSB8fCAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICAkdG9JU09TdHJpbmcuY2FsbChuZXcgRGF0ZShOYU4pKTtcbn0pKSA/IGZ1bmN0aW9uIHRvSVNPU3RyaW5nKCkge1xuICBpZiAoIWlzRmluaXRlKGdldFRpbWUuY2FsbCh0aGlzKSkpIHRocm93IFJhbmdlRXJyb3IoJ0ludmFsaWQgdGltZSB2YWx1ZScpO1xuICB2YXIgZCA9IHRoaXM7XG4gIHZhciB5ID0gZC5nZXRVVENGdWxsWWVhcigpO1xuICB2YXIgbSA9IGQuZ2V0VVRDTWlsbGlzZWNvbmRzKCk7XG4gIHZhciBzID0geSA8IDAgPyAnLScgOiB5ID4gOTk5OSA/ICcrJyA6ICcnO1xuICByZXR1cm4gcyArICgnMDAwMDAnICsgTWF0aC5hYnMoeSkpLnNsaWNlKHMgPyAtNiA6IC00KSArXG4gICAgJy0nICsgbHooZC5nZXRVVENNb250aCgpICsgMSkgKyAnLScgKyBseihkLmdldFVUQ0RhdGUoKSkgK1xuICAgICdUJyArIGx6KGQuZ2V0VVRDSG91cnMoKSkgKyAnOicgKyBseihkLmdldFVUQ01pbnV0ZXMoKSkgK1xuICAgICc6JyArIGx6KGQuZ2V0VVRDU2Vjb25kcygpKSArICcuJyArIChtID4gOTkgPyBtIDogJzAnICsgbHoobSkpICsgJ1onO1xufSA6ICR0b0lTT1N0cmluZztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2RhdGUtdG8taXNvLXN0cmluZy5qcyIsIid1c2Ugc3RyaWN0JztcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIHRvUHJpbWl0aXZlID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJyk7XG52YXIgTlVNQkVSID0gJ251bWJlcic7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGhpbnQpIHtcbiAgaWYgKGhpbnQgIT09ICdzdHJpbmcnICYmIGhpbnQgIT09IE5VTUJFUiAmJiBoaW50ICE9PSAnZGVmYXVsdCcpIHRocm93IFR5cGVFcnJvcignSW5jb3JyZWN0IGhpbnQnKTtcbiAgcmV0dXJuIHRvUHJpbWl0aXZlKGFuT2JqZWN0KHRoaXMpLCBoaW50ICE9IE5VTUJFUik7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZGF0ZS10by1wcmltaXRpdmUuanMiLCIvLyA3LjIuMSBSZXF1aXJlT2JqZWN0Q29lcmNpYmxlKGFyZ3VtZW50KVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKGl0ID09IHVuZGVmaW5lZCkgdGhyb3cgVHlwZUVycm9yKFwiQ2FuJ3QgY2FsbCBtZXRob2Qgb24gIFwiICsgaXQpO1xuICByZXR1cm4gaXQ7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZGVmaW5lZC5qcyIsIi8vIFRoYW5rJ3MgSUU4IGZvciBoaXMgZnVubnkgZGVmaW5lUHJvcGVydHlcbm1vZHVsZS5leHBvcnRzID0gIXJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAnYScsIHsgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiA3OyB9IH0pLmEgIT0gNztcbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZGVzY3JpcHRvcnMuanMiLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBkb2N1bWVudCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLmRvY3VtZW50O1xuLy8gdHlwZW9mIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgaXMgJ29iamVjdCcgaW4gb2xkIElFXG52YXIgaXMgPSBpc09iamVjdChkb2N1bWVudCkgJiYgaXNPYmplY3QoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXMgPyBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGl0KSA6IHt9O1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2RvbS1jcmVhdGUuanMiLCIvLyBJRSA4LSBkb24ndCBlbnVtIGJ1ZyBrZXlzXG5tb2R1bGUuZXhwb3J0cyA9IChcbiAgJ2NvbnN0cnVjdG9yLGhhc093blByb3BlcnR5LGlzUHJvdG90eXBlT2YscHJvcGVydHlJc0VudW1lcmFibGUsdG9Mb2NhbGVTdHJpbmcsdG9TdHJpbmcsdmFsdWVPZidcbikuc3BsaXQoJywnKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2VudW0tYnVnLWtleXMuanMiLCIvLyBhbGwgZW51bWVyYWJsZSBvYmplY3Qga2V5cywgaW5jbHVkZXMgc3ltYm9sc1xudmFyIGdldEtleXMgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpO1xudmFyIGdPUFMgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wcycpO1xudmFyIHBJRSA9IHJlcXVpcmUoJy4vX29iamVjdC1waWUnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHZhciByZXN1bHQgPSBnZXRLZXlzKGl0KTtcbiAgdmFyIGdldFN5bWJvbHMgPSBnT1BTLmY7XG4gIGlmIChnZXRTeW1ib2xzKSB7XG4gICAgdmFyIHN5bWJvbHMgPSBnZXRTeW1ib2xzKGl0KTtcbiAgICB2YXIgaXNFbnVtID0gcElFLmY7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBrZXk7XG4gICAgd2hpbGUgKHN5bWJvbHMubGVuZ3RoID4gaSkgaWYgKGlzRW51bS5jYWxsKGl0LCBrZXkgPSBzeW1ib2xzW2krK10pKSByZXN1bHQucHVzaChrZXkpO1xuICB9IHJldHVybiByZXN1bHQ7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZW51bS1rZXlzLmpzIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIGNvcmUgPSByZXF1aXJlKCcuL19jb3JlJyk7XG52YXIgaGlkZSA9IHJlcXVpcmUoJy4vX2hpZGUnKTtcbnZhciByZWRlZmluZSA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lJyk7XG52YXIgY3R4ID0gcmVxdWlyZSgnLi9fY3R4Jyk7XG52YXIgUFJPVE9UWVBFID0gJ3Byb3RvdHlwZSc7XG5cbnZhciAkZXhwb3J0ID0gZnVuY3Rpb24gKHR5cGUsIG5hbWUsIHNvdXJjZSkge1xuICB2YXIgSVNfRk9SQ0VEID0gdHlwZSAmICRleHBvcnQuRjtcbiAgdmFyIElTX0dMT0JBTCA9IHR5cGUgJiAkZXhwb3J0Lkc7XG4gIHZhciBJU19TVEFUSUMgPSB0eXBlICYgJGV4cG9ydC5TO1xuICB2YXIgSVNfUFJPVE8gPSB0eXBlICYgJGV4cG9ydC5QO1xuICB2YXIgSVNfQklORCA9IHR5cGUgJiAkZXhwb3J0LkI7XG4gIHZhciB0YXJnZXQgPSBJU19HTE9CQUwgPyBnbG9iYWwgOiBJU19TVEFUSUMgPyBnbG9iYWxbbmFtZV0gfHwgKGdsb2JhbFtuYW1lXSA9IHt9KSA6IChnbG9iYWxbbmFtZV0gfHwge30pW1BST1RPVFlQRV07XG4gIHZhciBleHBvcnRzID0gSVNfR0xPQkFMID8gY29yZSA6IGNvcmVbbmFtZV0gfHwgKGNvcmVbbmFtZV0gPSB7fSk7XG4gIHZhciBleHBQcm90byA9IGV4cG9ydHNbUFJPVE9UWVBFXSB8fCAoZXhwb3J0c1tQUk9UT1RZUEVdID0ge30pO1xuICB2YXIga2V5LCBvd24sIG91dCwgZXhwO1xuICBpZiAoSVNfR0xPQkFMKSBzb3VyY2UgPSBuYW1lO1xuICBmb3IgKGtleSBpbiBzb3VyY2UpIHtcbiAgICAvLyBjb250YWlucyBpbiBuYXRpdmVcbiAgICBvd24gPSAhSVNfRk9SQ0VEICYmIHRhcmdldCAmJiB0YXJnZXRba2V5XSAhPT0gdW5kZWZpbmVkO1xuICAgIC8vIGV4cG9ydCBuYXRpdmUgb3IgcGFzc2VkXG4gICAgb3V0ID0gKG93biA/IHRhcmdldCA6IHNvdXJjZSlba2V5XTtcbiAgICAvLyBiaW5kIHRpbWVycyB0byBnbG9iYWwgZm9yIGNhbGwgZnJvbSBleHBvcnQgY29udGV4dFxuICAgIGV4cCA9IElTX0JJTkQgJiYgb3duID8gY3R4KG91dCwgZ2xvYmFsKSA6IElTX1BST1RPICYmIHR5cGVvZiBvdXQgPT0gJ2Z1bmN0aW9uJyA/IGN0eChGdW5jdGlvbi5jYWxsLCBvdXQpIDogb3V0O1xuICAgIC8vIGV4dGVuZCBnbG9iYWxcbiAgICBpZiAodGFyZ2V0KSByZWRlZmluZSh0YXJnZXQsIGtleSwgb3V0LCB0eXBlICYgJGV4cG9ydC5VKTtcbiAgICAvLyBleHBvcnRcbiAgICBpZiAoZXhwb3J0c1trZXldICE9IG91dCkgaGlkZShleHBvcnRzLCBrZXksIGV4cCk7XG4gICAgaWYgKElTX1BST1RPICYmIGV4cFByb3RvW2tleV0gIT0gb3V0KSBleHBQcm90b1trZXldID0gb3V0O1xuICB9XG59O1xuZ2xvYmFsLmNvcmUgPSBjb3JlO1xuLy8gdHlwZSBiaXRtYXBcbiRleHBvcnQuRiA9IDE7ICAgLy8gZm9yY2VkXG4kZXhwb3J0LkcgPSAyOyAgIC8vIGdsb2JhbFxuJGV4cG9ydC5TID0gNDsgICAvLyBzdGF0aWNcbiRleHBvcnQuUCA9IDg7ICAgLy8gcHJvdG9cbiRleHBvcnQuQiA9IDE2OyAgLy8gYmluZFxuJGV4cG9ydC5XID0gMzI7ICAvLyB3cmFwXG4kZXhwb3J0LlUgPSA2NDsgIC8vIHNhZmVcbiRleHBvcnQuUiA9IDEyODsgLy8gcmVhbCBwcm90byBtZXRob2QgZm9yIGBsaWJyYXJ5YFxubW9kdWxlLmV4cG9ydHMgPSAkZXhwb3J0O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZXhwb3J0LmpzIiwidmFyIE1BVENIID0gcmVxdWlyZSgnLi9fd2tzJykoJ21hdGNoJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChLRVkpIHtcbiAgdmFyIHJlID0gLy4vO1xuICB0cnkge1xuICAgICcvLi8nW0tFWV0ocmUpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJlW01BVENIXSA9IGZhbHNlO1xuICAgICAgcmV0dXJuICEnLy4vJ1tLRVldKHJlKTtcbiAgICB9IGNhdGNoIChmKSB7IC8qIGVtcHR5ICovIH1cbiAgfSByZXR1cm4gdHJ1ZTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19mYWlscy1pcy1yZWdleHAuanMiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChleGVjKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuICEhZXhlYygpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19mYWlscy5qcyIsIid1c2Ugc3RyaWN0JztcbnZhciBoaWRlID0gcmVxdWlyZSgnLi9faGlkZScpO1xudmFyIHJlZGVmaW5lID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUnKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4vX2ZhaWxzJyk7XG52YXIgZGVmaW5lZCA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcbnZhciB3a3MgPSByZXF1aXJlKCcuL193a3MnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoS0VZLCBsZW5ndGgsIGV4ZWMpIHtcbiAgdmFyIFNZTUJPTCA9IHdrcyhLRVkpO1xuICB2YXIgZm5zID0gZXhlYyhkZWZpbmVkLCBTWU1CT0wsICcnW0tFWV0pO1xuICB2YXIgc3RyZm4gPSBmbnNbMF07XG4gIHZhciByeGZuID0gZm5zWzFdO1xuICBpZiAoZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgIHZhciBPID0ge307XG4gICAgT1tTWU1CT0xdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gNzsgfTtcbiAgICByZXR1cm4gJydbS0VZXShPKSAhPSA3O1xuICB9KSkge1xuICAgIHJlZGVmaW5lKFN0cmluZy5wcm90b3R5cGUsIEtFWSwgc3RyZm4pO1xuICAgIGhpZGUoUmVnRXhwLnByb3RvdHlwZSwgU1lNQk9MLCBsZW5ndGggPT0gMlxuICAgICAgLy8gMjEuMi41LjggUmVnRXhwLnByb3RvdHlwZVtAQHJlcGxhY2VdKHN0cmluZywgcmVwbGFjZVZhbHVlKVxuICAgICAgLy8gMjEuMi41LjExIFJlZ0V4cC5wcm90b3R5cGVbQEBzcGxpdF0oc3RyaW5nLCBsaW1pdClcbiAgICAgID8gZnVuY3Rpb24gKHN0cmluZywgYXJnKSB7IHJldHVybiByeGZuLmNhbGwoc3RyaW5nLCB0aGlzLCBhcmcpOyB9XG4gICAgICAvLyAyMS4yLjUuNiBSZWdFeHAucHJvdG90eXBlW0BAbWF0Y2hdKHN0cmluZylcbiAgICAgIC8vIDIxLjIuNS45IFJlZ0V4cC5wcm90b3R5cGVbQEBzZWFyY2hdKHN0cmluZylcbiAgICAgIDogZnVuY3Rpb24gKHN0cmluZykgeyByZXR1cm4gcnhmbi5jYWxsKHN0cmluZywgdGhpcyk7IH1cbiAgICApO1xuICB9XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZml4LXJlLXdrcy5qcyIsIid1c2Ugc3RyaWN0Jztcbi8vIDIxLjIuNS4zIGdldCBSZWdFeHAucHJvdG90eXBlLmZsYWdzXG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgdGhhdCA9IGFuT2JqZWN0KHRoaXMpO1xuICB2YXIgcmVzdWx0ID0gJyc7XG4gIGlmICh0aGF0Lmdsb2JhbCkgcmVzdWx0ICs9ICdnJztcbiAgaWYgKHRoYXQuaWdub3JlQ2FzZSkgcmVzdWx0ICs9ICdpJztcbiAgaWYgKHRoYXQubXVsdGlsaW5lKSByZXN1bHQgKz0gJ20nO1xuICBpZiAodGhhdC51bmljb2RlKSByZXN1bHQgKz0gJ3UnO1xuICBpZiAodGhhdC5zdGlja3kpIHJlc3VsdCArPSAneSc7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZmxhZ3MuanMiLCIndXNlIHN0cmljdCc7XG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL3Byb3Bvc2FsLWZsYXRNYXAvI3NlYy1GbGF0dGVuSW50b0FycmF5XG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJy4vX2lzLWFycmF5Jyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xudmFyIGN0eCA9IHJlcXVpcmUoJy4vX2N0eCcpO1xudmFyIElTX0NPTkNBVF9TUFJFQURBQkxFID0gcmVxdWlyZSgnLi9fd2tzJykoJ2lzQ29uY2F0U3ByZWFkYWJsZScpO1xuXG5mdW5jdGlvbiBmbGF0dGVuSW50b0FycmF5KHRhcmdldCwgb3JpZ2luYWwsIHNvdXJjZSwgc291cmNlTGVuLCBzdGFydCwgZGVwdGgsIG1hcHBlciwgdGhpc0FyZykge1xuICB2YXIgdGFyZ2V0SW5kZXggPSBzdGFydDtcbiAgdmFyIHNvdXJjZUluZGV4ID0gMDtcbiAgdmFyIG1hcEZuID0gbWFwcGVyID8gY3R4KG1hcHBlciwgdGhpc0FyZywgMykgOiBmYWxzZTtcbiAgdmFyIGVsZW1lbnQsIHNwcmVhZGFibGU7XG5cbiAgd2hpbGUgKHNvdXJjZUluZGV4IDwgc291cmNlTGVuKSB7XG4gICAgaWYgKHNvdXJjZUluZGV4IGluIHNvdXJjZSkge1xuICAgICAgZWxlbWVudCA9IG1hcEZuID8gbWFwRm4oc291cmNlW3NvdXJjZUluZGV4XSwgc291cmNlSW5kZXgsIG9yaWdpbmFsKSA6IHNvdXJjZVtzb3VyY2VJbmRleF07XG5cbiAgICAgIHNwcmVhZGFibGUgPSBmYWxzZTtcbiAgICAgIGlmIChpc09iamVjdChlbGVtZW50KSkge1xuICAgICAgICBzcHJlYWRhYmxlID0gZWxlbWVudFtJU19DT05DQVRfU1BSRUFEQUJMRV07XG4gICAgICAgIHNwcmVhZGFibGUgPSBzcHJlYWRhYmxlICE9PSB1bmRlZmluZWQgPyAhIXNwcmVhZGFibGUgOiBpc0FycmF5KGVsZW1lbnQpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3ByZWFkYWJsZSAmJiBkZXB0aCA+IDApIHtcbiAgICAgICAgdGFyZ2V0SW5kZXggPSBmbGF0dGVuSW50b0FycmF5KHRhcmdldCwgb3JpZ2luYWwsIGVsZW1lbnQsIHRvTGVuZ3RoKGVsZW1lbnQubGVuZ3RoKSwgdGFyZ2V0SW5kZXgsIGRlcHRoIC0gMSkgLSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRhcmdldEluZGV4ID49IDB4MWZmZmZmZmZmZmZmZmYpIHRocm93IFR5cGVFcnJvcigpO1xuICAgICAgICB0YXJnZXRbdGFyZ2V0SW5kZXhdID0gZWxlbWVudDtcbiAgICAgIH1cblxuICAgICAgdGFyZ2V0SW5kZXgrKztcbiAgICB9XG4gICAgc291cmNlSW5kZXgrKztcbiAgfVxuICByZXR1cm4gdGFyZ2V0SW5kZXg7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZmxhdHRlbkludG9BcnJheTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2ZsYXR0ZW4taW50by1hcnJheS5qcyIsInZhciBjdHggPSByZXF1aXJlKCcuL19jdHgnKTtcbnZhciBjYWxsID0gcmVxdWlyZSgnLi9faXRlci1jYWxsJyk7XG52YXIgaXNBcnJheUl0ZXIgPSByZXF1aXJlKCcuL19pcy1hcnJheS1pdGVyJyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xudmFyIGdldEl0ZXJGbiA9IHJlcXVpcmUoJy4vY29yZS5nZXQtaXRlcmF0b3ItbWV0aG9kJyk7XG52YXIgQlJFQUsgPSB7fTtcbnZhciBSRVRVUk4gPSB7fTtcbnZhciBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXRlcmFibGUsIGVudHJpZXMsIGZuLCB0aGF0LCBJVEVSQVRPUikge1xuICB2YXIgaXRlckZuID0gSVRFUkFUT1IgPyBmdW5jdGlvbiAoKSB7IHJldHVybiBpdGVyYWJsZTsgfSA6IGdldEl0ZXJGbihpdGVyYWJsZSk7XG4gIHZhciBmID0gY3R4KGZuLCB0aGF0LCBlbnRyaWVzID8gMiA6IDEpO1xuICB2YXIgaW5kZXggPSAwO1xuICB2YXIgbGVuZ3RoLCBzdGVwLCBpdGVyYXRvciwgcmVzdWx0O1xuICBpZiAodHlwZW9mIGl0ZXJGbiAhPSAnZnVuY3Rpb24nKSB0aHJvdyBUeXBlRXJyb3IoaXRlcmFibGUgKyAnIGlzIG5vdCBpdGVyYWJsZSEnKTtcbiAgLy8gZmFzdCBjYXNlIGZvciBhcnJheXMgd2l0aCBkZWZhdWx0IGl0ZXJhdG9yXG4gIGlmIChpc0FycmF5SXRlcihpdGVyRm4pKSBmb3IgKGxlbmd0aCA9IHRvTGVuZ3RoKGl0ZXJhYmxlLmxlbmd0aCk7IGxlbmd0aCA+IGluZGV4OyBpbmRleCsrKSB7XG4gICAgcmVzdWx0ID0gZW50cmllcyA/IGYoYW5PYmplY3Qoc3RlcCA9IGl0ZXJhYmxlW2luZGV4XSlbMF0sIHN0ZXBbMV0pIDogZihpdGVyYWJsZVtpbmRleF0pO1xuICAgIGlmIChyZXN1bHQgPT09IEJSRUFLIHx8IHJlc3VsdCA9PT0gUkVUVVJOKSByZXR1cm4gcmVzdWx0O1xuICB9IGVsc2UgZm9yIChpdGVyYXRvciA9IGl0ZXJGbi5jYWxsKGl0ZXJhYmxlKTsgIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lOykge1xuICAgIHJlc3VsdCA9IGNhbGwoaXRlcmF0b3IsIGYsIHN0ZXAudmFsdWUsIGVudHJpZXMpO1xuICAgIGlmIChyZXN1bHQgPT09IEJSRUFLIHx8IHJlc3VsdCA9PT0gUkVUVVJOKSByZXR1cm4gcmVzdWx0O1xuICB9XG59O1xuZXhwb3J0cy5CUkVBSyA9IEJSRUFLO1xuZXhwb3J0cy5SRVRVUk4gPSBSRVRVUk47XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19mb3Itb2YuanMiLCIvLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvODYjaXNzdWVjb21tZW50LTExNTc1OTAyOFxudmFyIGdsb2JhbCA9IG1vZHVsZS5leHBvcnRzID0gdHlwZW9mIHdpbmRvdyAhPSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuTWF0aCA9PSBNYXRoXG4gID8gd2luZG93IDogdHlwZW9mIHNlbGYgIT0gJ3VuZGVmaW5lZCcgJiYgc2VsZi5NYXRoID09IE1hdGggPyBzZWxmXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXctZnVuY1xuICA6IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5pZiAodHlwZW9mIF9fZyA9PSAnbnVtYmVyJykgX19nID0gZ2xvYmFsOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19nbG9iYWwuanMiLCJ2YXIgaGFzT3duUHJvcGVydHkgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0LCBrZXkpIHtcbiAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwoaXQsIGtleSk7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faGFzLmpzIiwidmFyIGRQID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJyk7XG52YXIgY3JlYXRlRGVzYyA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IGZ1bmN0aW9uIChvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgcmV0dXJuIGRQLmYob2JqZWN0LCBrZXksIGNyZWF0ZURlc2MoMSwgdmFsdWUpKTtcbn0gOiBmdW5jdGlvbiAob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIG9iamVjdFtrZXldID0gdmFsdWU7XG4gIHJldHVybiBvYmplY3Q7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faGlkZS5qcyIsInZhciBkb2N1bWVudCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLmRvY3VtZW50O1xubW9kdWxlLmV4cG9ydHMgPSBkb2N1bWVudCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19odG1sLmpzIiwibW9kdWxlLmV4cG9ydHMgPSAhcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSAmJiAhcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVxdWlyZSgnLi9fZG9tLWNyZWF0ZScpKCdkaXYnKSwgJ2EnLCB7IGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gNzsgfSB9KS5hICE9IDc7XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2llOC1kb20tZGVmaW5lLmpzIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgc2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuL19zZXQtcHJvdG8nKS5zZXQ7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh0aGF0LCB0YXJnZXQsIEMpIHtcbiAgdmFyIFMgPSB0YXJnZXQuY29uc3RydWN0b3I7XG4gIHZhciBQO1xuICBpZiAoUyAhPT0gQyAmJiB0eXBlb2YgUyA9PSAnZnVuY3Rpb24nICYmIChQID0gUy5wcm90b3R5cGUpICE9PSBDLnByb3RvdHlwZSAmJiBpc09iamVjdChQKSAmJiBzZXRQcm90b3R5cGVPZikge1xuICAgIHNldFByb3RvdHlwZU9mKHRoYXQsIFApO1xuICB9IHJldHVybiB0aGF0O1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2luaGVyaXQtaWYtcmVxdWlyZWQuanMiLCIvLyBmYXN0IGFwcGx5LCBodHRwOi8vanNwZXJmLmxua2l0LmNvbS9mYXN0LWFwcGx5LzVcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGZuLCBhcmdzLCB0aGF0KSB7XG4gIHZhciB1biA9IHRoYXQgPT09IHVuZGVmaW5lZDtcbiAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgIGNhc2UgMDogcmV0dXJuIHVuID8gZm4oKVxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0KTtcbiAgICBjYXNlIDE6IHJldHVybiB1biA/IGZuKGFyZ3NbMF0pXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQsIGFyZ3NbMF0pO1xuICAgIGNhc2UgMjogcmV0dXJuIHVuID8gZm4oYXJnc1swXSwgYXJnc1sxXSlcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCwgYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgY2FzZSAzOiByZXR1cm4gdW4gPyBmbihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKVxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0LCBhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgICBjYXNlIDQ6IHJldHVybiB1biA/IGZuKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10pXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQsIGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10pO1xuICB9IHJldHVybiBmbi5hcHBseSh0aGF0LCBhcmdzKTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pbnZva2UuanMiLCIvLyBmYWxsYmFjayBmb3Igbm9uLWFycmF5LWxpa2UgRVMzIGFuZCBub24tZW51bWVyYWJsZSBvbGQgVjggc3RyaW5nc1xudmFyIGNvZiA9IHJlcXVpcmUoJy4vX2NvZicpO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb3RvdHlwZS1idWlsdGluc1xubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QoJ3onKS5wcm9wZXJ0eUlzRW51bWVyYWJsZSgwKSA/IE9iamVjdCA6IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gY29mKGl0KSA9PSAnU3RyaW5nJyA/IGl0LnNwbGl0KCcnKSA6IE9iamVjdChpdCk7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faW9iamVjdC5qcyIsIi8vIGNoZWNrIG9uIGRlZmF1bHQgQXJyYXkgaXRlcmF0b3JcbnZhciBJdGVyYXRvcnMgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKTtcbnZhciBJVEVSQVRPUiA9IHJlcXVpcmUoJy4vX3drcycpKCdpdGVyYXRvcicpO1xudmFyIEFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGU7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBpdCAhPT0gdW5kZWZpbmVkICYmIChJdGVyYXRvcnMuQXJyYXkgPT09IGl0IHx8IEFycmF5UHJvdG9bSVRFUkFUT1JdID09PSBpdCk7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faXMtYXJyYXktaXRlci5qcyIsIi8vIDcuMi4yIElzQXJyYXkoYXJndW1lbnQpXG52YXIgY29mID0gcmVxdWlyZSgnLi9fY29mJyk7XG5tb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gaXNBcnJheShhcmcpIHtcbiAgcmV0dXJuIGNvZihhcmcpID09ICdBcnJheSc7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faXMtYXJyYXkuanMiLCIvLyAyMC4xLjIuMyBOdW1iZXIuaXNJbnRlZ2VyKG51bWJlcilcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIGZsb29yID0gTWF0aC5mbG9vcjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNJbnRlZ2VyKGl0KSB7XG4gIHJldHVybiAhaXNPYmplY3QoaXQpICYmIGlzRmluaXRlKGl0KSAmJiBmbG9vcihpdCkgPT09IGl0O1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2lzLWludGVnZXIuanMiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gdHlwZW9mIGl0ID09PSAnb2JqZWN0JyA/IGl0ICE9PSBudWxsIDogdHlwZW9mIGl0ID09PSAnZnVuY3Rpb24nO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2lzLW9iamVjdC5qcyIsIi8vIDcuMi44IElzUmVnRXhwKGFyZ3VtZW50KVxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgY29mID0gcmVxdWlyZSgnLi9fY29mJyk7XG52YXIgTUFUQ0ggPSByZXF1aXJlKCcuL193a3MnKSgnbWF0Y2gnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHZhciBpc1JlZ0V4cDtcbiAgcmV0dXJuIGlzT2JqZWN0KGl0KSAmJiAoKGlzUmVnRXhwID0gaXRbTUFUQ0hdKSAhPT0gdW5kZWZpbmVkID8gISFpc1JlZ0V4cCA6IGNvZihpdCkgPT0gJ1JlZ0V4cCcpO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2lzLXJlZ2V4cC5qcyIsIi8vIGNhbGwgc29tZXRoaW5nIG9uIGl0ZXJhdG9yIHN0ZXAgd2l0aCBzYWZlIGNsb3Npbmcgb24gZXJyb3JcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXRlcmF0b3IsIGZuLCB2YWx1ZSwgZW50cmllcykge1xuICB0cnkge1xuICAgIHJldHVybiBlbnRyaWVzID8gZm4oYW5PYmplY3QodmFsdWUpWzBdLCB2YWx1ZVsxXSkgOiBmbih2YWx1ZSk7XG4gIC8vIDcuNC42IEl0ZXJhdG9yQ2xvc2UoaXRlcmF0b3IsIGNvbXBsZXRpb24pXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB2YXIgcmV0ID0gaXRlcmF0b3JbJ3JldHVybiddO1xuICAgIGlmIChyZXQgIT09IHVuZGVmaW5lZCkgYW5PYmplY3QocmV0LmNhbGwoaXRlcmF0b3IpKTtcbiAgICB0aHJvdyBlO1xuICB9XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faXRlci1jYWxsLmpzIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGNyZWF0ZSA9IHJlcXVpcmUoJy4vX29iamVjdC1jcmVhdGUnKTtcbnZhciBkZXNjcmlwdG9yID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpO1xudmFyIHNldFRvU3RyaW5nVGFnID0gcmVxdWlyZSgnLi9fc2V0LXRvLXN0cmluZy10YWcnKTtcbnZhciBJdGVyYXRvclByb3RvdHlwZSA9IHt9O1xuXG4vLyAyNS4xLjIuMS4xICVJdGVyYXRvclByb3RvdHlwZSVbQEBpdGVyYXRvcl0oKVxucmVxdWlyZSgnLi9faGlkZScpKEl0ZXJhdG9yUHJvdG90eXBlLCByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBOQU1FLCBuZXh0KSB7XG4gIENvbnN0cnVjdG9yLnByb3RvdHlwZSA9IGNyZWF0ZShJdGVyYXRvclByb3RvdHlwZSwgeyBuZXh0OiBkZXNjcmlwdG9yKDEsIG5leHQpIH0pO1xuICBzZXRUb1N0cmluZ1RhZyhDb25zdHJ1Y3RvciwgTkFNRSArICcgSXRlcmF0b3InKTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pdGVyLWNyZWF0ZS5qcyIsIid1c2Ugc3RyaWN0JztcbnZhciBMSUJSQVJZID0gcmVxdWlyZSgnLi9fbGlicmFyeScpO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciByZWRlZmluZSA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lJyk7XG52YXIgaGlkZSA9IHJlcXVpcmUoJy4vX2hpZGUnKTtcbnZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciBJdGVyYXRvcnMgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKTtcbnZhciAkaXRlckNyZWF0ZSA9IHJlcXVpcmUoJy4vX2l0ZXItY3JlYXRlJyk7XG52YXIgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpO1xudmFyIGdldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpO1xudmFyIElURVJBVE9SID0gcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJyk7XG52YXIgQlVHR1kgPSAhKFtdLmtleXMgJiYgJ25leHQnIGluIFtdLmtleXMoKSk7IC8vIFNhZmFyaSBoYXMgYnVnZ3kgaXRlcmF0b3JzIHcvbyBgbmV4dGBcbnZhciBGRl9JVEVSQVRPUiA9ICdAQGl0ZXJhdG9yJztcbnZhciBLRVlTID0gJ2tleXMnO1xudmFyIFZBTFVFUyA9ICd2YWx1ZXMnO1xuXG52YXIgcmV0dXJuVGhpcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKEJhc2UsIE5BTUUsIENvbnN0cnVjdG9yLCBuZXh0LCBERUZBVUxULCBJU19TRVQsIEZPUkNFRCkge1xuICAkaXRlckNyZWF0ZShDb25zdHJ1Y3RvciwgTkFNRSwgbmV4dCk7XG4gIHZhciBnZXRNZXRob2QgPSBmdW5jdGlvbiAoa2luZCkge1xuICAgIGlmICghQlVHR1kgJiYga2luZCBpbiBwcm90bykgcmV0dXJuIHByb3RvW2tpbmRdO1xuICAgIHN3aXRjaCAoa2luZCkge1xuICAgICAgY2FzZSBLRVlTOiByZXR1cm4gZnVuY3Rpb24ga2V5cygpIHsgcmV0dXJuIG5ldyBDb25zdHJ1Y3Rvcih0aGlzLCBraW5kKTsgfTtcbiAgICAgIGNhc2UgVkFMVUVTOiByZXR1cm4gZnVuY3Rpb24gdmFsdWVzKCkgeyByZXR1cm4gbmV3IENvbnN0cnVjdG9yKHRoaXMsIGtpbmQpOyB9O1xuICAgIH0gcmV0dXJuIGZ1bmN0aW9uIGVudHJpZXMoKSB7IHJldHVybiBuZXcgQ29uc3RydWN0b3IodGhpcywga2luZCk7IH07XG4gIH07XG4gIHZhciBUQUcgPSBOQU1FICsgJyBJdGVyYXRvcic7XG4gIHZhciBERUZfVkFMVUVTID0gREVGQVVMVCA9PSBWQUxVRVM7XG4gIHZhciBWQUxVRVNfQlVHID0gZmFsc2U7XG4gIHZhciBwcm90byA9IEJhc2UucHJvdG90eXBlO1xuICB2YXIgJG5hdGl2ZSA9IHByb3RvW0lURVJBVE9SXSB8fCBwcm90b1tGRl9JVEVSQVRPUl0gfHwgREVGQVVMVCAmJiBwcm90b1tERUZBVUxUXTtcbiAgdmFyICRkZWZhdWx0ID0gJG5hdGl2ZSB8fCBnZXRNZXRob2QoREVGQVVMVCk7XG4gIHZhciAkZW50cmllcyA9IERFRkFVTFQgPyAhREVGX1ZBTFVFUyA/ICRkZWZhdWx0IDogZ2V0TWV0aG9kKCdlbnRyaWVzJykgOiB1bmRlZmluZWQ7XG4gIHZhciAkYW55TmF0aXZlID0gTkFNRSA9PSAnQXJyYXknID8gcHJvdG8uZW50cmllcyB8fCAkbmF0aXZlIDogJG5hdGl2ZTtcbiAgdmFyIG1ldGhvZHMsIGtleSwgSXRlcmF0b3JQcm90b3R5cGU7XG4gIC8vIEZpeCBuYXRpdmVcbiAgaWYgKCRhbnlOYXRpdmUpIHtcbiAgICBJdGVyYXRvclByb3RvdHlwZSA9IGdldFByb3RvdHlwZU9mKCRhbnlOYXRpdmUuY2FsbChuZXcgQmFzZSgpKSk7XG4gICAgaWYgKEl0ZXJhdG9yUHJvdG90eXBlICE9PSBPYmplY3QucHJvdG90eXBlICYmIEl0ZXJhdG9yUHJvdG90eXBlLm5leHQpIHtcbiAgICAgIC8vIFNldCBAQHRvU3RyaW5nVGFnIHRvIG5hdGl2ZSBpdGVyYXRvcnNcbiAgICAgIHNldFRvU3RyaW5nVGFnKEl0ZXJhdG9yUHJvdG90eXBlLCBUQUcsIHRydWUpO1xuICAgICAgLy8gZml4IGZvciBzb21lIG9sZCBlbmdpbmVzXG4gICAgICBpZiAoIUxJQlJBUlkgJiYgIWhhcyhJdGVyYXRvclByb3RvdHlwZSwgSVRFUkFUT1IpKSBoaWRlKEl0ZXJhdG9yUHJvdG90eXBlLCBJVEVSQVRPUiwgcmV0dXJuVGhpcyk7XG4gICAgfVxuICB9XG4gIC8vIGZpeCBBcnJheSN7dmFsdWVzLCBAQGl0ZXJhdG9yfS5uYW1lIGluIFY4IC8gRkZcbiAgaWYgKERFRl9WQUxVRVMgJiYgJG5hdGl2ZSAmJiAkbmF0aXZlLm5hbWUgIT09IFZBTFVFUykge1xuICAgIFZBTFVFU19CVUcgPSB0cnVlO1xuICAgICRkZWZhdWx0ID0gZnVuY3Rpb24gdmFsdWVzKCkgeyByZXR1cm4gJG5hdGl2ZS5jYWxsKHRoaXMpOyB9O1xuICB9XG4gIC8vIERlZmluZSBpdGVyYXRvclxuICBpZiAoKCFMSUJSQVJZIHx8IEZPUkNFRCkgJiYgKEJVR0dZIHx8IFZBTFVFU19CVUcgfHwgIXByb3RvW0lURVJBVE9SXSkpIHtcbiAgICBoaWRlKHByb3RvLCBJVEVSQVRPUiwgJGRlZmF1bHQpO1xuICB9XG4gIC8vIFBsdWcgZm9yIGxpYnJhcnlcbiAgSXRlcmF0b3JzW05BTUVdID0gJGRlZmF1bHQ7XG4gIEl0ZXJhdG9yc1tUQUddID0gcmV0dXJuVGhpcztcbiAgaWYgKERFRkFVTFQpIHtcbiAgICBtZXRob2RzID0ge1xuICAgICAgdmFsdWVzOiBERUZfVkFMVUVTID8gJGRlZmF1bHQgOiBnZXRNZXRob2QoVkFMVUVTKSxcbiAgICAgIGtleXM6IElTX1NFVCA/ICRkZWZhdWx0IDogZ2V0TWV0aG9kKEtFWVMpLFxuICAgICAgZW50cmllczogJGVudHJpZXNcbiAgICB9O1xuICAgIGlmIChGT1JDRUQpIGZvciAoa2V5IGluIG1ldGhvZHMpIHtcbiAgICAgIGlmICghKGtleSBpbiBwcm90bykpIHJlZGVmaW5lKHByb3RvLCBrZXksIG1ldGhvZHNba2V5XSk7XG4gICAgfSBlbHNlICRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogKEJVR0dZIHx8IFZBTFVFU19CVUcpLCBOQU1FLCBtZXRob2RzKTtcbiAgfVxuICByZXR1cm4gbWV0aG9kcztcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pdGVyLWRlZmluZS5qcyIsInZhciBJVEVSQVRPUiA9IHJlcXVpcmUoJy4vX3drcycpKCdpdGVyYXRvcicpO1xudmFyIFNBRkVfQ0xPU0lORyA9IGZhbHNlO1xuXG50cnkge1xuICB2YXIgcml0ZXIgPSBbN11bSVRFUkFUT1JdKCk7XG4gIHJpdGVyWydyZXR1cm4nXSA9IGZ1bmN0aW9uICgpIHsgU0FGRV9DTE9TSU5HID0gdHJ1ZTsgfTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXRocm93LWxpdGVyYWxcbiAgQXJyYXkuZnJvbShyaXRlciwgZnVuY3Rpb24gKCkgeyB0aHJvdyAyOyB9KTtcbn0gY2F0Y2ggKGUpIHsgLyogZW1wdHkgKi8gfVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChleGVjLCBza2lwQ2xvc2luZykge1xuICBpZiAoIXNraXBDbG9zaW5nICYmICFTQUZFX0NMT1NJTkcpIHJldHVybiBmYWxzZTtcbiAgdmFyIHNhZmUgPSBmYWxzZTtcbiAgdHJ5IHtcbiAgICB2YXIgYXJyID0gWzddO1xuICAgIHZhciBpdGVyID0gYXJyW0lURVJBVE9SXSgpO1xuICAgIGl0ZXIubmV4dCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHsgZG9uZTogc2FmZSA9IHRydWUgfTsgfTtcbiAgICBhcnJbSVRFUkFUT1JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gaXRlcjsgfTtcbiAgICBleGVjKGFycik7XG4gIH0gY2F0Y2ggKGUpIHsgLyogZW1wdHkgKi8gfVxuICByZXR1cm4gc2FmZTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pdGVyLWRldGVjdC5qcyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGRvbmUsIHZhbHVlKSB7XG4gIHJldHVybiB7IHZhbHVlOiB2YWx1ZSwgZG9uZTogISFkb25lIH07XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faXRlci1zdGVwLmpzIiwibW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2l0ZXJhdG9ycy5qcyIsIm1vZHVsZS5leHBvcnRzID0gZmFsc2U7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19saWJyYXJ5LmpzIiwiLy8gMjAuMi4yLjE0IE1hdGguZXhwbTEoeClcbnZhciAkZXhwbTEgPSBNYXRoLmV4cG0xO1xubW9kdWxlLmV4cG9ydHMgPSAoISRleHBtMVxuICAvLyBPbGQgRkYgYnVnXG4gIHx8ICRleHBtMSgxMCkgPiAyMjAyNS40NjU3OTQ4MDY3MTkgfHwgJGV4cG0xKDEwKSA8IDIyMDI1LjQ2NTc5NDgwNjcxNjUxNjhcbiAgLy8gVG9yIEJyb3dzZXIgYnVnXG4gIHx8ICRleHBtMSgtMmUtMTcpICE9IC0yZS0xN1xuKSA/IGZ1bmN0aW9uIGV4cG0xKHgpIHtcbiAgcmV0dXJuICh4ID0gK3gpID09IDAgPyB4IDogeCA+IC0xZS02ICYmIHggPCAxZS02ID8geCArIHggKiB4IC8gMiA6IE1hdGguZXhwKHgpIC0gMTtcbn0gOiAkZXhwbTE7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19tYXRoLWV4cG0xLmpzIiwiLy8gMjAuMi4yLjE2IE1hdGguZnJvdW5kKHgpXG52YXIgc2lnbiA9IHJlcXVpcmUoJy4vX21hdGgtc2lnbicpO1xudmFyIHBvdyA9IE1hdGgucG93O1xudmFyIEVQU0lMT04gPSBwb3coMiwgLTUyKTtcbnZhciBFUFNJTE9OMzIgPSBwb3coMiwgLTIzKTtcbnZhciBNQVgzMiA9IHBvdygyLCAxMjcpICogKDIgLSBFUFNJTE9OMzIpO1xudmFyIE1JTjMyID0gcG93KDIsIC0xMjYpO1xuXG52YXIgcm91bmRUaWVzVG9FdmVuID0gZnVuY3Rpb24gKG4pIHtcbiAgcmV0dXJuIG4gKyAxIC8gRVBTSUxPTiAtIDEgLyBFUFNJTE9OO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBNYXRoLmZyb3VuZCB8fCBmdW5jdGlvbiBmcm91bmQoeCkge1xuICB2YXIgJGFicyA9IE1hdGguYWJzKHgpO1xuICB2YXIgJHNpZ24gPSBzaWduKHgpO1xuICB2YXIgYSwgcmVzdWx0O1xuICBpZiAoJGFicyA8IE1JTjMyKSByZXR1cm4gJHNpZ24gKiByb3VuZFRpZXNUb0V2ZW4oJGFicyAvIE1JTjMyIC8gRVBTSUxPTjMyKSAqIE1JTjMyICogRVBTSUxPTjMyO1xuICBhID0gKDEgKyBFUFNJTE9OMzIgLyBFUFNJTE9OKSAqICRhYnM7XG4gIHJlc3VsdCA9IGEgLSAoYSAtICRhYnMpO1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gIGlmIChyZXN1bHQgPiBNQVgzMiB8fCByZXN1bHQgIT0gcmVzdWx0KSByZXR1cm4gJHNpZ24gKiBJbmZpbml0eTtcbiAgcmV0dXJuICRzaWduICogcmVzdWx0O1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX21hdGgtZnJvdW5kLmpzIiwiLy8gMjAuMi4yLjIwIE1hdGgubG9nMXAoeClcbm1vZHVsZS5leHBvcnRzID0gTWF0aC5sb2cxcCB8fCBmdW5jdGlvbiBsb2cxcCh4KSB7XG4gIHJldHVybiAoeCA9ICt4KSA+IC0xZS04ICYmIHggPCAxZS04ID8geCAtIHggKiB4IC8gMiA6IE1hdGgubG9nKDEgKyB4KTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19tYXRoLWxvZzFwLmpzIiwiLy8gaHR0cHM6Ly9yd2FsZHJvbi5naXRodWIuaW8vcHJvcG9zYWwtbWF0aC1leHRlbnNpb25zL1xubW9kdWxlLmV4cG9ydHMgPSBNYXRoLnNjYWxlIHx8IGZ1bmN0aW9uIHNjYWxlKHgsIGluTG93LCBpbkhpZ2gsIG91dExvdywgb3V0SGlnaCkge1xuICBpZiAoXG4gICAgYXJndW1lbnRzLmxlbmd0aCA9PT0gMFxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuICAgICAgfHwgeCAhPSB4XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gICAgICB8fCBpbkxvdyAhPSBpbkxvd1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuICAgICAgfHwgaW5IaWdoICE9IGluSGlnaFxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuICAgICAgfHwgb3V0TG93ICE9IG91dExvd1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuICAgICAgfHwgb3V0SGlnaCAhPSBvdXRIaWdoXG4gICkgcmV0dXJuIE5hTjtcbiAgaWYgKHggPT09IEluZmluaXR5IHx8IHggPT09IC1JbmZpbml0eSkgcmV0dXJuIHg7XG4gIHJldHVybiAoeCAtIGluTG93KSAqIChvdXRIaWdoIC0gb3V0TG93KSAvIChpbkhpZ2ggLSBpbkxvdykgKyBvdXRMb3c7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fbWF0aC1zY2FsZS5qcyIsIi8vIDIwLjIuMi4yOCBNYXRoLnNpZ24oeClcbm1vZHVsZS5leHBvcnRzID0gTWF0aC5zaWduIHx8IGZ1bmN0aW9uIHNpZ24oeCkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gIHJldHVybiAoeCA9ICt4KSA9PSAwIHx8IHggIT0geCA/IHggOiB4IDwgMCA/IC0xIDogMTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19tYXRoLXNpZ24uanMiLCJ2YXIgTUVUQSA9IHJlcXVpcmUoJy4vX3VpZCcpKCdtZXRhJyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciBzZXREZXNjID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZjtcbnZhciBpZCA9IDA7XG52YXIgaXNFeHRlbnNpYmxlID0gT2JqZWN0LmlzRXh0ZW5zaWJsZSB8fCBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0cnVlO1xufTtcbnZhciBGUkVFWkUgPSAhcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBpc0V4dGVuc2libGUoT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zKHt9KSk7XG59KTtcbnZhciBzZXRNZXRhID0gZnVuY3Rpb24gKGl0KSB7XG4gIHNldERlc2MoaXQsIE1FVEEsIHsgdmFsdWU6IHtcbiAgICBpOiAnTycgKyArK2lkLCAvLyBvYmplY3QgSURcbiAgICB3OiB7fSAgICAgICAgICAvLyB3ZWFrIGNvbGxlY3Rpb25zIElEc1xuICB9IH0pO1xufTtcbnZhciBmYXN0S2V5ID0gZnVuY3Rpb24gKGl0LCBjcmVhdGUpIHtcbiAgLy8gcmV0dXJuIHByaW1pdGl2ZSB3aXRoIHByZWZpeFxuICBpZiAoIWlzT2JqZWN0KGl0KSkgcmV0dXJuIHR5cGVvZiBpdCA9PSAnc3ltYm9sJyA/IGl0IDogKHR5cGVvZiBpdCA9PSAnc3RyaW5nJyA/ICdTJyA6ICdQJykgKyBpdDtcbiAgaWYgKCFoYXMoaXQsIE1FVEEpKSB7XG4gICAgLy8gY2FuJ3Qgc2V0IG1ldGFkYXRhIHRvIHVuY2F1Z2h0IGZyb3plbiBvYmplY3RcbiAgICBpZiAoIWlzRXh0ZW5zaWJsZShpdCkpIHJldHVybiAnRic7XG4gICAgLy8gbm90IG5lY2Vzc2FyeSB0byBhZGQgbWV0YWRhdGFcbiAgICBpZiAoIWNyZWF0ZSkgcmV0dXJuICdFJztcbiAgICAvLyBhZGQgbWlzc2luZyBtZXRhZGF0YVxuICAgIHNldE1ldGEoaXQpO1xuICAvLyByZXR1cm4gb2JqZWN0IElEXG4gIH0gcmV0dXJuIGl0W01FVEFdLmk7XG59O1xudmFyIGdldFdlYWsgPSBmdW5jdGlvbiAoaXQsIGNyZWF0ZSkge1xuICBpZiAoIWhhcyhpdCwgTUVUQSkpIHtcbiAgICAvLyBjYW4ndCBzZXQgbWV0YWRhdGEgdG8gdW5jYXVnaHQgZnJvemVuIG9iamVjdFxuICAgIGlmICghaXNFeHRlbnNpYmxlKGl0KSkgcmV0dXJuIHRydWU7XG4gICAgLy8gbm90IG5lY2Vzc2FyeSB0byBhZGQgbWV0YWRhdGFcbiAgICBpZiAoIWNyZWF0ZSkgcmV0dXJuIGZhbHNlO1xuICAgIC8vIGFkZCBtaXNzaW5nIG1ldGFkYXRhXG4gICAgc2V0TWV0YShpdCk7XG4gIC8vIHJldHVybiBoYXNoIHdlYWsgY29sbGVjdGlvbnMgSURzXG4gIH0gcmV0dXJuIGl0W01FVEFdLnc7XG59O1xuLy8gYWRkIG1ldGFkYXRhIG9uIGZyZWV6ZS1mYW1pbHkgbWV0aG9kcyBjYWxsaW5nXG52YXIgb25GcmVlemUgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKEZSRUVaRSAmJiBtZXRhLk5FRUQgJiYgaXNFeHRlbnNpYmxlKGl0KSAmJiAhaGFzKGl0LCBNRVRBKSkgc2V0TWV0YShpdCk7XG4gIHJldHVybiBpdDtcbn07XG52YXIgbWV0YSA9IG1vZHVsZS5leHBvcnRzID0ge1xuICBLRVk6IE1FVEEsXG4gIE5FRUQ6IGZhbHNlLFxuICBmYXN0S2V5OiBmYXN0S2V5LFxuICBnZXRXZWFrOiBnZXRXZWFrLFxuICBvbkZyZWV6ZTogb25GcmVlemVcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19tZXRhLmpzIiwidmFyIE1hcCA9IHJlcXVpcmUoJy4vZXM2Lm1hcCcpO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBzaGFyZWQgPSByZXF1aXJlKCcuL19zaGFyZWQnKSgnbWV0YWRhdGEnKTtcbnZhciBzdG9yZSA9IHNoYXJlZC5zdG9yZSB8fCAoc2hhcmVkLnN0b3JlID0gbmV3IChyZXF1aXJlKCcuL2VzNi53ZWFrLW1hcCcpKSgpKTtcblxudmFyIGdldE9yQ3JlYXRlTWV0YWRhdGFNYXAgPSBmdW5jdGlvbiAodGFyZ2V0LCB0YXJnZXRLZXksIGNyZWF0ZSkge1xuICB2YXIgdGFyZ2V0TWV0YWRhdGEgPSBzdG9yZS5nZXQodGFyZ2V0KTtcbiAgaWYgKCF0YXJnZXRNZXRhZGF0YSkge1xuICAgIGlmICghY3JlYXRlKSByZXR1cm4gdW5kZWZpbmVkO1xuICAgIHN0b3JlLnNldCh0YXJnZXQsIHRhcmdldE1ldGFkYXRhID0gbmV3IE1hcCgpKTtcbiAgfVxuICB2YXIga2V5TWV0YWRhdGEgPSB0YXJnZXRNZXRhZGF0YS5nZXQodGFyZ2V0S2V5KTtcbiAgaWYgKCFrZXlNZXRhZGF0YSkge1xuICAgIGlmICghY3JlYXRlKSByZXR1cm4gdW5kZWZpbmVkO1xuICAgIHRhcmdldE1ldGFkYXRhLnNldCh0YXJnZXRLZXksIGtleU1ldGFkYXRhID0gbmV3IE1hcCgpKTtcbiAgfSByZXR1cm4ga2V5TWV0YWRhdGE7XG59O1xudmFyIG9yZGluYXJ5SGFzT3duTWV0YWRhdGEgPSBmdW5jdGlvbiAoTWV0YWRhdGFLZXksIE8sIFApIHtcbiAgdmFyIG1ldGFkYXRhTWFwID0gZ2V0T3JDcmVhdGVNZXRhZGF0YU1hcChPLCBQLCBmYWxzZSk7XG4gIHJldHVybiBtZXRhZGF0YU1hcCA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBtZXRhZGF0YU1hcC5oYXMoTWV0YWRhdGFLZXkpO1xufTtcbnZhciBvcmRpbmFyeUdldE93bk1ldGFkYXRhID0gZnVuY3Rpb24gKE1ldGFkYXRhS2V5LCBPLCBQKSB7XG4gIHZhciBtZXRhZGF0YU1hcCA9IGdldE9yQ3JlYXRlTWV0YWRhdGFNYXAoTywgUCwgZmFsc2UpO1xuICByZXR1cm4gbWV0YWRhdGFNYXAgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IG1ldGFkYXRhTWFwLmdldChNZXRhZGF0YUtleSk7XG59O1xudmFyIG9yZGluYXJ5RGVmaW5lT3duTWV0YWRhdGEgPSBmdW5jdGlvbiAoTWV0YWRhdGFLZXksIE1ldGFkYXRhVmFsdWUsIE8sIFApIHtcbiAgZ2V0T3JDcmVhdGVNZXRhZGF0YU1hcChPLCBQLCB0cnVlKS5zZXQoTWV0YWRhdGFLZXksIE1ldGFkYXRhVmFsdWUpO1xufTtcbnZhciBvcmRpbmFyeU93bk1ldGFkYXRhS2V5cyA9IGZ1bmN0aW9uICh0YXJnZXQsIHRhcmdldEtleSkge1xuICB2YXIgbWV0YWRhdGFNYXAgPSBnZXRPckNyZWF0ZU1ldGFkYXRhTWFwKHRhcmdldCwgdGFyZ2V0S2V5LCBmYWxzZSk7XG4gIHZhciBrZXlzID0gW107XG4gIGlmIChtZXRhZGF0YU1hcCkgbWV0YWRhdGFNYXAuZm9yRWFjaChmdW5jdGlvbiAoXywga2V5KSB7IGtleXMucHVzaChrZXkpOyB9KTtcbiAgcmV0dXJuIGtleXM7XG59O1xudmFyIHRvTWV0YUtleSA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXQgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgaXQgPT0gJ3N5bWJvbCcgPyBpdCA6IFN0cmluZyhpdCk7XG59O1xudmFyIGV4cCA9IGZ1bmN0aW9uIChPKSB7XG4gICRleHBvcnQoJGV4cG9ydC5TLCAnUmVmbGVjdCcsIE8pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHN0b3JlOiBzdG9yZSxcbiAgbWFwOiBnZXRPckNyZWF0ZU1ldGFkYXRhTWFwLFxuICBoYXM6IG9yZGluYXJ5SGFzT3duTWV0YWRhdGEsXG4gIGdldDogb3JkaW5hcnlHZXRPd25NZXRhZGF0YSxcbiAgc2V0OiBvcmRpbmFyeURlZmluZU93bk1ldGFkYXRhLFxuICBrZXlzOiBvcmRpbmFyeU93bk1ldGFkYXRhS2V5cyxcbiAga2V5OiB0b01ldGFLZXksXG4gIGV4cDogZXhwXG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fbWV0YWRhdGEuanMiLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgbWFjcm90YXNrID0gcmVxdWlyZSgnLi9fdGFzaycpLnNldDtcbnZhciBPYnNlcnZlciA9IGdsb2JhbC5NdXRhdGlvbk9ic2VydmVyIHx8IGdsb2JhbC5XZWJLaXRNdXRhdGlvbk9ic2VydmVyO1xudmFyIHByb2Nlc3MgPSBnbG9iYWwucHJvY2VzcztcbnZhciBQcm9taXNlID0gZ2xvYmFsLlByb21pc2U7XG52YXIgaXNOb2RlID0gcmVxdWlyZSgnLi9fY29mJykocHJvY2VzcykgPT0gJ3Byb2Nlc3MnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGhlYWQsIGxhc3QsIG5vdGlmeTtcblxuICB2YXIgZmx1c2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHBhcmVudCwgZm47XG4gICAgaWYgKGlzTm9kZSAmJiAocGFyZW50ID0gcHJvY2Vzcy5kb21haW4pKSBwYXJlbnQuZXhpdCgpO1xuICAgIHdoaWxlIChoZWFkKSB7XG4gICAgICBmbiA9IGhlYWQuZm47XG4gICAgICBoZWFkID0gaGVhZC5uZXh0O1xuICAgICAgdHJ5IHtcbiAgICAgICAgZm4oKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKGhlYWQpIG5vdGlmeSgpO1xuICAgICAgICBlbHNlIGxhc3QgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgfSBsYXN0ID0gdW5kZWZpbmVkO1xuICAgIGlmIChwYXJlbnQpIHBhcmVudC5lbnRlcigpO1xuICB9O1xuXG4gIC8vIE5vZGUuanNcbiAgaWYgKGlzTm9kZSkge1xuICAgIG5vdGlmeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soZmx1c2gpO1xuICAgIH07XG4gIC8vIGJyb3dzZXJzIHdpdGggTXV0YXRpb25PYnNlcnZlclxuICB9IGVsc2UgaWYgKE9ic2VydmVyKSB7XG4gICAgdmFyIHRvZ2dsZSA9IHRydWU7XG4gICAgdmFyIG5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyk7XG4gICAgbmV3IE9ic2VydmVyKGZsdXNoKS5vYnNlcnZlKG5vZGUsIHsgY2hhcmFjdGVyRGF0YTogdHJ1ZSB9KTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXdcbiAgICBub3RpZnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBub2RlLmRhdGEgPSB0b2dnbGUgPSAhdG9nZ2xlO1xuICAgIH07XG4gIC8vIGVudmlyb25tZW50cyB3aXRoIG1heWJlIG5vbi1jb21wbGV0ZWx5IGNvcnJlY3QsIGJ1dCBleGlzdGVudCBQcm9taXNlXG4gIH0gZWxzZSBpZiAoUHJvbWlzZSAmJiBQcm9taXNlLnJlc29sdmUpIHtcbiAgICB2YXIgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSgpO1xuICAgIG5vdGlmeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHByb21pc2UudGhlbihmbHVzaCk7XG4gICAgfTtcbiAgLy8gZm9yIG90aGVyIGVudmlyb25tZW50cyAtIG1hY3JvdGFzayBiYXNlZCBvbjpcbiAgLy8gLSBzZXRJbW1lZGlhdGVcbiAgLy8gLSBNZXNzYWdlQ2hhbm5lbFxuICAvLyAtIHdpbmRvdy5wb3N0TWVzc2FnXG4gIC8vIC0gb25yZWFkeXN0YXRlY2hhbmdlXG4gIC8vIC0gc2V0VGltZW91dFxuICB9IGVsc2Uge1xuICAgIG5vdGlmeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIHN0cmFuZ2UgSUUgKyB3ZWJwYWNrIGRldiBzZXJ2ZXIgYnVnIC0gdXNlIC5jYWxsKGdsb2JhbClcbiAgICAgIG1hY3JvdGFzay5jYWxsKGdsb2JhbCwgZmx1c2gpO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKGZuKSB7XG4gICAgdmFyIHRhc2sgPSB7IGZuOiBmbiwgbmV4dDogdW5kZWZpbmVkIH07XG4gICAgaWYgKGxhc3QpIGxhc3QubmV4dCA9IHRhc2s7XG4gICAgaWYgKCFoZWFkKSB7XG4gICAgICBoZWFkID0gdGFzaztcbiAgICAgIG5vdGlmeSgpO1xuICAgIH0gbGFzdCA9IHRhc2s7XG4gIH07XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fbWljcm90YXNrLmpzIiwiJ3VzZSBzdHJpY3QnO1xuLy8gMjUuNC4xLjUgTmV3UHJvbWlzZUNhcGFiaWxpdHkoQylcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG5cbmZ1bmN0aW9uIFByb21pc2VDYXBhYmlsaXR5KEMpIHtcbiAgdmFyIHJlc29sdmUsIHJlamVjdDtcbiAgdGhpcy5wcm9taXNlID0gbmV3IEMoZnVuY3Rpb24gKCQkcmVzb2x2ZSwgJCRyZWplY3QpIHtcbiAgICBpZiAocmVzb2x2ZSAhPT0gdW5kZWZpbmVkIHx8IHJlamVjdCAhPT0gdW5kZWZpbmVkKSB0aHJvdyBUeXBlRXJyb3IoJ0JhZCBQcm9taXNlIGNvbnN0cnVjdG9yJyk7XG4gICAgcmVzb2x2ZSA9ICQkcmVzb2x2ZTtcbiAgICByZWplY3QgPSAkJHJlamVjdDtcbiAgfSk7XG4gIHRoaXMucmVzb2x2ZSA9IGFGdW5jdGlvbihyZXNvbHZlKTtcbiAgdGhpcy5yZWplY3QgPSBhRnVuY3Rpb24ocmVqZWN0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMuZiA9IGZ1bmN0aW9uIChDKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZUNhcGFiaWxpdHkoQyk7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fbmV3LXByb21pc2UtY2FwYWJpbGl0eS5qcyIsIid1c2Ugc3RyaWN0Jztcbi8vIDE5LjEuMi4xIE9iamVjdC5hc3NpZ24odGFyZ2V0LCBzb3VyY2UsIC4uLilcbnZhciBnZXRLZXlzID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKTtcbnZhciBnT1BTID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcHMnKTtcbnZhciBwSUUgPSByZXF1aXJlKCcuL19vYmplY3QtcGllJyk7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcbnZhciBJT2JqZWN0ID0gcmVxdWlyZSgnLi9faW9iamVjdCcpO1xudmFyICRhc3NpZ24gPSBPYmplY3QuYXNzaWduO1xuXG4vLyBzaG91bGQgd29yayB3aXRoIHN5bWJvbHMgYW5kIHNob3VsZCBoYXZlIGRldGVybWluaXN0aWMgcHJvcGVydHkgb3JkZXIgKFY4IGJ1Zylcbm1vZHVsZS5leHBvcnRzID0gISRhc3NpZ24gfHwgcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbiAoKSB7XG4gIHZhciBBID0ge307XG4gIHZhciBCID0ge307XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuICB2YXIgUyA9IFN5bWJvbCgpO1xuICB2YXIgSyA9ICdhYmNkZWZnaGlqa2xtbm9wcXJzdCc7XG4gIEFbU10gPSA3O1xuICBLLnNwbGl0KCcnKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7IEJba10gPSBrOyB9KTtcbiAgcmV0dXJuICRhc3NpZ24oe30sIEEpW1NdICE9IDcgfHwgT2JqZWN0LmtleXMoJGFzc2lnbih7fSwgQikpLmpvaW4oJycpICE9IEs7XG59KSA/IGZ1bmN0aW9uIGFzc2lnbih0YXJnZXQsIHNvdXJjZSkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gIHZhciBUID0gdG9PYmplY3QodGFyZ2V0KTtcbiAgdmFyIGFMZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICB2YXIgaW5kZXggPSAxO1xuICB2YXIgZ2V0U3ltYm9scyA9IGdPUFMuZjtcbiAgdmFyIGlzRW51bSA9IHBJRS5mO1xuICB3aGlsZSAoYUxlbiA+IGluZGV4KSB7XG4gICAgdmFyIFMgPSBJT2JqZWN0KGFyZ3VtZW50c1tpbmRleCsrXSk7XG4gICAgdmFyIGtleXMgPSBnZXRTeW1ib2xzID8gZ2V0S2V5cyhTKS5jb25jYXQoZ2V0U3ltYm9scyhTKSkgOiBnZXRLZXlzKFMpO1xuICAgIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICB2YXIgaiA9IDA7XG4gICAgdmFyIGtleTtcbiAgICB3aGlsZSAobGVuZ3RoID4gaikgaWYgKGlzRW51bS5jYWxsKFMsIGtleSA9IGtleXNbaisrXSkpIFRba2V5XSA9IFNba2V5XTtcbiAgfSByZXR1cm4gVDtcbn0gOiAkYXNzaWduO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWFzc2lnbi5qcyIsIi8vIDE5LjEuMi4yIC8gMTUuMi4zLjUgT2JqZWN0LmNyZWF0ZShPIFssIFByb3BlcnRpZXNdKVxudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgZFBzID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwcycpO1xudmFyIGVudW1CdWdLZXlzID0gcmVxdWlyZSgnLi9fZW51bS1idWcta2V5cycpO1xudmFyIElFX1BST1RPID0gcmVxdWlyZSgnLi9fc2hhcmVkLWtleScpKCdJRV9QUk9UTycpO1xudmFyIEVtcHR5ID0gZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9O1xudmFyIFBST1RPVFlQRSA9ICdwcm90b3R5cGUnO1xuXG4vLyBDcmVhdGUgb2JqZWN0IHdpdGggZmFrZSBgbnVsbGAgcHJvdG90eXBlOiB1c2UgaWZyYW1lIE9iamVjdCB3aXRoIGNsZWFyZWQgcHJvdG90eXBlXG52YXIgY3JlYXRlRGljdCA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gVGhyYXNoLCB3YXN0ZSBhbmQgc29kb215OiBJRSBHQyBidWdcbiAgdmFyIGlmcmFtZSA9IHJlcXVpcmUoJy4vX2RvbS1jcmVhdGUnKSgnaWZyYW1lJyk7XG4gIHZhciBpID0gZW51bUJ1Z0tleXMubGVuZ3RoO1xuICB2YXIgbHQgPSAnPCc7XG4gIHZhciBndCA9ICc+JztcbiAgdmFyIGlmcmFtZURvY3VtZW50O1xuICBpZnJhbWUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgcmVxdWlyZSgnLi9faHRtbCcpLmFwcGVuZENoaWxkKGlmcmFtZSk7XG4gIGlmcmFtZS5zcmMgPSAnamF2YXNjcmlwdDonOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNjcmlwdC11cmxcbiAgLy8gY3JlYXRlRGljdCA9IGlmcmFtZS5jb250ZW50V2luZG93Lk9iamVjdDtcbiAgLy8gaHRtbC5yZW1vdmVDaGlsZChpZnJhbWUpO1xuICBpZnJhbWVEb2N1bWVudCA9IGlmcmFtZS5jb250ZW50V2luZG93LmRvY3VtZW50O1xuICBpZnJhbWVEb2N1bWVudC5vcGVuKCk7XG4gIGlmcmFtZURvY3VtZW50LndyaXRlKGx0ICsgJ3NjcmlwdCcgKyBndCArICdkb2N1bWVudC5GPU9iamVjdCcgKyBsdCArICcvc2NyaXB0JyArIGd0KTtcbiAgaWZyYW1lRG9jdW1lbnQuY2xvc2UoKTtcbiAgY3JlYXRlRGljdCA9IGlmcmFtZURvY3VtZW50LkY7XG4gIHdoaWxlIChpLS0pIGRlbGV0ZSBjcmVhdGVEaWN0W1BST1RPVFlQRV1bZW51bUJ1Z0tleXNbaV1dO1xuICByZXR1cm4gY3JlYXRlRGljdCgpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QuY3JlYXRlIHx8IGZ1bmN0aW9uIGNyZWF0ZShPLCBQcm9wZXJ0aWVzKSB7XG4gIHZhciByZXN1bHQ7XG4gIGlmIChPICE9PSBudWxsKSB7XG4gICAgRW1wdHlbUFJPVE9UWVBFXSA9IGFuT2JqZWN0KE8pO1xuICAgIHJlc3VsdCA9IG5ldyBFbXB0eSgpO1xuICAgIEVtcHR5W1BST1RPVFlQRV0gPSBudWxsO1xuICAgIC8vIGFkZCBcIl9fcHJvdG9fX1wiIGZvciBPYmplY3QuZ2V0UHJvdG90eXBlT2YgcG9seWZpbGxcbiAgICByZXN1bHRbSUVfUFJPVE9dID0gTztcbiAgfSBlbHNlIHJlc3VsdCA9IGNyZWF0ZURpY3QoKTtcbiAgcmV0dXJuIFByb3BlcnRpZXMgPT09IHVuZGVmaW5lZCA/IHJlc3VsdCA6IGRQcyhyZXN1bHQsIFByb3BlcnRpZXMpO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1jcmVhdGUuanMiLCJ2YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBJRThfRE9NX0RFRklORSA9IHJlcXVpcmUoJy4vX2llOC1kb20tZGVmaW5lJyk7XG52YXIgdG9QcmltaXRpdmUgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKTtcbnZhciBkUCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcblxuZXhwb3J0cy5mID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSA6IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpIHtcbiAgYW5PYmplY3QoTyk7XG4gIFAgPSB0b1ByaW1pdGl2ZShQLCB0cnVlKTtcbiAgYW5PYmplY3QoQXR0cmlidXRlcyk7XG4gIGlmIChJRThfRE9NX0RFRklORSkgdHJ5IHtcbiAgICByZXR1cm4gZFAoTywgUCwgQXR0cmlidXRlcyk7XG4gIH0gY2F0Y2ggKGUpIHsgLyogZW1wdHkgKi8gfVxuICBpZiAoJ2dldCcgaW4gQXR0cmlidXRlcyB8fCAnc2V0JyBpbiBBdHRyaWJ1dGVzKSB0aHJvdyBUeXBlRXJyb3IoJ0FjY2Vzc29ycyBub3Qgc3VwcG9ydGVkIScpO1xuICBpZiAoJ3ZhbHVlJyBpbiBBdHRyaWJ1dGVzKSBPW1BdID0gQXR0cmlidXRlcy52YWx1ZTtcbiAgcmV0dXJuIE87XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWRwLmpzIiwidmFyIGRQID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBnZXRLZXlzID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMgOiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKE8sIFByb3BlcnRpZXMpIHtcbiAgYW5PYmplY3QoTyk7XG4gIHZhciBrZXlzID0gZ2V0S2V5cyhQcm9wZXJ0aWVzKTtcbiAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICB2YXIgaSA9IDA7XG4gIHZhciBQO1xuICB3aGlsZSAobGVuZ3RoID4gaSkgZFAuZihPLCBQID0ga2V5c1tpKytdLCBQcm9wZXJ0aWVzW1BdKTtcbiAgcmV0dXJuIE87XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWRwcy5qcyIsIid1c2Ugc3RyaWN0Jztcbi8vIEZvcmNlZCByZXBsYWNlbWVudCBwcm90b3R5cGUgYWNjZXNzb3JzIG1ldGhvZHNcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fbGlicmFyeScpIHx8ICFyZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uICgpIHtcbiAgdmFyIEsgPSBNYXRoLnJhbmRvbSgpO1xuICAvLyBJbiBGRiB0aHJvd3Mgb25seSBkZWZpbmUgbWV0aG9kc1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWYsIG5vLXVzZWxlc3MtY2FsbFxuICBfX2RlZmluZVNldHRlcl9fLmNhbGwobnVsbCwgSywgZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9KTtcbiAgZGVsZXRlIHJlcXVpcmUoJy4vX2dsb2JhbCcpW0tdO1xufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZm9yY2VkLXBhbS5qcyIsInZhciBwSUUgPSByZXF1aXJlKCcuL19vYmplY3QtcGllJyk7XG52YXIgY3JlYXRlRGVzYyA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKTtcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG52YXIgdG9QcmltaXRpdmUgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKTtcbnZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciBJRThfRE9NX0RFRklORSA9IHJlcXVpcmUoJy4vX2llOC1kb20tZGVmaW5lJyk7XG52YXIgZ09QRCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG5cbmV4cG9ydHMuZiA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBnT1BEIDogZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIFApIHtcbiAgTyA9IHRvSU9iamVjdChPKTtcbiAgUCA9IHRvUHJpbWl0aXZlKFAsIHRydWUpO1xuICBpZiAoSUU4X0RPTV9ERUZJTkUpIHRyeSB7XG4gICAgcmV0dXJuIGdPUEQoTywgUCk7XG4gIH0gY2F0Y2ggKGUpIHsgLyogZW1wdHkgKi8gfVxuICBpZiAoaGFzKE8sIFApKSByZXR1cm4gY3JlYXRlRGVzYyghcElFLmYuY2FsbChPLCBQKSwgT1tQXSk7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWdvcGQuanMiLCIvLyBmYWxsYmFjayBmb3IgSUUxMSBidWdneSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyB3aXRoIGlmcmFtZSBhbmQgd2luZG93XG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xudmFyIGdPUE4gPSByZXF1aXJlKCcuL19vYmplY3QtZ29wbicpLmY7XG52YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcblxudmFyIHdpbmRvd05hbWVzID0gdHlwZW9mIHdpbmRvdyA9PSAnb2JqZWN0JyAmJiB3aW5kb3cgJiYgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXNcbiAgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh3aW5kb3cpIDogW107XG5cbnZhciBnZXRXaW5kb3dOYW1lcyA9IGZ1bmN0aW9uIChpdCkge1xuICB0cnkge1xuICAgIHJldHVybiBnT1BOKGl0KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiB3aW5kb3dOYW1lcy5zbGljZSgpO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5mID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhpdCkge1xuICByZXR1cm4gd2luZG93TmFtZXMgJiYgdG9TdHJpbmcuY2FsbChpdCkgPT0gJ1tvYmplY3QgV2luZG93XScgPyBnZXRXaW5kb3dOYW1lcyhpdCkgOiBnT1BOKHRvSU9iamVjdChpdCkpO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1nb3BuLWV4dC5qcyIsIi8vIDE5LjEuMi43IC8gMTUuMi4zLjQgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoTylcbnZhciAka2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzLWludGVybmFsJyk7XG52YXIgaGlkZGVuS2V5cyA9IHJlcXVpcmUoJy4vX2VudW0tYnVnLWtleXMnKS5jb25jYXQoJ2xlbmd0aCcsICdwcm90b3R5cGUnKTtcblxuZXhwb3J0cy5mID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgfHwgZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhPKSB7XG4gIHJldHVybiAka2V5cyhPLCBoaWRkZW5LZXlzKTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZ29wbi5qcyIsImV4cG9ydHMuZiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZ29wcy5qcyIsIi8vIDE5LjEuMi45IC8gMTUuMi4zLjIgT2JqZWN0LmdldFByb3RvdHlwZU9mKE8pXG52YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcbnZhciBJRV9QUk9UTyA9IHJlcXVpcmUoJy4vX3NoYXJlZC1rZXknKSgnSUVfUFJPVE8nKTtcbnZhciBPYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmdldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIChPKSB7XG4gIE8gPSB0b09iamVjdChPKTtcbiAgaWYgKGhhcyhPLCBJRV9QUk9UTykpIHJldHVybiBPW0lFX1BST1RPXTtcbiAgaWYgKHR5cGVvZiBPLmNvbnN0cnVjdG9yID09ICdmdW5jdGlvbicgJiYgTyBpbnN0YW5jZW9mIE8uY29uc3RydWN0b3IpIHtcbiAgICByZXR1cm4gTy5jb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG4gIH0gcmV0dXJuIE8gaW5zdGFuY2VvZiBPYmplY3QgPyBPYmplY3RQcm90byA6IG51bGw7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWdwby5qcyIsInZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG52YXIgYXJyYXlJbmRleE9mID0gcmVxdWlyZSgnLi9fYXJyYXktaW5jbHVkZXMnKShmYWxzZSk7XG52YXIgSUVfUFJPVE8gPSByZXF1aXJlKCcuL19zaGFyZWQta2V5JykoJ0lFX1BST1RPJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iamVjdCwgbmFtZXMpIHtcbiAgdmFyIE8gPSB0b0lPYmplY3Qob2JqZWN0KTtcbiAgdmFyIGkgPSAwO1xuICB2YXIgcmVzdWx0ID0gW107XG4gIHZhciBrZXk7XG4gIGZvciAoa2V5IGluIE8pIGlmIChrZXkgIT0gSUVfUFJPVE8pIGhhcyhPLCBrZXkpICYmIHJlc3VsdC5wdXNoKGtleSk7XG4gIC8vIERvbid0IGVudW0gYnVnICYgaGlkZGVuIGtleXNcbiAgd2hpbGUgKG5hbWVzLmxlbmd0aCA+IGkpIGlmIChoYXMoTywga2V5ID0gbmFtZXNbaSsrXSkpIHtcbiAgICB+YXJyYXlJbmRleE9mKHJlc3VsdCwga2V5KSB8fCByZXN1bHQucHVzaChrZXkpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWtleXMtaW50ZXJuYWwuanMiLCIvLyAxOS4xLjIuMTQgLyAxNS4yLjMuMTQgT2JqZWN0LmtleXMoTylcbnZhciAka2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzLWludGVybmFsJyk7XG52YXIgZW51bUJ1Z0tleXMgPSByZXF1aXJlKCcuL19lbnVtLWJ1Zy1rZXlzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24ga2V5cyhPKSB7XG4gIHJldHVybiAka2V5cyhPLCBlbnVtQnVnS2V5cyk7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWtleXMuanMiLCJleHBvcnRzLmYgPSB7fS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1waWUuanMiLCIvLyBtb3N0IE9iamVjdCBtZXRob2RzIGJ5IEVTNiBzaG91bGQgYWNjZXB0IHByaW1pdGl2ZXNcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgY29yZSA9IHJlcXVpcmUoJy4vX2NvcmUnKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4vX2ZhaWxzJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChLRVksIGV4ZWMpIHtcbiAgdmFyIGZuID0gKGNvcmUuT2JqZWN0IHx8IHt9KVtLRVldIHx8IE9iamVjdFtLRVldO1xuICB2YXIgZXhwID0ge307XG4gIGV4cFtLRVldID0gZXhlYyhmbik7XG4gICRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogZmFpbHMoZnVuY3Rpb24gKCkgeyBmbigxKTsgfSksICdPYmplY3QnLCBleHApO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1zYXAuanMiLCJ2YXIgZ2V0S2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJyk7XG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xudmFyIGlzRW51bSA9IHJlcXVpcmUoJy4vX29iamVjdC1waWUnKS5mO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXNFbnRyaWVzKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoaXQpIHtcbiAgICB2YXIgTyA9IHRvSU9iamVjdChpdCk7XG4gICAgdmFyIGtleXMgPSBnZXRLZXlzKE8pO1xuICAgIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIHZhciBrZXk7XG4gICAgd2hpbGUgKGxlbmd0aCA+IGkpIGlmIChpc0VudW0uY2FsbChPLCBrZXkgPSBrZXlzW2krK10pKSB7XG4gICAgICByZXN1bHQucHVzaChpc0VudHJpZXMgPyBba2V5LCBPW2tleV1dIDogT1trZXldKTtcbiAgICB9IHJldHVybiByZXN1bHQ7XG4gIH07XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LXRvLWFycmF5LmpzIiwiLy8gYWxsIG9iamVjdCBrZXlzLCBpbmNsdWRlcyBub24tZW51bWVyYWJsZSBhbmQgc3ltYm9sc1xudmFyIGdPUE4gPSByZXF1aXJlKCcuL19vYmplY3QtZ29wbicpO1xudmFyIGdPUFMgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wcycpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgUmVmbGVjdCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLlJlZmxlY3Q7XG5tb2R1bGUuZXhwb3J0cyA9IFJlZmxlY3QgJiYgUmVmbGVjdC5vd25LZXlzIHx8IGZ1bmN0aW9uIG93bktleXMoaXQpIHtcbiAgdmFyIGtleXMgPSBnT1BOLmYoYW5PYmplY3QoaXQpKTtcbiAgdmFyIGdldFN5bWJvbHMgPSBnT1BTLmY7XG4gIHJldHVybiBnZXRTeW1ib2xzID8ga2V5cy5jb25jYXQoZ2V0U3ltYm9scyhpdCkpIDoga2V5cztcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vd24ta2V5cy5qcyIsInZhciAkcGFyc2VGbG9hdCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLnBhcnNlRmxvYXQ7XG52YXIgJHRyaW0gPSByZXF1aXJlKCcuL19zdHJpbmctdHJpbScpLnRyaW07XG5cbm1vZHVsZS5leHBvcnRzID0gMSAvICRwYXJzZUZsb2F0KHJlcXVpcmUoJy4vX3N0cmluZy13cycpICsgJy0wJykgIT09IC1JbmZpbml0eSA/IGZ1bmN0aW9uIHBhcnNlRmxvYXQoc3RyKSB7XG4gIHZhciBzdHJpbmcgPSAkdHJpbShTdHJpbmcoc3RyKSwgMyk7XG4gIHZhciByZXN1bHQgPSAkcGFyc2VGbG9hdChzdHJpbmcpO1xuICByZXR1cm4gcmVzdWx0ID09PSAwICYmIHN0cmluZy5jaGFyQXQoMCkgPT0gJy0nID8gLTAgOiByZXN1bHQ7XG59IDogJHBhcnNlRmxvYXQ7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19wYXJzZS1mbG9hdC5qcyIsInZhciAkcGFyc2VJbnQgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5wYXJzZUludDtcbnZhciAkdHJpbSA9IHJlcXVpcmUoJy4vX3N0cmluZy10cmltJykudHJpbTtcbnZhciB3cyA9IHJlcXVpcmUoJy4vX3N0cmluZy13cycpO1xudmFyIGhleCA9IC9eWy0rXT8wW3hYXS87XG5cbm1vZHVsZS5leHBvcnRzID0gJHBhcnNlSW50KHdzICsgJzA4JykgIT09IDggfHwgJHBhcnNlSW50KHdzICsgJzB4MTYnKSAhPT0gMjIgPyBmdW5jdGlvbiBwYXJzZUludChzdHIsIHJhZGl4KSB7XG4gIHZhciBzdHJpbmcgPSAkdHJpbShTdHJpbmcoc3RyKSwgMyk7XG4gIHJldHVybiAkcGFyc2VJbnQoc3RyaW5nLCAocmFkaXggPj4+IDApIHx8IChoZXgudGVzdChzdHJpbmcpID8gMTYgOiAxMCkpO1xufSA6ICRwYXJzZUludDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3BhcnNlLWludC5qcyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGV4ZWMpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4geyBlOiBmYWxzZSwgdjogZXhlYygpIH07XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4geyBlOiB0cnVlLCB2OiBlIH07XG4gIH1cbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19wZXJmb3JtLmpzIiwidmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBuZXdQcm9taXNlQ2FwYWJpbGl0eSA9IHJlcXVpcmUoJy4vX25ldy1wcm9taXNlLWNhcGFiaWxpdHknKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoQywgeCkge1xuICBhbk9iamVjdChDKTtcbiAgaWYgKGlzT2JqZWN0KHgpICYmIHguY29uc3RydWN0b3IgPT09IEMpIHJldHVybiB4O1xuICB2YXIgcHJvbWlzZUNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eS5mKEMpO1xuICB2YXIgcmVzb2x2ZSA9IHByb21pc2VDYXBhYmlsaXR5LnJlc29sdmU7XG4gIHJlc29sdmUoeCk7XG4gIHJldHVybiBwcm9taXNlQ2FwYWJpbGl0eS5wcm9taXNlO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3Byb21pc2UtcmVzb2x2ZS5qcyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGJpdG1hcCwgdmFsdWUpIHtcbiAgcmV0dXJuIHtcbiAgICBlbnVtZXJhYmxlOiAhKGJpdG1hcCAmIDEpLFxuICAgIGNvbmZpZ3VyYWJsZTogIShiaXRtYXAgJiAyKSxcbiAgICB3cml0YWJsZTogIShiaXRtYXAgJiA0KSxcbiAgICB2YWx1ZTogdmFsdWVcbiAgfTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19wcm9wZXJ0eS1kZXNjLmpzIiwidmFyIHJlZGVmaW5lID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHRhcmdldCwgc3JjLCBzYWZlKSB7XG4gIGZvciAodmFyIGtleSBpbiBzcmMpIHJlZGVmaW5lKHRhcmdldCwga2V5LCBzcmNba2V5XSwgc2FmZSk7XG4gIHJldHVybiB0YXJnZXQ7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fcmVkZWZpbmUtYWxsLmpzIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIGhpZGUgPSByZXF1aXJlKCcuL19oaWRlJyk7XG52YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgU1JDID0gcmVxdWlyZSgnLi9fdWlkJykoJ3NyYycpO1xudmFyIFRPX1NUUklORyA9ICd0b1N0cmluZyc7XG52YXIgJHRvU3RyaW5nID0gRnVuY3Rpb25bVE9fU1RSSU5HXTtcbnZhciBUUEwgPSAoJycgKyAkdG9TdHJpbmcpLnNwbGl0KFRPX1NUUklORyk7XG5cbnJlcXVpcmUoJy4vX2NvcmUnKS5pbnNwZWN0U291cmNlID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiAkdG9TdHJpbmcuY2FsbChpdCk7XG59O1xuXG4obW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoTywga2V5LCB2YWwsIHNhZmUpIHtcbiAgdmFyIGlzRnVuY3Rpb24gPSB0eXBlb2YgdmFsID09ICdmdW5jdGlvbic7XG4gIGlmIChpc0Z1bmN0aW9uKSBoYXModmFsLCAnbmFtZScpIHx8IGhpZGUodmFsLCAnbmFtZScsIGtleSk7XG4gIGlmIChPW2tleV0gPT09IHZhbCkgcmV0dXJuO1xuICBpZiAoaXNGdW5jdGlvbikgaGFzKHZhbCwgU1JDKSB8fCBoaWRlKHZhbCwgU1JDLCBPW2tleV0gPyAnJyArIE9ba2V5XSA6IFRQTC5qb2luKFN0cmluZyhrZXkpKSk7XG4gIGlmIChPID09PSBnbG9iYWwpIHtcbiAgICBPW2tleV0gPSB2YWw7XG4gIH0gZWxzZSBpZiAoIXNhZmUpIHtcbiAgICBkZWxldGUgT1trZXldO1xuICAgIGhpZGUoTywga2V5LCB2YWwpO1xuICB9IGVsc2UgaWYgKE9ba2V5XSkge1xuICAgIE9ba2V5XSA9IHZhbDtcbiAgfSBlbHNlIHtcbiAgICBoaWRlKE8sIGtleSwgdmFsKTtcbiAgfVxuLy8gYWRkIGZha2UgRnVuY3Rpb24jdG9TdHJpbmcgZm9yIGNvcnJlY3Qgd29yayB3cmFwcGVkIG1ldGhvZHMgLyBjb25zdHJ1Y3RvcnMgd2l0aCBtZXRob2RzIGxpa2UgTG9EYXNoIGlzTmF0aXZlXG59KShGdW5jdGlvbi5wcm90b3R5cGUsIFRPX1NUUklORywgZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gIHJldHVybiB0eXBlb2YgdGhpcyA9PSAnZnVuY3Rpb24nICYmIHRoaXNbU1JDXSB8fCAkdG9TdHJpbmcuY2FsbCh0aGlzKTtcbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fcmVkZWZpbmUuanMiLCIvLyA3LjIuOSBTYW1lVmFsdWUoeCwgeSlcbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmlzIHx8IGZ1bmN0aW9uIGlzKHgsIHkpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuICByZXR1cm4geCA9PT0geSA/IHggIT09IDAgfHwgMSAvIHggPT09IDEgLyB5IDogeCAhPSB4ICYmIHkgIT0geTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zYW1lLXZhbHVlLmpzIiwiJ3VzZSBzdHJpY3QnO1xuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9wcm9wb3NhbC1zZXRtYXAtb2Zmcm9tL1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG52YXIgY3R4ID0gcmVxdWlyZSgnLi9fY3R4Jyk7XG52YXIgZm9yT2YgPSByZXF1aXJlKCcuL19mb3Itb2YnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoQ09MTEVDVElPTikge1xuICAkZXhwb3J0KCRleHBvcnQuUywgQ09MTEVDVElPTiwgeyBmcm9tOiBmdW5jdGlvbiBmcm9tKHNvdXJjZSAvKiAsIG1hcEZuLCB0aGlzQXJnICovKSB7XG4gICAgdmFyIG1hcEZuID0gYXJndW1lbnRzWzFdO1xuICAgIHZhciBtYXBwaW5nLCBBLCBuLCBjYjtcbiAgICBhRnVuY3Rpb24odGhpcyk7XG4gICAgbWFwcGluZyA9IG1hcEZuICE9PSB1bmRlZmluZWQ7XG4gICAgaWYgKG1hcHBpbmcpIGFGdW5jdGlvbihtYXBGbik7XG4gICAgaWYgKHNvdXJjZSA9PSB1bmRlZmluZWQpIHJldHVybiBuZXcgdGhpcygpO1xuICAgIEEgPSBbXTtcbiAgICBpZiAobWFwcGluZykge1xuICAgICAgbiA9IDA7XG4gICAgICBjYiA9IGN0eChtYXBGbiwgYXJndW1lbnRzWzJdLCAyKTtcbiAgICAgIGZvck9mKHNvdXJjZSwgZmFsc2UsIGZ1bmN0aW9uIChuZXh0SXRlbSkge1xuICAgICAgICBBLnB1c2goY2IobmV4dEl0ZW0sIG4rKykpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvck9mKHNvdXJjZSwgZmFsc2UsIEEucHVzaCwgQSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgdGhpcyhBKTtcbiAgfSB9KTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zZXQtY29sbGVjdGlvbi1mcm9tLmpzIiwiJ3VzZSBzdHJpY3QnO1xuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9wcm9wb3NhbC1zZXRtYXAtb2Zmcm9tL1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoQ09MTEVDVElPTikge1xuICAkZXhwb3J0KCRleHBvcnQuUywgQ09MTEVDVElPTiwgeyBvZjogZnVuY3Rpb24gb2YoKSB7XG4gICAgdmFyIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgdmFyIEEgPSBBcnJheShsZW5ndGgpO1xuICAgIHdoaWxlIChsZW5ndGgtLSkgQVtsZW5ndGhdID0gYXJndW1lbnRzW2xlbmd0aF07XG4gICAgcmV0dXJuIG5ldyB0aGlzKEEpO1xuICB9IH0pO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3NldC1jb2xsZWN0aW9uLW9mLmpzIiwiLy8gV29ya3Mgd2l0aCBfX3Byb3RvX18gb25seS4gT2xkIHY4IGNhbid0IHdvcmsgd2l0aCBudWxsIHByb3RvIG9iamVjdHMuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBjaGVjayA9IGZ1bmN0aW9uIChPLCBwcm90bykge1xuICBhbk9iamVjdChPKTtcbiAgaWYgKCFpc09iamVjdChwcm90bykgJiYgcHJvdG8gIT09IG51bGwpIHRocm93IFR5cGVFcnJvcihwcm90byArIFwiOiBjYW4ndCBzZXQgYXMgcHJvdG90eXBlIVwiKTtcbn07XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc2V0OiBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgKCdfX3Byb3RvX18nIGluIHt9ID8gLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgIGZ1bmN0aW9uICh0ZXN0LCBidWdneSwgc2V0KSB7XG4gICAgICB0cnkge1xuICAgICAgICBzZXQgPSByZXF1aXJlKCcuL19jdHgnKShGdW5jdGlvbi5jYWxsLCByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpLmYoT2JqZWN0LnByb3RvdHlwZSwgJ19fcHJvdG9fXycpLnNldCwgMik7XG4gICAgICAgIHNldCh0ZXN0LCBbXSk7XG4gICAgICAgIGJ1Z2d5ID0gISh0ZXN0IGluc3RhbmNlb2YgQXJyYXkpO1xuICAgICAgfSBjYXRjaCAoZSkgeyBidWdneSA9IHRydWU7IH1cbiAgICAgIHJldHVybiBmdW5jdGlvbiBzZXRQcm90b3R5cGVPZihPLCBwcm90bykge1xuICAgICAgICBjaGVjayhPLCBwcm90byk7XG4gICAgICAgIGlmIChidWdneSkgTy5fX3Byb3RvX18gPSBwcm90bztcbiAgICAgICAgZWxzZSBzZXQoTywgcHJvdG8pO1xuICAgICAgICByZXR1cm4gTztcbiAgICAgIH07XG4gICAgfSh7fSwgZmFsc2UpIDogdW5kZWZpbmVkKSxcbiAgY2hlY2s6IGNoZWNrXG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc2V0LXByb3RvLmpzIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIGRQID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJyk7XG52YXIgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpO1xudmFyIFNQRUNJRVMgPSByZXF1aXJlKCcuL193a3MnKSgnc3BlY2llcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChLRVkpIHtcbiAgdmFyIEMgPSBnbG9iYWxbS0VZXTtcbiAgaWYgKERFU0NSSVBUT1JTICYmIEMgJiYgIUNbU1BFQ0lFU10pIGRQLmYoQywgU1BFQ0lFUywge1xuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH1cbiAgfSk7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc2V0LXNwZWNpZXMuanMiLCJ2YXIgZGVmID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZjtcbnZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciBUQUcgPSByZXF1aXJlKCcuL193a3MnKSgndG9TdHJpbmdUYWcnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQsIHRhZywgc3RhdCkge1xuICBpZiAoaXQgJiYgIWhhcyhpdCA9IHN0YXQgPyBpdCA6IGl0LnByb3RvdHlwZSwgVEFHKSkgZGVmKGl0LCBUQUcsIHsgY29uZmlndXJhYmxlOiB0cnVlLCB2YWx1ZTogdGFnIH0pO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3NldC10by1zdHJpbmctdGFnLmpzIiwidmFyIHNoYXJlZCA9IHJlcXVpcmUoJy4vX3NoYXJlZCcpKCdrZXlzJyk7XG52YXIgdWlkID0gcmVxdWlyZSgnLi9fdWlkJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgcmV0dXJuIHNoYXJlZFtrZXldIHx8IChzaGFyZWRba2V5XSA9IHVpZChrZXkpKTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zaGFyZWQta2V5LmpzIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIFNIQVJFRCA9ICdfX2NvcmUtanNfc2hhcmVkX18nO1xudmFyIHN0b3JlID0gZ2xvYmFsW1NIQVJFRF0gfHwgKGdsb2JhbFtTSEFSRURdID0ge30pO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIHJldHVybiBzdG9yZVtrZXldIHx8IChzdG9yZVtrZXldID0ge30pO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3NoYXJlZC5qcyIsIi8vIDcuMy4yMCBTcGVjaWVzQ29uc3RydWN0b3IoTywgZGVmYXVsdENvbnN0cnVjdG9yKVxudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpO1xudmFyIFNQRUNJRVMgPSByZXF1aXJlKCcuL193a3MnKSgnc3BlY2llcycpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoTywgRCkge1xuICB2YXIgQyA9IGFuT2JqZWN0KE8pLmNvbnN0cnVjdG9yO1xuICB2YXIgUztcbiAgcmV0dXJuIEMgPT09IHVuZGVmaW5lZCB8fCAoUyA9IGFuT2JqZWN0KEMpW1NQRUNJRVNdKSA9PSB1bmRlZmluZWQgPyBEIDogYUZ1bmN0aW9uKFMpO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3NwZWNpZXMtY29uc3RydWN0b3IuanMiLCIndXNlIHN0cmljdCc7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuL19mYWlscycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChtZXRob2QsIGFyZykge1xuICByZXR1cm4gISFtZXRob2QgJiYgZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11c2VsZXNzLWNhbGxcbiAgICBhcmcgPyBtZXRob2QuY2FsbChudWxsLCBmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH0sIDEpIDogbWV0aG9kLmNhbGwobnVsbCk7XG4gIH0pO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3N0cmljdC1tZXRob2QuanMiLCJ2YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpO1xudmFyIGRlZmluZWQgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG4vLyB0cnVlICAtPiBTdHJpbmcjYXRcbi8vIGZhbHNlIC0+IFN0cmluZyNjb2RlUG9pbnRBdFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoVE9fU1RSSU5HKSB7XG4gIHJldHVybiBmdW5jdGlvbiAodGhhdCwgcG9zKSB7XG4gICAgdmFyIHMgPSBTdHJpbmcoZGVmaW5lZCh0aGF0KSk7XG4gICAgdmFyIGkgPSB0b0ludGVnZXIocG9zKTtcbiAgICB2YXIgbCA9IHMubGVuZ3RoO1xuICAgIHZhciBhLCBiO1xuICAgIGlmIChpIDwgMCB8fCBpID49IGwpIHJldHVybiBUT19TVFJJTkcgPyAnJyA6IHVuZGVmaW5lZDtcbiAgICBhID0gcy5jaGFyQ29kZUF0KGkpO1xuICAgIHJldHVybiBhIDwgMHhkODAwIHx8IGEgPiAweGRiZmYgfHwgaSArIDEgPT09IGwgfHwgKGIgPSBzLmNoYXJDb2RlQXQoaSArIDEpKSA8IDB4ZGMwMCB8fCBiID4gMHhkZmZmXG4gICAgICA/IFRPX1NUUklORyA/IHMuY2hhckF0KGkpIDogYVxuICAgICAgOiBUT19TVFJJTkcgPyBzLnNsaWNlKGksIGkgKyAyKSA6IChhIC0gMHhkODAwIDw8IDEwKSArIChiIC0gMHhkYzAwKSArIDB4MTAwMDA7XG4gIH07XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc3RyaW5nLWF0LmpzIiwiLy8gaGVscGVyIGZvciBTdHJpbmcje3N0YXJ0c1dpdGgsIGVuZHNXaXRoLCBpbmNsdWRlc31cbnZhciBpc1JlZ0V4cCA9IHJlcXVpcmUoJy4vX2lzLXJlZ2V4cCcpO1xudmFyIGRlZmluZWQgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHRoYXQsIHNlYXJjaFN0cmluZywgTkFNRSkge1xuICBpZiAoaXNSZWdFeHAoc2VhcmNoU3RyaW5nKSkgdGhyb3cgVHlwZUVycm9yKCdTdHJpbmcjJyArIE5BTUUgKyBcIiBkb2Vzbid0IGFjY2VwdCByZWdleCFcIik7XG4gIHJldHVybiBTdHJpbmcoZGVmaW5lZCh0aGF0KSk7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc3RyaW5nLWNvbnRleHQuanMiLCJ2YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi9fZmFpbHMnKTtcbnZhciBkZWZpbmVkID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xudmFyIHF1b3QgPSAvXCIvZztcbi8vIEIuMi4zLjIuMSBDcmVhdGVIVE1MKHN0cmluZywgdGFnLCBhdHRyaWJ1dGUsIHZhbHVlKVxudmFyIGNyZWF0ZUhUTUwgPSBmdW5jdGlvbiAoc3RyaW5nLCB0YWcsIGF0dHJpYnV0ZSwgdmFsdWUpIHtcbiAgdmFyIFMgPSBTdHJpbmcoZGVmaW5lZChzdHJpbmcpKTtcbiAgdmFyIHAxID0gJzwnICsgdGFnO1xuICBpZiAoYXR0cmlidXRlICE9PSAnJykgcDEgKz0gJyAnICsgYXR0cmlidXRlICsgJz1cIicgKyBTdHJpbmcodmFsdWUpLnJlcGxhY2UocXVvdCwgJyZxdW90OycpICsgJ1wiJztcbiAgcmV0dXJuIHAxICsgJz4nICsgUyArICc8LycgKyB0YWcgKyAnPic7XG59O1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoTkFNRSwgZXhlYykge1xuICB2YXIgTyA9IHt9O1xuICBPW05BTUVdID0gZXhlYyhjcmVhdGVIVE1MKTtcbiAgJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiBmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHRlc3QgPSAnJ1tOQU1FXSgnXCInKTtcbiAgICByZXR1cm4gdGVzdCAhPT0gdGVzdC50b0xvd2VyQ2FzZSgpIHx8IHRlc3Quc3BsaXQoJ1wiJykubGVuZ3RoID4gMztcbiAgfSksICdTdHJpbmcnLCBPKTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zdHJpbmctaHRtbC5qcyIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLXN0cmluZy1wYWQtc3RhcnQtZW5kXG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcbnZhciByZXBlYXQgPSByZXF1aXJlKCcuL19zdHJpbmctcmVwZWF0Jyk7XG52YXIgZGVmaW5lZCA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodGhhdCwgbWF4TGVuZ3RoLCBmaWxsU3RyaW5nLCBsZWZ0KSB7XG4gIHZhciBTID0gU3RyaW5nKGRlZmluZWQodGhhdCkpO1xuICB2YXIgc3RyaW5nTGVuZ3RoID0gUy5sZW5ndGg7XG4gIHZhciBmaWxsU3RyID0gZmlsbFN0cmluZyA9PT0gdW5kZWZpbmVkID8gJyAnIDogU3RyaW5nKGZpbGxTdHJpbmcpO1xuICB2YXIgaW50TWF4TGVuZ3RoID0gdG9MZW5ndGgobWF4TGVuZ3RoKTtcbiAgaWYgKGludE1heExlbmd0aCA8PSBzdHJpbmdMZW5ndGggfHwgZmlsbFN0ciA9PSAnJykgcmV0dXJuIFM7XG4gIHZhciBmaWxsTGVuID0gaW50TWF4TGVuZ3RoIC0gc3RyaW5nTGVuZ3RoO1xuICB2YXIgc3RyaW5nRmlsbGVyID0gcmVwZWF0LmNhbGwoZmlsbFN0ciwgTWF0aC5jZWlsKGZpbGxMZW4gLyBmaWxsU3RyLmxlbmd0aCkpO1xuICBpZiAoc3RyaW5nRmlsbGVyLmxlbmd0aCA+IGZpbGxMZW4pIHN0cmluZ0ZpbGxlciA9IHN0cmluZ0ZpbGxlci5zbGljZSgwLCBmaWxsTGVuKTtcbiAgcmV0dXJuIGxlZnQgPyBzdHJpbmdGaWxsZXIgKyBTIDogUyArIHN0cmluZ0ZpbGxlcjtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zdHJpbmctcGFkLmpzIiwiJ3VzZSBzdHJpY3QnO1xudmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKTtcbnZhciBkZWZpbmVkID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHJlcGVhdChjb3VudCkge1xuICB2YXIgc3RyID0gU3RyaW5nKGRlZmluZWQodGhpcykpO1xuICB2YXIgcmVzID0gJyc7XG4gIHZhciBuID0gdG9JbnRlZ2VyKGNvdW50KTtcbiAgaWYgKG4gPCAwIHx8IG4gPT0gSW5maW5pdHkpIHRocm93IFJhbmdlRXJyb3IoXCJDb3VudCBjYW4ndCBiZSBuZWdhdGl2ZVwiKTtcbiAgZm9yICg7biA+IDA7IChuID4+Pj0gMSkgJiYgKHN0ciArPSBzdHIpKSBpZiAobiAmIDEpIHJlcyArPSBzdHI7XG4gIHJldHVybiByZXM7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc3RyaW5nLXJlcGVhdC5qcyIsInZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgZGVmaW5lZCA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4vX2ZhaWxzJyk7XG52YXIgc3BhY2VzID0gcmVxdWlyZSgnLi9fc3RyaW5nLXdzJyk7XG52YXIgc3BhY2UgPSAnWycgKyBzcGFjZXMgKyAnXSc7XG52YXIgbm9uID0gJ1xcdTIwMGJcXHUwMDg1JztcbnZhciBsdHJpbSA9IFJlZ0V4cCgnXicgKyBzcGFjZSArIHNwYWNlICsgJyonKTtcbnZhciBydHJpbSA9IFJlZ0V4cChzcGFjZSArIHNwYWNlICsgJyokJyk7XG5cbnZhciBleHBvcnRlciA9IGZ1bmN0aW9uIChLRVksIGV4ZWMsIEFMSUFTKSB7XG4gIHZhciBleHAgPSB7fTtcbiAgdmFyIEZPUkNFID0gZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAhIXNwYWNlc1tLRVldKCkgfHwgbm9uW0tFWV0oKSAhPSBub247XG4gIH0pO1xuICB2YXIgZm4gPSBleHBbS0VZXSA9IEZPUkNFID8gZXhlYyh0cmltKSA6IHNwYWNlc1tLRVldO1xuICBpZiAoQUxJQVMpIGV4cFtBTElBU10gPSBmbjtcbiAgJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiBGT1JDRSwgJ1N0cmluZycsIGV4cCk7XG59O1xuXG4vLyAxIC0+IFN0cmluZyN0cmltTGVmdFxuLy8gMiAtPiBTdHJpbmcjdHJpbVJpZ2h0XG4vLyAzIC0+IFN0cmluZyN0cmltXG52YXIgdHJpbSA9IGV4cG9ydGVyLnRyaW0gPSBmdW5jdGlvbiAoc3RyaW5nLCBUWVBFKSB7XG4gIHN0cmluZyA9IFN0cmluZyhkZWZpbmVkKHN0cmluZykpO1xuICBpZiAoVFlQRSAmIDEpIHN0cmluZyA9IHN0cmluZy5yZXBsYWNlKGx0cmltLCAnJyk7XG4gIGlmIChUWVBFICYgMikgc3RyaW5nID0gc3RyaW5nLnJlcGxhY2UocnRyaW0sICcnKTtcbiAgcmV0dXJuIHN0cmluZztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0ZXI7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zdHJpbmctdHJpbS5qcyIsIm1vZHVsZS5leHBvcnRzID0gJ1xceDA5XFx4MEFcXHgwQlxceDBDXFx4MERcXHgyMFxceEEwXFx1MTY4MFxcdTE4MEVcXHUyMDAwXFx1MjAwMVxcdTIwMDJcXHUyMDAzJyArXG4gICdcXHUyMDA0XFx1MjAwNVxcdTIwMDZcXHUyMDA3XFx1MjAwOFxcdTIwMDlcXHUyMDBBXFx1MjAyRlxcdTIwNUZcXHUzMDAwXFx1MjAyOFxcdTIwMjlcXHVGRUZGJztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3N0cmluZy13cy5qcyIsInZhciBjdHggPSByZXF1aXJlKCcuL19jdHgnKTtcbnZhciBpbnZva2UgPSByZXF1aXJlKCcuL19pbnZva2UnKTtcbnZhciBodG1sID0gcmVxdWlyZSgnLi9faHRtbCcpO1xudmFyIGNlbCA9IHJlcXVpcmUoJy4vX2RvbS1jcmVhdGUnKTtcbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBwcm9jZXNzID0gZ2xvYmFsLnByb2Nlc3M7XG52YXIgc2V0VGFzayA9IGdsb2JhbC5zZXRJbW1lZGlhdGU7XG52YXIgY2xlYXJUYXNrID0gZ2xvYmFsLmNsZWFySW1tZWRpYXRlO1xudmFyIE1lc3NhZ2VDaGFubmVsID0gZ2xvYmFsLk1lc3NhZ2VDaGFubmVsO1xudmFyIERpc3BhdGNoID0gZ2xvYmFsLkRpc3BhdGNoO1xudmFyIGNvdW50ZXIgPSAwO1xudmFyIHF1ZXVlID0ge307XG52YXIgT05SRUFEWVNUQVRFQ0hBTkdFID0gJ29ucmVhZHlzdGF0ZWNoYW5nZSc7XG52YXIgZGVmZXIsIGNoYW5uZWwsIHBvcnQ7XG52YXIgcnVuID0gZnVuY3Rpb24gKCkge1xuICB2YXIgaWQgPSArdGhpcztcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb3RvdHlwZS1idWlsdGluc1xuICBpZiAocXVldWUuaGFzT3duUHJvcGVydHkoaWQpKSB7XG4gICAgdmFyIGZuID0gcXVldWVbaWRdO1xuICAgIGRlbGV0ZSBxdWV1ZVtpZF07XG4gICAgZm4oKTtcbiAgfVxufTtcbnZhciBsaXN0ZW5lciA9IGZ1bmN0aW9uIChldmVudCkge1xuICBydW4uY2FsbChldmVudC5kYXRhKTtcbn07XG4vLyBOb2RlLmpzIDAuOSsgJiBJRTEwKyBoYXMgc2V0SW1tZWRpYXRlLCBvdGhlcndpc2U6XG5pZiAoIXNldFRhc2sgfHwgIWNsZWFyVGFzaykge1xuICBzZXRUYXNrID0gZnVuY3Rpb24gc2V0SW1tZWRpYXRlKGZuKSB7XG4gICAgdmFyIGFyZ3MgPSBbXTtcbiAgICB2YXIgaSA9IDE7XG4gICAgd2hpbGUgKGFyZ3VtZW50cy5sZW5ndGggPiBpKSBhcmdzLnB1c2goYXJndW1lbnRzW2krK10pO1xuICAgIHF1ZXVlWysrY291bnRlcl0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmV3LWZ1bmNcbiAgICAgIGludm9rZSh0eXBlb2YgZm4gPT0gJ2Z1bmN0aW9uJyA/IGZuIDogRnVuY3Rpb24oZm4pLCBhcmdzKTtcbiAgICB9O1xuICAgIGRlZmVyKGNvdW50ZXIpO1xuICAgIHJldHVybiBjb3VudGVyO1xuICB9O1xuICBjbGVhclRhc2sgPSBmdW5jdGlvbiBjbGVhckltbWVkaWF0ZShpZCkge1xuICAgIGRlbGV0ZSBxdWV1ZVtpZF07XG4gIH07XG4gIC8vIE5vZGUuanMgMC44LVxuICBpZiAocmVxdWlyZSgnLi9fY29mJykocHJvY2VzcykgPT0gJ3Byb2Nlc3MnKSB7XG4gICAgZGVmZXIgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soY3R4KHJ1biwgaWQsIDEpKTtcbiAgICB9O1xuICAvLyBTcGhlcmUgKEpTIGdhbWUgZW5naW5lKSBEaXNwYXRjaCBBUElcbiAgfSBlbHNlIGlmIChEaXNwYXRjaCAmJiBEaXNwYXRjaC5ub3cpIHtcbiAgICBkZWZlciA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgRGlzcGF0Y2gubm93KGN0eChydW4sIGlkLCAxKSk7XG4gICAgfTtcbiAgLy8gQnJvd3NlcnMgd2l0aCBNZXNzYWdlQ2hhbm5lbCwgaW5jbHVkZXMgV2ViV29ya2Vyc1xuICB9IGVsc2UgaWYgKE1lc3NhZ2VDaGFubmVsKSB7XG4gICAgY2hhbm5lbCA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpO1xuICAgIHBvcnQgPSBjaGFubmVsLnBvcnQyO1xuICAgIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gbGlzdGVuZXI7XG4gICAgZGVmZXIgPSBjdHgocG9ydC5wb3N0TWVzc2FnZSwgcG9ydCwgMSk7XG4gIC8vIEJyb3dzZXJzIHdpdGggcG9zdE1lc3NhZ2UsIHNraXAgV2ViV29ya2Vyc1xuICAvLyBJRTggaGFzIHBvc3RNZXNzYWdlLCBidXQgaXQncyBzeW5jICYgdHlwZW9mIGl0cyBwb3N0TWVzc2FnZSBpcyAnb2JqZWN0J1xuICB9IGVsc2UgaWYgKGdsb2JhbC5hZGRFdmVudExpc3RlbmVyICYmIHR5cGVvZiBwb3N0TWVzc2FnZSA9PSAnZnVuY3Rpb24nICYmICFnbG9iYWwuaW1wb3J0U2NyaXB0cykge1xuICAgIGRlZmVyID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICBnbG9iYWwucG9zdE1lc3NhZ2UoaWQgKyAnJywgJyonKTtcbiAgICB9O1xuICAgIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgbGlzdGVuZXIsIGZhbHNlKTtcbiAgLy8gSUU4LVxuICB9IGVsc2UgaWYgKE9OUkVBRFlTVEFURUNIQU5HRSBpbiBjZWwoJ3NjcmlwdCcpKSB7XG4gICAgZGVmZXIgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgIGh0bWwuYXBwZW5kQ2hpbGQoY2VsKCdzY3JpcHQnKSlbT05SRUFEWVNUQVRFQ0hBTkdFXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaHRtbC5yZW1vdmVDaGlsZCh0aGlzKTtcbiAgICAgICAgcnVuLmNhbGwoaWQpO1xuICAgICAgfTtcbiAgICB9O1xuICAvLyBSZXN0IG9sZCBicm93c2Vyc1xuICB9IGVsc2Uge1xuICAgIGRlZmVyID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICBzZXRUaW1lb3V0KGN0eChydW4sIGlkLCAxKSwgMCk7XG4gICAgfTtcbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHNldDogc2V0VGFzayxcbiAgY2xlYXI6IGNsZWFyVGFza1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3Rhc2suanMiLCJ2YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpO1xudmFyIG1heCA9IE1hdGgubWF4O1xudmFyIG1pbiA9IE1hdGgubWluO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaW5kZXgsIGxlbmd0aCkge1xuICBpbmRleCA9IHRvSW50ZWdlcihpbmRleCk7XG4gIHJldHVybiBpbmRleCA8IDAgPyBtYXgoaW5kZXggKyBsZW5ndGgsIDApIDogbWluKGluZGV4LCBsZW5ndGgpO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3RvLWFic29sdXRlLWluZGV4LmpzIiwiLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtdG9pbmRleFxudmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKGl0ID09PSB1bmRlZmluZWQpIHJldHVybiAwO1xuICB2YXIgbnVtYmVyID0gdG9JbnRlZ2VyKGl0KTtcbiAgdmFyIGxlbmd0aCA9IHRvTGVuZ3RoKG51bWJlcik7XG4gIGlmIChudW1iZXIgIT09IGxlbmd0aCkgdGhyb3cgUmFuZ2VFcnJvcignV3JvbmcgbGVuZ3RoIScpO1xuICByZXR1cm4gbGVuZ3RoO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3RvLWluZGV4LmpzIiwiLy8gNy4xLjQgVG9JbnRlZ2VyXG52YXIgY2VpbCA9IE1hdGguY2VpbDtcbnZhciBmbG9vciA9IE1hdGguZmxvb3I7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXNOYU4oaXQgPSAraXQpID8gMCA6IChpdCA+IDAgPyBmbG9vciA6IGNlaWwpKGl0KTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190by1pbnRlZ2VyLmpzIiwiLy8gdG8gaW5kZXhlZCBvYmplY3QsIHRvT2JqZWN0IHdpdGggZmFsbGJhY2sgZm9yIG5vbi1hcnJheS1saWtlIEVTMyBzdHJpbmdzXG52YXIgSU9iamVjdCA9IHJlcXVpcmUoJy4vX2lvYmplY3QnKTtcbnZhciBkZWZpbmVkID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIElPYmplY3QoZGVmaW5lZChpdCkpO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3RvLWlvYmplY3QuanMiLCIvLyA3LjEuMTUgVG9MZW5ndGhcbnZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJyk7XG52YXIgbWluID0gTWF0aC5taW47XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXQgPiAwID8gbWluKHRvSW50ZWdlcihpdCksIDB4MWZmZmZmZmZmZmZmZmYpIDogMDsgLy8gcG93KDIsIDUzKSAtIDEgPT0gOTAwNzE5OTI1NDc0MDk5MVxufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3RvLWxlbmd0aC5qcyIsIi8vIDcuMS4xMyBUb09iamVjdChhcmd1bWVudClcbnZhciBkZWZpbmVkID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIE9iamVjdChkZWZpbmVkKGl0KSk7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdG8tb2JqZWN0LmpzIiwiLy8gNy4xLjEgVG9QcmltaXRpdmUoaW5wdXQgWywgUHJlZmVycmVkVHlwZV0pXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbi8vIGluc3RlYWQgb2YgdGhlIEVTNiBzcGVjIHZlcnNpb24sIHdlIGRpZG4ndCBpbXBsZW1lbnQgQEB0b1ByaW1pdGl2ZSBjYXNlXG4vLyBhbmQgdGhlIHNlY29uZCBhcmd1bWVudCAtIGZsYWcgLSBwcmVmZXJyZWQgdHlwZSBpcyBhIHN0cmluZ1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQsIFMpIHtcbiAgaWYgKCFpc09iamVjdChpdCkpIHJldHVybiBpdDtcbiAgdmFyIGZuLCB2YWw7XG4gIGlmIChTICYmIHR5cGVvZiAoZm4gPSBpdC50b1N0cmluZykgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKSByZXR1cm4gdmFsO1xuICBpZiAodHlwZW9mIChmbiA9IGl0LnZhbHVlT2YpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSkgcmV0dXJuIHZhbDtcbiAgaWYgKCFTICYmIHR5cGVvZiAoZm4gPSBpdC50b1N0cmluZykgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKSByZXR1cm4gdmFsO1xuICB0aHJvdyBUeXBlRXJyb3IoXCJDYW4ndCBjb252ZXJ0IG9iamVjdCB0byBwcmltaXRpdmUgdmFsdWVcIik7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdG8tcHJpbWl0aXZlLmpzIiwiJ3VzZSBzdHJpY3QnO1xuaWYgKHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykpIHtcbiAgdmFyIExJQlJBUlkgPSByZXF1aXJlKCcuL19saWJyYXJ5Jyk7XG4gIHZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbiAgdmFyIGZhaWxzID0gcmVxdWlyZSgnLi9fZmFpbHMnKTtcbiAgdmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbiAgdmFyICR0eXBlZCA9IHJlcXVpcmUoJy4vX3R5cGVkJyk7XG4gIHZhciAkYnVmZmVyID0gcmVxdWlyZSgnLi9fdHlwZWQtYnVmZmVyJyk7XG4gIHZhciBjdHggPSByZXF1aXJlKCcuL19jdHgnKTtcbiAgdmFyIGFuSW5zdGFuY2UgPSByZXF1aXJlKCcuL19hbi1pbnN0YW5jZScpO1xuICB2YXIgcHJvcGVydHlEZXNjID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpO1xuICB2YXIgaGlkZSA9IHJlcXVpcmUoJy4vX2hpZGUnKTtcbiAgdmFyIHJlZGVmaW5lQWxsID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUtYWxsJyk7XG4gIHZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJyk7XG4gIHZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xuICB2YXIgdG9JbmRleCA9IHJlcXVpcmUoJy4vX3RvLWluZGV4Jyk7XG4gIHZhciB0b0Fic29sdXRlSW5kZXggPSByZXF1aXJlKCcuL190by1hYnNvbHV0ZS1pbmRleCcpO1xuICB2YXIgdG9QcmltaXRpdmUgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKTtcbiAgdmFyIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xuICB2YXIgY2xhc3NvZiA9IHJlcXVpcmUoJy4vX2NsYXNzb2YnKTtcbiAgdmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG4gIHZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpO1xuICB2YXIgaXNBcnJheUl0ZXIgPSByZXF1aXJlKCcuL19pcy1hcnJheS1pdGVyJyk7XG4gIHZhciBjcmVhdGUgPSByZXF1aXJlKCcuL19vYmplY3QtY3JlYXRlJyk7XG4gIHZhciBnZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4vX29iamVjdC1ncG8nKTtcbiAgdmFyIGdPUE4gPSByZXF1aXJlKCcuL19vYmplY3QtZ29wbicpLmY7XG4gIHZhciBnZXRJdGVyRm4gPSByZXF1aXJlKCcuL2NvcmUuZ2V0LWl0ZXJhdG9yLW1ldGhvZCcpO1xuICB2YXIgdWlkID0gcmVxdWlyZSgnLi9fdWlkJyk7XG4gIHZhciB3a3MgPSByZXF1aXJlKCcuL193a3MnKTtcbiAgdmFyIGNyZWF0ZUFycmF5TWV0aG9kID0gcmVxdWlyZSgnLi9fYXJyYXktbWV0aG9kcycpO1xuICB2YXIgY3JlYXRlQXJyYXlJbmNsdWRlcyA9IHJlcXVpcmUoJy4vX2FycmF5LWluY2x1ZGVzJyk7XG4gIHZhciBzcGVjaWVzQ29uc3RydWN0b3IgPSByZXF1aXJlKCcuL19zcGVjaWVzLWNvbnN0cnVjdG9yJyk7XG4gIHZhciBBcnJheUl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4vZXM2LmFycmF5Lml0ZXJhdG9yJyk7XG4gIHZhciBJdGVyYXRvcnMgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKTtcbiAgdmFyICRpdGVyRGV0ZWN0ID0gcmVxdWlyZSgnLi9faXRlci1kZXRlY3QnKTtcbiAgdmFyIHNldFNwZWNpZXMgPSByZXF1aXJlKCcuL19zZXQtc3BlY2llcycpO1xuICB2YXIgYXJyYXlGaWxsID0gcmVxdWlyZSgnLi9fYXJyYXktZmlsbCcpO1xuICB2YXIgYXJyYXlDb3B5V2l0aGluID0gcmVxdWlyZSgnLi9fYXJyYXktY29weS13aXRoaW4nKTtcbiAgdmFyICREUCA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpO1xuICB2YXIgJEdPUEQgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpO1xuICB2YXIgZFAgPSAkRFAuZjtcbiAgdmFyIGdPUEQgPSAkR09QRC5mO1xuICB2YXIgUmFuZ2VFcnJvciA9IGdsb2JhbC5SYW5nZUVycm9yO1xuICB2YXIgVHlwZUVycm9yID0gZ2xvYmFsLlR5cGVFcnJvcjtcbiAgdmFyIFVpbnQ4QXJyYXkgPSBnbG9iYWwuVWludDhBcnJheTtcbiAgdmFyIEFSUkFZX0JVRkZFUiA9ICdBcnJheUJ1ZmZlcic7XG4gIHZhciBTSEFSRURfQlVGRkVSID0gJ1NoYXJlZCcgKyBBUlJBWV9CVUZGRVI7XG4gIHZhciBCWVRFU19QRVJfRUxFTUVOVCA9ICdCWVRFU19QRVJfRUxFTUVOVCc7XG4gIHZhciBQUk9UT1RZUEUgPSAncHJvdG90eXBlJztcbiAgdmFyIEFycmF5UHJvdG8gPSBBcnJheVtQUk9UT1RZUEVdO1xuICB2YXIgJEFycmF5QnVmZmVyID0gJGJ1ZmZlci5BcnJheUJ1ZmZlcjtcbiAgdmFyICREYXRhVmlldyA9ICRidWZmZXIuRGF0YVZpZXc7XG4gIHZhciBhcnJheUZvckVhY2ggPSBjcmVhdGVBcnJheU1ldGhvZCgwKTtcbiAgdmFyIGFycmF5RmlsdGVyID0gY3JlYXRlQXJyYXlNZXRob2QoMik7XG4gIHZhciBhcnJheVNvbWUgPSBjcmVhdGVBcnJheU1ldGhvZCgzKTtcbiAgdmFyIGFycmF5RXZlcnkgPSBjcmVhdGVBcnJheU1ldGhvZCg0KTtcbiAgdmFyIGFycmF5RmluZCA9IGNyZWF0ZUFycmF5TWV0aG9kKDUpO1xuICB2YXIgYXJyYXlGaW5kSW5kZXggPSBjcmVhdGVBcnJheU1ldGhvZCg2KTtcbiAgdmFyIGFycmF5SW5jbHVkZXMgPSBjcmVhdGVBcnJheUluY2x1ZGVzKHRydWUpO1xuICB2YXIgYXJyYXlJbmRleE9mID0gY3JlYXRlQXJyYXlJbmNsdWRlcyhmYWxzZSk7XG4gIHZhciBhcnJheVZhbHVlcyA9IEFycmF5SXRlcmF0b3JzLnZhbHVlcztcbiAgdmFyIGFycmF5S2V5cyA9IEFycmF5SXRlcmF0b3JzLmtleXM7XG4gIHZhciBhcnJheUVudHJpZXMgPSBBcnJheUl0ZXJhdG9ycy5lbnRyaWVzO1xuICB2YXIgYXJyYXlMYXN0SW5kZXhPZiA9IEFycmF5UHJvdG8ubGFzdEluZGV4T2Y7XG4gIHZhciBhcnJheVJlZHVjZSA9IEFycmF5UHJvdG8ucmVkdWNlO1xuICB2YXIgYXJyYXlSZWR1Y2VSaWdodCA9IEFycmF5UHJvdG8ucmVkdWNlUmlnaHQ7XG4gIHZhciBhcnJheUpvaW4gPSBBcnJheVByb3RvLmpvaW47XG4gIHZhciBhcnJheVNvcnQgPSBBcnJheVByb3RvLnNvcnQ7XG4gIHZhciBhcnJheVNsaWNlID0gQXJyYXlQcm90by5zbGljZTtcbiAgdmFyIGFycmF5VG9TdHJpbmcgPSBBcnJheVByb3RvLnRvU3RyaW5nO1xuICB2YXIgYXJyYXlUb0xvY2FsZVN0cmluZyA9IEFycmF5UHJvdG8udG9Mb2NhbGVTdHJpbmc7XG4gIHZhciBJVEVSQVRPUiA9IHdrcygnaXRlcmF0b3InKTtcbiAgdmFyIFRBRyA9IHdrcygndG9TdHJpbmdUYWcnKTtcbiAgdmFyIFRZUEVEX0NPTlNUUlVDVE9SID0gdWlkKCd0eXBlZF9jb25zdHJ1Y3RvcicpO1xuICB2YXIgREVGX0NPTlNUUlVDVE9SID0gdWlkKCdkZWZfY29uc3RydWN0b3InKTtcbiAgdmFyIEFMTF9DT05TVFJVQ1RPUlMgPSAkdHlwZWQuQ09OU1RSO1xuICB2YXIgVFlQRURfQVJSQVkgPSAkdHlwZWQuVFlQRUQ7XG4gIHZhciBWSUVXID0gJHR5cGVkLlZJRVc7XG4gIHZhciBXUk9OR19MRU5HVEggPSAnV3JvbmcgbGVuZ3RoISc7XG5cbiAgdmFyICRtYXAgPSBjcmVhdGVBcnJheU1ldGhvZCgxLCBmdW5jdGlvbiAoTywgbGVuZ3RoKSB7XG4gICAgcmV0dXJuIGFsbG9jYXRlKHNwZWNpZXNDb25zdHJ1Y3RvcihPLCBPW0RFRl9DT05TVFJVQ1RPUl0pLCBsZW5ndGgpO1xuICB9KTtcblxuICB2YXIgTElUVExFX0VORElBTiA9IGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkobmV3IFVpbnQxNkFycmF5KFsxXSkuYnVmZmVyKVswXSA9PT0gMTtcbiAgfSk7XG5cbiAgdmFyIEZPUkNFRF9TRVQgPSAhIVVpbnQ4QXJyYXkgJiYgISFVaW50OEFycmF5W1BST1RPVFlQRV0uc2V0ICYmIGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICBuZXcgVWludDhBcnJheSgxKS5zZXQoe30pO1xuICB9KTtcblxuICB2YXIgdG9PZmZzZXQgPSBmdW5jdGlvbiAoaXQsIEJZVEVTKSB7XG4gICAgdmFyIG9mZnNldCA9IHRvSW50ZWdlcihpdCk7XG4gICAgaWYgKG9mZnNldCA8IDAgfHwgb2Zmc2V0ICUgQllURVMpIHRocm93IFJhbmdlRXJyb3IoJ1dyb25nIG9mZnNldCEnKTtcbiAgICByZXR1cm4gb2Zmc2V0O1xuICB9O1xuXG4gIHZhciB2YWxpZGF0ZSA9IGZ1bmN0aW9uIChpdCkge1xuICAgIGlmIChpc09iamVjdChpdCkgJiYgVFlQRURfQVJSQVkgaW4gaXQpIHJldHVybiBpdDtcbiAgICB0aHJvdyBUeXBlRXJyb3IoaXQgKyAnIGlzIG5vdCBhIHR5cGVkIGFycmF5IScpO1xuICB9O1xuXG4gIHZhciBhbGxvY2F0ZSA9IGZ1bmN0aW9uIChDLCBsZW5ndGgpIHtcbiAgICBpZiAoIShpc09iamVjdChDKSAmJiBUWVBFRF9DT05TVFJVQ1RPUiBpbiBDKSkge1xuICAgICAgdGhyb3cgVHlwZUVycm9yKCdJdCBpcyBub3QgYSB0eXBlZCBhcnJheSBjb25zdHJ1Y3RvciEnKTtcbiAgICB9IHJldHVybiBuZXcgQyhsZW5ndGgpO1xuICB9O1xuXG4gIHZhciBzcGVjaWVzRnJvbUxpc3QgPSBmdW5jdGlvbiAoTywgbGlzdCkge1xuICAgIHJldHVybiBmcm9tTGlzdChzcGVjaWVzQ29uc3RydWN0b3IoTywgT1tERUZfQ09OU1RSVUNUT1JdKSwgbGlzdCk7XG4gIH07XG5cbiAgdmFyIGZyb21MaXN0ID0gZnVuY3Rpb24gKEMsIGxpc3QpIHtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHZhciBsZW5ndGggPSBsaXN0Lmxlbmd0aDtcbiAgICB2YXIgcmVzdWx0ID0gYWxsb2NhdGUoQywgbGVuZ3RoKTtcbiAgICB3aGlsZSAobGVuZ3RoID4gaW5kZXgpIHJlc3VsdFtpbmRleF0gPSBsaXN0W2luZGV4KytdO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgdmFyIGFkZEdldHRlciA9IGZ1bmN0aW9uIChpdCwga2V5LCBpbnRlcm5hbCkge1xuICAgIGRQKGl0LCBrZXksIHsgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9kW2ludGVybmFsXTsgfSB9KTtcbiAgfTtcblxuICB2YXIgJGZyb20gPSBmdW5jdGlvbiBmcm9tKHNvdXJjZSAvKiAsIG1hcGZuLCB0aGlzQXJnICovKSB7XG4gICAgdmFyIE8gPSB0b09iamVjdChzb3VyY2UpO1xuICAgIHZhciBhTGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB2YXIgbWFwZm4gPSBhTGVuID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZDtcbiAgICB2YXIgbWFwcGluZyA9IG1hcGZuICE9PSB1bmRlZmluZWQ7XG4gICAgdmFyIGl0ZXJGbiA9IGdldEl0ZXJGbihPKTtcbiAgICB2YXIgaSwgbGVuZ3RoLCB2YWx1ZXMsIHJlc3VsdCwgc3RlcCwgaXRlcmF0b3I7XG4gICAgaWYgKGl0ZXJGbiAhPSB1bmRlZmluZWQgJiYgIWlzQXJyYXlJdGVyKGl0ZXJGbikpIHtcbiAgICAgIGZvciAoaXRlcmF0b3IgPSBpdGVyRm4uY2FsbChPKSwgdmFsdWVzID0gW10sIGkgPSAwOyAhKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmU7IGkrKykge1xuICAgICAgICB2YWx1ZXMucHVzaChzdGVwLnZhbHVlKTtcbiAgICAgIH0gTyA9IHZhbHVlcztcbiAgICB9XG4gICAgaWYgKG1hcHBpbmcgJiYgYUxlbiA+IDIpIG1hcGZuID0gY3R4KG1hcGZuLCBhcmd1bWVudHNbMl0sIDIpO1xuICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IHRvTGVuZ3RoKE8ubGVuZ3RoKSwgcmVzdWx0ID0gYWxsb2NhdGUodGhpcywgbGVuZ3RoKTsgbGVuZ3RoID4gaTsgaSsrKSB7XG4gICAgICByZXN1bHRbaV0gPSBtYXBwaW5nID8gbWFwZm4oT1tpXSwgaSkgOiBPW2ldO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIHZhciAkb2YgPSBmdW5jdGlvbiBvZigvKiAuLi5pdGVtcyAqLykge1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgdmFyIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgdmFyIHJlc3VsdCA9IGFsbG9jYXRlKHRoaXMsIGxlbmd0aCk7XG4gICAgd2hpbGUgKGxlbmd0aCA+IGluZGV4KSByZXN1bHRbaW5kZXhdID0gYXJndW1lbnRzW2luZGV4KytdO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gaU9TIFNhZmFyaSA2LnggZmFpbHMgaGVyZVxuICB2YXIgVE9fTE9DQUxFX0JVRyA9ICEhVWludDhBcnJheSAmJiBmYWlscyhmdW5jdGlvbiAoKSB7IGFycmF5VG9Mb2NhbGVTdHJpbmcuY2FsbChuZXcgVWludDhBcnJheSgxKSk7IH0pO1xuXG4gIHZhciAkdG9Mb2NhbGVTdHJpbmcgPSBmdW5jdGlvbiB0b0xvY2FsZVN0cmluZygpIHtcbiAgICByZXR1cm4gYXJyYXlUb0xvY2FsZVN0cmluZy5hcHBseShUT19MT0NBTEVfQlVHID8gYXJyYXlTbGljZS5jYWxsKHZhbGlkYXRlKHRoaXMpKSA6IHZhbGlkYXRlKHRoaXMpLCBhcmd1bWVudHMpO1xuICB9O1xuXG4gIHZhciBwcm90byA9IHtcbiAgICBjb3B5V2l0aGluOiBmdW5jdGlvbiBjb3B5V2l0aGluKHRhcmdldCwgc3RhcnQgLyogLCBlbmQgKi8pIHtcbiAgICAgIHJldHVybiBhcnJheUNvcHlXaXRoaW4uY2FsbCh2YWxpZGF0ZSh0aGlzKSwgdGFyZ2V0LCBzdGFydCwgYXJndW1lbnRzLmxlbmd0aCA+IDIgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQpO1xuICAgIH0sXG4gICAgZXZlcnk6IGZ1bmN0aW9uIGV2ZXJ5KGNhbGxiYWNrZm4gLyogLCB0aGlzQXJnICovKSB7XG4gICAgICByZXR1cm4gYXJyYXlFdmVyeSh2YWxpZGF0ZSh0aGlzKSwgY2FsbGJhY2tmbiwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICAgIH0sXG4gICAgZmlsbDogZnVuY3Rpb24gZmlsbCh2YWx1ZSAvKiAsIHN0YXJ0LCBlbmQgKi8pIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgICAgcmV0dXJuIGFycmF5RmlsbC5hcHBseSh2YWxpZGF0ZSh0aGlzKSwgYXJndW1lbnRzKTtcbiAgICB9LFxuICAgIGZpbHRlcjogZnVuY3Rpb24gZmlsdGVyKGNhbGxiYWNrZm4gLyogLCB0aGlzQXJnICovKSB7XG4gICAgICByZXR1cm4gc3BlY2llc0Zyb21MaXN0KHRoaXMsIGFycmF5RmlsdGVyKHZhbGlkYXRlKHRoaXMpLCBjYWxsYmFja2ZuLFxuICAgICAgICBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCkpO1xuICAgIH0sXG4gICAgZmluZDogZnVuY3Rpb24gZmluZChwcmVkaWNhdGUgLyogLCB0aGlzQXJnICovKSB7XG4gICAgICByZXR1cm4gYXJyYXlGaW5kKHZhbGlkYXRlKHRoaXMpLCBwcmVkaWNhdGUsIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgICB9LFxuICAgIGZpbmRJbmRleDogZnVuY3Rpb24gZmluZEluZGV4KHByZWRpY2F0ZSAvKiAsIHRoaXNBcmcgKi8pIHtcbiAgICAgIHJldHVybiBhcnJheUZpbmRJbmRleCh2YWxpZGF0ZSh0aGlzKSwgcHJlZGljYXRlLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gICAgfSxcbiAgICBmb3JFYWNoOiBmdW5jdGlvbiBmb3JFYWNoKGNhbGxiYWNrZm4gLyogLCB0aGlzQXJnICovKSB7XG4gICAgICBhcnJheUZvckVhY2godmFsaWRhdGUodGhpcyksIGNhbGxiYWNrZm4sIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgICB9LFxuICAgIGluZGV4T2Y6IGZ1bmN0aW9uIGluZGV4T2Yoc2VhcmNoRWxlbWVudCAvKiAsIGZyb21JbmRleCAqLykge1xuICAgICAgcmV0dXJuIGFycmF5SW5kZXhPZih2YWxpZGF0ZSh0aGlzKSwgc2VhcmNoRWxlbWVudCwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICAgIH0sXG4gICAgaW5jbHVkZXM6IGZ1bmN0aW9uIGluY2x1ZGVzKHNlYXJjaEVsZW1lbnQgLyogLCBmcm9tSW5kZXggKi8pIHtcbiAgICAgIHJldHVybiBhcnJheUluY2x1ZGVzKHZhbGlkYXRlKHRoaXMpLCBzZWFyY2hFbGVtZW50LCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gICAgfSxcbiAgICBqb2luOiBmdW5jdGlvbiBqb2luKHNlcGFyYXRvcikgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgICByZXR1cm4gYXJyYXlKb2luLmFwcGx5KHZhbGlkYXRlKHRoaXMpLCBhcmd1bWVudHMpO1xuICAgIH0sXG4gICAgbGFzdEluZGV4T2Y6IGZ1bmN0aW9uIGxhc3RJbmRleE9mKHNlYXJjaEVsZW1lbnQgLyogLCBmcm9tSW5kZXggKi8pIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgICAgcmV0dXJuIGFycmF5TGFzdEluZGV4T2YuYXBwbHkodmFsaWRhdGUodGhpcyksIGFyZ3VtZW50cyk7XG4gICAgfSxcbiAgICBtYXA6IGZ1bmN0aW9uIG1hcChtYXBmbiAvKiAsIHRoaXNBcmcgKi8pIHtcbiAgICAgIHJldHVybiAkbWFwKHZhbGlkYXRlKHRoaXMpLCBtYXBmbiwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICAgIH0sXG4gICAgcmVkdWNlOiBmdW5jdGlvbiByZWR1Y2UoY2FsbGJhY2tmbiAvKiAsIGluaXRpYWxWYWx1ZSAqLykgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgICByZXR1cm4gYXJyYXlSZWR1Y2UuYXBwbHkodmFsaWRhdGUodGhpcyksIGFyZ3VtZW50cyk7XG4gICAgfSxcbiAgICByZWR1Y2VSaWdodDogZnVuY3Rpb24gcmVkdWNlUmlnaHQoY2FsbGJhY2tmbiAvKiAsIGluaXRpYWxWYWx1ZSAqLykgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgICByZXR1cm4gYXJyYXlSZWR1Y2VSaWdodC5hcHBseSh2YWxpZGF0ZSh0aGlzKSwgYXJndW1lbnRzKTtcbiAgICB9LFxuICAgIHJldmVyc2U6IGZ1bmN0aW9uIHJldmVyc2UoKSB7XG4gICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICB2YXIgbGVuZ3RoID0gdmFsaWRhdGUodGhhdCkubGVuZ3RoO1xuICAgICAgdmFyIG1pZGRsZSA9IE1hdGguZmxvb3IobGVuZ3RoIC8gMik7XG4gICAgICB2YXIgaW5kZXggPSAwO1xuICAgICAgdmFyIHZhbHVlO1xuICAgICAgd2hpbGUgKGluZGV4IDwgbWlkZGxlKSB7XG4gICAgICAgIHZhbHVlID0gdGhhdFtpbmRleF07XG4gICAgICAgIHRoYXRbaW5kZXgrK10gPSB0aGF0Wy0tbGVuZ3RoXTtcbiAgICAgICAgdGhhdFtsZW5ndGhdID0gdmFsdWU7XG4gICAgICB9IHJldHVybiB0aGF0O1xuICAgIH0sXG4gICAgc29tZTogZnVuY3Rpb24gc29tZShjYWxsYmFja2ZuIC8qICwgdGhpc0FyZyAqLykge1xuICAgICAgcmV0dXJuIGFycmF5U29tZSh2YWxpZGF0ZSh0aGlzKSwgY2FsbGJhY2tmbiwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICAgIH0sXG4gICAgc29ydDogZnVuY3Rpb24gc29ydChjb21wYXJlZm4pIHtcbiAgICAgIHJldHVybiBhcnJheVNvcnQuY2FsbCh2YWxpZGF0ZSh0aGlzKSwgY29tcGFyZWZuKTtcbiAgICB9LFxuICAgIHN1YmFycmF5OiBmdW5jdGlvbiBzdWJhcnJheShiZWdpbiwgZW5kKSB7XG4gICAgICB2YXIgTyA9IHZhbGlkYXRlKHRoaXMpO1xuICAgICAgdmFyIGxlbmd0aCA9IE8ubGVuZ3RoO1xuICAgICAgdmFyICRiZWdpbiA9IHRvQWJzb2x1dGVJbmRleChiZWdpbiwgbGVuZ3RoKTtcbiAgICAgIHJldHVybiBuZXcgKHNwZWNpZXNDb25zdHJ1Y3RvcihPLCBPW0RFRl9DT05TVFJVQ1RPUl0pKShcbiAgICAgICAgTy5idWZmZXIsXG4gICAgICAgIE8uYnl0ZU9mZnNldCArICRiZWdpbiAqIE8uQllURVNfUEVSX0VMRU1FTlQsXG4gICAgICAgIHRvTGVuZ3RoKChlbmQgPT09IHVuZGVmaW5lZCA/IGxlbmd0aCA6IHRvQWJzb2x1dGVJbmRleChlbmQsIGxlbmd0aCkpIC0gJGJlZ2luKVxuICAgICAgKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyICRzbGljZSA9IGZ1bmN0aW9uIHNsaWNlKHN0YXJ0LCBlbmQpIHtcbiAgICByZXR1cm4gc3BlY2llc0Zyb21MaXN0KHRoaXMsIGFycmF5U2xpY2UuY2FsbCh2YWxpZGF0ZSh0aGlzKSwgc3RhcnQsIGVuZCkpO1xuICB9O1xuXG4gIHZhciAkc2V0ID0gZnVuY3Rpb24gc2V0KGFycmF5TGlrZSAvKiAsIG9mZnNldCAqLykge1xuICAgIHZhbGlkYXRlKHRoaXMpO1xuICAgIHZhciBvZmZzZXQgPSB0b09mZnNldChhcmd1bWVudHNbMV0sIDEpO1xuICAgIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aDtcbiAgICB2YXIgc3JjID0gdG9PYmplY3QoYXJyYXlMaWtlKTtcbiAgICB2YXIgbGVuID0gdG9MZW5ndGgoc3JjLmxlbmd0aCk7XG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICBpZiAobGVuICsgb2Zmc2V0ID4gbGVuZ3RoKSB0aHJvdyBSYW5nZUVycm9yKFdST05HX0xFTkdUSCk7XG4gICAgd2hpbGUgKGluZGV4IDwgbGVuKSB0aGlzW29mZnNldCArIGluZGV4XSA9IHNyY1tpbmRleCsrXTtcbiAgfTtcblxuICB2YXIgJGl0ZXJhdG9ycyA9IHtcbiAgICBlbnRyaWVzOiBmdW5jdGlvbiBlbnRyaWVzKCkge1xuICAgICAgcmV0dXJuIGFycmF5RW50cmllcy5jYWxsKHZhbGlkYXRlKHRoaXMpKTtcbiAgICB9LFxuICAgIGtleXM6IGZ1bmN0aW9uIGtleXMoKSB7XG4gICAgICByZXR1cm4gYXJyYXlLZXlzLmNhbGwodmFsaWRhdGUodGhpcykpO1xuICAgIH0sXG4gICAgdmFsdWVzOiBmdW5jdGlvbiB2YWx1ZXMoKSB7XG4gICAgICByZXR1cm4gYXJyYXlWYWx1ZXMuY2FsbCh2YWxpZGF0ZSh0aGlzKSk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBpc1RBSW5kZXggPSBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHtcbiAgICByZXR1cm4gaXNPYmplY3QodGFyZ2V0KVxuICAgICAgJiYgdGFyZ2V0W1RZUEVEX0FSUkFZXVxuICAgICAgJiYgdHlwZW9mIGtleSAhPSAnc3ltYm9sJ1xuICAgICAgJiYga2V5IGluIHRhcmdldFxuICAgICAgJiYgU3RyaW5nKCtrZXkpID09IFN0cmluZyhrZXkpO1xuICB9O1xuICB2YXIgJGdldERlc2MgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIHtcbiAgICByZXR1cm4gaXNUQUluZGV4KHRhcmdldCwga2V5ID0gdG9QcmltaXRpdmUoa2V5LCB0cnVlKSlcbiAgICAgID8gcHJvcGVydHlEZXNjKDIsIHRhcmdldFtrZXldKVxuICAgICAgOiBnT1BEKHRhcmdldCwga2V5KTtcbiAgfTtcbiAgdmFyICRzZXREZXNjID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICBpZiAoaXNUQUluZGV4KHRhcmdldCwga2V5ID0gdG9QcmltaXRpdmUoa2V5LCB0cnVlKSlcbiAgICAgICYmIGlzT2JqZWN0KGRlc2MpXG4gICAgICAmJiBoYXMoZGVzYywgJ3ZhbHVlJylcbiAgICAgICYmICFoYXMoZGVzYywgJ2dldCcpXG4gICAgICAmJiAhaGFzKGRlc2MsICdzZXQnKVxuICAgICAgLy8gVE9ETzogYWRkIHZhbGlkYXRpb24gZGVzY3JpcHRvciB3L28gY2FsbGluZyBhY2Nlc3NvcnNcbiAgICAgICYmICFkZXNjLmNvbmZpZ3VyYWJsZVxuICAgICAgJiYgKCFoYXMoZGVzYywgJ3dyaXRhYmxlJykgfHwgZGVzYy53cml0YWJsZSlcbiAgICAgICYmICghaGFzKGRlc2MsICdlbnVtZXJhYmxlJykgfHwgZGVzYy5lbnVtZXJhYmxlKVxuICAgICkge1xuICAgICAgdGFyZ2V0W2tleV0gPSBkZXNjLnZhbHVlO1xuICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9IHJldHVybiBkUCh0YXJnZXQsIGtleSwgZGVzYyk7XG4gIH07XG5cbiAgaWYgKCFBTExfQ09OU1RSVUNUT1JTKSB7XG4gICAgJEdPUEQuZiA9ICRnZXREZXNjO1xuICAgICREUC5mID0gJHNldERlc2M7XG4gIH1cblxuICAkZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFBTExfQ09OU1RSVUNUT1JTLCAnT2JqZWN0Jywge1xuICAgIGdldE93blByb3BlcnR5RGVzY3JpcHRvcjogJGdldERlc2MsXG4gICAgZGVmaW5lUHJvcGVydHk6ICRzZXREZXNjXG4gIH0pO1xuXG4gIGlmIChmYWlscyhmdW5jdGlvbiAoKSB7IGFycmF5VG9TdHJpbmcuY2FsbCh7fSk7IH0pKSB7XG4gICAgYXJyYXlUb1N0cmluZyA9IGFycmF5VG9Mb2NhbGVTdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgIHJldHVybiBhcnJheUpvaW4uY2FsbCh0aGlzKTtcbiAgICB9O1xuICB9XG5cbiAgdmFyICRUeXBlZEFycmF5UHJvdG90eXBlJCA9IHJlZGVmaW5lQWxsKHt9LCBwcm90byk7XG4gIHJlZGVmaW5lQWxsKCRUeXBlZEFycmF5UHJvdG90eXBlJCwgJGl0ZXJhdG9ycyk7XG4gIGhpZGUoJFR5cGVkQXJyYXlQcm90b3R5cGUkLCBJVEVSQVRPUiwgJGl0ZXJhdG9ycy52YWx1ZXMpO1xuICByZWRlZmluZUFsbCgkVHlwZWRBcnJheVByb3RvdHlwZSQsIHtcbiAgICBzbGljZTogJHNsaWNlLFxuICAgIHNldDogJHNldCxcbiAgICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24gKCkgeyAvKiBub29wICovIH0sXG4gICAgdG9TdHJpbmc6IGFycmF5VG9TdHJpbmcsXG4gICAgdG9Mb2NhbGVTdHJpbmc6ICR0b0xvY2FsZVN0cmluZ1xuICB9KTtcbiAgYWRkR2V0dGVyKCRUeXBlZEFycmF5UHJvdG90eXBlJCwgJ2J1ZmZlcicsICdiJyk7XG4gIGFkZEdldHRlcigkVHlwZWRBcnJheVByb3RvdHlwZSQsICdieXRlT2Zmc2V0JywgJ28nKTtcbiAgYWRkR2V0dGVyKCRUeXBlZEFycmF5UHJvdG90eXBlJCwgJ2J5dGVMZW5ndGgnLCAnbCcpO1xuICBhZGRHZXR0ZXIoJFR5cGVkQXJyYXlQcm90b3R5cGUkLCAnbGVuZ3RoJywgJ2UnKTtcbiAgZFAoJFR5cGVkQXJyYXlQcm90b3R5cGUkLCBUQUcsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXNbVFlQRURfQVJSQVldOyB9XG4gIH0pO1xuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtc3RhdGVtZW50c1xuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChLRVksIEJZVEVTLCB3cmFwcGVyLCBDTEFNUEVEKSB7XG4gICAgQ0xBTVBFRCA9ICEhQ0xBTVBFRDtcbiAgICB2YXIgTkFNRSA9IEtFWSArIChDTEFNUEVEID8gJ0NsYW1wZWQnIDogJycpICsgJ0FycmF5JztcbiAgICB2YXIgR0VUVEVSID0gJ2dldCcgKyBLRVk7XG4gICAgdmFyIFNFVFRFUiA9ICdzZXQnICsgS0VZO1xuICAgIHZhciBUeXBlZEFycmF5ID0gZ2xvYmFsW05BTUVdO1xuICAgIHZhciBCYXNlID0gVHlwZWRBcnJheSB8fCB7fTtcbiAgICB2YXIgVEFDID0gVHlwZWRBcnJheSAmJiBnZXRQcm90b3R5cGVPZihUeXBlZEFycmF5KTtcbiAgICB2YXIgRk9SQ0VEID0gIVR5cGVkQXJyYXkgfHwgISR0eXBlZC5BQlY7XG4gICAgdmFyIE8gPSB7fTtcbiAgICB2YXIgVHlwZWRBcnJheVByb3RvdHlwZSA9IFR5cGVkQXJyYXkgJiYgVHlwZWRBcnJheVtQUk9UT1RZUEVdO1xuICAgIHZhciBnZXR0ZXIgPSBmdW5jdGlvbiAodGhhdCwgaW5kZXgpIHtcbiAgICAgIHZhciBkYXRhID0gdGhhdC5fZDtcbiAgICAgIHJldHVybiBkYXRhLnZbR0VUVEVSXShpbmRleCAqIEJZVEVTICsgZGF0YS5vLCBMSVRUTEVfRU5ESUFOKTtcbiAgICB9O1xuICAgIHZhciBzZXR0ZXIgPSBmdW5jdGlvbiAodGhhdCwgaW5kZXgsIHZhbHVlKSB7XG4gICAgICB2YXIgZGF0YSA9IHRoYXQuX2Q7XG4gICAgICBpZiAoQ0xBTVBFRCkgdmFsdWUgPSAodmFsdWUgPSBNYXRoLnJvdW5kKHZhbHVlKSkgPCAwID8gMCA6IHZhbHVlID4gMHhmZiA/IDB4ZmYgOiB2YWx1ZSAmIDB4ZmY7XG4gICAgICBkYXRhLnZbU0VUVEVSXShpbmRleCAqIEJZVEVTICsgZGF0YS5vLCB2YWx1ZSwgTElUVExFX0VORElBTik7XG4gICAgfTtcbiAgICB2YXIgYWRkRWxlbWVudCA9IGZ1bmN0aW9uICh0aGF0LCBpbmRleCkge1xuICAgICAgZFAodGhhdCwgaW5kZXgsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIGdldHRlcih0aGlzLCBpbmRleCk7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIHNldHRlcih0aGlzLCBpbmRleCwgdmFsdWUpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9O1xuICAgIGlmIChGT1JDRUQpIHtcbiAgICAgIFR5cGVkQXJyYXkgPSB3cmFwcGVyKGZ1bmN0aW9uICh0aGF0LCBkYXRhLCAkb2Zmc2V0LCAkbGVuZ3RoKSB7XG4gICAgICAgIGFuSW5zdGFuY2UodGhhdCwgVHlwZWRBcnJheSwgTkFNRSwgJ19kJyk7XG4gICAgICAgIHZhciBpbmRleCA9IDA7XG4gICAgICAgIHZhciBvZmZzZXQgPSAwO1xuICAgICAgICB2YXIgYnVmZmVyLCBieXRlTGVuZ3RoLCBsZW5ndGgsIGtsYXNzO1xuICAgICAgICBpZiAoIWlzT2JqZWN0KGRhdGEpKSB7XG4gICAgICAgICAgbGVuZ3RoID0gdG9JbmRleChkYXRhKTtcbiAgICAgICAgICBieXRlTGVuZ3RoID0gbGVuZ3RoICogQllURVM7XG4gICAgICAgICAgYnVmZmVyID0gbmV3ICRBcnJheUJ1ZmZlcihieXRlTGVuZ3RoKTtcbiAgICAgICAgfSBlbHNlIGlmIChkYXRhIGluc3RhbmNlb2YgJEFycmF5QnVmZmVyIHx8IChrbGFzcyA9IGNsYXNzb2YoZGF0YSkpID09IEFSUkFZX0JVRkZFUiB8fCBrbGFzcyA9PSBTSEFSRURfQlVGRkVSKSB7XG4gICAgICAgICAgYnVmZmVyID0gZGF0YTtcbiAgICAgICAgICBvZmZzZXQgPSB0b09mZnNldCgkb2Zmc2V0LCBCWVRFUyk7XG4gICAgICAgICAgdmFyICRsZW4gPSBkYXRhLmJ5dGVMZW5ndGg7XG4gICAgICAgICAgaWYgKCRsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKCRsZW4gJSBCWVRFUykgdGhyb3cgUmFuZ2VFcnJvcihXUk9OR19MRU5HVEgpO1xuICAgICAgICAgICAgYnl0ZUxlbmd0aCA9ICRsZW4gLSBvZmZzZXQ7XG4gICAgICAgICAgICBpZiAoYnl0ZUxlbmd0aCA8IDApIHRocm93IFJhbmdlRXJyb3IoV1JPTkdfTEVOR1RIKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYnl0ZUxlbmd0aCA9IHRvTGVuZ3RoKCRsZW5ndGgpICogQllURVM7XG4gICAgICAgICAgICBpZiAoYnl0ZUxlbmd0aCArIG9mZnNldCA+ICRsZW4pIHRocm93IFJhbmdlRXJyb3IoV1JPTkdfTEVOR1RIKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGVuZ3RoID0gYnl0ZUxlbmd0aCAvIEJZVEVTO1xuICAgICAgICB9IGVsc2UgaWYgKFRZUEVEX0FSUkFZIGluIGRhdGEpIHtcbiAgICAgICAgICByZXR1cm4gZnJvbUxpc3QoVHlwZWRBcnJheSwgZGF0YSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuICRmcm9tLmNhbGwoVHlwZWRBcnJheSwgZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgaGlkZSh0aGF0LCAnX2QnLCB7XG4gICAgICAgICAgYjogYnVmZmVyLFxuICAgICAgICAgIG86IG9mZnNldCxcbiAgICAgICAgICBsOiBieXRlTGVuZ3RoLFxuICAgICAgICAgIGU6IGxlbmd0aCxcbiAgICAgICAgICB2OiBuZXcgJERhdGFWaWV3KGJ1ZmZlcilcbiAgICAgICAgfSk7XG4gICAgICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkgYWRkRWxlbWVudCh0aGF0LCBpbmRleCsrKTtcbiAgICAgIH0pO1xuICAgICAgVHlwZWRBcnJheVByb3RvdHlwZSA9IFR5cGVkQXJyYXlbUFJPVE9UWVBFXSA9IGNyZWF0ZSgkVHlwZWRBcnJheVByb3RvdHlwZSQpO1xuICAgICAgaGlkZShUeXBlZEFycmF5UHJvdG90eXBlLCAnY29uc3RydWN0b3InLCBUeXBlZEFycmF5KTtcbiAgICB9IGVsc2UgaWYgKCFmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgICBUeXBlZEFycmF5KDEpO1xuICAgIH0pIHx8ICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgICBuZXcgVHlwZWRBcnJheSgtMSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG4gICAgfSkgfHwgISRpdGVyRGV0ZWN0KGZ1bmN0aW9uIChpdGVyKSB7XG4gICAgICBuZXcgVHlwZWRBcnJheSgpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xuICAgICAgbmV3IFR5cGVkQXJyYXkobnVsbCk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG4gICAgICBuZXcgVHlwZWRBcnJheSgxLjUpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xuICAgICAgbmV3IFR5cGVkQXJyYXkoaXRlcik7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG4gICAgfSwgdHJ1ZSkpIHtcbiAgICAgIFR5cGVkQXJyYXkgPSB3cmFwcGVyKGZ1bmN0aW9uICh0aGF0LCBkYXRhLCAkb2Zmc2V0LCAkbGVuZ3RoKSB7XG4gICAgICAgIGFuSW5zdGFuY2UodGhhdCwgVHlwZWRBcnJheSwgTkFNRSk7XG4gICAgICAgIHZhciBrbGFzcztcbiAgICAgICAgLy8gYHdzYCBtb2R1bGUgYnVnLCB0ZW1wb3JhcmlseSByZW1vdmUgdmFsaWRhdGlvbiBsZW5ndGggZm9yIFVpbnQ4QXJyYXlcbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3dlYnNvY2tldHMvd3MvcHVsbC82NDVcbiAgICAgICAgaWYgKCFpc09iamVjdChkYXRhKSkgcmV0dXJuIG5ldyBCYXNlKHRvSW5kZXgoZGF0YSkpO1xuICAgICAgICBpZiAoZGF0YSBpbnN0YW5jZW9mICRBcnJheUJ1ZmZlciB8fCAoa2xhc3MgPSBjbGFzc29mKGRhdGEpKSA9PSBBUlJBWV9CVUZGRVIgfHwga2xhc3MgPT0gU0hBUkVEX0JVRkZFUikge1xuICAgICAgICAgIHJldHVybiAkbGVuZ3RoICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8gbmV3IEJhc2UoZGF0YSwgdG9PZmZzZXQoJG9mZnNldCwgQllURVMpLCAkbGVuZ3RoKVxuICAgICAgICAgICAgOiAkb2Zmc2V0ICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgPyBuZXcgQmFzZShkYXRhLCB0b09mZnNldCgkb2Zmc2V0LCBCWVRFUykpXG4gICAgICAgICAgICAgIDogbmV3IEJhc2UoZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFRZUEVEX0FSUkFZIGluIGRhdGEpIHJldHVybiBmcm9tTGlzdChUeXBlZEFycmF5LCBkYXRhKTtcbiAgICAgICAgcmV0dXJuICRmcm9tLmNhbGwoVHlwZWRBcnJheSwgZGF0YSk7XG4gICAgICB9KTtcbiAgICAgIGFycmF5Rm9yRWFjaChUQUMgIT09IEZ1bmN0aW9uLnByb3RvdHlwZSA/IGdPUE4oQmFzZSkuY29uY2F0KGdPUE4oVEFDKSkgOiBnT1BOKEJhc2UpLCBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIGlmICghKGtleSBpbiBUeXBlZEFycmF5KSkgaGlkZShUeXBlZEFycmF5LCBrZXksIEJhc2Vba2V5XSk7XG4gICAgICB9KTtcbiAgICAgIFR5cGVkQXJyYXlbUFJPVE9UWVBFXSA9IFR5cGVkQXJyYXlQcm90b3R5cGU7XG4gICAgICBpZiAoIUxJQlJBUlkpIFR5cGVkQXJyYXlQcm90b3R5cGUuY29uc3RydWN0b3IgPSBUeXBlZEFycmF5O1xuICAgIH1cbiAgICB2YXIgJG5hdGl2ZUl0ZXJhdG9yID0gVHlwZWRBcnJheVByb3RvdHlwZVtJVEVSQVRPUl07XG4gICAgdmFyIENPUlJFQ1RfSVRFUl9OQU1FID0gISEkbmF0aXZlSXRlcmF0b3JcbiAgICAgICYmICgkbmF0aXZlSXRlcmF0b3IubmFtZSA9PSAndmFsdWVzJyB8fCAkbmF0aXZlSXRlcmF0b3IubmFtZSA9PSB1bmRlZmluZWQpO1xuICAgIHZhciAkaXRlcmF0b3IgPSAkaXRlcmF0b3JzLnZhbHVlcztcbiAgICBoaWRlKFR5cGVkQXJyYXksIFRZUEVEX0NPTlNUUlVDVE9SLCB0cnVlKTtcbiAgICBoaWRlKFR5cGVkQXJyYXlQcm90b3R5cGUsIFRZUEVEX0FSUkFZLCBOQU1FKTtcbiAgICBoaWRlKFR5cGVkQXJyYXlQcm90b3R5cGUsIFZJRVcsIHRydWUpO1xuICAgIGhpZGUoVHlwZWRBcnJheVByb3RvdHlwZSwgREVGX0NPTlNUUlVDVE9SLCBUeXBlZEFycmF5KTtcblxuICAgIGlmIChDTEFNUEVEID8gbmV3IFR5cGVkQXJyYXkoMSlbVEFHXSAhPSBOQU1FIDogIShUQUcgaW4gVHlwZWRBcnJheVByb3RvdHlwZSkpIHtcbiAgICAgIGRQKFR5cGVkQXJyYXlQcm90b3R5cGUsIFRBRywge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIE5BTUU7IH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIE9bTkFNRV0gPSBUeXBlZEFycmF5O1xuXG4gICAgJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LlcgKyAkZXhwb3J0LkYgKiAoVHlwZWRBcnJheSAhPSBCYXNlKSwgTyk7XG5cbiAgICAkZXhwb3J0KCRleHBvcnQuUywgTkFNRSwge1xuICAgICAgQllURVNfUEVSX0VMRU1FTlQ6IEJZVEVTXG4gICAgfSk7XG5cbiAgICAkZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqIGZhaWxzKGZ1bmN0aW9uICgpIHsgQmFzZS5vZi5jYWxsKFR5cGVkQXJyYXksIDEpOyB9KSwgTkFNRSwge1xuICAgICAgZnJvbTogJGZyb20sXG4gICAgICBvZjogJG9mXG4gICAgfSk7XG5cbiAgICBpZiAoIShCWVRFU19QRVJfRUxFTUVOVCBpbiBUeXBlZEFycmF5UHJvdG90eXBlKSkgaGlkZShUeXBlZEFycmF5UHJvdG90eXBlLCBCWVRFU19QRVJfRUxFTUVOVCwgQllURVMpO1xuXG4gICAgJGV4cG9ydCgkZXhwb3J0LlAsIE5BTUUsIHByb3RvKTtcblxuICAgIHNldFNwZWNpZXMoTkFNRSk7XG5cbiAgICAkZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIEZPUkNFRF9TRVQsIE5BTUUsIHsgc2V0OiAkc2V0IH0pO1xuXG4gICAgJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAhQ09SUkVDVF9JVEVSX05BTUUsIE5BTUUsICRpdGVyYXRvcnMpO1xuXG4gICAgaWYgKCFMSUJSQVJZICYmIFR5cGVkQXJyYXlQcm90b3R5cGUudG9TdHJpbmcgIT0gYXJyYXlUb1N0cmluZykgVHlwZWRBcnJheVByb3RvdHlwZS50b1N0cmluZyA9IGFycmF5VG9TdHJpbmc7XG5cbiAgICAkZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICAgIG5ldyBUeXBlZEFycmF5KDEpLnNsaWNlKCk7XG4gICAgfSksIE5BTUUsIHsgc2xpY2U6ICRzbGljZSB9KTtcblxuICAgICRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogKGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBbMSwgMl0udG9Mb2NhbGVTdHJpbmcoKSAhPSBuZXcgVHlwZWRBcnJheShbMSwgMl0pLnRvTG9jYWxlU3RyaW5nKCk7XG4gICAgfSkgfHwgIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICAgIFR5cGVkQXJyYXlQcm90b3R5cGUudG9Mb2NhbGVTdHJpbmcuY2FsbChbMSwgMl0pO1xuICAgIH0pKSwgTkFNRSwgeyB0b0xvY2FsZVN0cmluZzogJHRvTG9jYWxlU3RyaW5nIH0pO1xuXG4gICAgSXRlcmF0b3JzW05BTUVdID0gQ09SUkVDVF9JVEVSX05BTUUgPyAkbmF0aXZlSXRlcmF0b3IgOiAkaXRlcmF0b3I7XG4gICAgaWYgKCFMSUJSQVJZICYmICFDT1JSRUNUX0lURVJfTkFNRSkgaGlkZShUeXBlZEFycmF5UHJvdG90eXBlLCBJVEVSQVRPUiwgJGl0ZXJhdG9yKTtcbiAgfTtcbn0gZWxzZSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3R5cGVkLWFycmF5LmpzIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKTtcbnZhciBMSUJSQVJZID0gcmVxdWlyZSgnLi9fbGlicmFyeScpO1xudmFyICR0eXBlZCA9IHJlcXVpcmUoJy4vX3R5cGVkJyk7XG52YXIgaGlkZSA9IHJlcXVpcmUoJy4vX2hpZGUnKTtcbnZhciByZWRlZmluZUFsbCA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lLWFsbCcpO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi9fZmFpbHMnKTtcbnZhciBhbkluc3RhbmNlID0gcmVxdWlyZSgnLi9fYW4taW5zdGFuY2UnKTtcbnZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcbnZhciB0b0luZGV4ID0gcmVxdWlyZSgnLi9fdG8taW5kZXgnKTtcbnZhciBnT1BOID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcG4nKS5mO1xudmFyIGRQID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZjtcbnZhciBhcnJheUZpbGwgPSByZXF1aXJlKCcuL19hcnJheS1maWxsJyk7XG52YXIgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpO1xudmFyIEFSUkFZX0JVRkZFUiA9ICdBcnJheUJ1ZmZlcic7XG52YXIgREFUQV9WSUVXID0gJ0RhdGFWaWV3JztcbnZhciBQUk9UT1RZUEUgPSAncHJvdG90eXBlJztcbnZhciBXUk9OR19MRU5HVEggPSAnV3JvbmcgbGVuZ3RoISc7XG52YXIgV1JPTkdfSU5ERVggPSAnV3JvbmcgaW5kZXghJztcbnZhciAkQXJyYXlCdWZmZXIgPSBnbG9iYWxbQVJSQVlfQlVGRkVSXTtcbnZhciAkRGF0YVZpZXcgPSBnbG9iYWxbREFUQV9WSUVXXTtcbnZhciBNYXRoID0gZ2xvYmFsLk1hdGg7XG52YXIgUmFuZ2VFcnJvciA9IGdsb2JhbC5SYW5nZUVycm9yO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNoYWRvdy1yZXN0cmljdGVkLW5hbWVzXG52YXIgSW5maW5pdHkgPSBnbG9iYWwuSW5maW5pdHk7XG52YXIgQmFzZUJ1ZmZlciA9ICRBcnJheUJ1ZmZlcjtcbnZhciBhYnMgPSBNYXRoLmFicztcbnZhciBwb3cgPSBNYXRoLnBvdztcbnZhciBmbG9vciA9IE1hdGguZmxvb3I7XG52YXIgbG9nID0gTWF0aC5sb2c7XG52YXIgTE4yID0gTWF0aC5MTjI7XG52YXIgQlVGRkVSID0gJ2J1ZmZlcic7XG52YXIgQllURV9MRU5HVEggPSAnYnl0ZUxlbmd0aCc7XG52YXIgQllURV9PRkZTRVQgPSAnYnl0ZU9mZnNldCc7XG52YXIgJEJVRkZFUiA9IERFU0NSSVBUT1JTID8gJ19iJyA6IEJVRkZFUjtcbnZhciAkTEVOR1RIID0gREVTQ1JJUFRPUlMgPyAnX2wnIDogQllURV9MRU5HVEg7XG52YXIgJE9GRlNFVCA9IERFU0NSSVBUT1JTID8gJ19vJyA6IEJZVEVfT0ZGU0VUO1xuXG4vLyBJRUVFNzU0IGNvbnZlcnNpb25zIGJhc2VkIG9uIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvaWVlZTc1NFxuZnVuY3Rpb24gcGFja0lFRUU3NTQodmFsdWUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgYnVmZmVyID0gQXJyYXkobkJ5dGVzKTtcbiAgdmFyIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDE7XG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxO1xuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDE7XG4gIHZhciBydCA9IG1MZW4gPT09IDIzID8gcG93KDIsIC0yNCkgLSBwb3coMiwgLTc3KSA6IDA7XG4gIHZhciBpID0gMDtcbiAgdmFyIHMgPSB2YWx1ZSA8IDAgfHwgdmFsdWUgPT09IDAgJiYgMSAvIHZhbHVlIDwgMCA/IDEgOiAwO1xuICB2YXIgZSwgbSwgYztcbiAgdmFsdWUgPSBhYnModmFsdWUpO1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gIGlmICh2YWx1ZSAhPSB2YWx1ZSB8fCB2YWx1ZSA9PT0gSW5maW5pdHkpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gICAgbSA9IHZhbHVlICE9IHZhbHVlID8gMSA6IDA7XG4gICAgZSA9IGVNYXg7XG4gIH0gZWxzZSB7XG4gICAgZSA9IGZsb29yKGxvZyh2YWx1ZSkgLyBMTjIpO1xuICAgIGlmICh2YWx1ZSAqIChjID0gcG93KDIsIC1lKSkgPCAxKSB7XG4gICAgICBlLS07XG4gICAgICBjICo9IDI7XG4gICAgfVxuICAgIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgdmFsdWUgKz0gcnQgLyBjO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSArPSBydCAqIHBvdygyLCAxIC0gZUJpYXMpO1xuICAgIH1cbiAgICBpZiAodmFsdWUgKiBjID49IDIpIHtcbiAgICAgIGUrKztcbiAgICAgIGMgLz0gMjtcbiAgICB9XG4gICAgaWYgKGUgKyBlQmlhcyA+PSBlTWF4KSB7XG4gICAgICBtID0gMDtcbiAgICAgIGUgPSBlTWF4O1xuICAgIH0gZWxzZSBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIG0gPSAodmFsdWUgKiBjIC0gMSkgKiBwb3coMiwgbUxlbik7XG4gICAgICBlID0gZSArIGVCaWFzO1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gdmFsdWUgKiBwb3coMiwgZUJpYXMgLSAxKSAqIHBvdygyLCBtTGVuKTtcbiAgICAgIGUgPSAwO1xuICAgIH1cbiAgfVxuICBmb3IgKDsgbUxlbiA+PSA4OyBidWZmZXJbaSsrXSA9IG0gJiAyNTUsIG0gLz0gMjU2LCBtTGVuIC09IDgpO1xuICBlID0gZSA8PCBtTGVuIHwgbTtcbiAgZUxlbiArPSBtTGVuO1xuICBmb3IgKDsgZUxlbiA+IDA7IGJ1ZmZlcltpKytdID0gZSAmIDI1NSwgZSAvPSAyNTYsIGVMZW4gLT0gOCk7XG4gIGJ1ZmZlclstLWldIHw9IHMgKiAxMjg7XG4gIHJldHVybiBidWZmZXI7XG59XG5mdW5jdGlvbiB1bnBhY2tJRUVFNzU0KGJ1ZmZlciwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlTGVuID0gbkJ5dGVzICogOCAtIG1MZW4gLSAxO1xuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMTtcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxO1xuICB2YXIgbkJpdHMgPSBlTGVuIC0gNztcbiAgdmFyIGkgPSBuQnl0ZXMgLSAxO1xuICB2YXIgcyA9IGJ1ZmZlcltpLS1dO1xuICB2YXIgZSA9IHMgJiAxMjc7XG4gIHZhciBtO1xuICBzID4+PSA3O1xuICBmb3IgKDsgbkJpdHMgPiAwOyBlID0gZSAqIDI1NiArIGJ1ZmZlcltpXSwgaS0tLCBuQml0cyAtPSA4KTtcbiAgbSA9IGUgJiAoMSA8PCAtbkJpdHMpIC0gMTtcbiAgZSA+Pj0gLW5CaXRzO1xuICBuQml0cyArPSBtTGVuO1xuICBmb3IgKDsgbkJpdHMgPiAwOyBtID0gbSAqIDI1NiArIGJ1ZmZlcltpXSwgaS0tLCBuQml0cyAtPSA4KTtcbiAgaWYgKGUgPT09IDApIHtcbiAgICBlID0gMSAtIGVCaWFzO1xuICB9IGVsc2UgaWYgKGUgPT09IGVNYXgpIHtcbiAgICByZXR1cm4gbSA/IE5hTiA6IHMgPyAtSW5maW5pdHkgOiBJbmZpbml0eTtcbiAgfSBlbHNlIHtcbiAgICBtID0gbSArIHBvdygyLCBtTGVuKTtcbiAgICBlID0gZSAtIGVCaWFzO1xuICB9IHJldHVybiAocyA/IC0xIDogMSkgKiBtICogcG93KDIsIGUgLSBtTGVuKTtcbn1cblxuZnVuY3Rpb24gdW5wYWNrSTMyKGJ5dGVzKSB7XG4gIHJldHVybiBieXRlc1szXSA8PCAyNCB8IGJ5dGVzWzJdIDw8IDE2IHwgYnl0ZXNbMV0gPDwgOCB8IGJ5dGVzWzBdO1xufVxuZnVuY3Rpb24gcGFja0k4KGl0KSB7XG4gIHJldHVybiBbaXQgJiAweGZmXTtcbn1cbmZ1bmN0aW9uIHBhY2tJMTYoaXQpIHtcbiAgcmV0dXJuIFtpdCAmIDB4ZmYsIGl0ID4+IDggJiAweGZmXTtcbn1cbmZ1bmN0aW9uIHBhY2tJMzIoaXQpIHtcbiAgcmV0dXJuIFtpdCAmIDB4ZmYsIGl0ID4+IDggJiAweGZmLCBpdCA+PiAxNiAmIDB4ZmYsIGl0ID4+IDI0ICYgMHhmZl07XG59XG5mdW5jdGlvbiBwYWNrRjY0KGl0KSB7XG4gIHJldHVybiBwYWNrSUVFRTc1NChpdCwgNTIsIDgpO1xufVxuZnVuY3Rpb24gcGFja0YzMihpdCkge1xuICByZXR1cm4gcGFja0lFRUU3NTQoaXQsIDIzLCA0KTtcbn1cblxuZnVuY3Rpb24gYWRkR2V0dGVyKEMsIGtleSwgaW50ZXJuYWwpIHtcbiAgZFAoQ1tQUk9UT1RZUEVdLCBrZXksIHsgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzW2ludGVybmFsXTsgfSB9KTtcbn1cblxuZnVuY3Rpb24gZ2V0KHZpZXcsIGJ5dGVzLCBpbmRleCwgaXNMaXR0bGVFbmRpYW4pIHtcbiAgdmFyIG51bUluZGV4ID0gK2luZGV4O1xuICB2YXIgaW50SW5kZXggPSB0b0luZGV4KG51bUluZGV4KTtcbiAgaWYgKGludEluZGV4ICsgYnl0ZXMgPiB2aWV3WyRMRU5HVEhdKSB0aHJvdyBSYW5nZUVycm9yKFdST05HX0lOREVYKTtcbiAgdmFyIHN0b3JlID0gdmlld1skQlVGRkVSXS5fYjtcbiAgdmFyIHN0YXJ0ID0gaW50SW5kZXggKyB2aWV3WyRPRkZTRVRdO1xuICB2YXIgcGFjayA9IHN0b3JlLnNsaWNlKHN0YXJ0LCBzdGFydCArIGJ5dGVzKTtcbiAgcmV0dXJuIGlzTGl0dGxlRW5kaWFuID8gcGFjayA6IHBhY2sucmV2ZXJzZSgpO1xufVxuZnVuY3Rpb24gc2V0KHZpZXcsIGJ5dGVzLCBpbmRleCwgY29udmVyc2lvbiwgdmFsdWUsIGlzTGl0dGxlRW5kaWFuKSB7XG4gIHZhciBudW1JbmRleCA9ICtpbmRleDtcbiAgdmFyIGludEluZGV4ID0gdG9JbmRleChudW1JbmRleCk7XG4gIGlmIChpbnRJbmRleCArIGJ5dGVzID4gdmlld1skTEVOR1RIXSkgdGhyb3cgUmFuZ2VFcnJvcihXUk9OR19JTkRFWCk7XG4gIHZhciBzdG9yZSA9IHZpZXdbJEJVRkZFUl0uX2I7XG4gIHZhciBzdGFydCA9IGludEluZGV4ICsgdmlld1skT0ZGU0VUXTtcbiAgdmFyIHBhY2sgPSBjb252ZXJzaW9uKCt2YWx1ZSk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXM7IGkrKykgc3RvcmVbc3RhcnQgKyBpXSA9IHBhY2tbaXNMaXR0bGVFbmRpYW4gPyBpIDogYnl0ZXMgLSBpIC0gMV07XG59XG5cbmlmICghJHR5cGVkLkFCVikge1xuICAkQXJyYXlCdWZmZXIgPSBmdW5jdGlvbiBBcnJheUJ1ZmZlcihsZW5ndGgpIHtcbiAgICBhbkluc3RhbmNlKHRoaXMsICRBcnJheUJ1ZmZlciwgQVJSQVlfQlVGRkVSKTtcbiAgICB2YXIgYnl0ZUxlbmd0aCA9IHRvSW5kZXgobGVuZ3RoKTtcbiAgICB0aGlzLl9iID0gYXJyYXlGaWxsLmNhbGwoQXJyYXkoYnl0ZUxlbmd0aCksIDApO1xuICAgIHRoaXNbJExFTkdUSF0gPSBieXRlTGVuZ3RoO1xuICB9O1xuXG4gICREYXRhVmlldyA9IGZ1bmN0aW9uIERhdGFWaWV3KGJ1ZmZlciwgYnl0ZU9mZnNldCwgYnl0ZUxlbmd0aCkge1xuICAgIGFuSW5zdGFuY2UodGhpcywgJERhdGFWaWV3LCBEQVRBX1ZJRVcpO1xuICAgIGFuSW5zdGFuY2UoYnVmZmVyLCAkQXJyYXlCdWZmZXIsIERBVEFfVklFVyk7XG4gICAgdmFyIGJ1ZmZlckxlbmd0aCA9IGJ1ZmZlclskTEVOR1RIXTtcbiAgICB2YXIgb2Zmc2V0ID0gdG9JbnRlZ2VyKGJ5dGVPZmZzZXQpO1xuICAgIGlmIChvZmZzZXQgPCAwIHx8IG9mZnNldCA+IGJ1ZmZlckxlbmd0aCkgdGhyb3cgUmFuZ2VFcnJvcignV3Jvbmcgb2Zmc2V0IScpO1xuICAgIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID09PSB1bmRlZmluZWQgPyBidWZmZXJMZW5ndGggLSBvZmZzZXQgOiB0b0xlbmd0aChieXRlTGVuZ3RoKTtcbiAgICBpZiAob2Zmc2V0ICsgYnl0ZUxlbmd0aCA+IGJ1ZmZlckxlbmd0aCkgdGhyb3cgUmFuZ2VFcnJvcihXUk9OR19MRU5HVEgpO1xuICAgIHRoaXNbJEJVRkZFUl0gPSBidWZmZXI7XG4gICAgdGhpc1skT0ZGU0VUXSA9IG9mZnNldDtcbiAgICB0aGlzWyRMRU5HVEhdID0gYnl0ZUxlbmd0aDtcbiAgfTtcblxuICBpZiAoREVTQ1JJUFRPUlMpIHtcbiAgICBhZGRHZXR0ZXIoJEFycmF5QnVmZmVyLCBCWVRFX0xFTkdUSCwgJ19sJyk7XG4gICAgYWRkR2V0dGVyKCREYXRhVmlldywgQlVGRkVSLCAnX2InKTtcbiAgICBhZGRHZXR0ZXIoJERhdGFWaWV3LCBCWVRFX0xFTkdUSCwgJ19sJyk7XG4gICAgYWRkR2V0dGVyKCREYXRhVmlldywgQllURV9PRkZTRVQsICdfbycpO1xuICB9XG5cbiAgcmVkZWZpbmVBbGwoJERhdGFWaWV3W1BST1RPVFlQRV0sIHtcbiAgICBnZXRJbnQ4OiBmdW5jdGlvbiBnZXRJbnQ4KGJ5dGVPZmZzZXQpIHtcbiAgICAgIHJldHVybiBnZXQodGhpcywgMSwgYnl0ZU9mZnNldClbMF0gPDwgMjQgPj4gMjQ7XG4gICAgfSxcbiAgICBnZXRVaW50ODogZnVuY3Rpb24gZ2V0VWludDgoYnl0ZU9mZnNldCkge1xuICAgICAgcmV0dXJuIGdldCh0aGlzLCAxLCBieXRlT2Zmc2V0KVswXTtcbiAgICB9LFxuICAgIGdldEludDE2OiBmdW5jdGlvbiBnZXRJbnQxNihieXRlT2Zmc2V0IC8qICwgbGl0dGxlRW5kaWFuICovKSB7XG4gICAgICB2YXIgYnl0ZXMgPSBnZXQodGhpcywgMiwgYnl0ZU9mZnNldCwgYXJndW1lbnRzWzFdKTtcbiAgICAgIHJldHVybiAoYnl0ZXNbMV0gPDwgOCB8IGJ5dGVzWzBdKSA8PCAxNiA+PiAxNjtcbiAgICB9LFxuICAgIGdldFVpbnQxNjogZnVuY3Rpb24gZ2V0VWludDE2KGJ5dGVPZmZzZXQgLyogLCBsaXR0bGVFbmRpYW4gKi8pIHtcbiAgICAgIHZhciBieXRlcyA9IGdldCh0aGlzLCAyLCBieXRlT2Zmc2V0LCBhcmd1bWVudHNbMV0pO1xuICAgICAgcmV0dXJuIGJ5dGVzWzFdIDw8IDggfCBieXRlc1swXTtcbiAgICB9LFxuICAgIGdldEludDMyOiBmdW5jdGlvbiBnZXRJbnQzMihieXRlT2Zmc2V0IC8qICwgbGl0dGxlRW5kaWFuICovKSB7XG4gICAgICByZXR1cm4gdW5wYWNrSTMyKGdldCh0aGlzLCA0LCBieXRlT2Zmc2V0LCBhcmd1bWVudHNbMV0pKTtcbiAgICB9LFxuICAgIGdldFVpbnQzMjogZnVuY3Rpb24gZ2V0VWludDMyKGJ5dGVPZmZzZXQgLyogLCBsaXR0bGVFbmRpYW4gKi8pIHtcbiAgICAgIHJldHVybiB1bnBhY2tJMzIoZ2V0KHRoaXMsIDQsIGJ5dGVPZmZzZXQsIGFyZ3VtZW50c1sxXSkpID4+PiAwO1xuICAgIH0sXG4gICAgZ2V0RmxvYXQzMjogZnVuY3Rpb24gZ2V0RmxvYXQzMihieXRlT2Zmc2V0IC8qICwgbGl0dGxlRW5kaWFuICovKSB7XG4gICAgICByZXR1cm4gdW5wYWNrSUVFRTc1NChnZXQodGhpcywgNCwgYnl0ZU9mZnNldCwgYXJndW1lbnRzWzFdKSwgMjMsIDQpO1xuICAgIH0sXG4gICAgZ2V0RmxvYXQ2NDogZnVuY3Rpb24gZ2V0RmxvYXQ2NChieXRlT2Zmc2V0IC8qICwgbGl0dGxlRW5kaWFuICovKSB7XG4gICAgICByZXR1cm4gdW5wYWNrSUVFRTc1NChnZXQodGhpcywgOCwgYnl0ZU9mZnNldCwgYXJndW1lbnRzWzFdKSwgNTIsIDgpO1xuICAgIH0sXG4gICAgc2V0SW50ODogZnVuY3Rpb24gc2V0SW50OChieXRlT2Zmc2V0LCB2YWx1ZSkge1xuICAgICAgc2V0KHRoaXMsIDEsIGJ5dGVPZmZzZXQsIHBhY2tJOCwgdmFsdWUpO1xuICAgIH0sXG4gICAgc2V0VWludDg6IGZ1bmN0aW9uIHNldFVpbnQ4KGJ5dGVPZmZzZXQsIHZhbHVlKSB7XG4gICAgICBzZXQodGhpcywgMSwgYnl0ZU9mZnNldCwgcGFja0k4LCB2YWx1ZSk7XG4gICAgfSxcbiAgICBzZXRJbnQxNjogZnVuY3Rpb24gc2V0SW50MTYoYnl0ZU9mZnNldCwgdmFsdWUgLyogLCBsaXR0bGVFbmRpYW4gKi8pIHtcbiAgICAgIHNldCh0aGlzLCAyLCBieXRlT2Zmc2V0LCBwYWNrSTE2LCB2YWx1ZSwgYXJndW1lbnRzWzJdKTtcbiAgICB9LFxuICAgIHNldFVpbnQxNjogZnVuY3Rpb24gc2V0VWludDE2KGJ5dGVPZmZzZXQsIHZhbHVlIC8qICwgbGl0dGxlRW5kaWFuICovKSB7XG4gICAgICBzZXQodGhpcywgMiwgYnl0ZU9mZnNldCwgcGFja0kxNiwgdmFsdWUsIGFyZ3VtZW50c1syXSk7XG4gICAgfSxcbiAgICBzZXRJbnQzMjogZnVuY3Rpb24gc2V0SW50MzIoYnl0ZU9mZnNldCwgdmFsdWUgLyogLCBsaXR0bGVFbmRpYW4gKi8pIHtcbiAgICAgIHNldCh0aGlzLCA0LCBieXRlT2Zmc2V0LCBwYWNrSTMyLCB2YWx1ZSwgYXJndW1lbnRzWzJdKTtcbiAgICB9LFxuICAgIHNldFVpbnQzMjogZnVuY3Rpb24gc2V0VWludDMyKGJ5dGVPZmZzZXQsIHZhbHVlIC8qICwgbGl0dGxlRW5kaWFuICovKSB7XG4gICAgICBzZXQodGhpcywgNCwgYnl0ZU9mZnNldCwgcGFja0kzMiwgdmFsdWUsIGFyZ3VtZW50c1syXSk7XG4gICAgfSxcbiAgICBzZXRGbG9hdDMyOiBmdW5jdGlvbiBzZXRGbG9hdDMyKGJ5dGVPZmZzZXQsIHZhbHVlIC8qICwgbGl0dGxlRW5kaWFuICovKSB7XG4gICAgICBzZXQodGhpcywgNCwgYnl0ZU9mZnNldCwgcGFja0YzMiwgdmFsdWUsIGFyZ3VtZW50c1syXSk7XG4gICAgfSxcbiAgICBzZXRGbG9hdDY0OiBmdW5jdGlvbiBzZXRGbG9hdDY0KGJ5dGVPZmZzZXQsIHZhbHVlIC8qICwgbGl0dGxlRW5kaWFuICovKSB7XG4gICAgICBzZXQodGhpcywgOCwgYnl0ZU9mZnNldCwgcGFja0Y2NCwgdmFsdWUsIGFyZ3VtZW50c1syXSk7XG4gICAgfVxuICB9KTtcbn0gZWxzZSB7XG4gIGlmICghZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgICRBcnJheUJ1ZmZlcigxKTtcbiAgfSkgfHwgIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICBuZXcgJEFycmF5QnVmZmVyKC0xKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXdcbiAgfSkgfHwgZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgIG5ldyAkQXJyYXlCdWZmZXIoKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXdcbiAgICBuZXcgJEFycmF5QnVmZmVyKDEuNSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG4gICAgbmV3ICRBcnJheUJ1ZmZlcihOYU4pOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xuICAgIHJldHVybiAkQXJyYXlCdWZmZXIubmFtZSAhPSBBUlJBWV9CVUZGRVI7XG4gIH0pKSB7XG4gICAgJEFycmF5QnVmZmVyID0gZnVuY3Rpb24gQXJyYXlCdWZmZXIobGVuZ3RoKSB7XG4gICAgICBhbkluc3RhbmNlKHRoaXMsICRBcnJheUJ1ZmZlcik7XG4gICAgICByZXR1cm4gbmV3IEJhc2VCdWZmZXIodG9JbmRleChsZW5ndGgpKTtcbiAgICB9O1xuICAgIHZhciBBcnJheUJ1ZmZlclByb3RvID0gJEFycmF5QnVmZmVyW1BST1RPVFlQRV0gPSBCYXNlQnVmZmVyW1BST1RPVFlQRV07XG4gICAgZm9yICh2YXIga2V5cyA9IGdPUE4oQmFzZUJ1ZmZlciksIGogPSAwLCBrZXk7IGtleXMubGVuZ3RoID4gajspIHtcbiAgICAgIGlmICghKChrZXkgPSBrZXlzW2orK10pIGluICRBcnJheUJ1ZmZlcikpIGhpZGUoJEFycmF5QnVmZmVyLCBrZXksIEJhc2VCdWZmZXJba2V5XSk7XG4gICAgfVxuICAgIGlmICghTElCUkFSWSkgQXJyYXlCdWZmZXJQcm90by5jb25zdHJ1Y3RvciA9ICRBcnJheUJ1ZmZlcjtcbiAgfVxuICAvLyBpT1MgU2FmYXJpIDcueCBidWdcbiAgdmFyIHZpZXcgPSBuZXcgJERhdGFWaWV3KG5ldyAkQXJyYXlCdWZmZXIoMikpO1xuICB2YXIgJHNldEludDggPSAkRGF0YVZpZXdbUFJPVE9UWVBFXS5zZXRJbnQ4O1xuICB2aWV3LnNldEludDgoMCwgMjE0NzQ4MzY0OCk7XG4gIHZpZXcuc2V0SW50OCgxLCAyMTQ3NDgzNjQ5KTtcbiAgaWYgKHZpZXcuZ2V0SW50OCgwKSB8fCAhdmlldy5nZXRJbnQ4KDEpKSByZWRlZmluZUFsbCgkRGF0YVZpZXdbUFJPVE9UWVBFXSwge1xuICAgIHNldEludDg6IGZ1bmN0aW9uIHNldEludDgoYnl0ZU9mZnNldCwgdmFsdWUpIHtcbiAgICAgICRzZXRJbnQ4LmNhbGwodGhpcywgYnl0ZU9mZnNldCwgdmFsdWUgPDwgMjQgPj4gMjQpO1xuICAgIH0sXG4gICAgc2V0VWludDg6IGZ1bmN0aW9uIHNldFVpbnQ4KGJ5dGVPZmZzZXQsIHZhbHVlKSB7XG4gICAgICAkc2V0SW50OC5jYWxsKHRoaXMsIGJ5dGVPZmZzZXQsIHZhbHVlIDw8IDI0ID4+IDI0KTtcbiAgICB9XG4gIH0sIHRydWUpO1xufVxuc2V0VG9TdHJpbmdUYWcoJEFycmF5QnVmZmVyLCBBUlJBWV9CVUZGRVIpO1xuc2V0VG9TdHJpbmdUYWcoJERhdGFWaWV3LCBEQVRBX1ZJRVcpO1xuaGlkZSgkRGF0YVZpZXdbUFJPVE9UWVBFXSwgJHR5cGVkLlZJRVcsIHRydWUpO1xuZXhwb3J0c1tBUlJBWV9CVUZGRVJdID0gJEFycmF5QnVmZmVyO1xuZXhwb3J0c1tEQVRBX1ZJRVddID0gJERhdGFWaWV3O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdHlwZWQtYnVmZmVyLmpzIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIGhpZGUgPSByZXF1aXJlKCcuL19oaWRlJyk7XG52YXIgdWlkID0gcmVxdWlyZSgnLi9fdWlkJyk7XG52YXIgVFlQRUQgPSB1aWQoJ3R5cGVkX2FycmF5Jyk7XG52YXIgVklFVyA9IHVpZCgndmlldycpO1xudmFyIEFCViA9ICEhKGdsb2JhbC5BcnJheUJ1ZmZlciAmJiBnbG9iYWwuRGF0YVZpZXcpO1xudmFyIENPTlNUUiA9IEFCVjtcbnZhciBpID0gMDtcbnZhciBsID0gOTtcbnZhciBUeXBlZDtcblxudmFyIFR5cGVkQXJyYXlDb25zdHJ1Y3RvcnMgPSAoXG4gICdJbnQ4QXJyYXksVWludDhBcnJheSxVaW50OENsYW1wZWRBcnJheSxJbnQxNkFycmF5LFVpbnQxNkFycmF5LEludDMyQXJyYXksVWludDMyQXJyYXksRmxvYXQzMkFycmF5LEZsb2F0NjRBcnJheSdcbikuc3BsaXQoJywnKTtcblxud2hpbGUgKGkgPCBsKSB7XG4gIGlmIChUeXBlZCA9IGdsb2JhbFtUeXBlZEFycmF5Q29uc3RydWN0b3JzW2krK11dKSB7XG4gICAgaGlkZShUeXBlZC5wcm90b3R5cGUsIFRZUEVELCB0cnVlKTtcbiAgICBoaWRlKFR5cGVkLnByb3RvdHlwZSwgVklFVywgdHJ1ZSk7XG4gIH0gZWxzZSBDT05TVFIgPSBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIEFCVjogQUJWLFxuICBDT05TVFI6IENPTlNUUixcbiAgVFlQRUQ6IFRZUEVELFxuICBWSUVXOiBWSUVXXG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdHlwZWQuanMiLCJ2YXIgaWQgPSAwO1xudmFyIHB4ID0gTWF0aC5yYW5kb20oKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSkge1xuICByZXR1cm4gJ1N5bWJvbCgnLmNvbmNhdChrZXkgPT09IHVuZGVmaW5lZCA/ICcnIDoga2V5LCAnKV8nLCAoKytpZCArIHB4KS50b1N0cmluZygzNikpO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3VpZC5qcyIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQsIFRZUEUpIHtcbiAgaWYgKCFpc09iamVjdChpdCkgfHwgaXQuX3QgIT09IFRZUEUpIHRocm93IFR5cGVFcnJvcignSW5jb21wYXRpYmxlIHJlY2VpdmVyLCAnICsgVFlQRSArICcgcmVxdWlyZWQhJyk7XG4gIHJldHVybiBpdDtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL192YWxpZGF0ZS1jb2xsZWN0aW9uLmpzIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIGNvcmUgPSByZXF1aXJlKCcuL19jb3JlJyk7XG52YXIgTElCUkFSWSA9IHJlcXVpcmUoJy4vX2xpYnJhcnknKTtcbnZhciB3a3NFeHQgPSByZXF1aXJlKCcuL193a3MtZXh0Jyk7XG52YXIgZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobmFtZSkge1xuICB2YXIgJFN5bWJvbCA9IGNvcmUuU3ltYm9sIHx8IChjb3JlLlN5bWJvbCA9IExJQlJBUlkgPyB7fSA6IGdsb2JhbC5TeW1ib2wgfHwge30pO1xuICBpZiAobmFtZS5jaGFyQXQoMCkgIT0gJ18nICYmICEobmFtZSBpbiAkU3ltYm9sKSkgZGVmaW5lUHJvcGVydHkoJFN5bWJvbCwgbmFtZSwgeyB2YWx1ZTogd2tzRXh0LmYobmFtZSkgfSk7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fd2tzLWRlZmluZS5qcyIsImV4cG9ydHMuZiA9IHJlcXVpcmUoJy4vX3drcycpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fd2tzLWV4dC5qcyIsInZhciBzdG9yZSA9IHJlcXVpcmUoJy4vX3NoYXJlZCcpKCd3a3MnKTtcbnZhciB1aWQgPSByZXF1aXJlKCcuL191aWQnKTtcbnZhciBTeW1ib2wgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5TeW1ib2w7XG52YXIgVVNFX1NZTUJPTCA9IHR5cGVvZiBTeW1ib2wgPT0gJ2Z1bmN0aW9uJztcblxudmFyICRleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4gc3RvcmVbbmFtZV0gfHwgKHN0b3JlW25hbWVdID1cbiAgICBVU0VfU1lNQk9MICYmIFN5bWJvbFtuYW1lXSB8fCAoVVNFX1NZTUJPTCA/IFN5bWJvbCA6IHVpZCkoJ1N5bWJvbC4nICsgbmFtZSkpO1xufTtcblxuJGV4cG9ydHMuc3RvcmUgPSBzdG9yZTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3drcy5qcyIsInZhciBjbGFzc29mID0gcmVxdWlyZSgnLi9fY2xhc3NvZicpO1xudmFyIElURVJBVE9SID0gcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJyk7XG52YXIgSXRlcmF0b3JzID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2NvcmUnKS5nZXRJdGVyYXRvck1ldGhvZCA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoaXQgIT0gdW5kZWZpbmVkKSByZXR1cm4gaXRbSVRFUkFUT1JdXG4gICAgfHwgaXRbJ0BAaXRlcmF0b3InXVxuICAgIHx8IEl0ZXJhdG9yc1tjbGFzc29mKGl0KV07XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9jb3JlLmdldC1pdGVyYXRvci1tZXRob2QuanMiLCIvLyAyMi4xLjMuMyBBcnJheS5wcm90b3R5cGUuY29weVdpdGhpbih0YXJnZXQsIHN0YXJ0LCBlbmQgPSB0aGlzLmxlbmd0aClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5QLCAnQXJyYXknLCB7IGNvcHlXaXRoaW46IHJlcXVpcmUoJy4vX2FycmF5LWNvcHktd2l0aGluJykgfSk7XG5cbnJlcXVpcmUoJy4vX2FkZC10by11bnNjb3BhYmxlcycpKCdjb3B5V2l0aGluJyk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5jb3B5LXdpdGhpbi5qcyIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgJGV2ZXJ5ID0gcmVxdWlyZSgnLi9fYXJyYXktbWV0aG9kcycpKDQpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqICFyZXF1aXJlKCcuL19zdHJpY3QtbWV0aG9kJykoW10uZXZlcnksIHRydWUpLCAnQXJyYXknLCB7XG4gIC8vIDIyLjEuMy41IC8gMTUuNC40LjE2IEFycmF5LnByb3RvdHlwZS5ldmVyeShjYWxsYmFja2ZuIFssIHRoaXNBcmddKVxuICBldmVyeTogZnVuY3Rpb24gZXZlcnkoY2FsbGJhY2tmbiAvKiAsIHRoaXNBcmcgKi8pIHtcbiAgICByZXR1cm4gJGV2ZXJ5KHRoaXMsIGNhbGxiYWNrZm4sIGFyZ3VtZW50c1sxXSk7XG4gIH1cbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuZXZlcnkuanMiLCIvLyAyMi4xLjMuNiBBcnJheS5wcm90b3R5cGUuZmlsbCh2YWx1ZSwgc3RhcnQgPSAwLCBlbmQgPSB0aGlzLmxlbmd0aClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5QLCAnQXJyYXknLCB7IGZpbGw6IHJlcXVpcmUoJy4vX2FycmF5LWZpbGwnKSB9KTtcblxucmVxdWlyZSgnLi9fYWRkLXRvLXVuc2NvcGFibGVzJykoJ2ZpbGwnKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmZpbGwuanMiLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyICRmaWx0ZXIgPSByZXF1aXJlKCcuL19hcnJheS1tZXRob2RzJykoMik7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogIXJlcXVpcmUoJy4vX3N0cmljdC1tZXRob2QnKShbXS5maWx0ZXIsIHRydWUpLCAnQXJyYXknLCB7XG4gIC8vIDIyLjEuMy43IC8gMTUuNC40LjIwIEFycmF5LnByb3RvdHlwZS5maWx0ZXIoY2FsbGJhY2tmbiBbLCB0aGlzQXJnXSlcbiAgZmlsdGVyOiBmdW5jdGlvbiBmaWx0ZXIoY2FsbGJhY2tmbiAvKiAsIHRoaXNBcmcgKi8pIHtcbiAgICByZXR1cm4gJGZpbHRlcih0aGlzLCBjYWxsYmFja2ZuLCBhcmd1bWVudHNbMV0pO1xuICB9XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmZpbHRlci5qcyIsIid1c2Ugc3RyaWN0Jztcbi8vIDIyLjEuMy45IEFycmF5LnByb3RvdHlwZS5maW5kSW5kZXgocHJlZGljYXRlLCB0aGlzQXJnID0gdW5kZWZpbmVkKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciAkZmluZCA9IHJlcXVpcmUoJy4vX2FycmF5LW1ldGhvZHMnKSg2KTtcbnZhciBLRVkgPSAnZmluZEluZGV4JztcbnZhciBmb3JjZWQgPSB0cnVlO1xuLy8gU2hvdWxkbid0IHNraXAgaG9sZXNcbmlmIChLRVkgaW4gW10pIEFycmF5KDEpW0tFWV0oZnVuY3Rpb24gKCkgeyBmb3JjZWQgPSBmYWxzZTsgfSk7XG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIGZvcmNlZCwgJ0FycmF5Jywge1xuICBmaW5kSW5kZXg6IGZ1bmN0aW9uIGZpbmRJbmRleChjYWxsYmFja2ZuIC8qICwgdGhhdCA9IHVuZGVmaW5lZCAqLykge1xuICAgIHJldHVybiAkZmluZCh0aGlzLCBjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gIH1cbn0pO1xucmVxdWlyZSgnLi9fYWRkLXRvLXVuc2NvcGFibGVzJykoS0VZKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmZpbmQtaW5kZXguanMiLCIndXNlIHN0cmljdCc7XG4vLyAyMi4xLjMuOCBBcnJheS5wcm90b3R5cGUuZmluZChwcmVkaWNhdGUsIHRoaXNBcmcgPSB1bmRlZmluZWQpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyICRmaW5kID0gcmVxdWlyZSgnLi9fYXJyYXktbWV0aG9kcycpKDUpO1xudmFyIEtFWSA9ICdmaW5kJztcbnZhciBmb3JjZWQgPSB0cnVlO1xuLy8gU2hvdWxkbid0IHNraXAgaG9sZXNcbmlmIChLRVkgaW4gW10pIEFycmF5KDEpW0tFWV0oZnVuY3Rpb24gKCkgeyBmb3JjZWQgPSBmYWxzZTsgfSk7XG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIGZvcmNlZCwgJ0FycmF5Jywge1xuICBmaW5kOiBmdW5jdGlvbiBmaW5kKGNhbGxiYWNrZm4gLyogLCB0aGF0ID0gdW5kZWZpbmVkICovKSB7XG4gICAgcmV0dXJuICRmaW5kKHRoaXMsIGNhbGxiYWNrZm4sIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgfVxufSk7XG5yZXF1aXJlKCcuL19hZGQtdG8tdW5zY29wYWJsZXMnKShLRVkpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuZmluZC5qcyIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgJGZvckVhY2ggPSByZXF1aXJlKCcuL19hcnJheS1tZXRob2RzJykoMCk7XG52YXIgU1RSSUNUID0gcmVxdWlyZSgnLi9fc3RyaWN0LW1ldGhvZCcpKFtdLmZvckVhY2gsIHRydWUpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqICFTVFJJQ1QsICdBcnJheScsIHtcbiAgLy8gMjIuMS4zLjEwIC8gMTUuNC40LjE4IEFycmF5LnByb3RvdHlwZS5mb3JFYWNoKGNhbGxiYWNrZm4gWywgdGhpc0FyZ10pXG4gIGZvckVhY2g6IGZ1bmN0aW9uIGZvckVhY2goY2FsbGJhY2tmbiAvKiAsIHRoaXNBcmcgKi8pIHtcbiAgICByZXR1cm4gJGZvckVhY2godGhpcywgY2FsbGJhY2tmbiwgYXJndW1lbnRzWzFdKTtcbiAgfVxufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5mb3ItZWFjaC5qcyIsIid1c2Ugc3RyaWN0JztcbnZhciBjdHggPSByZXF1aXJlKCcuL19jdHgnKTtcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcbnZhciBjYWxsID0gcmVxdWlyZSgnLi9faXRlci1jYWxsJyk7XG52YXIgaXNBcnJheUl0ZXIgPSByZXF1aXJlKCcuL19pcy1hcnJheS1pdGVyJyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcbnZhciBjcmVhdGVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX2NyZWF0ZS1wcm9wZXJ0eScpO1xudmFyIGdldEl0ZXJGbiA9IHJlcXVpcmUoJy4vY29yZS5nZXQtaXRlcmF0b3ItbWV0aG9kJyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIXJlcXVpcmUoJy4vX2l0ZXItZGV0ZWN0JykoZnVuY3Rpb24gKGl0ZXIpIHsgQXJyYXkuZnJvbShpdGVyKTsgfSksICdBcnJheScsIHtcbiAgLy8gMjIuMS4yLjEgQXJyYXkuZnJvbShhcnJheUxpa2UsIG1hcGZuID0gdW5kZWZpbmVkLCB0aGlzQXJnID0gdW5kZWZpbmVkKVxuICBmcm9tOiBmdW5jdGlvbiBmcm9tKGFycmF5TGlrZSAvKiAsIG1hcGZuID0gdW5kZWZpbmVkLCB0aGlzQXJnID0gdW5kZWZpbmVkICovKSB7XG4gICAgdmFyIE8gPSB0b09iamVjdChhcnJheUxpa2UpO1xuICAgIHZhciBDID0gdHlwZW9mIHRoaXMgPT0gJ2Z1bmN0aW9uJyA/IHRoaXMgOiBBcnJheTtcbiAgICB2YXIgYUxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgdmFyIG1hcGZuID0gYUxlbiA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQ7XG4gICAgdmFyIG1hcHBpbmcgPSBtYXBmbiAhPT0gdW5kZWZpbmVkO1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgdmFyIGl0ZXJGbiA9IGdldEl0ZXJGbihPKTtcbiAgICB2YXIgbGVuZ3RoLCByZXN1bHQsIHN0ZXAsIGl0ZXJhdG9yO1xuICAgIGlmIChtYXBwaW5nKSBtYXBmbiA9IGN0eChtYXBmbiwgYUxlbiA+IDIgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQsIDIpO1xuICAgIC8vIGlmIG9iamVjdCBpc24ndCBpdGVyYWJsZSBvciBpdCdzIGFycmF5IHdpdGggZGVmYXVsdCBpdGVyYXRvciAtIHVzZSBzaW1wbGUgY2FzZVxuICAgIGlmIChpdGVyRm4gIT0gdW5kZWZpbmVkICYmICEoQyA9PSBBcnJheSAmJiBpc0FycmF5SXRlcihpdGVyRm4pKSkge1xuICAgICAgZm9yIChpdGVyYXRvciA9IGl0ZXJGbi5jYWxsKE8pLCByZXN1bHQgPSBuZXcgQygpOyAhKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmU7IGluZGV4KyspIHtcbiAgICAgICAgY3JlYXRlUHJvcGVydHkocmVzdWx0LCBpbmRleCwgbWFwcGluZyA/IGNhbGwoaXRlcmF0b3IsIG1hcGZuLCBbc3RlcC52YWx1ZSwgaW5kZXhdLCB0cnVlKSA6IHN0ZXAudmFsdWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsZW5ndGggPSB0b0xlbmd0aChPLmxlbmd0aCk7XG4gICAgICBmb3IgKHJlc3VsdCA9IG5ldyBDKGxlbmd0aCk7IGxlbmd0aCA+IGluZGV4OyBpbmRleCsrKSB7XG4gICAgICAgIGNyZWF0ZVByb3BlcnR5KHJlc3VsdCwgaW5kZXgsIG1hcHBpbmcgPyBtYXBmbihPW2luZGV4XSwgaW5kZXgpIDogT1tpbmRleF0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXN1bHQubGVuZ3RoID0gaW5kZXg7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5mcm9tLmpzIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciAkaW5kZXhPZiA9IHJlcXVpcmUoJy4vX2FycmF5LWluY2x1ZGVzJykoZmFsc2UpO1xudmFyICRuYXRpdmUgPSBbXS5pbmRleE9mO1xudmFyIE5FR0FUSVZFX1pFUk8gPSAhISRuYXRpdmUgJiYgMSAvIFsxXS5pbmRleE9mKDEsIC0wKSA8IDA7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogKE5FR0FUSVZFX1pFUk8gfHwgIXJlcXVpcmUoJy4vX3N0cmljdC1tZXRob2QnKSgkbmF0aXZlKSksICdBcnJheScsIHtcbiAgLy8gMjIuMS4zLjExIC8gMTUuNC40LjE0IEFycmF5LnByb3RvdHlwZS5pbmRleE9mKHNlYXJjaEVsZW1lbnQgWywgZnJvbUluZGV4XSlcbiAgaW5kZXhPZjogZnVuY3Rpb24gaW5kZXhPZihzZWFyY2hFbGVtZW50IC8qICwgZnJvbUluZGV4ID0gMCAqLykge1xuICAgIHJldHVybiBORUdBVElWRV9aRVJPXG4gICAgICAvLyBjb252ZXJ0IC0wIHRvICswXG4gICAgICA/ICRuYXRpdmUuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCAwXG4gICAgICA6ICRpbmRleE9mKHRoaXMsIHNlYXJjaEVsZW1lbnQsIGFyZ3VtZW50c1sxXSk7XG4gIH1cbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuaW5kZXgtb2YuanMiLCIvLyAyMi4xLjIuMiAvIDE1LjQuMy4yIEFycmF5LmlzQXJyYXkoYXJnKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdBcnJheScsIHsgaXNBcnJheTogcmVxdWlyZSgnLi9faXMtYXJyYXknKSB9KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmlzLWFycmF5LmpzIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGFkZFRvVW5zY29wYWJsZXMgPSByZXF1aXJlKCcuL19hZGQtdG8tdW5zY29wYWJsZXMnKTtcbnZhciBzdGVwID0gcmVxdWlyZSgnLi9faXRlci1zdGVwJyk7XG52YXIgSXRlcmF0b3JzID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJyk7XG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xuXG4vLyAyMi4xLjMuNCBBcnJheS5wcm90b3R5cGUuZW50cmllcygpXG4vLyAyMi4xLjMuMTMgQXJyYXkucHJvdG90eXBlLmtleXMoKVxuLy8gMjIuMS4zLjI5IEFycmF5LnByb3RvdHlwZS52YWx1ZXMoKVxuLy8gMjIuMS4zLjMwIEFycmF5LnByb3RvdHlwZVtAQGl0ZXJhdG9yXSgpXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2l0ZXItZGVmaW5lJykoQXJyYXksICdBcnJheScsIGZ1bmN0aW9uIChpdGVyYXRlZCwga2luZCkge1xuICB0aGlzLl90ID0gdG9JT2JqZWN0KGl0ZXJhdGVkKTsgLy8gdGFyZ2V0XG4gIHRoaXMuX2kgPSAwOyAgICAgICAgICAgICAgICAgICAvLyBuZXh0IGluZGV4XG4gIHRoaXMuX2sgPSBraW5kOyAgICAgICAgICAgICAgICAvLyBraW5kXG4vLyAyMi4xLjUuMi4xICVBcnJheUl0ZXJhdG9yUHJvdG90eXBlJS5uZXh0KClcbn0sIGZ1bmN0aW9uICgpIHtcbiAgdmFyIE8gPSB0aGlzLl90O1xuICB2YXIga2luZCA9IHRoaXMuX2s7XG4gIHZhciBpbmRleCA9IHRoaXMuX2krKztcbiAgaWYgKCFPIHx8IGluZGV4ID49IE8ubGVuZ3RoKSB7XG4gICAgdGhpcy5fdCA9IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gc3RlcCgxKTtcbiAgfVxuICBpZiAoa2luZCA9PSAna2V5cycpIHJldHVybiBzdGVwKDAsIGluZGV4KTtcbiAgaWYgKGtpbmQgPT0gJ3ZhbHVlcycpIHJldHVybiBzdGVwKDAsIE9baW5kZXhdKTtcbiAgcmV0dXJuIHN0ZXAoMCwgW2luZGV4LCBPW2luZGV4XV0pO1xufSwgJ3ZhbHVlcycpO1xuXG4vLyBhcmd1bWVudHNMaXN0W0BAaXRlcmF0b3JdIGlzICVBcnJheVByb3RvX3ZhbHVlcyUgKDkuNC40LjYsIDkuNC40LjcpXG5JdGVyYXRvcnMuQXJndW1lbnRzID0gSXRlcmF0b3JzLkFycmF5O1xuXG5hZGRUb1Vuc2NvcGFibGVzKCdrZXlzJyk7XG5hZGRUb1Vuc2NvcGFibGVzKCd2YWx1ZXMnKTtcbmFkZFRvVW5zY29wYWJsZXMoJ2VudHJpZXMnKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5Lml0ZXJhdG9yLmpzIiwiJ3VzZSBzdHJpY3QnO1xuLy8gMjIuMS4zLjEzIEFycmF5LnByb3RvdHlwZS5qb2luKHNlcGFyYXRvcilcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xudmFyIGFycmF5Sm9pbiA9IFtdLmpvaW47XG5cbi8vIGZhbGxiYWNrIGZvciBub3QgYXJyYXktbGlrZSBzdHJpbmdzXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIChyZXF1aXJlKCcuL19pb2JqZWN0JykgIT0gT2JqZWN0IHx8ICFyZXF1aXJlKCcuL19zdHJpY3QtbWV0aG9kJykoYXJyYXlKb2luKSksICdBcnJheScsIHtcbiAgam9pbjogZnVuY3Rpb24gam9pbihzZXBhcmF0b3IpIHtcbiAgICByZXR1cm4gYXJyYXlKb2luLmNhbGwodG9JT2JqZWN0KHRoaXMpLCBzZXBhcmF0b3IgPT09IHVuZGVmaW5lZCA/ICcsJyA6IHNlcGFyYXRvcik7XG4gIH1cbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuam9pbi5qcyIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xudmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xudmFyICRuYXRpdmUgPSBbXS5sYXN0SW5kZXhPZjtcbnZhciBORUdBVElWRV9aRVJPID0gISEkbmF0aXZlICYmIDEgLyBbMV0ubGFzdEluZGV4T2YoMSwgLTApIDwgMDtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAoTkVHQVRJVkVfWkVSTyB8fCAhcmVxdWlyZSgnLi9fc3RyaWN0LW1ldGhvZCcpKCRuYXRpdmUpKSwgJ0FycmF5Jywge1xuICAvLyAyMi4xLjMuMTQgLyAxNS40LjQuMTUgQXJyYXkucHJvdG90eXBlLmxhc3RJbmRleE9mKHNlYXJjaEVsZW1lbnQgWywgZnJvbUluZGV4XSlcbiAgbGFzdEluZGV4T2Y6IGZ1bmN0aW9uIGxhc3RJbmRleE9mKHNlYXJjaEVsZW1lbnQgLyogLCBmcm9tSW5kZXggPSBAWyotMV0gKi8pIHtcbiAgICAvLyBjb252ZXJ0IC0wIHRvICswXG4gICAgaWYgKE5FR0FUSVZFX1pFUk8pIHJldHVybiAkbmF0aXZlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgMDtcbiAgICB2YXIgTyA9IHRvSU9iamVjdCh0aGlzKTtcbiAgICB2YXIgbGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpO1xuICAgIHZhciBpbmRleCA9IGxlbmd0aCAtIDE7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSBpbmRleCA9IE1hdGgubWluKGluZGV4LCB0b0ludGVnZXIoYXJndW1lbnRzWzFdKSk7XG4gICAgaWYgKGluZGV4IDwgMCkgaW5kZXggPSBsZW5ndGggKyBpbmRleDtcbiAgICBmb3IgKDtpbmRleCA+PSAwOyBpbmRleC0tKSBpZiAoaW5kZXggaW4gTykgaWYgKE9baW5kZXhdID09PSBzZWFyY2hFbGVtZW50KSByZXR1cm4gaW5kZXggfHwgMDtcbiAgICByZXR1cm4gLTE7XG4gIH1cbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkubGFzdC1pbmRleC1vZi5qcyIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgJG1hcCA9IHJlcXVpcmUoJy4vX2FycmF5LW1ldGhvZHMnKSgxKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAhcmVxdWlyZSgnLi9fc3RyaWN0LW1ldGhvZCcpKFtdLm1hcCwgdHJ1ZSksICdBcnJheScsIHtcbiAgLy8gMjIuMS4zLjE1IC8gMTUuNC40LjE5IEFycmF5LnByb3RvdHlwZS5tYXAoY2FsbGJhY2tmbiBbLCB0aGlzQXJnXSlcbiAgbWFwOiBmdW5jdGlvbiBtYXAoY2FsbGJhY2tmbiAvKiAsIHRoaXNBcmcgKi8pIHtcbiAgICByZXR1cm4gJG1hcCh0aGlzLCBjYWxsYmFja2ZuLCBhcmd1bWVudHNbMV0pO1xuICB9XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5Lm1hcC5qcyIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgY3JlYXRlUHJvcGVydHkgPSByZXF1aXJlKCcuL19jcmVhdGUtcHJvcGVydHknKTtcblxuLy8gV2ViS2l0IEFycmF5Lm9mIGlzbid0IGdlbmVyaWNcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEYoKSB7IC8qIGVtcHR5ICovIH1cbiAgcmV0dXJuICEoQXJyYXkub2YuY2FsbChGKSBpbnN0YW5jZW9mIEYpO1xufSksICdBcnJheScsIHtcbiAgLy8gMjIuMS4yLjMgQXJyYXkub2YoIC4uLml0ZW1zKVxuICBvZjogZnVuY3Rpb24gb2YoLyogLi4uYXJncyAqLykge1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgdmFyIGFMZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHZhciByZXN1bHQgPSBuZXcgKHR5cGVvZiB0aGlzID09ICdmdW5jdGlvbicgPyB0aGlzIDogQXJyYXkpKGFMZW4pO1xuICAgIHdoaWxlIChhTGVuID4gaW5kZXgpIGNyZWF0ZVByb3BlcnR5KHJlc3VsdCwgaW5kZXgsIGFyZ3VtZW50c1tpbmRleCsrXSk7XG4gICAgcmVzdWx0Lmxlbmd0aCA9IGFMZW47XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5vZi5qcyIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgJHJlZHVjZSA9IHJlcXVpcmUoJy4vX2FycmF5LXJlZHVjZScpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqICFyZXF1aXJlKCcuL19zdHJpY3QtbWV0aG9kJykoW10ucmVkdWNlUmlnaHQsIHRydWUpLCAnQXJyYXknLCB7XG4gIC8vIDIyLjEuMy4xOSAvIDE1LjQuNC4yMiBBcnJheS5wcm90b3R5cGUucmVkdWNlUmlnaHQoY2FsbGJhY2tmbiBbLCBpbml0aWFsVmFsdWVdKVxuICByZWR1Y2VSaWdodDogZnVuY3Rpb24gcmVkdWNlUmlnaHQoY2FsbGJhY2tmbiAvKiAsIGluaXRpYWxWYWx1ZSAqLykge1xuICAgIHJldHVybiAkcmVkdWNlKHRoaXMsIGNhbGxiYWNrZm4sIGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3VtZW50c1sxXSwgdHJ1ZSk7XG4gIH1cbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkucmVkdWNlLXJpZ2h0LmpzIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciAkcmVkdWNlID0gcmVxdWlyZSgnLi9fYXJyYXktcmVkdWNlJyk7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogIXJlcXVpcmUoJy4vX3N0cmljdC1tZXRob2QnKShbXS5yZWR1Y2UsIHRydWUpLCAnQXJyYXknLCB7XG4gIC8vIDIyLjEuMy4xOCAvIDE1LjQuNC4yMSBBcnJheS5wcm90b3R5cGUucmVkdWNlKGNhbGxiYWNrZm4gWywgaW5pdGlhbFZhbHVlXSlcbiAgcmVkdWNlOiBmdW5jdGlvbiByZWR1Y2UoY2FsbGJhY2tmbiAvKiAsIGluaXRpYWxWYWx1ZSAqLykge1xuICAgIHJldHVybiAkcmVkdWNlKHRoaXMsIGNhbGxiYWNrZm4sIGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3VtZW50c1sxXSwgZmFsc2UpO1xuICB9XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LnJlZHVjZS5qcyIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgaHRtbCA9IHJlcXVpcmUoJy4vX2h0bWwnKTtcbnZhciBjb2YgPSByZXF1aXJlKCcuL19jb2YnKTtcbnZhciB0b0Fic29sdXRlSW5kZXggPSByZXF1aXJlKCcuL190by1hYnNvbHV0ZS1pbmRleCcpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG52YXIgYXJyYXlTbGljZSA9IFtdLnNsaWNlO1xuXG4vLyBmYWxsYmFjayBmb3Igbm90IGFycmF5LWxpa2UgRVMzIHN0cmluZ3MgYW5kIERPTSBvYmplY3RzXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIHJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICBpZiAoaHRtbCkgYXJyYXlTbGljZS5jYWxsKGh0bWwpO1xufSksICdBcnJheScsIHtcbiAgc2xpY2U6IGZ1bmN0aW9uIHNsaWNlKGJlZ2luLCBlbmQpIHtcbiAgICB2YXIgbGVuID0gdG9MZW5ndGgodGhpcy5sZW5ndGgpO1xuICAgIHZhciBrbGFzcyA9IGNvZih0aGlzKTtcbiAgICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbiA6IGVuZDtcbiAgICBpZiAoa2xhc3MgPT0gJ0FycmF5JykgcmV0dXJuIGFycmF5U2xpY2UuY2FsbCh0aGlzLCBiZWdpbiwgZW5kKTtcbiAgICB2YXIgc3RhcnQgPSB0b0Fic29sdXRlSW5kZXgoYmVnaW4sIGxlbik7XG4gICAgdmFyIHVwVG8gPSB0b0Fic29sdXRlSW5kZXgoZW5kLCBsZW4pO1xuICAgIHZhciBzaXplID0gdG9MZW5ndGgodXBUbyAtIHN0YXJ0KTtcbiAgICB2YXIgY2xvbmVkID0gQXJyYXkoc2l6ZSk7XG4gICAgdmFyIGkgPSAwO1xuICAgIGZvciAoOyBpIDwgc2l6ZTsgaSsrKSBjbG9uZWRbaV0gPSBrbGFzcyA9PSAnU3RyaW5nJ1xuICAgICAgPyB0aGlzLmNoYXJBdChzdGFydCArIGkpXG4gICAgICA6IHRoaXNbc3RhcnQgKyBpXTtcbiAgICByZXR1cm4gY2xvbmVkO1xuICB9XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LnNsaWNlLmpzIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciAkc29tZSA9IHJlcXVpcmUoJy4vX2FycmF5LW1ldGhvZHMnKSgzKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAhcmVxdWlyZSgnLi9fc3RyaWN0LW1ldGhvZCcpKFtdLnNvbWUsIHRydWUpLCAnQXJyYXknLCB7XG4gIC8vIDIyLjEuMy4yMyAvIDE1LjQuNC4xNyBBcnJheS5wcm90b3R5cGUuc29tZShjYWxsYmFja2ZuIFssIHRoaXNBcmddKVxuICBzb21lOiBmdW5jdGlvbiBzb21lKGNhbGxiYWNrZm4gLyogLCB0aGlzQXJnICovKSB7XG4gICAgcmV0dXJuICRzb21lKHRoaXMsIGNhbGxiYWNrZm4sIGFyZ3VtZW50c1sxXSk7XG4gIH1cbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuc29tZS5qcyIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuL19mYWlscycpO1xudmFyICRzb3J0ID0gW10uc29ydDtcbnZhciB0ZXN0ID0gWzEsIDIsIDNdO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIChmYWlscyhmdW5jdGlvbiAoKSB7XG4gIC8vIElFOC1cbiAgdGVzdC5zb3J0KHVuZGVmaW5lZCk7XG59KSB8fCAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICAvLyBWOCBidWdcbiAgdGVzdC5zb3J0KG51bGwpO1xuICAvLyBPbGQgV2ViS2l0XG59KSB8fCAhcmVxdWlyZSgnLi9fc3RyaWN0LW1ldGhvZCcpKCRzb3J0KSksICdBcnJheScsIHtcbiAgLy8gMjIuMS4zLjI1IEFycmF5LnByb3RvdHlwZS5zb3J0KGNvbXBhcmVmbilcbiAgc29ydDogZnVuY3Rpb24gc29ydChjb21wYXJlZm4pIHtcbiAgICByZXR1cm4gY29tcGFyZWZuID09PSB1bmRlZmluZWRcbiAgICAgID8gJHNvcnQuY2FsbCh0b09iamVjdCh0aGlzKSlcbiAgICAgIDogJHNvcnQuY2FsbCh0b09iamVjdCh0aGlzKSwgYUZ1bmN0aW9uKGNvbXBhcmVmbikpO1xuICB9XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LnNvcnQuanMiLCJyZXF1aXJlKCcuL19zZXQtc3BlY2llcycpKCdBcnJheScpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuc3BlY2llcy5qcyIsIi8vIDIwLjMuMy4xIC8gMTUuOS40LjQgRGF0ZS5ub3coKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdEYXRlJywgeyBub3c6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBEYXRlKCkuZ2V0VGltZSgpOyB9IH0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuZGF0ZS5ub3cuanMiLCIvLyAyMC4zLjQuMzYgLyAxNS45LjUuNDMgRGF0ZS5wcm90b3R5cGUudG9JU09TdHJpbmcoKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciB0b0lTT1N0cmluZyA9IHJlcXVpcmUoJy4vX2RhdGUtdG8taXNvLXN0cmluZycpO1xuXG4vLyBQaGFudG9tSlMgLyBvbGQgV2ViS2l0IGhhcyBhIGJyb2tlbiBpbXBsZW1lbnRhdGlvbnNcbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogKERhdGUucHJvdG90eXBlLnRvSVNPU3RyaW5nICE9PSB0b0lTT1N0cmluZyksICdEYXRlJywge1xuICB0b0lTT1N0cmluZzogdG9JU09TdHJpbmdcbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuZGF0ZS50by1pc28tc3RyaW5nLmpzIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpO1xudmFyIHRvUHJpbWl0aXZlID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJyk7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBuZXcgRGF0ZShOYU4pLnRvSlNPTigpICE9PSBudWxsXG4gICAgfHwgRGF0ZS5wcm90b3R5cGUudG9KU09OLmNhbGwoeyB0b0lTT1N0cmluZzogZnVuY3Rpb24gKCkgeyByZXR1cm4gMTsgfSB9KSAhPT0gMTtcbn0pLCAnRGF0ZScsIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG4gIHRvSlNPTjogZnVuY3Rpb24gdG9KU09OKGtleSkge1xuICAgIHZhciBPID0gdG9PYmplY3QodGhpcyk7XG4gICAgdmFyIHB2ID0gdG9QcmltaXRpdmUoTyk7XG4gICAgcmV0dXJuIHR5cGVvZiBwdiA9PSAnbnVtYmVyJyAmJiAhaXNGaW5pdGUocHYpID8gbnVsbCA6IE8udG9JU09TdHJpbmcoKTtcbiAgfVxufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5kYXRlLnRvLWpzb24uanMiLCJ2YXIgVE9fUFJJTUlUSVZFID0gcmVxdWlyZSgnLi9fd2tzJykoJ3RvUHJpbWl0aXZlJyk7XG52YXIgcHJvdG8gPSBEYXRlLnByb3RvdHlwZTtcblxuaWYgKCEoVE9fUFJJTUlUSVZFIGluIHByb3RvKSkgcmVxdWlyZSgnLi9faGlkZScpKHByb3RvLCBUT19QUklNSVRJVkUsIHJlcXVpcmUoJy4vX2RhdGUtdG8tcHJpbWl0aXZlJykpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuZGF0ZS50by1wcmltaXRpdmUuanMiLCJ2YXIgRGF0ZVByb3RvID0gRGF0ZS5wcm90b3R5cGU7XG52YXIgSU5WQUxJRF9EQVRFID0gJ0ludmFsaWQgRGF0ZSc7XG52YXIgVE9fU1RSSU5HID0gJ3RvU3RyaW5nJztcbnZhciAkdG9TdHJpbmcgPSBEYXRlUHJvdG9bVE9fU1RSSU5HXTtcbnZhciBnZXRUaW1lID0gRGF0ZVByb3RvLmdldFRpbWU7XG5pZiAobmV3IERhdGUoTmFOKSArICcnICE9IElOVkFMSURfREFURSkge1xuICByZXF1aXJlKCcuL19yZWRlZmluZScpKERhdGVQcm90bywgVE9fU1RSSU5HLCBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICB2YXIgdmFsdWUgPSBnZXRUaW1lLmNhbGwodGhpcyk7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuICAgIHJldHVybiB2YWx1ZSA9PT0gdmFsdWUgPyAkdG9TdHJpbmcuY2FsbCh0aGlzKSA6IElOVkFMSURfREFURTtcbiAgfSk7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5kYXRlLnRvLXN0cmluZy5qcyIsIi8vIDE5LjIuMy4yIC8gMTUuMy40LjUgRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQodGhpc0FyZywgYXJncy4uLilcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5QLCAnRnVuY3Rpb24nLCB7IGJpbmQ6IHJlcXVpcmUoJy4vX2JpbmQnKSB9KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmZ1bmN0aW9uLmJpbmQuanMiLCIndXNlIHN0cmljdCc7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBnZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4vX29iamVjdC1ncG8nKTtcbnZhciBIQVNfSU5TVEFOQ0UgPSByZXF1aXJlKCcuL193a3MnKSgnaGFzSW5zdGFuY2UnKTtcbnZhciBGdW5jdGlvblByb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlO1xuLy8gMTkuMi4zLjYgRnVuY3Rpb24ucHJvdG90eXBlW0BAaGFzSW5zdGFuY2VdKFYpXG5pZiAoIShIQVNfSU5TVEFOQ0UgaW4gRnVuY3Rpb25Qcm90bykpIHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmYoRnVuY3Rpb25Qcm90bywgSEFTX0lOU1RBTkNFLCB7IHZhbHVlOiBmdW5jdGlvbiAoTykge1xuICBpZiAodHlwZW9mIHRoaXMgIT0gJ2Z1bmN0aW9uJyB8fCAhaXNPYmplY3QoTykpIHJldHVybiBmYWxzZTtcbiAgaWYgKCFpc09iamVjdCh0aGlzLnByb3RvdHlwZSkpIHJldHVybiBPIGluc3RhbmNlb2YgdGhpcztcbiAgLy8gZm9yIGVudmlyb25tZW50IHcvbyBuYXRpdmUgYEBAaGFzSW5zdGFuY2VgIGxvZ2ljIGVub3VnaCBgaW5zdGFuY2VvZmAsIGJ1dCBhZGQgdGhpczpcbiAgd2hpbGUgKE8gPSBnZXRQcm90b3R5cGVPZihPKSkgaWYgKHRoaXMucHJvdG90eXBlID09PSBPKSByZXR1cm4gdHJ1ZTtcbiAgcmV0dXJuIGZhbHNlO1xufSB9KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmZ1bmN0aW9uLmhhcy1pbnN0YW5jZS5qcyIsInZhciBkUCA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmY7XG52YXIgRlByb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlO1xudmFyIG5hbWVSRSA9IC9eXFxzKmZ1bmN0aW9uIChbXiAoXSopLztcbnZhciBOQU1FID0gJ25hbWUnO1xuXG4vLyAxOS4yLjQuMiBuYW1lXG5OQU1FIGluIEZQcm90byB8fCByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpICYmIGRQKEZQcm90bywgTkFNRSwge1xuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gKCcnICsgdGhpcykubWF0Y2gobmFtZVJFKVsxXTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuICB9XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmZ1bmN0aW9uLm5hbWUuanMiLCIndXNlIHN0cmljdCc7XG52YXIgc3Ryb25nID0gcmVxdWlyZSgnLi9fY29sbGVjdGlvbi1zdHJvbmcnKTtcbnZhciB2YWxpZGF0ZSA9IHJlcXVpcmUoJy4vX3ZhbGlkYXRlLWNvbGxlY3Rpb24nKTtcbnZhciBNQVAgPSAnTWFwJztcblxuLy8gMjMuMSBNYXAgT2JqZWN0c1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19jb2xsZWN0aW9uJykoTUFQLCBmdW5jdGlvbiAoZ2V0KSB7XG4gIHJldHVybiBmdW5jdGlvbiBNYXAoKSB7IHJldHVybiBnZXQodGhpcywgYXJndW1lbnRzLmxlbmd0aCA+IDAgPyBhcmd1bWVudHNbMF0gOiB1bmRlZmluZWQpOyB9O1xufSwge1xuICAvLyAyMy4xLjMuNiBNYXAucHJvdG90eXBlLmdldChrZXkpXG4gIGdldDogZnVuY3Rpb24gZ2V0KGtleSkge1xuICAgIHZhciBlbnRyeSA9IHN0cm9uZy5nZXRFbnRyeSh2YWxpZGF0ZSh0aGlzLCBNQVApLCBrZXkpO1xuICAgIHJldHVybiBlbnRyeSAmJiBlbnRyeS52O1xuICB9LFxuICAvLyAyMy4xLjMuOSBNYXAucHJvdG90eXBlLnNldChrZXksIHZhbHVlKVxuICBzZXQ6IGZ1bmN0aW9uIHNldChrZXksIHZhbHVlKSB7XG4gICAgcmV0dXJuIHN0cm9uZy5kZWYodmFsaWRhdGUodGhpcywgTUFQKSwga2V5ID09PSAwID8gMCA6IGtleSwgdmFsdWUpO1xuICB9XG59LCBzdHJvbmcsIHRydWUpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWFwLmpzIiwiLy8gMjAuMi4yLjMgTWF0aC5hY29zaCh4KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBsb2cxcCA9IHJlcXVpcmUoJy4vX21hdGgtbG9nMXAnKTtcbnZhciBzcXJ0ID0gTWF0aC5zcXJ0O1xudmFyICRhY29zaCA9IE1hdGguYWNvc2g7XG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogISgkYWNvc2hcbiAgLy8gVjggYnVnOiBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzUwOVxuICAmJiBNYXRoLmZsb29yKCRhY29zaChOdW1iZXIuTUFYX1ZBTFVFKSkgPT0gNzEwXG4gIC8vIFRvciBCcm93c2VyIGJ1ZzogTWF0aC5hY29zaChJbmZpbml0eSkgLT4gTmFOXG4gICYmICRhY29zaChJbmZpbml0eSkgPT0gSW5maW5pdHlcbiksICdNYXRoJywge1xuICBhY29zaDogZnVuY3Rpb24gYWNvc2goeCkge1xuICAgIHJldHVybiAoeCA9ICt4KSA8IDEgPyBOYU4gOiB4ID4gOTQ5MDYyNjUuNjI0MjUxNTZcbiAgICAgID8gTWF0aC5sb2coeCkgKyBNYXRoLkxOMlxuICAgICAgOiBsb2cxcCh4IC0gMSArIHNxcnQoeCAtIDEpICogc3FydCh4ICsgMSkpO1xuICB9XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguYWNvc2guanMiLCIvLyAyMC4yLjIuNSBNYXRoLmFzaW5oKHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyICRhc2luaCA9IE1hdGguYXNpbmg7XG5cbmZ1bmN0aW9uIGFzaW5oKHgpIHtcbiAgcmV0dXJuICFpc0Zpbml0ZSh4ID0gK3gpIHx8IHggPT0gMCA/IHggOiB4IDwgMCA/IC1hc2luaCgteCkgOiBNYXRoLmxvZyh4ICsgTWF0aC5zcXJ0KHggKiB4ICsgMSkpO1xufVxuXG4vLyBUb3IgQnJvd3NlciBidWc6IE1hdGguYXNpbmgoMCkgLT4gLTBcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogISgkYXNpbmggJiYgMSAvICRhc2luaCgwKSA+IDApLCAnTWF0aCcsIHsgYXNpbmg6IGFzaW5oIH0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5hc2luaC5qcyIsIi8vIDIwLjIuMi43IE1hdGguYXRhbmgoeClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgJGF0YW5oID0gTWF0aC5hdGFuaDtcblxuLy8gVG9yIEJyb3dzZXIgYnVnOiBNYXRoLmF0YW5oKC0wKSAtPiAwXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICEoJGF0YW5oICYmIDEgLyAkYXRhbmgoLTApIDwgMCksICdNYXRoJywge1xuICBhdGFuaDogZnVuY3Rpb24gYXRhbmgoeCkge1xuICAgIHJldHVybiAoeCA9ICt4KSA9PSAwID8geCA6IE1hdGgubG9nKCgxICsgeCkgLyAoMSAtIHgpKSAvIDI7XG4gIH1cbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5hdGFuaC5qcyIsIi8vIDIwLjIuMi45IE1hdGguY2JydCh4KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBzaWduID0gcmVxdWlyZSgnLi9fbWF0aC1zaWduJyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHtcbiAgY2JydDogZnVuY3Rpb24gY2JydCh4KSB7XG4gICAgcmV0dXJuIHNpZ24oeCA9ICt4KSAqIE1hdGgucG93KE1hdGguYWJzKHgpLCAxIC8gMyk7XG4gIH1cbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5jYnJ0LmpzIiwiLy8gMjAuMi4yLjExIE1hdGguY2x6MzIoeClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHtcbiAgY2x6MzI6IGZ1bmN0aW9uIGNsejMyKHgpIHtcbiAgICByZXR1cm4gKHggPj4+PSAwKSA/IDMxIC0gTWF0aC5mbG9vcihNYXRoLmxvZyh4ICsgMC41KSAqIE1hdGguTE9HMkUpIDogMzI7XG4gIH1cbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5jbHozMi5qcyIsIi8vIDIwLjIuMi4xMiBNYXRoLmNvc2goeClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgZXhwID0gTWF0aC5leHA7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHtcbiAgY29zaDogZnVuY3Rpb24gY29zaCh4KSB7XG4gICAgcmV0dXJuIChleHAoeCA9ICt4KSArIGV4cCgteCkpIC8gMjtcbiAgfVxufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmNvc2guanMiLCIvLyAyMC4yLjIuMTQgTWF0aC5leHBtMSh4KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciAkZXhwbTEgPSByZXF1aXJlKCcuL19tYXRoLWV4cG0xJyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogKCRleHBtMSAhPSBNYXRoLmV4cG0xKSwgJ01hdGgnLCB7IGV4cG0xOiAkZXhwbTEgfSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmV4cG0xLmpzIiwiLy8gMjAuMi4yLjE2IE1hdGguZnJvdW5kKHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7IGZyb3VuZDogcmVxdWlyZSgnLi9fbWF0aC1mcm91bmQnKSB9KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguZnJvdW5kLmpzIiwiLy8gMjAuMi4yLjE3IE1hdGguaHlwb3QoW3ZhbHVlMVssIHZhbHVlMlssIOKApiBdXV0pXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGFicyA9IE1hdGguYWJzO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7XG4gIGh5cG90OiBmdW5jdGlvbiBoeXBvdCh2YWx1ZTEsIHZhbHVlMikgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgdmFyIHN1bSA9IDA7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBhTGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB2YXIgbGFyZyA9IDA7XG4gICAgdmFyIGFyZywgZGl2O1xuICAgIHdoaWxlIChpIDwgYUxlbikge1xuICAgICAgYXJnID0gYWJzKGFyZ3VtZW50c1tpKytdKTtcbiAgICAgIGlmIChsYXJnIDwgYXJnKSB7XG4gICAgICAgIGRpdiA9IGxhcmcgLyBhcmc7XG4gICAgICAgIHN1bSA9IHN1bSAqIGRpdiAqIGRpdiArIDE7XG4gICAgICAgIGxhcmcgPSBhcmc7XG4gICAgICB9IGVsc2UgaWYgKGFyZyA+IDApIHtcbiAgICAgICAgZGl2ID0gYXJnIC8gbGFyZztcbiAgICAgICAgc3VtICs9IGRpdiAqIGRpdjtcbiAgICAgIH0gZWxzZSBzdW0gKz0gYXJnO1xuICAgIH1cbiAgICByZXR1cm4gbGFyZyA9PT0gSW5maW5pdHkgPyBJbmZpbml0eSA6IGxhcmcgKiBNYXRoLnNxcnQoc3VtKTtcbiAgfVxufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmh5cG90LmpzIiwiLy8gMjAuMi4yLjE4IE1hdGguaW11bCh4LCB5KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciAkaW11bCA9IE1hdGguaW11bDtcblxuLy8gc29tZSBXZWJLaXQgdmVyc2lvbnMgZmFpbHMgd2l0aCBiaWcgbnVtYmVycywgc29tZSBoYXMgd3JvbmcgYXJpdHlcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAkaW11bCgweGZmZmZmZmZmLCA1KSAhPSAtNSB8fCAkaW11bC5sZW5ndGggIT0gMjtcbn0pLCAnTWF0aCcsIHtcbiAgaW11bDogZnVuY3Rpb24gaW11bCh4LCB5KSB7XG4gICAgdmFyIFVJTlQxNiA9IDB4ZmZmZjtcbiAgICB2YXIgeG4gPSAreDtcbiAgICB2YXIgeW4gPSAreTtcbiAgICB2YXIgeGwgPSBVSU5UMTYgJiB4bjtcbiAgICB2YXIgeWwgPSBVSU5UMTYgJiB5bjtcbiAgICByZXR1cm4gMCB8IHhsICogeWwgKyAoKFVJTlQxNiAmIHhuID4+PiAxNikgKiB5bCArIHhsICogKFVJTlQxNiAmIHluID4+PiAxNikgPDwgMTYgPj4+IDApO1xuICB9XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguaW11bC5qcyIsIi8vIDIwLjIuMi4yMSBNYXRoLmxvZzEwKHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7XG4gIGxvZzEwOiBmdW5jdGlvbiBsb2cxMCh4KSB7XG4gICAgcmV0dXJuIE1hdGgubG9nKHgpICogTWF0aC5MT0cxMEU7XG4gIH1cbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5sb2cxMC5qcyIsIi8vIDIwLjIuMi4yMCBNYXRoLmxvZzFwKHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7IGxvZzFwOiByZXF1aXJlKCcuL19tYXRoLWxvZzFwJykgfSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmxvZzFwLmpzIiwiLy8gMjAuMi4yLjIyIE1hdGgubG9nMih4KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywge1xuICBsb2cyOiBmdW5jdGlvbiBsb2cyKHgpIHtcbiAgICByZXR1cm4gTWF0aC5sb2coeCkgLyBNYXRoLkxOMjtcbiAgfVxufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmxvZzIuanMiLCIvLyAyMC4yLjIuMjggTWF0aC5zaWduKHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7IHNpZ246IHJlcXVpcmUoJy4vX21hdGgtc2lnbicpIH0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5zaWduLmpzIiwiLy8gMjAuMi4yLjMwIE1hdGguc2luaCh4KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBleHBtMSA9IHJlcXVpcmUoJy4vX21hdGgtZXhwbTEnKTtcbnZhciBleHAgPSBNYXRoLmV4cDtcblxuLy8gVjggbmVhciBDaHJvbWl1bSAzOCBoYXMgYSBwcm9ibGVtIHdpdGggdmVyeSBzbWFsbCBudW1iZXJzXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqIHJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gIU1hdGguc2luaCgtMmUtMTcpICE9IC0yZS0xNztcbn0pLCAnTWF0aCcsIHtcbiAgc2luaDogZnVuY3Rpb24gc2luaCh4KSB7XG4gICAgcmV0dXJuIE1hdGguYWJzKHggPSAreCkgPCAxXG4gICAgICA/IChleHBtMSh4KSAtIGV4cG0xKC14KSkgLyAyXG4gICAgICA6IChleHAoeCAtIDEpIC0gZXhwKC14IC0gMSkpICogKE1hdGguRSAvIDIpO1xuICB9XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguc2luaC5qcyIsIi8vIDIwLjIuMi4zMyBNYXRoLnRhbmgoeClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgZXhwbTEgPSByZXF1aXJlKCcuL19tYXRoLWV4cG0xJyk7XG52YXIgZXhwID0gTWF0aC5leHA7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHtcbiAgdGFuaDogZnVuY3Rpb24gdGFuaCh4KSB7XG4gICAgdmFyIGEgPSBleHBtMSh4ID0gK3gpO1xuICAgIHZhciBiID0gZXhwbTEoLXgpO1xuICAgIHJldHVybiBhID09IEluZmluaXR5ID8gMSA6IGIgPT0gSW5maW5pdHkgPyAtMSA6IChhIC0gYikgLyAoZXhwKHgpICsgZXhwKC14KSk7XG4gIH1cbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC50YW5oLmpzIiwiLy8gMjAuMi4yLjM0IE1hdGgudHJ1bmMoeClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHtcbiAgdHJ1bmM6IGZ1bmN0aW9uIHRydW5jKGl0KSB7XG4gICAgcmV0dXJuIChpdCA+IDAgPyBNYXRoLmZsb29yIDogTWF0aC5jZWlsKShpdCk7XG4gIH1cbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC50cnVuYy5qcyIsIid1c2Ugc3RyaWN0JztcbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciBjb2YgPSByZXF1aXJlKCcuL19jb2YnKTtcbnZhciBpbmhlcml0SWZSZXF1aXJlZCA9IHJlcXVpcmUoJy4vX2luaGVyaXQtaWYtcmVxdWlyZWQnKTtcbnZhciB0b1ByaW1pdGl2ZSA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi9fZmFpbHMnKTtcbnZhciBnT1BOID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcG4nKS5mO1xudmFyIGdPUEQgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpLmY7XG52YXIgZFAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mO1xudmFyICR0cmltID0gcmVxdWlyZSgnLi9fc3RyaW5nLXRyaW0nKS50cmltO1xudmFyIE5VTUJFUiA9ICdOdW1iZXInO1xudmFyICROdW1iZXIgPSBnbG9iYWxbTlVNQkVSXTtcbnZhciBCYXNlID0gJE51bWJlcjtcbnZhciBwcm90byA9ICROdW1iZXIucHJvdG90eXBlO1xuLy8gT3BlcmEgfjEyIGhhcyBicm9rZW4gT2JqZWN0I3RvU3RyaW5nXG52YXIgQlJPS0VOX0NPRiA9IGNvZihyZXF1aXJlKCcuL19vYmplY3QtY3JlYXRlJykocHJvdG8pKSA9PSBOVU1CRVI7XG52YXIgVFJJTSA9ICd0cmltJyBpbiBTdHJpbmcucHJvdG90eXBlO1xuXG4vLyA3LjEuMyBUb051bWJlcihhcmd1bWVudClcbnZhciB0b051bWJlciA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICB2YXIgaXQgPSB0b1ByaW1pdGl2ZShhcmd1bWVudCwgZmFsc2UpO1xuICBpZiAodHlwZW9mIGl0ID09ICdzdHJpbmcnICYmIGl0Lmxlbmd0aCA+IDIpIHtcbiAgICBpdCA9IFRSSU0gPyBpdC50cmltKCkgOiAkdHJpbShpdCwgMyk7XG4gICAgdmFyIGZpcnN0ID0gaXQuY2hhckNvZGVBdCgwKTtcbiAgICB2YXIgdGhpcmQsIHJhZGl4LCBtYXhDb2RlO1xuICAgIGlmIChmaXJzdCA9PT0gNDMgfHwgZmlyc3QgPT09IDQ1KSB7XG4gICAgICB0aGlyZCA9IGl0LmNoYXJDb2RlQXQoMik7XG4gICAgICBpZiAodGhpcmQgPT09IDg4IHx8IHRoaXJkID09PSAxMjApIHJldHVybiBOYU47IC8vIE51bWJlcignKzB4MScpIHNob3VsZCBiZSBOYU4sIG9sZCBWOCBmaXhcbiAgICB9IGVsc2UgaWYgKGZpcnN0ID09PSA0OCkge1xuICAgICAgc3dpdGNoIChpdC5jaGFyQ29kZUF0KDEpKSB7XG4gICAgICAgIGNhc2UgNjY6IGNhc2UgOTg6IHJhZGl4ID0gMjsgbWF4Q29kZSA9IDQ5OyBicmVhazsgLy8gZmFzdCBlcXVhbCAvXjBiWzAxXSskL2lcbiAgICAgICAgY2FzZSA3OTogY2FzZSAxMTE6IHJhZGl4ID0gODsgbWF4Q29kZSA9IDU1OyBicmVhazsgLy8gZmFzdCBlcXVhbCAvXjBvWzAtN10rJC9pXG4gICAgICAgIGRlZmF1bHQ6IHJldHVybiAraXQ7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBkaWdpdHMgPSBpdC5zbGljZSgyKSwgaSA9IDAsIGwgPSBkaWdpdHMubGVuZ3RoLCBjb2RlOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGNvZGUgPSBkaWdpdHMuY2hhckNvZGVBdChpKTtcbiAgICAgICAgLy8gcGFyc2VJbnQgcGFyc2VzIGEgc3RyaW5nIHRvIGEgZmlyc3QgdW5hdmFpbGFibGUgc3ltYm9sXG4gICAgICAgIC8vIGJ1dCBUb051bWJlciBzaG91bGQgcmV0dXJuIE5hTiBpZiBhIHN0cmluZyBjb250YWlucyB1bmF2YWlsYWJsZSBzeW1ib2xzXG4gICAgICAgIGlmIChjb2RlIDwgNDggfHwgY29kZSA+IG1heENvZGUpIHJldHVybiBOYU47XG4gICAgICB9IHJldHVybiBwYXJzZUludChkaWdpdHMsIHJhZGl4KTtcbiAgICB9XG4gIH0gcmV0dXJuICtpdDtcbn07XG5cbmlmICghJE51bWJlcignIDBvMScpIHx8ICEkTnVtYmVyKCcwYjEnKSB8fCAkTnVtYmVyKCcrMHgxJykpIHtcbiAgJE51bWJlciA9IGZ1bmN0aW9uIE51bWJlcih2YWx1ZSkge1xuICAgIHZhciBpdCA9IGFyZ3VtZW50cy5sZW5ndGggPCAxID8gMCA6IHZhbHVlO1xuICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICByZXR1cm4gdGhhdCBpbnN0YW5jZW9mICROdW1iZXJcbiAgICAgIC8vIGNoZWNrIG9uIDEuLmNvbnN0cnVjdG9yKGZvbykgY2FzZVxuICAgICAgJiYgKEJST0tFTl9DT0YgPyBmYWlscyhmdW5jdGlvbiAoKSB7IHByb3RvLnZhbHVlT2YuY2FsbCh0aGF0KTsgfSkgOiBjb2YodGhhdCkgIT0gTlVNQkVSKVxuICAgICAgICA/IGluaGVyaXRJZlJlcXVpcmVkKG5ldyBCYXNlKHRvTnVtYmVyKGl0KSksIHRoYXQsICROdW1iZXIpIDogdG9OdW1iZXIoaXQpO1xuICB9O1xuICBmb3IgKHZhciBrZXlzID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IGdPUE4oQmFzZSkgOiAoXG4gICAgLy8gRVMzOlxuICAgICdNQVhfVkFMVUUsTUlOX1ZBTFVFLE5hTixORUdBVElWRV9JTkZJTklUWSxQT1NJVElWRV9JTkZJTklUWSwnICtcbiAgICAvLyBFUzYgKGluIGNhc2UsIGlmIG1vZHVsZXMgd2l0aCBFUzYgTnVtYmVyIHN0YXRpY3MgcmVxdWlyZWQgYmVmb3JlKTpcbiAgICAnRVBTSUxPTixpc0Zpbml0ZSxpc0ludGVnZXIsaXNOYU4saXNTYWZlSW50ZWdlcixNQVhfU0FGRV9JTlRFR0VSLCcgK1xuICAgICdNSU5fU0FGRV9JTlRFR0VSLHBhcnNlRmxvYXQscGFyc2VJbnQsaXNJbnRlZ2VyJ1xuICApLnNwbGl0KCcsJyksIGogPSAwLCBrZXk7IGtleXMubGVuZ3RoID4gajsgaisrKSB7XG4gICAgaWYgKGhhcyhCYXNlLCBrZXkgPSBrZXlzW2pdKSAmJiAhaGFzKCROdW1iZXIsIGtleSkpIHtcbiAgICAgIGRQKCROdW1iZXIsIGtleSwgZ09QRChCYXNlLCBrZXkpKTtcbiAgICB9XG4gIH1cbiAgJE51bWJlci5wcm90b3R5cGUgPSBwcm90bztcbiAgcHJvdG8uY29uc3RydWN0b3IgPSAkTnVtYmVyO1xuICByZXF1aXJlKCcuL19yZWRlZmluZScpKGdsb2JhbCwgTlVNQkVSLCAkTnVtYmVyKTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci5jb25zdHJ1Y3Rvci5qcyIsIi8vIDIwLjEuMi4xIE51bWJlci5FUFNJTE9OXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ051bWJlcicsIHsgRVBTSUxPTjogTWF0aC5wb3coMiwgLTUyKSB9KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci5lcHNpbG9uLmpzIiwiLy8gMjAuMS4yLjIgTnVtYmVyLmlzRmluaXRlKG51bWJlcilcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgX2lzRmluaXRlID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykuaXNGaW5pdGU7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTnVtYmVyJywge1xuICBpc0Zpbml0ZTogZnVuY3Rpb24gaXNGaW5pdGUoaXQpIHtcbiAgICByZXR1cm4gdHlwZW9mIGl0ID09ICdudW1iZXInICYmIF9pc0Zpbml0ZShpdCk7XG4gIH1cbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLmlzLWZpbml0ZS5qcyIsIi8vIDIwLjEuMi4zIE51bWJlci5pc0ludGVnZXIobnVtYmVyKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdOdW1iZXInLCB7IGlzSW50ZWdlcjogcmVxdWlyZSgnLi9faXMtaW50ZWdlcicpIH0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLmlzLWludGVnZXIuanMiLCIvLyAyMC4xLjIuNCBOdW1iZXIuaXNOYU4obnVtYmVyKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdOdW1iZXInLCB7XG4gIGlzTmFOOiBmdW5jdGlvbiBpc05hTihudW1iZXIpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gICAgcmV0dXJuIG51bWJlciAhPSBudW1iZXI7XG4gIH1cbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLmlzLW5hbi5qcyIsIi8vIDIwLjEuMi41IE51bWJlci5pc1NhZmVJbnRlZ2VyKG51bWJlcilcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgaXNJbnRlZ2VyID0gcmVxdWlyZSgnLi9faXMtaW50ZWdlcicpO1xudmFyIGFicyA9IE1hdGguYWJzO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ051bWJlcicsIHtcbiAgaXNTYWZlSW50ZWdlcjogZnVuY3Rpb24gaXNTYWZlSW50ZWdlcihudW1iZXIpIHtcbiAgICByZXR1cm4gaXNJbnRlZ2VyKG51bWJlcikgJiYgYWJzKG51bWJlcikgPD0gMHgxZmZmZmZmZmZmZmZmZjtcbiAgfVxufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5udW1iZXIuaXMtc2FmZS1pbnRlZ2VyLmpzIiwiLy8gMjAuMS4yLjYgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTnVtYmVyJywgeyBNQVhfU0FGRV9JTlRFR0VSOiAweDFmZmZmZmZmZmZmZmZmIH0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLm1heC1zYWZlLWludGVnZXIuanMiLCIvLyAyMC4xLjIuMTAgTnVtYmVyLk1JTl9TQUZFX0lOVEVHRVJcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTnVtYmVyJywgeyBNSU5fU0FGRV9JTlRFR0VSOiAtMHgxZmZmZmZmZmZmZmZmZiB9KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci5taW4tc2FmZS1pbnRlZ2VyLmpzIiwidmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciAkcGFyc2VGbG9hdCA9IHJlcXVpcmUoJy4vX3BhcnNlLWZsb2F0Jyk7XG4vLyAyMC4xLjIuMTIgTnVtYmVyLnBhcnNlRmxvYXQoc3RyaW5nKVxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAoTnVtYmVyLnBhcnNlRmxvYXQgIT0gJHBhcnNlRmxvYXQpLCAnTnVtYmVyJywgeyBwYXJzZUZsb2F0OiAkcGFyc2VGbG9hdCB9KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci5wYXJzZS1mbG9hdC5qcyIsInZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgJHBhcnNlSW50ID0gcmVxdWlyZSgnLi9fcGFyc2UtaW50Jyk7XG4vLyAyMC4xLjIuMTMgTnVtYmVyLnBhcnNlSW50KHN0cmluZywgcmFkaXgpXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqIChOdW1iZXIucGFyc2VJbnQgIT0gJHBhcnNlSW50KSwgJ051bWJlcicsIHsgcGFyc2VJbnQ6ICRwYXJzZUludCB9KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci5wYXJzZS1pbnQuanMiLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKTtcbnZhciBhTnVtYmVyVmFsdWUgPSByZXF1aXJlKCcuL19hLW51bWJlci12YWx1ZScpO1xudmFyIHJlcGVhdCA9IHJlcXVpcmUoJy4vX3N0cmluZy1yZXBlYXQnKTtcbnZhciAkdG9GaXhlZCA9IDEuMC50b0ZpeGVkO1xudmFyIGZsb29yID0gTWF0aC5mbG9vcjtcbnZhciBkYXRhID0gWzAsIDAsIDAsIDAsIDAsIDBdO1xudmFyIEVSUk9SID0gJ051bWJlci50b0ZpeGVkOiBpbmNvcnJlY3QgaW52b2NhdGlvbiEnO1xudmFyIFpFUk8gPSAnMCc7XG5cbnZhciBtdWx0aXBseSA9IGZ1bmN0aW9uIChuLCBjKSB7XG4gIHZhciBpID0gLTE7XG4gIHZhciBjMiA9IGM7XG4gIHdoaWxlICgrK2kgPCA2KSB7XG4gICAgYzIgKz0gbiAqIGRhdGFbaV07XG4gICAgZGF0YVtpXSA9IGMyICUgMWU3O1xuICAgIGMyID0gZmxvb3IoYzIgLyAxZTcpO1xuICB9XG59O1xudmFyIGRpdmlkZSA9IGZ1bmN0aW9uIChuKSB7XG4gIHZhciBpID0gNjtcbiAgdmFyIGMgPSAwO1xuICB3aGlsZSAoLS1pID49IDApIHtcbiAgICBjICs9IGRhdGFbaV07XG4gICAgZGF0YVtpXSA9IGZsb29yKGMgLyBuKTtcbiAgICBjID0gKGMgJSBuKSAqIDFlNztcbiAgfVxufTtcbnZhciBudW1Ub1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGkgPSA2O1xuICB2YXIgcyA9ICcnO1xuICB3aGlsZSAoLS1pID49IDApIHtcbiAgICBpZiAocyAhPT0gJycgfHwgaSA9PT0gMCB8fCBkYXRhW2ldICE9PSAwKSB7XG4gICAgICB2YXIgdCA9IFN0cmluZyhkYXRhW2ldKTtcbiAgICAgIHMgPSBzID09PSAnJyA/IHQgOiBzICsgcmVwZWF0LmNhbGwoWkVSTywgNyAtIHQubGVuZ3RoKSArIHQ7XG4gICAgfVxuICB9IHJldHVybiBzO1xufTtcbnZhciBwb3cgPSBmdW5jdGlvbiAoeCwgbiwgYWNjKSB7XG4gIHJldHVybiBuID09PSAwID8gYWNjIDogbiAlIDIgPT09IDEgPyBwb3coeCwgbiAtIDEsIGFjYyAqIHgpIDogcG93KHggKiB4LCBuIC8gMiwgYWNjKTtcbn07XG52YXIgbG9nID0gZnVuY3Rpb24gKHgpIHtcbiAgdmFyIG4gPSAwO1xuICB2YXIgeDIgPSB4O1xuICB3aGlsZSAoeDIgPj0gNDA5Nikge1xuICAgIG4gKz0gMTI7XG4gICAgeDIgLz0gNDA5NjtcbiAgfVxuICB3aGlsZSAoeDIgPj0gMikge1xuICAgIG4gKz0gMTtcbiAgICB4MiAvPSAyO1xuICB9IHJldHVybiBuO1xufTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAoISEkdG9GaXhlZCAmJiAoXG4gIDAuMDAwMDgudG9GaXhlZCgzKSAhPT0gJzAuMDAwJyB8fFxuICAwLjkudG9GaXhlZCgwKSAhPT0gJzEnIHx8XG4gIDEuMjU1LnRvRml4ZWQoMikgIT09ICcxLjI1JyB8fFxuICAxMDAwMDAwMDAwMDAwMDAwMTI4LjAudG9GaXhlZCgwKSAhPT0gJzEwMDAwMDAwMDAwMDAwMDAxMjgnXG4pIHx8ICFyZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uICgpIHtcbiAgLy8gVjggfiBBbmRyb2lkIDQuMy1cbiAgJHRvRml4ZWQuY2FsbCh7fSk7XG59KSksICdOdW1iZXInLCB7XG4gIHRvRml4ZWQ6IGZ1bmN0aW9uIHRvRml4ZWQoZnJhY3Rpb25EaWdpdHMpIHtcbiAgICB2YXIgeCA9IGFOdW1iZXJWYWx1ZSh0aGlzLCBFUlJPUik7XG4gICAgdmFyIGYgPSB0b0ludGVnZXIoZnJhY3Rpb25EaWdpdHMpO1xuICAgIHZhciBzID0gJyc7XG4gICAgdmFyIG0gPSBaRVJPO1xuICAgIHZhciBlLCB6LCBqLCBrO1xuICAgIGlmIChmIDwgMCB8fCBmID4gMjApIHRocm93IFJhbmdlRXJyb3IoRVJST1IpO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgICBpZiAoeCAhPSB4KSByZXR1cm4gJ05hTic7XG4gICAgaWYgKHggPD0gLTFlMjEgfHwgeCA+PSAxZTIxKSByZXR1cm4gU3RyaW5nKHgpO1xuICAgIGlmICh4IDwgMCkge1xuICAgICAgcyA9ICctJztcbiAgICAgIHggPSAteDtcbiAgICB9XG4gICAgaWYgKHggPiAxZS0yMSkge1xuICAgICAgZSA9IGxvZyh4ICogcG93KDIsIDY5LCAxKSkgLSA2OTtcbiAgICAgIHogPSBlIDwgMCA/IHggKiBwb3coMiwgLWUsIDEpIDogeCAvIHBvdygyLCBlLCAxKTtcbiAgICAgIHogKj0gMHgxMDAwMDAwMDAwMDAwMDtcbiAgICAgIGUgPSA1MiAtIGU7XG4gICAgICBpZiAoZSA+IDApIHtcbiAgICAgICAgbXVsdGlwbHkoMCwgeik7XG4gICAgICAgIGogPSBmO1xuICAgICAgICB3aGlsZSAoaiA+PSA3KSB7XG4gICAgICAgICAgbXVsdGlwbHkoMWU3LCAwKTtcbiAgICAgICAgICBqIC09IDc7XG4gICAgICAgIH1cbiAgICAgICAgbXVsdGlwbHkocG93KDEwLCBqLCAxKSwgMCk7XG4gICAgICAgIGogPSBlIC0gMTtcbiAgICAgICAgd2hpbGUgKGogPj0gMjMpIHtcbiAgICAgICAgICBkaXZpZGUoMSA8PCAyMyk7XG4gICAgICAgICAgaiAtPSAyMztcbiAgICAgICAgfVxuICAgICAgICBkaXZpZGUoMSA8PCBqKTtcbiAgICAgICAgbXVsdGlwbHkoMSwgMSk7XG4gICAgICAgIGRpdmlkZSgyKTtcbiAgICAgICAgbSA9IG51bVRvU3RyaW5nKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtdWx0aXBseSgwLCB6KTtcbiAgICAgICAgbXVsdGlwbHkoMSA8PCAtZSwgMCk7XG4gICAgICAgIG0gPSBudW1Ub1N0cmluZygpICsgcmVwZWF0LmNhbGwoWkVSTywgZik7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChmID4gMCkge1xuICAgICAgayA9IG0ubGVuZ3RoO1xuICAgICAgbSA9IHMgKyAoayA8PSBmID8gJzAuJyArIHJlcGVhdC5jYWxsKFpFUk8sIGYgLSBrKSArIG0gOiBtLnNsaWNlKDAsIGsgLSBmKSArICcuJyArIG0uc2xpY2UoayAtIGYpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IHMgKyBtO1xuICAgIH0gcmV0dXJuIG07XG4gIH1cbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLnRvLWZpeGVkLmpzIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciAkZmFpbHMgPSByZXF1aXJlKCcuL19mYWlscycpO1xudmFyIGFOdW1iZXJWYWx1ZSA9IHJlcXVpcmUoJy4vX2EtbnVtYmVyLXZhbHVlJyk7XG52YXIgJHRvUHJlY2lzaW9uID0gMS4wLnRvUHJlY2lzaW9uO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqICgkZmFpbHMoZnVuY3Rpb24gKCkge1xuICAvLyBJRTctXG4gIHJldHVybiAkdG9QcmVjaXNpb24uY2FsbCgxLCB1bmRlZmluZWQpICE9PSAnMSc7XG59KSB8fCAhJGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgLy8gVjggfiBBbmRyb2lkIDQuMy1cbiAgJHRvUHJlY2lzaW9uLmNhbGwoe30pO1xufSkpLCAnTnVtYmVyJywge1xuICB0b1ByZWNpc2lvbjogZnVuY3Rpb24gdG9QcmVjaXNpb24ocHJlY2lzaW9uKSB7XG4gICAgdmFyIHRoYXQgPSBhTnVtYmVyVmFsdWUodGhpcywgJ051bWJlciN0b1ByZWNpc2lvbjogaW5jb3JyZWN0IGludm9jYXRpb24hJyk7XG4gICAgcmV0dXJuIHByZWNpc2lvbiA9PT0gdW5kZWZpbmVkID8gJHRvUHJlY2lzaW9uLmNhbGwodGhhdCkgOiAkdG9QcmVjaXNpb24uY2FsbCh0aGF0LCBwcmVjaXNpb24pO1xuICB9XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci50by1wcmVjaXNpb24uanMiLCIvLyAxOS4xLjMuMSBPYmplY3QuYXNzaWduKHRhcmdldCwgc291cmNlKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYsICdPYmplY3QnLCB7IGFzc2lnbjogcmVxdWlyZSgnLi9fb2JqZWN0LWFzc2lnbicpIH0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmFzc2lnbi5qcyIsInZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG4vLyAxOS4xLjIuMiAvIDE1LjIuMy41IE9iamVjdC5jcmVhdGUoTyBbLCBQcm9wZXJ0aWVzXSlcbiRleHBvcnQoJGV4cG9ydC5TLCAnT2JqZWN0JywgeyBjcmVhdGU6IHJlcXVpcmUoJy4vX29iamVjdC1jcmVhdGUnKSB9KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5jcmVhdGUuanMiLCJ2YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuLy8gMTkuMS4yLjMgLyAxNS4yLjMuNyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhPLCBQcm9wZXJ0aWVzKVxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSwgJ09iamVjdCcsIHsgZGVmaW5lUHJvcGVydGllczogcmVxdWlyZSgnLi9fb2JqZWN0LWRwcycpIH0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmRlZmluZS1wcm9wZXJ0aWVzLmpzIiwidmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbi8vIDE5LjEuMi40IC8gMTUuMi4zLjYgT2JqZWN0LmRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFyZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpLCAnT2JqZWN0JywgeyBkZWZpbmVQcm9wZXJ0eTogcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZiB9KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5kZWZpbmUtcHJvcGVydHkuanMiLCIvLyAxOS4xLjIuNSBPYmplY3QuZnJlZXplKE8pXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBtZXRhID0gcmVxdWlyZSgnLi9fbWV0YScpLm9uRnJlZXplO1xuXG5yZXF1aXJlKCcuL19vYmplY3Qtc2FwJykoJ2ZyZWV6ZScsIGZ1bmN0aW9uICgkZnJlZXplKSB7XG4gIHJldHVybiBmdW5jdGlvbiBmcmVlemUoaXQpIHtcbiAgICByZXR1cm4gJGZyZWV6ZSAmJiBpc09iamVjdChpdCkgPyAkZnJlZXplKG1ldGEoaXQpKSA6IGl0O1xuICB9O1xufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuZnJlZXplLmpzIiwiLy8gMTkuMS4yLjYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKVxudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcbnZhciAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKS5mO1xuXG5yZXF1aXJlKCcuL19vYmplY3Qtc2FwJykoJ2dldE93blByb3BlcnR5RGVzY3JpcHRvcicsIGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihpdCwga2V5KSB7XG4gICAgcmV0dXJuICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodG9JT2JqZWN0KGl0KSwga2V5KTtcbiAgfTtcbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvci5qcyIsIi8vIDE5LjEuMi43IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKE8pXG5yZXF1aXJlKCcuL19vYmplY3Qtc2FwJykoJ2dldE93blByb3BlcnR5TmFtZXMnLCBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiByZXF1aXJlKCcuL19vYmplY3QtZ29wbi1leHQnKS5mO1xufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuZ2V0LW93bi1wcm9wZXJ0eS1uYW1lcy5qcyIsIi8vIDE5LjEuMi45IE9iamVjdC5nZXRQcm90b3R5cGVPZihPKVxudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG52YXIgJGdldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpO1xuXG5yZXF1aXJlKCcuL19vYmplY3Qtc2FwJykoJ2dldFByb3RvdHlwZU9mJywgZnVuY3Rpb24gKCkge1xuICByZXR1cm4gZnVuY3Rpb24gZ2V0UHJvdG90eXBlT2YoaXQpIHtcbiAgICByZXR1cm4gJGdldFByb3RvdHlwZU9mKHRvT2JqZWN0KGl0KSk7XG4gIH07XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5nZXQtcHJvdG90eXBlLW9mLmpzIiwiLy8gMTkuMS4yLjExIE9iamVjdC5pc0V4dGVuc2libGUoTylcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xuXG5yZXF1aXJlKCcuL19vYmplY3Qtc2FwJykoJ2lzRXh0ZW5zaWJsZScsIGZ1bmN0aW9uICgkaXNFeHRlbnNpYmxlKSB7XG4gIHJldHVybiBmdW5jdGlvbiBpc0V4dGVuc2libGUoaXQpIHtcbiAgICByZXR1cm4gaXNPYmplY3QoaXQpID8gJGlzRXh0ZW5zaWJsZSA/ICRpc0V4dGVuc2libGUoaXQpIDogdHJ1ZSA6IGZhbHNlO1xuICB9O1xufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuaXMtZXh0ZW5zaWJsZS5qcyIsIi8vIDE5LjEuMi4xMiBPYmplY3QuaXNGcm96ZW4oTylcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xuXG5yZXF1aXJlKCcuL19vYmplY3Qtc2FwJykoJ2lzRnJvemVuJywgZnVuY3Rpb24gKCRpc0Zyb3plbikge1xuICByZXR1cm4gZnVuY3Rpb24gaXNGcm96ZW4oaXQpIHtcbiAgICByZXR1cm4gaXNPYmplY3QoaXQpID8gJGlzRnJvemVuID8gJGlzRnJvemVuKGl0KSA6IGZhbHNlIDogdHJ1ZTtcbiAgfTtcbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmlzLWZyb3plbi5qcyIsIi8vIDE5LjEuMi4xMyBPYmplY3QuaXNTZWFsZWQoTylcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xuXG5yZXF1aXJlKCcuL19vYmplY3Qtc2FwJykoJ2lzU2VhbGVkJywgZnVuY3Rpb24gKCRpc1NlYWxlZCkge1xuICByZXR1cm4gZnVuY3Rpb24gaXNTZWFsZWQoaXQpIHtcbiAgICByZXR1cm4gaXNPYmplY3QoaXQpID8gJGlzU2VhbGVkID8gJGlzU2VhbGVkKGl0KSA6IGZhbHNlIDogdHJ1ZTtcbiAgfTtcbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmlzLXNlYWxlZC5qcyIsIi8vIDE5LjEuMy4xMCBPYmplY3QuaXModmFsdWUxLCB2YWx1ZTIpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuJGV4cG9ydCgkZXhwb3J0LlMsICdPYmplY3QnLCB7IGlzOiByZXF1aXJlKCcuL19zYW1lLXZhbHVlJykgfSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuaXMuanMiLCIvLyAxOS4xLjIuMTQgT2JqZWN0LmtleXMoTylcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpO1xudmFyICRrZXlzID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKTtcblxucmVxdWlyZSgnLi9fb2JqZWN0LXNhcCcpKCdrZXlzJywgZnVuY3Rpb24gKCkge1xuICByZXR1cm4gZnVuY3Rpb24ga2V5cyhpdCkge1xuICAgIHJldHVybiAka2V5cyh0b09iamVjdChpdCkpO1xuICB9O1xufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3Qua2V5cy5qcyIsIi8vIDE5LjEuMi4xNSBPYmplY3QucHJldmVudEV4dGVuc2lvbnMoTylcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIG1ldGEgPSByZXF1aXJlKCcuL19tZXRhJykub25GcmVlemU7XG5cbnJlcXVpcmUoJy4vX29iamVjdC1zYXAnKSgncHJldmVudEV4dGVuc2lvbnMnLCBmdW5jdGlvbiAoJHByZXZlbnRFeHRlbnNpb25zKSB7XG4gIHJldHVybiBmdW5jdGlvbiBwcmV2ZW50RXh0ZW5zaW9ucyhpdCkge1xuICAgIHJldHVybiAkcHJldmVudEV4dGVuc2lvbnMgJiYgaXNPYmplY3QoaXQpID8gJHByZXZlbnRFeHRlbnNpb25zKG1ldGEoaXQpKSA6IGl0O1xuICB9O1xufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QucHJldmVudC1leHRlbnNpb25zLmpzIiwiLy8gMTkuMS4yLjE3IE9iamVjdC5zZWFsKE8pXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBtZXRhID0gcmVxdWlyZSgnLi9fbWV0YScpLm9uRnJlZXplO1xuXG5yZXF1aXJlKCcuL19vYmplY3Qtc2FwJykoJ3NlYWwnLCBmdW5jdGlvbiAoJHNlYWwpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHNlYWwoaXQpIHtcbiAgICByZXR1cm4gJHNlYWwgJiYgaXNPYmplY3QoaXQpID8gJHNlYWwobWV0YShpdCkpIDogaXQ7XG4gIH07XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5zZWFsLmpzIiwiLy8gMTkuMS4zLjE5IE9iamVjdC5zZXRQcm90b3R5cGVPZihPLCBwcm90bylcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG4kZXhwb3J0KCRleHBvcnQuUywgJ09iamVjdCcsIHsgc2V0UHJvdG90eXBlT2Y6IHJlcXVpcmUoJy4vX3NldC1wcm90bycpLnNldCB9KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5zZXQtcHJvdG90eXBlLW9mLmpzIiwiJ3VzZSBzdHJpY3QnO1xuLy8gMTkuMS4zLjYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZygpXG52YXIgY2xhc3NvZiA9IHJlcXVpcmUoJy4vX2NsYXNzb2YnKTtcbnZhciB0ZXN0ID0ge307XG50ZXN0W3JlcXVpcmUoJy4vX3drcycpKCd0b1N0cmluZ1RhZycpXSA9ICd6JztcbmlmICh0ZXN0ICsgJycgIT0gJ1tvYmplY3Qgel0nKSB7XG4gIHJlcXVpcmUoJy4vX3JlZGVmaW5lJykoT2JqZWN0LnByb3RvdHlwZSwgJ3RvU3RyaW5nJywgZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuICdbb2JqZWN0ICcgKyBjbGFzc29mKHRoaXMpICsgJ10nO1xuICB9LCB0cnVlKTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC50by1zdHJpbmcuanMiLCJ2YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyICRwYXJzZUZsb2F0ID0gcmVxdWlyZSgnLi9fcGFyc2UtZmxvYXQnKTtcbi8vIDE4LjIuNCBwYXJzZUZsb2F0KHN0cmluZylcbiRleHBvcnQoJGV4cG9ydC5HICsgJGV4cG9ydC5GICogKHBhcnNlRmxvYXQgIT0gJHBhcnNlRmxvYXQpLCB7IHBhcnNlRmxvYXQ6ICRwYXJzZUZsb2F0IH0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucGFyc2UtZmxvYXQuanMiLCJ2YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyICRwYXJzZUludCA9IHJlcXVpcmUoJy4vX3BhcnNlLWludCcpO1xuLy8gMTguMi41IHBhcnNlSW50KHN0cmluZywgcmFkaXgpXG4kZXhwb3J0KCRleHBvcnQuRyArICRleHBvcnQuRiAqIChwYXJzZUludCAhPSAkcGFyc2VJbnQpLCB7IHBhcnNlSW50OiAkcGFyc2VJbnQgfSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5wYXJzZS1pbnQuanMiLCIndXNlIHN0cmljdCc7XG52YXIgTElCUkFSWSA9IHJlcXVpcmUoJy4vX2xpYnJhcnknKTtcbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBjdHggPSByZXF1aXJlKCcuL19jdHgnKTtcbnZhciBjbGFzc29mID0gcmVxdWlyZSgnLi9fY2xhc3NvZicpO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKTtcbnZhciBhbkluc3RhbmNlID0gcmVxdWlyZSgnLi9fYW4taW5zdGFuY2UnKTtcbnZhciBmb3JPZiA9IHJlcXVpcmUoJy4vX2Zvci1vZicpO1xudmFyIHNwZWNpZXNDb25zdHJ1Y3RvciA9IHJlcXVpcmUoJy4vX3NwZWNpZXMtY29uc3RydWN0b3InKTtcbnZhciB0YXNrID0gcmVxdWlyZSgnLi9fdGFzaycpLnNldDtcbnZhciBtaWNyb3Rhc2sgPSByZXF1aXJlKCcuL19taWNyb3Rhc2snKSgpO1xudmFyIG5ld1Byb21pc2VDYXBhYmlsaXR5TW9kdWxlID0gcmVxdWlyZSgnLi9fbmV3LXByb21pc2UtY2FwYWJpbGl0eScpO1xudmFyIHBlcmZvcm0gPSByZXF1aXJlKCcuL19wZXJmb3JtJyk7XG52YXIgcHJvbWlzZVJlc29sdmUgPSByZXF1aXJlKCcuL19wcm9taXNlLXJlc29sdmUnKTtcbnZhciBQUk9NSVNFID0gJ1Byb21pc2UnO1xudmFyIFR5cGVFcnJvciA9IGdsb2JhbC5UeXBlRXJyb3I7XG52YXIgcHJvY2VzcyA9IGdsb2JhbC5wcm9jZXNzO1xudmFyICRQcm9taXNlID0gZ2xvYmFsW1BST01JU0VdO1xudmFyIGlzTm9kZSA9IGNsYXNzb2YocHJvY2VzcykgPT0gJ3Byb2Nlc3MnO1xudmFyIGVtcHR5ID0gZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9O1xudmFyIEludGVybmFsLCBuZXdHZW5lcmljUHJvbWlzZUNhcGFiaWxpdHksIE93blByb21pc2VDYXBhYmlsaXR5LCBXcmFwcGVyO1xudmFyIG5ld1Byb21pc2VDYXBhYmlsaXR5ID0gbmV3R2VuZXJpY1Byb21pc2VDYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHlNb2R1bGUuZjtcblxudmFyIFVTRV9OQVRJVkUgPSAhIWZ1bmN0aW9uICgpIHtcbiAgdHJ5IHtcbiAgICAvLyBjb3JyZWN0IHN1YmNsYXNzaW5nIHdpdGggQEBzcGVjaWVzIHN1cHBvcnRcbiAgICB2YXIgcHJvbWlzZSA9ICRQcm9taXNlLnJlc29sdmUoMSk7XG4gICAgdmFyIEZha2VQcm9taXNlID0gKHByb21pc2UuY29uc3RydWN0b3IgPSB7fSlbcmVxdWlyZSgnLi9fd2tzJykoJ3NwZWNpZXMnKV0gPSBmdW5jdGlvbiAoZXhlYykge1xuICAgICAgZXhlYyhlbXB0eSwgZW1wdHkpO1xuICAgIH07XG4gICAgLy8gdW5oYW5kbGVkIHJlamVjdGlvbnMgdHJhY2tpbmcgc3VwcG9ydCwgTm9kZUpTIFByb21pc2Ugd2l0aG91dCBpdCBmYWlscyBAQHNwZWNpZXMgdGVzdFxuICAgIHJldHVybiAoaXNOb2RlIHx8IHR5cGVvZiBQcm9taXNlUmVqZWN0aW9uRXZlbnQgPT0gJ2Z1bmN0aW9uJykgJiYgcHJvbWlzZS50aGVuKGVtcHR5KSBpbnN0YW5jZW9mIEZha2VQcm9taXNlO1xuICB9IGNhdGNoIChlKSB7IC8qIGVtcHR5ICovIH1cbn0oKTtcblxuLy8gaGVscGVyc1xudmFyIGlzVGhlbmFibGUgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIHRoZW47XG4gIHJldHVybiBpc09iamVjdChpdCkgJiYgdHlwZW9mICh0aGVuID0gaXQudGhlbikgPT0gJ2Z1bmN0aW9uJyA/IHRoZW4gOiBmYWxzZTtcbn07XG52YXIgbm90aWZ5ID0gZnVuY3Rpb24gKHByb21pc2UsIGlzUmVqZWN0KSB7XG4gIGlmIChwcm9taXNlLl9uKSByZXR1cm47XG4gIHByb21pc2UuX24gPSB0cnVlO1xuICB2YXIgY2hhaW4gPSBwcm9taXNlLl9jO1xuICBtaWNyb3Rhc2soZnVuY3Rpb24gKCkge1xuICAgIHZhciB2YWx1ZSA9IHByb21pc2UuX3Y7XG4gICAgdmFyIG9rID0gcHJvbWlzZS5fcyA9PSAxO1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgcnVuID0gZnVuY3Rpb24gKHJlYWN0aW9uKSB7XG4gICAgICB2YXIgaGFuZGxlciA9IG9rID8gcmVhY3Rpb24ub2sgOiByZWFjdGlvbi5mYWlsO1xuICAgICAgdmFyIHJlc29sdmUgPSByZWFjdGlvbi5yZXNvbHZlO1xuICAgICAgdmFyIHJlamVjdCA9IHJlYWN0aW9uLnJlamVjdDtcbiAgICAgIHZhciBkb21haW4gPSByZWFjdGlvbi5kb21haW47XG4gICAgICB2YXIgcmVzdWx0LCB0aGVuO1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKGhhbmRsZXIpIHtcbiAgICAgICAgICBpZiAoIW9rKSB7XG4gICAgICAgICAgICBpZiAocHJvbWlzZS5faCA9PSAyKSBvbkhhbmRsZVVuaGFuZGxlZChwcm9taXNlKTtcbiAgICAgICAgICAgIHByb21pc2UuX2ggPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaGFuZGxlciA9PT0gdHJ1ZSkgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoZG9tYWluKSBkb21haW4uZW50ZXIoKTtcbiAgICAgICAgICAgIHJlc3VsdCA9IGhhbmRsZXIodmFsdWUpO1xuICAgICAgICAgICAgaWYgKGRvbWFpbikgZG9tYWluLmV4aXQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHJlc3VsdCA9PT0gcmVhY3Rpb24ucHJvbWlzZSkge1xuICAgICAgICAgICAgcmVqZWN0KFR5cGVFcnJvcignUHJvbWlzZS1jaGFpbiBjeWNsZScpKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHRoZW4gPSBpc1RoZW5hYmxlKHJlc3VsdCkpIHtcbiAgICAgICAgICAgIHRoZW4uY2FsbChyZXN1bHQsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSBlbHNlIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfSBlbHNlIHJlamVjdCh2YWx1ZSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJlamVjdChlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHdoaWxlIChjaGFpbi5sZW5ndGggPiBpKSBydW4oY2hhaW5baSsrXSk7IC8vIHZhcmlhYmxlIGxlbmd0aCAtIGNhbid0IHVzZSBmb3JFYWNoXG4gICAgcHJvbWlzZS5fYyA9IFtdO1xuICAgIHByb21pc2UuX24gPSBmYWxzZTtcbiAgICBpZiAoaXNSZWplY3QgJiYgIXByb21pc2UuX2gpIG9uVW5oYW5kbGVkKHByb21pc2UpO1xuICB9KTtcbn07XG52YXIgb25VbmhhbmRsZWQgPSBmdW5jdGlvbiAocHJvbWlzZSkge1xuICB0YXNrLmNhbGwoZ2xvYmFsLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHZhbHVlID0gcHJvbWlzZS5fdjtcbiAgICB2YXIgdW5oYW5kbGVkID0gaXNVbmhhbmRsZWQocHJvbWlzZSk7XG4gICAgdmFyIHJlc3VsdCwgaGFuZGxlciwgY29uc29sZTtcbiAgICBpZiAodW5oYW5kbGVkKSB7XG4gICAgICByZXN1bHQgPSBwZXJmb3JtKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGlzTm9kZSkge1xuICAgICAgICAgIHByb2Nlc3MuZW1pdCgndW5oYW5kbGVkUmVqZWN0aW9uJywgdmFsdWUsIHByb21pc2UpO1xuICAgICAgICB9IGVsc2UgaWYgKGhhbmRsZXIgPSBnbG9iYWwub251bmhhbmRsZWRyZWplY3Rpb24pIHtcbiAgICAgICAgICBoYW5kbGVyKHsgcHJvbWlzZTogcHJvbWlzZSwgcmVhc29uOiB2YWx1ZSB9KTtcbiAgICAgICAgfSBlbHNlIGlmICgoY29uc29sZSA9IGdsb2JhbC5jb25zb2xlKSAmJiBjb25zb2xlLmVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignVW5oYW5kbGVkIHByb21pc2UgcmVqZWN0aW9uJywgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIC8vIEJyb3dzZXJzIHNob3VsZCBub3QgdHJpZ2dlciBgcmVqZWN0aW9uSGFuZGxlZGAgZXZlbnQgaWYgaXQgd2FzIGhhbmRsZWQgaGVyZSwgTm9kZUpTIC0gc2hvdWxkXG4gICAgICBwcm9taXNlLl9oID0gaXNOb2RlIHx8IGlzVW5oYW5kbGVkKHByb21pc2UpID8gMiA6IDE7XG4gICAgfSBwcm9taXNlLl9hID0gdW5kZWZpbmVkO1xuICAgIGlmICh1bmhhbmRsZWQgJiYgcmVzdWx0LmUpIHRocm93IHJlc3VsdC52O1xuICB9KTtcbn07XG52YXIgaXNVbmhhbmRsZWQgPSBmdW5jdGlvbiAocHJvbWlzZSkge1xuICBpZiAocHJvbWlzZS5faCA9PSAxKSByZXR1cm4gZmFsc2U7XG4gIHZhciBjaGFpbiA9IHByb21pc2UuX2EgfHwgcHJvbWlzZS5fYztcbiAgdmFyIGkgPSAwO1xuICB2YXIgcmVhY3Rpb247XG4gIHdoaWxlIChjaGFpbi5sZW5ndGggPiBpKSB7XG4gICAgcmVhY3Rpb24gPSBjaGFpbltpKytdO1xuICAgIGlmIChyZWFjdGlvbi5mYWlsIHx8ICFpc1VuaGFuZGxlZChyZWFjdGlvbi5wcm9taXNlKSkgcmV0dXJuIGZhbHNlO1xuICB9IHJldHVybiB0cnVlO1xufTtcbnZhciBvbkhhbmRsZVVuaGFuZGxlZCA9IGZ1bmN0aW9uIChwcm9taXNlKSB7XG4gIHRhc2suY2FsbChnbG9iYWwsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaGFuZGxlcjtcbiAgICBpZiAoaXNOb2RlKSB7XG4gICAgICBwcm9jZXNzLmVtaXQoJ3JlamVjdGlvbkhhbmRsZWQnLCBwcm9taXNlKTtcbiAgICB9IGVsc2UgaWYgKGhhbmRsZXIgPSBnbG9iYWwub25yZWplY3Rpb25oYW5kbGVkKSB7XG4gICAgICBoYW5kbGVyKHsgcHJvbWlzZTogcHJvbWlzZSwgcmVhc29uOiBwcm9taXNlLl92IH0pO1xuICAgIH1cbiAgfSk7XG59O1xudmFyICRyZWplY3QgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgdmFyIHByb21pc2UgPSB0aGlzO1xuICBpZiAocHJvbWlzZS5fZCkgcmV0dXJuO1xuICBwcm9taXNlLl9kID0gdHJ1ZTtcbiAgcHJvbWlzZSA9IHByb21pc2UuX3cgfHwgcHJvbWlzZTsgLy8gdW53cmFwXG4gIHByb21pc2UuX3YgPSB2YWx1ZTtcbiAgcHJvbWlzZS5fcyA9IDI7XG4gIGlmICghcHJvbWlzZS5fYSkgcHJvbWlzZS5fYSA9IHByb21pc2UuX2Muc2xpY2UoKTtcbiAgbm90aWZ5KHByb21pc2UsIHRydWUpO1xufTtcbnZhciAkcmVzb2x2ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICB2YXIgcHJvbWlzZSA9IHRoaXM7XG4gIHZhciB0aGVuO1xuICBpZiAocHJvbWlzZS5fZCkgcmV0dXJuO1xuICBwcm9taXNlLl9kID0gdHJ1ZTtcbiAgcHJvbWlzZSA9IHByb21pc2UuX3cgfHwgcHJvbWlzZTsgLy8gdW53cmFwXG4gIHRyeSB7XG4gICAgaWYgKHByb21pc2UgPT09IHZhbHVlKSB0aHJvdyBUeXBlRXJyb3IoXCJQcm9taXNlIGNhbid0IGJlIHJlc29sdmVkIGl0c2VsZlwiKTtcbiAgICBpZiAodGhlbiA9IGlzVGhlbmFibGUodmFsdWUpKSB7XG4gICAgICBtaWNyb3Rhc2soZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgd3JhcHBlciA9IHsgX3c6IHByb21pc2UsIF9kOiBmYWxzZSB9OyAvLyB3cmFwXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdGhlbi5jYWxsKHZhbHVlLCBjdHgoJHJlc29sdmUsIHdyYXBwZXIsIDEpLCBjdHgoJHJlamVjdCwgd3JhcHBlciwgMSkpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgJHJlamVjdC5jYWxsKHdyYXBwZXIsIGUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJvbWlzZS5fdiA9IHZhbHVlO1xuICAgICAgcHJvbWlzZS5fcyA9IDE7XG4gICAgICBub3RpZnkocHJvbWlzZSwgZmFsc2UpO1xuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgICRyZWplY3QuY2FsbCh7IF93OiBwcm9taXNlLCBfZDogZmFsc2UgfSwgZSk7IC8vIHdyYXBcbiAgfVxufTtcblxuLy8gY29uc3RydWN0b3IgcG9seWZpbGxcbmlmICghVVNFX05BVElWRSkge1xuICAvLyAyNS40LjMuMSBQcm9taXNlKGV4ZWN1dG9yKVxuICAkUHJvbWlzZSA9IGZ1bmN0aW9uIFByb21pc2UoZXhlY3V0b3IpIHtcbiAgICBhbkluc3RhbmNlKHRoaXMsICRQcm9taXNlLCBQUk9NSVNFLCAnX2gnKTtcbiAgICBhRnVuY3Rpb24oZXhlY3V0b3IpO1xuICAgIEludGVybmFsLmNhbGwodGhpcyk7XG4gICAgdHJ5IHtcbiAgICAgIGV4ZWN1dG9yKGN0eCgkcmVzb2x2ZSwgdGhpcywgMSksIGN0eCgkcmVqZWN0LCB0aGlzLCAxKSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAkcmVqZWN0LmNhbGwodGhpcywgZXJyKTtcbiAgICB9XG4gIH07XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuICBJbnRlcm5hbCA9IGZ1bmN0aW9uIFByb21pc2UoZXhlY3V0b3IpIHtcbiAgICB0aGlzLl9jID0gW107ICAgICAgICAgICAgIC8vIDwtIGF3YWl0aW5nIHJlYWN0aW9uc1xuICAgIHRoaXMuX2EgPSB1bmRlZmluZWQ7ICAgICAgLy8gPC0gY2hlY2tlZCBpbiBpc1VuaGFuZGxlZCByZWFjdGlvbnNcbiAgICB0aGlzLl9zID0gMDsgICAgICAgICAgICAgIC8vIDwtIHN0YXRlXG4gICAgdGhpcy5fZCA9IGZhbHNlOyAgICAgICAgICAvLyA8LSBkb25lXG4gICAgdGhpcy5fdiA9IHVuZGVmaW5lZDsgICAgICAvLyA8LSB2YWx1ZVxuICAgIHRoaXMuX2ggPSAwOyAgICAgICAgICAgICAgLy8gPC0gcmVqZWN0aW9uIHN0YXRlLCAwIC0gZGVmYXVsdCwgMSAtIGhhbmRsZWQsIDIgLSB1bmhhbmRsZWRcbiAgICB0aGlzLl9uID0gZmFsc2U7ICAgICAgICAgIC8vIDwtIG5vdGlmeVxuICB9O1xuICBJbnRlcm5hbC5wcm90b3R5cGUgPSByZXF1aXJlKCcuL19yZWRlZmluZS1hbGwnKSgkUHJvbWlzZS5wcm90b3R5cGUsIHtcbiAgICAvLyAyNS40LjUuMyBQcm9taXNlLnByb3RvdHlwZS50aGVuKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKVxuICAgIHRoZW46IGZ1bmN0aW9uIHRoZW4ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpIHtcbiAgICAgIHZhciByZWFjdGlvbiA9IG5ld1Byb21pc2VDYXBhYmlsaXR5KHNwZWNpZXNDb25zdHJ1Y3Rvcih0aGlzLCAkUHJvbWlzZSkpO1xuICAgICAgcmVhY3Rpb24ub2sgPSB0eXBlb2Ygb25GdWxmaWxsZWQgPT0gJ2Z1bmN0aW9uJyA/IG9uRnVsZmlsbGVkIDogdHJ1ZTtcbiAgICAgIHJlYWN0aW9uLmZhaWwgPSB0eXBlb2Ygb25SZWplY3RlZCA9PSAnZnVuY3Rpb24nICYmIG9uUmVqZWN0ZWQ7XG4gICAgICByZWFjdGlvbi5kb21haW4gPSBpc05vZGUgPyBwcm9jZXNzLmRvbWFpbiA6IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuX2MucHVzaChyZWFjdGlvbik7XG4gICAgICBpZiAodGhpcy5fYSkgdGhpcy5fYS5wdXNoKHJlYWN0aW9uKTtcbiAgICAgIGlmICh0aGlzLl9zKSBub3RpZnkodGhpcywgZmFsc2UpO1xuICAgICAgcmV0dXJuIHJlYWN0aW9uLnByb21pc2U7XG4gICAgfSxcbiAgICAvLyAyNS40LjUuMSBQcm9taXNlLnByb3RvdHlwZS5jYXRjaChvblJlamVjdGVkKVxuICAgICdjYXRjaCc6IGZ1bmN0aW9uIChvblJlamVjdGVkKSB7XG4gICAgICByZXR1cm4gdGhpcy50aGVuKHVuZGVmaW5lZCwgb25SZWplY3RlZCk7XG4gICAgfVxuICB9KTtcbiAgT3duUHJvbWlzZUNhcGFiaWxpdHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHByb21pc2UgPSBuZXcgSW50ZXJuYWwoKTtcbiAgICB0aGlzLnByb21pc2UgPSBwcm9taXNlO1xuICAgIHRoaXMucmVzb2x2ZSA9IGN0eCgkcmVzb2x2ZSwgcHJvbWlzZSwgMSk7XG4gICAgdGhpcy5yZWplY3QgPSBjdHgoJHJlamVjdCwgcHJvbWlzZSwgMSk7XG4gIH07XG4gIG5ld1Byb21pc2VDYXBhYmlsaXR5TW9kdWxlLmYgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eSA9IGZ1bmN0aW9uIChDKSB7XG4gICAgcmV0dXJuIEMgPT09ICRQcm9taXNlIHx8IEMgPT09IFdyYXBwZXJcbiAgICAgID8gbmV3IE93blByb21pc2VDYXBhYmlsaXR5KEMpXG4gICAgICA6IG5ld0dlbmVyaWNQcm9taXNlQ2FwYWJpbGl0eShDKTtcbiAgfTtcbn1cblxuJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LlcgKyAkZXhwb3J0LkYgKiAhVVNFX05BVElWRSwgeyBQcm9taXNlOiAkUHJvbWlzZSB9KTtcbnJlcXVpcmUoJy4vX3NldC10by1zdHJpbmctdGFnJykoJFByb21pc2UsIFBST01JU0UpO1xucmVxdWlyZSgnLi9fc2V0LXNwZWNpZXMnKShQUk9NSVNFKTtcbldyYXBwZXIgPSByZXF1aXJlKCcuL19jb3JlJylbUFJPTUlTRV07XG5cbi8vIHN0YXRpY3NcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIVVTRV9OQVRJVkUsIFBST01JU0UsIHtcbiAgLy8gMjUuNC40LjUgUHJvbWlzZS5yZWplY3QocilcbiAgcmVqZWN0OiBmdW5jdGlvbiByZWplY3Qocikge1xuICAgIHZhciBjYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkodGhpcyk7XG4gICAgdmFyICQkcmVqZWN0ID0gY2FwYWJpbGl0eS5yZWplY3Q7XG4gICAgJCRyZWplY3Qocik7XG4gICAgcmV0dXJuIGNhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxufSk7XG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqIChMSUJSQVJZIHx8ICFVU0VfTkFUSVZFKSwgUFJPTUlTRSwge1xuICAvLyAyNS40LjQuNiBQcm9taXNlLnJlc29sdmUoeClcbiAgcmVzb2x2ZTogZnVuY3Rpb24gcmVzb2x2ZSh4KSB7XG4gICAgcmV0dXJuIHByb21pc2VSZXNvbHZlKExJQlJBUlkgJiYgdGhpcyA9PT0gV3JhcHBlciA/ICRQcm9taXNlIDogdGhpcywgeCk7XG4gIH1cbn0pO1xuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhKFVTRV9OQVRJVkUgJiYgcmVxdWlyZSgnLi9faXRlci1kZXRlY3QnKShmdW5jdGlvbiAoaXRlcikge1xuICAkUHJvbWlzZS5hbGwoaXRlcilbJ2NhdGNoJ10oZW1wdHkpO1xufSkpLCBQUk9NSVNFLCB7XG4gIC8vIDI1LjQuNC4xIFByb21pc2UuYWxsKGl0ZXJhYmxlKVxuICBhbGw6IGZ1bmN0aW9uIGFsbChpdGVyYWJsZSkge1xuICAgIHZhciBDID0gdGhpcztcbiAgICB2YXIgY2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5KEMpO1xuICAgIHZhciByZXNvbHZlID0gY2FwYWJpbGl0eS5yZXNvbHZlO1xuICAgIHZhciByZWplY3QgPSBjYXBhYmlsaXR5LnJlamVjdDtcbiAgICB2YXIgcmVzdWx0ID0gcGVyZm9ybShmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgdmFsdWVzID0gW107XG4gICAgICB2YXIgaW5kZXggPSAwO1xuICAgICAgdmFyIHJlbWFpbmluZyA9IDE7XG4gICAgICBmb3JPZihpdGVyYWJsZSwgZmFsc2UsIGZ1bmN0aW9uIChwcm9taXNlKSB7XG4gICAgICAgIHZhciAkaW5kZXggPSBpbmRleCsrO1xuICAgICAgICB2YXIgYWxyZWFkeUNhbGxlZCA9IGZhbHNlO1xuICAgICAgICB2YWx1ZXMucHVzaCh1bmRlZmluZWQpO1xuICAgICAgICByZW1haW5pbmcrKztcbiAgICAgICAgQy5yZXNvbHZlKHByb21pc2UpLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgaWYgKGFscmVhZHlDYWxsZWQpIHJldHVybjtcbiAgICAgICAgICBhbHJlYWR5Q2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgICB2YWx1ZXNbJGluZGV4XSA9IHZhbHVlO1xuICAgICAgICAgIC0tcmVtYWluaW5nIHx8IHJlc29sdmUodmFsdWVzKTtcbiAgICAgICAgfSwgcmVqZWN0KTtcbiAgICAgIH0pO1xuICAgICAgLS1yZW1haW5pbmcgfHwgcmVzb2x2ZSh2YWx1ZXMpO1xuICAgIH0pO1xuICAgIGlmIChyZXN1bHQuZSkgcmVqZWN0KHJlc3VsdC52KTtcbiAgICByZXR1cm4gY2FwYWJpbGl0eS5wcm9taXNlO1xuICB9LFxuICAvLyAyNS40LjQuNCBQcm9taXNlLnJhY2UoaXRlcmFibGUpXG4gIHJhY2U6IGZ1bmN0aW9uIHJhY2UoaXRlcmFibGUpIHtcbiAgICB2YXIgQyA9IHRoaXM7XG4gICAgdmFyIGNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eShDKTtcbiAgICB2YXIgcmVqZWN0ID0gY2FwYWJpbGl0eS5yZWplY3Q7XG4gICAgdmFyIHJlc3VsdCA9IHBlcmZvcm0oZnVuY3Rpb24gKCkge1xuICAgICAgZm9yT2YoaXRlcmFibGUsIGZhbHNlLCBmdW5jdGlvbiAocHJvbWlzZSkge1xuICAgICAgICBDLnJlc29sdmUocHJvbWlzZSkudGhlbihjYXBhYmlsaXR5LnJlc29sdmUsIHJlamVjdCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBpZiAocmVzdWx0LmUpIHJlamVjdChyZXN1bHQudik7XG4gICAgcmV0dXJuIGNhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5wcm9taXNlLmpzIiwiLy8gMjYuMS4xIFJlZmxlY3QuYXBwbHkodGFyZ2V0LCB0aGlzQXJndW1lbnQsIGFyZ3VtZW50c0xpc3QpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIHJBcHBseSA9IChyZXF1aXJlKCcuL19nbG9iYWwnKS5SZWZsZWN0IHx8IHt9KS5hcHBseTtcbnZhciBmQXBwbHkgPSBGdW5jdGlvbi5hcHBseTtcbi8vIE1TIEVkZ2UgYXJndW1lbnRzTGlzdCBhcmd1bWVudCBpcyBvcHRpb25hbFxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbiAoKSB7XG4gIHJBcHBseShmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH0pO1xufSksICdSZWZsZWN0Jywge1xuICBhcHBseTogZnVuY3Rpb24gYXBwbHkodGFyZ2V0LCB0aGlzQXJndW1lbnQsIGFyZ3VtZW50c0xpc3QpIHtcbiAgICB2YXIgVCA9IGFGdW5jdGlvbih0YXJnZXQpO1xuICAgIHZhciBMID0gYW5PYmplY3QoYXJndW1lbnRzTGlzdCk7XG4gICAgcmV0dXJuIHJBcHBseSA/IHJBcHBseShULCB0aGlzQXJndW1lbnQsIEwpIDogZkFwcGx5LmNhbGwoVCwgdGhpc0FyZ3VtZW50LCBMKTtcbiAgfVxufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LmFwcGx5LmpzIiwiLy8gMjYuMS4yIFJlZmxlY3QuY29uc3RydWN0KHRhcmdldCwgYXJndW1lbnRzTGlzdCBbLCBuZXdUYXJnZXRdKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBjcmVhdGUgPSByZXF1aXJlKCcuL19vYmplY3QtY3JlYXRlJyk7XG52YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4vX2ZhaWxzJyk7XG52YXIgYmluZCA9IHJlcXVpcmUoJy4vX2JpbmQnKTtcbnZhciByQ29uc3RydWN0ID0gKHJlcXVpcmUoJy4vX2dsb2JhbCcpLlJlZmxlY3QgfHwge30pLmNvbnN0cnVjdDtcblxuLy8gTVMgRWRnZSBzdXBwb3J0cyBvbmx5IDIgYXJndW1lbnRzIGFuZCBhcmd1bWVudHNMaXN0IGFyZ3VtZW50IGlzIG9wdGlvbmFsXG4vLyBGRiBOaWdodGx5IHNldHMgdGhpcmQgYXJndW1lbnQgYXMgYG5ldy50YXJnZXRgLCBidXQgZG9lcyBub3QgY3JlYXRlIGB0aGlzYCBmcm9tIGl0XG52YXIgTkVXX1RBUkdFVF9CVUcgPSBmYWlscyhmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEYoKSB7IC8qIGVtcHR5ICovIH1cbiAgcmV0dXJuICEockNvbnN0cnVjdChmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH0sIFtdLCBGKSBpbnN0YW5jZW9mIEYpO1xufSk7XG52YXIgQVJHU19CVUcgPSAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICByQ29uc3RydWN0KGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfSk7XG59KTtcblxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAoTkVXX1RBUkdFVF9CVUcgfHwgQVJHU19CVUcpLCAnUmVmbGVjdCcsIHtcbiAgY29uc3RydWN0OiBmdW5jdGlvbiBjb25zdHJ1Y3QoVGFyZ2V0LCBhcmdzIC8qICwgbmV3VGFyZ2V0ICovKSB7XG4gICAgYUZ1bmN0aW9uKFRhcmdldCk7XG4gICAgYW5PYmplY3QoYXJncyk7XG4gICAgdmFyIG5ld1RhcmdldCA9IGFyZ3VtZW50cy5sZW5ndGggPCAzID8gVGFyZ2V0IDogYUZ1bmN0aW9uKGFyZ3VtZW50c1syXSk7XG4gICAgaWYgKEFSR1NfQlVHICYmICFORVdfVEFSR0VUX0JVRykgcmV0dXJuIHJDb25zdHJ1Y3QoVGFyZ2V0LCBhcmdzLCBuZXdUYXJnZXQpO1xuICAgIGlmIChUYXJnZXQgPT0gbmV3VGFyZ2V0KSB7XG4gICAgICAvLyB3L28gYWx0ZXJlZCBuZXdUYXJnZXQsIG9wdGltaXphdGlvbiBmb3IgMC00IGFyZ3VtZW50c1xuICAgICAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgICAgICBjYXNlIDA6IHJldHVybiBuZXcgVGFyZ2V0KCk7XG4gICAgICAgIGNhc2UgMTogcmV0dXJuIG5ldyBUYXJnZXQoYXJnc1swXSk7XG4gICAgICAgIGNhc2UgMjogcmV0dXJuIG5ldyBUYXJnZXQoYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgICAgIGNhc2UgMzogcmV0dXJuIG5ldyBUYXJnZXQoYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgICAgIGNhc2UgNDogcmV0dXJuIG5ldyBUYXJnZXQoYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSk7XG4gICAgICB9XG4gICAgICAvLyB3L28gYWx0ZXJlZCBuZXdUYXJnZXQsIGxvdCBvZiBhcmd1bWVudHMgY2FzZVxuICAgICAgdmFyICRhcmdzID0gW251bGxdO1xuICAgICAgJGFyZ3MucHVzaC5hcHBseSgkYXJncywgYXJncyk7XG4gICAgICByZXR1cm4gbmV3IChiaW5kLmFwcGx5KFRhcmdldCwgJGFyZ3MpKSgpO1xuICAgIH1cbiAgICAvLyB3aXRoIGFsdGVyZWQgbmV3VGFyZ2V0LCBub3Qgc3VwcG9ydCBidWlsdC1pbiBjb25zdHJ1Y3RvcnNcbiAgICB2YXIgcHJvdG8gPSBuZXdUYXJnZXQucHJvdG90eXBlO1xuICAgIHZhciBpbnN0YW5jZSA9IGNyZWF0ZShpc09iamVjdChwcm90bykgPyBwcm90byA6IE9iamVjdC5wcm90b3R5cGUpO1xuICAgIHZhciByZXN1bHQgPSBGdW5jdGlvbi5hcHBseS5jYWxsKFRhcmdldCwgaW5zdGFuY2UsIGFyZ3MpO1xuICAgIHJldHVybiBpc09iamVjdChyZXN1bHQpID8gcmVzdWx0IDogaW5zdGFuY2U7XG4gIH1cbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5jb25zdHJ1Y3QuanMiLCIvLyAyNi4xLjMgUmVmbGVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIHByb3BlcnR5S2V5LCBhdHRyaWJ1dGVzKVxudmFyIGRQID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJyk7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgdG9QcmltaXRpdmUgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKTtcblxuLy8gTVMgRWRnZSBoYXMgYnJva2VuIFJlZmxlY3QuZGVmaW5lUHJvcGVydHkgLSB0aHJvd2luZyBpbnN0ZWFkIG9mIHJldHVybmluZyBmYWxzZVxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiByZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uICgpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG4gIFJlZmxlY3QuZGVmaW5lUHJvcGVydHkoZFAuZih7fSwgMSwgeyB2YWx1ZTogMSB9KSwgMSwgeyB2YWx1ZTogMiB9KTtcbn0pLCAnUmVmbGVjdCcsIHtcbiAgZGVmaW5lUHJvcGVydHk6IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KHRhcmdldCwgcHJvcGVydHlLZXksIGF0dHJpYnV0ZXMpIHtcbiAgICBhbk9iamVjdCh0YXJnZXQpO1xuICAgIHByb3BlcnR5S2V5ID0gdG9QcmltaXRpdmUocHJvcGVydHlLZXksIHRydWUpO1xuICAgIGFuT2JqZWN0KGF0dHJpYnV0ZXMpO1xuICAgIHRyeSB7XG4gICAgICBkUC5mKHRhcmdldCwgcHJvcGVydHlLZXksIGF0dHJpYnV0ZXMpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LmRlZmluZS1wcm9wZXJ0eS5qcyIsIi8vIDI2LjEuNCBSZWZsZWN0LmRlbGV0ZVByb3BlcnR5KHRhcmdldCwgcHJvcGVydHlLZXkpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGdPUEQgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpLmY7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdSZWZsZWN0Jywge1xuICBkZWxldGVQcm9wZXJ0eTogZnVuY3Rpb24gZGVsZXRlUHJvcGVydHkodGFyZ2V0LCBwcm9wZXJ0eUtleSkge1xuICAgIHZhciBkZXNjID0gZ09QRChhbk9iamVjdCh0YXJnZXQpLCBwcm9wZXJ0eUtleSk7XG4gICAgcmV0dXJuIGRlc2MgJiYgIWRlc2MuY29uZmlndXJhYmxlID8gZmFsc2UgOiBkZWxldGUgdGFyZ2V0W3Byb3BlcnR5S2V5XTtcbiAgfVxufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LmRlbGV0ZS1wcm9wZXJ0eS5qcyIsIid1c2Ugc3RyaWN0Jztcbi8vIDI2LjEuNSBSZWZsZWN0LmVudW1lcmF0ZSh0YXJnZXQpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgRW51bWVyYXRlID0gZnVuY3Rpb24gKGl0ZXJhdGVkKSB7XG4gIHRoaXMuX3QgPSBhbk9iamVjdChpdGVyYXRlZCk7IC8vIHRhcmdldFxuICB0aGlzLl9pID0gMDsgICAgICAgICAgICAgICAgICAvLyBuZXh0IGluZGV4XG4gIHZhciBrZXlzID0gdGhpcy5fayA9IFtdOyAgICAgIC8vIGtleXNcbiAgdmFyIGtleTtcbiAgZm9yIChrZXkgaW4gaXRlcmF0ZWQpIGtleXMucHVzaChrZXkpO1xufTtcbnJlcXVpcmUoJy4vX2l0ZXItY3JlYXRlJykoRW51bWVyYXRlLCAnT2JqZWN0JywgZnVuY3Rpb24gKCkge1xuICB2YXIgdGhhdCA9IHRoaXM7XG4gIHZhciBrZXlzID0gdGhhdC5faztcbiAgdmFyIGtleTtcbiAgZG8ge1xuICAgIGlmICh0aGF0Ll9pID49IGtleXMubGVuZ3RoKSByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gIH0gd2hpbGUgKCEoKGtleSA9IGtleXNbdGhhdC5faSsrXSkgaW4gdGhhdC5fdCkpO1xuICByZXR1cm4geyB2YWx1ZToga2V5LCBkb25lOiBmYWxzZSB9O1xufSk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnUmVmbGVjdCcsIHtcbiAgZW51bWVyYXRlOiBmdW5jdGlvbiBlbnVtZXJhdGUodGFyZ2V0KSB7XG4gICAgcmV0dXJuIG5ldyBFbnVtZXJhdGUodGFyZ2V0KTtcbiAgfVxufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LmVudW1lcmF0ZS5qcyIsIi8vIDI2LjEuNyBSZWZsZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIHByb3BlcnR5S2V5KVxudmFyIGdPUEQgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ1JlZmxlY3QnLCB7XG4gIGdldE93blByb3BlcnR5RGVzY3JpcHRvcjogZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwgcHJvcGVydHlLZXkpIHtcbiAgICByZXR1cm4gZ09QRC5mKGFuT2JqZWN0KHRhcmdldCksIHByb3BlcnR5S2V5KTtcbiAgfVxufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LmdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvci5qcyIsIi8vIDI2LjEuOCBSZWZsZWN0LmdldFByb3RvdHlwZU9mKHRhcmdldClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgZ2V0UHJvdG8gPSByZXF1aXJlKCcuL19vYmplY3QtZ3BvJyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdSZWZsZWN0Jywge1xuICBnZXRQcm90b3R5cGVPZjogZnVuY3Rpb24gZ2V0UHJvdG90eXBlT2YodGFyZ2V0KSB7XG4gICAgcmV0dXJuIGdldFByb3RvKGFuT2JqZWN0KHRhcmdldCkpO1xuICB9XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QuZ2V0LXByb3RvdHlwZS1vZi5qcyIsIi8vIDI2LjEuNiBSZWZsZWN0LmdldCh0YXJnZXQsIHByb3BlcnR5S2V5IFssIHJlY2VpdmVyXSlcbnZhciBnT1BEID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKTtcbnZhciBnZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4vX29iamVjdC1ncG8nKTtcbnZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xuXG5mdW5jdGlvbiBnZXQodGFyZ2V0LCBwcm9wZXJ0eUtleSAvKiAsIHJlY2VpdmVyICovKSB7XG4gIHZhciByZWNlaXZlciA9IGFyZ3VtZW50cy5sZW5ndGggPCAzID8gdGFyZ2V0IDogYXJndW1lbnRzWzJdO1xuICB2YXIgZGVzYywgcHJvdG87XG4gIGlmIChhbk9iamVjdCh0YXJnZXQpID09PSByZWNlaXZlcikgcmV0dXJuIHRhcmdldFtwcm9wZXJ0eUtleV07XG4gIGlmIChkZXNjID0gZ09QRC5mKHRhcmdldCwgcHJvcGVydHlLZXkpKSByZXR1cm4gaGFzKGRlc2MsICd2YWx1ZScpXG4gICAgPyBkZXNjLnZhbHVlXG4gICAgOiBkZXNjLmdldCAhPT0gdW5kZWZpbmVkXG4gICAgICA/IGRlc2MuZ2V0LmNhbGwocmVjZWl2ZXIpXG4gICAgICA6IHVuZGVmaW5lZDtcbiAgaWYgKGlzT2JqZWN0KHByb3RvID0gZ2V0UHJvdG90eXBlT2YodGFyZ2V0KSkpIHJldHVybiBnZXQocHJvdG8sIHByb3BlcnR5S2V5LCByZWNlaXZlcik7XG59XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnUmVmbGVjdCcsIHsgZ2V0OiBnZXQgfSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LmdldC5qcyIsIi8vIDI2LjEuOSBSZWZsZWN0Lmhhcyh0YXJnZXQsIHByb3BlcnR5S2V5KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdSZWZsZWN0Jywge1xuICBoYXM6IGZ1bmN0aW9uIGhhcyh0YXJnZXQsIHByb3BlcnR5S2V5KSB7XG4gICAgcmV0dXJuIHByb3BlcnR5S2V5IGluIHRhcmdldDtcbiAgfVxufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0Lmhhcy5qcyIsIi8vIDI2LjEuMTAgUmVmbGVjdC5pc0V4dGVuc2libGUodGFyZ2V0KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyICRpc0V4dGVuc2libGUgPSBPYmplY3QuaXNFeHRlbnNpYmxlO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ1JlZmxlY3QnLCB7XG4gIGlzRXh0ZW5zaWJsZTogZnVuY3Rpb24gaXNFeHRlbnNpYmxlKHRhcmdldCkge1xuICAgIGFuT2JqZWN0KHRhcmdldCk7XG4gICAgcmV0dXJuICRpc0V4dGVuc2libGUgPyAkaXNFeHRlbnNpYmxlKHRhcmdldCkgOiB0cnVlO1xuICB9XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QuaXMtZXh0ZW5zaWJsZS5qcyIsIi8vIDI2LjEuMTEgUmVmbGVjdC5vd25LZXlzKHRhcmdldClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnUmVmbGVjdCcsIHsgb3duS2V5czogcmVxdWlyZSgnLi9fb3duLWtleXMnKSB9KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3Qub3duLWtleXMuanMiLCIvLyAyNi4xLjEyIFJlZmxlY3QucHJldmVudEV4dGVuc2lvbnModGFyZ2V0KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyICRwcmV2ZW50RXh0ZW5zaW9ucyA9IE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucztcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdSZWZsZWN0Jywge1xuICBwcmV2ZW50RXh0ZW5zaW9uczogZnVuY3Rpb24gcHJldmVudEV4dGVuc2lvbnModGFyZ2V0KSB7XG4gICAgYW5PYmplY3QodGFyZ2V0KTtcbiAgICB0cnkge1xuICAgICAgaWYgKCRwcmV2ZW50RXh0ZW5zaW9ucykgJHByZXZlbnRFeHRlbnNpb25zKHRhcmdldCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QucHJldmVudC1leHRlbnNpb25zLmpzIiwiLy8gMjYuMS4xNCBSZWZsZWN0LnNldFByb3RvdHlwZU9mKHRhcmdldCwgcHJvdG8pXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIHNldFByb3RvID0gcmVxdWlyZSgnLi9fc2V0LXByb3RvJyk7XG5cbmlmIChzZXRQcm90bykgJGV4cG9ydCgkZXhwb3J0LlMsICdSZWZsZWN0Jywge1xuICBzZXRQcm90b3R5cGVPZjogZnVuY3Rpb24gc2V0UHJvdG90eXBlT2YodGFyZ2V0LCBwcm90bykge1xuICAgIHNldFByb3RvLmNoZWNrKHRhcmdldCwgcHJvdG8pO1xuICAgIHRyeSB7XG4gICAgICBzZXRQcm90by5zZXQodGFyZ2V0LCBwcm90byk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3Quc2V0LXByb3RvdHlwZS1vZi5qcyIsIi8vIDI2LjEuMTMgUmVmbGVjdC5zZXQodGFyZ2V0LCBwcm9wZXJ0eUtleSwgViBbLCByZWNlaXZlcl0pXG52YXIgZFAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKTtcbnZhciBnT1BEID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKTtcbnZhciBnZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4vX29iamVjdC1ncG8nKTtcbnZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgY3JlYXRlRGVzYyA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG5cbmZ1bmN0aW9uIHNldCh0YXJnZXQsIHByb3BlcnR5S2V5LCBWIC8qICwgcmVjZWl2ZXIgKi8pIHtcbiAgdmFyIHJlY2VpdmVyID0gYXJndW1lbnRzLmxlbmd0aCA8IDQgPyB0YXJnZXQgOiBhcmd1bWVudHNbM107XG4gIHZhciBvd25EZXNjID0gZ09QRC5mKGFuT2JqZWN0KHRhcmdldCksIHByb3BlcnR5S2V5KTtcbiAgdmFyIGV4aXN0aW5nRGVzY3JpcHRvciwgcHJvdG87XG4gIGlmICghb3duRGVzYykge1xuICAgIGlmIChpc09iamVjdChwcm90byA9IGdldFByb3RvdHlwZU9mKHRhcmdldCkpKSB7XG4gICAgICByZXR1cm4gc2V0KHByb3RvLCBwcm9wZXJ0eUtleSwgViwgcmVjZWl2ZXIpO1xuICAgIH1cbiAgICBvd25EZXNjID0gY3JlYXRlRGVzYygwKTtcbiAgfVxuICBpZiAoaGFzKG93bkRlc2MsICd2YWx1ZScpKSB7XG4gICAgaWYgKG93bkRlc2Mud3JpdGFibGUgPT09IGZhbHNlIHx8ICFpc09iamVjdChyZWNlaXZlcikpIHJldHVybiBmYWxzZTtcbiAgICBleGlzdGluZ0Rlc2NyaXB0b3IgPSBnT1BELmYocmVjZWl2ZXIsIHByb3BlcnR5S2V5KSB8fCBjcmVhdGVEZXNjKDApO1xuICAgIGV4aXN0aW5nRGVzY3JpcHRvci52YWx1ZSA9IFY7XG4gICAgZFAuZihyZWNlaXZlciwgcHJvcGVydHlLZXksIGV4aXN0aW5nRGVzY3JpcHRvcik7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIG93bkRlc2Muc2V0ID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IChvd25EZXNjLnNldC5jYWxsKHJlY2VpdmVyLCBWKSwgdHJ1ZSk7XG59XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnUmVmbGVjdCcsIHsgc2V0OiBzZXQgfSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LnNldC5qcyIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBpbmhlcml0SWZSZXF1aXJlZCA9IHJlcXVpcmUoJy4vX2luaGVyaXQtaWYtcmVxdWlyZWQnKTtcbnZhciBkUCA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmY7XG52YXIgZ09QTiA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BuJykuZjtcbnZhciBpc1JlZ0V4cCA9IHJlcXVpcmUoJy4vX2lzLXJlZ2V4cCcpO1xudmFyICRmbGFncyA9IHJlcXVpcmUoJy4vX2ZsYWdzJyk7XG52YXIgJFJlZ0V4cCA9IGdsb2JhbC5SZWdFeHA7XG52YXIgQmFzZSA9ICRSZWdFeHA7XG52YXIgcHJvdG8gPSAkUmVnRXhwLnByb3RvdHlwZTtcbnZhciByZTEgPSAvYS9nO1xudmFyIHJlMiA9IC9hL2c7XG4vLyBcIm5ld1wiIGNyZWF0ZXMgYSBuZXcgb2JqZWN0LCBvbGQgd2Via2l0IGJ1Z2d5IGhlcmVcbnZhciBDT1JSRUNUX05FVyA9IG5ldyAkUmVnRXhwKHJlMSkgIT09IHJlMTtcblxuaWYgKHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgJiYgKCFDT1JSRUNUX05FVyB8fCByZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uICgpIHtcbiAgcmUyW3JlcXVpcmUoJy4vX3drcycpKCdtYXRjaCcpXSA9IGZhbHNlO1xuICAvLyBSZWdFeHAgY29uc3RydWN0b3IgY2FuIGFsdGVyIGZsYWdzIGFuZCBJc1JlZ0V4cCB3b3JrcyBjb3JyZWN0IHdpdGggQEBtYXRjaFxuICByZXR1cm4gJFJlZ0V4cChyZTEpICE9IHJlMSB8fCAkUmVnRXhwKHJlMikgPT0gcmUyIHx8ICRSZWdFeHAocmUxLCAnaScpICE9ICcvYS9pJztcbn0pKSkge1xuICAkUmVnRXhwID0gZnVuY3Rpb24gUmVnRXhwKHAsIGYpIHtcbiAgICB2YXIgdGlSRSA9IHRoaXMgaW5zdGFuY2VvZiAkUmVnRXhwO1xuICAgIHZhciBwaVJFID0gaXNSZWdFeHAocCk7XG4gICAgdmFyIGZpVSA9IGYgPT09IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gIXRpUkUgJiYgcGlSRSAmJiBwLmNvbnN0cnVjdG9yID09PSAkUmVnRXhwICYmIGZpVSA/IHBcbiAgICAgIDogaW5oZXJpdElmUmVxdWlyZWQoQ09SUkVDVF9ORVdcbiAgICAgICAgPyBuZXcgQmFzZShwaVJFICYmICFmaVUgPyBwLnNvdXJjZSA6IHAsIGYpXG4gICAgICAgIDogQmFzZSgocGlSRSA9IHAgaW5zdGFuY2VvZiAkUmVnRXhwKSA/IHAuc291cmNlIDogcCwgcGlSRSAmJiBmaVUgPyAkZmxhZ3MuY2FsbChwKSA6IGYpXG4gICAgICAsIHRpUkUgPyB0aGlzIDogcHJvdG8sICRSZWdFeHApO1xuICB9O1xuICB2YXIgcHJveHkgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAga2V5IGluICRSZWdFeHAgfHwgZFAoJFJlZ0V4cCwga2V5LCB7XG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIEJhc2Vba2V5XTsgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gKGl0KSB7IEJhc2Vba2V5XSA9IGl0OyB9XG4gICAgfSk7XG4gIH07XG4gIGZvciAodmFyIGtleXMgPSBnT1BOKEJhc2UpLCBpID0gMDsga2V5cy5sZW5ndGggPiBpOykgcHJveHkoa2V5c1tpKytdKTtcbiAgcHJvdG8uY29uc3RydWN0b3IgPSAkUmVnRXhwO1xuICAkUmVnRXhwLnByb3RvdHlwZSA9IHByb3RvO1xuICByZXF1aXJlKCcuL19yZWRlZmluZScpKGdsb2JhbCwgJ1JlZ0V4cCcsICRSZWdFeHApO1xufVxuXG5yZXF1aXJlKCcuL19zZXQtc3BlY2llcycpKCdSZWdFeHAnKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZ2V4cC5jb25zdHJ1Y3Rvci5qcyIsIi8vIDIxLjIuNS4zIGdldCBSZWdFeHAucHJvdG90eXBlLmZsYWdzKClcbmlmIChyZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpICYmIC8uL2cuZmxhZ3MgIT0gJ2cnKSByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mKFJlZ0V4cC5wcm90b3R5cGUsICdmbGFncycsIHtcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBnZXQ6IHJlcXVpcmUoJy4vX2ZsYWdzJylcbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVnZXhwLmZsYWdzLmpzIiwiLy8gQEBtYXRjaCBsb2dpY1xucmVxdWlyZSgnLi9fZml4LXJlLXdrcycpKCdtYXRjaCcsIDEsIGZ1bmN0aW9uIChkZWZpbmVkLCBNQVRDSCwgJG1hdGNoKSB7XG4gIC8vIDIxLjEuMy4xMSBTdHJpbmcucHJvdG90eXBlLm1hdGNoKHJlZ2V4cClcbiAgcmV0dXJuIFtmdW5jdGlvbiBtYXRjaChyZWdleHApIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgdmFyIE8gPSBkZWZpbmVkKHRoaXMpO1xuICAgIHZhciBmbiA9IHJlZ2V4cCA9PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiByZWdleHBbTUFUQ0hdO1xuICAgIHJldHVybiBmbiAhPT0gdW5kZWZpbmVkID8gZm4uY2FsbChyZWdleHAsIE8pIDogbmV3IFJlZ0V4cChyZWdleHApW01BVENIXShTdHJpbmcoTykpO1xuICB9LCAkbWF0Y2hdO1xufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWdleHAubWF0Y2guanMiLCIvLyBAQHJlcGxhY2UgbG9naWNcbnJlcXVpcmUoJy4vX2ZpeC1yZS13a3MnKSgncmVwbGFjZScsIDIsIGZ1bmN0aW9uIChkZWZpbmVkLCBSRVBMQUNFLCAkcmVwbGFjZSkge1xuICAvLyAyMS4xLjMuMTQgU3RyaW5nLnByb3RvdHlwZS5yZXBsYWNlKHNlYXJjaFZhbHVlLCByZXBsYWNlVmFsdWUpXG4gIHJldHVybiBbZnVuY3Rpb24gcmVwbGFjZShzZWFyY2hWYWx1ZSwgcmVwbGFjZVZhbHVlKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIHZhciBPID0gZGVmaW5lZCh0aGlzKTtcbiAgICB2YXIgZm4gPSBzZWFyY2hWYWx1ZSA9PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBzZWFyY2hWYWx1ZVtSRVBMQUNFXTtcbiAgICByZXR1cm4gZm4gIT09IHVuZGVmaW5lZFxuICAgICAgPyBmbi5jYWxsKHNlYXJjaFZhbHVlLCBPLCByZXBsYWNlVmFsdWUpXG4gICAgICA6ICRyZXBsYWNlLmNhbGwoU3RyaW5nKE8pLCBzZWFyY2hWYWx1ZSwgcmVwbGFjZVZhbHVlKTtcbiAgfSwgJHJlcGxhY2VdO1xufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWdleHAucmVwbGFjZS5qcyIsIi8vIEBAc2VhcmNoIGxvZ2ljXG5yZXF1aXJlKCcuL19maXgtcmUtd2tzJykoJ3NlYXJjaCcsIDEsIGZ1bmN0aW9uIChkZWZpbmVkLCBTRUFSQ0gsICRzZWFyY2gpIHtcbiAgLy8gMjEuMS4zLjE1IFN0cmluZy5wcm90b3R5cGUuc2VhcmNoKHJlZ2V4cClcbiAgcmV0dXJuIFtmdW5jdGlvbiBzZWFyY2gocmVnZXhwKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIHZhciBPID0gZGVmaW5lZCh0aGlzKTtcbiAgICB2YXIgZm4gPSByZWdleHAgPT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogcmVnZXhwW1NFQVJDSF07XG4gICAgcmV0dXJuIGZuICE9PSB1bmRlZmluZWQgPyBmbi5jYWxsKHJlZ2V4cCwgTykgOiBuZXcgUmVnRXhwKHJlZ2V4cClbU0VBUkNIXShTdHJpbmcoTykpO1xuICB9LCAkc2VhcmNoXTtcbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVnZXhwLnNlYXJjaC5qcyIsIi8vIEBAc3BsaXQgbG9naWNcbnJlcXVpcmUoJy4vX2ZpeC1yZS13a3MnKSgnc3BsaXQnLCAyLCBmdW5jdGlvbiAoZGVmaW5lZCwgU1BMSVQsICRzcGxpdCkge1xuICAndXNlIHN0cmljdCc7XG4gIHZhciBpc1JlZ0V4cCA9IHJlcXVpcmUoJy4vX2lzLXJlZ2V4cCcpO1xuICB2YXIgX3NwbGl0ID0gJHNwbGl0O1xuICB2YXIgJHB1c2ggPSBbXS5wdXNoO1xuICB2YXIgJFNQTElUID0gJ3NwbGl0JztcbiAgdmFyIExFTkdUSCA9ICdsZW5ndGgnO1xuICB2YXIgTEFTVF9JTkRFWCA9ICdsYXN0SW5kZXgnO1xuICBpZiAoXG4gICAgJ2FiYmMnWyRTUExJVF0oLyhiKSovKVsxXSA9PSAnYycgfHxcbiAgICAndGVzdCdbJFNQTElUXSgvKD86KS8sIC0xKVtMRU5HVEhdICE9IDQgfHxcbiAgICAnYWInWyRTUExJVF0oLyg/OmFiKSovKVtMRU5HVEhdICE9IDIgfHxcbiAgICAnLidbJFNQTElUXSgvKC4/KSguPykvKVtMRU5HVEhdICE9IDQgfHxcbiAgICAnLidbJFNQTElUXSgvKCkoKS8pW0xFTkdUSF0gPiAxIHx8XG4gICAgJydbJFNQTElUXSgvLj8vKVtMRU5HVEhdXG4gICkge1xuICAgIHZhciBOUENHID0gLygpPz8vLmV4ZWMoJycpWzFdID09PSB1bmRlZmluZWQ7IC8vIG5vbnBhcnRpY2lwYXRpbmcgY2FwdHVyaW5nIGdyb3VwXG4gICAgLy8gYmFzZWQgb24gZXM1LXNoaW0gaW1wbGVtZW50YXRpb24sIG5lZWQgdG8gcmV3b3JrIGl0XG4gICAgJHNwbGl0ID0gZnVuY3Rpb24gKHNlcGFyYXRvciwgbGltaXQpIHtcbiAgICAgIHZhciBzdHJpbmcgPSBTdHJpbmcodGhpcyk7XG4gICAgICBpZiAoc2VwYXJhdG9yID09PSB1bmRlZmluZWQgJiYgbGltaXQgPT09IDApIHJldHVybiBbXTtcbiAgICAgIC8vIElmIGBzZXBhcmF0b3JgIGlzIG5vdCBhIHJlZ2V4LCB1c2UgbmF0aXZlIHNwbGl0XG4gICAgICBpZiAoIWlzUmVnRXhwKHNlcGFyYXRvcikpIHJldHVybiBfc3BsaXQuY2FsbChzdHJpbmcsIHNlcGFyYXRvciwgbGltaXQpO1xuICAgICAgdmFyIG91dHB1dCA9IFtdO1xuICAgICAgdmFyIGZsYWdzID0gKHNlcGFyYXRvci5pZ25vcmVDYXNlID8gJ2knIDogJycpICtcbiAgICAgICAgICAgICAgICAgIChzZXBhcmF0b3IubXVsdGlsaW5lID8gJ20nIDogJycpICtcbiAgICAgICAgICAgICAgICAgIChzZXBhcmF0b3IudW5pY29kZSA/ICd1JyA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAoc2VwYXJhdG9yLnN0aWNreSA/ICd5JyA6ICcnKTtcbiAgICAgIHZhciBsYXN0TGFzdEluZGV4ID0gMDtcbiAgICAgIHZhciBzcGxpdExpbWl0ID0gbGltaXQgPT09IHVuZGVmaW5lZCA/IDQyOTQ5NjcyOTUgOiBsaW1pdCA+Pj4gMDtcbiAgICAgIC8vIE1ha2UgYGdsb2JhbGAgYW5kIGF2b2lkIGBsYXN0SW5kZXhgIGlzc3VlcyBieSB3b3JraW5nIHdpdGggYSBjb3B5XG4gICAgICB2YXIgc2VwYXJhdG9yQ29weSA9IG5ldyBSZWdFeHAoc2VwYXJhdG9yLnNvdXJjZSwgZmxhZ3MgKyAnZycpO1xuICAgICAgdmFyIHNlcGFyYXRvcjIsIG1hdGNoLCBsYXN0SW5kZXgsIGxhc3RMZW5ndGgsIGk7XG4gICAgICAvLyBEb2Vzbid0IG5lZWQgZmxhZ3MgZ3ksIGJ1dCB0aGV5IGRvbid0IGh1cnRcbiAgICAgIGlmICghTlBDRykgc2VwYXJhdG9yMiA9IG5ldyBSZWdFeHAoJ14nICsgc2VwYXJhdG9yQ29weS5zb3VyY2UgKyAnJCg/IVxcXFxzKScsIGZsYWdzKTtcbiAgICAgIHdoaWxlIChtYXRjaCA9IHNlcGFyYXRvckNvcHkuZXhlYyhzdHJpbmcpKSB7XG4gICAgICAgIC8vIGBzZXBhcmF0b3JDb3B5Lmxhc3RJbmRleGAgaXMgbm90IHJlbGlhYmxlIGNyb3NzLWJyb3dzZXJcbiAgICAgICAgbGFzdEluZGV4ID0gbWF0Y2guaW5kZXggKyBtYXRjaFswXVtMRU5HVEhdO1xuICAgICAgICBpZiAobGFzdEluZGV4ID4gbGFzdExhc3RJbmRleCkge1xuICAgICAgICAgIG91dHB1dC5wdXNoKHN0cmluZy5zbGljZShsYXN0TGFzdEluZGV4LCBtYXRjaC5pbmRleCkpO1xuICAgICAgICAgIC8vIEZpeCBicm93c2VycyB3aG9zZSBgZXhlY2AgbWV0aG9kcyBkb24ndCBjb25zaXN0ZW50bHkgcmV0dXJuIGB1bmRlZmluZWRgIGZvciBOUENHXG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWxvb3AtZnVuY1xuICAgICAgICAgIGlmICghTlBDRyAmJiBtYXRjaFtMRU5HVEhdID4gMSkgbWF0Y2hbMF0ucmVwbGFjZShzZXBhcmF0b3IyLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBmb3IgKGkgPSAxOyBpIDwgYXJndW1lbnRzW0xFTkdUSF0gLSAyOyBpKyspIGlmIChhcmd1bWVudHNbaV0gPT09IHVuZGVmaW5lZCkgbWF0Y2hbaV0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKG1hdGNoW0xFTkdUSF0gPiAxICYmIG1hdGNoLmluZGV4IDwgc3RyaW5nW0xFTkdUSF0pICRwdXNoLmFwcGx5KG91dHB1dCwgbWF0Y2guc2xpY2UoMSkpO1xuICAgICAgICAgIGxhc3RMZW5ndGggPSBtYXRjaFswXVtMRU5HVEhdO1xuICAgICAgICAgIGxhc3RMYXN0SW5kZXggPSBsYXN0SW5kZXg7XG4gICAgICAgICAgaWYgKG91dHB1dFtMRU5HVEhdID49IHNwbGl0TGltaXQpIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZXBhcmF0b3JDb3B5W0xBU1RfSU5ERVhdID09PSBtYXRjaC5pbmRleCkgc2VwYXJhdG9yQ29weVtMQVNUX0lOREVYXSsrOyAvLyBBdm9pZCBhbiBpbmZpbml0ZSBsb29wXG4gICAgICB9XG4gICAgICBpZiAobGFzdExhc3RJbmRleCA9PT0gc3RyaW5nW0xFTkdUSF0pIHtcbiAgICAgICAgaWYgKGxhc3RMZW5ndGggfHwgIXNlcGFyYXRvckNvcHkudGVzdCgnJykpIG91dHB1dC5wdXNoKCcnKTtcbiAgICAgIH0gZWxzZSBvdXRwdXQucHVzaChzdHJpbmcuc2xpY2UobGFzdExhc3RJbmRleCkpO1xuICAgICAgcmV0dXJuIG91dHB1dFtMRU5HVEhdID4gc3BsaXRMaW1pdCA/IG91dHB1dC5zbGljZSgwLCBzcGxpdExpbWl0KSA6IG91dHB1dDtcbiAgICB9O1xuICAvLyBDaGFrcmEsIFY4XG4gIH0gZWxzZSBpZiAoJzAnWyRTUExJVF0odW5kZWZpbmVkLCAwKVtMRU5HVEhdKSB7XG4gICAgJHNwbGl0ID0gZnVuY3Rpb24gKHNlcGFyYXRvciwgbGltaXQpIHtcbiAgICAgIHJldHVybiBzZXBhcmF0b3IgPT09IHVuZGVmaW5lZCAmJiBsaW1pdCA9PT0gMCA/IFtdIDogX3NwbGl0LmNhbGwodGhpcywgc2VwYXJhdG9yLCBsaW1pdCk7XG4gICAgfTtcbiAgfVxuICAvLyAyMS4xLjMuMTcgU3RyaW5nLnByb3RvdHlwZS5zcGxpdChzZXBhcmF0b3IsIGxpbWl0KVxuICByZXR1cm4gW2Z1bmN0aW9uIHNwbGl0KHNlcGFyYXRvciwgbGltaXQpIHtcbiAgICB2YXIgTyA9IGRlZmluZWQodGhpcyk7XG4gICAgdmFyIGZuID0gc2VwYXJhdG9yID09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IHNlcGFyYXRvcltTUExJVF07XG4gICAgcmV0dXJuIGZuICE9PSB1bmRlZmluZWQgPyBmbi5jYWxsKHNlcGFyYXRvciwgTywgbGltaXQpIDogJHNwbGl0LmNhbGwoU3RyaW5nKE8pLCBzZXBhcmF0b3IsIGxpbWl0KTtcbiAgfSwgJHNwbGl0XTtcbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVnZXhwLnNwbGl0LmpzIiwiJ3VzZSBzdHJpY3QnO1xucmVxdWlyZSgnLi9lczYucmVnZXhwLmZsYWdzJyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciAkZmxhZ3MgPSByZXF1aXJlKCcuL19mbGFncycpO1xudmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKTtcbnZhciBUT19TVFJJTkcgPSAndG9TdHJpbmcnO1xudmFyICR0b1N0cmluZyA9IC8uL1tUT19TVFJJTkddO1xuXG52YXIgZGVmaW5lID0gZnVuY3Rpb24gKGZuKSB7XG4gIHJlcXVpcmUoJy4vX3JlZGVmaW5lJykoUmVnRXhwLnByb3RvdHlwZSwgVE9fU1RSSU5HLCBmbiwgdHJ1ZSk7XG59O1xuXG4vLyAyMS4yLjUuMTQgUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZygpXG5pZiAocmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbiAoKSB7IHJldHVybiAkdG9TdHJpbmcuY2FsbCh7IHNvdXJjZTogJ2EnLCBmbGFnczogJ2InIH0pICE9ICcvYS9iJzsgfSkpIHtcbiAgZGVmaW5lKGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHZhciBSID0gYW5PYmplY3QodGhpcyk7XG4gICAgcmV0dXJuICcvJy5jb25jYXQoUi5zb3VyY2UsICcvJyxcbiAgICAgICdmbGFncycgaW4gUiA/IFIuZmxhZ3MgOiAhREVTQ1JJUFRPUlMgJiYgUiBpbnN0YW5jZW9mIFJlZ0V4cCA/ICRmbGFncy5jYWxsKFIpIDogdW5kZWZpbmVkKTtcbiAgfSk7XG4vLyBGRjQ0LSBSZWdFeHAjdG9TdHJpbmcgaGFzIGEgd3JvbmcgbmFtZVxufSBlbHNlIGlmICgkdG9TdHJpbmcubmFtZSAhPSBUT19TVFJJTkcpIHtcbiAgZGVmaW5lKGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiAkdG9TdHJpbmcuY2FsbCh0aGlzKTtcbiAgfSk7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWdleHAudG8tc3RyaW5nLmpzIiwiJ3VzZSBzdHJpY3QnO1xudmFyIHN0cm9uZyA9IHJlcXVpcmUoJy4vX2NvbGxlY3Rpb24tc3Ryb25nJyk7XG52YXIgdmFsaWRhdGUgPSByZXF1aXJlKCcuL192YWxpZGF0ZS1jb2xsZWN0aW9uJyk7XG52YXIgU0VUID0gJ1NldCc7XG5cbi8vIDIzLjIgU2V0IE9iamVjdHNcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fY29sbGVjdGlvbicpKFNFVCwgZnVuY3Rpb24gKGdldCkge1xuICByZXR1cm4gZnVuY3Rpb24gU2V0KCkgeyByZXR1cm4gZ2V0KHRoaXMsIGFyZ3VtZW50cy5sZW5ndGggPiAwID8gYXJndW1lbnRzWzBdIDogdW5kZWZpbmVkKTsgfTtcbn0sIHtcbiAgLy8gMjMuMi4zLjEgU2V0LnByb3RvdHlwZS5hZGQodmFsdWUpXG4gIGFkZDogZnVuY3Rpb24gYWRkKHZhbHVlKSB7XG4gICAgcmV0dXJuIHN0cm9uZy5kZWYodmFsaWRhdGUodGhpcywgU0VUKSwgdmFsdWUgPSB2YWx1ZSA9PT0gMCA/IDAgOiB2YWx1ZSwgdmFsdWUpO1xuICB9XG59LCBzdHJvbmcpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc2V0LmpzIiwiJ3VzZSBzdHJpY3QnO1xuLy8gQi4yLjMuMiBTdHJpbmcucHJvdG90eXBlLmFuY2hvcihuYW1lKVxucmVxdWlyZSgnLi9fc3RyaW5nLWh0bWwnKSgnYW5jaG9yJywgZnVuY3Rpb24gKGNyZWF0ZUhUTUwpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGFuY2hvcihuYW1lKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUhUTUwodGhpcywgJ2EnLCAnbmFtZScsIG5hbWUpO1xuICB9O1xufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuYW5jaG9yLmpzIiwiJ3VzZSBzdHJpY3QnO1xuLy8gQi4yLjMuMyBTdHJpbmcucHJvdG90eXBlLmJpZygpXG5yZXF1aXJlKCcuL19zdHJpbmctaHRtbCcpKCdiaWcnLCBmdW5jdGlvbiAoY3JlYXRlSFRNTCkge1xuICByZXR1cm4gZnVuY3Rpb24gYmlnKCkge1xuICAgIHJldHVybiBjcmVhdGVIVE1MKHRoaXMsICdiaWcnLCAnJywgJycpO1xuICB9O1xufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuYmlnLmpzIiwiJ3VzZSBzdHJpY3QnO1xuLy8gQi4yLjMuNCBTdHJpbmcucHJvdG90eXBlLmJsaW5rKClcbnJlcXVpcmUoJy4vX3N0cmluZy1odG1sJykoJ2JsaW5rJywgZnVuY3Rpb24gKGNyZWF0ZUhUTUwpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGJsaW5rKCkge1xuICAgIHJldHVybiBjcmVhdGVIVE1MKHRoaXMsICdibGluaycsICcnLCAnJyk7XG4gIH07XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5ibGluay5qcyIsIid1c2Ugc3RyaWN0Jztcbi8vIEIuMi4zLjUgU3RyaW5nLnByb3RvdHlwZS5ib2xkKClcbnJlcXVpcmUoJy4vX3N0cmluZy1odG1sJykoJ2JvbGQnLCBmdW5jdGlvbiAoY3JlYXRlSFRNTCkge1xuICByZXR1cm4gZnVuY3Rpb24gYm9sZCgpIHtcbiAgICByZXR1cm4gY3JlYXRlSFRNTCh0aGlzLCAnYicsICcnLCAnJyk7XG4gIH07XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5ib2xkLmpzIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciAkYXQgPSByZXF1aXJlKCcuL19zdHJpbmctYXQnKShmYWxzZSk7XG4kZXhwb3J0KCRleHBvcnQuUCwgJ1N0cmluZycsIHtcbiAgLy8gMjEuMS4zLjMgU3RyaW5nLnByb3RvdHlwZS5jb2RlUG9pbnRBdChwb3MpXG4gIGNvZGVQb2ludEF0OiBmdW5jdGlvbiBjb2RlUG9pbnRBdChwb3MpIHtcbiAgICByZXR1cm4gJGF0KHRoaXMsIHBvcyk7XG4gIH1cbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmNvZGUtcG9pbnQtYXQuanMiLCIvLyAyMS4xLjMuNiBTdHJpbmcucHJvdG90eXBlLmVuZHNXaXRoKHNlYXJjaFN0cmluZyBbLCBlbmRQb3NpdGlvbl0pXG4ndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG52YXIgY29udGV4dCA9IHJlcXVpcmUoJy4vX3N0cmluZy1jb250ZXh0Jyk7XG52YXIgRU5EU19XSVRIID0gJ2VuZHNXaXRoJztcbnZhciAkZW5kc1dpdGggPSAnJ1tFTkRTX1dJVEhdO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIHJlcXVpcmUoJy4vX2ZhaWxzLWlzLXJlZ2V4cCcpKEVORFNfV0lUSCksICdTdHJpbmcnLCB7XG4gIGVuZHNXaXRoOiBmdW5jdGlvbiBlbmRzV2l0aChzZWFyY2hTdHJpbmcgLyogLCBlbmRQb3NpdGlvbiA9IEBsZW5ndGggKi8pIHtcbiAgICB2YXIgdGhhdCA9IGNvbnRleHQodGhpcywgc2VhcmNoU3RyaW5nLCBFTkRTX1dJVEgpO1xuICAgIHZhciBlbmRQb3NpdGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkO1xuICAgIHZhciBsZW4gPSB0b0xlbmd0aCh0aGF0Lmxlbmd0aCk7XG4gICAgdmFyIGVuZCA9IGVuZFBvc2l0aW9uID09PSB1bmRlZmluZWQgPyBsZW4gOiBNYXRoLm1pbih0b0xlbmd0aChlbmRQb3NpdGlvbiksIGxlbik7XG4gICAgdmFyIHNlYXJjaCA9IFN0cmluZyhzZWFyY2hTdHJpbmcpO1xuICAgIHJldHVybiAkZW5kc1dpdGhcbiAgICAgID8gJGVuZHNXaXRoLmNhbGwodGhhdCwgc2VhcmNoLCBlbmQpXG4gICAgICA6IHRoYXQuc2xpY2UoZW5kIC0gc2VhcmNoLmxlbmd0aCwgZW5kKSA9PT0gc2VhcmNoO1xuICB9XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5lbmRzLXdpdGguanMiLCIndXNlIHN0cmljdCc7XG4vLyBCLjIuMy42IFN0cmluZy5wcm90b3R5cGUuZml4ZWQoKVxucmVxdWlyZSgnLi9fc3RyaW5nLWh0bWwnKSgnZml4ZWQnLCBmdW5jdGlvbiAoY3JlYXRlSFRNTCkge1xuICByZXR1cm4gZnVuY3Rpb24gZml4ZWQoKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUhUTUwodGhpcywgJ3R0JywgJycsICcnKTtcbiAgfTtcbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmZpeGVkLmpzIiwiJ3VzZSBzdHJpY3QnO1xuLy8gQi4yLjMuNyBTdHJpbmcucHJvdG90eXBlLmZvbnRjb2xvcihjb2xvcilcbnJlcXVpcmUoJy4vX3N0cmluZy1odG1sJykoJ2ZvbnRjb2xvcicsIGZ1bmN0aW9uIChjcmVhdGVIVE1MKSB7XG4gIHJldHVybiBmdW5jdGlvbiBmb250Y29sb3IoY29sb3IpIHtcbiAgICByZXR1cm4gY3JlYXRlSFRNTCh0aGlzLCAnZm9udCcsICdjb2xvcicsIGNvbG9yKTtcbiAgfTtcbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmZvbnRjb2xvci5qcyIsIid1c2Ugc3RyaWN0Jztcbi8vIEIuMi4zLjggU3RyaW5nLnByb3RvdHlwZS5mb250c2l6ZShzaXplKVxucmVxdWlyZSgnLi9fc3RyaW5nLWh0bWwnKSgnZm9udHNpemUnLCBmdW5jdGlvbiAoY3JlYXRlSFRNTCkge1xuICByZXR1cm4gZnVuY3Rpb24gZm9udHNpemUoc2l6ZSkge1xuICAgIHJldHVybiBjcmVhdGVIVE1MKHRoaXMsICdmb250JywgJ3NpemUnLCBzaXplKTtcbiAgfTtcbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmZvbnRzaXplLmpzIiwidmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciB0b0Fic29sdXRlSW5kZXggPSByZXF1aXJlKCcuL190by1hYnNvbHV0ZS1pbmRleCcpO1xudmFyIGZyb21DaGFyQ29kZSA9IFN0cmluZy5mcm9tQ2hhckNvZGU7XG52YXIgJGZyb21Db2RlUG9pbnQgPSBTdHJpbmcuZnJvbUNvZGVQb2ludDtcblxuLy8gbGVuZ3RoIHNob3VsZCBiZSAxLCBvbGQgRkYgcHJvYmxlbVxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAoISEkZnJvbUNvZGVQb2ludCAmJiAkZnJvbUNvZGVQb2ludC5sZW5ndGggIT0gMSksICdTdHJpbmcnLCB7XG4gIC8vIDIxLjEuMi4yIFN0cmluZy5mcm9tQ29kZVBvaW50KC4uLmNvZGVQb2ludHMpXG4gIGZyb21Db2RlUG9pbnQ6IGZ1bmN0aW9uIGZyb21Db2RlUG9pbnQoeCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgdmFyIHJlcyA9IFtdO1xuICAgIHZhciBhTGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGNvZGU7XG4gICAgd2hpbGUgKGFMZW4gPiBpKSB7XG4gICAgICBjb2RlID0gK2FyZ3VtZW50c1tpKytdO1xuICAgICAgaWYgKHRvQWJzb2x1dGVJbmRleChjb2RlLCAweDEwZmZmZikgIT09IGNvZGUpIHRocm93IFJhbmdlRXJyb3IoY29kZSArICcgaXMgbm90IGEgdmFsaWQgY29kZSBwb2ludCcpO1xuICAgICAgcmVzLnB1c2goY29kZSA8IDB4MTAwMDBcbiAgICAgICAgPyBmcm9tQ2hhckNvZGUoY29kZSlcbiAgICAgICAgOiBmcm9tQ2hhckNvZGUoKChjb2RlIC09IDB4MTAwMDApID4+IDEwKSArIDB4ZDgwMCwgY29kZSAlIDB4NDAwICsgMHhkYzAwKVxuICAgICAgKTtcbiAgICB9IHJldHVybiByZXMuam9pbignJyk7XG4gIH1cbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmZyb20tY29kZS1wb2ludC5qcyIsIi8vIDIxLjEuMy43IFN0cmluZy5wcm90b3R5cGUuaW5jbHVkZXMoc2VhcmNoU3RyaW5nLCBwb3NpdGlvbiA9IDApXG4ndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGNvbnRleHQgPSByZXF1aXJlKCcuL19zdHJpbmctY29udGV4dCcpO1xudmFyIElOQ0xVREVTID0gJ2luY2x1ZGVzJztcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiByZXF1aXJlKCcuL19mYWlscy1pcy1yZWdleHAnKShJTkNMVURFUyksICdTdHJpbmcnLCB7XG4gIGluY2x1ZGVzOiBmdW5jdGlvbiBpbmNsdWRlcyhzZWFyY2hTdHJpbmcgLyogLCBwb3NpdGlvbiA9IDAgKi8pIHtcbiAgICByZXR1cm4gISF+Y29udGV4dCh0aGlzLCBzZWFyY2hTdHJpbmcsIElOQ0xVREVTKVxuICAgICAgLmluZGV4T2Yoc2VhcmNoU3RyaW5nLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gIH1cbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmluY2x1ZGVzLmpzIiwiJ3VzZSBzdHJpY3QnO1xuLy8gQi4yLjMuOSBTdHJpbmcucHJvdG90eXBlLml0YWxpY3MoKVxucmVxdWlyZSgnLi9fc3RyaW5nLWh0bWwnKSgnaXRhbGljcycsIGZ1bmN0aW9uIChjcmVhdGVIVE1MKSB7XG4gIHJldHVybiBmdW5jdGlvbiBpdGFsaWNzKCkge1xuICAgIHJldHVybiBjcmVhdGVIVE1MKHRoaXMsICdpJywgJycsICcnKTtcbiAgfTtcbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLml0YWxpY3MuanMiLCIndXNlIHN0cmljdCc7XG52YXIgJGF0ID0gcmVxdWlyZSgnLi9fc3RyaW5nLWF0JykodHJ1ZSk7XG5cbi8vIDIxLjEuMy4yNyBTdHJpbmcucHJvdG90eXBlW0BAaXRlcmF0b3JdKClcbnJlcXVpcmUoJy4vX2l0ZXItZGVmaW5lJykoU3RyaW5nLCAnU3RyaW5nJywgZnVuY3Rpb24gKGl0ZXJhdGVkKSB7XG4gIHRoaXMuX3QgPSBTdHJpbmcoaXRlcmF0ZWQpOyAvLyB0YXJnZXRcbiAgdGhpcy5faSA9IDA7ICAgICAgICAgICAgICAgIC8vIG5leHQgaW5kZXhcbi8vIDIxLjEuNS4yLjEgJVN0cmluZ0l0ZXJhdG9yUHJvdG90eXBlJS5uZXh0KClcbn0sIGZ1bmN0aW9uICgpIHtcbiAgdmFyIE8gPSB0aGlzLl90O1xuICB2YXIgaW5kZXggPSB0aGlzLl9pO1xuICB2YXIgcG9pbnQ7XG4gIGlmIChpbmRleCA+PSBPLmxlbmd0aCkgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICBwb2ludCA9ICRhdChPLCBpbmRleCk7XG4gIHRoaXMuX2kgKz0gcG9pbnQubGVuZ3RoO1xuICByZXR1cm4geyB2YWx1ZTogcG9pbnQsIGRvbmU6IGZhbHNlIH07XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5pdGVyYXRvci5qcyIsIid1c2Ugc3RyaWN0Jztcbi8vIEIuMi4zLjEwIFN0cmluZy5wcm90b3R5cGUubGluayh1cmwpXG5yZXF1aXJlKCcuL19zdHJpbmctaHRtbCcpKCdsaW5rJywgZnVuY3Rpb24gKGNyZWF0ZUhUTUwpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGxpbmsodXJsKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUhUTUwodGhpcywgJ2EnLCAnaHJlZicsIHVybCk7XG4gIH07XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5saW5rLmpzIiwidmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdTdHJpbmcnLCB7XG4gIC8vIDIxLjEuMi40IFN0cmluZy5yYXcoY2FsbFNpdGUsIC4uLnN1YnN0aXR1dGlvbnMpXG4gIHJhdzogZnVuY3Rpb24gcmF3KGNhbGxTaXRlKSB7XG4gICAgdmFyIHRwbCA9IHRvSU9iamVjdChjYWxsU2l0ZS5yYXcpO1xuICAgIHZhciBsZW4gPSB0b0xlbmd0aCh0cGwubGVuZ3RoKTtcbiAgICB2YXIgYUxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgdmFyIHJlcyA9IFtdO1xuICAgIHZhciBpID0gMDtcbiAgICB3aGlsZSAobGVuID4gaSkge1xuICAgICAgcmVzLnB1c2goU3RyaW5nKHRwbFtpKytdKSk7XG4gICAgICBpZiAoaSA8IGFMZW4pIHJlcy5wdXNoKFN0cmluZyhhcmd1bWVudHNbaV0pKTtcbiAgICB9IHJldHVybiByZXMuam9pbignJyk7XG4gIH1cbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLnJhdy5qcyIsInZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5QLCAnU3RyaW5nJywge1xuICAvLyAyMS4xLjMuMTMgU3RyaW5nLnByb3RvdHlwZS5yZXBlYXQoY291bnQpXG4gIHJlcGVhdDogcmVxdWlyZSgnLi9fc3RyaW5nLXJlcGVhdCcpXG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5yZXBlYXQuanMiLCIndXNlIHN0cmljdCc7XG4vLyBCLjIuMy4xMSBTdHJpbmcucHJvdG90eXBlLnNtYWxsKClcbnJlcXVpcmUoJy4vX3N0cmluZy1odG1sJykoJ3NtYWxsJywgZnVuY3Rpb24gKGNyZWF0ZUhUTUwpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHNtYWxsKCkge1xuICAgIHJldHVybiBjcmVhdGVIVE1MKHRoaXMsICdzbWFsbCcsICcnLCAnJyk7XG4gIH07XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5zbWFsbC5qcyIsIi8vIDIxLjEuMy4xOCBTdHJpbmcucHJvdG90eXBlLnN0YXJ0c1dpdGgoc2VhcmNoU3RyaW5nIFssIHBvc2l0aW9uIF0pXG4ndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG52YXIgY29udGV4dCA9IHJlcXVpcmUoJy4vX3N0cmluZy1jb250ZXh0Jyk7XG52YXIgU1RBUlRTX1dJVEggPSAnc3RhcnRzV2l0aCc7XG52YXIgJHN0YXJ0c1dpdGggPSAnJ1tTVEFSVFNfV0lUSF07XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogcmVxdWlyZSgnLi9fZmFpbHMtaXMtcmVnZXhwJykoU1RBUlRTX1dJVEgpLCAnU3RyaW5nJywge1xuICBzdGFydHNXaXRoOiBmdW5jdGlvbiBzdGFydHNXaXRoKHNlYXJjaFN0cmluZyAvKiAsIHBvc2l0aW9uID0gMCAqLykge1xuICAgIHZhciB0aGF0ID0gY29udGV4dCh0aGlzLCBzZWFyY2hTdHJpbmcsIFNUQVJUU19XSVRIKTtcbiAgICB2YXIgaW5kZXggPSB0b0xlbmd0aChNYXRoLm1pbihhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCwgdGhhdC5sZW5ndGgpKTtcbiAgICB2YXIgc2VhcmNoID0gU3RyaW5nKHNlYXJjaFN0cmluZyk7XG4gICAgcmV0dXJuICRzdGFydHNXaXRoXG4gICAgICA/ICRzdGFydHNXaXRoLmNhbGwodGhhdCwgc2VhcmNoLCBpbmRleClcbiAgICAgIDogdGhhdC5zbGljZShpbmRleCwgaW5kZXggKyBzZWFyY2gubGVuZ3RoKSA9PT0gc2VhcmNoO1xuICB9XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5zdGFydHMtd2l0aC5qcyIsIid1c2Ugc3RyaWN0Jztcbi8vIEIuMi4zLjEyIFN0cmluZy5wcm90b3R5cGUuc3RyaWtlKClcbnJlcXVpcmUoJy4vX3N0cmluZy1odG1sJykoJ3N0cmlrZScsIGZ1bmN0aW9uIChjcmVhdGVIVE1MKSB7XG4gIHJldHVybiBmdW5jdGlvbiBzdHJpa2UoKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUhUTUwodGhpcywgJ3N0cmlrZScsICcnLCAnJyk7XG4gIH07XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5zdHJpa2UuanMiLCIndXNlIHN0cmljdCc7XG4vLyBCLjIuMy4xMyBTdHJpbmcucHJvdG90eXBlLnN1YigpXG5yZXF1aXJlKCcuL19zdHJpbmctaHRtbCcpKCdzdWInLCBmdW5jdGlvbiAoY3JlYXRlSFRNTCkge1xuICByZXR1cm4gZnVuY3Rpb24gc3ViKCkge1xuICAgIHJldHVybiBjcmVhdGVIVE1MKHRoaXMsICdzdWInLCAnJywgJycpO1xuICB9O1xufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuc3ViLmpzIiwiJ3VzZSBzdHJpY3QnO1xuLy8gQi4yLjMuMTQgU3RyaW5nLnByb3RvdHlwZS5zdXAoKVxucmVxdWlyZSgnLi9fc3RyaW5nLWh0bWwnKSgnc3VwJywgZnVuY3Rpb24gKGNyZWF0ZUhUTUwpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHN1cCgpIHtcbiAgICByZXR1cm4gY3JlYXRlSFRNTCh0aGlzLCAnc3VwJywgJycsICcnKTtcbiAgfTtcbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLnN1cC5qcyIsIid1c2Ugc3RyaWN0Jztcbi8vIDIxLjEuMy4yNSBTdHJpbmcucHJvdG90eXBlLnRyaW0oKVxucmVxdWlyZSgnLi9fc3RyaW5nLXRyaW0nKSgndHJpbScsIGZ1bmN0aW9uICgkdHJpbSkge1xuICByZXR1cm4gZnVuY3Rpb24gdHJpbSgpIHtcbiAgICByZXR1cm4gJHRyaW0odGhpcywgMyk7XG4gIH07XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy50cmltLmpzIiwiJ3VzZSBzdHJpY3QnO1xuLy8gRUNNQVNjcmlwdCA2IHN5bWJvbHMgc2hpbVxudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xudmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKTtcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgcmVkZWZpbmUgPSByZXF1aXJlKCcuL19yZWRlZmluZScpO1xudmFyIE1FVEEgPSByZXF1aXJlKCcuL19tZXRhJykuS0VZO1xudmFyICRmYWlscyA9IHJlcXVpcmUoJy4vX2ZhaWxzJyk7XG52YXIgc2hhcmVkID0gcmVxdWlyZSgnLi9fc2hhcmVkJyk7XG52YXIgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpO1xudmFyIHVpZCA9IHJlcXVpcmUoJy4vX3VpZCcpO1xudmFyIHdrcyA9IHJlcXVpcmUoJy4vX3drcycpO1xudmFyIHdrc0V4dCA9IHJlcXVpcmUoJy4vX3drcy1leHQnKTtcbnZhciB3a3NEZWZpbmUgPSByZXF1aXJlKCcuL193a3MtZGVmaW5lJyk7XG52YXIgZW51bUtleXMgPSByZXF1aXJlKCcuL19lbnVtLWtleXMnKTtcbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnLi9faXMtYXJyYXknKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcbnZhciB0b1ByaW1pdGl2ZSA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpO1xudmFyIGNyZWF0ZURlc2MgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJyk7XG52YXIgX2NyZWF0ZSA9IHJlcXVpcmUoJy4vX29iamVjdC1jcmVhdGUnKTtcbnZhciBnT1BORXh0ID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcG4tZXh0Jyk7XG52YXIgJEdPUEQgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpO1xudmFyICREUCA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpO1xudmFyICRrZXlzID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKTtcbnZhciBnT1BEID0gJEdPUEQuZjtcbnZhciBkUCA9ICREUC5mO1xudmFyIGdPUE4gPSBnT1BORXh0LmY7XG52YXIgJFN5bWJvbCA9IGdsb2JhbC5TeW1ib2w7XG52YXIgJEpTT04gPSBnbG9iYWwuSlNPTjtcbnZhciBfc3RyaW5naWZ5ID0gJEpTT04gJiYgJEpTT04uc3RyaW5naWZ5O1xudmFyIFBST1RPVFlQRSA9ICdwcm90b3R5cGUnO1xudmFyIEhJRERFTiA9IHdrcygnX2hpZGRlbicpO1xudmFyIFRPX1BSSU1JVElWRSA9IHdrcygndG9QcmltaXRpdmUnKTtcbnZhciBpc0VudW0gPSB7fS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcbnZhciBTeW1ib2xSZWdpc3RyeSA9IHNoYXJlZCgnc3ltYm9sLXJlZ2lzdHJ5Jyk7XG52YXIgQWxsU3ltYm9scyA9IHNoYXJlZCgnc3ltYm9scycpO1xudmFyIE9QU3ltYm9scyA9IHNoYXJlZCgnb3Atc3ltYm9scycpO1xudmFyIE9iamVjdFByb3RvID0gT2JqZWN0W1BST1RPVFlQRV07XG52YXIgVVNFX05BVElWRSA9IHR5cGVvZiAkU3ltYm9sID09ICdmdW5jdGlvbic7XG52YXIgUU9iamVjdCA9IGdsb2JhbC5RT2JqZWN0O1xuLy8gRG9uJ3QgdXNlIHNldHRlcnMgaW4gUXQgU2NyaXB0LCBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvMTczXG52YXIgc2V0dGVyID0gIVFPYmplY3QgfHwgIVFPYmplY3RbUFJPVE9UWVBFXSB8fCAhUU9iamVjdFtQUk9UT1RZUEVdLmZpbmRDaGlsZDtcblxuLy8gZmFsbGJhY2sgZm9yIG9sZCBBbmRyb2lkLCBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9Njg3XG52YXIgc2V0U3ltYm9sRGVzYyA9IERFU0NSSVBUT1JTICYmICRmYWlscyhmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBfY3JlYXRlKGRQKHt9LCAnYScsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRQKHRoaXMsICdhJywgeyB2YWx1ZTogNyB9KS5hOyB9XG4gIH0pKS5hICE9IDc7XG59KSA/IGZ1bmN0aW9uIChpdCwga2V5LCBEKSB7XG4gIHZhciBwcm90b0Rlc2MgPSBnT1BEKE9iamVjdFByb3RvLCBrZXkpO1xuICBpZiAocHJvdG9EZXNjKSBkZWxldGUgT2JqZWN0UHJvdG9ba2V5XTtcbiAgZFAoaXQsIGtleSwgRCk7XG4gIGlmIChwcm90b0Rlc2MgJiYgaXQgIT09IE9iamVjdFByb3RvKSBkUChPYmplY3RQcm90bywga2V5LCBwcm90b0Rlc2MpO1xufSA6IGRQO1xuXG52YXIgd3JhcCA9IGZ1bmN0aW9uICh0YWcpIHtcbiAgdmFyIHN5bSA9IEFsbFN5bWJvbHNbdGFnXSA9IF9jcmVhdGUoJFN5bWJvbFtQUk9UT1RZUEVdKTtcbiAgc3ltLl9rID0gdGFnO1xuICByZXR1cm4gc3ltO1xufTtcblxudmFyIGlzU3ltYm9sID0gVVNFX05BVElWRSAmJiB0eXBlb2YgJFN5bWJvbC5pdGVyYXRvciA9PSAnc3ltYm9sJyA/IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gdHlwZW9mIGl0ID09ICdzeW1ib2wnO1xufSA6IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXQgaW5zdGFuY2VvZiAkU3ltYm9sO1xufTtcblxudmFyICRkZWZpbmVQcm9wZXJ0eSA9IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KGl0LCBrZXksIEQpIHtcbiAgaWYgKGl0ID09PSBPYmplY3RQcm90bykgJGRlZmluZVByb3BlcnR5KE9QU3ltYm9scywga2V5LCBEKTtcbiAgYW5PYmplY3QoaXQpO1xuICBrZXkgPSB0b1ByaW1pdGl2ZShrZXksIHRydWUpO1xuICBhbk9iamVjdChEKTtcbiAgaWYgKGhhcyhBbGxTeW1ib2xzLCBrZXkpKSB7XG4gICAgaWYgKCFELmVudW1lcmFibGUpIHtcbiAgICAgIGlmICghaGFzKGl0LCBISURERU4pKSBkUChpdCwgSElEREVOLCBjcmVhdGVEZXNjKDEsIHt9KSk7XG4gICAgICBpdFtISURERU5dW2tleV0gPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaGFzKGl0LCBISURERU4pICYmIGl0W0hJRERFTl1ba2V5XSkgaXRbSElEREVOXVtrZXldID0gZmFsc2U7XG4gICAgICBEID0gX2NyZWF0ZShELCB7IGVudW1lcmFibGU6IGNyZWF0ZURlc2MoMCwgZmFsc2UpIH0pO1xuICAgIH0gcmV0dXJuIHNldFN5bWJvbERlc2MoaXQsIGtleSwgRCk7XG4gIH0gcmV0dXJuIGRQKGl0LCBrZXksIEQpO1xufTtcbnZhciAkZGVmaW5lUHJvcGVydGllcyA9IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXMoaXQsIFApIHtcbiAgYW5PYmplY3QoaXQpO1xuICB2YXIga2V5cyA9IGVudW1LZXlzKFAgPSB0b0lPYmplY3QoUCkpO1xuICB2YXIgaSA9IDA7XG4gIHZhciBsID0ga2V5cy5sZW5ndGg7XG4gIHZhciBrZXk7XG4gIHdoaWxlIChsID4gaSkgJGRlZmluZVByb3BlcnR5KGl0LCBrZXkgPSBrZXlzW2krK10sIFBba2V5XSk7XG4gIHJldHVybiBpdDtcbn07XG52YXIgJGNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShpdCwgUCkge1xuICByZXR1cm4gUCA9PT0gdW5kZWZpbmVkID8gX2NyZWF0ZShpdCkgOiAkZGVmaW5lUHJvcGVydGllcyhfY3JlYXRlKGl0KSwgUCk7XG59O1xudmFyICRwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IGZ1bmN0aW9uIHByb3BlcnR5SXNFbnVtZXJhYmxlKGtleSkge1xuICB2YXIgRSA9IGlzRW51bS5jYWxsKHRoaXMsIGtleSA9IHRvUHJpbWl0aXZlKGtleSwgdHJ1ZSkpO1xuICBpZiAodGhpcyA9PT0gT2JqZWN0UHJvdG8gJiYgaGFzKEFsbFN5bWJvbHMsIGtleSkgJiYgIWhhcyhPUFN5bWJvbHMsIGtleSkpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIEUgfHwgIWhhcyh0aGlzLCBrZXkpIHx8ICFoYXMoQWxsU3ltYm9scywga2V5KSB8fCBoYXModGhpcywgSElEREVOKSAmJiB0aGlzW0hJRERFTl1ba2V5XSA/IEUgOiB0cnVlO1xufTtcbnZhciAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGl0LCBrZXkpIHtcbiAgaXQgPSB0b0lPYmplY3QoaXQpO1xuICBrZXkgPSB0b1ByaW1pdGl2ZShrZXksIHRydWUpO1xuICBpZiAoaXQgPT09IE9iamVjdFByb3RvICYmIGhhcyhBbGxTeW1ib2xzLCBrZXkpICYmICFoYXMoT1BTeW1ib2xzLCBrZXkpKSByZXR1cm47XG4gIHZhciBEID0gZ09QRChpdCwga2V5KTtcbiAgaWYgKEQgJiYgaGFzKEFsbFN5bWJvbHMsIGtleSkgJiYgIShoYXMoaXQsIEhJRERFTikgJiYgaXRbSElEREVOXVtrZXldKSkgRC5lbnVtZXJhYmxlID0gdHJ1ZTtcbiAgcmV0dXJuIEQ7XG59O1xudmFyICRnZXRPd25Qcm9wZXJ0eU5hbWVzID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhpdCkge1xuICB2YXIgbmFtZXMgPSBnT1BOKHRvSU9iamVjdChpdCkpO1xuICB2YXIgcmVzdWx0ID0gW107XG4gIHZhciBpID0gMDtcbiAgdmFyIGtleTtcbiAgd2hpbGUgKG5hbWVzLmxlbmd0aCA+IGkpIHtcbiAgICBpZiAoIWhhcyhBbGxTeW1ib2xzLCBrZXkgPSBuYW1lc1tpKytdKSAmJiBrZXkgIT0gSElEREVOICYmIGtleSAhPSBNRVRBKSByZXN1bHQucHVzaChrZXkpO1xuICB9IHJldHVybiByZXN1bHQ7XG59O1xudmFyICRnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoaXQpIHtcbiAgdmFyIElTX09QID0gaXQgPT09IE9iamVjdFByb3RvO1xuICB2YXIgbmFtZXMgPSBnT1BOKElTX09QID8gT1BTeW1ib2xzIDogdG9JT2JqZWN0KGl0KSk7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgdmFyIGkgPSAwO1xuICB2YXIga2V5O1xuICB3aGlsZSAobmFtZXMubGVuZ3RoID4gaSkge1xuICAgIGlmIChoYXMoQWxsU3ltYm9scywga2V5ID0gbmFtZXNbaSsrXSkgJiYgKElTX09QID8gaGFzKE9iamVjdFByb3RvLCBrZXkpIDogdHJ1ZSkpIHJlc3VsdC5wdXNoKEFsbFN5bWJvbHNba2V5XSk7XG4gIH0gcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8vIDE5LjQuMS4xIFN5bWJvbChbZGVzY3JpcHRpb25dKVxuaWYgKCFVU0VfTkFUSVZFKSB7XG4gICRTeW1ib2wgPSBmdW5jdGlvbiBTeW1ib2woKSB7XG4gICAgaWYgKHRoaXMgaW5zdGFuY2VvZiAkU3ltYm9sKSB0aHJvdyBUeXBlRXJyb3IoJ1N5bWJvbCBpcyBub3QgYSBjb25zdHJ1Y3RvciEnKTtcbiAgICB2YXIgdGFnID0gdWlkKGFyZ3VtZW50cy5sZW5ndGggPiAwID8gYXJndW1lbnRzWzBdIDogdW5kZWZpbmVkKTtcbiAgICB2YXIgJHNldCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgaWYgKHRoaXMgPT09IE9iamVjdFByb3RvKSAkc2V0LmNhbGwoT1BTeW1ib2xzLCB2YWx1ZSk7XG4gICAgICBpZiAoaGFzKHRoaXMsIEhJRERFTikgJiYgaGFzKHRoaXNbSElEREVOXSwgdGFnKSkgdGhpc1tISURERU5dW3RhZ10gPSBmYWxzZTtcbiAgICAgIHNldFN5bWJvbERlc2ModGhpcywgdGFnLCBjcmVhdGVEZXNjKDEsIHZhbHVlKSk7XG4gICAgfTtcbiAgICBpZiAoREVTQ1JJUFRPUlMgJiYgc2V0dGVyKSBzZXRTeW1ib2xEZXNjKE9iamVjdFByb3RvLCB0YWcsIHsgY29uZmlndXJhYmxlOiB0cnVlLCBzZXQ6ICRzZXQgfSk7XG4gICAgcmV0dXJuIHdyYXAodGFnKTtcbiAgfTtcbiAgcmVkZWZpbmUoJFN5bWJvbFtQUk9UT1RZUEVdLCAndG9TdHJpbmcnLCBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5faztcbiAgfSk7XG5cbiAgJEdPUEQuZiA9ICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG4gICREUC5mID0gJGRlZmluZVByb3BlcnR5O1xuICByZXF1aXJlKCcuL19vYmplY3QtZ29wbicpLmYgPSBnT1BORXh0LmYgPSAkZ2V0T3duUHJvcGVydHlOYW1lcztcbiAgcmVxdWlyZSgnLi9fb2JqZWN0LXBpZScpLmYgPSAkcHJvcGVydHlJc0VudW1lcmFibGU7XG4gIHJlcXVpcmUoJy4vX29iamVjdC1nb3BzJykuZiA9ICRnZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG5cbiAgaWYgKERFU0NSSVBUT1JTICYmICFyZXF1aXJlKCcuL19saWJyYXJ5JykpIHtcbiAgICByZWRlZmluZShPYmplY3RQcm90bywgJ3Byb3BlcnR5SXNFbnVtZXJhYmxlJywgJHByb3BlcnR5SXNFbnVtZXJhYmxlLCB0cnVlKTtcbiAgfVxuXG4gIHdrc0V4dC5mID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICByZXR1cm4gd3JhcCh3a3MobmFtZSkpO1xuICB9O1xufVxuXG4kZXhwb3J0KCRleHBvcnQuRyArICRleHBvcnQuVyArICRleHBvcnQuRiAqICFVU0VfTkFUSVZFLCB7IFN5bWJvbDogJFN5bWJvbCB9KTtcblxuZm9yICh2YXIgZXM2U3ltYm9scyA9IChcbiAgLy8gMTkuNC4yLjIsIDE5LjQuMi4zLCAxOS40LjIuNCwgMTkuNC4yLjYsIDE5LjQuMi44LCAxOS40LjIuOSwgMTkuNC4yLjEwLCAxOS40LjIuMTEsIDE5LjQuMi4xMiwgMTkuNC4yLjEzLCAxOS40LjIuMTRcbiAgJ2hhc0luc3RhbmNlLGlzQ29uY2F0U3ByZWFkYWJsZSxpdGVyYXRvcixtYXRjaCxyZXBsYWNlLHNlYXJjaCxzcGVjaWVzLHNwbGl0LHRvUHJpbWl0aXZlLHRvU3RyaW5nVGFnLHVuc2NvcGFibGVzJ1xuKS5zcGxpdCgnLCcpLCBqID0gMDsgZXM2U3ltYm9scy5sZW5ndGggPiBqOyl3a3MoZXM2U3ltYm9sc1tqKytdKTtcblxuZm9yICh2YXIgd2VsbEtub3duU3ltYm9scyA9ICRrZXlzKHdrcy5zdG9yZSksIGsgPSAwOyB3ZWxsS25vd25TeW1ib2xzLmxlbmd0aCA+IGs7KSB3a3NEZWZpbmUod2VsbEtub3duU3ltYm9sc1trKytdKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhVVNFX05BVElWRSwgJ1N5bWJvbCcsIHtcbiAgLy8gMTkuNC4yLjEgU3ltYm9sLmZvcihrZXkpXG4gICdmb3InOiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuIGhhcyhTeW1ib2xSZWdpc3RyeSwga2V5ICs9ICcnKVxuICAgICAgPyBTeW1ib2xSZWdpc3RyeVtrZXldXG4gICAgICA6IFN5bWJvbFJlZ2lzdHJ5W2tleV0gPSAkU3ltYm9sKGtleSk7XG4gIH0sXG4gIC8vIDE5LjQuMi41IFN5bWJvbC5rZXlGb3Ioc3ltKVxuICBrZXlGb3I6IGZ1bmN0aW9uIGtleUZvcihzeW0pIHtcbiAgICBpZiAoIWlzU3ltYm9sKHN5bSkpIHRocm93IFR5cGVFcnJvcihzeW0gKyAnIGlzIG5vdCBhIHN5bWJvbCEnKTtcbiAgICBmb3IgKHZhciBrZXkgaW4gU3ltYm9sUmVnaXN0cnkpIGlmIChTeW1ib2xSZWdpc3RyeVtrZXldID09PSBzeW0pIHJldHVybiBrZXk7XG4gIH0sXG4gIHVzZVNldHRlcjogZnVuY3Rpb24gKCkgeyBzZXR0ZXIgPSB0cnVlOyB9LFxuICB1c2VTaW1wbGU6IGZ1bmN0aW9uICgpIHsgc2V0dGVyID0gZmFsc2U7IH1cbn0pO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFVU0VfTkFUSVZFLCAnT2JqZWN0Jywge1xuICAvLyAxOS4xLjIuMiBPYmplY3QuY3JlYXRlKE8gWywgUHJvcGVydGllc10pXG4gIGNyZWF0ZTogJGNyZWF0ZSxcbiAgLy8gMTkuMS4yLjQgT2JqZWN0LmRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpXG4gIGRlZmluZVByb3BlcnR5OiAkZGVmaW5lUHJvcGVydHksXG4gIC8vIDE5LjEuMi4zIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKE8sIFByb3BlcnRpZXMpXG4gIGRlZmluZVByb3BlcnRpZXM6ICRkZWZpbmVQcm9wZXJ0aWVzLFxuICAvLyAxOS4xLjIuNiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIFApXG4gIGdldE93blByb3BlcnR5RGVzY3JpcHRvcjogJGdldE93blByb3BlcnR5RGVzY3JpcHRvcixcbiAgLy8gMTkuMS4yLjcgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoTylcbiAgZ2V0T3duUHJvcGVydHlOYW1lczogJGdldE93blByb3BlcnR5TmFtZXMsXG4gIC8vIDE5LjEuMi44IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoTylcbiAgZ2V0T3duUHJvcGVydHlTeW1ib2xzOiAkZ2V0T3duUHJvcGVydHlTeW1ib2xzXG59KTtcblxuLy8gMjQuMy4yIEpTT04uc3RyaW5naWZ5KHZhbHVlIFssIHJlcGxhY2VyIFssIHNwYWNlXV0pXG4kSlNPTiAmJiAkZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICghVVNFX05BVElWRSB8fCAkZmFpbHMoZnVuY3Rpb24gKCkge1xuICB2YXIgUyA9ICRTeW1ib2woKTtcbiAgLy8gTVMgRWRnZSBjb252ZXJ0cyBzeW1ib2wgdmFsdWVzIHRvIEpTT04gYXMge31cbiAgLy8gV2ViS2l0IGNvbnZlcnRzIHN5bWJvbCB2YWx1ZXMgdG8gSlNPTiBhcyBudWxsXG4gIC8vIFY4IHRocm93cyBvbiBib3hlZCBzeW1ib2xzXG4gIHJldHVybiBfc3RyaW5naWZ5KFtTXSkgIT0gJ1tudWxsXScgfHwgX3N0cmluZ2lmeSh7IGE6IFMgfSkgIT0gJ3t9JyB8fCBfc3RyaW5naWZ5KE9iamVjdChTKSkgIT0gJ3t9Jztcbn0pKSwgJ0pTT04nLCB7XG4gIHN0cmluZ2lmeTogZnVuY3Rpb24gc3RyaW5naWZ5KGl0KSB7XG4gICAgaWYgKGl0ID09PSB1bmRlZmluZWQgfHwgaXNTeW1ib2woaXQpKSByZXR1cm47IC8vIElFOCByZXR1cm5zIHN0cmluZyBvbiB1bmRlZmluZWRcbiAgICB2YXIgYXJncyA9IFtpdF07XG4gICAgdmFyIGkgPSAxO1xuICAgIHZhciByZXBsYWNlciwgJHJlcGxhY2VyO1xuICAgIHdoaWxlIChhcmd1bWVudHMubGVuZ3RoID4gaSkgYXJncy5wdXNoKGFyZ3VtZW50c1tpKytdKTtcbiAgICByZXBsYWNlciA9IGFyZ3NbMV07XG4gICAgaWYgKHR5cGVvZiByZXBsYWNlciA9PSAnZnVuY3Rpb24nKSAkcmVwbGFjZXIgPSByZXBsYWNlcjtcbiAgICBpZiAoJHJlcGxhY2VyIHx8ICFpc0FycmF5KHJlcGxhY2VyKSkgcmVwbGFjZXIgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgaWYgKCRyZXBsYWNlcikgdmFsdWUgPSAkcmVwbGFjZXIuY2FsbCh0aGlzLCBrZXksIHZhbHVlKTtcbiAgICAgIGlmICghaXNTeW1ib2wodmFsdWUpKSByZXR1cm4gdmFsdWU7XG4gICAgfTtcbiAgICBhcmdzWzFdID0gcmVwbGFjZXI7XG4gICAgcmV0dXJuIF9zdHJpbmdpZnkuYXBwbHkoJEpTT04sIGFyZ3MpO1xuICB9XG59KTtcblxuLy8gMTkuNC4zLjQgU3ltYm9sLnByb3RvdHlwZVtAQHRvUHJpbWl0aXZlXShoaW50KVxuJFN5bWJvbFtQUk9UT1RZUEVdW1RPX1BSSU1JVElWRV0gfHwgcmVxdWlyZSgnLi9faGlkZScpKCRTeW1ib2xbUFJPVE9UWVBFXSwgVE9fUFJJTUlUSVZFLCAkU3ltYm9sW1BST1RPVFlQRV0udmFsdWVPZik7XG4vLyAxOS40LjMuNSBTeW1ib2wucHJvdG90eXBlW0BAdG9TdHJpbmdUYWddXG5zZXRUb1N0cmluZ1RhZygkU3ltYm9sLCAnU3ltYm9sJyk7XG4vLyAyMC4yLjEuOSBNYXRoW0BAdG9TdHJpbmdUYWddXG5zZXRUb1N0cmluZ1RhZyhNYXRoLCAnTWF0aCcsIHRydWUpO1xuLy8gMjQuMy4zIEpTT05bQEB0b1N0cmluZ1RhZ11cbnNldFRvU3RyaW5nVGFnKGdsb2JhbC5KU09OLCAnSlNPTicsIHRydWUpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3ltYm9sLmpzIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciAkdHlwZWQgPSByZXF1aXJlKCcuL190eXBlZCcpO1xudmFyIGJ1ZmZlciA9IHJlcXVpcmUoJy4vX3R5cGVkLWJ1ZmZlcicpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgdG9BYnNvbHV0ZUluZGV4ID0gcmVxdWlyZSgnLi9fdG8tYWJzb2x1dGUtaW5kZXgnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgQXJyYXlCdWZmZXIgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5BcnJheUJ1ZmZlcjtcbnZhciBzcGVjaWVzQ29uc3RydWN0b3IgPSByZXF1aXJlKCcuL19zcGVjaWVzLWNvbnN0cnVjdG9yJyk7XG52YXIgJEFycmF5QnVmZmVyID0gYnVmZmVyLkFycmF5QnVmZmVyO1xudmFyICREYXRhVmlldyA9IGJ1ZmZlci5EYXRhVmlldztcbnZhciAkaXNWaWV3ID0gJHR5cGVkLkFCViAmJiBBcnJheUJ1ZmZlci5pc1ZpZXc7XG52YXIgJHNsaWNlID0gJEFycmF5QnVmZmVyLnByb3RvdHlwZS5zbGljZTtcbnZhciBWSUVXID0gJHR5cGVkLlZJRVc7XG52YXIgQVJSQVlfQlVGRkVSID0gJ0FycmF5QnVmZmVyJztcblxuJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LlcgKyAkZXhwb3J0LkYgKiAoQXJyYXlCdWZmZXIgIT09ICRBcnJheUJ1ZmZlciksIHsgQXJyYXlCdWZmZXI6ICRBcnJheUJ1ZmZlciB9KTtcblxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhJHR5cGVkLkNPTlNUUiwgQVJSQVlfQlVGRkVSLCB7XG4gIC8vIDI0LjEuMy4xIEFycmF5QnVmZmVyLmlzVmlldyhhcmcpXG4gIGlzVmlldzogZnVuY3Rpb24gaXNWaWV3KGl0KSB7XG4gICAgcmV0dXJuICRpc1ZpZXcgJiYgJGlzVmlldyhpdCkgfHwgaXNPYmplY3QoaXQpICYmIFZJRVcgaW4gaXQ7XG4gIH1cbn0pO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuVSArICRleHBvcnQuRiAqIHJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gIW5ldyAkQXJyYXlCdWZmZXIoMikuc2xpY2UoMSwgdW5kZWZpbmVkKS5ieXRlTGVuZ3RoO1xufSksIEFSUkFZX0JVRkZFUiwge1xuICAvLyAyNC4xLjQuMyBBcnJheUJ1ZmZlci5wcm90b3R5cGUuc2xpY2Uoc3RhcnQsIGVuZClcbiAgc2xpY2U6IGZ1bmN0aW9uIHNsaWNlKHN0YXJ0LCBlbmQpIHtcbiAgICBpZiAoJHNsaWNlICE9PSB1bmRlZmluZWQgJiYgZW5kID09PSB1bmRlZmluZWQpIHJldHVybiAkc2xpY2UuY2FsbChhbk9iamVjdCh0aGlzKSwgc3RhcnQpOyAvLyBGRiBmaXhcbiAgICB2YXIgbGVuID0gYW5PYmplY3QodGhpcykuYnl0ZUxlbmd0aDtcbiAgICB2YXIgZmlyc3QgPSB0b0Fic29sdXRlSW5kZXgoc3RhcnQsIGxlbik7XG4gICAgdmFyIGZpbmFsID0gdG9BYnNvbHV0ZUluZGV4KGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuIDogZW5kLCBsZW4pO1xuICAgIHZhciByZXN1bHQgPSBuZXcgKHNwZWNpZXNDb25zdHJ1Y3Rvcih0aGlzLCAkQXJyYXlCdWZmZXIpKSh0b0xlbmd0aChmaW5hbCAtIGZpcnN0KSk7XG4gICAgdmFyIHZpZXdTID0gbmV3ICREYXRhVmlldyh0aGlzKTtcbiAgICB2YXIgdmlld1QgPSBuZXcgJERhdGFWaWV3KHJlc3VsdCk7XG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICB3aGlsZSAoZmlyc3QgPCBmaW5hbCkge1xuICAgICAgdmlld1Quc2V0VWludDgoaW5kZXgrKywgdmlld1MuZ2V0VWludDgoZmlyc3QrKykpO1xuICAgIH0gcmV0dXJuIHJlc3VsdDtcbiAgfVxufSk7XG5cbnJlcXVpcmUoJy4vX3NldC1zcGVjaWVzJykoQVJSQVlfQlVGRkVSKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnR5cGVkLmFycmF5LWJ1ZmZlci5qcyIsInZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG4kZXhwb3J0KCRleHBvcnQuRyArICRleHBvcnQuVyArICRleHBvcnQuRiAqICFyZXF1aXJlKCcuL190eXBlZCcpLkFCViwge1xuICBEYXRhVmlldzogcmVxdWlyZSgnLi9fdHlwZWQtYnVmZmVyJykuRGF0YVZpZXdcbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQuZGF0YS12aWV3LmpzIiwicmVxdWlyZSgnLi9fdHlwZWQtYXJyYXknKSgnRmxvYXQzMicsIDQsIGZ1bmN0aW9uIChpbml0KSB7XG4gIHJldHVybiBmdW5jdGlvbiBGbG9hdDMyQXJyYXkoZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG4gICAgcmV0dXJuIGluaXQodGhpcywgZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKTtcbiAgfTtcbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQuZmxvYXQzMi1hcnJheS5qcyIsInJlcXVpcmUoJy4vX3R5cGVkLWFycmF5JykoJ0Zsb2F0NjQnLCA4LCBmdW5jdGlvbiAoaW5pdCkge1xuICByZXR1cm4gZnVuY3Rpb24gRmxvYXQ2NEFycmF5KGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICAgIHJldHVybiBpbml0KHRoaXMsIGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCk7XG4gIH07XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnR5cGVkLmZsb2F0NjQtYXJyYXkuanMiLCJyZXF1aXJlKCcuL190eXBlZC1hcnJheScpKCdJbnQxNicsIDIsIGZ1bmN0aW9uIChpbml0KSB7XG4gIHJldHVybiBmdW5jdGlvbiBJbnQxNkFycmF5KGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICAgIHJldHVybiBpbml0KHRoaXMsIGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCk7XG4gIH07XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnR5cGVkLmludDE2LWFycmF5LmpzIiwicmVxdWlyZSgnLi9fdHlwZWQtYXJyYXknKSgnSW50MzInLCA0LCBmdW5jdGlvbiAoaW5pdCkge1xuICByZXR1cm4gZnVuY3Rpb24gSW50MzJBcnJheShkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgICByZXR1cm4gaW5pdCh0aGlzLCBkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpO1xuICB9O1xufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC5pbnQzMi1hcnJheS5qcyIsInJlcXVpcmUoJy4vX3R5cGVkLWFycmF5JykoJ0ludDgnLCAxLCBmdW5jdGlvbiAoaW5pdCkge1xuICByZXR1cm4gZnVuY3Rpb24gSW50OEFycmF5KGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICAgIHJldHVybiBpbml0KHRoaXMsIGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCk7XG4gIH07XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnR5cGVkLmludDgtYXJyYXkuanMiLCJyZXF1aXJlKCcuL190eXBlZC1hcnJheScpKCdVaW50MTYnLCAyLCBmdW5jdGlvbiAoaW5pdCkge1xuICByZXR1cm4gZnVuY3Rpb24gVWludDE2QXJyYXkoZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG4gICAgcmV0dXJuIGluaXQodGhpcywgZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKTtcbiAgfTtcbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQudWludDE2LWFycmF5LmpzIiwicmVxdWlyZSgnLi9fdHlwZWQtYXJyYXknKSgnVWludDMyJywgNCwgZnVuY3Rpb24gKGluaXQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIFVpbnQzMkFycmF5KGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICAgIHJldHVybiBpbml0KHRoaXMsIGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCk7XG4gIH07XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnR5cGVkLnVpbnQzMi1hcnJheS5qcyIsInJlcXVpcmUoJy4vX3R5cGVkLWFycmF5JykoJ1VpbnQ4JywgMSwgZnVuY3Rpb24gKGluaXQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIFVpbnQ4QXJyYXkoZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG4gICAgcmV0dXJuIGluaXQodGhpcywgZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKTtcbiAgfTtcbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQudWludDgtYXJyYXkuanMiLCJyZXF1aXJlKCcuL190eXBlZC1hcnJheScpKCdVaW50OCcsIDEsIGZ1bmN0aW9uIChpbml0KSB7XG4gIHJldHVybiBmdW5jdGlvbiBVaW50OENsYW1wZWRBcnJheShkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgICByZXR1cm4gaW5pdCh0aGlzLCBkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpO1xuICB9O1xufSwgdHJ1ZSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC51aW50OC1jbGFtcGVkLWFycmF5LmpzIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGVhY2ggPSByZXF1aXJlKCcuL19hcnJheS1tZXRob2RzJykoMCk7XG52YXIgcmVkZWZpbmUgPSByZXF1aXJlKCcuL19yZWRlZmluZScpO1xudmFyIG1ldGEgPSByZXF1aXJlKCcuL19tZXRhJyk7XG52YXIgYXNzaWduID0gcmVxdWlyZSgnLi9fb2JqZWN0LWFzc2lnbicpO1xudmFyIHdlYWsgPSByZXF1aXJlKCcuL19jb2xsZWN0aW9uLXdlYWsnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi9fZmFpbHMnKTtcbnZhciB2YWxpZGF0ZSA9IHJlcXVpcmUoJy4vX3ZhbGlkYXRlLWNvbGxlY3Rpb24nKTtcbnZhciBXRUFLX01BUCA9ICdXZWFrTWFwJztcbnZhciBnZXRXZWFrID0gbWV0YS5nZXRXZWFrO1xudmFyIGlzRXh0ZW5zaWJsZSA9IE9iamVjdC5pc0V4dGVuc2libGU7XG52YXIgdW5jYXVnaHRGcm96ZW5TdG9yZSA9IHdlYWsudWZzdG9yZTtcbnZhciB0bXAgPSB7fTtcbnZhciBJbnRlcm5hbE1hcDtcblxudmFyIHdyYXBwZXIgPSBmdW5jdGlvbiAoZ2V0KSB7XG4gIHJldHVybiBmdW5jdGlvbiBXZWFrTWFwKCkge1xuICAgIHJldHVybiBnZXQodGhpcywgYXJndW1lbnRzLmxlbmd0aCA+IDAgPyBhcmd1bWVudHNbMF0gOiB1bmRlZmluZWQpO1xuICB9O1xufTtcblxudmFyIG1ldGhvZHMgPSB7XG4gIC8vIDIzLjMuMy4zIFdlYWtNYXAucHJvdG90eXBlLmdldChrZXkpXG4gIGdldDogZnVuY3Rpb24gZ2V0KGtleSkge1xuICAgIGlmIChpc09iamVjdChrZXkpKSB7XG4gICAgICB2YXIgZGF0YSA9IGdldFdlYWsoa2V5KTtcbiAgICAgIGlmIChkYXRhID09PSB0cnVlKSByZXR1cm4gdW5jYXVnaHRGcm96ZW5TdG9yZSh2YWxpZGF0ZSh0aGlzLCBXRUFLX01BUCkpLmdldChrZXkpO1xuICAgICAgcmV0dXJuIGRhdGEgPyBkYXRhW3RoaXMuX2ldIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgfSxcbiAgLy8gMjMuMy4zLjUgV2Vha01hcC5wcm90b3R5cGUuc2V0KGtleSwgdmFsdWUpXG4gIHNldDogZnVuY3Rpb24gc2V0KGtleSwgdmFsdWUpIHtcbiAgICByZXR1cm4gd2Vhay5kZWYodmFsaWRhdGUodGhpcywgV0VBS19NQVApLCBrZXksIHZhbHVlKTtcbiAgfVxufTtcblxuLy8gMjMuMyBXZWFrTWFwIE9iamVjdHNcbnZhciAkV2Vha01hcCA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fY29sbGVjdGlvbicpKFdFQUtfTUFQLCB3cmFwcGVyLCBtZXRob2RzLCB3ZWFrLCB0cnVlLCB0cnVlKTtcblxuLy8gSUUxMSBXZWFrTWFwIGZyb3plbiBrZXlzIGZpeFxuaWYgKGZhaWxzKGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyAkV2Vha01hcCgpLnNldCgoT2JqZWN0LmZyZWV6ZSB8fCBPYmplY3QpKHRtcCksIDcpLmdldCh0bXApICE9IDc7IH0pKSB7XG4gIEludGVybmFsTWFwID0gd2Vhay5nZXRDb25zdHJ1Y3Rvcih3cmFwcGVyLCBXRUFLX01BUCk7XG4gIGFzc2lnbihJbnRlcm5hbE1hcC5wcm90b3R5cGUsIG1ldGhvZHMpO1xuICBtZXRhLk5FRUQgPSB0cnVlO1xuICBlYWNoKFsnZGVsZXRlJywgJ2hhcycsICdnZXQnLCAnc2V0J10sIGZ1bmN0aW9uIChrZXkpIHtcbiAgICB2YXIgcHJvdG8gPSAkV2Vha01hcC5wcm90b3R5cGU7XG4gICAgdmFyIG1ldGhvZCA9IHByb3RvW2tleV07XG4gICAgcmVkZWZpbmUocHJvdG8sIGtleSwgZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIC8vIHN0b3JlIGZyb3plbiBvYmplY3RzIG9uIGludGVybmFsIHdlYWttYXAgc2hpbVxuICAgICAgaWYgKGlzT2JqZWN0KGEpICYmICFpc0V4dGVuc2libGUoYSkpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9mKSB0aGlzLl9mID0gbmV3IEludGVybmFsTWFwKCk7XG4gICAgICAgIHZhciByZXN1bHQgPSB0aGlzLl9mW2tleV0oYSwgYik7XG4gICAgICAgIHJldHVybiBrZXkgPT0gJ3NldCcgPyB0aGlzIDogcmVzdWx0O1xuICAgICAgLy8gc3RvcmUgYWxsIHRoZSByZXN0IG9uIG5hdGl2ZSB3ZWFrbWFwXG4gICAgICB9IHJldHVybiBtZXRob2QuY2FsbCh0aGlzLCBhLCBiKTtcbiAgICB9KTtcbiAgfSk7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi53ZWFrLW1hcC5qcyIsIid1c2Ugc3RyaWN0JztcbnZhciB3ZWFrID0gcmVxdWlyZSgnLi9fY29sbGVjdGlvbi13ZWFrJyk7XG52YXIgdmFsaWRhdGUgPSByZXF1aXJlKCcuL192YWxpZGF0ZS1jb2xsZWN0aW9uJyk7XG52YXIgV0VBS19TRVQgPSAnV2Vha1NldCc7XG5cbi8vIDIzLjQgV2Vha1NldCBPYmplY3RzXG5yZXF1aXJlKCcuL19jb2xsZWN0aW9uJykoV0VBS19TRVQsIGZ1bmN0aW9uIChnZXQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIFdlYWtTZXQoKSB7IHJldHVybiBnZXQodGhpcywgYXJndW1lbnRzLmxlbmd0aCA+IDAgPyBhcmd1bWVudHNbMF0gOiB1bmRlZmluZWQpOyB9O1xufSwge1xuICAvLyAyMy40LjMuMSBXZWFrU2V0LnByb3RvdHlwZS5hZGQodmFsdWUpXG4gIGFkZDogZnVuY3Rpb24gYWRkKHZhbHVlKSB7XG4gICAgcmV0dXJuIHdlYWsuZGVmKHZhbGlkYXRlKHRoaXMsIFdFQUtfU0VUKSwgdmFsdWUsIHRydWUpO1xuICB9XG59LCB3ZWFrLCBmYWxzZSwgdHJ1ZSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi53ZWFrLXNldC5qcyIsIid1c2Ugc3RyaWN0Jztcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vcHJvcG9zYWwtZmxhdE1hcC8jc2VjLUFycmF5LnByb3RvdHlwZS5mbGF0TWFwXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGZsYXR0ZW5JbnRvQXJyYXkgPSByZXF1aXJlKCcuL19mbGF0dGVuLWludG8tYXJyYXknKTtcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG52YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpO1xudmFyIGFycmF5U3BlY2llc0NyZWF0ZSA9IHJlcXVpcmUoJy4vX2FycmF5LXNwZWNpZXMtY3JlYXRlJyk7XG5cbiRleHBvcnQoJGV4cG9ydC5QLCAnQXJyYXknLCB7XG4gIGZsYXRNYXA6IGZ1bmN0aW9uIGZsYXRNYXAoY2FsbGJhY2tmbiAvKiAsIHRoaXNBcmcgKi8pIHtcbiAgICB2YXIgTyA9IHRvT2JqZWN0KHRoaXMpO1xuICAgIHZhciBzb3VyY2VMZW4sIEE7XG4gICAgYUZ1bmN0aW9uKGNhbGxiYWNrZm4pO1xuICAgIHNvdXJjZUxlbiA9IHRvTGVuZ3RoKE8ubGVuZ3RoKTtcbiAgICBBID0gYXJyYXlTcGVjaWVzQ3JlYXRlKE8sIDApO1xuICAgIGZsYXR0ZW5JbnRvQXJyYXkoQSwgTywgTywgc291cmNlTGVuLCAwLCAxLCBjYWxsYmFja2ZuLCBhcmd1bWVudHNbMV0pO1xuICAgIHJldHVybiBBO1xuICB9XG59KTtcblxucmVxdWlyZSgnLi9fYWRkLXRvLXVuc2NvcGFibGVzJykoJ2ZsYXRNYXAnKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LmFycmF5LmZsYXQtbWFwLmpzIiwiJ3VzZSBzdHJpY3QnO1xuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9wcm9wb3NhbC1mbGF0TWFwLyNzZWMtQXJyYXkucHJvdG90eXBlLmZsYXR0ZW5cbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgZmxhdHRlbkludG9BcnJheSA9IHJlcXVpcmUoJy4vX2ZsYXR0ZW4taW50by1hcnJheScpO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcbnZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJyk7XG52YXIgYXJyYXlTcGVjaWVzQ3JlYXRlID0gcmVxdWlyZSgnLi9fYXJyYXktc3BlY2llcy1jcmVhdGUnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAsICdBcnJheScsIHtcbiAgZmxhdHRlbjogZnVuY3Rpb24gZmxhdHRlbigvKiBkZXB0aEFyZyA9IDEgKi8pIHtcbiAgICB2YXIgZGVwdGhBcmcgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIE8gPSB0b09iamVjdCh0aGlzKTtcbiAgICB2YXIgc291cmNlTGVuID0gdG9MZW5ndGgoTy5sZW5ndGgpO1xuICAgIHZhciBBID0gYXJyYXlTcGVjaWVzQ3JlYXRlKE8sIDApO1xuICAgIGZsYXR0ZW5JbnRvQXJyYXkoQSwgTywgTywgc291cmNlTGVuLCAwLCBkZXB0aEFyZyA9PT0gdW5kZWZpbmVkID8gMSA6IHRvSW50ZWdlcihkZXB0aEFyZykpO1xuICAgIHJldHVybiBBO1xuICB9XG59KTtcblxucmVxdWlyZSgnLi9fYWRkLXRvLXVuc2NvcGFibGVzJykoJ2ZsYXR0ZW4nKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LmFycmF5LmZsYXR0ZW4uanMiLCIndXNlIHN0cmljdCc7XG4vLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9BcnJheS5wcm90b3R5cGUuaW5jbHVkZXNcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgJGluY2x1ZGVzID0gcmVxdWlyZSgnLi9fYXJyYXktaW5jbHVkZXMnKSh0cnVlKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAsICdBcnJheScsIHtcbiAgaW5jbHVkZXM6IGZ1bmN0aW9uIGluY2x1ZGVzKGVsIC8qICwgZnJvbUluZGV4ID0gMCAqLykge1xuICAgIHJldHVybiAkaW5jbHVkZXModGhpcywgZWwsIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgfVxufSk7XG5cbnJlcXVpcmUoJy4vX2FkZC10by11bnNjb3BhYmxlcycpKCdpbmNsdWRlcycpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcuYXJyYXkuaW5jbHVkZXMuanMiLCIvLyBodHRwczovL2dpdGh1Yi5jb20vcndhbGRyb24vdGMzOS1ub3Rlcy9ibG9iL21hc3Rlci9lczYvMjAxNC0wOS9zZXB0LTI1Lm1kIzUxMC1nbG9iYWxhc2FwLWZvci1lbnF1ZXVpbmctYS1taWNyb3Rhc2tcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgbWljcm90YXNrID0gcmVxdWlyZSgnLi9fbWljcm90YXNrJykoKTtcbnZhciBwcm9jZXNzID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykucHJvY2VzcztcbnZhciBpc05vZGUgPSByZXF1aXJlKCcuL19jb2YnKShwcm9jZXNzKSA9PSAncHJvY2Vzcyc7XG5cbiRleHBvcnQoJGV4cG9ydC5HLCB7XG4gIGFzYXA6IGZ1bmN0aW9uIGFzYXAoZm4pIHtcbiAgICB2YXIgZG9tYWluID0gaXNOb2RlICYmIHByb2Nlc3MuZG9tYWluO1xuICAgIG1pY3JvdGFzayhkb21haW4gPyBkb21haW4uYmluZChmbikgOiBmbik7XG4gIH1cbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcuYXNhcC5qcyIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9samhhcmIvcHJvcG9zYWwtaXMtZXJyb3JcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgY29mID0gcmVxdWlyZSgnLi9fY29mJyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnRXJyb3InLCB7XG4gIGlzRXJyb3I6IGZ1bmN0aW9uIGlzRXJyb3IoaXQpIHtcbiAgICByZXR1cm4gY29mKGl0KSA9PT0gJ0Vycm9yJztcbiAgfVxufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5lcnJvci5pcy1lcnJvci5qcyIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLWdsb2JhbFxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LkcsIHsgZ2xvYmFsOiByZXF1aXJlKCcuL19nbG9iYWwnKSB9KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3Lmdsb2JhbC5qcyIsIi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vcHJvcG9zYWwtc2V0bWFwLW9mZnJvbS8jc2VjLW1hcC5mcm9tXG5yZXF1aXJlKCcuL19zZXQtY29sbGVjdGlvbi1mcm9tJykoJ01hcCcpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcubWFwLmZyb20uanMiLCIvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL3Byb3Bvc2FsLXNldG1hcC1vZmZyb20vI3NlYy1tYXAub2ZcbnJlcXVpcmUoJy4vX3NldC1jb2xsZWN0aW9uLW9mJykoJ01hcCcpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcubWFwLm9mLmpzIiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL0RhdmlkQnJ1YW50L01hcC1TZXQucHJvdG90eXBlLnRvSlNPTlxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LlIsICdNYXAnLCB7IHRvSlNPTjogcmVxdWlyZSgnLi9fY29sbGVjdGlvbi10by1qc29uJykoJ01hcCcpIH0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcubWFwLnRvLWpzb24uanMiLCIvLyBodHRwczovL3J3YWxkcm9uLmdpdGh1Yi5pby9wcm9wb3NhbC1tYXRoLWV4dGVuc2lvbnMvXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7XG4gIGNsYW1wOiBmdW5jdGlvbiBjbGFtcCh4LCBsb3dlciwgdXBwZXIpIHtcbiAgICByZXR1cm4gTWF0aC5taW4odXBwZXIsIE1hdGgubWF4KGxvd2VyLCB4KSk7XG4gIH1cbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcubWF0aC5jbGFtcC5qcyIsIi8vIGh0dHBzOi8vcndhbGRyb24uZ2l0aHViLmlvL3Byb3Bvc2FsLW1hdGgtZXh0ZW5zaW9ucy9cbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHsgREVHX1BFUl9SQUQ6IE1hdGguUEkgLyAxODAgfSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5tYXRoLmRlZy1wZXItcmFkLmpzIiwiLy8gaHR0cHM6Ly9yd2FsZHJvbi5naXRodWIuaW8vcHJvcG9zYWwtbWF0aC1leHRlbnNpb25zL1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBSQURfUEVSX0RFRyA9IDE4MCAvIE1hdGguUEk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHtcbiAgZGVncmVlczogZnVuY3Rpb24gZGVncmVlcyhyYWRpYW5zKSB7XG4gICAgcmV0dXJuIHJhZGlhbnMgKiBSQURfUEVSX0RFRztcbiAgfVxufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5tYXRoLmRlZ3JlZXMuanMiLCIvLyBodHRwczovL3J3YWxkcm9uLmdpdGh1Yi5pby9wcm9wb3NhbC1tYXRoLWV4dGVuc2lvbnMvXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIHNjYWxlID0gcmVxdWlyZSgnLi9fbWF0aC1zY2FsZScpO1xudmFyIGZyb3VuZCA9IHJlcXVpcmUoJy4vX21hdGgtZnJvdW5kJyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHtcbiAgZnNjYWxlOiBmdW5jdGlvbiBmc2NhbGUoeCwgaW5Mb3csIGluSGlnaCwgb3V0TG93LCBvdXRIaWdoKSB7XG4gICAgcmV0dXJuIGZyb3VuZChzY2FsZSh4LCBpbkxvdywgaW5IaWdoLCBvdXRMb3csIG91dEhpZ2gpKTtcbiAgfVxufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5tYXRoLmZzY2FsZS5qcyIsIi8vIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL0JyZW5kYW5FaWNoLzQyOTRkNWMyMTJhNmQyMjU0NzAzXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7XG4gIGlhZGRoOiBmdW5jdGlvbiBpYWRkaCh4MCwgeDEsIHkwLCB5MSkge1xuICAgIHZhciAkeDAgPSB4MCA+Pj4gMDtcbiAgICB2YXIgJHgxID0geDEgPj4+IDA7XG4gICAgdmFyICR5MCA9IHkwID4+PiAwO1xuICAgIHJldHVybiAkeDEgKyAoeTEgPj4+IDApICsgKCgkeDAgJiAkeTAgfCAoJHgwIHwgJHkwKSAmIH4oJHgwICsgJHkwID4+PiAwKSkgPj4+IDMxKSB8IDA7XG4gIH1cbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcubWF0aC5pYWRkaC5qcyIsIi8vIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL0JyZW5kYW5FaWNoLzQyOTRkNWMyMTJhNmQyMjU0NzAzXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7XG4gIGltdWxoOiBmdW5jdGlvbiBpbXVsaCh1LCB2KSB7XG4gICAgdmFyIFVJTlQxNiA9IDB4ZmZmZjtcbiAgICB2YXIgJHUgPSArdTtcbiAgICB2YXIgJHYgPSArdjtcbiAgICB2YXIgdTAgPSAkdSAmIFVJTlQxNjtcbiAgICB2YXIgdjAgPSAkdiAmIFVJTlQxNjtcbiAgICB2YXIgdTEgPSAkdSA+PiAxNjtcbiAgICB2YXIgdjEgPSAkdiA+PiAxNjtcbiAgICB2YXIgdCA9ICh1MSAqIHYwID4+PiAwKSArICh1MCAqIHYwID4+PiAxNik7XG4gICAgcmV0dXJuIHUxICogdjEgKyAodCA+PiAxNikgKyAoKHUwICogdjEgPj4+IDApICsgKHQgJiBVSU5UMTYpID4+IDE2KTtcbiAgfVxufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5tYXRoLmltdWxoLmpzIiwiLy8gaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vQnJlbmRhbkVpY2gvNDI5NGQ1YzIxMmE2ZDIyNTQ3MDNcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHtcbiAgaXN1Ymg6IGZ1bmN0aW9uIGlzdWJoKHgwLCB4MSwgeTAsIHkxKSB7XG4gICAgdmFyICR4MCA9IHgwID4+PiAwO1xuICAgIHZhciAkeDEgPSB4MSA+Pj4gMDtcbiAgICB2YXIgJHkwID0geTAgPj4+IDA7XG4gICAgcmV0dXJuICR4MSAtICh5MSA+Pj4gMCkgLSAoKH4keDAgJiAkeTAgfCB+KCR4MCBeICR5MCkgJiAkeDAgLSAkeTAgPj4+IDApID4+PiAzMSkgfCAwO1xuICB9XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3Lm1hdGguaXN1YmguanMiLCIvLyBodHRwczovL3J3YWxkcm9uLmdpdGh1Yi5pby9wcm9wb3NhbC1tYXRoLWV4dGVuc2lvbnMvXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7IFJBRF9QRVJfREVHOiAxODAgLyBNYXRoLlBJIH0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcubWF0aC5yYWQtcGVyLWRlZy5qcyIsIi8vIGh0dHBzOi8vcndhbGRyb24uZ2l0aHViLmlvL3Byb3Bvc2FsLW1hdGgtZXh0ZW5zaW9ucy9cbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgREVHX1BFUl9SQUQgPSBNYXRoLlBJIC8gMTgwO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7XG4gIHJhZGlhbnM6IGZ1bmN0aW9uIHJhZGlhbnMoZGVncmVlcykge1xuICAgIHJldHVybiBkZWdyZWVzICogREVHX1BFUl9SQUQ7XG4gIH1cbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcubWF0aC5yYWRpYW5zLmpzIiwiLy8gaHR0cHM6Ly9yd2FsZHJvbi5naXRodWIuaW8vcHJvcG9zYWwtbWF0aC1leHRlbnNpb25zL1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywgeyBzY2FsZTogcmVxdWlyZSgnLi9fbWF0aC1zY2FsZScpIH0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcubWF0aC5zY2FsZS5qcyIsIi8vIGh0dHA6Ly9qZmJhc3RpZW4uZ2l0aHViLmlvL3BhcGVycy9NYXRoLnNpZ25iaXQuaHRtbFxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywgeyBzaWduYml0OiBmdW5jdGlvbiBzaWduYml0KHgpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuICByZXR1cm4gKHggPSAreCkgIT0geCA/IHggOiB4ID09IDAgPyAxIC8geCA9PSBJbmZpbml0eSA6IHggPiAwO1xufSB9KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3Lm1hdGguc2lnbmJpdC5qcyIsIi8vIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL0JyZW5kYW5FaWNoLzQyOTRkNWMyMTJhNmQyMjU0NzAzXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7XG4gIHVtdWxoOiBmdW5jdGlvbiB1bXVsaCh1LCB2KSB7XG4gICAgdmFyIFVJTlQxNiA9IDB4ZmZmZjtcbiAgICB2YXIgJHUgPSArdTtcbiAgICB2YXIgJHYgPSArdjtcbiAgICB2YXIgdTAgPSAkdSAmIFVJTlQxNjtcbiAgICB2YXIgdjAgPSAkdiAmIFVJTlQxNjtcbiAgICB2YXIgdTEgPSAkdSA+Pj4gMTY7XG4gICAgdmFyIHYxID0gJHYgPj4+IDE2O1xuICAgIHZhciB0ID0gKHUxICogdjAgPj4+IDApICsgKHUwICogdjAgPj4+IDE2KTtcbiAgICByZXR1cm4gdTEgKiB2MSArICh0ID4+PiAxNikgKyAoKHUwICogdjEgPj4+IDApICsgKHQgJiBVSU5UMTYpID4+PiAxNik7XG4gIH1cbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcubWF0aC51bXVsaC5qcyIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG52YXIgJGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJyk7XG5cbi8vIEIuMi4yLjIgT2JqZWN0LnByb3RvdHlwZS5fX2RlZmluZUdldHRlcl9fKFAsIGdldHRlcilcbnJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgJiYgJGV4cG9ydCgkZXhwb3J0LlAgKyByZXF1aXJlKCcuL19vYmplY3QtZm9yY2VkLXBhbScpLCAnT2JqZWN0Jywge1xuICBfX2RlZmluZUdldHRlcl9fOiBmdW5jdGlvbiBfX2RlZmluZUdldHRlcl9fKFAsIGdldHRlcikge1xuICAgICRkZWZpbmVQcm9wZXJ0eS5mKHRvT2JqZWN0KHRoaXMpLCBQLCB7IGdldDogYUZ1bmN0aW9uKGdldHRlciksIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9KTtcbiAgfVxufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5vYmplY3QuZGVmaW5lLWdldHRlci5qcyIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG52YXIgJGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJyk7XG5cbi8vIEIuMi4yLjMgT2JqZWN0LnByb3RvdHlwZS5fX2RlZmluZVNldHRlcl9fKFAsIHNldHRlcilcbnJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgJiYgJGV4cG9ydCgkZXhwb3J0LlAgKyByZXF1aXJlKCcuL19vYmplY3QtZm9yY2VkLXBhbScpLCAnT2JqZWN0Jywge1xuICBfX2RlZmluZVNldHRlcl9fOiBmdW5jdGlvbiBfX2RlZmluZVNldHRlcl9fKFAsIHNldHRlcikge1xuICAgICRkZWZpbmVQcm9wZXJ0eS5mKHRvT2JqZWN0KHRoaXMpLCBQLCB7IHNldDogYUZ1bmN0aW9uKHNldHRlciksIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9KTtcbiAgfVxufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5vYmplY3QuZGVmaW5lLXNldHRlci5qcyIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLW9iamVjdC12YWx1ZXMtZW50cmllc1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciAkZW50cmllcyA9IHJlcXVpcmUoJy4vX29iamVjdC10by1hcnJheScpKHRydWUpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ09iamVjdCcsIHtcbiAgZW50cmllczogZnVuY3Rpb24gZW50cmllcyhpdCkge1xuICAgIHJldHVybiAkZW50cmllcyhpdCk7XG4gIH1cbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcub2JqZWN0LmVudHJpZXMuanMiLCIvLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1vYmplY3QtZ2V0b3ducHJvcGVydHlkZXNjcmlwdG9yc1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBvd25LZXlzID0gcmVxdWlyZSgnLi9fb3duLWtleXMnKTtcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG52YXIgZ09QRCA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BkJyk7XG52YXIgY3JlYXRlUHJvcGVydHkgPSByZXF1aXJlKCcuL19jcmVhdGUtcHJvcGVydHknKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdPYmplY3QnLCB7XG4gIGdldE93blByb3BlcnR5RGVzY3JpcHRvcnM6IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcnMob2JqZWN0KSB7XG4gICAgdmFyIE8gPSB0b0lPYmplY3Qob2JqZWN0KTtcbiAgICB2YXIgZ2V0RGVzYyA9IGdPUEQuZjtcbiAgICB2YXIga2V5cyA9IG93bktleXMoTyk7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIga2V5LCBkZXNjO1xuICAgIHdoaWxlIChrZXlzLmxlbmd0aCA+IGkpIHtcbiAgICAgIGRlc2MgPSBnZXREZXNjKE8sIGtleSA9IGtleXNbaSsrXSk7XG4gICAgICBpZiAoZGVzYyAhPT0gdW5kZWZpbmVkKSBjcmVhdGVQcm9wZXJ0eShyZXN1bHQsIGtleSwgZGVzYyk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcub2JqZWN0LmdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvcnMuanMiLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG52YXIgdG9QcmltaXRpdmUgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKTtcbnZhciBnZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4vX29iamVjdC1ncG8nKTtcbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpLmY7XG5cbi8vIEIuMi4yLjQgT2JqZWN0LnByb3RvdHlwZS5fX2xvb2t1cEdldHRlcl9fKFApXG5yZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpICYmICRleHBvcnQoJGV4cG9ydC5QICsgcmVxdWlyZSgnLi9fb2JqZWN0LWZvcmNlZC1wYW0nKSwgJ09iamVjdCcsIHtcbiAgX19sb29rdXBHZXR0ZXJfXzogZnVuY3Rpb24gX19sb29rdXBHZXR0ZXJfXyhQKSB7XG4gICAgdmFyIE8gPSB0b09iamVjdCh0aGlzKTtcbiAgICB2YXIgSyA9IHRvUHJpbWl0aXZlKFAsIHRydWUpO1xuICAgIHZhciBEO1xuICAgIGRvIHtcbiAgICAgIGlmIChEID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIEspKSByZXR1cm4gRC5nZXQ7XG4gICAgfSB3aGlsZSAoTyA9IGdldFByb3RvdHlwZU9mKE8pKTtcbiAgfVxufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5vYmplY3QubG9va3VwLWdldHRlci5qcyIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcbnZhciB0b1ByaW1pdGl2ZSA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpO1xudmFyIGdldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpO1xudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BkJykuZjtcblxuLy8gQi4yLjIuNSBPYmplY3QucHJvdG90eXBlLl9fbG9va3VwU2V0dGVyX18oUClcbnJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgJiYgJGV4cG9ydCgkZXhwb3J0LlAgKyByZXF1aXJlKCcuL19vYmplY3QtZm9yY2VkLXBhbScpLCAnT2JqZWN0Jywge1xuICBfX2xvb2t1cFNldHRlcl9fOiBmdW5jdGlvbiBfX2xvb2t1cFNldHRlcl9fKFApIHtcbiAgICB2YXIgTyA9IHRvT2JqZWN0KHRoaXMpO1xuICAgIHZhciBLID0gdG9QcmltaXRpdmUoUCwgdHJ1ZSk7XG4gICAgdmFyIEQ7XG4gICAgZG8ge1xuICAgICAgaWYgKEQgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgSykpIHJldHVybiBELnNldDtcbiAgICB9IHdoaWxlIChPID0gZ2V0UHJvdG90eXBlT2YoTykpO1xuICB9XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3Lm9iamVjdC5sb29rdXAtc2V0dGVyLmpzIiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtb2JqZWN0LXZhbHVlcy1lbnRyaWVzXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyICR2YWx1ZXMgPSByZXF1aXJlKCcuL19vYmplY3QtdG8tYXJyYXknKShmYWxzZSk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnT2JqZWN0Jywge1xuICB2YWx1ZXM6IGZ1bmN0aW9uIHZhbHVlcyhpdCkge1xuICAgIHJldHVybiAkdmFsdWVzKGl0KTtcbiAgfVxufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5vYmplY3QudmFsdWVzLmpzIiwiJ3VzZSBzdHJpY3QnO1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL3plbnBhcnNpbmcvZXMtb2JzZXJ2YWJsZVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBjb3JlID0gcmVxdWlyZSgnLi9fY29yZScpO1xudmFyIG1pY3JvdGFzayA9IHJlcXVpcmUoJy4vX21pY3JvdGFzaycpKCk7XG52YXIgT0JTRVJWQUJMRSA9IHJlcXVpcmUoJy4vX3drcycpKCdvYnNlcnZhYmxlJyk7XG52YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgYW5JbnN0YW5jZSA9IHJlcXVpcmUoJy4vX2FuLWluc3RhbmNlJyk7XG52YXIgcmVkZWZpbmVBbGwgPSByZXF1aXJlKCcuL19yZWRlZmluZS1hbGwnKTtcbnZhciBoaWRlID0gcmVxdWlyZSgnLi9faGlkZScpO1xudmFyIGZvck9mID0gcmVxdWlyZSgnLi9fZm9yLW9mJyk7XG52YXIgUkVUVVJOID0gZm9yT2YuUkVUVVJOO1xuXG52YXIgZ2V0TWV0aG9kID0gZnVuY3Rpb24gKGZuKSB7XG4gIHJldHVybiBmbiA9PSBudWxsID8gdW5kZWZpbmVkIDogYUZ1bmN0aW9uKGZuKTtcbn07XG5cbnZhciBjbGVhbnVwU3Vic2NyaXB0aW9uID0gZnVuY3Rpb24gKHN1YnNjcmlwdGlvbikge1xuICB2YXIgY2xlYW51cCA9IHN1YnNjcmlwdGlvbi5fYztcbiAgaWYgKGNsZWFudXApIHtcbiAgICBzdWJzY3JpcHRpb24uX2MgPSB1bmRlZmluZWQ7XG4gICAgY2xlYW51cCgpO1xuICB9XG59O1xuXG52YXIgc3Vic2NyaXB0aW9uQ2xvc2VkID0gZnVuY3Rpb24gKHN1YnNjcmlwdGlvbikge1xuICByZXR1cm4gc3Vic2NyaXB0aW9uLl9vID09PSB1bmRlZmluZWQ7XG59O1xuXG52YXIgY2xvc2VTdWJzY3JpcHRpb24gPSBmdW5jdGlvbiAoc3Vic2NyaXB0aW9uKSB7XG4gIGlmICghc3Vic2NyaXB0aW9uQ2xvc2VkKHN1YnNjcmlwdGlvbikpIHtcbiAgICBzdWJzY3JpcHRpb24uX28gPSB1bmRlZmluZWQ7XG4gICAgY2xlYW51cFN1YnNjcmlwdGlvbihzdWJzY3JpcHRpb24pO1xuICB9XG59O1xuXG52YXIgU3Vic2NyaXB0aW9uID0gZnVuY3Rpb24gKG9ic2VydmVyLCBzdWJzY3JpYmVyKSB7XG4gIGFuT2JqZWN0KG9ic2VydmVyKTtcbiAgdGhpcy5fYyA9IHVuZGVmaW5lZDtcbiAgdGhpcy5fbyA9IG9ic2VydmVyO1xuICBvYnNlcnZlciA9IG5ldyBTdWJzY3JpcHRpb25PYnNlcnZlcih0aGlzKTtcbiAgdHJ5IHtcbiAgICB2YXIgY2xlYW51cCA9IHN1YnNjcmliZXIob2JzZXJ2ZXIpO1xuICAgIHZhciBzdWJzY3JpcHRpb24gPSBjbGVhbnVwO1xuICAgIGlmIChjbGVhbnVwICE9IG51bGwpIHtcbiAgICAgIGlmICh0eXBlb2YgY2xlYW51cC51bnN1YnNjcmliZSA9PT0gJ2Z1bmN0aW9uJykgY2xlYW51cCA9IGZ1bmN0aW9uICgpIHsgc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7IH07XG4gICAgICBlbHNlIGFGdW5jdGlvbihjbGVhbnVwKTtcbiAgICAgIHRoaXMuX2MgPSBjbGVhbnVwO1xuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIG9ic2VydmVyLmVycm9yKGUpO1xuICAgIHJldHVybjtcbiAgfSBpZiAoc3Vic2NyaXB0aW9uQ2xvc2VkKHRoaXMpKSBjbGVhbnVwU3Vic2NyaXB0aW9uKHRoaXMpO1xufTtcblxuU3Vic2NyaXB0aW9uLnByb3RvdHlwZSA9IHJlZGVmaW5lQWxsKHt9LCB7XG4gIHVuc3Vic2NyaWJlOiBmdW5jdGlvbiB1bnN1YnNjcmliZSgpIHsgY2xvc2VTdWJzY3JpcHRpb24odGhpcyk7IH1cbn0pO1xuXG52YXIgU3Vic2NyaXB0aW9uT2JzZXJ2ZXIgPSBmdW5jdGlvbiAoc3Vic2NyaXB0aW9uKSB7XG4gIHRoaXMuX3MgPSBzdWJzY3JpcHRpb247XG59O1xuXG5TdWJzY3JpcHRpb25PYnNlcnZlci5wcm90b3R5cGUgPSByZWRlZmluZUFsbCh7fSwge1xuICBuZXh0OiBmdW5jdGlvbiBuZXh0KHZhbHVlKSB7XG4gICAgdmFyIHN1YnNjcmlwdGlvbiA9IHRoaXMuX3M7XG4gICAgaWYgKCFzdWJzY3JpcHRpb25DbG9zZWQoc3Vic2NyaXB0aW9uKSkge1xuICAgICAgdmFyIG9ic2VydmVyID0gc3Vic2NyaXB0aW9uLl9vO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIG0gPSBnZXRNZXRob2Qob2JzZXJ2ZXIubmV4dCk7XG4gICAgICAgIGlmIChtKSByZXR1cm4gbS5jYWxsKG9ic2VydmVyLCB2YWx1ZSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY2xvc2VTdWJzY3JpcHRpb24oc3Vic2NyaXB0aW9uKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBlcnJvcjogZnVuY3Rpb24gZXJyb3IodmFsdWUpIHtcbiAgICB2YXIgc3Vic2NyaXB0aW9uID0gdGhpcy5fcztcbiAgICBpZiAoc3Vic2NyaXB0aW9uQ2xvc2VkKHN1YnNjcmlwdGlvbikpIHRocm93IHZhbHVlO1xuICAgIHZhciBvYnNlcnZlciA9IHN1YnNjcmlwdGlvbi5fbztcbiAgICBzdWJzY3JpcHRpb24uX28gPSB1bmRlZmluZWQ7XG4gICAgdHJ5IHtcbiAgICAgIHZhciBtID0gZ2V0TWV0aG9kKG9ic2VydmVyLmVycm9yKTtcbiAgICAgIGlmICghbSkgdGhyb3cgdmFsdWU7XG4gICAgICB2YWx1ZSA9IG0uY2FsbChvYnNlcnZlciwgdmFsdWUpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNsZWFudXBTdWJzY3JpcHRpb24oc3Vic2NyaXB0aW9uKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgfSBjbGVhbnVwU3Vic2NyaXB0aW9uKHN1YnNjcmlwdGlvbik7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9LFxuICBjb21wbGV0ZTogZnVuY3Rpb24gY29tcGxldGUodmFsdWUpIHtcbiAgICB2YXIgc3Vic2NyaXB0aW9uID0gdGhpcy5fcztcbiAgICBpZiAoIXN1YnNjcmlwdGlvbkNsb3NlZChzdWJzY3JpcHRpb24pKSB7XG4gICAgICB2YXIgb2JzZXJ2ZXIgPSBzdWJzY3JpcHRpb24uX287XG4gICAgICBzdWJzY3JpcHRpb24uX28gPSB1bmRlZmluZWQ7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgbSA9IGdldE1ldGhvZChvYnNlcnZlci5jb21wbGV0ZSk7XG4gICAgICAgIHZhbHVlID0gbSA/IG0uY2FsbChvYnNlcnZlciwgdmFsdWUpIDogdW5kZWZpbmVkO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNsZWFudXBTdWJzY3JpcHRpb24oc3Vic2NyaXB0aW9uKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICB9IGNsZWFudXBTdWJzY3JpcHRpb24oc3Vic2NyaXB0aW9uKTtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gIH1cbn0pO1xuXG52YXIgJE9ic2VydmFibGUgPSBmdW5jdGlvbiBPYnNlcnZhYmxlKHN1YnNjcmliZXIpIHtcbiAgYW5JbnN0YW5jZSh0aGlzLCAkT2JzZXJ2YWJsZSwgJ09ic2VydmFibGUnLCAnX2YnKS5fZiA9IGFGdW5jdGlvbihzdWJzY3JpYmVyKTtcbn07XG5cbnJlZGVmaW5lQWxsKCRPYnNlcnZhYmxlLnByb3RvdHlwZSwge1xuICBzdWJzY3JpYmU6IGZ1bmN0aW9uIHN1YnNjcmliZShvYnNlcnZlcikge1xuICAgIHJldHVybiBuZXcgU3Vic2NyaXB0aW9uKG9ic2VydmVyLCB0aGlzLl9mKTtcbiAgfSxcbiAgZm9yRWFjaDogZnVuY3Rpb24gZm9yRWFjaChmbikge1xuICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICByZXR1cm4gbmV3IChjb3JlLlByb21pc2UgfHwgZ2xvYmFsLlByb21pc2UpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIGFGdW5jdGlvbihmbik7XG4gICAgICB2YXIgc3Vic2NyaXB0aW9uID0gdGhhdC5zdWJzY3JpYmUoe1xuICAgICAgICBuZXh0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGZuKHZhbHVlKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgICBzdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVycm9yOiByZWplY3QsXG4gICAgICAgIGNvbXBsZXRlOiByZXNvbHZlXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxufSk7XG5cbnJlZGVmaW5lQWxsKCRPYnNlcnZhYmxlLCB7XG4gIGZyb206IGZ1bmN0aW9uIGZyb20oeCkge1xuICAgIHZhciBDID0gdHlwZW9mIHRoaXMgPT09ICdmdW5jdGlvbicgPyB0aGlzIDogJE9ic2VydmFibGU7XG4gICAgdmFyIG1ldGhvZCA9IGdldE1ldGhvZChhbk9iamVjdCh4KVtPQlNFUlZBQkxFXSk7XG4gICAgaWYgKG1ldGhvZCkge1xuICAgICAgdmFyIG9ic2VydmFibGUgPSBhbk9iamVjdChtZXRob2QuY2FsbCh4KSk7XG4gICAgICByZXR1cm4gb2JzZXJ2YWJsZS5jb25zdHJ1Y3RvciA9PT0gQyA/IG9ic2VydmFibGUgOiBuZXcgQyhmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcbiAgICAgICAgcmV0dXJuIG9ic2VydmFibGUuc3Vic2NyaWJlKG9ic2VydmVyKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEMoZnVuY3Rpb24gKG9ic2VydmVyKSB7XG4gICAgICB2YXIgZG9uZSA9IGZhbHNlO1xuICAgICAgbWljcm90YXNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFkb25lKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChmb3JPZih4LCBmYWxzZSwgZnVuY3Rpb24gKGl0KSB7XG4gICAgICAgICAgICAgIG9ic2VydmVyLm5leHQoaXQpO1xuICAgICAgICAgICAgICBpZiAoZG9uZSkgcmV0dXJuIFJFVFVSTjtcbiAgICAgICAgICAgIH0pID09PSBSRVRVUk4pIHJldHVybjtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBpZiAoZG9uZSkgdGhyb3cgZTtcbiAgICAgICAgICAgIG9ic2VydmVyLmVycm9yKGUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH0gb2JzZXJ2ZXIuY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkgeyBkb25lID0gdHJ1ZTsgfTtcbiAgICB9KTtcbiAgfSxcbiAgb2Y6IGZ1bmN0aW9uIG9mKCkge1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gYXJndW1lbnRzLmxlbmd0aCwgaXRlbXMgPSBBcnJheShsKTsgaSA8IGw7KSBpdGVtc1tpXSA9IGFyZ3VtZW50c1tpKytdO1xuICAgIHJldHVybiBuZXcgKHR5cGVvZiB0aGlzID09PSAnZnVuY3Rpb24nID8gdGhpcyA6ICRPYnNlcnZhYmxlKShmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcbiAgICAgIHZhciBkb25lID0gZmFsc2U7XG4gICAgICBtaWNyb3Rhc2soZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIWRvbmUpIHtcbiAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGl0ZW1zLmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgICBvYnNlcnZlci5uZXh0KGl0ZW1zW2pdKTtcbiAgICAgICAgICAgIGlmIChkb25lKSByZXR1cm47XG4gICAgICAgICAgfSBvYnNlcnZlci5jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7IGRvbmUgPSB0cnVlOyB9O1xuICAgIH0pO1xuICB9XG59KTtcblxuaGlkZSgkT2JzZXJ2YWJsZS5wcm90b3R5cGUsIE9CU0VSVkFCTEUsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0pO1xuXG4kZXhwb3J0KCRleHBvcnQuRywgeyBPYnNlcnZhYmxlOiAkT2JzZXJ2YWJsZSB9KTtcblxucmVxdWlyZSgnLi9fc2V0LXNwZWNpZXMnKSgnT2JzZXJ2YWJsZScpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcub2JzZXJ2YWJsZS5qcyIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLXByb21pc2UtZmluYWxseVxuJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBjb3JlID0gcmVxdWlyZSgnLi9fY29yZScpO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIHNwZWNpZXNDb25zdHJ1Y3RvciA9IHJlcXVpcmUoJy4vX3NwZWNpZXMtY29uc3RydWN0b3InKTtcbnZhciBwcm9taXNlUmVzb2x2ZSA9IHJlcXVpcmUoJy4vX3Byb21pc2UtcmVzb2x2ZScpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuUiwgJ1Byb21pc2UnLCB7ICdmaW5hbGx5JzogZnVuY3Rpb24gKG9uRmluYWxseSkge1xuICB2YXIgQyA9IHNwZWNpZXNDb25zdHJ1Y3Rvcih0aGlzLCBjb3JlLlByb21pc2UgfHwgZ2xvYmFsLlByb21pc2UpO1xuICB2YXIgaXNGdW5jdGlvbiA9IHR5cGVvZiBvbkZpbmFsbHkgPT0gJ2Z1bmN0aW9uJztcbiAgcmV0dXJuIHRoaXMudGhlbihcbiAgICBpc0Z1bmN0aW9uID8gZnVuY3Rpb24gKHgpIHtcbiAgICAgIHJldHVybiBwcm9taXNlUmVzb2x2ZShDLCBvbkZpbmFsbHkoKSkudGhlbihmdW5jdGlvbiAoKSB7IHJldHVybiB4OyB9KTtcbiAgICB9IDogb25GaW5hbGx5LFxuICAgIGlzRnVuY3Rpb24gPyBmdW5jdGlvbiAoZSkge1xuICAgICAgcmV0dXJuIHByb21pc2VSZXNvbHZlKEMsIG9uRmluYWxseSgpKS50aGVuKGZ1bmN0aW9uICgpIHsgdGhyb3cgZTsgfSk7XG4gICAgfSA6IG9uRmluYWxseVxuICApO1xufSB9KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnByb21pc2UuZmluYWxseS5qcyIsIid1c2Ugc3RyaWN0Jztcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLXByb21pc2UtdHJ5XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIG5ld1Byb21pc2VDYXBhYmlsaXR5ID0gcmVxdWlyZSgnLi9fbmV3LXByb21pc2UtY2FwYWJpbGl0eScpO1xudmFyIHBlcmZvcm0gPSByZXF1aXJlKCcuL19wZXJmb3JtJyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnUHJvbWlzZScsIHsgJ3RyeSc6IGZ1bmN0aW9uIChjYWxsYmFja2ZuKSB7XG4gIHZhciBwcm9taXNlQ2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5LmYodGhpcyk7XG4gIHZhciByZXN1bHQgPSBwZXJmb3JtKGNhbGxiYWNrZm4pO1xuICAocmVzdWx0LmUgPyBwcm9taXNlQ2FwYWJpbGl0eS5yZWplY3QgOiBwcm9taXNlQ2FwYWJpbGl0eS5yZXNvbHZlKShyZXN1bHQudik7XG4gIHJldHVybiBwcm9taXNlQ2FwYWJpbGl0eS5wcm9taXNlO1xufSB9KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnByb21pc2UudHJ5LmpzIiwidmFyIG1ldGFkYXRhID0gcmVxdWlyZSgnLi9fbWV0YWRhdGEnKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIHRvTWV0YUtleSA9IG1ldGFkYXRhLmtleTtcbnZhciBvcmRpbmFyeURlZmluZU93bk1ldGFkYXRhID0gbWV0YWRhdGEuc2V0O1xuXG5tZXRhZGF0YS5leHAoeyBkZWZpbmVNZXRhZGF0YTogZnVuY3Rpb24gZGVmaW5lTWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUsIHRhcmdldCwgdGFyZ2V0S2V5KSB7XG4gIG9yZGluYXJ5RGVmaW5lT3duTWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUsIGFuT2JqZWN0KHRhcmdldCksIHRvTWV0YUtleSh0YXJnZXRLZXkpKTtcbn0gfSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5yZWZsZWN0LmRlZmluZS1tZXRhZGF0YS5qcyIsInZhciBtZXRhZGF0YSA9IHJlcXVpcmUoJy4vX21ldGFkYXRhJyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciB0b01ldGFLZXkgPSBtZXRhZGF0YS5rZXk7XG52YXIgZ2V0T3JDcmVhdGVNZXRhZGF0YU1hcCA9IG1ldGFkYXRhLm1hcDtcbnZhciBzdG9yZSA9IG1ldGFkYXRhLnN0b3JlO1xuXG5tZXRhZGF0YS5leHAoeyBkZWxldGVNZXRhZGF0YTogZnVuY3Rpb24gZGVsZXRlTWV0YWRhdGEobWV0YWRhdGFLZXksIHRhcmdldCAvKiAsIHRhcmdldEtleSAqLykge1xuICB2YXIgdGFyZ2V0S2V5ID0gYXJndW1lbnRzLmxlbmd0aCA8IDMgPyB1bmRlZmluZWQgOiB0b01ldGFLZXkoYXJndW1lbnRzWzJdKTtcbiAgdmFyIG1ldGFkYXRhTWFwID0gZ2V0T3JDcmVhdGVNZXRhZGF0YU1hcChhbk9iamVjdCh0YXJnZXQpLCB0YXJnZXRLZXksIGZhbHNlKTtcbiAgaWYgKG1ldGFkYXRhTWFwID09PSB1bmRlZmluZWQgfHwgIW1ldGFkYXRhTWFwWydkZWxldGUnXShtZXRhZGF0YUtleSkpIHJldHVybiBmYWxzZTtcbiAgaWYgKG1ldGFkYXRhTWFwLnNpemUpIHJldHVybiB0cnVlO1xuICB2YXIgdGFyZ2V0TWV0YWRhdGEgPSBzdG9yZS5nZXQodGFyZ2V0KTtcbiAgdGFyZ2V0TWV0YWRhdGFbJ2RlbGV0ZSddKHRhcmdldEtleSk7XG4gIHJldHVybiAhIXRhcmdldE1ldGFkYXRhLnNpemUgfHwgc3RvcmVbJ2RlbGV0ZSddKHRhcmdldCk7XG59IH0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcucmVmbGVjdC5kZWxldGUtbWV0YWRhdGEuanMiLCJ2YXIgU2V0ID0gcmVxdWlyZSgnLi9lczYuc2V0Jyk7XG52YXIgZnJvbSA9IHJlcXVpcmUoJy4vX2FycmF5LWZyb20taXRlcmFibGUnKTtcbnZhciBtZXRhZGF0YSA9IHJlcXVpcmUoJy4vX21ldGFkYXRhJyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBnZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4vX29iamVjdC1ncG8nKTtcbnZhciBvcmRpbmFyeU93bk1ldGFkYXRhS2V5cyA9IG1ldGFkYXRhLmtleXM7XG52YXIgdG9NZXRhS2V5ID0gbWV0YWRhdGEua2V5O1xuXG52YXIgb3JkaW5hcnlNZXRhZGF0YUtleXMgPSBmdW5jdGlvbiAoTywgUCkge1xuICB2YXIgb0tleXMgPSBvcmRpbmFyeU93bk1ldGFkYXRhS2V5cyhPLCBQKTtcbiAgdmFyIHBhcmVudCA9IGdldFByb3RvdHlwZU9mKE8pO1xuICBpZiAocGFyZW50ID09PSBudWxsKSByZXR1cm4gb0tleXM7XG4gIHZhciBwS2V5cyA9IG9yZGluYXJ5TWV0YWRhdGFLZXlzKHBhcmVudCwgUCk7XG4gIHJldHVybiBwS2V5cy5sZW5ndGggPyBvS2V5cy5sZW5ndGggPyBmcm9tKG5ldyBTZXQob0tleXMuY29uY2F0KHBLZXlzKSkpIDogcEtleXMgOiBvS2V5cztcbn07XG5cbm1ldGFkYXRhLmV4cCh7IGdldE1ldGFkYXRhS2V5czogZnVuY3Rpb24gZ2V0TWV0YWRhdGFLZXlzKHRhcmdldCAvKiAsIHRhcmdldEtleSAqLykge1xuICByZXR1cm4gb3JkaW5hcnlNZXRhZGF0YUtleXMoYW5PYmplY3QodGFyZ2V0KSwgYXJndW1lbnRzLmxlbmd0aCA8IDIgPyB1bmRlZmluZWQgOiB0b01ldGFLZXkoYXJndW1lbnRzWzFdKSk7XG59IH0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcucmVmbGVjdC5nZXQtbWV0YWRhdGEta2V5cy5qcyIsInZhciBtZXRhZGF0YSA9IHJlcXVpcmUoJy4vX21ldGFkYXRhJyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBnZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4vX29iamVjdC1ncG8nKTtcbnZhciBvcmRpbmFyeUhhc093bk1ldGFkYXRhID0gbWV0YWRhdGEuaGFzO1xudmFyIG9yZGluYXJ5R2V0T3duTWV0YWRhdGEgPSBtZXRhZGF0YS5nZXQ7XG52YXIgdG9NZXRhS2V5ID0gbWV0YWRhdGEua2V5O1xuXG52YXIgb3JkaW5hcnlHZXRNZXRhZGF0YSA9IGZ1bmN0aW9uIChNZXRhZGF0YUtleSwgTywgUCkge1xuICB2YXIgaGFzT3duID0gb3JkaW5hcnlIYXNPd25NZXRhZGF0YShNZXRhZGF0YUtleSwgTywgUCk7XG4gIGlmIChoYXNPd24pIHJldHVybiBvcmRpbmFyeUdldE93bk1ldGFkYXRhKE1ldGFkYXRhS2V5LCBPLCBQKTtcbiAgdmFyIHBhcmVudCA9IGdldFByb3RvdHlwZU9mKE8pO1xuICByZXR1cm4gcGFyZW50ICE9PSBudWxsID8gb3JkaW5hcnlHZXRNZXRhZGF0YShNZXRhZGF0YUtleSwgcGFyZW50LCBQKSA6IHVuZGVmaW5lZDtcbn07XG5cbm1ldGFkYXRhLmV4cCh7IGdldE1ldGFkYXRhOiBmdW5jdGlvbiBnZXRNZXRhZGF0YShtZXRhZGF0YUtleSwgdGFyZ2V0IC8qICwgdGFyZ2V0S2V5ICovKSB7XG4gIHJldHVybiBvcmRpbmFyeUdldE1ldGFkYXRhKG1ldGFkYXRhS2V5LCBhbk9iamVjdCh0YXJnZXQpLCBhcmd1bWVudHMubGVuZ3RoIDwgMyA/IHVuZGVmaW5lZCA6IHRvTWV0YUtleShhcmd1bWVudHNbMl0pKTtcbn0gfSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5yZWZsZWN0LmdldC1tZXRhZGF0YS5qcyIsInZhciBtZXRhZGF0YSA9IHJlcXVpcmUoJy4vX21ldGFkYXRhJyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBvcmRpbmFyeU93bk1ldGFkYXRhS2V5cyA9IG1ldGFkYXRhLmtleXM7XG52YXIgdG9NZXRhS2V5ID0gbWV0YWRhdGEua2V5O1xuXG5tZXRhZGF0YS5leHAoeyBnZXRPd25NZXRhZGF0YUtleXM6IGZ1bmN0aW9uIGdldE93bk1ldGFkYXRhS2V5cyh0YXJnZXQgLyogLCB0YXJnZXRLZXkgKi8pIHtcbiAgcmV0dXJuIG9yZGluYXJ5T3duTWV0YWRhdGFLZXlzKGFuT2JqZWN0KHRhcmdldCksIGFyZ3VtZW50cy5sZW5ndGggPCAyID8gdW5kZWZpbmVkIDogdG9NZXRhS2V5KGFyZ3VtZW50c1sxXSkpO1xufSB9KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnJlZmxlY3QuZ2V0LW93bi1tZXRhZGF0YS1rZXlzLmpzIiwidmFyIG1ldGFkYXRhID0gcmVxdWlyZSgnLi9fbWV0YWRhdGEnKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIG9yZGluYXJ5R2V0T3duTWV0YWRhdGEgPSBtZXRhZGF0YS5nZXQ7XG52YXIgdG9NZXRhS2V5ID0gbWV0YWRhdGEua2V5O1xuXG5tZXRhZGF0YS5leHAoeyBnZXRPd25NZXRhZGF0YTogZnVuY3Rpb24gZ2V0T3duTWV0YWRhdGEobWV0YWRhdGFLZXksIHRhcmdldCAvKiAsIHRhcmdldEtleSAqLykge1xuICByZXR1cm4gb3JkaW5hcnlHZXRPd25NZXRhZGF0YShtZXRhZGF0YUtleSwgYW5PYmplY3QodGFyZ2V0KVxuICAgICwgYXJndW1lbnRzLmxlbmd0aCA8IDMgPyB1bmRlZmluZWQgOiB0b01ldGFLZXkoYXJndW1lbnRzWzJdKSk7XG59IH0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcucmVmbGVjdC5nZXQtb3duLW1ldGFkYXRhLmpzIiwidmFyIG1ldGFkYXRhID0gcmVxdWlyZSgnLi9fbWV0YWRhdGEnKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIGdldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpO1xudmFyIG9yZGluYXJ5SGFzT3duTWV0YWRhdGEgPSBtZXRhZGF0YS5oYXM7XG52YXIgdG9NZXRhS2V5ID0gbWV0YWRhdGEua2V5O1xuXG52YXIgb3JkaW5hcnlIYXNNZXRhZGF0YSA9IGZ1bmN0aW9uIChNZXRhZGF0YUtleSwgTywgUCkge1xuICB2YXIgaGFzT3duID0gb3JkaW5hcnlIYXNPd25NZXRhZGF0YShNZXRhZGF0YUtleSwgTywgUCk7XG4gIGlmIChoYXNPd24pIHJldHVybiB0cnVlO1xuICB2YXIgcGFyZW50ID0gZ2V0UHJvdG90eXBlT2YoTyk7XG4gIHJldHVybiBwYXJlbnQgIT09IG51bGwgPyBvcmRpbmFyeUhhc01ldGFkYXRhKE1ldGFkYXRhS2V5LCBwYXJlbnQsIFApIDogZmFsc2U7XG59O1xuXG5tZXRhZGF0YS5leHAoeyBoYXNNZXRhZGF0YTogZnVuY3Rpb24gaGFzTWV0YWRhdGEobWV0YWRhdGFLZXksIHRhcmdldCAvKiAsIHRhcmdldEtleSAqLykge1xuICByZXR1cm4gb3JkaW5hcnlIYXNNZXRhZGF0YShtZXRhZGF0YUtleSwgYW5PYmplY3QodGFyZ2V0KSwgYXJndW1lbnRzLmxlbmd0aCA8IDMgPyB1bmRlZmluZWQgOiB0b01ldGFLZXkoYXJndW1lbnRzWzJdKSk7XG59IH0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcucmVmbGVjdC5oYXMtbWV0YWRhdGEuanMiLCJ2YXIgbWV0YWRhdGEgPSByZXF1aXJlKCcuL19tZXRhZGF0YScpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgb3JkaW5hcnlIYXNPd25NZXRhZGF0YSA9IG1ldGFkYXRhLmhhcztcbnZhciB0b01ldGFLZXkgPSBtZXRhZGF0YS5rZXk7XG5cbm1ldGFkYXRhLmV4cCh7IGhhc093bk1ldGFkYXRhOiBmdW5jdGlvbiBoYXNPd25NZXRhZGF0YShtZXRhZGF0YUtleSwgdGFyZ2V0IC8qICwgdGFyZ2V0S2V5ICovKSB7XG4gIHJldHVybiBvcmRpbmFyeUhhc093bk1ldGFkYXRhKG1ldGFkYXRhS2V5LCBhbk9iamVjdCh0YXJnZXQpXG4gICAgLCBhcmd1bWVudHMubGVuZ3RoIDwgMyA/IHVuZGVmaW5lZCA6IHRvTWV0YUtleShhcmd1bWVudHNbMl0pKTtcbn0gfSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5yZWZsZWN0Lmhhcy1vd24tbWV0YWRhdGEuanMiLCJ2YXIgJG1ldGFkYXRhID0gcmVxdWlyZSgnLi9fbWV0YWRhdGEnKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKTtcbnZhciB0b01ldGFLZXkgPSAkbWV0YWRhdGEua2V5O1xudmFyIG9yZGluYXJ5RGVmaW5lT3duTWV0YWRhdGEgPSAkbWV0YWRhdGEuc2V0O1xuXG4kbWV0YWRhdGEuZXhwKHsgbWV0YWRhdGE6IGZ1bmN0aW9uIG1ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbiBkZWNvcmF0b3IodGFyZ2V0LCB0YXJnZXRLZXkpIHtcbiAgICBvcmRpbmFyeURlZmluZU93bk1ldGFkYXRhKFxuICAgICAgbWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUsXG4gICAgICAodGFyZ2V0S2V5ICE9PSB1bmRlZmluZWQgPyBhbk9iamVjdCA6IGFGdW5jdGlvbikodGFyZ2V0KSxcbiAgICAgIHRvTWV0YUtleSh0YXJnZXRLZXkpXG4gICAgKTtcbiAgfTtcbn0gfSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5yZWZsZWN0Lm1ldGFkYXRhLmpzIiwiLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9wcm9wb3NhbC1zZXRtYXAtb2Zmcm9tLyNzZWMtc2V0LmZyb21cbnJlcXVpcmUoJy4vX3NldC1jb2xsZWN0aW9uLWZyb20nKSgnU2V0Jyk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5zZXQuZnJvbS5qcyIsIi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vcHJvcG9zYWwtc2V0bWFwLW9mZnJvbS8jc2VjLXNldC5vZlxucmVxdWlyZSgnLi9fc2V0LWNvbGxlY3Rpb24tb2YnKSgnU2V0Jyk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5zZXQub2YuanMiLCIvLyBodHRwczovL2dpdGh1Yi5jb20vRGF2aWRCcnVhbnQvTWFwLVNldC5wcm90b3R5cGUudG9KU09OXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuUiwgJ1NldCcsIHsgdG9KU09OOiByZXF1aXJlKCcuL19jb2xsZWN0aW9uLXRvLWpzb24nKSgnU2V0JykgfSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5zZXQudG8tanNvbi5qcyIsIid1c2Ugc3RyaWN0Jztcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXRoaWFzYnluZW5zL1N0cmluZy5wcm90b3R5cGUuYXRcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgJGF0ID0gcmVxdWlyZSgnLi9fc3RyaW5nLWF0JykodHJ1ZSk7XG5cbiRleHBvcnQoJGV4cG9ydC5QLCAnU3RyaW5nJywge1xuICBhdDogZnVuY3Rpb24gYXQocG9zKSB7XG4gICAgcmV0dXJuICRhdCh0aGlzLCBwb3MpO1xuICB9XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnN0cmluZy5hdC5qcyIsIid1c2Ugc3RyaWN0Jztcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vU3RyaW5nLnByb3RvdHlwZS5tYXRjaEFsbC9cbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgZGVmaW5lZCA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xudmFyIGlzUmVnRXhwID0gcmVxdWlyZSgnLi9faXMtcmVnZXhwJyk7XG52YXIgZ2V0RmxhZ3MgPSByZXF1aXJlKCcuL19mbGFncycpO1xudmFyIFJlZ0V4cFByb3RvID0gUmVnRXhwLnByb3RvdHlwZTtcblxudmFyICRSZWdFeHBTdHJpbmdJdGVyYXRvciA9IGZ1bmN0aW9uIChyZWdleHAsIHN0cmluZykge1xuICB0aGlzLl9yID0gcmVnZXhwO1xuICB0aGlzLl9zID0gc3RyaW5nO1xufTtcblxucmVxdWlyZSgnLi9faXRlci1jcmVhdGUnKSgkUmVnRXhwU3RyaW5nSXRlcmF0b3IsICdSZWdFeHAgU3RyaW5nJywgZnVuY3Rpb24gbmV4dCgpIHtcbiAgdmFyIG1hdGNoID0gdGhpcy5fci5leGVjKHRoaXMuX3MpO1xuICByZXR1cm4geyB2YWx1ZTogbWF0Y2gsIGRvbmU6IG1hdGNoID09PSBudWxsIH07XG59KTtcblxuJGV4cG9ydCgkZXhwb3J0LlAsICdTdHJpbmcnLCB7XG4gIG1hdGNoQWxsOiBmdW5jdGlvbiBtYXRjaEFsbChyZWdleHApIHtcbiAgICBkZWZpbmVkKHRoaXMpO1xuICAgIGlmICghaXNSZWdFeHAocmVnZXhwKSkgdGhyb3cgVHlwZUVycm9yKHJlZ2V4cCArICcgaXMgbm90IGEgcmVnZXhwIScpO1xuICAgIHZhciBTID0gU3RyaW5nKHRoaXMpO1xuICAgIHZhciBmbGFncyA9ICdmbGFncycgaW4gUmVnRXhwUHJvdG8gPyBTdHJpbmcocmVnZXhwLmZsYWdzKSA6IGdldEZsYWdzLmNhbGwocmVnZXhwKTtcbiAgICB2YXIgcnggPSBuZXcgUmVnRXhwKHJlZ2V4cC5zb3VyY2UsIH5mbGFncy5pbmRleE9mKCdnJykgPyBmbGFncyA6ICdnJyArIGZsYWdzKTtcbiAgICByeC5sYXN0SW5kZXggPSB0b0xlbmd0aChyZWdleHAubGFzdEluZGV4KTtcbiAgICByZXR1cm4gbmV3ICRSZWdFeHBTdHJpbmdJdGVyYXRvcihyeCwgUyk7XG4gIH1cbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcuc3RyaW5nLm1hdGNoLWFsbC5qcyIsIid1c2Ugc3RyaWN0Jztcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLXN0cmluZy1wYWQtc3RhcnQtZW5kXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyICRwYWQgPSByZXF1aXJlKCcuL19zdHJpbmctcGFkJyk7XG5cbiRleHBvcnQoJGV4cG9ydC5QLCAnU3RyaW5nJywge1xuICBwYWRFbmQ6IGZ1bmN0aW9uIHBhZEVuZChtYXhMZW5ndGggLyogLCBmaWxsU3RyaW5nID0gJyAnICovKSB7XG4gICAgcmV0dXJuICRwYWQodGhpcywgbWF4TGVuZ3RoLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCwgZmFsc2UpO1xuICB9XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnN0cmluZy5wYWQtZW5kLmpzIiwiJ3VzZSBzdHJpY3QnO1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtc3RyaW5nLXBhZC1zdGFydC1lbmRcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgJHBhZCA9IHJlcXVpcmUoJy4vX3N0cmluZy1wYWQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAsICdTdHJpbmcnLCB7XG4gIHBhZFN0YXJ0OiBmdW5jdGlvbiBwYWRTdGFydChtYXhMZW5ndGggLyogLCBmaWxsU3RyaW5nID0gJyAnICovKSB7XG4gICAgcmV0dXJuICRwYWQodGhpcywgbWF4TGVuZ3RoLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCwgdHJ1ZSk7XG4gIH1cbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcuc3RyaW5nLnBhZC1zdGFydC5qcyIsIid1c2Ugc3RyaWN0Jztcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9zZWJtYXJrYmFnZS9lY21hc2NyaXB0LXN0cmluZy1sZWZ0LXJpZ2h0LXRyaW1cbnJlcXVpcmUoJy4vX3N0cmluZy10cmltJykoJ3RyaW1MZWZ0JywgZnVuY3Rpb24gKCR0cmltKSB7XG4gIHJldHVybiBmdW5jdGlvbiB0cmltTGVmdCgpIHtcbiAgICByZXR1cm4gJHRyaW0odGhpcywgMSk7XG4gIH07XG59LCAndHJpbVN0YXJ0Jyk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5zdHJpbmcudHJpbS1sZWZ0LmpzIiwiJ3VzZSBzdHJpY3QnO1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL3NlYm1hcmtiYWdlL2VjbWFzY3JpcHQtc3RyaW5nLWxlZnQtcmlnaHQtdHJpbVxucmVxdWlyZSgnLi9fc3RyaW5nLXRyaW0nKSgndHJpbVJpZ2h0JywgZnVuY3Rpb24gKCR0cmltKSB7XG4gIHJldHVybiBmdW5jdGlvbiB0cmltUmlnaHQoKSB7XG4gICAgcmV0dXJuICR0cmltKHRoaXMsIDIpO1xuICB9O1xufSwgJ3RyaW1FbmQnKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnN0cmluZy50cmltLXJpZ2h0LmpzIiwicmVxdWlyZSgnLi9fd2tzLWRlZmluZScpKCdhc3luY0l0ZXJhdG9yJyk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5zeW1ib2wuYXN5bmMtaXRlcmF0b3IuanMiLCJyZXF1aXJlKCcuL193a3MtZGVmaW5lJykoJ29ic2VydmFibGUnKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnN5bWJvbC5vYnNlcnZhYmxlLmpzIiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtZ2xvYmFsXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ1N5c3RlbScsIHsgZ2xvYmFsOiByZXF1aXJlKCcuL19nbG9iYWwnKSB9KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnN5c3RlbS5nbG9iYWwuanMiLCIvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL3Byb3Bvc2FsLXNldG1hcC1vZmZyb20vI3NlYy13ZWFrbWFwLmZyb21cbnJlcXVpcmUoJy4vX3NldC1jb2xsZWN0aW9uLWZyb20nKSgnV2Vha01hcCcpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcud2Vhay1tYXAuZnJvbS5qcyIsIi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vcHJvcG9zYWwtc2V0bWFwLW9mZnJvbS8jc2VjLXdlYWttYXAub2ZcbnJlcXVpcmUoJy4vX3NldC1jb2xsZWN0aW9uLW9mJykoJ1dlYWtNYXAnKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LndlYWstbWFwLm9mLmpzIiwiLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9wcm9wb3NhbC1zZXRtYXAtb2Zmcm9tLyNzZWMtd2Vha3NldC5mcm9tXG5yZXF1aXJlKCcuL19zZXQtY29sbGVjdGlvbi1mcm9tJykoJ1dlYWtTZXQnKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LndlYWstc2V0LmZyb20uanMiLCIvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL3Byb3Bvc2FsLXNldG1hcC1vZmZyb20vI3NlYy13ZWFrc2V0Lm9mXG5yZXF1aXJlKCcuL19zZXQtY29sbGVjdGlvbi1vZicpKCdXZWFrU2V0Jyk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy53ZWFrLXNldC5vZi5qcyIsInZhciAkaXRlcmF0b3JzID0gcmVxdWlyZSgnLi9lczYuYXJyYXkuaXRlcmF0b3InKTtcbnZhciBnZXRLZXlzID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKTtcbnZhciByZWRlZmluZSA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lJyk7XG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgaGlkZSA9IHJlcXVpcmUoJy4vX2hpZGUnKTtcbnZhciBJdGVyYXRvcnMgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKTtcbnZhciB3a3MgPSByZXF1aXJlKCcuL193a3MnKTtcbnZhciBJVEVSQVRPUiA9IHdrcygnaXRlcmF0b3InKTtcbnZhciBUT19TVFJJTkdfVEFHID0gd2tzKCd0b1N0cmluZ1RhZycpO1xudmFyIEFycmF5VmFsdWVzID0gSXRlcmF0b3JzLkFycmF5O1xuXG52YXIgRE9NSXRlcmFibGVzID0ge1xuICBDU1NSdWxlTGlzdDogdHJ1ZSwgLy8gVE9ETzogTm90IHNwZWMgY29tcGxpYW50LCBzaG91bGQgYmUgZmFsc2UuXG4gIENTU1N0eWxlRGVjbGFyYXRpb246IGZhbHNlLFxuICBDU1NWYWx1ZUxpc3Q6IGZhbHNlLFxuICBDbGllbnRSZWN0TGlzdDogZmFsc2UsXG4gIERPTVJlY3RMaXN0OiBmYWxzZSxcbiAgRE9NU3RyaW5nTGlzdDogZmFsc2UsXG4gIERPTVRva2VuTGlzdDogdHJ1ZSxcbiAgRGF0YVRyYW5zZmVySXRlbUxpc3Q6IGZhbHNlLFxuICBGaWxlTGlzdDogZmFsc2UsXG4gIEhUTUxBbGxDb2xsZWN0aW9uOiBmYWxzZSxcbiAgSFRNTENvbGxlY3Rpb246IGZhbHNlLFxuICBIVE1MRm9ybUVsZW1lbnQ6IGZhbHNlLFxuICBIVE1MU2VsZWN0RWxlbWVudDogZmFsc2UsXG4gIE1lZGlhTGlzdDogdHJ1ZSwgLy8gVE9ETzogTm90IHNwZWMgY29tcGxpYW50LCBzaG91bGQgYmUgZmFsc2UuXG4gIE1pbWVUeXBlQXJyYXk6IGZhbHNlLFxuICBOYW1lZE5vZGVNYXA6IGZhbHNlLFxuICBOb2RlTGlzdDogdHJ1ZSxcbiAgUGFpbnRSZXF1ZXN0TGlzdDogZmFsc2UsXG4gIFBsdWdpbjogZmFsc2UsXG4gIFBsdWdpbkFycmF5OiBmYWxzZSxcbiAgU1ZHTGVuZ3RoTGlzdDogZmFsc2UsXG4gIFNWR051bWJlckxpc3Q6IGZhbHNlLFxuICBTVkdQYXRoU2VnTGlzdDogZmFsc2UsXG4gIFNWR1BvaW50TGlzdDogZmFsc2UsXG4gIFNWR1N0cmluZ0xpc3Q6IGZhbHNlLFxuICBTVkdUcmFuc2Zvcm1MaXN0OiBmYWxzZSxcbiAgU291cmNlQnVmZmVyTGlzdDogZmFsc2UsXG4gIFN0eWxlU2hlZXRMaXN0OiB0cnVlLCAvLyBUT0RPOiBOb3Qgc3BlYyBjb21wbGlhbnQsIHNob3VsZCBiZSBmYWxzZS5cbiAgVGV4dFRyYWNrQ3VlTGlzdDogZmFsc2UsXG4gIFRleHRUcmFja0xpc3Q6IGZhbHNlLFxuICBUb3VjaExpc3Q6IGZhbHNlXG59O1xuXG5mb3IgKHZhciBjb2xsZWN0aW9ucyA9IGdldEtleXMoRE9NSXRlcmFibGVzKSwgaSA9IDA7IGkgPCBjb2xsZWN0aW9ucy5sZW5ndGg7IGkrKykge1xuICB2YXIgTkFNRSA9IGNvbGxlY3Rpb25zW2ldO1xuICB2YXIgZXhwbGljaXQgPSBET01JdGVyYWJsZXNbTkFNRV07XG4gIHZhciBDb2xsZWN0aW9uID0gZ2xvYmFsW05BTUVdO1xuICB2YXIgcHJvdG8gPSBDb2xsZWN0aW9uICYmIENvbGxlY3Rpb24ucHJvdG90eXBlO1xuICB2YXIga2V5O1xuICBpZiAocHJvdG8pIHtcbiAgICBpZiAoIXByb3RvW0lURVJBVE9SXSkgaGlkZShwcm90bywgSVRFUkFUT1IsIEFycmF5VmFsdWVzKTtcbiAgICBpZiAoIXByb3RvW1RPX1NUUklOR19UQUddKSBoaWRlKHByb3RvLCBUT19TVFJJTkdfVEFHLCBOQU1FKTtcbiAgICBJdGVyYXRvcnNbTkFNRV0gPSBBcnJheVZhbHVlcztcbiAgICBpZiAoZXhwbGljaXQpIGZvciAoa2V5IGluICRpdGVyYXRvcnMpIGlmICghcHJvdG9ba2V5XSkgcmVkZWZpbmUocHJvdG8sIGtleSwgJGl0ZXJhdG9yc1trZXldLCB0cnVlKTtcbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy93ZWIuZG9tLml0ZXJhYmxlLmpzIiwidmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciAkdGFzayA9IHJlcXVpcmUoJy4vX3Rhc2snKTtcbiRleHBvcnQoJGV4cG9ydC5HICsgJGV4cG9ydC5CLCB7XG4gIHNldEltbWVkaWF0ZTogJHRhc2suc2V0LFxuICBjbGVhckltbWVkaWF0ZTogJHRhc2suY2xlYXJcbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy93ZWIuaW1tZWRpYXRlLmpzIiwiLy8gaWU5LSBzZXRUaW1lb3V0ICYgc2V0SW50ZXJ2YWwgYWRkaXRpb25hbCBwYXJhbWV0ZXJzIGZpeFxudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBuYXZpZ2F0b3IgPSBnbG9iYWwubmF2aWdhdG9yO1xudmFyIHNsaWNlID0gW10uc2xpY2U7XG52YXIgTVNJRSA9ICEhbmF2aWdhdG9yICYmIC9NU0lFIC5cXC4vLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7IC8vIDwtIGRpcnR5IGllOS0gY2hlY2tcbnZhciB3cmFwID0gZnVuY3Rpb24gKHNldCkge1xuICByZXR1cm4gZnVuY3Rpb24gKGZuLCB0aW1lIC8qICwgLi4uYXJncyAqLykge1xuICAgIHZhciBib3VuZEFyZ3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMjtcbiAgICB2YXIgYXJncyA9IGJvdW5kQXJncyA/IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKSA6IGZhbHNlO1xuICAgIHJldHVybiBzZXQoYm91bmRBcmdzID8gZnVuY3Rpb24gKCkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5ldy1mdW5jXG4gICAgICAodHlwZW9mIGZuID09ICdmdW5jdGlvbicgPyBmbiA6IEZ1bmN0aW9uKGZuKSkuYXBwbHkodGhpcywgYXJncyk7XG4gICAgfSA6IGZuLCB0aW1lKTtcbiAgfTtcbn07XG4kZXhwb3J0KCRleHBvcnQuRyArICRleHBvcnQuQiArICRleHBvcnQuRiAqIE1TSUUsIHtcbiAgc2V0VGltZW91dDogd3JhcChnbG9iYWwuc2V0VGltZW91dCksXG4gIHNldEludGVydmFsOiB3cmFwKGdsb2JhbC5zZXRJbnRlcnZhbClcbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy93ZWIudGltZXJzLmpzIiwicmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zeW1ib2wnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LmNyZWF0ZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5vYmplY3QuZGVmaW5lLXByb3BlcnR5Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm9iamVjdC5kZWZpbmUtcHJvcGVydGllcycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5vYmplY3QuZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm9iamVjdC5nZXQtcHJvdG90eXBlLW9mJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm9iamVjdC5rZXlzJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm9iamVjdC5nZXQtb3duLXByb3BlcnR5LW5hbWVzJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm9iamVjdC5mcmVlemUnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LnNlYWwnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LnByZXZlbnQtZXh0ZW5zaW9ucycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5vYmplY3QuaXMtZnJvemVuJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm9iamVjdC5pcy1zZWFsZWQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LmlzLWV4dGVuc2libGUnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LmFzc2lnbicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5vYmplY3QuaXMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LnNldC1wcm90b3R5cGUtb2YnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LnRvLXN0cmluZycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5mdW5jdGlvbi5iaW5kJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmZ1bmN0aW9uLm5hbWUnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuZnVuY3Rpb24uaGFzLWluc3RhbmNlJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnBhcnNlLWludCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5wYXJzZS1mbG9hdCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5udW1iZXIuY29uc3RydWN0b3InKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubnVtYmVyLnRvLWZpeGVkJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm51bWJlci50by1wcmVjaXNpb24nKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubnVtYmVyLmVwc2lsb24nKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubnVtYmVyLmlzLWZpbml0ZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5udW1iZXIuaXMtaW50ZWdlcicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5udW1iZXIuaXMtbmFuJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm51bWJlci5pcy1zYWZlLWludGVnZXInKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubnVtYmVyLm1heC1zYWZlLWludGVnZXInKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubnVtYmVyLm1pbi1zYWZlLWludGVnZXInKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubnVtYmVyLnBhcnNlLWZsb2F0Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm51bWJlci5wYXJzZS1pbnQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWF0aC5hY29zaCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXRoLmFzaW5oJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hdGguYXRhbmgnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWF0aC5jYnJ0Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hdGguY2x6MzInKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWF0aC5jb3NoJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hdGguZXhwbTEnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWF0aC5mcm91bmQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWF0aC5oeXBvdCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXRoLmltdWwnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWF0aC5sb2cxMCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXRoLmxvZzFwJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hdGgubG9nMicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXRoLnNpZ24nKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWF0aC5zaW5oJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hdGgudGFuaCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXRoLnRydW5jJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5mcm9tLWNvZGUtcG9pbnQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLnJhdycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcudHJpbScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuaXRlcmF0b3InKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLmNvZGUtcG9pbnQtYXQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLmVuZHMtd2l0aCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuaW5jbHVkZXMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLnJlcGVhdCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuc3RhcnRzLXdpdGgnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLmFuY2hvcicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuYmlnJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5ibGluaycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuYm9sZCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuZml4ZWQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLmZvbnRjb2xvcicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuZm9udHNpemUnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLml0YWxpY3MnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLmxpbmsnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLnNtYWxsJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5zdHJpa2UnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLnN1YicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuc3VwJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmRhdGUubm93Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmRhdGUudG8tanNvbicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5kYXRlLnRvLWlzby1zdHJpbmcnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuZGF0ZS50by1zdHJpbmcnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuZGF0ZS50by1wcmltaXRpdmUnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkuaXMtYXJyYXknKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkuZnJvbScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5vZicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5qb2luJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5LnNsaWNlJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5LnNvcnQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkuZm9yLWVhY2gnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkubWFwJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5LmZpbHRlcicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5zb21lJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5LmV2ZXJ5Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5LnJlZHVjZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5yZWR1Y2UtcmlnaHQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkuaW5kZXgtb2YnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkubGFzdC1pbmRleC1vZicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5jb3B5LXdpdGhpbicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5maWxsJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5LmZpbmQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkuZmluZC1pbmRleCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5zcGVjaWVzJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5Lml0ZXJhdG9yJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZ2V4cC5jb25zdHJ1Y3RvcicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWdleHAudG8tc3RyaW5nJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZ2V4cC5mbGFncycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWdleHAubWF0Y2gnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVnZXhwLnJlcGxhY2UnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVnZXhwLnNlYXJjaCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWdleHAuc3BsaXQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucHJvbWlzZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXAnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc2V0Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LndlYWstbWFwJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LndlYWstc2V0Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnR5cGVkLmFycmF5LWJ1ZmZlcicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi50eXBlZC5kYXRhLXZpZXcnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYudHlwZWQuaW50OC1hcnJheScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi50eXBlZC51aW50OC1hcnJheScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi50eXBlZC51aW50OC1jbGFtcGVkLWFycmF5Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnR5cGVkLmludDE2LWFycmF5Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnR5cGVkLnVpbnQxNi1hcnJheScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi50eXBlZC5pbnQzMi1hcnJheScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi50eXBlZC51aW50MzItYXJyYXknKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYudHlwZWQuZmxvYXQzMi1hcnJheScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi50eXBlZC5mbG9hdDY0LWFycmF5Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZmxlY3QuYXBwbHknKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVmbGVjdC5jb25zdHJ1Y3QnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVmbGVjdC5kZWZpbmUtcHJvcGVydHknKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVmbGVjdC5kZWxldGUtcHJvcGVydHknKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVmbGVjdC5lbnVtZXJhdGUnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVmbGVjdC5nZXQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVmbGVjdC5nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3InKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVmbGVjdC5nZXQtcHJvdG90eXBlLW9mJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZmxlY3QuaGFzJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZmxlY3QuaXMtZXh0ZW5zaWJsZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWZsZWN0Lm93bi1rZXlzJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZmxlY3QucHJldmVudC1leHRlbnNpb25zJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZmxlY3Quc2V0Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZmxlY3Quc2V0LXByb3RvdHlwZS1vZicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5hcnJheS5pbmNsdWRlcycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5hcnJheS5mbGF0LW1hcCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5hcnJheS5mbGF0dGVuJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnN0cmluZy5hdCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5zdHJpbmcucGFkLXN0YXJ0Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnN0cmluZy5wYWQtZW5kJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnN0cmluZy50cmltLWxlZnQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcuc3RyaW5nLnRyaW0tcmlnaHQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcuc3RyaW5nLm1hdGNoLWFsbCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5zeW1ib2wuYXN5bmMtaXRlcmF0b3InKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcuc3ltYm9sLm9ic2VydmFibGUnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcub2JqZWN0LmdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvcnMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcub2JqZWN0LnZhbHVlcycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5vYmplY3QuZW50cmllcycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5vYmplY3QuZGVmaW5lLWdldHRlcicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5vYmplY3QuZGVmaW5lLXNldHRlcicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5vYmplY3QubG9va3VwLWdldHRlcicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5vYmplY3QubG9va3VwLXNldHRlcicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5tYXAudG8tanNvbicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5zZXQudG8tanNvbicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5tYXAub2YnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcuc2V0Lm9mJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LndlYWstbWFwLm9mJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LndlYWstc2V0Lm9mJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm1hcC5mcm9tJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnNldC5mcm9tJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LndlYWstbWFwLmZyb20nKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcud2Vhay1zZXQuZnJvbScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5nbG9iYWwnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcuc3lzdGVtLmdsb2JhbCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5lcnJvci5pcy1lcnJvcicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5tYXRoLmNsYW1wJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm1hdGguZGVnLXBlci1yYWQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcubWF0aC5kZWdyZWVzJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm1hdGguZnNjYWxlJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm1hdGguaWFkZGgnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcubWF0aC5pc3ViaCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5tYXRoLmltdWxoJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm1hdGgucmFkLXBlci1kZWcnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcubWF0aC5yYWRpYW5zJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm1hdGguc2NhbGUnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcubWF0aC51bXVsaCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5tYXRoLnNpZ25iaXQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcucHJvbWlzZS5maW5hbGx5Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnByb21pc2UudHJ5Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnJlZmxlY3QuZGVmaW5lLW1ldGFkYXRhJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnJlZmxlY3QuZGVsZXRlLW1ldGFkYXRhJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnJlZmxlY3QuZ2V0LW1ldGFkYXRhJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnJlZmxlY3QuZ2V0LW1ldGFkYXRhLWtleXMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcucmVmbGVjdC5nZXQtb3duLW1ldGFkYXRhJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnJlZmxlY3QuZ2V0LW93bi1tZXRhZGF0YS1rZXlzJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnJlZmxlY3QuaGFzLW1ldGFkYXRhJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnJlZmxlY3QuaGFzLW93bi1tZXRhZGF0YScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5yZWZsZWN0Lm1ldGFkYXRhJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LmFzYXAnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcub2JzZXJ2YWJsZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL3dlYi50aW1lcnMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy93ZWIuaW1tZWRpYXRlJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvd2ViLmRvbS5pdGVyYWJsZScpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL21vZHVsZXMvX2NvcmUnKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL3NoaW0uanMiLCJcInVzZSBzdHJpY3RcIjtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBcbiAqL1xuXG5mdW5jdGlvbiBtYWtlRW1wdHlGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gYXJnO1xuICB9O1xufVxuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gYWNjZXB0cyBhbmQgZGlzY2FyZHMgaW5wdXRzOyBpdCBoYXMgbm8gc2lkZSBlZmZlY3RzLiBUaGlzIGlzXG4gKiBwcmltYXJpbHkgdXNlZnVsIGlkaW9tYXRpY2FsbHkgZm9yIG92ZXJyaWRhYmxlIGZ1bmN0aW9uIGVuZHBvaW50cyB3aGljaFxuICogYWx3YXlzIG5lZWQgdG8gYmUgY2FsbGFibGUsIHNpbmNlIEpTIGxhY2tzIGEgbnVsbC1jYWxsIGlkaW9tIGFsYSBDb2NvYS5cbiAqL1xudmFyIGVtcHR5RnVuY3Rpb24gPSBmdW5jdGlvbiBlbXB0eUZ1bmN0aW9uKCkge307XG5cbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnMgPSBtYWtlRW1wdHlGdW5jdGlvbjtcbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNGYWxzZSA9IG1ha2VFbXB0eUZ1bmN0aW9uKGZhbHNlKTtcbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNUcnVlID0gbWFrZUVtcHR5RnVuY3Rpb24odHJ1ZSk7XG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zTnVsbCA9IG1ha2VFbXB0eUZ1bmN0aW9uKG51bGwpO1xuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc1RoaXMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzO1xufTtcbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNBcmd1bWVudCA9IGZ1bmN0aW9uIChhcmcpIHtcbiAgcmV0dXJuIGFyZztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZW1wdHlGdW5jdGlvbjtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvZW1wdHlGdW5jdGlvbi5qcyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGVtcHR5T2JqZWN0ID0ge307XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIE9iamVjdC5mcmVlemUoZW1wdHlPYmplY3QpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGVtcHR5T2JqZWN0O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9lbXB0eU9iamVjdC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBVc2UgaW52YXJpYW50KCkgdG8gYXNzZXJ0IHN0YXRlIHdoaWNoIHlvdXIgcHJvZ3JhbSBhc3N1bWVzIHRvIGJlIHRydWUuXG4gKlxuICogUHJvdmlkZSBzcHJpbnRmLXN0eWxlIGZvcm1hdCAob25seSAlcyBpcyBzdXBwb3J0ZWQpIGFuZCBhcmd1bWVudHNcbiAqIHRvIHByb3ZpZGUgaW5mb3JtYXRpb24gYWJvdXQgd2hhdCBicm9rZSBhbmQgd2hhdCB5b3Ugd2VyZVxuICogZXhwZWN0aW5nLlxuICpcbiAqIFRoZSBpbnZhcmlhbnQgbWVzc2FnZSB3aWxsIGJlIHN0cmlwcGVkIGluIHByb2R1Y3Rpb24sIGJ1dCB0aGUgaW52YXJpYW50XG4gKiB3aWxsIHJlbWFpbiB0byBlbnN1cmUgbG9naWMgZG9lcyBub3QgZGlmZmVyIGluIHByb2R1Y3Rpb24uXG4gKi9cblxudmFyIHZhbGlkYXRlRm9ybWF0ID0gZnVuY3Rpb24gdmFsaWRhdGVGb3JtYXQoZm9ybWF0KSB7fTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFsaWRhdGVGb3JtYXQgPSBmdW5jdGlvbiB2YWxpZGF0ZUZvcm1hdChmb3JtYXQpIHtcbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YXJpYW50IHJlcXVpcmVzIGFuIGVycm9yIG1lc3NhZ2UgYXJndW1lbnQnKTtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGludmFyaWFudChjb25kaXRpb24sIGZvcm1hdCwgYSwgYiwgYywgZCwgZSwgZikge1xuICB2YWxpZGF0ZUZvcm1hdChmb3JtYXQpO1xuXG4gIGlmICghY29uZGl0aW9uKSB7XG4gICAgdmFyIGVycm9yO1xuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoJ01pbmlmaWVkIGV4Y2VwdGlvbiBvY2N1cnJlZDsgdXNlIHRoZSBub24tbWluaWZpZWQgZGV2IGVudmlyb25tZW50ICcgKyAnZm9yIHRoZSBmdWxsIGVycm9yIG1lc3NhZ2UgYW5kIGFkZGl0aW9uYWwgaGVscGZ1bCB3YXJuaW5ncy4nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGFyZ3MgPSBbYSwgYiwgYywgZCwgZSwgZl07XG4gICAgICB2YXIgYXJnSW5kZXggPSAwO1xuICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoZm9ybWF0LnJlcGxhY2UoLyVzL2csIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGFyZ3NbYXJnSW5kZXgrK107XG4gICAgICB9KSk7XG4gICAgICBlcnJvci5uYW1lID0gJ0ludmFyaWFudCBWaW9sYXRpb24nO1xuICAgIH1cblxuICAgIGVycm9yLmZyYW1lc1RvUG9wID0gMTsgLy8gd2UgZG9uJ3QgY2FyZSBhYm91dCBpbnZhcmlhbnQncyBvd24gZnJhbWVcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGludmFyaWFudDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvaW52YXJpYW50LmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAdHlwZWNoZWNrc1xuICogXG4gKi9cblxuLyplc2xpbnQtZGlzYWJsZSBuby1zZWxmLWNvbXBhcmUgKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIGlubGluZWQgT2JqZWN0LmlzIHBvbHlmaWxsIHRvIGF2b2lkIHJlcXVpcmluZyBjb25zdW1lcnMgc2hpcCB0aGVpciBvd25cbiAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9pc1xuICovXG5mdW5jdGlvbiBpcyh4LCB5KSB7XG4gIC8vIFNhbWVWYWx1ZSBhbGdvcml0aG1cbiAgaWYgKHggPT09IHkpIHtcbiAgICAvLyBTdGVwcyAxLTUsIDctMTBcbiAgICAvLyBTdGVwcyA2LmItNi5lOiArMCAhPSAtMFxuICAgIC8vIEFkZGVkIHRoZSBub256ZXJvIHkgY2hlY2sgdG8gbWFrZSBGbG93IGhhcHB5LCBidXQgaXQgaXMgcmVkdW5kYW50XG4gICAgcmV0dXJuIHggIT09IDAgfHwgeSAhPT0gMCB8fCAxIC8geCA9PT0gMSAvIHk7XG4gIH0gZWxzZSB7XG4gICAgLy8gU3RlcCA2LmE6IE5hTiA9PSBOYU5cbiAgICByZXR1cm4geCAhPT0geCAmJiB5ICE9PSB5O1xuICB9XG59XG5cbi8qKlxuICogUGVyZm9ybXMgZXF1YWxpdHkgYnkgaXRlcmF0aW5nIHRocm91Z2gga2V5cyBvbiBhbiBvYmplY3QgYW5kIHJldHVybmluZyBmYWxzZVxuICogd2hlbiBhbnkga2V5IGhhcyB2YWx1ZXMgd2hpY2ggYXJlIG5vdCBzdHJpY3RseSBlcXVhbCBiZXR3ZWVuIHRoZSBhcmd1bWVudHMuXG4gKiBSZXR1cm5zIHRydWUgd2hlbiB0aGUgdmFsdWVzIG9mIGFsbCBrZXlzIGFyZSBzdHJpY3RseSBlcXVhbC5cbiAqL1xuZnVuY3Rpb24gc2hhbGxvd0VxdWFsKG9iakEsIG9iakIpIHtcbiAgaWYgKGlzKG9iakEsIG9iakIpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAodHlwZW9mIG9iakEgIT09ICdvYmplY3QnIHx8IG9iakEgPT09IG51bGwgfHwgdHlwZW9mIG9iakIgIT09ICdvYmplY3QnIHx8IG9iakIgPT09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIga2V5c0EgPSBPYmplY3Qua2V5cyhvYmpBKTtcbiAgdmFyIGtleXNCID0gT2JqZWN0LmtleXMob2JqQik7XG5cbiAgaWYgKGtleXNBLmxlbmd0aCAhPT0ga2V5c0IubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gVGVzdCBmb3IgQSdzIGtleXMgZGlmZmVyZW50IGZyb20gQi5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzQS5sZW5ndGg7IGkrKykge1xuICAgIGlmICghaGFzT3duUHJvcGVydHkuY2FsbChvYmpCLCBrZXlzQVtpXSkgfHwgIWlzKG9iakFba2V5c0FbaV1dLCBvYmpCW2tleXNBW2ldXSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzaGFsbG93RXF1YWw7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2ZianMvbGliL3NoYWxsb3dFcXVhbC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGVtcHR5RnVuY3Rpb24gPSByZXF1aXJlKCcuL2VtcHR5RnVuY3Rpb24nKTtcblxuLyoqXG4gKiBTaW1pbGFyIHRvIGludmFyaWFudCBidXQgb25seSBsb2dzIGEgd2FybmluZyBpZiB0aGUgY29uZGl0aW9uIGlzIG5vdCBtZXQuXG4gKiBUaGlzIGNhbiBiZSB1c2VkIHRvIGxvZyBpc3N1ZXMgaW4gZGV2ZWxvcG1lbnQgZW52aXJvbm1lbnRzIGluIGNyaXRpY2FsXG4gKiBwYXRocy4gUmVtb3ZpbmcgdGhlIGxvZ2dpbmcgY29kZSBmb3IgcHJvZHVjdGlvbiBlbnZpcm9ubWVudHMgd2lsbCBrZWVwIHRoZVxuICogc2FtZSBsb2dpYyBhbmQgZm9sbG93IHRoZSBzYW1lIGNvZGUgcGF0aHMuXG4gKi9cblxudmFyIHdhcm5pbmcgPSBlbXB0eUZ1bmN0aW9uO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgcHJpbnRXYXJuaW5nID0gZnVuY3Rpb24gcHJpbnRXYXJuaW5nKGZvcm1hdCkge1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgdmFyIGFyZ0luZGV4ID0gMDtcbiAgICB2YXIgbWVzc2FnZSA9ICdXYXJuaW5nOiAnICsgZm9ybWF0LnJlcGxhY2UoLyVzL2csIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBhcmdzW2FyZ0luZGV4KytdO1xuICAgIH0pO1xuICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IobWVzc2FnZSk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAvLyAtLS0gV2VsY29tZSB0byBkZWJ1Z2dpbmcgUmVhY3QgLS0tXG4gICAgICAvLyBUaGlzIGVycm9yIHdhcyB0aHJvd24gYXMgYSBjb252ZW5pZW5jZSBzbyB0aGF0IHlvdSBjYW4gdXNlIHRoaXMgc3RhY2tcbiAgICAgIC8vIHRvIGZpbmQgdGhlIGNhbGxzaXRlIHRoYXQgY2F1c2VkIHRoaXMgd2FybmluZyB0byBmaXJlLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgIH0gY2F0Y2ggKHgpIHt9XG4gIH07XG5cbiAgd2FybmluZyA9IGZ1bmN0aW9uIHdhcm5pbmcoY29uZGl0aW9uLCBmb3JtYXQpIHtcbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignYHdhcm5pbmcoY29uZGl0aW9uLCBmb3JtYXQsIC4uLmFyZ3MpYCByZXF1aXJlcyBhIHdhcm5pbmcgJyArICdtZXNzYWdlIGFyZ3VtZW50Jyk7XG4gICAgfVxuXG4gICAgaWYgKGZvcm1hdC5pbmRleE9mKCdGYWlsZWQgQ29tcG9zaXRlIHByb3BUeXBlOiAnKSA9PT0gMCkge1xuICAgICAgcmV0dXJuOyAvLyBJZ25vcmUgQ29tcG9zaXRlQ29tcG9uZW50IHByb3B0eXBlIGNoZWNrLlxuICAgIH1cblxuICAgIGlmICghY29uZGl0aW9uKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuMiA+IDIgPyBfbGVuMiAtIDIgOiAwKSwgX2tleTIgPSAyOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgIGFyZ3NbX2tleTIgLSAyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICB9XG5cbiAgICAgIHByaW50V2FybmluZy5hcHBseSh1bmRlZmluZWQsIFtmb3JtYXRdLmNvbmNhdChhcmdzKSk7XG4gICAgfVxuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHdhcm5pbmc7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2ZianMvbGliL3dhcm5pbmcuanMiLCIvKiFcbiAqICBob3dsZXIuanMgdjIuMC41XG4gKiAgaG93bGVyanMuY29tXG4gKlxuICogIChjKSAyMDEzLTIwMTcsIEphbWVzIFNpbXBzb24gb2YgR29sZEZpcmUgU3R1ZGlvc1xuICogIGdvbGRmaXJlc3R1ZGlvcy5jb21cbiAqXG4gKiAgTUlUIExpY2Vuc2VcbiAqL1xuXG4oZnVuY3Rpb24oKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8qKiBHbG9iYWwgTWV0aG9kcyAqKi9cbiAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAvKipcbiAgICogQ3JlYXRlIHRoZSBnbG9iYWwgY29udHJvbGxlci4gQWxsIGNvbnRhaW5lZCBtZXRob2RzIGFuZCBwcm9wZXJ0aWVzIGFwcGx5XG4gICAqIHRvIGFsbCBzb3VuZHMgdGhhdCBhcmUgY3VycmVudGx5IHBsYXlpbmcgb3Igd2lsbCBiZSBpbiB0aGUgZnV0dXJlLlxuICAgKi9cbiAgdmFyIEhvd2xlckdsb2JhbCA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuaW5pdCgpO1xuICB9O1xuICBIb3dsZXJHbG9iYWwucHJvdG90eXBlID0ge1xuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemUgdGhlIGdsb2JhbCBIb3dsZXIgb2JqZWN0LlxuICAgICAqIEByZXR1cm4ge0hvd2xlcn1cbiAgICAgKi9cbiAgICBpbml0OiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcyB8fCBIb3dsZXI7XG5cbiAgICAgIC8vIENyZWF0ZSBhIGdsb2JhbCBJRCBjb3VudGVyLlxuICAgICAgc2VsZi5fY291bnRlciA9IDEwMDA7XG5cbiAgICAgIC8vIEludGVybmFsIHByb3BlcnRpZXMuXG4gICAgICBzZWxmLl9jb2RlY3MgPSB7fTtcbiAgICAgIHNlbGYuX2hvd2xzID0gW107XG4gICAgICBzZWxmLl9tdXRlZCA9IGZhbHNlO1xuICAgICAgc2VsZi5fdm9sdW1lID0gMTtcbiAgICAgIHNlbGYuX2NhblBsYXlFdmVudCA9ICdjYW5wbGF5dGhyb3VnaCc7XG4gICAgICBzZWxmLl9uYXZpZ2F0b3IgPSAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93Lm5hdmlnYXRvcikgPyB3aW5kb3cubmF2aWdhdG9yIDogbnVsbDtcblxuICAgICAgLy8gUHVibGljIHByb3BlcnRpZXMuXG4gICAgICBzZWxmLm1hc3RlckdhaW4gPSBudWxsO1xuICAgICAgc2VsZi5ub0F1ZGlvID0gZmFsc2U7XG4gICAgICBzZWxmLnVzaW5nV2ViQXVkaW8gPSB0cnVlO1xuICAgICAgc2VsZi5hdXRvU3VzcGVuZCA9IHRydWU7XG4gICAgICBzZWxmLmN0eCA9IG51bGw7XG5cbiAgICAgIC8vIFNldCB0byBmYWxzZSB0byBkaXNhYmxlIHRoZSBhdXRvIGlPUyBlbmFibGVyLlxuICAgICAgc2VsZi5tb2JpbGVBdXRvRW5hYmxlID0gdHJ1ZTtcblxuICAgICAgLy8gU2V0dXAgdGhlIHZhcmlvdXMgc3RhdGUgdmFsdWVzIGZvciBnbG9iYWwgdHJhY2tpbmcuXG4gICAgICBzZWxmLl9zZXR1cCgpO1xuXG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0L3NldCB0aGUgZ2xvYmFsIHZvbHVtZSBmb3IgYWxsIHNvdW5kcy5cbiAgICAgKiBAcGFyYW0gIHtGbG9hdH0gdm9sIFZvbHVtZSBmcm9tIDAuMCB0byAxLjAuXG4gICAgICogQHJldHVybiB7SG93bGVyL0Zsb2F0fSAgICAgUmV0dXJucyBzZWxmIG9yIGN1cnJlbnQgdm9sdW1lLlxuICAgICAqL1xuICAgIHZvbHVtZTogZnVuY3Rpb24odm9sKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXMgfHwgSG93bGVyO1xuICAgICAgdm9sID0gcGFyc2VGbG9hdCh2b2wpO1xuXG4gICAgICAvLyBJZiB3ZSBkb24ndCBoYXZlIGFuIEF1ZGlvQ29udGV4dCBjcmVhdGVkIHlldCwgcnVuIHRoZSBzZXR1cC5cbiAgICAgIGlmICghc2VsZi5jdHgpIHtcbiAgICAgICAgc2V0dXBBdWRpb0NvbnRleHQoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiB2b2wgIT09ICd1bmRlZmluZWQnICYmIHZvbCA+PSAwICYmIHZvbCA8PSAxKSB7XG4gICAgICAgIHNlbGYuX3ZvbHVtZSA9IHZvbDtcblxuICAgICAgICAvLyBEb24ndCB1cGRhdGUgYW55IG9mIHRoZSBub2RlcyBpZiB3ZSBhcmUgbXV0ZWQuXG4gICAgICAgIGlmIChzZWxmLl9tdXRlZCkge1xuICAgICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gV2hlbiB1c2luZyBXZWIgQXVkaW8sIHdlIGp1c3QgbmVlZCB0byBhZGp1c3QgdGhlIG1hc3RlciBnYWluLlxuICAgICAgICBpZiAoc2VsZi51c2luZ1dlYkF1ZGlvKSB7XG4gICAgICAgICAgc2VsZi5tYXN0ZXJHYWluLmdhaW4udmFsdWUgPSB2b2w7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBMb29wIHRocm91Z2ggYW5kIGNoYW5nZSB2b2x1bWUgZm9yIGFsbCBIVE1MNSBhdWRpbyBub2Rlcy5cbiAgICAgICAgZm9yICh2YXIgaT0wOyBpPHNlbGYuX2hvd2xzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKCFzZWxmLl9ob3dsc1tpXS5fd2ViQXVkaW8pIHtcbiAgICAgICAgICAgIC8vIEdldCBhbGwgb2YgdGhlIHNvdW5kcyBpbiB0aGlzIEhvd2wgZ3JvdXAuXG4gICAgICAgICAgICB2YXIgaWRzID0gc2VsZi5faG93bHNbaV0uX2dldFNvdW5kSWRzKCk7XG5cbiAgICAgICAgICAgIC8vIExvb3AgdGhyb3VnaCBhbGwgc291bmRzIGFuZCBjaGFuZ2UgdGhlIHZvbHVtZXMuXG4gICAgICAgICAgICBmb3IgKHZhciBqPTA7IGo8aWRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgIHZhciBzb3VuZCA9IHNlbGYuX2hvd2xzW2ldLl9zb3VuZEJ5SWQoaWRzW2pdKTtcblxuICAgICAgICAgICAgICBpZiAoc291bmQgJiYgc291bmQuX25vZGUpIHtcbiAgICAgICAgICAgICAgICBzb3VuZC5fbm9kZS52b2x1bWUgPSBzb3VuZC5fdm9sdW1lICogdm9sO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmLl92b2x1bWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEhhbmRsZSBtdXRpbmcgYW5kIHVubXV0aW5nIGdsb2JhbGx5LlxuICAgICAqIEBwYXJhbSAge0Jvb2xlYW59IG11dGVkIElzIG11dGVkIG9yIG5vdC5cbiAgICAgKi9cbiAgICBtdXRlOiBmdW5jdGlvbihtdXRlZCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzIHx8IEhvd2xlcjtcblxuICAgICAgLy8gSWYgd2UgZG9uJ3QgaGF2ZSBhbiBBdWRpb0NvbnRleHQgY3JlYXRlZCB5ZXQsIHJ1biB0aGUgc2V0dXAuXG4gICAgICBpZiAoIXNlbGYuY3R4KSB7XG4gICAgICAgIHNldHVwQXVkaW9Db250ZXh0KCk7XG4gICAgICB9XG5cbiAgICAgIHNlbGYuX211dGVkID0gbXV0ZWQ7XG5cbiAgICAgIC8vIFdpdGggV2ViIEF1ZGlvLCB3ZSBqdXN0IG5lZWQgdG8gbXV0ZSB0aGUgbWFzdGVyIGdhaW4uXG4gICAgICBpZiAoc2VsZi51c2luZ1dlYkF1ZGlvKSB7XG4gICAgICAgIHNlbGYubWFzdGVyR2Fpbi5nYWluLnZhbHVlID0gbXV0ZWQgPyAwIDogc2VsZi5fdm9sdW1lO1xuICAgICAgfVxuXG4gICAgICAvLyBMb29wIHRocm91Z2ggYW5kIG11dGUgYWxsIEhUTUw1IEF1ZGlvIG5vZGVzLlxuICAgICAgZm9yICh2YXIgaT0wOyBpPHNlbGYuX2hvd2xzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICghc2VsZi5faG93bHNbaV0uX3dlYkF1ZGlvKSB7XG4gICAgICAgICAgLy8gR2V0IGFsbCBvZiB0aGUgc291bmRzIGluIHRoaXMgSG93bCBncm91cC5cbiAgICAgICAgICB2YXIgaWRzID0gc2VsZi5faG93bHNbaV0uX2dldFNvdW5kSWRzKCk7XG5cbiAgICAgICAgICAvLyBMb29wIHRocm91Z2ggYWxsIHNvdW5kcyBhbmQgbWFyayB0aGUgYXVkaW8gbm9kZSBhcyBtdXRlZC5cbiAgICAgICAgICBmb3IgKHZhciBqPTA7IGo8aWRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICB2YXIgc291bmQgPSBzZWxmLl9ob3dsc1tpXS5fc291bmRCeUlkKGlkc1tqXSk7XG5cbiAgICAgICAgICAgIGlmIChzb3VuZCAmJiBzb3VuZC5fbm9kZSkge1xuICAgICAgICAgICAgICBzb3VuZC5fbm9kZS5tdXRlZCA9IChtdXRlZCkgPyB0cnVlIDogc291bmQuX211dGVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVW5sb2FkIGFuZCBkZXN0cm95IGFsbCBjdXJyZW50bHkgbG9hZGVkIEhvd2wgb2JqZWN0cy5cbiAgICAgKiBAcmV0dXJuIHtIb3dsZXJ9XG4gICAgICovXG4gICAgdW5sb2FkOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcyB8fCBIb3dsZXI7XG5cbiAgICAgIGZvciAodmFyIGk9c2VsZi5faG93bHMubGVuZ3RoLTE7IGk+PTA7IGktLSkge1xuICAgICAgICBzZWxmLl9ob3dsc1tpXS51bmxvYWQoKTtcbiAgICAgIH1cblxuICAgICAgLy8gQ3JlYXRlIGEgbmV3IEF1ZGlvQ29udGV4dCB0byBtYWtlIHN1cmUgaXQgaXMgZnVsbHkgcmVzZXQuXG4gICAgICBpZiAoc2VsZi51c2luZ1dlYkF1ZGlvICYmIHNlbGYuY3R4ICYmIHR5cGVvZiBzZWxmLmN0eC5jbG9zZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgc2VsZi5jdHguY2xvc2UoKTtcbiAgICAgICAgc2VsZi5jdHggPSBudWxsO1xuICAgICAgICBzZXR1cEF1ZGlvQ29udGV4dCgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgZm9yIGNvZGVjIHN1cHBvcnQgb2Ygc3BlY2lmaWMgZXh0ZW5zaW9uLlxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gZXh0IEF1ZGlvIGZpbGUgZXh0ZW50aW9uLlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICovXG4gICAgY29kZWNzOiBmdW5jdGlvbihleHQpIHtcbiAgICAgIHJldHVybiAodGhpcyB8fCBIb3dsZXIpLl9jb2RlY3NbZXh0LnJlcGxhY2UoL154LS8sICcnKV07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHVwIHZhcmlvdXMgc3RhdGUgdmFsdWVzIGZvciBnbG9iYWwgdHJhY2tpbmcuXG4gICAgICogQHJldHVybiB7SG93bGVyfVxuICAgICAqL1xuICAgIF9zZXR1cDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXMgfHwgSG93bGVyO1xuXG4gICAgICAvLyBLZWVwcyB0cmFjayBvZiB0aGUgc3VzcGVuZC9yZXN1bWUgc3RhdGUgb2YgdGhlIEF1ZGlvQ29udGV4dC5cbiAgICAgIHNlbGYuc3RhdGUgPSBzZWxmLmN0eCA/IHNlbGYuY3R4LnN0YXRlIHx8ICdydW5uaW5nJyA6ICdydW5uaW5nJztcblxuICAgICAgLy8gQXV0b21hdGljYWxseSBiZWdpbiB0aGUgMzAtc2Vjb25kIHN1c3BlbmQgcHJvY2Vzc1xuICAgICAgc2VsZi5fYXV0b1N1c3BlbmQoKTtcblxuICAgICAgLy8gQ2hlY2sgaWYgYXVkaW8gaXMgYXZhaWxhYmxlLlxuICAgICAgaWYgKCFzZWxmLnVzaW5nV2ViQXVkaW8pIHtcbiAgICAgICAgLy8gTm8gYXVkaW8gaXMgYXZhaWxhYmxlIG9uIHRoaXMgc3lzdGVtIGlmIG5vQXVkaW8gaXMgc2V0IHRvIHRydWUuXG4gICAgICAgIGlmICh0eXBlb2YgQXVkaW8gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciB0ZXN0ID0gbmV3IEF1ZGlvKCk7XG5cbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoZSBjYW5wbGF5dGhyb3VnaCBldmVudCBpcyBhdmFpbGFibGUuXG4gICAgICAgICAgICBpZiAodHlwZW9mIHRlc3Qub25jYW5wbGF5dGhyb3VnaCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgc2VsZi5fY2FuUGxheUV2ZW50ID0gJ2NhbnBsYXknO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICAgICAgc2VsZi5ub0F1ZGlvID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2VsZi5ub0F1ZGlvID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUZXN0IHRvIG1ha2Ugc3VyZSBhdWRpbyBpc24ndCBkaXNhYmxlZCBpbiBJbnRlcm5ldCBFeHBsb3Jlci5cbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciB0ZXN0ID0gbmV3IEF1ZGlvKCk7XG4gICAgICAgIGlmICh0ZXN0Lm11dGVkKSB7XG4gICAgICAgICAgc2VsZi5ub0F1ZGlvID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZSkge31cblxuICAgICAgLy8gQ2hlY2sgZm9yIHN1cHBvcnRlZCBjb2RlY3MuXG4gICAgICBpZiAoIXNlbGYubm9BdWRpbykge1xuICAgICAgICBzZWxmLl9zZXR1cENvZGVjcygpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgZm9yIGJyb3dzZXIgc3VwcG9ydCBmb3IgdmFyaW91cyBjb2RlY3MgYW5kIGNhY2hlIHRoZSByZXN1bHRzLlxuICAgICAqIEByZXR1cm4ge0hvd2xlcn1cbiAgICAgKi9cbiAgICBfc2V0dXBDb2RlY3M6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzIHx8IEhvd2xlcjtcbiAgICAgIHZhciBhdWRpb1Rlc3QgPSBudWxsO1xuXG4gICAgICAvLyBNdXN0IHdyYXAgaW4gYSB0cnkvY2F0Y2ggYmVjYXVzZSBJRTExIGluIHNlcnZlciBtb2RlIHRocm93cyBhbiBlcnJvci5cbiAgICAgIHRyeSB7XG4gICAgICAgIGF1ZGlvVGVzdCA9ICh0eXBlb2YgQXVkaW8gIT09ICd1bmRlZmluZWQnKSA/IG5ldyBBdWRpbygpIDogbnVsbDtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgIH1cblxuICAgICAgaWYgKCFhdWRpb1Rlc3QgfHwgdHlwZW9mIGF1ZGlvVGVzdC5jYW5QbGF5VHlwZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgIH1cblxuICAgICAgdmFyIG1wZWdUZXN0ID0gYXVkaW9UZXN0LmNhblBsYXlUeXBlKCdhdWRpby9tcGVnOycpLnJlcGxhY2UoL15ubyQvLCAnJyk7XG5cbiAgICAgIC8vIE9wZXJhIHZlcnNpb24gPDMzIGhhcyBtaXhlZCBNUDMgc3VwcG9ydCwgc28gd2UgbmVlZCB0byBjaGVjayBmb3IgYW5kIGJsb2NrIGl0LlxuICAgICAgdmFyIGNoZWNrT3BlcmEgPSBzZWxmLl9uYXZpZ2F0b3IgJiYgc2VsZi5fbmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvT1BSXFwvKFswLTZdLikvZyk7XG4gICAgICB2YXIgaXNPbGRPcGVyYSA9IChjaGVja09wZXJhICYmIHBhcnNlSW50KGNoZWNrT3BlcmFbMF0uc3BsaXQoJy8nKVsxXSwgMTApIDwgMzMpO1xuXG4gICAgICBzZWxmLl9jb2RlY3MgPSB7XG4gICAgICAgIG1wMzogISEoIWlzT2xkT3BlcmEgJiYgKG1wZWdUZXN0IHx8IGF1ZGlvVGVzdC5jYW5QbGF5VHlwZSgnYXVkaW8vbXAzOycpLnJlcGxhY2UoL15ubyQvLCAnJykpKSxcbiAgICAgICAgbXBlZzogISFtcGVnVGVzdCxcbiAgICAgICAgb3B1czogISFhdWRpb1Rlc3QuY2FuUGxheVR5cGUoJ2F1ZGlvL29nZzsgY29kZWNzPVwib3B1c1wiJykucmVwbGFjZSgvXm5vJC8sICcnKSxcbiAgICAgICAgb2dnOiAhIWF1ZGlvVGVzdC5jYW5QbGF5VHlwZSgnYXVkaW8vb2dnOyBjb2RlY3M9XCJ2b3JiaXNcIicpLnJlcGxhY2UoL15ubyQvLCAnJyksXG4gICAgICAgIG9nYTogISFhdWRpb1Rlc3QuY2FuUGxheVR5cGUoJ2F1ZGlvL29nZzsgY29kZWNzPVwidm9yYmlzXCInKS5yZXBsYWNlKC9ebm8kLywgJycpLFxuICAgICAgICB3YXY6ICEhYXVkaW9UZXN0LmNhblBsYXlUeXBlKCdhdWRpby93YXY7IGNvZGVjcz1cIjFcIicpLnJlcGxhY2UoL15ubyQvLCAnJyksXG4gICAgICAgIGFhYzogISFhdWRpb1Rlc3QuY2FuUGxheVR5cGUoJ2F1ZGlvL2FhYzsnKS5yZXBsYWNlKC9ebm8kLywgJycpLFxuICAgICAgICBjYWY6ICEhYXVkaW9UZXN0LmNhblBsYXlUeXBlKCdhdWRpby94LWNhZjsnKS5yZXBsYWNlKC9ebm8kLywgJycpLFxuICAgICAgICBtNGE6ICEhKGF1ZGlvVGVzdC5jYW5QbGF5VHlwZSgnYXVkaW8veC1tNGE7JykgfHwgYXVkaW9UZXN0LmNhblBsYXlUeXBlKCdhdWRpby9tNGE7JykgfHwgYXVkaW9UZXN0LmNhblBsYXlUeXBlKCdhdWRpby9hYWM7JykpLnJlcGxhY2UoL15ubyQvLCAnJyksXG4gICAgICAgIG1wNDogISEoYXVkaW9UZXN0LmNhblBsYXlUeXBlKCdhdWRpby94LW1wNDsnKSB8fCBhdWRpb1Rlc3QuY2FuUGxheVR5cGUoJ2F1ZGlvL21wNDsnKSB8fCBhdWRpb1Rlc3QuY2FuUGxheVR5cGUoJ2F1ZGlvL2FhYzsnKSkucmVwbGFjZSgvXm5vJC8sICcnKSxcbiAgICAgICAgd2ViYTogISFhdWRpb1Rlc3QuY2FuUGxheVR5cGUoJ2F1ZGlvL3dlYm07IGNvZGVjcz1cInZvcmJpc1wiJykucmVwbGFjZSgvXm5vJC8sICcnKSxcbiAgICAgICAgd2VibTogISFhdWRpb1Rlc3QuY2FuUGxheVR5cGUoJ2F1ZGlvL3dlYm07IGNvZGVjcz1cInZvcmJpc1wiJykucmVwbGFjZSgvXm5vJC8sICcnKSxcbiAgICAgICAgZG9sYnk6ICEhYXVkaW9UZXN0LmNhblBsYXlUeXBlKCdhdWRpby9tcDQ7IGNvZGVjcz1cImVjLTNcIicpLnJlcGxhY2UoL15ubyQvLCAnJyksXG4gICAgICAgIGZsYWM6ICEhKGF1ZGlvVGVzdC5jYW5QbGF5VHlwZSgnYXVkaW8veC1mbGFjOycpIHx8IGF1ZGlvVGVzdC5jYW5QbGF5VHlwZSgnYXVkaW8vZmxhYzsnKSkucmVwbGFjZSgvXm5vJC8sICcnKVxuICAgICAgfTtcblxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1vYmlsZSBicm93c2VycyB3aWxsIG9ubHkgYWxsb3cgYXVkaW8gdG8gYmUgcGxheWVkIGFmdGVyIGEgdXNlciBpbnRlcmFjdGlvbi5cbiAgICAgKiBBdHRlbXB0IHRvIGF1dG9tYXRpY2FsbHkgdW5sb2NrIGF1ZGlvIG9uIHRoZSBmaXJzdCB1c2VyIGludGVyYWN0aW9uLlxuICAgICAqIENvbmNlcHQgZnJvbTogaHR0cDovL3BhdWxiYWthdXMuY29tL3R1dG9yaWFscy9odG1sNS93ZWItYXVkaW8tb24taW9zL1xuICAgICAqIEByZXR1cm4ge0hvd2xlcn1cbiAgICAgKi9cbiAgICBfZW5hYmxlTW9iaWxlQXVkaW86IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzIHx8IEhvd2xlcjtcblxuICAgICAgLy8gT25seSBydW4gdGhpcyBvbiBtb2JpbGUgZGV2aWNlcyBpZiBhdWRpbyBpc24ndCBhbHJlYWR5IGVhbmJsZWQuXG4gICAgICB2YXIgaXNNb2JpbGUgPSAvaVBob25lfGlQYWR8aVBvZHxBbmRyb2lkfEJsYWNrQmVycnl8QkIxMHxTaWxrfE1vYmkvaS50ZXN0KHNlbGYuX25hdmlnYXRvciAmJiBzZWxmLl9uYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgICAgIHZhciBpc1RvdWNoID0gISEoKCdvbnRvdWNoZW5kJyBpbiB3aW5kb3cpIHx8IChzZWxmLl9uYXZpZ2F0b3IgJiYgc2VsZi5fbmF2aWdhdG9yLm1heFRvdWNoUG9pbnRzID4gMCkgfHwgKHNlbGYuX25hdmlnYXRvciAmJiBzZWxmLl9uYXZpZ2F0b3IubXNNYXhUb3VjaFBvaW50cyA+IDApKTtcbiAgICAgIGlmIChzZWxmLl9tb2JpbGVFbmFibGVkIHx8ICFzZWxmLmN0eCB8fCAoIWlzTW9iaWxlICYmICFpc1RvdWNoKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHNlbGYuX21vYmlsZUVuYWJsZWQgPSBmYWxzZTtcblxuICAgICAgLy8gU29tZSBtb2JpbGUgZGV2aWNlcy9wbGF0Zm9ybXMgaGF2ZSBkaXN0b3J0aW9uIGlzc3VlcyB3aGVuIG9wZW5pbmcvY2xvc2luZyB0YWJzIGFuZC9vciB3ZWIgdmlld3MuXG4gICAgICAvLyBCdWdzIGluIHRoZSBicm93c2VyIChlc3BlY2lhbGx5IE1vYmlsZSBTYWZhcmkpIGNhbiBjYXVzZSB0aGUgc2FtcGxlUmF0ZSB0byBjaGFuZ2UgZnJvbSA0NDEwMCB0byA0ODAwMC5cbiAgICAgIC8vIEJ5IGNhbGxpbmcgSG93bGVyLnVubG9hZCgpLCB3ZSBjcmVhdGUgYSBuZXcgQXVkaW9Db250ZXh0IHdpdGggdGhlIGNvcnJlY3Qgc2FtcGxlUmF0ZS5cbiAgICAgIGlmICghc2VsZi5fbW9iaWxlVW5sb2FkZWQgJiYgc2VsZi5jdHguc2FtcGxlUmF0ZSAhPT0gNDQxMDApIHtcbiAgICAgICAgc2VsZi5fbW9iaWxlVW5sb2FkZWQgPSB0cnVlO1xuICAgICAgICBzZWxmLnVubG9hZCgpO1xuICAgICAgfVxuXG4gICAgICAvLyBTY3JhdGNoIGJ1ZmZlciBmb3IgZW5hYmxpbmcgaU9TIHRvIGRpc3Bvc2Ugb2Ygd2ViIGF1ZGlvIGJ1ZmZlcnMgY29ycmVjdGx5LCBhcyBwZXI6XG4gICAgICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzI0MTE5Njg0XG4gICAgICBzZWxmLl9zY3JhdGNoQnVmZmVyID0gc2VsZi5jdHguY3JlYXRlQnVmZmVyKDEsIDEsIDIyMDUwKTtcblxuICAgICAgLy8gQ2FsbCB0aGlzIG1ldGhvZCBvbiB0b3VjaCBzdGFydCB0byBjcmVhdGUgYW5kIHBsYXkgYSBidWZmZXIsXG4gICAgICAvLyB0aGVuIGNoZWNrIGlmIHRoZSBhdWRpbyBhY3R1YWxseSBwbGF5ZWQgdG8gZGV0ZXJtaW5lIGlmXG4gICAgICAvLyBhdWRpbyBoYXMgbm93IGJlZW4gdW5sb2NrZWQgb24gaU9TLCBBbmRyb2lkLCBldGMuXG4gICAgICB2YXIgdW5sb2NrID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIEZpeCBBbmRyb2lkIGNhbiBub3QgcGxheSBpbiBzdXNwZW5kIHN0YXRlLlxuICAgICAgICBIb3dsZXIuX2F1dG9SZXN1bWUoKTtcblxuICAgICAgICAvLyBDcmVhdGUgYW4gZW1wdHkgYnVmZmVyLlxuICAgICAgICB2YXIgc291cmNlID0gc2VsZi5jdHguY3JlYXRlQnVmZmVyU291cmNlKCk7XG4gICAgICAgIHNvdXJjZS5idWZmZXIgPSBzZWxmLl9zY3JhdGNoQnVmZmVyO1xuICAgICAgICBzb3VyY2UuY29ubmVjdChzZWxmLmN0eC5kZXN0aW5hdGlvbik7XG5cbiAgICAgICAgLy8gUGxheSB0aGUgZW1wdHkgYnVmZmVyLlxuICAgICAgICBpZiAodHlwZW9mIHNvdXJjZS5zdGFydCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICBzb3VyY2Uubm90ZU9uKDApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNvdXJjZS5zdGFydCgwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENhbGxpbmcgcmVzdW1lKCkgb24gYSBzdGFjayBpbml0aWF0ZWQgYnkgdXNlciBnZXN0dXJlIGlzIHdoYXQgYWN0dWFsbHkgdW5sb2NrcyB0aGUgYXVkaW8gb24gQW5kcm9pZCBDaHJvbWUgPj0gNTUuXG4gICAgICAgIGlmICh0eXBlb2Ygc2VsZi5jdHgucmVzdW1lID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgc2VsZi5jdHgucmVzdW1lKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTZXR1cCBhIHRpbWVvdXQgdG8gY2hlY2sgdGhhdCB3ZSBhcmUgdW5sb2NrZWQgb24gdGhlIG5leHQgZXZlbnQgbG9vcC5cbiAgICAgICAgc291cmNlLm9uZW5kZWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICBzb3VyY2UuZGlzY29ubmVjdCgwKTtcblxuICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgdW5sb2NrZWQgc3RhdGUgYW5kIHByZXZlbnQgdGhpcyBjaGVjayBmcm9tIGhhcHBlbmluZyBhZ2Fpbi5cbiAgICAgICAgICBzZWxmLl9tb2JpbGVFbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgICBzZWxmLm1vYmlsZUF1dG9FbmFibGUgPSBmYWxzZTtcblxuICAgICAgICAgIC8vIFJlbW92ZSB0aGUgdG91Y2ggc3RhcnQgbGlzdGVuZXIuXG4gICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIHVubG9jaywgdHJ1ZSk7XG4gICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCB1bmxvY2ssIHRydWUpO1xuICAgICAgICB9O1xuICAgICAgfTtcblxuICAgICAgLy8gU2V0dXAgYSB0b3VjaCBzdGFydCBsaXN0ZW5lciB0byBhdHRlbXB0IGFuIHVubG9jayBpbi5cbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCB1bmxvY2ssIHRydWUpO1xuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCB1bmxvY2ssIHRydWUpO1xuXG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQXV0b21hdGljYWxseSBzdXNwZW5kIHRoZSBXZWIgQXVkaW8gQXVkaW9Db250ZXh0IGFmdGVyIG5vIHNvdW5kIGhhcyBwbGF5ZWQgZm9yIDMwIHNlY29uZHMuXG4gICAgICogVGhpcyBzYXZlcyBwcm9jZXNzaW5nL2VuZXJneSBhbmQgZml4ZXMgdmFyaW91cyBicm93c2VyLXNwZWNpZmljIGJ1Z3Mgd2l0aCBhdWRpbyBnZXR0aW5nIHN0dWNrLlxuICAgICAqIEByZXR1cm4ge0hvd2xlcn1cbiAgICAgKi9cbiAgICBfYXV0b1N1c3BlbmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICBpZiAoIXNlbGYuYXV0b1N1c3BlbmQgfHwgIXNlbGYuY3R4IHx8IHR5cGVvZiBzZWxmLmN0eC5zdXNwZW5kID09PSAndW5kZWZpbmVkJyB8fCAhSG93bGVyLnVzaW5nV2ViQXVkaW8pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBDaGVjayBpZiBhbnkgc291bmRzIGFyZSBwbGF5aW5nLlxuICAgICAgZm9yICh2YXIgaT0wOyBpPHNlbGYuX2hvd2xzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChzZWxmLl9ob3dsc1tpXS5fd2ViQXVkaW8pIHtcbiAgICAgICAgICBmb3IgKHZhciBqPTA7IGo8c2VsZi5faG93bHNbaV0uX3NvdW5kcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgaWYgKCFzZWxmLl9ob3dsc1tpXS5fc291bmRzW2pdLl9wYXVzZWQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChzZWxmLl9zdXNwZW5kVGltZXIpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHNlbGYuX3N1c3BlbmRUaW1lcik7XG4gICAgICB9XG5cbiAgICAgIC8vIElmIG5vIHNvdW5kIGhhcyBwbGF5ZWQgYWZ0ZXIgMzAgc2Vjb25kcywgc3VzcGVuZCB0aGUgY29udGV4dC5cbiAgICAgIHNlbGYuX3N1c3BlbmRUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghc2VsZi5hdXRvU3VzcGVuZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHNlbGYuX3N1c3BlbmRUaW1lciA9IG51bGw7XG4gICAgICAgIHNlbGYuc3RhdGUgPSAnc3VzcGVuZGluZyc7XG4gICAgICAgIHNlbGYuY3R4LnN1c3BlbmQoKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHNlbGYuc3RhdGUgPSAnc3VzcGVuZGVkJztcblxuICAgICAgICAgIGlmIChzZWxmLl9yZXN1bWVBZnRlclN1c3BlbmQpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBzZWxmLl9yZXN1bWVBZnRlclN1c3BlbmQ7XG4gICAgICAgICAgICBzZWxmLl9hdXRvUmVzdW1lKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0sIDMwMDAwKTtcblxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEF1dG9tYXRpY2FsbHkgcmVzdW1lIHRoZSBXZWIgQXVkaW8gQXVkaW9Db250ZXh0IHdoZW4gYSBuZXcgc291bmQgaXMgcGxheWVkLlxuICAgICAqIEByZXR1cm4ge0hvd2xlcn1cbiAgICAgKi9cbiAgICBfYXV0b1Jlc3VtZTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgIGlmICghc2VsZi5jdHggfHwgdHlwZW9mIHNlbGYuY3R4LnJlc3VtZSA9PT0gJ3VuZGVmaW5lZCcgfHwgIUhvd2xlci51c2luZ1dlYkF1ZGlvKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHNlbGYuc3RhdGUgPT09ICdydW5uaW5nJyAmJiBzZWxmLl9zdXNwZW5kVGltZXIpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHNlbGYuX3N1c3BlbmRUaW1lcik7XG4gICAgICAgIHNlbGYuX3N1c3BlbmRUaW1lciA9IG51bGw7XG4gICAgICB9IGVsc2UgaWYgKHNlbGYuc3RhdGUgPT09ICdzdXNwZW5kZWQnKSB7XG4gICAgICAgIHNlbGYuY3R4LnJlc3VtZSgpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgc2VsZi5zdGF0ZSA9ICdydW5uaW5nJztcblxuICAgICAgICAgIC8vIEVtaXQgdG8gYWxsIEhvd2xzIHRoYXQgdGhlIGF1ZGlvIGhhcyByZXN1bWVkLlxuICAgICAgICAgIGZvciAodmFyIGk9MDsgaTxzZWxmLl9ob3dscy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgc2VsZi5faG93bHNbaV0uX2VtaXQoJ3Jlc3VtZScpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHNlbGYuX3N1c3BlbmRUaW1lcikge1xuICAgICAgICAgIGNsZWFyVGltZW91dChzZWxmLl9zdXNwZW5kVGltZXIpO1xuICAgICAgICAgIHNlbGYuX3N1c3BlbmRUaW1lciA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoc2VsZi5zdGF0ZSA9PT0gJ3N1c3BlbmRpbmcnKSB7XG4gICAgICAgIHNlbGYuX3Jlc3VtZUFmdGVyU3VzcGVuZCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cbiAgfTtcblxuICAvLyBTZXR1cCB0aGUgZ2xvYmFsIGF1ZGlvIGNvbnRyb2xsZXIuXG4gIHZhciBIb3dsZXIgPSBuZXcgSG93bGVyR2xvYmFsKCk7XG5cbiAgLyoqIEdyb3VwIE1ldGhvZHMgKiovXG4gIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBhdWRpbyBncm91cCBjb250cm9sbGVyLlxuICAgKiBAcGFyYW0ge09iamVjdH0gbyBQYXNzZWQgaW4gcHJvcGVydGllcyBmb3IgdGhpcyBncm91cC5cbiAgICovXG4gIHZhciBIb3dsID0gZnVuY3Rpb24obykge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIC8vIFRocm93IGFuIGVycm9yIGlmIG5vIHNvdXJjZSBpcyBwcm92aWRlZC5cbiAgICBpZiAoIW8uc3JjIHx8IG8uc3JjLmxlbmd0aCA9PT0gMCkge1xuICAgICAgY29uc29sZS5lcnJvcignQW4gYXJyYXkgb2Ygc291cmNlIGZpbGVzIG11c3QgYmUgcGFzc2VkIHdpdGggYW55IG5ldyBIb3dsLicpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHNlbGYuaW5pdChvKTtcbiAgfTtcbiAgSG93bC5wcm90b3R5cGUgPSB7XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZSBhIG5ldyBIb3dsIGdyb3VwIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IG8gUGFzc2VkIGluIHByb3BlcnRpZXMgZm9yIHRoaXMgZ3JvdXAuXG4gICAgICogQHJldHVybiB7SG93bH1cbiAgICAgKi9cbiAgICBpbml0OiBmdW5jdGlvbihvKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgIC8vIElmIHdlIGRvbid0IGhhdmUgYW4gQXVkaW9Db250ZXh0IGNyZWF0ZWQgeWV0LCBydW4gdGhlIHNldHVwLlxuICAgICAgaWYgKCFIb3dsZXIuY3R4KSB7XG4gICAgICAgIHNldHVwQXVkaW9Db250ZXh0KCk7XG4gICAgICB9XG5cbiAgICAgIC8vIFNldHVwIHVzZXItZGVmaW5lZCBkZWZhdWx0IHByb3BlcnRpZXMuXG4gICAgICBzZWxmLl9hdXRvcGxheSA9IG8uYXV0b3BsYXkgfHwgZmFsc2U7XG4gICAgICBzZWxmLl9mb3JtYXQgPSAodHlwZW9mIG8uZm9ybWF0ICE9PSAnc3RyaW5nJykgPyBvLmZvcm1hdCA6IFtvLmZvcm1hdF07XG4gICAgICBzZWxmLl9odG1sNSA9IG8uaHRtbDUgfHwgZmFsc2U7XG4gICAgICBzZWxmLl9tdXRlZCA9IG8ubXV0ZSB8fCBmYWxzZTtcbiAgICAgIHNlbGYuX2xvb3AgPSBvLmxvb3AgfHwgZmFsc2U7XG4gICAgICBzZWxmLl9wb29sID0gby5wb29sIHx8IDU7XG4gICAgICBzZWxmLl9wcmVsb2FkID0gKHR5cGVvZiBvLnByZWxvYWQgPT09ICdib29sZWFuJykgPyBvLnByZWxvYWQgOiB0cnVlO1xuICAgICAgc2VsZi5fcmF0ZSA9IG8ucmF0ZSB8fCAxO1xuICAgICAgc2VsZi5fc3ByaXRlID0gby5zcHJpdGUgfHwge307XG4gICAgICBzZWxmLl9zcmMgPSAodHlwZW9mIG8uc3JjICE9PSAnc3RyaW5nJykgPyBvLnNyYyA6IFtvLnNyY107XG4gICAgICBzZWxmLl92b2x1bWUgPSBvLnZvbHVtZSAhPT0gdW5kZWZpbmVkID8gby52b2x1bWUgOiAxO1xuICAgICAgc2VsZi5feGhyV2l0aENyZWRlbnRpYWxzID0gby54aHJXaXRoQ3JlZGVudGlhbHMgfHwgZmFsc2U7XG5cbiAgICAgIC8vIFNldHVwIGFsbCBvdGhlciBkZWZhdWx0IHByb3BlcnRpZXMuXG4gICAgICBzZWxmLl9kdXJhdGlvbiA9IDA7XG4gICAgICBzZWxmLl9zdGF0ZSA9ICd1bmxvYWRlZCc7XG4gICAgICBzZWxmLl9zb3VuZHMgPSBbXTtcbiAgICAgIHNlbGYuX2VuZFRpbWVycyA9IHt9O1xuICAgICAgc2VsZi5fcXVldWUgPSBbXTtcblxuICAgICAgLy8gU2V0dXAgZXZlbnQgbGlzdGVuZXJzLlxuICAgICAgc2VsZi5fb25lbmQgPSBvLm9uZW5kID8gW3tmbjogby5vbmVuZH1dIDogW107XG4gICAgICBzZWxmLl9vbmZhZGUgPSBvLm9uZmFkZSA/IFt7Zm46IG8ub25mYWRlfV0gOiBbXTtcbiAgICAgIHNlbGYuX29ubG9hZCA9IG8ub25sb2FkID8gW3tmbjogby5vbmxvYWR9XSA6IFtdO1xuICAgICAgc2VsZi5fb25sb2FkZXJyb3IgPSBvLm9ubG9hZGVycm9yID8gW3tmbjogby5vbmxvYWRlcnJvcn1dIDogW107XG4gICAgICBzZWxmLl9vbnBsYXllcnJvciA9IG8ub25wbGF5ZXJyb3IgPyBbe2ZuOiBvLm9ucGxheWVycm9yfV0gOiBbXTtcbiAgICAgIHNlbGYuX29ucGF1c2UgPSBvLm9ucGF1c2UgPyBbe2ZuOiBvLm9ucGF1c2V9XSA6IFtdO1xuICAgICAgc2VsZi5fb25wbGF5ID0gby5vbnBsYXkgPyBbe2ZuOiBvLm9ucGxheX1dIDogW107XG4gICAgICBzZWxmLl9vbnN0b3AgPSBvLm9uc3RvcCA/IFt7Zm46IG8ub25zdG9wfV0gOiBbXTtcbiAgICAgIHNlbGYuX29ubXV0ZSA9IG8ub25tdXRlID8gW3tmbjogby5vbm11dGV9XSA6IFtdO1xuICAgICAgc2VsZi5fb252b2x1bWUgPSBvLm9udm9sdW1lID8gW3tmbjogby5vbnZvbHVtZX1dIDogW107XG4gICAgICBzZWxmLl9vbnJhdGUgPSBvLm9ucmF0ZSA/IFt7Zm46IG8ub25yYXRlfV0gOiBbXTtcbiAgICAgIHNlbGYuX29uc2VlayA9IG8ub25zZWVrID8gW3tmbjogby5vbnNlZWt9XSA6IFtdO1xuICAgICAgc2VsZi5fb25yZXN1bWUgPSBbXTtcblxuICAgICAgLy8gV2ViIEF1ZGlvIG9yIEhUTUw1IEF1ZGlvP1xuICAgICAgc2VsZi5fd2ViQXVkaW8gPSBIb3dsZXIudXNpbmdXZWJBdWRpbyAmJiAhc2VsZi5faHRtbDU7XG5cbiAgICAgIC8vIEF1dG9tYXRpY2FsbHkgdHJ5IHRvIGVuYWJsZSBhdWRpbyBvbiBpT1MuXG4gICAgICBpZiAodHlwZW9mIEhvd2xlci5jdHggIT09ICd1bmRlZmluZWQnICYmIEhvd2xlci5jdHggJiYgSG93bGVyLm1vYmlsZUF1dG9FbmFibGUpIHtcbiAgICAgICAgSG93bGVyLl9lbmFibGVNb2JpbGVBdWRpbygpO1xuICAgICAgfVxuXG4gICAgICAvLyBLZWVwIHRyYWNrIG9mIHRoaXMgSG93bCBncm91cCBpbiB0aGUgZ2xvYmFsIGNvbnRyb2xsZXIuXG4gICAgICBIb3dsZXIuX2hvd2xzLnB1c2goc2VsZik7XG5cbiAgICAgIC8vIElmIHRoZXkgc2VsZWN0ZWQgYXV0b3BsYXksIGFkZCBhIHBsYXkgZXZlbnQgdG8gdGhlIGxvYWQgcXVldWUuXG4gICAgICBpZiAoc2VsZi5fYXV0b3BsYXkpIHtcbiAgICAgICAgc2VsZi5fcXVldWUucHVzaCh7XG4gICAgICAgICAgZXZlbnQ6ICdwbGF5JyxcbiAgICAgICAgICBhY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgc2VsZi5wbGF5KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgLy8gTG9hZCB0aGUgc291cmNlIGZpbGUgdW5sZXNzIG90aGVyd2lzZSBzcGVjaWZpZWQuXG4gICAgICBpZiAoc2VsZi5fcHJlbG9hZCkge1xuICAgICAgICBzZWxmLmxvYWQoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIExvYWQgdGhlIGF1ZGlvIGZpbGUuXG4gICAgICogQHJldHVybiB7SG93bGVyfVxuICAgICAqL1xuICAgIGxvYWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIHVybCA9IG51bGw7XG5cbiAgICAgIC8vIElmIG5vIGF1ZGlvIGlzIGF2YWlsYWJsZSwgcXVpdCBpbW1lZGlhdGVseS5cbiAgICAgIGlmIChIb3dsZXIubm9BdWRpbykge1xuICAgICAgICBzZWxmLl9lbWl0KCdsb2FkZXJyb3InLCBudWxsLCAnTm8gYXVkaW8gc3VwcG9ydC4nKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBNYWtlIHN1cmUgb3VyIHNvdXJjZSBpcyBpbiBhbiBhcnJheS5cbiAgICAgIGlmICh0eXBlb2Ygc2VsZi5fc3JjID09PSAnc3RyaW5nJykge1xuICAgICAgICBzZWxmLl9zcmMgPSBbc2VsZi5fc3JjXTtcbiAgICAgIH1cblxuICAgICAgLy8gTG9vcCB0aHJvdWdoIHRoZSBzb3VyY2VzIGFuZCBwaWNrIHRoZSBmaXJzdCBvbmUgdGhhdCBpcyBjb21wYXRpYmxlLlxuICAgICAgZm9yICh2YXIgaT0wOyBpPHNlbGYuX3NyYy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZXh0LCBzdHI7XG5cbiAgICAgICAgaWYgKHNlbGYuX2Zvcm1hdCAmJiBzZWxmLl9mb3JtYXRbaV0pIHtcbiAgICAgICAgICAvLyBJZiBhbiBleHRlbnNpb24gd2FzIHNwZWNpZmllZCwgdXNlIHRoYXQgaW5zdGVhZC5cbiAgICAgICAgICBleHQgPSBzZWxmLl9mb3JtYXRbaV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gTWFrZSBzdXJlIHRoZSBzb3VyY2UgaXMgYSBzdHJpbmcuXG4gICAgICAgICAgc3RyID0gc2VsZi5fc3JjW2ldO1xuICAgICAgICAgIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgc2VsZi5fZW1pdCgnbG9hZGVycm9yJywgbnVsbCwgJ05vbi1zdHJpbmcgZm91bmQgaW4gc2VsZWN0ZWQgYXVkaW8gc291cmNlcyAtIGlnbm9yaW5nLicpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gRXh0cmFjdCB0aGUgZmlsZSBleHRlbnNpb24gZnJvbSB0aGUgVVJMIG9yIGJhc2U2NCBkYXRhIFVSSS5cbiAgICAgICAgICBleHQgPSAvXmRhdGE6YXVkaW9cXC8oW147LF0rKTsvaS5leGVjKHN0cik7XG4gICAgICAgICAgaWYgKCFleHQpIHtcbiAgICAgICAgICAgIGV4dCA9IC9cXC4oW14uXSspJC8uZXhlYyhzdHIuc3BsaXQoJz8nLCAxKVswXSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGV4dCkge1xuICAgICAgICAgICAgZXh0ID0gZXh0WzFdLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gTG9nIGEgd2FybmluZyBpZiBubyBleHRlbnNpb24gd2FzIGZvdW5kLlxuICAgICAgICBpZiAoIWV4dCkge1xuICAgICAgICAgIGNvbnNvbGUud2FybignTm8gZmlsZSBleHRlbnNpb24gd2FzIGZvdW5kLiBDb25zaWRlciB1c2luZyB0aGUgXCJmb3JtYXRcIiBwcm9wZXJ0eSBvciBzcGVjaWZ5IGFuIGV4dGVuc2lvbi4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENoZWNrIGlmIHRoaXMgZXh0ZW5zaW9uIGlzIGF2YWlsYWJsZS5cbiAgICAgICAgaWYgKGV4dCAmJiBIb3dsZXIuY29kZWNzKGV4dCkpIHtcbiAgICAgICAgICB1cmwgPSBzZWxmLl9zcmNbaV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCF1cmwpIHtcbiAgICAgICAgc2VsZi5fZW1pdCgnbG9hZGVycm9yJywgbnVsbCwgJ05vIGNvZGVjIHN1cHBvcnQgZm9yIHNlbGVjdGVkIGF1ZGlvIHNvdXJjZXMuJyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgc2VsZi5fc3JjID0gdXJsO1xuICAgICAgc2VsZi5fc3RhdGUgPSAnbG9hZGluZyc7XG5cbiAgICAgIC8vIElmIHRoZSBob3N0aW5nIHBhZ2UgaXMgSFRUUFMgYW5kIHRoZSBzb3VyY2UgaXNuJ3QsXG4gICAgICAvLyBkcm9wIGRvd24gdG8gSFRNTDUgQXVkaW8gdG8gYXZvaWQgTWl4ZWQgQ29udGVudCBlcnJvcnMuXG4gICAgICBpZiAod2luZG93LmxvY2F0aW9uLnByb3RvY29sID09PSAnaHR0cHM6JyAmJiB1cmwuc2xpY2UoMCwgNSkgPT09ICdodHRwOicpIHtcbiAgICAgICAgc2VsZi5faHRtbDUgPSB0cnVlO1xuICAgICAgICBzZWxmLl93ZWJBdWRpbyA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICAvLyBDcmVhdGUgYSBuZXcgc291bmQgb2JqZWN0IGFuZCBhZGQgaXQgdG8gdGhlIHBvb2wuXG4gICAgICBuZXcgU291bmQoc2VsZik7XG5cbiAgICAgIC8vIExvYWQgYW5kIGRlY29kZSB0aGUgYXVkaW8gZGF0YSBmb3IgcGxheWJhY2suXG4gICAgICBpZiAoc2VsZi5fd2ViQXVkaW8pIHtcbiAgICAgICAgbG9hZEJ1ZmZlcihzZWxmKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFBsYXkgYSBzb3VuZCBvciByZXN1bWUgcHJldmlvdXMgcGxheWJhY2suXG4gICAgICogQHBhcmFtICB7U3RyaW5nL051bWJlcn0gc3ByaXRlICAgU3ByaXRlIG5hbWUgZm9yIHNwcml0ZSBwbGF5YmFjayBvciBzb3VuZCBpZCB0byBjb250aW51ZSBwcmV2aW91cy5cbiAgICAgKiBAcGFyYW0gIHtCb29sZWFufSBpbnRlcm5hbCBJbnRlcm5hbCBVc2U6IHRydWUgcHJldmVudHMgZXZlbnQgZmlyaW5nLlxuICAgICAqIEByZXR1cm4ge051bWJlcn0gICAgICAgICAgU291bmQgSUQuXG4gICAgICovXG4gICAgcGxheTogZnVuY3Rpb24oc3ByaXRlLCBpbnRlcm5hbCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIGlkID0gbnVsbDtcblxuICAgICAgLy8gRGV0ZXJtaW5lIGlmIGEgc3ByaXRlLCBzb3VuZCBpZCBvciBub3RoaW5nIHdhcyBwYXNzZWRcbiAgICAgIGlmICh0eXBlb2Ygc3ByaXRlID09PSAnbnVtYmVyJykge1xuICAgICAgICBpZCA9IHNwcml0ZTtcbiAgICAgICAgc3ByaXRlID0gbnVsbDtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHNwcml0ZSA9PT0gJ3N0cmluZycgJiYgc2VsZi5fc3RhdGUgPT09ICdsb2FkZWQnICYmICFzZWxmLl9zcHJpdGVbc3ByaXRlXSkge1xuICAgICAgICAvLyBJZiB0aGUgcGFzc2VkIHNwcml0ZSBkb2Vzbid0IGV4aXN0LCBkbyBub3RoaW5nLlxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHNwcml0ZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgLy8gVXNlIHRoZSBkZWZhdWx0IHNvdW5kIHNwcml0ZSAocGxheXMgdGhlIGZ1bGwgYXVkaW8gbGVuZ3RoKS5cbiAgICAgICAgc3ByaXRlID0gJ19fZGVmYXVsdCc7XG5cbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhlcmUgaXMgYSBzaW5nbGUgcGF1c2VkIHNvdW5kIHRoYXQgaXNuJ3QgZW5kZWQuXG4gICAgICAgIC8vIElmIHRoZXJlIGlzLCBwbGF5IHRoYXQgc291bmQuIElmIG5vdCwgY29udGludWUgYXMgdXN1YWwuXG4gICAgICAgIHZhciBudW0gPSAwO1xuICAgICAgICBmb3IgKHZhciBpPTA7IGk8c2VsZi5fc291bmRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKHNlbGYuX3NvdW5kc1tpXS5fcGF1c2VkICYmICFzZWxmLl9zb3VuZHNbaV0uX2VuZGVkKSB7XG4gICAgICAgICAgICBudW0rKztcbiAgICAgICAgICAgIGlkID0gc2VsZi5fc291bmRzW2ldLl9pZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobnVtID09PSAxKSB7XG4gICAgICAgICAgc3ByaXRlID0gbnVsbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gR2V0IHRoZSBzZWxlY3RlZCBub2RlLCBvciBnZXQgb25lIGZyb20gdGhlIHBvb2wuXG4gICAgICB2YXIgc291bmQgPSBpZCA/IHNlbGYuX3NvdW5kQnlJZChpZCkgOiBzZWxmLl9pbmFjdGl2ZVNvdW5kKCk7XG5cbiAgICAgIC8vIElmIHRoZSBzb3VuZCBkb2Vzbid0IGV4aXN0LCBkbyBub3RoaW5nLlxuICAgICAgaWYgKCFzb3VuZCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgLy8gU2VsZWN0IHRoZSBzcHJpdGUgZGVmaW5pdGlvbi5cbiAgICAgIGlmIChpZCAmJiAhc3ByaXRlKSB7XG4gICAgICAgIHNwcml0ZSA9IHNvdW5kLl9zcHJpdGUgfHwgJ19fZGVmYXVsdCc7XG4gICAgICB9XG5cbiAgICAgIC8vIElmIHRoZSBzb3VuZCBoYXNuJ3QgbG9hZGVkLCB3ZSBtdXN0IHdhaXQgdG8gZ2V0IHRoZSBhdWRpbydzIGR1cmF0aW9uLlxuICAgICAgLy8gV2UgYWxzbyBuZWVkIHRvIHdhaXQgdG8gbWFrZSBzdXJlIHdlIGRvbid0IHJ1biBpbnRvIHJhY2UgY29uZGl0aW9ucyB3aXRoXG4gICAgICAvLyB0aGUgb3JkZXIgb2YgZnVuY3Rpb24gY2FsbHMuXG4gICAgICBpZiAoc2VsZi5fc3RhdGUgIT09ICdsb2FkZWQnKSB7XG4gICAgICAgIC8vIFNldCB0aGUgc3ByaXRlIHZhbHVlIG9uIHRoaXMgc291bmQuXG4gICAgICAgIHNvdW5kLl9zcHJpdGUgPSBzcHJpdGU7XG5cbiAgICAgICAgLy8gTWFrciB0aGlzIHNvdW5kZWQgYXMgbm90IGVuZGVkIGluIGNhc2UgYW5vdGhlciBzb3VuZCBpcyBwbGF5ZWQgYmVmb3JlIHRoaXMgb25lIGxvYWRzLlxuICAgICAgICBzb3VuZC5fZW5kZWQgPSBmYWxzZTtcblxuICAgICAgICAvLyBBZGQgdGhlIHNvdW5kIHRvIHRoZSBxdWV1ZSB0byBiZSBwbGF5ZWQgb24gbG9hZC5cbiAgICAgICAgdmFyIHNvdW5kSWQgPSBzb3VuZC5faWQ7XG4gICAgICAgIHNlbGYuX3F1ZXVlLnB1c2goe1xuICAgICAgICAgIGV2ZW50OiAncGxheScsXG4gICAgICAgICAgYWN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHNlbGYucGxheShzb3VuZElkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBzb3VuZElkO1xuICAgICAgfVxuXG4gICAgICAvLyBEb24ndCBwbGF5IHRoZSBzb3VuZCBpZiBhbiBpZCB3YXMgcGFzc2VkIGFuZCBpdCBpcyBhbHJlYWR5IHBsYXlpbmcuXG4gICAgICBpZiAoaWQgJiYgIXNvdW5kLl9wYXVzZWQpIHtcbiAgICAgICAgLy8gVHJpZ2dlciB0aGUgcGxheSBldmVudCwgaW4gb3JkZXIgdG8ga2VlcCBpdGVyYXRpbmcgdGhyb3VnaCBxdWV1ZS5cbiAgICAgICAgaWYgKCFpbnRlcm5hbCkge1xuICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBzZWxmLl9lbWl0KCdwbGF5Jywgc291bmQuX2lkKTtcbiAgICAgICAgICB9LCAwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzb3VuZC5faWQ7XG4gICAgICB9XG5cbiAgICAgIC8vIE1ha2Ugc3VyZSB0aGUgQXVkaW9Db250ZXh0IGlzbid0IHN1c3BlbmRlZCwgYW5kIHJlc3VtZSBpdCBpZiBpdCBpcy5cbiAgICAgIGlmIChzZWxmLl93ZWJBdWRpbykge1xuICAgICAgICBIb3dsZXIuX2F1dG9SZXN1bWUoKTtcbiAgICAgIH1cblxuICAgICAgLy8gRGV0ZXJtaW5lIGhvdyBsb25nIHRvIHBsYXkgZm9yIGFuZCB3aGVyZSB0byBzdGFydCBwbGF5aW5nLlxuICAgICAgdmFyIHNlZWsgPSBNYXRoLm1heCgwLCBzb3VuZC5fc2VlayA+IDAgPyBzb3VuZC5fc2VlayA6IHNlbGYuX3Nwcml0ZVtzcHJpdGVdWzBdIC8gMTAwMCk7XG4gICAgICB2YXIgZHVyYXRpb24gPSBNYXRoLm1heCgwLCAoKHNlbGYuX3Nwcml0ZVtzcHJpdGVdWzBdICsgc2VsZi5fc3ByaXRlW3Nwcml0ZV1bMV0pIC8gMTAwMCkgLSBzZWVrKTtcbiAgICAgIHZhciB0aW1lb3V0ID0gKGR1cmF0aW9uICogMTAwMCkgLyBNYXRoLmFicyhzb3VuZC5fcmF0ZSk7XG5cbiAgICAgIC8vIFVwZGF0ZSB0aGUgcGFyYW1ldGVycyBvZiB0aGUgc291bmRcbiAgICAgIHNvdW5kLl9wYXVzZWQgPSBmYWxzZTtcbiAgICAgIHNvdW5kLl9lbmRlZCA9IGZhbHNlO1xuICAgICAgc291bmQuX3Nwcml0ZSA9IHNwcml0ZTtcbiAgICAgIHNvdW5kLl9zZWVrID0gc2VlaztcbiAgICAgIHNvdW5kLl9zdGFydCA9IHNlbGYuX3Nwcml0ZVtzcHJpdGVdWzBdIC8gMTAwMDtcbiAgICAgIHNvdW5kLl9zdG9wID0gKHNlbGYuX3Nwcml0ZVtzcHJpdGVdWzBdICsgc2VsZi5fc3ByaXRlW3Nwcml0ZV1bMV0pIC8gMTAwMDtcbiAgICAgIHNvdW5kLl9sb29wID0gISEoc291bmQuX2xvb3AgfHwgc2VsZi5fc3ByaXRlW3Nwcml0ZV1bMl0pO1xuXG4gICAgICAvLyBCZWdpbiB0aGUgYWN0dWFsIHBsYXliYWNrLlxuICAgICAgdmFyIG5vZGUgPSBzb3VuZC5fbm9kZTtcbiAgICAgIGlmIChzZWxmLl93ZWJBdWRpbykge1xuICAgICAgICAvLyBGaXJlIHRoaXMgd2hlbiB0aGUgc291bmQgaXMgcmVhZHkgdG8gcGxheSB0byBiZWdpbiBXZWIgQXVkaW8gcGxheWJhY2suXG4gICAgICAgIHZhciBwbGF5V2ViQXVkaW8gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICBzZWxmLl9yZWZyZXNoQnVmZmVyKHNvdW5kKTtcblxuICAgICAgICAgIC8vIFNldHVwIHRoZSBwbGF5YmFjayBwYXJhbXMuXG4gICAgICAgICAgdmFyIHZvbCA9IChzb3VuZC5fbXV0ZWQgfHwgc2VsZi5fbXV0ZWQpID8gMCA6IHNvdW5kLl92b2x1bWU7XG4gICAgICAgICAgbm9kZS5nYWluLnNldFZhbHVlQXRUaW1lKHZvbCwgSG93bGVyLmN0eC5jdXJyZW50VGltZSk7XG4gICAgICAgICAgc291bmQuX3BsYXlTdGFydCA9IEhvd2xlci5jdHguY3VycmVudFRpbWU7XG5cbiAgICAgICAgICAvLyBQbGF5IHRoZSBzb3VuZCB1c2luZyB0aGUgc3VwcG9ydGVkIG1ldGhvZC5cbiAgICAgICAgICBpZiAodHlwZW9mIG5vZGUuYnVmZmVyU291cmNlLnN0YXJ0ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgc291bmQuX2xvb3AgPyBub2RlLmJ1ZmZlclNvdXJjZS5ub3RlR3JhaW5PbigwLCBzZWVrLCA4NjQwMCkgOiBub2RlLmJ1ZmZlclNvdXJjZS5ub3RlR3JhaW5PbigwLCBzZWVrLCBkdXJhdGlvbik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNvdW5kLl9sb29wID8gbm9kZS5idWZmZXJTb3VyY2Uuc3RhcnQoMCwgc2VlaywgODY0MDApIDogbm9kZS5idWZmZXJTb3VyY2Uuc3RhcnQoMCwgc2VlaywgZHVyYXRpb24pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFN0YXJ0IGEgbmV3IHRpbWVyIGlmIG5vbmUgaXMgcHJlc2VudC5cbiAgICAgICAgICBpZiAodGltZW91dCAhPT0gSW5maW5pdHkpIHtcbiAgICAgICAgICAgIHNlbGYuX2VuZFRpbWVyc1tzb3VuZC5faWRdID0gc2V0VGltZW91dChzZWxmLl9lbmRlZC5iaW5kKHNlbGYsIHNvdW5kKSwgdGltZW91dCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCFpbnRlcm5hbCkge1xuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgc2VsZi5fZW1pdCgncGxheScsIHNvdW5kLl9pZCk7XG4gICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKEhvd2xlci5zdGF0ZSA9PT0gJ3J1bm5pbmcnKSB7XG4gICAgICAgICAgcGxheVdlYkF1ZGlvKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2VsZi5vbmNlKCdyZXN1bWUnLCBwbGF5V2ViQXVkaW8pO1xuXG4gICAgICAgICAgLy8gQ2FuY2VsIHRoZSBlbmQgdGltZXIuXG4gICAgICAgICAgc2VsZi5fY2xlYXJUaW1lcihzb3VuZC5faWQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBGaXJlIHRoaXMgd2hlbiB0aGUgc291bmQgaXMgcmVhZHkgdG8gcGxheSB0byBiZWdpbiBIVE1MNSBBdWRpbyBwbGF5YmFjay5cbiAgICAgICAgdmFyIHBsYXlIdG1sNSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIG5vZGUuY3VycmVudFRpbWUgPSBzZWVrO1xuICAgICAgICAgIG5vZGUubXV0ZWQgPSBzb3VuZC5fbXV0ZWQgfHwgc2VsZi5fbXV0ZWQgfHwgSG93bGVyLl9tdXRlZCB8fCBub2RlLm11dGVkO1xuICAgICAgICAgIG5vZGUudm9sdW1lID0gc291bmQuX3ZvbHVtZSAqIEhvd2xlci52b2x1bWUoKTtcbiAgICAgICAgICBub2RlLnBsYXliYWNrUmF0ZSA9IHNvdW5kLl9yYXRlO1xuXG4gICAgICAgICAgLy8gTW9iaWxlIGJyb3dzZXJzIHdpbGwgdGhyb3cgYW4gZXJyb3IgaWYgdGhpcyBpcyBjYWxsZWQgd2l0aG91dCB1c2VyIGludGVyYWN0aW9uLlxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBub2RlLnBsYXkoKTtcblxuICAgICAgICAgICAgLy8gSWYgdGhlIG5vZGUgaXMgc3RpbGwgcGF1c2VkLCB0aGVuIHdlIGNhbiBhc3N1bWUgdGhlcmUgd2FzIGEgcGxheWJhY2sgaXNzdWUuXG4gICAgICAgICAgICBpZiAobm9kZS5wYXVzZWQpIHtcbiAgICAgICAgICAgICAgc2VsZi5fZW1pdCgncGxheWVycm9yJywgc291bmQuX2lkLCAnUGxheWJhY2sgd2FzIHVuYWJsZSB0byBzdGFydC4gVGhpcyBpcyBtb3N0IGNvbW1vbmx5IGFuIGlzc3VlICcgK1xuICAgICAgICAgICAgICAgICdvbiBtb2JpbGUgZGV2aWNlcyB3aGVyZSBwbGF5YmFjayB3YXMgbm90IHdpdGhpbiBhIHVzZXIgaW50ZXJhY3Rpb24uJyk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gU2V0dXAgdGhlIG5ldyBlbmQgdGltZXIuXG4gICAgICAgICAgICBpZiAodGltZW91dCAhPT0gSW5maW5pdHkpIHtcbiAgICAgICAgICAgICAgc2VsZi5fZW5kVGltZXJzW3NvdW5kLl9pZF0gPSBzZXRUaW1lb3V0KHNlbGYuX2VuZGVkLmJpbmQoc2VsZiwgc291bmQpLCB0aW1lb3V0KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFpbnRlcm5hbCkge1xuICAgICAgICAgICAgICBzZWxmLl9lbWl0KCdwbGF5Jywgc291bmQuX2lkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHNlbGYuX2VtaXQoJ3BsYXllcnJvcicsIHNvdW5kLl9pZCwgZXJyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gUGxheSBpbW1lZGlhdGVseSBpZiByZWFkeSwgb3Igd2FpdCBmb3IgdGhlICdjYW5wbGF5dGhyb3VnaCdlIHZlbnQuXG4gICAgICAgIHZhciBsb2FkZWROb1JlYWR5U3RhdGUgPSAod2luZG93ICYmIHdpbmRvdy5lamVjdGEpIHx8ICghbm9kZS5yZWFkeVN0YXRlICYmIEhvd2xlci5fbmF2aWdhdG9yLmlzQ29jb29uSlMpO1xuICAgICAgICBpZiAobm9kZS5yZWFkeVN0YXRlID09PSA0IHx8IGxvYWRlZE5vUmVhZHlTdGF0ZSkge1xuICAgICAgICAgIHBsYXlIdG1sNSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBsaXN0ZW5lciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgLy8gQmVnaW4gcGxheWJhY2suXG4gICAgICAgICAgICBwbGF5SHRtbDUoKTtcblxuICAgICAgICAgICAgLy8gQ2xlYXIgdGhpcyBsaXN0ZW5lci5cbiAgICAgICAgICAgIG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihIb3dsZXIuX2NhblBsYXlFdmVudCwgbGlzdGVuZXIsIGZhbHNlKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihIb3dsZXIuX2NhblBsYXlFdmVudCwgbGlzdGVuZXIsIGZhbHNlKTtcblxuICAgICAgICAgIC8vIENhbmNlbCB0aGUgZW5kIHRpbWVyLlxuICAgICAgICAgIHNlbGYuX2NsZWFyVGltZXIoc291bmQuX2lkKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gc291bmQuX2lkO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBQYXVzZSBwbGF5YmFjayBhbmQgc2F2ZSBjdXJyZW50IHBvc2l0aW9uLlxuICAgICAqIEBwYXJhbSAge051bWJlcn0gaWQgVGhlIHNvdW5kIElEIChlbXB0eSB0byBwYXVzZSBhbGwgaW4gZ3JvdXApLlxuICAgICAqIEByZXR1cm4ge0hvd2x9XG4gICAgICovXG4gICAgcGF1c2U6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgIC8vIElmIHRoZSBzb3VuZCBoYXNuJ3QgbG9hZGVkLCBhZGQgaXQgdG8gdGhlIGxvYWQgcXVldWUgdG8gcGF1c2Ugd2hlbiBjYXBhYmxlLlxuICAgICAgaWYgKHNlbGYuX3N0YXRlICE9PSAnbG9hZGVkJykge1xuICAgICAgICBzZWxmLl9xdWV1ZS5wdXNoKHtcbiAgICAgICAgICBldmVudDogJ3BhdXNlJyxcbiAgICAgICAgICBhY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgc2VsZi5wYXVzZShpZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgIH1cblxuICAgICAgLy8gSWYgbm8gaWQgaXMgcGFzc2VkLCBnZXQgYWxsIElEJ3MgdG8gYmUgcGF1c2VkLlxuICAgICAgdmFyIGlkcyA9IHNlbGYuX2dldFNvdW5kSWRzKGlkKTtcblxuICAgICAgZm9yICh2YXIgaT0wOyBpPGlkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAvLyBDbGVhciB0aGUgZW5kIHRpbWVyLlxuICAgICAgICBzZWxmLl9jbGVhclRpbWVyKGlkc1tpXSk7XG5cbiAgICAgICAgLy8gR2V0IHRoZSBzb3VuZC5cbiAgICAgICAgdmFyIHNvdW5kID0gc2VsZi5fc291bmRCeUlkKGlkc1tpXSk7XG5cbiAgICAgICAgaWYgKHNvdW5kICYmICFzb3VuZC5fcGF1c2VkKSB7XG4gICAgICAgICAgLy8gUmVzZXQgdGhlIHNlZWsgcG9zaXRpb24uXG4gICAgICAgICAgc291bmQuX3NlZWsgPSBzZWxmLnNlZWsoaWRzW2ldKTtcbiAgICAgICAgICBzb3VuZC5fcmF0ZVNlZWsgPSAwO1xuICAgICAgICAgIHNvdW5kLl9wYXVzZWQgPSB0cnVlO1xuXG4gICAgICAgICAgLy8gU3RvcCBjdXJyZW50bHkgcnVubmluZyBmYWRlcy5cbiAgICAgICAgICBzZWxmLl9zdG9wRmFkZShpZHNbaV0pO1xuXG4gICAgICAgICAgaWYgKHNvdW5kLl9ub2RlKSB7XG4gICAgICAgICAgICBpZiAoc2VsZi5fd2ViQXVkaW8pIHtcbiAgICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHRoZSBzb3VuZCBoYXMgYmVlbiBjcmVhdGVkLlxuICAgICAgICAgICAgICBpZiAoIXNvdW5kLl9ub2RlLmJ1ZmZlclNvdXJjZSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzb3VuZC5fbm9kZS5idWZmZXJTb3VyY2Uuc3RvcCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBzb3VuZC5fbm9kZS5idWZmZXJTb3VyY2Uubm90ZU9mZigwKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzb3VuZC5fbm9kZS5idWZmZXJTb3VyY2Uuc3RvcCgwKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIC8vIENsZWFuIHVwIHRoZSBidWZmZXIgc291cmNlLlxuICAgICAgICAgICAgICBzZWxmLl9jbGVhbkJ1ZmZlcihzb3VuZC5fbm9kZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFpc05hTihzb3VuZC5fbm9kZS5kdXJhdGlvbikgfHwgc291bmQuX25vZGUuZHVyYXRpb24gPT09IEluZmluaXR5KSB7XG4gICAgICAgICAgICAgIHNvdW5kLl9ub2RlLnBhdXNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gRmlyZSB0aGUgcGF1c2UgZXZlbnQsIHVubGVzcyBgdHJ1ZWAgaXMgcGFzc2VkIGFzIHRoZSAybmQgYXJndW1lbnQuXG4gICAgICAgIGlmICghYXJndW1lbnRzWzFdKSB7XG4gICAgICAgICAgc2VsZi5fZW1pdCgncGF1c2UnLCBzb3VuZCA/IHNvdW5kLl9pZCA6IG51bGwpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTdG9wIHBsYXliYWNrIGFuZCByZXNldCB0byBzdGFydC5cbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGlkIFRoZSBzb3VuZCBJRCAoZW1wdHkgdG8gc3RvcCBhbGwgaW4gZ3JvdXApLlxuICAgICAqIEBwYXJhbSAge0Jvb2xlYW59IGludGVybmFsIEludGVybmFsIFVzZTogdHJ1ZSBwcmV2ZW50cyBldmVudCBmaXJpbmcuXG4gICAgICogQHJldHVybiB7SG93bH1cbiAgICAgKi9cbiAgICBzdG9wOiBmdW5jdGlvbihpZCwgaW50ZXJuYWwpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgLy8gSWYgdGhlIHNvdW5kIGhhc24ndCBsb2FkZWQsIGFkZCBpdCB0byB0aGUgbG9hZCBxdWV1ZSB0byBzdG9wIHdoZW4gY2FwYWJsZS5cbiAgICAgIGlmIChzZWxmLl9zdGF0ZSAhPT0gJ2xvYWRlZCcpIHtcbiAgICAgICAgc2VsZi5fcXVldWUucHVzaCh7XG4gICAgICAgICAgZXZlbnQ6ICdzdG9wJyxcbiAgICAgICAgICBhY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgc2VsZi5zdG9wKGlkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgfVxuXG4gICAgICAvLyBJZiBubyBpZCBpcyBwYXNzZWQsIGdldCBhbGwgSUQncyB0byBiZSBzdG9wcGVkLlxuICAgICAgdmFyIGlkcyA9IHNlbGYuX2dldFNvdW5kSWRzKGlkKTtcblxuICAgICAgZm9yICh2YXIgaT0wOyBpPGlkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAvLyBDbGVhciB0aGUgZW5kIHRpbWVyLlxuICAgICAgICBzZWxmLl9jbGVhclRpbWVyKGlkc1tpXSk7XG5cbiAgICAgICAgLy8gR2V0IHRoZSBzb3VuZC5cbiAgICAgICAgdmFyIHNvdW5kID0gc2VsZi5fc291bmRCeUlkKGlkc1tpXSk7XG5cbiAgICAgICAgaWYgKHNvdW5kKSB7XG4gICAgICAgICAgLy8gUmVzZXQgdGhlIHNlZWsgcG9zaXRpb24uXG4gICAgICAgICAgc291bmQuX3NlZWsgPSBzb3VuZC5fc3RhcnQgfHwgMDtcbiAgICAgICAgICBzb3VuZC5fcmF0ZVNlZWsgPSAwO1xuICAgICAgICAgIHNvdW5kLl9wYXVzZWQgPSB0cnVlO1xuICAgICAgICAgIHNvdW5kLl9lbmRlZCA9IHRydWU7XG5cbiAgICAgICAgICAvLyBTdG9wIGN1cnJlbnRseSBydW5uaW5nIGZhZGVzLlxuICAgICAgICAgIHNlbGYuX3N0b3BGYWRlKGlkc1tpXSk7XG5cbiAgICAgICAgICBpZiAoc291bmQuX25vZGUpIHtcbiAgICAgICAgICAgIGlmIChzZWxmLl93ZWJBdWRpbykge1xuICAgICAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhlIHNvdW5kJ3MgQXVkaW9CdWZmZXJTb3VyY2VOb2RlIGhhcyBiZWVuIGNyZWF0ZWQuXG4gICAgICAgICAgICAgIGlmIChzb3VuZC5fbm9kZS5idWZmZXJTb3VyY2UpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHNvdW5kLl9ub2RlLmJ1ZmZlclNvdXJjZS5zdG9wID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgc291bmQuX25vZGUuYnVmZmVyU291cmNlLm5vdGVPZmYoMCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHNvdW5kLl9ub2RlLmJ1ZmZlclNvdXJjZS5zdG9wKDApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIENsZWFuIHVwIHRoZSBidWZmZXIgc291cmNlLlxuICAgICAgICAgICAgICAgIHNlbGYuX2NsZWFuQnVmZmVyKHNvdW5kLl9ub2RlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICghaXNOYU4oc291bmQuX25vZGUuZHVyYXRpb24pIHx8IHNvdW5kLl9ub2RlLmR1cmF0aW9uID09PSBJbmZpbml0eSkge1xuICAgICAgICAgICAgICBzb3VuZC5fbm9kZS5jdXJyZW50VGltZSA9IHNvdW5kLl9zdGFydCB8fCAwO1xuICAgICAgICAgICAgICBzb3VuZC5fbm9kZS5wYXVzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghaW50ZXJuYWwpIHtcbiAgICAgICAgICAgIHNlbGYuX2VtaXQoJ3N0b3AnLCBzb3VuZC5faWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTXV0ZS91bm11dGUgYSBzaW5nbGUgc291bmQgb3IgYWxsIHNvdW5kcyBpbiB0aGlzIEhvd2wgZ3JvdXAuXG4gICAgICogQHBhcmFtICB7Qm9vbGVhbn0gbXV0ZWQgU2V0IHRvIHRydWUgdG8gbXV0ZSBhbmQgZmFsc2UgdG8gdW5tdXRlLlxuICAgICAqIEBwYXJhbSAge051bWJlcn0gaWQgICAgVGhlIHNvdW5kIElEIHRvIHVwZGF0ZSAob21pdCB0byBtdXRlL3VubXV0ZSBhbGwpLlxuICAgICAqIEByZXR1cm4ge0hvd2x9XG4gICAgICovXG4gICAgbXV0ZTogZnVuY3Rpb24obXV0ZWQsIGlkKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgIC8vIElmIHRoZSBzb3VuZCBoYXNuJ3QgbG9hZGVkLCBhZGQgaXQgdG8gdGhlIGxvYWQgcXVldWUgdG8gbXV0ZSB3aGVuIGNhcGFibGUuXG4gICAgICBpZiAoc2VsZi5fc3RhdGUgIT09ICdsb2FkZWQnKSB7XG4gICAgICAgIHNlbGYuX3F1ZXVlLnB1c2goe1xuICAgICAgICAgIGV2ZW50OiAnbXV0ZScsXG4gICAgICAgICAgYWN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHNlbGYubXV0ZShtdXRlZCwgaWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICB9XG5cbiAgICAgIC8vIElmIGFwcGx5aW5nIG11dGUvdW5tdXRlIHRvIGFsbCBzb3VuZHMsIHVwZGF0ZSB0aGUgZ3JvdXAncyB2YWx1ZS5cbiAgICAgIGlmICh0eXBlb2YgaWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbXV0ZWQgPT09ICdib29sZWFuJykge1xuICAgICAgICAgIHNlbGYuX211dGVkID0gbXV0ZWQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHNlbGYuX211dGVkO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIElmIG5vIGlkIGlzIHBhc3NlZCwgZ2V0IGFsbCBJRCdzIHRvIGJlIG11dGVkLlxuICAgICAgdmFyIGlkcyA9IHNlbGYuX2dldFNvdW5kSWRzKGlkKTtcblxuICAgICAgZm9yICh2YXIgaT0wOyBpPGlkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAvLyBHZXQgdGhlIHNvdW5kLlxuICAgICAgICB2YXIgc291bmQgPSBzZWxmLl9zb3VuZEJ5SWQoaWRzW2ldKTtcblxuICAgICAgICBpZiAoc291bmQpIHtcbiAgICAgICAgICBzb3VuZC5fbXV0ZWQgPSBtdXRlZDtcblxuICAgICAgICAgIGlmIChzZWxmLl93ZWJBdWRpbyAmJiBzb3VuZC5fbm9kZSkge1xuICAgICAgICAgICAgc291bmQuX25vZGUuZ2Fpbi5zZXRWYWx1ZUF0VGltZShtdXRlZCA/IDAgOiBzb3VuZC5fdm9sdW1lLCBIb3dsZXIuY3R4LmN1cnJlbnRUaW1lKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHNvdW5kLl9ub2RlKSB7XG4gICAgICAgICAgICBzb3VuZC5fbm9kZS5tdXRlZCA9IEhvd2xlci5fbXV0ZWQgPyB0cnVlIDogbXV0ZWQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc2VsZi5fZW1pdCgnbXV0ZScsIHNvdW5kLl9pZCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldC9zZXQgdGhlIHZvbHVtZSBvZiB0aGlzIHNvdW5kIG9yIG9mIHRoZSBIb3dsIGdyb3VwLiBUaGlzIG1ldGhvZCBjYW4gb3B0aW9uYWxseSB0YWtlIDAsIDEgb3IgMiBhcmd1bWVudHMuXG4gICAgICogICB2b2x1bWUoKSAtPiBSZXR1cm5zIHRoZSBncm91cCdzIHZvbHVtZSB2YWx1ZS5cbiAgICAgKiAgIHZvbHVtZShpZCkgLT4gUmV0dXJucyB0aGUgc291bmQgaWQncyBjdXJyZW50IHZvbHVtZS5cbiAgICAgKiAgIHZvbHVtZSh2b2wpIC0+IFNldHMgdGhlIHZvbHVtZSBvZiBhbGwgc291bmRzIGluIHRoaXMgSG93bCBncm91cC5cbiAgICAgKiAgIHZvbHVtZSh2b2wsIGlkKSAtPiBTZXRzIHRoZSB2b2x1bWUgb2YgcGFzc2VkIHNvdW5kIGlkLlxuICAgICAqIEByZXR1cm4ge0hvd2wvTnVtYmVyfSBSZXR1cm5zIHNlbGYgb3IgY3VycmVudCB2b2x1bWUuXG4gICAgICovXG4gICAgdm9sdW1lOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgdmFyIHZvbCwgaWQ7XG5cbiAgICAgIC8vIERldGVybWluZSB0aGUgdmFsdWVzIGJhc2VkIG9uIGFyZ3VtZW50cy5cbiAgICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAvLyBSZXR1cm4gdGhlIHZhbHVlIG9mIHRoZSBncm91cHMnIHZvbHVtZS5cbiAgICAgICAgcmV0dXJuIHNlbGYuX3ZvbHVtZTtcbiAgICAgIH0gZWxzZSBpZiAoYXJncy5sZW5ndGggPT09IDEgfHwgYXJncy5sZW5ndGggPT09IDIgJiYgdHlwZW9mIGFyZ3NbMV0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIC8vIEZpcnN0IGNoZWNrIGlmIHRoaXMgaXMgYW4gSUQsIGFuZCBpZiBub3QsIGFzc3VtZSBpdCBpcyBhIG5ldyB2b2x1bWUuXG4gICAgICAgIHZhciBpZHMgPSBzZWxmLl9nZXRTb3VuZElkcygpO1xuICAgICAgICB2YXIgaW5kZXggPSBpZHMuaW5kZXhPZihhcmdzWzBdKTtcbiAgICAgICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgICBpZCA9IHBhcnNlSW50KGFyZ3NbMF0sIDEwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2b2wgPSBwYXJzZUZsb2F0KGFyZ3NbMF0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGFyZ3MubGVuZ3RoID49IDIpIHtcbiAgICAgICAgdm9sID0gcGFyc2VGbG9hdChhcmdzWzBdKTtcbiAgICAgICAgaWQgPSBwYXJzZUludChhcmdzWzFdLCAxMCk7XG4gICAgICB9XG5cbiAgICAgIC8vIFVwZGF0ZSB0aGUgdm9sdW1lIG9yIHJldHVybiB0aGUgY3VycmVudCB2b2x1bWUuXG4gICAgICB2YXIgc291bmQ7XG4gICAgICBpZiAodHlwZW9mIHZvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgdm9sID49IDAgJiYgdm9sIDw9IDEpIHtcbiAgICAgICAgLy8gSWYgdGhlIHNvdW5kIGhhc24ndCBsb2FkZWQsIGFkZCBpdCB0byB0aGUgbG9hZCBxdWV1ZSB0byBjaGFuZ2Ugdm9sdW1lIHdoZW4gY2FwYWJsZS5cbiAgICAgICAgaWYgKHNlbGYuX3N0YXRlICE9PSAnbG9hZGVkJykge1xuICAgICAgICAgIHNlbGYuX3F1ZXVlLnB1c2goe1xuICAgICAgICAgICAgZXZlbnQ6ICd2b2x1bWUnLFxuICAgICAgICAgICAgYWN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgc2VsZi52b2x1bWUuYXBwbHkoc2VsZiwgYXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNldCB0aGUgZ3JvdXAgdm9sdW1lLlxuICAgICAgICBpZiAodHlwZW9mIGlkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHNlbGYuX3ZvbHVtZSA9IHZvbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFVwZGF0ZSBvbmUgb3IgYWxsIHZvbHVtZXMuXG4gICAgICAgIGlkID0gc2VsZi5fZ2V0U291bmRJZHMoaWQpO1xuICAgICAgICBmb3IgKHZhciBpPTA7IGk8aWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAvLyBHZXQgdGhlIHNvdW5kLlxuICAgICAgICAgIHNvdW5kID0gc2VsZi5fc291bmRCeUlkKGlkW2ldKTtcblxuICAgICAgICAgIGlmIChzb3VuZCkge1xuICAgICAgICAgICAgc291bmQuX3ZvbHVtZSA9IHZvbDtcblxuICAgICAgICAgICAgLy8gU3RvcCBjdXJyZW50bHkgcnVubmluZyBmYWRlcy5cbiAgICAgICAgICAgIGlmICghYXJnc1syXSkge1xuICAgICAgICAgICAgICBzZWxmLl9zdG9wRmFkZShpZFtpXSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzZWxmLl93ZWJBdWRpbyAmJiBzb3VuZC5fbm9kZSAmJiAhc291bmQuX211dGVkKSB7XG4gICAgICAgICAgICAgIHNvdW5kLl9ub2RlLmdhaW4uc2V0VmFsdWVBdFRpbWUodm9sLCBIb3dsZXIuY3R4LmN1cnJlbnRUaW1lKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc291bmQuX25vZGUgJiYgIXNvdW5kLl9tdXRlZCkge1xuICAgICAgICAgICAgICBzb3VuZC5fbm9kZS52b2x1bWUgPSB2b2wgKiBIb3dsZXIudm9sdW1lKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNlbGYuX2VtaXQoJ3ZvbHVtZScsIHNvdW5kLl9pZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzb3VuZCA9IGlkID8gc2VsZi5fc291bmRCeUlkKGlkKSA6IHNlbGYuX3NvdW5kc1swXTtcbiAgICAgICAgcmV0dXJuIHNvdW5kID8gc291bmQuX3ZvbHVtZSA6IDA7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGYWRlIGEgY3VycmVudGx5IHBsYXlpbmcgc291bmQgYmV0d2VlbiB0d28gdm9sdW1lcyAoaWYgbm8gaWQgaXMgcGFzc3NlZCwgYWxsIHNvdW5kcyB3aWxsIGZhZGUpLlxuICAgICAqIEBwYXJhbSAge051bWJlcn0gZnJvbSBUaGUgdmFsdWUgdG8gZmFkZSBmcm9tICgwLjAgdG8gMS4wKS5cbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHRvICAgVGhlIHZvbHVtZSB0byBmYWRlIHRvICgwLjAgdG8gMS4wKS5cbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGxlbiAgVGltZSBpbiBtaWxsaXNlY29uZHMgdG8gZmFkZS5cbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGlkICAgVGhlIHNvdW5kIGlkIChvbWl0IHRvIGZhZGUgYWxsIHNvdW5kcykuXG4gICAgICogQHJldHVybiB7SG93bH1cbiAgICAgKi9cbiAgICBmYWRlOiBmdW5jdGlvbihmcm9tLCB0bywgbGVuLCBpZCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAvLyBJZiB0aGUgc291bmQgaGFzbid0IGxvYWRlZCwgYWRkIGl0IHRvIHRoZSBsb2FkIHF1ZXVlIHRvIGZhZGUgd2hlbiBjYXBhYmxlLlxuICAgICAgaWYgKHNlbGYuX3N0YXRlICE9PSAnbG9hZGVkJykge1xuICAgICAgICBzZWxmLl9xdWV1ZS5wdXNoKHtcbiAgICAgICAgICBldmVudDogJ2ZhZGUnLFxuICAgICAgICAgIGFjdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBzZWxmLmZhZGUoZnJvbSwgdG8sIGxlbiwgaWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICB9XG5cbiAgICAgIC8vIFNldCB0aGUgdm9sdW1lIHRvIHRoZSBzdGFydCBwb3NpdGlvbi5cbiAgICAgIHNlbGYudm9sdW1lKGZyb20sIGlkKTtcblxuICAgICAgLy8gRmFkZSB0aGUgdm9sdW1lIG9mIG9uZSBvciBhbGwgc291bmRzLlxuICAgICAgdmFyIGlkcyA9IHNlbGYuX2dldFNvdW5kSWRzKGlkKTtcbiAgICAgIGZvciAodmFyIGk9MDsgaTxpZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy8gR2V0IHRoZSBzb3VuZC5cbiAgICAgICAgdmFyIHNvdW5kID0gc2VsZi5fc291bmRCeUlkKGlkc1tpXSk7XG5cbiAgICAgICAgLy8gQ3JlYXRlIGEgbGluZWFyIGZhZGUgb3IgZmFsbCBiYWNrIHRvIHRpbWVvdXRzIHdpdGggSFRNTDUgQXVkaW8uXG4gICAgICAgIGlmIChzb3VuZCkge1xuICAgICAgICAgIC8vIFN0b3AgdGhlIHByZXZpb3VzIGZhZGUgaWYgbm8gc3ByaXRlIGlzIGJlaW5nIHVzZWQgKG90aGVyd2lzZSwgdm9sdW1lIGhhbmRsZXMgdGhpcykuXG4gICAgICAgICAgaWYgKCFpZCkge1xuICAgICAgICAgICAgc2VsZi5fc3RvcEZhZGUoaWRzW2ldKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBJZiB3ZSBhcmUgdXNpbmcgV2ViIEF1ZGlvLCBsZXQgdGhlIG5hdGl2ZSBtZXRob2RzIGRvIHRoZSBhY3R1YWwgZmFkZS5cbiAgICAgICAgICBpZiAoc2VsZi5fd2ViQXVkaW8gJiYgIXNvdW5kLl9tdXRlZCkge1xuICAgICAgICAgICAgdmFyIGN1cnJlbnRUaW1lID0gSG93bGVyLmN0eC5jdXJyZW50VGltZTtcbiAgICAgICAgICAgIHZhciBlbmQgPSBjdXJyZW50VGltZSArIChsZW4gLyAxMDAwKTtcbiAgICAgICAgICAgIHNvdW5kLl92b2x1bWUgPSBmcm9tO1xuICAgICAgICAgICAgc291bmQuX25vZGUuZ2Fpbi5zZXRWYWx1ZUF0VGltZShmcm9tLCBjdXJyZW50VGltZSk7XG4gICAgICAgICAgICBzb3VuZC5fbm9kZS5nYWluLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKHRvLCBlbmQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHNlbGYuX3N0YXJ0RmFkZUludGVydmFsKHNvdW5kLCBmcm9tLCB0bywgbGVuLCBpZHNbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTdGFydHMgdGhlIGludGVybmFsIGludGVydmFsIHRvIGZhZGUgYSBzb3VuZC5cbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IHNvdW5kIFJlZmVyZW5jZSB0byBzb3VuZCB0byBmYWRlLlxuICAgICAqIEBwYXJhbSAge051bWJlcn0gZnJvbSBUaGUgdmFsdWUgdG8gZmFkZSBmcm9tICgwLjAgdG8gMS4wKS5cbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHRvICAgVGhlIHZvbHVtZSB0byBmYWRlIHRvICgwLjAgdG8gMS4wKS5cbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGxlbiAgVGltZSBpbiBtaWxsaXNlY29uZHMgdG8gZmFkZS5cbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGlkICAgVGhlIHNvdW5kIGlkIHRvIGZhZGUuXG4gICAgICovXG4gICAgX3N0YXJ0RmFkZUludGVydmFsOiBmdW5jdGlvbihzb3VuZCwgZnJvbSwgdG8sIGxlbiwgaWQpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciB2b2wgPSBmcm9tO1xuICAgICAgdmFyIGRpciA9IGZyb20gPiB0byA/ICdvdXQnIDogJ2luJztcbiAgICAgIHZhciBkaWZmID0gTWF0aC5hYnMoZnJvbSAtIHRvKTtcbiAgICAgIHZhciBzdGVwcyA9IGRpZmYgLyAwLjAxO1xuICAgICAgdmFyIHN0ZXBMZW4gPSAoc3RlcHMgPiAwKSA/IGxlbiAvIHN0ZXBzIDogbGVuO1xuXG4gICAgICAvLyBTaW5jZSBicm93c2VycyBjbGFtcCB0aW1lb3V0cyB0byA0bXMsIHdlIG5lZWQgdG8gY2xhbXAgb3VyIHN0ZXBzIHRvIHRoYXQgdG9vLlxuICAgICAgaWYgKHN0ZXBMZW4gPCA0KSB7XG4gICAgICAgIHN0ZXBzID0gTWF0aC5jZWlsKHN0ZXBzIC8gKDQgLyBzdGVwTGVuKSk7XG4gICAgICAgIHN0ZXBMZW4gPSA0O1xuICAgICAgfVxuXG4gICAgICBzb3VuZC5faW50ZXJ2YWwgPSBzZXRJbnRlcnZhbChmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gVXBkYXRlIHRoZSB2b2x1bWUgYW1vdW50LCBidXQgb25seSBpZiB0aGUgdm9sdW1lIHNob3VsZCBjaGFuZ2UuXG4gICAgICAgIGlmIChzdGVwcyA+IDApIHtcbiAgICAgICAgICB2b2wgKz0gKGRpciA9PT0gJ2luJyA/IDAuMDEgOiAtMC4wMSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBNYWtlIHN1cmUgdGhlIHZvbHVtZSBpcyBpbiB0aGUgcmlnaHQgYm91bmRzLlxuICAgICAgICB2b2wgPSBNYXRoLm1heCgwLCB2b2wpO1xuICAgICAgICB2b2wgPSBNYXRoLm1pbigxLCB2b2wpO1xuXG4gICAgICAgIC8vIFJvdW5kIHRvIHdpdGhpbiAyIGRlY2ltYWwgcG9pbnRzLlxuICAgICAgICB2b2wgPSBNYXRoLnJvdW5kKHZvbCAqIDEwMCkgLyAxMDA7XG5cbiAgICAgICAgLy8gQ2hhbmdlIHRoZSB2b2x1bWUuXG4gICAgICAgIGlmIChzZWxmLl93ZWJBdWRpbykge1xuICAgICAgICAgIGlmICh0eXBlb2YgaWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBzZWxmLl92b2x1bWUgPSB2b2w7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc291bmQuX3ZvbHVtZSA9IHZvbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZWxmLnZvbHVtZSh2b2wsIHNvdW5kLl9pZCwgdHJ1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBXaGVuIHRoZSBmYWRlIGlzIGNvbXBsZXRlLCBzdG9wIGl0IGFuZCBmaXJlIGV2ZW50LlxuICAgICAgICBpZiAoKHRvIDwgZnJvbSAmJiB2b2wgPD0gdG8pIHx8ICh0byA+IGZyb20gJiYgdm9sID49IHRvKSkge1xuICAgICAgICAgIGNsZWFySW50ZXJ2YWwoc291bmQuX2ludGVydmFsKTtcbiAgICAgICAgICBzb3VuZC5faW50ZXJ2YWwgPSBudWxsO1xuICAgICAgICAgIHNlbGYudm9sdW1lKHRvLCBzb3VuZC5faWQpO1xuICAgICAgICAgIHNlbGYuX2VtaXQoJ2ZhZGUnLCBzb3VuZC5faWQpO1xuICAgICAgICB9XG4gICAgICB9LCBzdGVwTGVuKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSW50ZXJuYWwgbWV0aG9kIHRoYXQgc3RvcHMgdGhlIGN1cnJlbnRseSBwbGF5aW5nIGZhZGUgd2hlblxuICAgICAqIGEgbmV3IGZhZGUgc3RhcnRzLCB2b2x1bWUgaXMgY2hhbmdlZCBvciB0aGUgc291bmQgaXMgc3RvcHBlZC5cbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGlkIFRoZSBzb3VuZCBpZC5cbiAgICAgKiBAcmV0dXJuIHtIb3dsfVxuICAgICAqL1xuICAgIF9zdG9wRmFkZTogZnVuY3Rpb24oaWQpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciBzb3VuZCA9IHNlbGYuX3NvdW5kQnlJZChpZCk7XG5cbiAgICAgIGlmIChzb3VuZCAmJiBzb3VuZC5faW50ZXJ2YWwpIHtcbiAgICAgICAgaWYgKHNlbGYuX3dlYkF1ZGlvKSB7XG4gICAgICAgICAgc291bmQuX25vZGUuZ2Fpbi5jYW5jZWxTY2hlZHVsZWRWYWx1ZXMoSG93bGVyLmN0eC5jdXJyZW50VGltZSk7XG4gICAgICAgIH1cblxuICAgICAgICBjbGVhckludGVydmFsKHNvdW5kLl9pbnRlcnZhbCk7XG4gICAgICAgIHNvdW5kLl9pbnRlcnZhbCA9IG51bGw7XG4gICAgICAgIHNlbGYuX2VtaXQoJ2ZhZGUnLCBpZCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQvc2V0IHRoZSBsb29wIHBhcmFtZXRlciBvbiBhIHNvdW5kLiBUaGlzIG1ldGhvZCBjYW4gb3B0aW9uYWxseSB0YWtlIDAsIDEgb3IgMiBhcmd1bWVudHMuXG4gICAgICogICBsb29wKCkgLT4gUmV0dXJucyB0aGUgZ3JvdXAncyBsb29wIHZhbHVlLlxuICAgICAqICAgbG9vcChpZCkgLT4gUmV0dXJucyB0aGUgc291bmQgaWQncyBsb29wIHZhbHVlLlxuICAgICAqICAgbG9vcChsb29wKSAtPiBTZXRzIHRoZSBsb29wIHZhbHVlIGZvciBhbGwgc291bmRzIGluIHRoaXMgSG93bCBncm91cC5cbiAgICAgKiAgIGxvb3AobG9vcCwgaWQpIC0+IFNldHMgdGhlIGxvb3AgdmFsdWUgb2YgcGFzc2VkIHNvdW5kIGlkLlxuICAgICAqIEByZXR1cm4ge0hvd2wvQm9vbGVhbn0gUmV0dXJucyBzZWxmIG9yIGN1cnJlbnQgbG9vcCB2YWx1ZS5cbiAgICAgKi9cbiAgICBsb29wOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgdmFyIGxvb3AsIGlkLCBzb3VuZDtcblxuICAgICAgLy8gRGV0ZXJtaW5lIHRoZSB2YWx1ZXMgZm9yIGxvb3AgYW5kIGlkLlxuICAgICAgaWYgKGFyZ3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIC8vIFJldHVybiB0aGUgZ3JvdSdzIGxvb3AgdmFsdWUuXG4gICAgICAgIHJldHVybiBzZWxmLl9sb29wO1xuICAgICAgfSBlbHNlIGlmIChhcmdzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBpZiAodHlwZW9mIGFyZ3NbMF0gPT09ICdib29sZWFuJykge1xuICAgICAgICAgIGxvb3AgPSBhcmdzWzBdO1xuICAgICAgICAgIHNlbGYuX2xvb3AgPSBsb29wO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFJldHVybiB0aGlzIHNvdW5kJ3MgbG9vcCB2YWx1ZS5cbiAgICAgICAgICBzb3VuZCA9IHNlbGYuX3NvdW5kQnlJZChwYXJzZUludChhcmdzWzBdLCAxMCkpO1xuICAgICAgICAgIHJldHVybiBzb3VuZCA/IHNvdW5kLl9sb29wIDogZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoYXJncy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgbG9vcCA9IGFyZ3NbMF07XG4gICAgICAgIGlkID0gcGFyc2VJbnQoYXJnc1sxXSwgMTApO1xuICAgICAgfVxuXG4gICAgICAvLyBJZiBubyBpZCBpcyBwYXNzZWQsIGdldCBhbGwgSUQncyB0byBiZSBsb29wZWQuXG4gICAgICB2YXIgaWRzID0gc2VsZi5fZ2V0U291bmRJZHMoaWQpO1xuICAgICAgZm9yICh2YXIgaT0wOyBpPGlkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBzb3VuZCA9IHNlbGYuX3NvdW5kQnlJZChpZHNbaV0pO1xuXG4gICAgICAgIGlmIChzb3VuZCkge1xuICAgICAgICAgIHNvdW5kLl9sb29wID0gbG9vcDtcbiAgICAgICAgICBpZiAoc2VsZi5fd2ViQXVkaW8gJiYgc291bmQuX25vZGUgJiYgc291bmQuX25vZGUuYnVmZmVyU291cmNlKSB7XG4gICAgICAgICAgICBzb3VuZC5fbm9kZS5idWZmZXJTb3VyY2UubG9vcCA9IGxvb3A7XG4gICAgICAgICAgICBpZiAobG9vcCkge1xuICAgICAgICAgICAgICBzb3VuZC5fbm9kZS5idWZmZXJTb3VyY2UubG9vcFN0YXJ0ID0gc291bmQuX3N0YXJ0IHx8IDA7XG4gICAgICAgICAgICAgIHNvdW5kLl9ub2RlLmJ1ZmZlclNvdXJjZS5sb29wRW5kID0gc291bmQuX3N0b3A7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQvc2V0IHRoZSBwbGF5YmFjayByYXRlIG9mIGEgc291bmQuIFRoaXMgbWV0aG9kIGNhbiBvcHRpb25hbGx5IHRha2UgMCwgMSBvciAyIGFyZ3VtZW50cy5cbiAgICAgKiAgIHJhdGUoKSAtPiBSZXR1cm5zIHRoZSBmaXJzdCBzb3VuZCBub2RlJ3MgY3VycmVudCBwbGF5YmFjayByYXRlLlxuICAgICAqICAgcmF0ZShpZCkgLT4gUmV0dXJucyB0aGUgc291bmQgaWQncyBjdXJyZW50IHBsYXliYWNrIHJhdGUuXG4gICAgICogICByYXRlKHJhdGUpIC0+IFNldHMgdGhlIHBsYXliYWNrIHJhdGUgb2YgYWxsIHNvdW5kcyBpbiB0aGlzIEhvd2wgZ3JvdXAuXG4gICAgICogICByYXRlKHJhdGUsIGlkKSAtPiBTZXRzIHRoZSBwbGF5YmFjayByYXRlIG9mIHBhc3NlZCBzb3VuZCBpZC5cbiAgICAgKiBAcmV0dXJuIHtIb3dsL051bWJlcn0gUmV0dXJucyBzZWxmIG9yIHRoZSBjdXJyZW50IHBsYXliYWNrIHJhdGUuXG4gICAgICovXG4gICAgcmF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgIHZhciByYXRlLCBpZDtcblxuICAgICAgLy8gRGV0ZXJtaW5lIHRoZSB2YWx1ZXMgYmFzZWQgb24gYXJndW1lbnRzLlxuICAgICAgaWYgKGFyZ3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIC8vIFdlIHdpbGwgc2ltcGx5IHJldHVybiB0aGUgY3VycmVudCByYXRlIG9mIHRoZSBmaXJzdCBub2RlLlxuICAgICAgICBpZCA9IHNlbGYuX3NvdW5kc1swXS5faWQ7XG4gICAgICB9IGVsc2UgaWYgKGFyZ3MubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIC8vIEZpcnN0IGNoZWNrIGlmIHRoaXMgaXMgYW4gSUQsIGFuZCBpZiBub3QsIGFzc3VtZSBpdCBpcyBhIG5ldyByYXRlIHZhbHVlLlxuICAgICAgICB2YXIgaWRzID0gc2VsZi5fZ2V0U291bmRJZHMoKTtcbiAgICAgICAgdmFyIGluZGV4ID0gaWRzLmluZGV4T2YoYXJnc1swXSk7XG4gICAgICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAgICAgaWQgPSBwYXJzZUludChhcmdzWzBdLCAxMCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmF0ZSA9IHBhcnNlRmxvYXQoYXJnc1swXSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoYXJncy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgcmF0ZSA9IHBhcnNlRmxvYXQoYXJnc1swXSk7XG4gICAgICAgIGlkID0gcGFyc2VJbnQoYXJnc1sxXSwgMTApO1xuICAgICAgfVxuXG4gICAgICAvLyBVcGRhdGUgdGhlIHBsYXliYWNrIHJhdGUgb3IgcmV0dXJuIHRoZSBjdXJyZW50IHZhbHVlLlxuICAgICAgdmFyIHNvdW5kO1xuICAgICAgaWYgKHR5cGVvZiByYXRlID09PSAnbnVtYmVyJykge1xuICAgICAgICAvLyBJZiB0aGUgc291bmQgaGFzbid0IGxvYWRlZCwgYWRkIGl0IHRvIHRoZSBsb2FkIHF1ZXVlIHRvIGNoYW5nZSBwbGF5YmFjayByYXRlIHdoZW4gY2FwYWJsZS5cbiAgICAgICAgaWYgKHNlbGYuX3N0YXRlICE9PSAnbG9hZGVkJykge1xuICAgICAgICAgIHNlbGYuX3F1ZXVlLnB1c2goe1xuICAgICAgICAgICAgZXZlbnQ6ICdyYXRlJyxcbiAgICAgICAgICAgIGFjdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHNlbGYucmF0ZS5hcHBseShzZWxmLCBhcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2V0IHRoZSBncm91cCByYXRlLlxuICAgICAgICBpZiAodHlwZW9mIGlkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHNlbGYuX3JhdGUgPSByYXRlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVXBkYXRlIG9uZSBvciBhbGwgdm9sdW1lcy5cbiAgICAgICAgaWQgPSBzZWxmLl9nZXRTb3VuZElkcyhpZCk7XG4gICAgICAgIGZvciAodmFyIGk9MDsgaTxpZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIC8vIEdldCB0aGUgc291bmQuXG4gICAgICAgICAgc291bmQgPSBzZWxmLl9zb3VuZEJ5SWQoaWRbaV0pO1xuXG4gICAgICAgICAgaWYgKHNvdW5kKSB7XG4gICAgICAgICAgICAvLyBLZWVwIHRyYWNrIG9mIG91ciBwb3NpdGlvbiB3aGVuIHRoZSByYXRlIGNoYW5nZWQgYW5kIHVwZGF0ZSB0aGUgcGxheWJhY2tcbiAgICAgICAgICAgIC8vIHN0YXJ0IHBvc2l0aW9uIHNvIHdlIGNhbiBwcm9wZXJseSBhZGp1c3QgdGhlIHNlZWsgcG9zaXRpb24gZm9yIHRpbWUgZWxhcHNlZC5cbiAgICAgICAgICAgIHNvdW5kLl9yYXRlU2VlayA9IHNlbGYuc2VlayhpZFtpXSk7XG4gICAgICAgICAgICBzb3VuZC5fcGxheVN0YXJ0ID0gc2VsZi5fd2ViQXVkaW8gPyBIb3dsZXIuY3R4LmN1cnJlbnRUaW1lIDogc291bmQuX3BsYXlTdGFydDtcbiAgICAgICAgICAgIHNvdW5kLl9yYXRlID0gcmF0ZTtcblxuICAgICAgICAgICAgLy8gQ2hhbmdlIHRoZSBwbGF5YmFjayByYXRlLlxuICAgICAgICAgICAgaWYgKHNlbGYuX3dlYkF1ZGlvICYmIHNvdW5kLl9ub2RlICYmIHNvdW5kLl9ub2RlLmJ1ZmZlclNvdXJjZSkge1xuICAgICAgICAgICAgICBzb3VuZC5fbm9kZS5idWZmZXJTb3VyY2UucGxheWJhY2tSYXRlLnZhbHVlID0gcmF0ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc291bmQuX25vZGUpIHtcbiAgICAgICAgICAgICAgc291bmQuX25vZGUucGxheWJhY2tSYXRlID0gcmF0ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gUmVzZXQgdGhlIHRpbWVycy5cbiAgICAgICAgICAgIHZhciBzZWVrID0gc2VsZi5zZWVrKGlkW2ldKTtcbiAgICAgICAgICAgIHZhciBkdXJhdGlvbiA9ICgoc2VsZi5fc3ByaXRlW3NvdW5kLl9zcHJpdGVdWzBdICsgc2VsZi5fc3ByaXRlW3NvdW5kLl9zcHJpdGVdWzFdKSAvIDEwMDApIC0gc2VlaztcbiAgICAgICAgICAgIHZhciB0aW1lb3V0ID0gKGR1cmF0aW9uICogMTAwMCkgLyBNYXRoLmFicyhzb3VuZC5fcmF0ZSk7XG5cbiAgICAgICAgICAgIC8vIFN0YXJ0IGEgbmV3IGVuZCB0aW1lciBpZiBzb3VuZCBpcyBhbHJlYWR5IHBsYXlpbmcuXG4gICAgICAgICAgICBpZiAoc2VsZi5fZW5kVGltZXJzW2lkW2ldXSB8fCAhc291bmQuX3BhdXNlZCkge1xuICAgICAgICAgICAgICBzZWxmLl9jbGVhclRpbWVyKGlkW2ldKTtcbiAgICAgICAgICAgICAgc2VsZi5fZW5kVGltZXJzW2lkW2ldXSA9IHNldFRpbWVvdXQoc2VsZi5fZW5kZWQuYmluZChzZWxmLCBzb3VuZCksIHRpbWVvdXQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzZWxmLl9lbWl0KCdyYXRlJywgc291bmQuX2lkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNvdW5kID0gc2VsZi5fc291bmRCeUlkKGlkKTtcbiAgICAgICAgcmV0dXJuIHNvdW5kID8gc291bmQuX3JhdGUgOiBzZWxmLl9yYXRlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0L3NldCB0aGUgc2VlayBwb3NpdGlvbiBvZiBhIHNvdW5kLiBUaGlzIG1ldGhvZCBjYW4gb3B0aW9uYWxseSB0YWtlIDAsIDEgb3IgMiBhcmd1bWVudHMuXG4gICAgICogICBzZWVrKCkgLT4gUmV0dXJucyB0aGUgZmlyc3Qgc291bmQgbm9kZSdzIGN1cnJlbnQgc2VlayBwb3NpdGlvbi5cbiAgICAgKiAgIHNlZWsoaWQpIC0+IFJldHVybnMgdGhlIHNvdW5kIGlkJ3MgY3VycmVudCBzZWVrIHBvc2l0aW9uLlxuICAgICAqICAgc2VlayhzZWVrKSAtPiBTZXRzIHRoZSBzZWVrIHBvc2l0aW9uIG9mIHRoZSBmaXJzdCBzb3VuZCBub2RlLlxuICAgICAqICAgc2VlayhzZWVrLCBpZCkgLT4gU2V0cyB0aGUgc2VlayBwb3NpdGlvbiBvZiBwYXNzZWQgc291bmQgaWQuXG4gICAgICogQHJldHVybiB7SG93bC9OdW1iZXJ9IFJldHVybnMgc2VsZiBvciB0aGUgY3VycmVudCBzZWVrIHBvc2l0aW9uLlxuICAgICAqL1xuICAgIHNlZWs6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICB2YXIgc2VlaywgaWQ7XG5cbiAgICAgIC8vIERldGVybWluZSB0aGUgdmFsdWVzIGJhc2VkIG9uIGFyZ3VtZW50cy5cbiAgICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAvLyBXZSB3aWxsIHNpbXBseSByZXR1cm4gdGhlIGN1cnJlbnQgcG9zaXRpb24gb2YgdGhlIGZpcnN0IG5vZGUuXG4gICAgICAgIGlkID0gc2VsZi5fc291bmRzWzBdLl9pZDtcbiAgICAgIH0gZWxzZSBpZiAoYXJncy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgLy8gRmlyc3QgY2hlY2sgaWYgdGhpcyBpcyBhbiBJRCwgYW5kIGlmIG5vdCwgYXNzdW1lIGl0IGlzIGEgbmV3IHNlZWsgcG9zaXRpb24uXG4gICAgICAgIHZhciBpZHMgPSBzZWxmLl9nZXRTb3VuZElkcygpO1xuICAgICAgICB2YXIgaW5kZXggPSBpZHMuaW5kZXhPZihhcmdzWzBdKTtcbiAgICAgICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgICBpZCA9IHBhcnNlSW50KGFyZ3NbMF0sIDEwKTtcbiAgICAgICAgfSBlbHNlIGlmIChzZWxmLl9zb3VuZHMubGVuZ3RoKSB7XG4gICAgICAgICAgaWQgPSBzZWxmLl9zb3VuZHNbMF0uX2lkO1xuICAgICAgICAgIHNlZWsgPSBwYXJzZUZsb2F0KGFyZ3NbMF0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGFyZ3MubGVuZ3RoID09PSAyKSB7XG4gICAgICAgIHNlZWsgPSBwYXJzZUZsb2F0KGFyZ3NbMF0pO1xuICAgICAgICBpZCA9IHBhcnNlSW50KGFyZ3NbMV0sIDEwKTtcbiAgICAgIH1cblxuICAgICAgLy8gSWYgdGhlcmUgaXMgbm8gSUQsIGJhaWwgb3V0LlxuICAgICAgaWYgKHR5cGVvZiBpZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICB9XG5cbiAgICAgIC8vIElmIHRoZSBzb3VuZCBoYXNuJ3QgbG9hZGVkLCBhZGQgaXQgdG8gdGhlIGxvYWQgcXVldWUgdG8gc2VlayB3aGVuIGNhcGFibGUuXG4gICAgICBpZiAoc2VsZi5fc3RhdGUgIT09ICdsb2FkZWQnKSB7XG4gICAgICAgIHNlbGYuX3F1ZXVlLnB1c2goe1xuICAgICAgICAgIGV2ZW50OiAnc2VlaycsXG4gICAgICAgICAgYWN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHNlbGYuc2Vlay5hcHBseShzZWxmLCBhcmdzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgfVxuXG4gICAgICAvLyBHZXQgdGhlIHNvdW5kLlxuICAgICAgdmFyIHNvdW5kID0gc2VsZi5fc291bmRCeUlkKGlkKTtcblxuICAgICAgaWYgKHNvdW5kKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2VlayA9PT0gJ251bWJlcicgJiYgc2VlayA+PSAwKSB7XG4gICAgICAgICAgLy8gUGF1c2UgdGhlIHNvdW5kIGFuZCB1cGRhdGUgcG9zaXRpb24gZm9yIHJlc3RhcnRpbmcgcGxheWJhY2suXG4gICAgICAgICAgdmFyIHBsYXlpbmcgPSBzZWxmLnBsYXlpbmcoaWQpO1xuICAgICAgICAgIGlmIChwbGF5aW5nKSB7XG4gICAgICAgICAgICBzZWxmLnBhdXNlKGlkLCB0cnVlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBNb3ZlIHRoZSBwb3NpdGlvbiBvZiB0aGUgdHJhY2sgYW5kIGNhbmNlbCB0aW1lci5cbiAgICAgICAgICBzb3VuZC5fc2VlayA9IHNlZWs7XG4gICAgICAgICAgc291bmQuX2VuZGVkID0gZmFsc2U7XG4gICAgICAgICAgc2VsZi5fY2xlYXJUaW1lcihpZCk7XG5cbiAgICAgICAgICAvLyBSZXN0YXJ0IHRoZSBwbGF5YmFjayBpZiB0aGUgc291bmQgd2FzIHBsYXlpbmcuXG4gICAgICAgICAgaWYgKHBsYXlpbmcpIHtcbiAgICAgICAgICAgIHNlbGYucGxheShpZCwgdHJ1ZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gVXBkYXRlIHRoZSBzZWVrIHBvc2l0aW9uIGZvciBIVE1MNSBBdWRpby5cbiAgICAgICAgICBpZiAoIXNlbGYuX3dlYkF1ZGlvICYmIHNvdW5kLl9ub2RlKSB7XG4gICAgICAgICAgICBzb3VuZC5fbm9kZS5jdXJyZW50VGltZSA9IHNlZWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc2VsZi5fZW1pdCgnc2VlaycsIGlkKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoc2VsZi5fd2ViQXVkaW8pIHtcbiAgICAgICAgICAgIHZhciByZWFsVGltZSA9IHNlbGYucGxheWluZyhpZCkgPyBIb3dsZXIuY3R4LmN1cnJlbnRUaW1lIC0gc291bmQuX3BsYXlTdGFydCA6IDA7XG4gICAgICAgICAgICB2YXIgcmF0ZVNlZWsgPSBzb3VuZC5fcmF0ZVNlZWsgPyBzb3VuZC5fcmF0ZVNlZWsgLSBzb3VuZC5fc2VlayA6IDA7XG4gICAgICAgICAgICByZXR1cm4gc291bmQuX3NlZWsgKyAocmF0ZVNlZWsgKyByZWFsVGltZSAqIE1hdGguYWJzKHNvdW5kLl9yYXRlKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBzb3VuZC5fbm9kZS5jdXJyZW50VGltZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIGEgc3BlY2lmaWMgc291bmQgaXMgY3VycmVudGx5IHBsYXlpbmcgb3Igbm90IChpZiBpZCBpcyBwcm92aWRlZCksIG9yIGNoZWNrIGlmIGF0IGxlYXN0IG9uZSBvZiB0aGUgc291bmRzIGluIHRoZSBncm91cCBpcyBwbGF5aW5nIG9yIG5vdC5cbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9ICBpZCBUaGUgc291bmQgaWQgdG8gY2hlY2suIElmIG5vbmUgaXMgcGFzc2VkLCB0aGUgd2hvbGUgc291bmQgZ3JvdXAgaXMgY2hlY2tlZC5cbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBUcnVlIGlmIHBsYXlpbmcgYW5kIGZhbHNlIGlmIG5vdC5cbiAgICAgKi9cbiAgICBwbGF5aW5nOiBmdW5jdGlvbihpZCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAvLyBDaGVjayB0aGUgcGFzc2VkIHNvdW5kIElEIChpZiBhbnkpLlxuICAgICAgaWYgKHR5cGVvZiBpZCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgdmFyIHNvdW5kID0gc2VsZi5fc291bmRCeUlkKGlkKTtcbiAgICAgICAgcmV0dXJuIHNvdW5kID8gIXNvdW5kLl9wYXVzZWQgOiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgLy8gT3RoZXJ3aXNlLCBsb29wIHRocm91Z2ggYWxsIHNvdW5kcyBhbmQgY2hlY2sgaWYgYW55IGFyZSBwbGF5aW5nLlxuICAgICAgZm9yICh2YXIgaT0wOyBpPHNlbGYuX3NvdW5kcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoIXNlbGYuX3NvdW5kc1tpXS5fcGF1c2VkKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGR1cmF0aW9uIG9mIHRoaXMgc291bmQuIFBhc3NpbmcgYSBzb3VuZCBpZCB3aWxsIHJldHVybiB0aGUgc3ByaXRlIGR1cmF0aW9uLlxuICAgICAqIEBwYXJhbSAge051bWJlcn0gaWQgVGhlIHNvdW5kIGlkIHRvIGNoZWNrLiBJZiBub25lIGlzIHBhc3NlZCwgcmV0dXJuIGZ1bGwgc291cmNlIGR1cmF0aW9uLlxuICAgICAqIEByZXR1cm4ge051bWJlcn0gQXVkaW8gZHVyYXRpb24gaW4gc2Vjb25kcy5cbiAgICAgKi9cbiAgICBkdXJhdGlvbjogZnVuY3Rpb24oaWQpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciBkdXJhdGlvbiA9IHNlbGYuX2R1cmF0aW9uO1xuXG4gICAgICAvLyBJZiB3ZSBwYXNzIGFuIElELCBnZXQgdGhlIHNvdW5kIGFuZCByZXR1cm4gdGhlIHNwcml0ZSBsZW5ndGguXG4gICAgICB2YXIgc291bmQgPSBzZWxmLl9zb3VuZEJ5SWQoaWQpO1xuICAgICAgaWYgKHNvdW5kKSB7XG4gICAgICAgIGR1cmF0aW9uID0gc2VsZi5fc3ByaXRlW3NvdW5kLl9zcHJpdGVdWzFdIC8gMTAwMDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGR1cmF0aW9uO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IGxvYWRlZCBzdGF0ZSBvZiB0aGlzIEhvd2wuXG4gICAgICogQHJldHVybiB7U3RyaW5nfSAndW5sb2FkZWQnLCAnbG9hZGluZycsICdsb2FkZWQnXG4gICAgICovXG4gICAgc3RhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3N0YXRlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBVbmxvYWQgYW5kIGRlc3Ryb3kgdGhlIGN1cnJlbnQgSG93bCBvYmplY3QuXG4gICAgICogVGhpcyB3aWxsIGltbWVkaWF0ZWx5IHN0b3AgYWxsIHNvdW5kIGluc3RhbmNlcyBhdHRhY2hlZCB0byB0aGlzIGdyb3VwLlxuICAgICAqL1xuICAgIHVubG9hZDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgIC8vIFN0b3AgcGxheWluZyBhbnkgYWN0aXZlIHNvdW5kcy5cbiAgICAgIHZhciBzb3VuZHMgPSBzZWxmLl9zb3VuZHM7XG4gICAgICBmb3IgKHZhciBpPTA7IGk8c291bmRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIC8vIFN0b3AgdGhlIHNvdW5kIGlmIGl0IGlzIGN1cnJlbnRseSBwbGF5aW5nLlxuICAgICAgICBpZiAoIXNvdW5kc1tpXS5fcGF1c2VkKSB7XG4gICAgICAgICAgc2VsZi5zdG9wKHNvdW5kc1tpXS5faWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmVtb3ZlIHRoZSBzb3VyY2Ugb3IgZGlzY29ubmVjdC5cbiAgICAgICAgaWYgKCFzZWxmLl93ZWJBdWRpbykge1xuICAgICAgICAgIC8vIFNldCB0aGUgc291cmNlIHRvIDAtc2Vjb25kIHNpbGVuY2UgdG8gc3RvcCBhbnkgZG93bmxvYWRpbmcgKGV4Y2VwdCBpbiBJRSkuXG4gICAgICAgICAgdmFyIGNoZWNrSUUgPSAvTVNJRSB8VHJpZGVudFxcLy8udGVzdChIb3dsZXIuX25hdmlnYXRvciAmJiBIb3dsZXIuX25hdmlnYXRvci51c2VyQWdlbnQpO1xuICAgICAgICAgIGlmICghY2hlY2tJRSkge1xuICAgICAgICAgICAgc291bmRzW2ldLl9ub2RlLnNyYyA9ICdkYXRhOmF1ZGlvL3dhdjtiYXNlNjQsVWtsR1JpZ0FBQUJYUVZaRlptMTBJQklBQUFBQkFBRUFSS3dBQUloWUFRQUNBQkFBQUFCa1lYUmhBZ0FBQUFFQSc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gUmVtb3ZlIGFueSBldmVudCBsaXN0ZW5lcnMuXG4gICAgICAgICAgc291bmRzW2ldLl9ub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgc291bmRzW2ldLl9lcnJvckZuLCBmYWxzZSk7XG4gICAgICAgICAgc291bmRzW2ldLl9ub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoSG93bGVyLl9jYW5QbGF5RXZlbnQsIHNvdW5kc1tpXS5fbG9hZEZuLCBmYWxzZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBFbXB0eSBvdXQgYWxsIG9mIHRoZSBub2Rlcy5cbiAgICAgICAgZGVsZXRlIHNvdW5kc1tpXS5fbm9kZTtcblxuICAgICAgICAvLyBNYWtlIHN1cmUgYWxsIHRpbWVycyBhcmUgY2xlYXJlZCBvdXQuXG4gICAgICAgIHNlbGYuX2NsZWFyVGltZXIoc291bmRzW2ldLl9pZCk7XG5cbiAgICAgICAgLy8gUmVtb3ZlIHRoZSByZWZlcmVuY2VzIGluIHRoZSBnbG9iYWwgSG93bGVyIG9iamVjdC5cbiAgICAgICAgdmFyIGluZGV4ID0gSG93bGVyLl9ob3dscy5pbmRleE9mKHNlbGYpO1xuICAgICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICAgIEhvd2xlci5faG93bHMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBEZWxldGUgdGhpcyBzb3VuZCBmcm9tIHRoZSBjYWNoZSAoaWYgbm8gb3RoZXIgSG93bCBpcyB1c2luZyBpdCkuXG4gICAgICB2YXIgcmVtQ2FjaGUgPSB0cnVlO1xuICAgICAgZm9yIChpPTA7IGk8SG93bGVyLl9ob3dscy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoSG93bGVyLl9ob3dsc1tpXS5fc3JjID09PSBzZWxmLl9zcmMpIHtcbiAgICAgICAgICByZW1DYWNoZSA9IGZhbHNlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChjYWNoZSAmJiByZW1DYWNoZSkge1xuICAgICAgICBkZWxldGUgY2FjaGVbc2VsZi5fc3JjXTtcbiAgICAgIH1cblxuICAgICAgLy8gQ2xlYXIgZ2xvYmFsIGVycm9ycy5cbiAgICAgIEhvd2xlci5ub0F1ZGlvID0gZmFsc2U7XG5cbiAgICAgIC8vIENsZWFyIG91dCBgc2VsZmAuXG4gICAgICBzZWxmLl9zdGF0ZSA9ICd1bmxvYWRlZCc7XG4gICAgICBzZWxmLl9zb3VuZHMgPSBbXTtcbiAgICAgIHNlbGYgPSBudWxsO1xuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTGlzdGVuIHRvIGEgY3VzdG9tIGV2ZW50LlxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gICBldmVudCBFdmVudCBuYW1lLlxuICAgICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBmbiAgICBMaXN0ZW5lciB0byBjYWxsLlxuICAgICAqIEBwYXJhbSAge051bWJlcn0gICBpZCAgICAob3B0aW9uYWwpIE9ubHkgbGlzdGVuIHRvIGV2ZW50cyBmb3IgdGhpcyBzb3VuZC5cbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9ICAgb25jZSAgKElOVEVSTkFMKSBNYXJrcyBldmVudCB0byBmaXJlIG9ubHkgb25jZS5cbiAgICAgKiBAcmV0dXJuIHtIb3dsfVxuICAgICAqL1xuICAgIG9uOiBmdW5jdGlvbihldmVudCwgZm4sIGlkLCBvbmNlKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgZXZlbnRzID0gc2VsZlsnX29uJyArIGV2ZW50XTtcblxuICAgICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBldmVudHMucHVzaChvbmNlID8ge2lkOiBpZCwgZm46IGZuLCBvbmNlOiBvbmNlfSA6IHtpZDogaWQsIGZuOiBmbn0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGEgY3VzdG9tIGV2ZW50LiBDYWxsIHdpdGhvdXQgcGFyYW1ldGVycyB0byByZW1vdmUgYWxsIGV2ZW50cy5cbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9ICAgZXZlbnQgRXZlbnQgbmFtZS5cbiAgICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gZm4gICAgTGlzdGVuZXIgdG8gcmVtb3ZlLiBMZWF2ZSBlbXB0eSB0byByZW1vdmUgYWxsLlxuICAgICAqIEBwYXJhbSAge051bWJlcn0gICBpZCAgICAob3B0aW9uYWwpIE9ubHkgcmVtb3ZlIGV2ZW50cyBmb3IgdGhpcyBzb3VuZC5cbiAgICAgKiBAcmV0dXJuIHtIb3dsfVxuICAgICAqL1xuICAgIG9mZjogZnVuY3Rpb24oZXZlbnQsIGZuLCBpZCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIGV2ZW50cyA9IHNlbGZbJ19vbicgKyBldmVudF07XG4gICAgICB2YXIgaSA9IDA7XG5cbiAgICAgIC8vIEFsbG93IHBhc3NpbmcganVzdCBhbiBldmVudCBhbmQgSUQuXG4gICAgICBpZiAodHlwZW9mIGZuID09PSAnbnVtYmVyJykge1xuICAgICAgICBpZCA9IGZuO1xuICAgICAgICBmbiA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIGlmIChmbiB8fCBpZCkge1xuICAgICAgICAvLyBMb29wIHRocm91Z2ggZXZlbnQgc3RvcmUgYW5kIHJlbW92ZSB0aGUgcGFzc2VkIGZ1bmN0aW9uLlxuICAgICAgICBmb3IgKGk9MDsgaTxldmVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgaXNJZCA9IChpZCA9PT0gZXZlbnRzW2ldLmlkKTtcbiAgICAgICAgICBpZiAoZm4gPT09IGV2ZW50c1tpXS5mbiAmJiBpc0lkIHx8ICFmbiAmJiBpc0lkKSB7XG4gICAgICAgICAgICBldmVudHMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGV2ZW50KSB7XG4gICAgICAgIC8vIENsZWFyIG91dCBhbGwgZXZlbnRzIG9mIHRoaXMgdHlwZS5cbiAgICAgICAgc2VsZlsnX29uJyArIGV2ZW50XSA9IFtdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQ2xlYXIgb3V0IGFsbCBldmVudHMgb2YgZXZlcnkgdHlwZS5cbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhzZWxmKTtcbiAgICAgICAgZm9yIChpPTA7IGk8a2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmICgoa2V5c1tpXS5pbmRleE9mKCdfb24nKSA9PT0gMCkgJiYgQXJyYXkuaXNBcnJheShzZWxmW2tleXNbaV1dKSkge1xuICAgICAgICAgICAgc2VsZltrZXlzW2ldXSA9IFtdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTGlzdGVuIHRvIGEgY3VzdG9tIGV2ZW50IGFuZCByZW1vdmUgaXQgb25jZSBmaXJlZC5cbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9ICAgZXZlbnQgRXZlbnQgbmFtZS5cbiAgICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gZm4gICAgTGlzdGVuZXIgdG8gY2FsbC5cbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9ICAgaWQgICAgKG9wdGlvbmFsKSBPbmx5IGxpc3RlbiB0byBldmVudHMgZm9yIHRoaXMgc291bmQuXG4gICAgICogQHJldHVybiB7SG93bH1cbiAgICAgKi9cbiAgICBvbmNlOiBmdW5jdGlvbihldmVudCwgZm4sIGlkKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgIC8vIFNldHVwIHRoZSBldmVudCBsaXN0ZW5lci5cbiAgICAgIHNlbGYub24oZXZlbnQsIGZuLCBpZCwgMSk7XG5cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBFbWl0IGFsbCBldmVudHMgb2YgYSBzcGVjaWZpYyB0eXBlIGFuZCBwYXNzIHRoZSBzb3VuZCBpZC5cbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IGV2ZW50IEV2ZW50IG5hbWUuXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBpZCAgICBTb3VuZCBJRC5cbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IG1zZyAgIE1lc3NhZ2UgdG8gZ28gd2l0aCBldmVudC5cbiAgICAgKiBAcmV0dXJuIHtIb3dsfVxuICAgICAqL1xuICAgIF9lbWl0OiBmdW5jdGlvbihldmVudCwgaWQsIG1zZykge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIGV2ZW50cyA9IHNlbGZbJ19vbicgKyBldmVudF07XG5cbiAgICAgIC8vIExvb3AgdGhyb3VnaCBldmVudCBzdG9yZSBhbmQgZmlyZSBhbGwgZnVuY3Rpb25zLlxuICAgICAgZm9yICh2YXIgaT1ldmVudHMubGVuZ3RoLTE7IGk+PTA7IGktLSkge1xuICAgICAgICBpZiAoIWV2ZW50c1tpXS5pZCB8fCBldmVudHNbaV0uaWQgPT09IGlkIHx8IGV2ZW50ID09PSAnbG9hZCcpIHtcbiAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKGZuKSB7XG4gICAgICAgICAgICBmbi5jYWxsKHRoaXMsIGlkLCBtc2cpO1xuICAgICAgICAgIH0uYmluZChzZWxmLCBldmVudHNbaV0uZm4pLCAwKTtcblxuICAgICAgICAgIC8vIElmIHRoaXMgZXZlbnQgd2FzIHNldHVwIHdpdGggYG9uY2VgLCByZW1vdmUgaXQuXG4gICAgICAgICAgaWYgKGV2ZW50c1tpXS5vbmNlKSB7XG4gICAgICAgICAgICBzZWxmLm9mZihldmVudCwgZXZlbnRzW2ldLmZuLCBldmVudHNbaV0uaWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUXVldWUgb2YgYWN0aW9ucyBpbml0aWF0ZWQgYmVmb3JlIHRoZSBzb3VuZCBoYXMgbG9hZGVkLlxuICAgICAqIFRoZXNlIHdpbGwgYmUgY2FsbGVkIGluIHNlcXVlbmNlLCB3aXRoIHRoZSBuZXh0IG9ubHkgZmlyaW5nXG4gICAgICogYWZ0ZXIgdGhlIHByZXZpb3VzIGhhcyBmaW5pc2hlZCBleGVjdXRpbmcgKGV2ZW4gaWYgYXN5bmMgbGlrZSBwbGF5KS5cbiAgICAgKiBAcmV0dXJuIHtIb3dsfVxuICAgICAqL1xuICAgIF9sb2FkUXVldWU6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICBpZiAoc2VsZi5fcXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgICB2YXIgdGFzayA9IHNlbGYuX3F1ZXVlWzBdO1xuXG4gICAgICAgIC8vIGRvbid0IG1vdmUgb250byB0aGUgbmV4dCB0YXNrIHVudGlsIHRoaXMgb25lIGlzIGRvbmVcbiAgICAgICAgc2VsZi5vbmNlKHRhc2suZXZlbnQsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHNlbGYuX3F1ZXVlLnNoaWZ0KCk7XG4gICAgICAgICAgc2VsZi5fbG9hZFF1ZXVlKCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRhc2suYWN0aW9uKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGaXJlZCB3aGVuIHBsYXliYWNrIGVuZHMgYXQgdGhlIGVuZCBvZiB0aGUgZHVyYXRpb24uXG4gICAgICogQHBhcmFtICB7U291bmR9IHNvdW5kIFRoZSBzb3VuZCBvYmplY3QgdG8gd29yayB3aXRoLlxuICAgICAqIEByZXR1cm4ge0hvd2x9XG4gICAgICovXG4gICAgX2VuZGVkOiBmdW5jdGlvbihzb3VuZCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIHNwcml0ZSA9IHNvdW5kLl9zcHJpdGU7XG5cbiAgICAgIC8vIElmIHdlIGFyZSB1c2luZyBJRSBhbmQgdGhlcmUgd2FzIG5ldHdvcmsgbGF0ZW5jeSB3ZSBtYXkgYmUgY2xpcHBpbmdcbiAgICAgIC8vIGF1ZGlvIGJlZm9yZSBpdCBjb21wbGV0ZXMgcGxheWluZy4gTGV0cyBjaGVjayB0aGUgbm9kZSB0byBtYWtlIHN1cmUgaXRcbiAgICAgIC8vIGJlbGlldmVzIGl0IGhhcyBjb21wbGV0ZWQsIGJlZm9yZSBlbmRpbmcgdGhlIHBsYXliYWNrLlxuICAgICAgaWYgKCFzZWxmLl93ZWJBdWRpbyAmJiBzb3VuZC5fbm9kZSAmJiAhc291bmQuX25vZGUucGF1c2VkKSB7XG4gICAgICAgIHNldFRpbWVvdXQoc2VsZi5fZW5kZWQuYmluZChzZWxmLCBzb3VuZCksIDEwMCk7XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgfVxuXG4gICAgICAvLyBTaG91bGQgdGhpcyBzb3VuZCBsb29wP1xuICAgICAgdmFyIGxvb3AgPSAhIShzb3VuZC5fbG9vcCB8fCBzZWxmLl9zcHJpdGVbc3ByaXRlXVsyXSk7XG5cbiAgICAgIC8vIEZpcmUgdGhlIGVuZGVkIGV2ZW50LlxuICAgICAgc2VsZi5fZW1pdCgnZW5kJywgc291bmQuX2lkKTtcblxuICAgICAgLy8gUmVzdGFydCB0aGUgcGxheWJhY2sgZm9yIEhUTUw1IEF1ZGlvIGxvb3AuXG4gICAgICBpZiAoIXNlbGYuX3dlYkF1ZGlvICYmIGxvb3ApIHtcbiAgICAgICAgc2VsZi5zdG9wKHNvdW5kLl9pZCwgdHJ1ZSkucGxheShzb3VuZC5faWQpO1xuICAgICAgfVxuXG4gICAgICAvLyBSZXN0YXJ0IHRoaXMgdGltZXIgaWYgb24gYSBXZWIgQXVkaW8gbG9vcC5cbiAgICAgIGlmIChzZWxmLl93ZWJBdWRpbyAmJiBsb29wKSB7XG4gICAgICAgIHNlbGYuX2VtaXQoJ3BsYXknLCBzb3VuZC5faWQpO1xuICAgICAgICBzb3VuZC5fc2VlayA9IHNvdW5kLl9zdGFydCB8fCAwO1xuICAgICAgICBzb3VuZC5fcmF0ZVNlZWsgPSAwO1xuICAgICAgICBzb3VuZC5fcGxheVN0YXJ0ID0gSG93bGVyLmN0eC5jdXJyZW50VGltZTtcblxuICAgICAgICB2YXIgdGltZW91dCA9ICgoc291bmQuX3N0b3AgLSBzb3VuZC5fc3RhcnQpICogMTAwMCkgLyBNYXRoLmFicyhzb3VuZC5fcmF0ZSk7XG4gICAgICAgIHNlbGYuX2VuZFRpbWVyc1tzb3VuZC5faWRdID0gc2V0VGltZW91dChzZWxmLl9lbmRlZC5iaW5kKHNlbGYsIHNvdW5kKSwgdGltZW91dCk7XG4gICAgICB9XG5cbiAgICAgIC8vIE1hcmsgdGhlIG5vZGUgYXMgcGF1c2VkLlxuICAgICAgaWYgKHNlbGYuX3dlYkF1ZGlvICYmICFsb29wKSB7XG4gICAgICAgIHNvdW5kLl9wYXVzZWQgPSB0cnVlO1xuICAgICAgICBzb3VuZC5fZW5kZWQgPSB0cnVlO1xuICAgICAgICBzb3VuZC5fc2VlayA9IHNvdW5kLl9zdGFydCB8fCAwO1xuICAgICAgICBzb3VuZC5fcmF0ZVNlZWsgPSAwO1xuICAgICAgICBzZWxmLl9jbGVhclRpbWVyKHNvdW5kLl9pZCk7XG5cbiAgICAgICAgLy8gQ2xlYW4gdXAgdGhlIGJ1ZmZlciBzb3VyY2UuXG4gICAgICAgIHNlbGYuX2NsZWFuQnVmZmVyKHNvdW5kLl9ub2RlKTtcblxuICAgICAgICAvLyBBdHRlbXB0IHRvIGF1dG8tc3VzcGVuZCBBdWRpb0NvbnRleHQgaWYgbm8gc291bmRzIGFyZSBzdGlsbCBwbGF5aW5nLlxuICAgICAgICBIb3dsZXIuX2F1dG9TdXNwZW5kKCk7XG4gICAgICB9XG5cbiAgICAgIC8vIFdoZW4gdXNpbmcgYSBzcHJpdGUsIGVuZCB0aGUgdHJhY2suXG4gICAgICBpZiAoIXNlbGYuX3dlYkF1ZGlvICYmICFsb29wKSB7XG4gICAgICAgIHNlbGYuc3RvcChzb3VuZC5faWQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2xlYXIgdGhlIGVuZCB0aW1lciBmb3IgYSBzb3VuZCBwbGF5YmFjay5cbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGlkIFRoZSBzb3VuZCBJRC5cbiAgICAgKiBAcmV0dXJuIHtIb3dsfVxuICAgICAqL1xuICAgIF9jbGVhclRpbWVyOiBmdW5jdGlvbihpZCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICBpZiAoc2VsZi5fZW5kVGltZXJzW2lkXSkge1xuICAgICAgICBjbGVhclRpbWVvdXQoc2VsZi5fZW5kVGltZXJzW2lkXSk7XG4gICAgICAgIGRlbGV0ZSBzZWxmLl9lbmRUaW1lcnNbaWRdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBzb3VuZCBpZGVudGlmaWVkIGJ5IHRoaXMgSUQsIG9yIHJldHVybiBudWxsLlxuICAgICAqIEBwYXJhbSAge051bWJlcn0gaWQgU291bmQgSURcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9ICAgIFNvdW5kIG9iamVjdCBvciBudWxsLlxuICAgICAqL1xuICAgIF9zb3VuZEJ5SWQ6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgIC8vIExvb3AgdGhyb3VnaCBhbGwgc291bmRzIGFuZCBmaW5kIHRoZSBvbmUgd2l0aCB0aGlzIElELlxuICAgICAgZm9yICh2YXIgaT0wOyBpPHNlbGYuX3NvdW5kcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoaWQgPT09IHNlbGYuX3NvdW5kc1tpXS5faWQpIHtcbiAgICAgICAgICByZXR1cm4gc2VsZi5fc291bmRzW2ldO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYW4gaW5hY3RpdmUgc291bmQgZnJvbSB0aGUgcG9vbCBvciBjcmVhdGUgYSBuZXcgb25lLlxuICAgICAqIEByZXR1cm4ge1NvdW5kfSBTb3VuZCBwbGF5YmFjayBvYmplY3QuXG4gICAgICovXG4gICAgX2luYWN0aXZlU291bmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICBzZWxmLl9kcmFpbigpO1xuXG4gICAgICAvLyBGaW5kIHRoZSBmaXJzdCBpbmFjdGl2ZSBub2RlIHRvIHJlY3ljbGUuXG4gICAgICBmb3IgKHZhciBpPTA7IGk8c2VsZi5fc291bmRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChzZWxmLl9zb3VuZHNbaV0uX2VuZGVkKSB7XG4gICAgICAgICAgcmV0dXJuIHNlbGYuX3NvdW5kc1tpXS5yZXNldCgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIElmIG5vIGluYWN0aXZlIG5vZGUgd2FzIGZvdW5kLCBjcmVhdGUgYSBuZXcgb25lLlxuICAgICAgcmV0dXJuIG5ldyBTb3VuZChzZWxmKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRHJhaW4gZXhjZXNzIGluYWN0aXZlIHNvdW5kcyBmcm9tIHRoZSBwb29sLlxuICAgICAqL1xuICAgIF9kcmFpbjogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgbGltaXQgPSBzZWxmLl9wb29sO1xuICAgICAgdmFyIGNudCA9IDA7XG4gICAgICB2YXIgaSA9IDA7XG5cbiAgICAgIC8vIElmIHRoZXJlIGFyZSBsZXNzIHNvdW5kcyB0aGFuIHRoZSBtYXggcG9vbCBzaXplLCB3ZSBhcmUgZG9uZS5cbiAgICAgIGlmIChzZWxmLl9zb3VuZHMubGVuZ3RoIDwgbGltaXQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBDb3VudCB0aGUgbnVtYmVyIG9mIGluYWN0aXZlIHNvdW5kcy5cbiAgICAgIGZvciAoaT0wOyBpPHNlbGYuX3NvdW5kcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoc2VsZi5fc291bmRzW2ldLl9lbmRlZCkge1xuICAgICAgICAgIGNudCsrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFJlbW92ZSBleGNlc3MgaW5hY3RpdmUgc291bmRzLCBnb2luZyBpbiByZXZlcnNlIG9yZGVyLlxuICAgICAgZm9yIChpPXNlbGYuX3NvdW5kcy5sZW5ndGggLSAxOyBpPj0wOyBpLS0pIHtcbiAgICAgICAgaWYgKGNudCA8PSBsaW1pdCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzZWxmLl9zb3VuZHNbaV0uX2VuZGVkKSB7XG4gICAgICAgICAgLy8gRGlzY29ubmVjdCB0aGUgYXVkaW8gc291cmNlIHdoZW4gdXNpbmcgV2ViIEF1ZGlvLlxuICAgICAgICAgIGlmIChzZWxmLl93ZWJBdWRpbyAmJiBzZWxmLl9zb3VuZHNbaV0uX25vZGUpIHtcbiAgICAgICAgICAgIHNlbGYuX3NvdW5kc1tpXS5fbm9kZS5kaXNjb25uZWN0KDApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFJlbW92ZSBzb3VuZHMgdW50aWwgd2UgaGF2ZSB0aGUgcG9vbCBzaXplLlxuICAgICAgICAgIHNlbGYuX3NvdW5kcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgY250LS07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IGFsbCBJRCdzIGZyb20gdGhlIHNvdW5kcyBwb29sLlxuICAgICAqIEBwYXJhbSAge051bWJlcn0gaWQgT25seSByZXR1cm4gb25lIElEIGlmIG9uZSBpcyBwYXNzZWQuXG4gICAgICogQHJldHVybiB7QXJyYXl9ICAgIEFycmF5IG9mIElEcy5cbiAgICAgKi9cbiAgICBfZ2V0U291bmRJZHM6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgIGlmICh0eXBlb2YgaWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHZhciBpZHMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaT0wOyBpPHNlbGYuX3NvdW5kcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlkcy5wdXNoKHNlbGYuX3NvdW5kc1tpXS5faWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGlkcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBbaWRdO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBMb2FkIHRoZSBzb3VuZCBiYWNrIGludG8gdGhlIGJ1ZmZlciBzb3VyY2UuXG4gICAgICogQHBhcmFtICB7U291bmR9IHNvdW5kIFRoZSBzb3VuZCBvYmplY3QgdG8gd29yayB3aXRoLlxuICAgICAqIEByZXR1cm4ge0hvd2x9XG4gICAgICovXG4gICAgX3JlZnJlc2hCdWZmZXI6IGZ1bmN0aW9uKHNvdW5kKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgIC8vIFNldHVwIHRoZSBidWZmZXIgc291cmNlIGZvciBwbGF5YmFjay5cbiAgICAgIHNvdW5kLl9ub2RlLmJ1ZmZlclNvdXJjZSA9IEhvd2xlci5jdHguY3JlYXRlQnVmZmVyU291cmNlKCk7XG4gICAgICBzb3VuZC5fbm9kZS5idWZmZXJTb3VyY2UuYnVmZmVyID0gY2FjaGVbc2VsZi5fc3JjXTtcblxuICAgICAgLy8gQ29ubmVjdCB0byB0aGUgY29ycmVjdCBub2RlLlxuICAgICAgaWYgKHNvdW5kLl9wYW5uZXIpIHtcbiAgICAgICAgc291bmQuX25vZGUuYnVmZmVyU291cmNlLmNvbm5lY3Qoc291bmQuX3Bhbm5lcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzb3VuZC5fbm9kZS5idWZmZXJTb3VyY2UuY29ubmVjdChzb3VuZC5fbm9kZSk7XG4gICAgICB9XG5cbiAgICAgIC8vIFNldHVwIGxvb3BpbmcgYW5kIHBsYXliYWNrIHJhdGUuXG4gICAgICBzb3VuZC5fbm9kZS5idWZmZXJTb3VyY2UubG9vcCA9IHNvdW5kLl9sb29wO1xuICAgICAgaWYgKHNvdW5kLl9sb29wKSB7XG4gICAgICAgIHNvdW5kLl9ub2RlLmJ1ZmZlclNvdXJjZS5sb29wU3RhcnQgPSBzb3VuZC5fc3RhcnQgfHwgMDtcbiAgICAgICAgc291bmQuX25vZGUuYnVmZmVyU291cmNlLmxvb3BFbmQgPSBzb3VuZC5fc3RvcDtcbiAgICAgIH1cbiAgICAgIHNvdW5kLl9ub2RlLmJ1ZmZlclNvdXJjZS5wbGF5YmFja1JhdGUudmFsdWUgPSBzb3VuZC5fcmF0ZTtcblxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFByZXZlbnQgbWVtb3J5IGxlYWtzIGJ5IGNsZWFuaW5nIHVwIHRoZSBidWZmZXIgc291cmNlIGFmdGVyIHBsYXliYWNrLlxuICAgICAqIEBwYXJhbSAge09iamVjdH0gbm9kZSBTb3VuZCdzIGF1ZGlvIG5vZGUgY29udGFpbmluZyB0aGUgYnVmZmVyIHNvdXJjZS5cbiAgICAgKiBAcmV0dXJuIHtIb3dsfVxuICAgICAqL1xuICAgIF9jbGVhbkJ1ZmZlcjogZnVuY3Rpb24obm9kZSkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICBpZiAoc2VsZi5fc2NyYXRjaEJ1ZmZlcikge1xuICAgICAgICBub2RlLmJ1ZmZlclNvdXJjZS5vbmVuZGVkID0gbnVsbDtcbiAgICAgICAgbm9kZS5idWZmZXJTb3VyY2UuZGlzY29ubmVjdCgwKTtcbiAgICAgICAgdHJ5IHsgbm9kZS5idWZmZXJTb3VyY2UuYnVmZmVyID0gc2VsZi5fc2NyYXRjaEJ1ZmZlcjsgfSBjYXRjaChlKSB7fVxuICAgICAgfVxuICAgICAgbm9kZS5idWZmZXJTb3VyY2UgPSBudWxsO1xuXG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9XG4gIH07XG5cbiAgLyoqIFNpbmdsZSBTb3VuZCBNZXRob2RzICoqL1xuICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gIC8qKlxuICAgKiBTZXR1cCB0aGUgc291bmQgb2JqZWN0LCB3aGljaCBlYWNoIG5vZGUgYXR0YWNoZWQgdG8gYSBIb3dsIGdyb3VwIGlzIGNvbnRhaW5lZCBpbi5cbiAgICogQHBhcmFtIHtPYmplY3R9IGhvd2wgVGhlIEhvd2wgcGFyZW50IGdyb3VwLlxuICAgKi9cbiAgdmFyIFNvdW5kID0gZnVuY3Rpb24oaG93bCkge1xuICAgIHRoaXMuX3BhcmVudCA9IGhvd2w7XG4gICAgdGhpcy5pbml0KCk7XG4gIH07XG4gIFNvdW5kLnByb3RvdHlwZSA9IHtcbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplIGEgbmV3IFNvdW5kIG9iamVjdC5cbiAgICAgKiBAcmV0dXJuIHtTb3VuZH1cbiAgICAgKi9cbiAgICBpbml0OiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciBwYXJlbnQgPSBzZWxmLl9wYXJlbnQ7XG5cbiAgICAgIC8vIFNldHVwIHRoZSBkZWZhdWx0IHBhcmFtZXRlcnMuXG4gICAgICBzZWxmLl9tdXRlZCA9IHBhcmVudC5fbXV0ZWQ7XG4gICAgICBzZWxmLl9sb29wID0gcGFyZW50Ll9sb29wO1xuICAgICAgc2VsZi5fdm9sdW1lID0gcGFyZW50Ll92b2x1bWU7XG4gICAgICBzZWxmLl9yYXRlID0gcGFyZW50Ll9yYXRlO1xuICAgICAgc2VsZi5fc2VlayA9IDA7XG4gICAgICBzZWxmLl9wYXVzZWQgPSB0cnVlO1xuICAgICAgc2VsZi5fZW5kZWQgPSB0cnVlO1xuICAgICAgc2VsZi5fc3ByaXRlID0gJ19fZGVmYXVsdCc7XG5cbiAgICAgIC8vIEdlbmVyYXRlIGEgdW5pcXVlIElEIGZvciB0aGlzIHNvdW5kLlxuICAgICAgc2VsZi5faWQgPSArK0hvd2xlci5fY291bnRlcjtcblxuICAgICAgLy8gQWRkIGl0c2VsZiB0byB0aGUgcGFyZW50J3MgcG9vbC5cbiAgICAgIHBhcmVudC5fc291bmRzLnB1c2goc2VsZik7XG5cbiAgICAgIC8vIENyZWF0ZSB0aGUgbmV3IG5vZGUuXG4gICAgICBzZWxmLmNyZWF0ZSgpO1xuXG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGFuZCBzZXR1cCBhIG5ldyBzb3VuZCBvYmplY3QsIHdoZXRoZXIgSFRNTDUgQXVkaW8gb3IgV2ViIEF1ZGlvLlxuICAgICAqIEByZXR1cm4ge1NvdW5kfVxuICAgICAqL1xuICAgIGNyZWF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgcGFyZW50ID0gc2VsZi5fcGFyZW50O1xuICAgICAgdmFyIHZvbHVtZSA9IChIb3dsZXIuX211dGVkIHx8IHNlbGYuX211dGVkIHx8IHNlbGYuX3BhcmVudC5fbXV0ZWQpID8gMCA6IHNlbGYuX3ZvbHVtZTtcblxuICAgICAgaWYgKHBhcmVudC5fd2ViQXVkaW8pIHtcbiAgICAgICAgLy8gQ3JlYXRlIHRoZSBnYWluIG5vZGUgZm9yIGNvbnRyb2xsaW5nIHZvbHVtZSAodGhlIHNvdXJjZSB3aWxsIGNvbm5lY3QgdG8gdGhpcykuXG4gICAgICAgIHNlbGYuX25vZGUgPSAodHlwZW9mIEhvd2xlci5jdHguY3JlYXRlR2FpbiA9PT0gJ3VuZGVmaW5lZCcpID8gSG93bGVyLmN0eC5jcmVhdGVHYWluTm9kZSgpIDogSG93bGVyLmN0eC5jcmVhdGVHYWluKCk7XG4gICAgICAgIHNlbGYuX25vZGUuZ2Fpbi5zZXRWYWx1ZUF0VGltZSh2b2x1bWUsIEhvd2xlci5jdHguY3VycmVudFRpbWUpO1xuICAgICAgICBzZWxmLl9ub2RlLnBhdXNlZCA9IHRydWU7XG4gICAgICAgIHNlbGYuX25vZGUuY29ubmVjdChIb3dsZXIubWFzdGVyR2Fpbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWxmLl9ub2RlID0gbmV3IEF1ZGlvKCk7XG5cbiAgICAgICAgLy8gTGlzdGVuIGZvciBlcnJvcnMgKGh0dHA6Ly9kZXYudzMub3JnL2h0bWw1L3NwZWMtYXV0aG9yLXZpZXcvc3BlYy5odG1sI21lZGlhZXJyb3IpLlxuICAgICAgICBzZWxmLl9lcnJvckZuID0gc2VsZi5fZXJyb3JMaXN0ZW5lci5iaW5kKHNlbGYpO1xuICAgICAgICBzZWxmLl9ub2RlLmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgc2VsZi5fZXJyb3JGbiwgZmFsc2UpO1xuXG4gICAgICAgIC8vIExpc3RlbiBmb3IgJ2NhbnBsYXl0aHJvdWdoJyBldmVudCB0byBsZXQgdXMga25vdyB0aGUgc291bmQgaXMgcmVhZHkuXG4gICAgICAgIHNlbGYuX2xvYWRGbiA9IHNlbGYuX2xvYWRMaXN0ZW5lci5iaW5kKHNlbGYpO1xuICAgICAgICBzZWxmLl9ub2RlLmFkZEV2ZW50TGlzdGVuZXIoSG93bGVyLl9jYW5QbGF5RXZlbnQsIHNlbGYuX2xvYWRGbiwgZmFsc2UpO1xuXG4gICAgICAgIC8vIFNldHVwIHRoZSBuZXcgYXVkaW8gbm9kZS5cbiAgICAgICAgc2VsZi5fbm9kZS5zcmMgPSBwYXJlbnQuX3NyYztcbiAgICAgICAgc2VsZi5fbm9kZS5wcmVsb2FkID0gJ2F1dG8nO1xuICAgICAgICBzZWxmLl9ub2RlLnZvbHVtZSA9IHZvbHVtZSAqIEhvd2xlci52b2x1bWUoKTtcblxuICAgICAgICAvLyBCZWdpbiBsb2FkaW5nIHRoZSBzb3VyY2UuXG4gICAgICAgIHNlbGYuX25vZGUubG9hZCgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVzZXQgdGhlIHBhcmFtZXRlcnMgb2YgdGhpcyBzb3VuZCB0byB0aGUgb3JpZ2luYWwgc3RhdGUgKGZvciByZWN5Y2xlKS5cbiAgICAgKiBAcmV0dXJuIHtTb3VuZH1cbiAgICAgKi9cbiAgICByZXNldDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgcGFyZW50ID0gc2VsZi5fcGFyZW50O1xuXG4gICAgICAvLyBSZXNldCBhbGwgb2YgdGhlIHBhcmFtZXRlcnMgb2YgdGhpcyBzb3VuZC5cbiAgICAgIHNlbGYuX211dGVkID0gcGFyZW50Ll9tdXRlZDtcbiAgICAgIHNlbGYuX2xvb3AgPSBwYXJlbnQuX2xvb3A7XG4gICAgICBzZWxmLl92b2x1bWUgPSBwYXJlbnQuX3ZvbHVtZTtcbiAgICAgIHNlbGYuX3JhdGUgPSBwYXJlbnQuX3JhdGU7XG4gICAgICBzZWxmLl9zZWVrID0gMDtcbiAgICAgIHNlbGYuX3JhdGVTZWVrID0gMDtcbiAgICAgIHNlbGYuX3BhdXNlZCA9IHRydWU7XG4gICAgICBzZWxmLl9lbmRlZCA9IHRydWU7XG4gICAgICBzZWxmLl9zcHJpdGUgPSAnX19kZWZhdWx0JztcblxuICAgICAgLy8gR2VuZXJhdGUgYSBuZXcgSUQgc28gdGhhdCBpdCBpc24ndCBjb25mdXNlZCB3aXRoIHRoZSBwcmV2aW91cyBzb3VuZC5cbiAgICAgIHNlbGYuX2lkID0gKytIb3dsZXIuX2NvdW50ZXI7XG5cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBIVE1MNSBBdWRpbyBlcnJvciBsaXN0ZW5lciBjYWxsYmFjay5cbiAgICAgKi9cbiAgICBfZXJyb3JMaXN0ZW5lcjogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgIC8vIEZpcmUgYW4gZXJyb3IgZXZlbnQgYW5kIHBhc3MgYmFjayB0aGUgY29kZS5cbiAgICAgIHNlbGYuX3BhcmVudC5fZW1pdCgnbG9hZGVycm9yJywgc2VsZi5faWQsIHNlbGYuX25vZGUuZXJyb3IgPyBzZWxmLl9ub2RlLmVycm9yLmNvZGUgOiAwKTtcblxuICAgICAgLy8gQ2xlYXIgdGhlIGV2ZW50IGxpc3RlbmVyLlxuICAgICAgc2VsZi5fbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKCdlcnJvcicsIHNlbGYuX2Vycm9yRm4sIGZhbHNlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSFRNTDUgQXVkaW8gY2FucGxheXRocm91Z2ggbGlzdGVuZXIgY2FsbGJhY2suXG4gICAgICovXG4gICAgX2xvYWRMaXN0ZW5lcjogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgcGFyZW50ID0gc2VsZi5fcGFyZW50O1xuXG4gICAgICAvLyBSb3VuZCB1cCB0aGUgZHVyYXRpb24gdG8gYWNjb3VudCBmb3IgdGhlIGxvd2VyIHByZWNpc2lvbiBpbiBIVE1MNSBBdWRpby5cbiAgICAgIHBhcmVudC5fZHVyYXRpb24gPSBNYXRoLmNlaWwoc2VsZi5fbm9kZS5kdXJhdGlvbiAqIDEwKSAvIDEwO1xuXG4gICAgICAvLyBTZXR1cCBhIHNwcml0ZSBpZiBub25lIGlzIGRlZmluZWQuXG4gICAgICBpZiAoT2JqZWN0LmtleXMocGFyZW50Ll9zcHJpdGUpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBwYXJlbnQuX3Nwcml0ZSA9IHtfX2RlZmF1bHQ6IFswLCBwYXJlbnQuX2R1cmF0aW9uICogMTAwMF19O1xuICAgICAgfVxuXG4gICAgICBpZiAocGFyZW50Ll9zdGF0ZSAhPT0gJ2xvYWRlZCcpIHtcbiAgICAgICAgcGFyZW50Ll9zdGF0ZSA9ICdsb2FkZWQnO1xuICAgICAgICBwYXJlbnQuX2VtaXQoJ2xvYWQnKTtcbiAgICAgICAgcGFyZW50Ll9sb2FkUXVldWUoKTtcbiAgICAgIH1cblxuICAgICAgLy8gQ2xlYXIgdGhlIGV2ZW50IGxpc3RlbmVyLlxuICAgICAgc2VsZi5fbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKEhvd2xlci5fY2FuUGxheUV2ZW50LCBzZWxmLl9sb2FkRm4sIGZhbHNlKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqIEhlbHBlciBNZXRob2RzICoqL1xuICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gIHZhciBjYWNoZSA9IHt9O1xuXG4gIC8qKlxuICAgKiBCdWZmZXIgYSBzb3VuZCBmcm9tIFVSTCwgRGF0YSBVUkkgb3IgY2FjaGUgYW5kIGRlY29kZSB0byBhdWRpbyBzb3VyY2UgKFdlYiBBdWRpbyBBUEkpLlxuICAgKiBAcGFyYW0gIHtIb3dsfSBzZWxmXG4gICAqL1xuICB2YXIgbG9hZEJ1ZmZlciA9IGZ1bmN0aW9uKHNlbGYpIHtcbiAgICB2YXIgdXJsID0gc2VsZi5fc3JjO1xuXG4gICAgLy8gQ2hlY2sgaWYgdGhlIGJ1ZmZlciBoYXMgYWxyZWFkeSBiZWVuIGNhY2hlZCBhbmQgdXNlIGl0IGluc3RlYWQuXG4gICAgaWYgKGNhY2hlW3VybF0pIHtcbiAgICAgIC8vIFNldCB0aGUgZHVyYXRpb24gZnJvbSB0aGUgY2FjaGUuXG4gICAgICBzZWxmLl9kdXJhdGlvbiA9IGNhY2hlW3VybF0uZHVyYXRpb247XG5cbiAgICAgIC8vIExvYWQgdGhlIHNvdW5kIGludG8gdGhpcyBIb3dsLlxuICAgICAgbG9hZFNvdW5kKHNlbGYpO1xuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKC9eZGF0YTpbXjtdKztiYXNlNjQsLy50ZXN0KHVybCkpIHtcbiAgICAgIC8vIERlY29kZSB0aGUgYmFzZTY0IGRhdGEgVVJJIHdpdGhvdXQgWEhSLCBzaW5jZSBzb21lIGJyb3dzZXJzIGRvbid0IHN1cHBvcnQgaXQuXG4gICAgICB2YXIgZGF0YSA9IGF0b2IodXJsLnNwbGl0KCcsJylbMV0pO1xuICAgICAgdmFyIGRhdGFWaWV3ID0gbmV3IFVpbnQ4QXJyYXkoZGF0YS5sZW5ndGgpO1xuICAgICAgZm9yICh2YXIgaT0wOyBpPGRhdGEubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgZGF0YVZpZXdbaV0gPSBkYXRhLmNoYXJDb2RlQXQoaSk7XG4gICAgICB9XG5cbiAgICAgIGRlY29kZUF1ZGlvRGF0YShkYXRhVmlldy5idWZmZXIsIHNlbGYpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBMb2FkIHRoZSBidWZmZXIgZnJvbSB0aGUgVVJMLlxuICAgICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgeGhyLm9wZW4oJ0dFVCcsIHVybCwgdHJ1ZSk7XG4gICAgICB4aHIud2l0aENyZWRlbnRpYWxzID0gc2VsZi5feGhyV2l0aENyZWRlbnRpYWxzO1xuICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9ICdhcnJheWJ1ZmZlcic7XG4gICAgICB4aHIub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIE1ha2Ugc3VyZSB3ZSBnZXQgYSBzdWNjZXNzZnVsIHJlc3BvbnNlIGJhY2suXG4gICAgICAgIHZhciBjb2RlID0gKHhoci5zdGF0dXMgKyAnJylbMF07XG4gICAgICAgIGlmIChjb2RlICE9PSAnMCcgJiYgY29kZSAhPT0gJzInICYmIGNvZGUgIT09ICczJykge1xuICAgICAgICAgIHNlbGYuX2VtaXQoJ2xvYWRlcnJvcicsIG51bGwsICdGYWlsZWQgbG9hZGluZyBhdWRpbyBmaWxlIHdpdGggc3RhdHVzOiAnICsgeGhyLnN0YXR1cyArICcuJyk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgZGVjb2RlQXVkaW9EYXRhKHhoci5yZXNwb25zZSwgc2VsZik7XG4gICAgICB9O1xuICAgICAgeGhyLm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gSWYgdGhlcmUgaXMgYW4gZXJyb3IsIHN3aXRjaCB0byBIVE1MNSBBdWRpby5cbiAgICAgICAgaWYgKHNlbGYuX3dlYkF1ZGlvKSB7XG4gICAgICAgICAgc2VsZi5faHRtbDUgPSB0cnVlO1xuICAgICAgICAgIHNlbGYuX3dlYkF1ZGlvID0gZmFsc2U7XG4gICAgICAgICAgc2VsZi5fc291bmRzID0gW107XG4gICAgICAgICAgZGVsZXRlIGNhY2hlW3VybF07XG4gICAgICAgICAgc2VsZi5sb2FkKCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBzYWZlWGhyU2VuZCh4aHIpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogU2VuZCB0aGUgWEhSIHJlcXVlc3Qgd3JhcHBlZCBpbiBhIHRyeS9jYXRjaC5cbiAgICogQHBhcmFtICB7T2JqZWN0fSB4aHIgWEhSIHRvIHNlbmQuXG4gICAqL1xuICB2YXIgc2FmZVhoclNlbmQgPSBmdW5jdGlvbih4aHIpIHtcbiAgICB0cnkge1xuICAgICAgeGhyLnNlbmQoKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB4aHIub25lcnJvcigpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogRGVjb2RlIGF1ZGlvIGRhdGEgZnJvbSBhbiBhcnJheSBidWZmZXIuXG4gICAqIEBwYXJhbSAge0FycmF5QnVmZmVyfSBhcnJheWJ1ZmZlciBUaGUgYXVkaW8gZGF0YS5cbiAgICogQHBhcmFtICB7SG93bH0gICAgICAgIHNlbGZcbiAgICovXG4gIHZhciBkZWNvZGVBdWRpb0RhdGEgPSBmdW5jdGlvbihhcnJheWJ1ZmZlciwgc2VsZikge1xuICAgIC8vIERlY29kZSB0aGUgYnVmZmVyIGludG8gYW4gYXVkaW8gc291cmNlLlxuICAgIEhvd2xlci5jdHguZGVjb2RlQXVkaW9EYXRhKGFycmF5YnVmZmVyLCBmdW5jdGlvbihidWZmZXIpIHtcbiAgICAgIGlmIChidWZmZXIgJiYgc2VsZi5fc291bmRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY2FjaGVbc2VsZi5fc3JjXSA9IGJ1ZmZlcjtcbiAgICAgICAgbG9hZFNvdW5kKHNlbGYsIGJ1ZmZlcik7XG4gICAgICB9XG4gICAgfSwgZnVuY3Rpb24oKSB7XG4gICAgICBzZWxmLl9lbWl0KCdsb2FkZXJyb3InLCBudWxsLCAnRGVjb2RpbmcgYXVkaW8gZGF0YSBmYWlsZWQuJyk7XG4gICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNvdW5kIGlzIG5vdyBsb2FkZWQsIHNvIGZpbmlzaCBzZXR0aW5nIGV2ZXJ5dGhpbmcgdXAgYW5kIGZpcmUgdGhlIGxvYWRlZCBldmVudC5cbiAgICogQHBhcmFtICB7SG93bH0gc2VsZlxuICAgKiBAcGFyYW0gIHtPYmplY3R9IGJ1ZmZlciBUaGUgZGVjb2RlZCBidWZmZXIgc291bmQgc291cmNlLlxuICAgKi9cbiAgdmFyIGxvYWRTb3VuZCA9IGZ1bmN0aW9uKHNlbGYsIGJ1ZmZlcikge1xuICAgIC8vIFNldCB0aGUgZHVyYXRpb24uXG4gICAgaWYgKGJ1ZmZlciAmJiAhc2VsZi5fZHVyYXRpb24pIHtcbiAgICAgIHNlbGYuX2R1cmF0aW9uID0gYnVmZmVyLmR1cmF0aW9uO1xuICAgIH1cblxuICAgIC8vIFNldHVwIGEgc3ByaXRlIGlmIG5vbmUgaXMgZGVmaW5lZC5cbiAgICBpZiAoT2JqZWN0LmtleXMoc2VsZi5fc3ByaXRlKS5sZW5ndGggPT09IDApIHtcbiAgICAgIHNlbGYuX3Nwcml0ZSA9IHtfX2RlZmF1bHQ6IFswLCBzZWxmLl9kdXJhdGlvbiAqIDEwMDBdfTtcbiAgICB9XG5cbiAgICAvLyBGaXJlIHRoZSBsb2FkZWQgZXZlbnQuXG4gICAgaWYgKHNlbGYuX3N0YXRlICE9PSAnbG9hZGVkJykge1xuICAgICAgc2VsZi5fc3RhdGUgPSAnbG9hZGVkJztcbiAgICAgIHNlbGYuX2VtaXQoJ2xvYWQnKTtcbiAgICAgIHNlbGYuX2xvYWRRdWV1ZSgpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogU2V0dXAgdGhlIGF1ZGlvIGNvbnRleHQgd2hlbiBhdmFpbGFibGUsIG9yIHN3aXRjaCB0byBIVE1MNSBBdWRpbyBtb2RlLlxuICAgKi9cbiAgdmFyIHNldHVwQXVkaW9Db250ZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgLy8gQ2hlY2sgaWYgd2UgYXJlIHVzaW5nIFdlYiBBdWRpbyBhbmQgc2V0dXAgdGhlIEF1ZGlvQ29udGV4dCBpZiB3ZSBhcmUuXG4gICAgdHJ5IHtcbiAgICAgIGlmICh0eXBlb2YgQXVkaW9Db250ZXh0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBIb3dsZXIuY3R4ID0gbmV3IEF1ZGlvQ29udGV4dCgpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygd2Via2l0QXVkaW9Db250ZXh0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBIb3dsZXIuY3R4ID0gbmV3IHdlYmtpdEF1ZGlvQ29udGV4dCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgSG93bGVyLnVzaW5nV2ViQXVkaW8gPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGNhdGNoKGUpIHtcbiAgICAgIEhvd2xlci51c2luZ1dlYkF1ZGlvID0gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgaWYgYSB3ZWJ2aWV3IGlzIGJlaW5nIHVzZWQgb24gaU9TOCBvciBlYXJsaWVyIChyYXRoZXIgdGhhbiB0aGUgYnJvd3NlcikuXG4gICAgLy8gSWYgaXQgaXMsIGRpc2FibGUgV2ViIEF1ZGlvIGFzIGl0IGNhdXNlcyBjcmFzaGluZy5cbiAgICB2YXIgaU9TID0gKC9pUChob25lfG9kfGFkKS8udGVzdChIb3dsZXIuX25hdmlnYXRvciAmJiBIb3dsZXIuX25hdmlnYXRvci5wbGF0Zm9ybSkpO1xuICAgIHZhciBhcHBWZXJzaW9uID0gSG93bGVyLl9uYXZpZ2F0b3IgJiYgSG93bGVyLl9uYXZpZ2F0b3IuYXBwVmVyc2lvbi5tYXRjaCgvT1MgKFxcZCspXyhcXGQrKV8/KFxcZCspPy8pO1xuICAgIHZhciB2ZXJzaW9uID0gYXBwVmVyc2lvbiA/IHBhcnNlSW50KGFwcFZlcnNpb25bMV0sIDEwKSA6IG51bGw7XG4gICAgaWYgKGlPUyAmJiB2ZXJzaW9uICYmIHZlcnNpb24gPCA5KSB7XG4gICAgICB2YXIgc2FmYXJpID0gL3NhZmFyaS8udGVzdChIb3dsZXIuX25hdmlnYXRvciAmJiBIb3dsZXIuX25hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKSk7XG4gICAgICBpZiAoSG93bGVyLl9uYXZpZ2F0b3IgJiYgSG93bGVyLl9uYXZpZ2F0b3Iuc3RhbmRhbG9uZSAmJiAhc2FmYXJpIHx8IEhvd2xlci5fbmF2aWdhdG9yICYmICFIb3dsZXIuX25hdmlnYXRvci5zdGFuZGFsb25lICYmICFzYWZhcmkpIHtcbiAgICAgICAgSG93bGVyLnVzaW5nV2ViQXVkaW8gPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBDcmVhdGUgYW5kIGV4cG9zZSB0aGUgbWFzdGVyIEdhaW5Ob2RlIHdoZW4gdXNpbmcgV2ViIEF1ZGlvICh1c2VmdWwgZm9yIHBsdWdpbnMgb3IgYWR2YW5jZWQgdXNhZ2UpLlxuICAgIGlmIChIb3dsZXIudXNpbmdXZWJBdWRpbykge1xuICAgICAgSG93bGVyLm1hc3RlckdhaW4gPSAodHlwZW9mIEhvd2xlci5jdHguY3JlYXRlR2FpbiA9PT0gJ3VuZGVmaW5lZCcpID8gSG93bGVyLmN0eC5jcmVhdGVHYWluTm9kZSgpIDogSG93bGVyLmN0eC5jcmVhdGVHYWluKCk7XG4gICAgICBIb3dsZXIubWFzdGVyR2Fpbi5nYWluLnZhbHVlID0gSG93bGVyLl9tdXRlZCA/IDAgOiAxO1xuICAgICAgSG93bGVyLm1hc3RlckdhaW4uY29ubmVjdChIb3dsZXIuY3R4LmRlc3RpbmF0aW9uKTtcbiAgICB9XG5cbiAgICAvLyBSZS1ydW4gdGhlIHNldHVwIG9uIEhvd2xlci5cbiAgICBIb3dsZXIuX3NldHVwKCk7XG4gIH07XG5cbiAgLy8gQWRkIHN1cHBvcnQgZm9yIEFNRCAoQXN5bmNocm9ub3VzIE1vZHVsZSBEZWZpbml0aW9uKSBsaWJyYXJpZXMgc3VjaCBhcyByZXF1aXJlLmpzLlxuICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgZGVmaW5lKFtdLCBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIEhvd2xlcjogSG93bGVyLFxuICAgICAgICBIb3dsOiBIb3dsXG4gICAgICB9O1xuICAgIH0pO1xuICB9XG5cbiAgLy8gQWRkIHN1cHBvcnQgZm9yIENvbW1vbkpTIGxpYnJhcmllcyBzdWNoIGFzIGJyb3dzZXJpZnkuXG4gIGlmICh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBleHBvcnRzLkhvd2xlciA9IEhvd2xlcjtcbiAgICBleHBvcnRzLkhvd2wgPSBIb3dsO1xuICB9XG5cbiAgLy8gRGVmaW5lIGdsb2JhbGx5IGluIGNhc2UgQU1EIGlzIG5vdCBhdmFpbGFibGUgb3IgdW51c2VkLlxuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB3aW5kb3cuSG93bGVyR2xvYmFsID0gSG93bGVyR2xvYmFsO1xuICAgIHdpbmRvdy5Ib3dsZXIgPSBIb3dsZXI7XG4gICAgd2luZG93Lkhvd2wgPSBIb3dsO1xuICAgIHdpbmRvdy5Tb3VuZCA9IFNvdW5kO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnKSB7IC8vIEFkZCB0byBnbG9iYWwgaW4gTm9kZS5qcyAoZm9yIHRlc3RpbmcsIGV0YykuXG4gICAgZ2xvYmFsLkhvd2xlckdsb2JhbCA9IEhvd2xlckdsb2JhbDtcbiAgICBnbG9iYWwuSG93bGVyID0gSG93bGVyO1xuICAgIGdsb2JhbC5Ib3dsID0gSG93bDtcbiAgICBnbG9iYWwuU291bmQgPSBTb3VuZDtcbiAgfVxufSkoKTtcblxuXG4vKiFcbiAqICBTcGF0aWFsIFBsdWdpbiAtIEFkZHMgc3VwcG9ydCBmb3Igc3RlcmVvIGFuZCAzRCBhdWRpbyB3aGVyZSBXZWIgQXVkaW8gaXMgc3VwcG9ydGVkLlxuICogIFxuICogIGhvd2xlci5qcyB2Mi4wLjVcbiAqICBob3dsZXJqcy5jb21cbiAqXG4gKiAgKGMpIDIwMTMtMjAxNywgSmFtZXMgU2ltcHNvbiBvZiBHb2xkRmlyZSBTdHVkaW9zXG4gKiAgZ29sZGZpcmVzdHVkaW9zLmNvbVxuICpcbiAqICBNSVQgTGljZW5zZVxuICovXG5cbihmdW5jdGlvbigpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgLy8gU2V0dXAgZGVmYXVsdCBwcm9wZXJ0aWVzLlxuICBIb3dsZXJHbG9iYWwucHJvdG90eXBlLl9wb3MgPSBbMCwgMCwgMF07XG4gIEhvd2xlckdsb2JhbC5wcm90b3R5cGUuX29yaWVudGF0aW9uID0gWzAsIDAsIC0xLCAwLCAxLCAwXTtcbiAgXG4gIC8qKiBHbG9iYWwgTWV0aG9kcyAqKi9cbiAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAvKipcbiAgICogSGVscGVyIG1ldGhvZCB0byB1cGRhdGUgdGhlIHN0ZXJlbyBwYW5uaW5nIHBvc2l0aW9uIG9mIGFsbCBjdXJyZW50IEhvd2xzLlxuICAgKiBGdXR1cmUgSG93bHMgd2lsbCBub3QgdXNlIHRoaXMgdmFsdWUgdW5sZXNzIGV4cGxpY2l0bHkgc2V0LlxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHBhbiBBIHZhbHVlIG9mIC0xLjAgaXMgYWxsIHRoZSB3YXkgbGVmdCBhbmQgMS4wIGlzIGFsbCB0aGUgd2F5IHJpZ2h0LlxuICAgKiBAcmV0dXJuIHtIb3dsZXIvTnVtYmVyfSAgICAgU2VsZiBvciBjdXJyZW50IHN0ZXJlbyBwYW5uaW5nIHZhbHVlLlxuICAgKi9cbiAgSG93bGVyR2xvYmFsLnByb3RvdHlwZS5zdGVyZW8gPSBmdW5jdGlvbihwYW4pIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAvLyBTdG9wIHJpZ2h0IGhlcmUgaWYgbm90IHVzaW5nIFdlYiBBdWRpby5cbiAgICBpZiAoIXNlbGYuY3R4IHx8ICFzZWxmLmN0eC5saXN0ZW5lcikge1xuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfVxuXG4gICAgLy8gTG9vcCB0aHJvdWdoIGFsbCBIb3dscyBhbmQgdXBkYXRlIHRoZWlyIHN0ZXJlbyBwYW5uaW5nLlxuICAgIGZvciAodmFyIGk9c2VsZi5faG93bHMubGVuZ3RoLTE7IGk+PTA7IGktLSkge1xuICAgICAgc2VsZi5faG93bHNbaV0uc3RlcmVvKHBhbik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNlbGY7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldC9zZXQgdGhlIHBvc2l0aW9uIG9mIHRoZSBsaXN0ZW5lciBpbiAzRCBjYXJ0ZXNpYW4gc3BhY2UuIFNvdW5kcyB1c2luZ1xuICAgKiAzRCBwb3NpdGlvbiB3aWxsIGJlIHJlbGF0aXZlIHRvIHRoZSBsaXN0ZW5lcidzIHBvc2l0aW9uLlxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHggVGhlIHgtcG9zaXRpb24gb2YgdGhlIGxpc3RlbmVyLlxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHkgVGhlIHktcG9zaXRpb24gb2YgdGhlIGxpc3RlbmVyLlxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHogVGhlIHotcG9zaXRpb24gb2YgdGhlIGxpc3RlbmVyLlxuICAgKiBAcmV0dXJuIHtIb3dsZXIvQXJyYXl9ICAgU2VsZiBvciBjdXJyZW50IGxpc3RlbmVyIHBvc2l0aW9uLlxuICAgKi9cbiAgSG93bGVyR2xvYmFsLnByb3RvdHlwZS5wb3MgPSBmdW5jdGlvbih4LCB5LCB6KSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgLy8gU3RvcCByaWdodCBoZXJlIGlmIG5vdCB1c2luZyBXZWIgQXVkaW8uXG4gICAgaWYgKCFzZWxmLmN0eCB8fCAhc2VsZi5jdHgubGlzdGVuZXIpIHtcbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cblxuICAgIC8vIFNldCB0aGUgZGVmYXVsdHMgZm9yIG9wdGlvbmFsICd5JyAmICd6Jy5cbiAgICB5ID0gKHR5cGVvZiB5ICE9PSAnbnVtYmVyJykgPyBzZWxmLl9wb3NbMV0gOiB5O1xuICAgIHogPSAodHlwZW9mIHogIT09ICdudW1iZXInKSA/IHNlbGYuX3Bvc1syXSA6IHo7XG5cbiAgICBpZiAodHlwZW9mIHggPT09ICdudW1iZXInKSB7XG4gICAgICBzZWxmLl9wb3MgPSBbeCwgeSwgel07XG4gICAgICBzZWxmLmN0eC5saXN0ZW5lci5zZXRQb3NpdGlvbihzZWxmLl9wb3NbMF0sIHNlbGYuX3Bvc1sxXSwgc2VsZi5fcG9zWzJdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHNlbGYuX3BvcztcbiAgICB9XG5cbiAgICByZXR1cm4gc2VsZjtcbiAgfTtcblxuICAvKipcbiAgICogR2V0L3NldCB0aGUgZGlyZWN0aW9uIHRoZSBsaXN0ZW5lciBpcyBwb2ludGluZyBpbiB0aGUgM0QgY2FydGVzaWFuIHNwYWNlLlxuICAgKiBBIGZyb250IGFuZCB1cCB2ZWN0b3IgbXVzdCBiZSBwcm92aWRlZC4gVGhlIGZyb250IGlzIHRoZSBkaXJlY3Rpb24gdGhlXG4gICAqIGZhY2Ugb2YgdGhlIGxpc3RlbmVyIGlzIHBvaW50aW5nLCBhbmQgdXAgaXMgdGhlIGRpcmVjdGlvbiB0aGUgdG9wIG9mIHRoZVxuICAgKiBsaXN0ZW5lciBpcyBwb2ludGluZy4gVGh1cywgdGhlc2UgdmFsdWVzIGFyZSBleHBlY3RlZCB0byBiZSBhdCByaWdodCBhbmdsZXNcbiAgICogZnJvbSBlYWNoIG90aGVyLlxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHggICBUaGUgeC1vcmllbnRhdGlvbiBvZiB0aGUgbGlzdGVuZXIuXG4gICAqIEBwYXJhbSAge051bWJlcn0geSAgIFRoZSB5LW9yaWVudGF0aW9uIG9mIHRoZSBsaXN0ZW5lci5cbiAgICogQHBhcmFtICB7TnVtYmVyfSB6ICAgVGhlIHotb3JpZW50YXRpb24gb2YgdGhlIGxpc3RlbmVyLlxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHhVcCBUaGUgeC1vcmllbnRhdGlvbiBvZiB0aGUgdG9wIG9mIHRoZSBsaXN0ZW5lci5cbiAgICogQHBhcmFtICB7TnVtYmVyfSB5VXAgVGhlIHktb3JpZW50YXRpb24gb2YgdGhlIHRvcCBvZiB0aGUgbGlzdGVuZXIuXG4gICAqIEBwYXJhbSAge051bWJlcn0gelVwIFRoZSB6LW9yaWVudGF0aW9uIG9mIHRoZSB0b3Agb2YgdGhlIGxpc3RlbmVyLlxuICAgKiBAcmV0dXJuIHtIb3dsZXIvQXJyYXl9ICAgICBSZXR1cm5zIHNlbGYgb3IgdGhlIGN1cnJlbnQgb3JpZW50YXRpb24gdmVjdG9ycy5cbiAgICovXG4gIEhvd2xlckdsb2JhbC5wcm90b3R5cGUub3JpZW50YXRpb24gPSBmdW5jdGlvbih4LCB5LCB6LCB4VXAsIHlVcCwgelVwKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgLy8gU3RvcCByaWdodCBoZXJlIGlmIG5vdCB1c2luZyBXZWIgQXVkaW8uXG4gICAgaWYgKCFzZWxmLmN0eCB8fCAhc2VsZi5jdHgubGlzdGVuZXIpIHtcbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cblxuICAgIC8vIFNldCB0aGUgZGVmYXVsdHMgZm9yIG9wdGlvbmFsICd5JyAmICd6Jy5cbiAgICB2YXIgb3IgPSBzZWxmLl9vcmllbnRhdGlvbjtcbiAgICB5ID0gKHR5cGVvZiB5ICE9PSAnbnVtYmVyJykgPyBvclsxXSA6IHk7XG4gICAgeiA9ICh0eXBlb2YgeiAhPT0gJ251bWJlcicpID8gb3JbMl0gOiB6O1xuICAgIHhVcCA9ICh0eXBlb2YgeFVwICE9PSAnbnVtYmVyJykgPyBvclszXSA6IHhVcDtcbiAgICB5VXAgPSAodHlwZW9mIHlVcCAhPT0gJ251bWJlcicpID8gb3JbNF0gOiB5VXA7XG4gICAgelVwID0gKHR5cGVvZiB6VXAgIT09ICdudW1iZXInKSA/IG9yWzVdIDogelVwO1xuXG4gICAgaWYgKHR5cGVvZiB4ID09PSAnbnVtYmVyJykge1xuICAgICAgc2VsZi5fb3JpZW50YXRpb24gPSBbeCwgeSwgeiwgeFVwLCB5VXAsIHpVcF07XG4gICAgICBzZWxmLmN0eC5saXN0ZW5lci5zZXRPcmllbnRhdGlvbih4LCB5LCB6LCB4VXAsIHlVcCwgelVwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG9yO1xuICAgIH1cblxuICAgIHJldHVybiBzZWxmO1xuICB9O1xuXG4gIC8qKiBHcm91cCBNZXRob2RzICoqL1xuICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gIC8qKlxuICAgKiBBZGQgbmV3IHByb3BlcnRpZXMgdG8gdGhlIGNvcmUgaW5pdC5cbiAgICogQHBhcmFtICB7RnVuY3Rpb259IF9zdXBlciBDb3JlIGluaXQgbWV0aG9kLlxuICAgKiBAcmV0dXJuIHtIb3dsfVxuICAgKi9cbiAgSG93bC5wcm90b3R5cGUuaW5pdCA9IChmdW5jdGlvbihfc3VwZXIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24obykge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAvLyBTZXR1cCB1c2VyLWRlZmluZWQgZGVmYXVsdCBwcm9wZXJ0aWVzLlxuICAgICAgc2VsZi5fb3JpZW50YXRpb24gPSBvLm9yaWVudGF0aW9uIHx8IFsxLCAwLCAwXTtcbiAgICAgIHNlbGYuX3N0ZXJlbyA9IG8uc3RlcmVvIHx8IG51bGw7XG4gICAgICBzZWxmLl9wb3MgPSBvLnBvcyB8fCBudWxsO1xuICAgICAgc2VsZi5fcGFubmVyQXR0ciA9IHtcbiAgICAgICAgY29uZUlubmVyQW5nbGU6IHR5cGVvZiBvLmNvbmVJbm5lckFuZ2xlICE9PSAndW5kZWZpbmVkJyA/IG8uY29uZUlubmVyQW5nbGUgOiAzNjAsXG4gICAgICAgIGNvbmVPdXRlckFuZ2xlOiB0eXBlb2Ygby5jb25lT3V0ZXJBbmdsZSAhPT0gJ3VuZGVmaW5lZCcgPyBvLmNvbmVPdXRlckFuZ2xlIDogMzYwLFxuICAgICAgICBjb25lT3V0ZXJHYWluOiB0eXBlb2Ygby5jb25lT3V0ZXJHYWluICE9PSAndW5kZWZpbmVkJyA/IG8uY29uZU91dGVyR2FpbiA6IDAsXG4gICAgICAgIGRpc3RhbmNlTW9kZWw6IHR5cGVvZiBvLmRpc3RhbmNlTW9kZWwgIT09ICd1bmRlZmluZWQnID8gby5kaXN0YW5jZU1vZGVsIDogJ2ludmVyc2UnLFxuICAgICAgICBtYXhEaXN0YW5jZTogdHlwZW9mIG8ubWF4RGlzdGFuY2UgIT09ICd1bmRlZmluZWQnID8gby5tYXhEaXN0YW5jZSA6IDEwMDAwLFxuICAgICAgICBwYW5uaW5nTW9kZWw6IHR5cGVvZiBvLnBhbm5pbmdNb2RlbCAhPT0gJ3VuZGVmaW5lZCcgPyBvLnBhbm5pbmdNb2RlbCA6ICdIUlRGJyxcbiAgICAgICAgcmVmRGlzdGFuY2U6IHR5cGVvZiBvLnJlZkRpc3RhbmNlICE9PSAndW5kZWZpbmVkJyA/IG8ucmVmRGlzdGFuY2UgOiAxLFxuICAgICAgICByb2xsb2ZmRmFjdG9yOiB0eXBlb2Ygby5yb2xsb2ZmRmFjdG9yICE9PSAndW5kZWZpbmVkJyA/IG8ucm9sbG9mZkZhY3RvciA6IDFcbiAgICAgIH07XG5cbiAgICAgIC8vIFNldHVwIGV2ZW50IGxpc3RlbmVycy5cbiAgICAgIHNlbGYuX29uc3RlcmVvID0gby5vbnN0ZXJlbyA/IFt7Zm46IG8ub25zdGVyZW99XSA6IFtdO1xuICAgICAgc2VsZi5fb25wb3MgPSBvLm9ucG9zID8gW3tmbjogby5vbnBvc31dIDogW107XG4gICAgICBzZWxmLl9vbm9yaWVudGF0aW9uID0gby5vbm9yaWVudGF0aW9uID8gW3tmbjogby5vbm9yaWVudGF0aW9ufV0gOiBbXTtcblxuICAgICAgLy8gQ29tcGxldGUgaW5pdGlsaXphdGlvbiB3aXRoIGhvd2xlci5qcyBjb3JlJ3MgaW5pdCBmdW5jdGlvbi5cbiAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBvKTtcbiAgICB9O1xuICB9KShIb3dsLnByb3RvdHlwZS5pbml0KTtcblxuICAvKipcbiAgICogR2V0L3NldCB0aGUgc3RlcmVvIHBhbm5pbmcgb2YgdGhlIGF1ZGlvIHNvdXJjZSBmb3IgdGhpcyBzb3VuZCBvciBhbGwgaW4gdGhlIGdyb3VwLlxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHBhbiAgQSB2YWx1ZSBvZiAtMS4wIGlzIGFsbCB0aGUgd2F5IGxlZnQgYW5kIDEuMCBpcyBhbGwgdGhlIHdheSByaWdodC5cbiAgICogQHBhcmFtICB7TnVtYmVyfSBpZCAob3B0aW9uYWwpIFRoZSBzb3VuZCBJRC4gSWYgbm9uZSBpcyBwYXNzZWQsIGFsbCBpbiBncm91cCB3aWxsIGJlIHVwZGF0ZWQuXG4gICAqIEByZXR1cm4ge0hvd2wvTnVtYmVyfSAgICBSZXR1cm5zIHNlbGYgb3IgdGhlIGN1cnJlbnQgc3RlcmVvIHBhbm5pbmcgdmFsdWUuXG4gICAqL1xuICBIb3dsLnByb3RvdHlwZS5zdGVyZW8gPSBmdW5jdGlvbihwYW4sIGlkKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgLy8gU3RvcCByaWdodCBoZXJlIGlmIG5vdCB1c2luZyBXZWIgQXVkaW8uXG4gICAgaWYgKCFzZWxmLl93ZWJBdWRpbykge1xuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIHNvdW5kIGhhc24ndCBsb2FkZWQsIGFkZCBpdCB0byB0aGUgbG9hZCBxdWV1ZSB0byBjaGFuZ2Ugc3RlcmVvIHBhbiB3aGVuIGNhcGFibGUuXG4gICAgaWYgKHNlbGYuX3N0YXRlICE9PSAnbG9hZGVkJykge1xuICAgICAgc2VsZi5fcXVldWUucHVzaCh7XG4gICAgICAgIGV2ZW50OiAnc3RlcmVvJyxcbiAgICAgICAgYWN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICBzZWxmLnN0ZXJlbyhwYW4sIGlkKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGZvciBQYW5uZXJTdGVyZW9Ob2RlIHN1cHBvcnQgYW5kIGZhbGxiYWNrIHRvIFBhbm5lck5vZGUgaWYgaXQgZG9lc24ndCBleGlzdC5cbiAgICB2YXIgcGFubmVyVHlwZSA9ICh0eXBlb2YgSG93bGVyLmN0eC5jcmVhdGVTdGVyZW9QYW5uZXIgPT09ICd1bmRlZmluZWQnKSA/ICdzcGF0aWFsJyA6ICdzdGVyZW8nO1xuXG4gICAgLy8gU2V0dXAgdGhlIGdyb3VwJ3Mgc3RlcmVvIHBhbm5pbmcgaWYgbm8gSUQgaXMgcGFzc2VkLlxuICAgIGlmICh0eXBlb2YgaWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAvLyBSZXR1cm4gdGhlIGdyb3VwJ3Mgc3RlcmVvIHBhbm5pbmcgaWYgbm8gcGFyYW1ldGVycyBhcmUgcGFzc2VkLlxuICAgICAgaWYgKHR5cGVvZiBwYW4gPT09ICdudW1iZXInKSB7XG4gICAgICAgIHNlbGYuX3N0ZXJlbyA9IHBhbjtcbiAgICAgICAgc2VsZi5fcG9zID0gW3BhbiwgMCwgMF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gc2VsZi5fc3RlcmVvO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIENoYW5nZSB0aGUgc3RyZW8gcGFubmluZyBvZiBvbmUgb3IgYWxsIHNvdW5kcyBpbiBncm91cC5cbiAgICB2YXIgaWRzID0gc2VsZi5fZ2V0U291bmRJZHMoaWQpO1xuICAgIGZvciAodmFyIGk9MDsgaTxpZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIC8vIEdldCB0aGUgc291bmQuXG4gICAgICB2YXIgc291bmQgPSBzZWxmLl9zb3VuZEJ5SWQoaWRzW2ldKTtcblxuICAgICAgaWYgKHNvdW5kKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcGFuID09PSAnbnVtYmVyJykge1xuICAgICAgICAgIHNvdW5kLl9zdGVyZW8gPSBwYW47XG4gICAgICAgICAgc291bmQuX3BvcyA9IFtwYW4sIDAsIDBdO1xuXG4gICAgICAgICAgaWYgKHNvdW5kLl9ub2RlKSB7XG4gICAgICAgICAgICAvLyBJZiB3ZSBhcmUgZmFsbGluZyBiYWNrLCBtYWtlIHN1cmUgdGhlIHBhbm5pbmdNb2RlbCBpcyBlcXVhbHBvd2VyLlxuICAgICAgICAgICAgc291bmQuX3Bhbm5lckF0dHIucGFubmluZ01vZGVsID0gJ2VxdWFscG93ZXInO1xuXG4gICAgICAgICAgICAvLyBDaGVjayBpZiB0aGVyZSBpcyBhIHBhbm5lciBzZXR1cCBhbmQgY3JlYXRlIGEgbmV3IG9uZSBpZiBub3QuXG4gICAgICAgICAgICBpZiAoIXNvdW5kLl9wYW5uZXIgfHwgIXNvdW5kLl9wYW5uZXIucGFuKSB7XG4gICAgICAgICAgICAgIHNldHVwUGFubmVyKHNvdW5kLCBwYW5uZXJUeXBlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHBhbm5lclR5cGUgPT09ICdzcGF0aWFsJykge1xuICAgICAgICAgICAgICBzb3VuZC5fcGFubmVyLnNldFBvc2l0aW9uKHBhbiwgMCwgMCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzb3VuZC5fcGFubmVyLnBhbi52YWx1ZSA9IHBhbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzZWxmLl9lbWl0KCdzdGVyZW8nLCBzb3VuZC5faWQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBzb3VuZC5fc3RlcmVvO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHNlbGY7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldC9zZXQgdGhlIDNEIHNwYXRpYWwgcG9zaXRpb24gb2YgdGhlIGF1ZGlvIHNvdXJjZSBmb3IgdGhpcyBzb3VuZCBvciBncm91cCByZWxhdGl2ZSB0byB0aGUgZ2xvYmFsIGxpc3RlbmVyLlxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHggIFRoZSB4LXBvc2l0aW9uIG9mIHRoZSBhdWRpbyBzb3VyY2UuXG4gICAqIEBwYXJhbSAge051bWJlcn0geSAgVGhlIHktcG9zaXRpb24gb2YgdGhlIGF1ZGlvIHNvdXJjZS5cbiAgICogQHBhcmFtICB7TnVtYmVyfSB6ICBUaGUgei1wb3NpdGlvbiBvZiB0aGUgYXVkaW8gc291cmNlLlxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGlkIChvcHRpb25hbCkgVGhlIHNvdW5kIElELiBJZiBub25lIGlzIHBhc3NlZCwgYWxsIGluIGdyb3VwIHdpbGwgYmUgdXBkYXRlZC5cbiAgICogQHJldHVybiB7SG93bC9BcnJheX0gICAgUmV0dXJucyBzZWxmIG9yIHRoZSBjdXJyZW50IDNEIHNwYXRpYWwgcG9zaXRpb246IFt4LCB5LCB6XS5cbiAgICovXG4gIEhvd2wucHJvdG90eXBlLnBvcyA9IGZ1bmN0aW9uKHgsIHksIHosIGlkKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgLy8gU3RvcCByaWdodCBoZXJlIGlmIG5vdCB1c2luZyBXZWIgQXVkaW8uXG4gICAgaWYgKCFzZWxmLl93ZWJBdWRpbykge1xuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIHNvdW5kIGhhc24ndCBsb2FkZWQsIGFkZCBpdCB0byB0aGUgbG9hZCBxdWV1ZSB0byBjaGFuZ2UgcG9zaXRpb24gd2hlbiBjYXBhYmxlLlxuICAgIGlmIChzZWxmLl9zdGF0ZSAhPT0gJ2xvYWRlZCcpIHtcbiAgICAgIHNlbGYuX3F1ZXVlLnB1c2goe1xuICAgICAgICBldmVudDogJ3BvcycsXG4gICAgICAgIGFjdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgc2VsZi5wb3MoeCwgeSwgeiwgaWQpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfVxuXG4gICAgLy8gU2V0IHRoZSBkZWZhdWx0cyBmb3Igb3B0aW9uYWwgJ3knICYgJ3onLlxuICAgIHkgPSAodHlwZW9mIHkgIT09ICdudW1iZXInKSA/IDAgOiB5O1xuICAgIHogPSAodHlwZW9mIHogIT09ICdudW1iZXInKSA/IC0wLjUgOiB6O1xuXG4gICAgLy8gU2V0dXAgdGhlIGdyb3VwJ3Mgc3BhdGlhbCBwb3NpdGlvbiBpZiBubyBJRCBpcyBwYXNzZWQuXG4gICAgaWYgKHR5cGVvZiBpZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIC8vIFJldHVybiB0aGUgZ3JvdXAncyBzcGF0aWFsIHBvc2l0aW9uIGlmIG5vIHBhcmFtZXRlcnMgYXJlIHBhc3NlZC5cbiAgICAgIGlmICh0eXBlb2YgeCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgc2VsZi5fcG9zID0gW3gsIHksIHpdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHNlbGYuX3BvcztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBDaGFuZ2UgdGhlIHNwYXRpYWwgcG9zaXRpb24gb2Ygb25lIG9yIGFsbCBzb3VuZHMgaW4gZ3JvdXAuXG4gICAgdmFyIGlkcyA9IHNlbGYuX2dldFNvdW5kSWRzKGlkKTtcbiAgICBmb3IgKHZhciBpPTA7IGk8aWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAvLyBHZXQgdGhlIHNvdW5kLlxuICAgICAgdmFyIHNvdW5kID0gc2VsZi5fc291bmRCeUlkKGlkc1tpXSk7XG5cbiAgICAgIGlmIChzb3VuZCkge1xuICAgICAgICBpZiAodHlwZW9mIHggPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgc291bmQuX3BvcyA9IFt4LCB5LCB6XTtcblxuICAgICAgICAgIGlmIChzb3VuZC5fbm9kZSkge1xuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlcmUgaXMgYSBwYW5uZXIgc2V0dXAgYW5kIGNyZWF0ZSBhIG5ldyBvbmUgaWYgbm90LlxuICAgICAgICAgICAgaWYgKCFzb3VuZC5fcGFubmVyIHx8IHNvdW5kLl9wYW5uZXIucGFuKSB7XG4gICAgICAgICAgICAgIHNldHVwUGFubmVyKHNvdW5kLCAnc3BhdGlhbCcpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzb3VuZC5fcGFubmVyLnNldFBvc2l0aW9uKHgsIHksIHopO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHNlbGYuX2VtaXQoJ3BvcycsIHNvdW5kLl9pZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHNvdW5kLl9wb3M7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc2VsZjtcbiAgfTtcblxuICAvKipcbiAgICogR2V0L3NldCB0aGUgZGlyZWN0aW9uIHRoZSBhdWRpbyBzb3VyY2UgaXMgcG9pbnRpbmcgaW4gdGhlIDNEIGNhcnRlc2lhbiBjb29yZGluYXRlXG4gICAqIHNwYWNlLiBEZXBlbmRpbmcgb24gaG93IGRpcmVjdGlvbiB0aGUgc291bmQgaXMsIGJhc2VkIG9uIHRoZSBgY29uZWAgYXR0cmlidXRlcyxcbiAgICogYSBzb3VuZCBwb2ludGluZyBhd2F5IGZyb20gdGhlIGxpc3RlbmVyIGNhbiBiZSBxdWlldCBvciBzaWxlbnQuXG4gICAqIEBwYXJhbSAge051bWJlcn0geCAgVGhlIHgtb3JpZW50YXRpb24gb2YgdGhlIHNvdXJjZS5cbiAgICogQHBhcmFtICB7TnVtYmVyfSB5ICBUaGUgeS1vcmllbnRhdGlvbiBvZiB0aGUgc291cmNlLlxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHogIFRoZSB6LW9yaWVudGF0aW9uIG9mIHRoZSBzb3VyY2UuXG4gICAqIEBwYXJhbSAge051bWJlcn0gaWQgKG9wdGlvbmFsKSBUaGUgc291bmQgSUQuIElmIG5vbmUgaXMgcGFzc2VkLCBhbGwgaW4gZ3JvdXAgd2lsbCBiZSB1cGRhdGVkLlxuICAgKiBAcmV0dXJuIHtIb3dsL0FycmF5fSAgICBSZXR1cm5zIHNlbGYgb3IgdGhlIGN1cnJlbnQgM0Qgc3BhdGlhbCBvcmllbnRhdGlvbjogW3gsIHksIHpdLlxuICAgKi9cbiAgSG93bC5wcm90b3R5cGUub3JpZW50YXRpb24gPSBmdW5jdGlvbih4LCB5LCB6LCBpZCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIC8vIFN0b3AgcmlnaHQgaGVyZSBpZiBub3QgdXNpbmcgV2ViIEF1ZGlvLlxuICAgIGlmICghc2VsZi5fd2ViQXVkaW8pIHtcbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cblxuICAgIC8vIElmIHRoZSBzb3VuZCBoYXNuJ3QgbG9hZGVkLCBhZGQgaXQgdG8gdGhlIGxvYWQgcXVldWUgdG8gY2hhbmdlIG9yaWVudGF0aW9uIHdoZW4gY2FwYWJsZS5cbiAgICBpZiAoc2VsZi5fc3RhdGUgIT09ICdsb2FkZWQnKSB7XG4gICAgICBzZWxmLl9xdWV1ZS5wdXNoKHtcbiAgICAgICAgZXZlbnQ6ICdvcmllbnRhdGlvbicsXG4gICAgICAgIGFjdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgc2VsZi5vcmllbnRhdGlvbih4LCB5LCB6LCBpZCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9XG5cbiAgICAvLyBTZXQgdGhlIGRlZmF1bHRzIGZvciBvcHRpb25hbCAneScgJiAneicuXG4gICAgeSA9ICh0eXBlb2YgeSAhPT0gJ251bWJlcicpID8gc2VsZi5fb3JpZW50YXRpb25bMV0gOiB5O1xuICAgIHogPSAodHlwZW9mIHogIT09ICdudW1iZXInKSA/IHNlbGYuX29yaWVudGF0aW9uWzJdIDogejtcblxuICAgIC8vIFNldHVwIHRoZSBncm91cCdzIHNwYXRpYWwgb3JpZW50YXRpb24gaWYgbm8gSUQgaXMgcGFzc2VkLlxuICAgIGlmICh0eXBlb2YgaWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAvLyBSZXR1cm4gdGhlIGdyb3VwJ3Mgc3BhdGlhbCBvcmllbnRhdGlvbiBpZiBubyBwYXJhbWV0ZXJzIGFyZSBwYXNzZWQuXG4gICAgICBpZiAodHlwZW9mIHggPT09ICdudW1iZXInKSB7XG4gICAgICAgIHNlbGYuX29yaWVudGF0aW9uID0gW3gsIHksIHpdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHNlbGYuX29yaWVudGF0aW9uO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIENoYW5nZSB0aGUgc3BhdGlhbCBvcmllbnRhdGlvbiBvZiBvbmUgb3IgYWxsIHNvdW5kcyBpbiBncm91cC5cbiAgICB2YXIgaWRzID0gc2VsZi5fZ2V0U291bmRJZHMoaWQpO1xuICAgIGZvciAodmFyIGk9MDsgaTxpZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIC8vIEdldCB0aGUgc291bmQuXG4gICAgICB2YXIgc291bmQgPSBzZWxmLl9zb3VuZEJ5SWQoaWRzW2ldKTtcblxuICAgICAgaWYgKHNvdW5kKSB7XG4gICAgICAgIGlmICh0eXBlb2YgeCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICBzb3VuZC5fb3JpZW50YXRpb24gPSBbeCwgeSwgel07XG5cbiAgICAgICAgICBpZiAoc291bmQuX25vZGUpIHtcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoZXJlIGlzIGEgcGFubmVyIHNldHVwIGFuZCBjcmVhdGUgYSBuZXcgb25lIGlmIG5vdC5cbiAgICAgICAgICAgIGlmICghc291bmQuX3Bhbm5lcikge1xuICAgICAgICAgICAgICAvLyBNYWtlIHN1cmUgd2UgaGF2ZSBhIHBvc2l0aW9uIHRvIHNldHVwIHRoZSBub2RlIHdpdGguXG4gICAgICAgICAgICAgIGlmICghc291bmQuX3Bvcykge1xuICAgICAgICAgICAgICAgIHNvdW5kLl9wb3MgPSBzZWxmLl9wb3MgfHwgWzAsIDAsIC0wLjVdO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgc2V0dXBQYW5uZXIoc291bmQsICdzcGF0aWFsJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNvdW5kLl9wYW5uZXIuc2V0T3JpZW50YXRpb24oeCwgeSwgeik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc2VsZi5fZW1pdCgnb3JpZW50YXRpb24nLCBzb3VuZC5faWQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBzb3VuZC5fb3JpZW50YXRpb247XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc2VsZjtcbiAgfTtcblxuICAvKipcbiAgICogR2V0L3NldCB0aGUgcGFubmVyIG5vZGUncyBhdHRyaWJ1dGVzIGZvciBhIHNvdW5kIG9yIGdyb3VwIG9mIHNvdW5kcy5cbiAgICogVGhpcyBtZXRob2QgY2FuIG9wdGlvbmFsbCB0YWtlIDAsIDEgb3IgMiBhcmd1bWVudHMuXG4gICAqICAgcGFubmVyQXR0cigpIC0+IFJldHVybnMgdGhlIGdyb3VwJ3MgdmFsdWVzLlxuICAgKiAgIHBhbm5lckF0dHIoaWQpIC0+IFJldHVybnMgdGhlIHNvdW5kIGlkJ3MgdmFsdWVzLlxuICAgKiAgIHBhbm5lckF0dHIobykgLT4gU2V0J3MgdGhlIHZhbHVlcyBvZiBhbGwgc291bmRzIGluIHRoaXMgSG93bCBncm91cC5cbiAgICogICBwYW5uZXJBdHRyKG8sIGlkKSAtPiBTZXQncyB0aGUgdmFsdWVzIG9mIHBhc3NlZCBzb3VuZCBpZC5cbiAgICpcbiAgICogICBBdHRyaWJ1dGVzOlxuICAgKiAgICAgY29uZUlubmVyQW5nbGUgLSAoMzYwIGJ5IGRlZmF1bHQpIEEgcGFyYW1ldGVyIGZvciBkaXJlY3Rpb25hbCBhdWRpbyBzb3VyY2VzLCB0aGlzIGlzIGFuIGFuZ2xlLCBpbiBkZWdyZWVzLFxuICAgKiAgICAgICAgICAgICAgICAgICAgICBpbnNpZGUgb2Ygd2hpY2ggdGhlcmUgd2lsbCBiZSBubyB2b2x1bWUgcmVkdWN0aW9uLlxuICAgKiAgICAgY29uZU91dGVyQW5nbGUgLSAoMzYwIGJ5IGRlZmF1bHQpIEEgcGFyYW1ldGVyIGZvciBkaXJlY3Rpb25hbCBhdWRpbyBzb3VyY2VzLCB0aGlzIGlzIGFuIGFuZ2xlLCBpbiBkZWdyZWVzLFxuICAgKiAgICAgICAgICAgICAgICAgICAgICBvdXRzaWRlIG9mIHdoaWNoIHRoZSB2b2x1bWUgd2lsbCBiZSByZWR1Y2VkIHRvIGEgY29uc3RhbnQgdmFsdWUgb2YgYGNvbmVPdXRlckdhaW5gLlxuICAgKiAgICAgY29uZU91dGVyR2FpbiAtICgwIGJ5IGRlZmF1bHQpIEEgcGFyYW1ldGVyIGZvciBkaXJlY3Rpb25hbCBhdWRpbyBzb3VyY2VzLCB0aGlzIGlzIHRoZSBnYWluIG91dHNpZGUgb2YgdGhlXG4gICAqICAgICAgICAgICAgICAgICAgICAgYGNvbmVPdXRlckFuZ2xlYC4gSXQgaXMgYSBsaW5lYXIgdmFsdWUgaW4gdGhlIHJhbmdlIGBbMCwgMV1gLlxuICAgKiAgICAgZGlzdGFuY2VNb2RlbCAtICgnaW52ZXJzZScgYnkgZGVmYXVsdCkgRGV0ZXJtaW5lcyBhbGdvcml0aG0gdXNlZCB0byByZWR1Y2Ugdm9sdW1lIGFzIGF1ZGlvIG1vdmVzIGF3YXkgZnJvbVxuICAgKiAgICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyLiBDYW4gYmUgYGxpbmVhcmAsIGBpbnZlcnNlYCBvciBgZXhwb25lbnRpYWwuXG4gICAqICAgICBtYXhEaXN0YW5jZSAtICgxMDAwMCBieSBkZWZhdWx0KSBUaGUgbWF4aW11bSBkaXN0YW5jZSBiZXR3ZWVuIHNvdXJjZSBhbmQgbGlzdGVuZXIsIGFmdGVyIHdoaWNoIHRoZSB2b2x1bWVcbiAgICogICAgICAgICAgICAgICAgICAgd2lsbCBub3QgYmUgcmVkdWNlZCBhbnkgZnVydGhlci5cbiAgICogICAgIHJlZkRpc3RhbmNlIC0gKDEgYnkgZGVmYXVsdCkgQSByZWZlcmVuY2UgZGlzdGFuY2UgZm9yIHJlZHVjaW5nIHZvbHVtZSBhcyBzb3VyY2UgbW92ZXMgZnVydGhlciBmcm9tIHRoZSBsaXN0ZW5lci5cbiAgICogICAgICAgICAgICAgICAgICAgVGhpcyBpcyBzaW1wbHkgYSB2YXJpYWJsZSBvZiB0aGUgZGlzdGFuY2UgbW9kZWwgYW5kIGhhcyBhIGRpZmZlcmVudCBlZmZlY3QgZGVwZW5kaW5nIG9uIHdoaWNoIG1vZGVsXG4gICAqICAgICAgICAgICAgICAgICAgIGlzIHVzZWQgYW5kIHRoZSBzY2FsZSBvZiB5b3VyIGNvb3JkaW5hdGVzLiBHZW5lcmFsbHksIHZvbHVtZSB3aWxsIGJlIGVxdWFsIHRvIDEgYXQgdGhpcyBkaXN0YW5jZS5cbiAgICogICAgIHJvbGxvZmZGYWN0b3IgLSAoMSBieSBkZWZhdWx0KSBIb3cgcXVpY2tseSB0aGUgdm9sdW1lIHJlZHVjZXMgYXMgc291cmNlIG1vdmVzIGZyb20gbGlzdGVuZXIuIFRoaXMgaXMgc2ltcGx5IGFcbiAgICogICAgICAgICAgICAgICAgICAgICB2YXJpYWJsZSBvZiB0aGUgZGlzdGFuY2UgbW9kZWwgYW5kIGNhbiBiZSBpbiB0aGUgcmFuZ2Ugb2YgYFswLCAxXWAgd2l0aCBgbGluZWFyYCBhbmQgYFswLCDiiJ5dYFxuICAgKiAgICAgICAgICAgICAgICAgICAgIHdpdGggYGludmVyc2VgIGFuZCBgZXhwb25lbnRpYWxgLlxuICAgKiAgICAgcGFubmluZ01vZGVsIC0gKCdIUlRGJyBieSBkZWZhdWx0KSBEZXRlcm1pbmVzIHdoaWNoIHNwYXRpYWxpemF0aW9uIGFsZ29yaXRobSBpcyB1c2VkIHRvIHBvc2l0aW9uIGF1ZGlvLlxuICAgKiAgICAgICAgICAgICAgICAgICAgIENhbiBiZSBgSFJURmAgb3IgYGVxdWFscG93ZXJgLlxuICAgKiBcbiAgICogQHJldHVybiB7SG93bC9PYmplY3R9IFJldHVybnMgc2VsZiBvciBjdXJyZW50IHBhbm5lciBhdHRyaWJ1dGVzLlxuICAgKi9cbiAgSG93bC5wcm90b3R5cGUucGFubmVyQXR0ciA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICB2YXIgbywgaWQsIHNvdW5kO1xuXG4gICAgLy8gU3RvcCByaWdodCBoZXJlIGlmIG5vdCB1c2luZyBXZWIgQXVkaW8uXG4gICAgaWYgKCFzZWxmLl93ZWJBdWRpbykge1xuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfVxuXG4gICAgLy8gRGV0ZXJtaW5lIHRoZSB2YWx1ZXMgYmFzZWQgb24gYXJndW1lbnRzLlxuICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgLy8gUmV0dXJuIHRoZSBncm91cCdzIHBhbm5lciBhdHRyaWJ1dGUgdmFsdWVzLlxuICAgICAgcmV0dXJuIHNlbGYuX3Bhbm5lckF0dHI7XG4gICAgfSBlbHNlIGlmIChhcmdzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgaWYgKHR5cGVvZiBhcmdzWzBdID09PSAnb2JqZWN0Jykge1xuICAgICAgICBvID0gYXJnc1swXTtcblxuICAgICAgICAvLyBTZXQgdGhlIGdyb3UncyBwYW5uZXIgYXR0cmlidXRlIHZhbHVlcy5cbiAgICAgICAgaWYgKHR5cGVvZiBpZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICBpZiAoIW8ucGFubmVyQXR0cikge1xuICAgICAgICAgICAgby5wYW5uZXJBdHRyID0ge1xuICAgICAgICAgICAgICBjb25lSW5uZXJBbmdsZTogby5jb25lSW5uZXJBbmdsZSxcbiAgICAgICAgICAgICAgY29uZU91dGVyQW5nbGU6IG8uY29uZU91dGVyQW5nbGUsXG4gICAgICAgICAgICAgIGNvbmVPdXRlckdhaW46IG8uY29uZU91dGVyR2FpbixcbiAgICAgICAgICAgICAgZGlzdGFuY2VNb2RlbDogby5kaXN0YW5jZU1vZGVsLFxuICAgICAgICAgICAgICBtYXhEaXN0YW5jZTogby5tYXhEaXN0YW5jZSxcbiAgICAgICAgICAgICAgcmVmRGlzdGFuY2U6IG8ucmVmRGlzdGFuY2UsXG4gICAgICAgICAgICAgIHJvbGxvZmZGYWN0b3I6IG8ucm9sbG9mZkZhY3RvcixcbiAgICAgICAgICAgICAgcGFubmluZ01vZGVsOiBvLnBhbm5pbmdNb2RlbFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzZWxmLl9wYW5uZXJBdHRyID0ge1xuICAgICAgICAgICAgY29uZUlubmVyQW5nbGU6IHR5cGVvZiBvLnBhbm5lckF0dHIuY29uZUlubmVyQW5nbGUgIT09ICd1bmRlZmluZWQnID8gby5wYW5uZXJBdHRyLmNvbmVJbm5lckFuZ2xlIDogc2VsZi5fY29uZUlubmVyQW5nbGUsXG4gICAgICAgICAgICBjb25lT3V0ZXJBbmdsZTogdHlwZW9mIG8ucGFubmVyQXR0ci5jb25lT3V0ZXJBbmdsZSAhPT0gJ3VuZGVmaW5lZCcgPyBvLnBhbm5lckF0dHIuY29uZU91dGVyQW5nbGUgOiBzZWxmLl9jb25lT3V0ZXJBbmdsZSxcbiAgICAgICAgICAgIGNvbmVPdXRlckdhaW46IHR5cGVvZiBvLnBhbm5lckF0dHIuY29uZU91dGVyR2FpbiAhPT0gJ3VuZGVmaW5lZCcgPyBvLnBhbm5lckF0dHIuY29uZU91dGVyR2FpbiA6IHNlbGYuX2NvbmVPdXRlckdhaW4sXG4gICAgICAgICAgICBkaXN0YW5jZU1vZGVsOiB0eXBlb2Ygby5wYW5uZXJBdHRyLmRpc3RhbmNlTW9kZWwgIT09ICd1bmRlZmluZWQnID8gby5wYW5uZXJBdHRyLmRpc3RhbmNlTW9kZWwgOiBzZWxmLl9kaXN0YW5jZU1vZGVsLFxuICAgICAgICAgICAgbWF4RGlzdGFuY2U6IHR5cGVvZiBvLnBhbm5lckF0dHIubWF4RGlzdGFuY2UgIT09ICd1bmRlZmluZWQnID8gby5wYW5uZXJBdHRyLm1heERpc3RhbmNlIDogc2VsZi5fbWF4RGlzdGFuY2UsXG4gICAgICAgICAgICByZWZEaXN0YW5jZTogdHlwZW9mIG8ucGFubmVyQXR0ci5yZWZEaXN0YW5jZSAhPT0gJ3VuZGVmaW5lZCcgPyBvLnBhbm5lckF0dHIucmVmRGlzdGFuY2UgOiBzZWxmLl9yZWZEaXN0YW5jZSxcbiAgICAgICAgICAgIHJvbGxvZmZGYWN0b3I6IHR5cGVvZiBvLnBhbm5lckF0dHIucm9sbG9mZkZhY3RvciAhPT0gJ3VuZGVmaW5lZCcgPyBvLnBhbm5lckF0dHIucm9sbG9mZkZhY3RvciA6IHNlbGYuX3JvbGxvZmZGYWN0b3IsXG4gICAgICAgICAgICBwYW5uaW5nTW9kZWw6IHR5cGVvZiBvLnBhbm5lckF0dHIucGFubmluZ01vZGVsICE9PSAndW5kZWZpbmVkJyA/IG8ucGFubmVyQXR0ci5wYW5uaW5nTW9kZWwgOiBzZWxmLl9wYW5uaW5nTW9kZWxcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBSZXR1cm4gdGhpcyBzb3VuZCdzIHBhbm5lciBhdHRyaWJ1dGUgdmFsdWVzLlxuICAgICAgICBzb3VuZCA9IHNlbGYuX3NvdW5kQnlJZChwYXJzZUludChhcmdzWzBdLCAxMCkpO1xuICAgICAgICByZXR1cm4gc291bmQgPyBzb3VuZC5fcGFubmVyQXR0ciA6IHNlbGYuX3Bhbm5lckF0dHI7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChhcmdzLmxlbmd0aCA9PT0gMikge1xuICAgICAgbyA9IGFyZ3NbMF07XG4gICAgICBpZCA9IHBhcnNlSW50KGFyZ3NbMV0sIDEwKTtcbiAgICB9XG5cbiAgICAvLyBVcGRhdGUgdGhlIHZhbHVlcyBvZiB0aGUgc3BlY2lmaWVkIHNvdW5kcy5cbiAgICB2YXIgaWRzID0gc2VsZi5fZ2V0U291bmRJZHMoaWQpO1xuICAgIGZvciAodmFyIGk9MDsgaTxpZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHNvdW5kID0gc2VsZi5fc291bmRCeUlkKGlkc1tpXSk7XG5cbiAgICAgIGlmIChzb3VuZCkge1xuICAgICAgICAvLyBNZXJnZSB0aGUgbmV3IHZhbHVlcyBpbnRvIHRoZSBzb3VuZC5cbiAgICAgICAgdmFyIHBhID0gc291bmQuX3Bhbm5lckF0dHI7XG4gICAgICAgIHBhID0ge1xuICAgICAgICAgIGNvbmVJbm5lckFuZ2xlOiB0eXBlb2Ygby5jb25lSW5uZXJBbmdsZSAhPT0gJ3VuZGVmaW5lZCcgPyBvLmNvbmVJbm5lckFuZ2xlIDogcGEuY29uZUlubmVyQW5nbGUsXG4gICAgICAgICAgY29uZU91dGVyQW5nbGU6IHR5cGVvZiBvLmNvbmVPdXRlckFuZ2xlICE9PSAndW5kZWZpbmVkJyA/IG8uY29uZU91dGVyQW5nbGUgOiBwYS5jb25lT3V0ZXJBbmdsZSxcbiAgICAgICAgICBjb25lT3V0ZXJHYWluOiB0eXBlb2Ygby5jb25lT3V0ZXJHYWluICE9PSAndW5kZWZpbmVkJyA/IG8uY29uZU91dGVyR2FpbiA6IHBhLmNvbmVPdXRlckdhaW4sXG4gICAgICAgICAgZGlzdGFuY2VNb2RlbDogdHlwZW9mIG8uZGlzdGFuY2VNb2RlbCAhPT0gJ3VuZGVmaW5lZCcgPyBvLmRpc3RhbmNlTW9kZWwgOiBwYS5kaXN0YW5jZU1vZGVsLFxuICAgICAgICAgIG1heERpc3RhbmNlOiB0eXBlb2Ygby5tYXhEaXN0YW5jZSAhPT0gJ3VuZGVmaW5lZCcgPyBvLm1heERpc3RhbmNlIDogcGEubWF4RGlzdGFuY2UsXG4gICAgICAgICAgcmVmRGlzdGFuY2U6IHR5cGVvZiBvLnJlZkRpc3RhbmNlICE9PSAndW5kZWZpbmVkJyA/IG8ucmVmRGlzdGFuY2UgOiBwYS5yZWZEaXN0YW5jZSxcbiAgICAgICAgICByb2xsb2ZmRmFjdG9yOiB0eXBlb2Ygby5yb2xsb2ZmRmFjdG9yICE9PSAndW5kZWZpbmVkJyA/IG8ucm9sbG9mZkZhY3RvciA6IHBhLnJvbGxvZmZGYWN0b3IsXG4gICAgICAgICAgcGFubmluZ01vZGVsOiB0eXBlb2Ygby5wYW5uaW5nTW9kZWwgIT09ICd1bmRlZmluZWQnID8gby5wYW5uaW5nTW9kZWwgOiBwYS5wYW5uaW5nTW9kZWxcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBVcGRhdGUgdGhlIHBhbm5lciB2YWx1ZXMgb3IgY3JlYXRlIGEgbmV3IHBhbm5lciBpZiBub25lIGV4aXN0cy5cbiAgICAgICAgdmFyIHBhbm5lciA9IHNvdW5kLl9wYW5uZXI7XG4gICAgICAgIGlmIChwYW5uZXIpIHtcbiAgICAgICAgICBwYW5uZXIuY29uZUlubmVyQW5nbGUgPSBwYS5jb25lSW5uZXJBbmdsZTtcbiAgICAgICAgICBwYW5uZXIuY29uZU91dGVyQW5nbGUgPSBwYS5jb25lT3V0ZXJBbmdsZTtcbiAgICAgICAgICBwYW5uZXIuY29uZU91dGVyR2FpbiA9IHBhLmNvbmVPdXRlckdhaW47XG4gICAgICAgICAgcGFubmVyLmRpc3RhbmNlTW9kZWwgPSBwYS5kaXN0YW5jZU1vZGVsO1xuICAgICAgICAgIHBhbm5lci5tYXhEaXN0YW5jZSA9IHBhLm1heERpc3RhbmNlO1xuICAgICAgICAgIHBhbm5lci5yZWZEaXN0YW5jZSA9IHBhLnJlZkRpc3RhbmNlO1xuICAgICAgICAgIHBhbm5lci5yb2xsb2ZmRmFjdG9yID0gcGEucm9sbG9mZkZhY3RvcjtcbiAgICAgICAgICBwYW5uZXIucGFubmluZ01vZGVsID0gcGEucGFubmluZ01vZGVsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIE1ha2Ugc3VyZSB3ZSBoYXZlIGEgcG9zaXRpb24gdG8gc2V0dXAgdGhlIG5vZGUgd2l0aC5cbiAgICAgICAgICBpZiAoIXNvdW5kLl9wb3MpIHtcbiAgICAgICAgICAgIHNvdW5kLl9wb3MgPSBzZWxmLl9wb3MgfHwgWzAsIDAsIC0wLjVdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIENyZWF0ZSBhIG5ldyBwYW5uZXIgbm9kZS5cbiAgICAgICAgICBzZXR1cFBhbm5lcihzb3VuZCwgJ3NwYXRpYWwnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzZWxmO1xuICB9O1xuXG4gIC8qKiBTaW5nbGUgU291bmQgTWV0aG9kcyAqKi9cbiAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAvKipcbiAgICogQWRkIG5ldyBwcm9wZXJ0aWVzIHRvIHRoZSBjb3JlIFNvdW5kIGluaXQuXG4gICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBfc3VwZXIgQ29yZSBTb3VuZCBpbml0IG1ldGhvZC5cbiAgICogQHJldHVybiB7U291bmR9XG4gICAqL1xuICBTb3VuZC5wcm90b3R5cGUuaW5pdCA9IChmdW5jdGlvbihfc3VwZXIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgcGFyZW50ID0gc2VsZi5fcGFyZW50O1xuXG4gICAgICAvLyBTZXR1cCB1c2VyLWRlZmluZWQgZGVmYXVsdCBwcm9wZXJ0aWVzLlxuICAgICAgc2VsZi5fb3JpZW50YXRpb24gPSBwYXJlbnQuX29yaWVudGF0aW9uO1xuICAgICAgc2VsZi5fc3RlcmVvID0gcGFyZW50Ll9zdGVyZW87XG4gICAgICBzZWxmLl9wb3MgPSBwYXJlbnQuX3BvcztcbiAgICAgIHNlbGYuX3Bhbm5lckF0dHIgPSBwYXJlbnQuX3Bhbm5lckF0dHI7XG5cbiAgICAgIC8vIENvbXBsZXRlIGluaXRpbGl6YXRpb24gd2l0aCBob3dsZXIuanMgY29yZSBTb3VuZCdzIGluaXQgZnVuY3Rpb24uXG4gICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcblxuICAgICAgLy8gSWYgYSBzdGVyZW8gb3IgcG9zaXRpb24gd2FzIHNwZWNpZmllZCwgc2V0IGl0IHVwLlxuICAgICAgaWYgKHNlbGYuX3N0ZXJlbykge1xuICAgICAgICBwYXJlbnQuc3RlcmVvKHNlbGYuX3N0ZXJlbyk7XG4gICAgICB9IGVsc2UgaWYgKHNlbGYuX3Bvcykge1xuICAgICAgICBwYXJlbnQucG9zKHNlbGYuX3Bvc1swXSwgc2VsZi5fcG9zWzFdLCBzZWxmLl9wb3NbMl0sIHNlbGYuX2lkKTtcbiAgICAgIH1cbiAgICB9O1xuICB9KShTb3VuZC5wcm90b3R5cGUuaW5pdCk7XG5cbiAgLyoqXG4gICAqIE92ZXJyaWRlIHRoZSBTb3VuZC5yZXNldCBtZXRob2QgdG8gY2xlYW4gdXAgcHJvcGVydGllcyBmcm9tIHRoZSBzcGF0aWFsIHBsdWdpbi5cbiAgICogQHBhcmFtICB7RnVuY3Rpb259IF9zdXBlciBTb3VuZCByZXNldCBtZXRob2QuXG4gICAqIEByZXR1cm4ge1NvdW5kfVxuICAgKi9cbiAgU291bmQucHJvdG90eXBlLnJlc2V0ID0gKGZ1bmN0aW9uKF9zdXBlcikge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciBwYXJlbnQgPSBzZWxmLl9wYXJlbnQ7XG5cbiAgICAgIC8vIFJlc2V0IGFsbCBzcGF0aWFsIHBsdWdpbiBwcm9wZXJ0aWVzIG9uIHRoaXMgc291bmQuXG4gICAgICBzZWxmLl9vcmllbnRhdGlvbiA9IHBhcmVudC5fb3JpZW50YXRpb247XG4gICAgICBzZWxmLl9wb3MgPSBwYXJlbnQuX3BvcztcbiAgICAgIHNlbGYuX3Bhbm5lckF0dHIgPSBwYXJlbnQuX3Bhbm5lckF0dHI7XG5cbiAgICAgIC8vIENvbXBsZXRlIHJlc2V0dGluZyBvZiB0aGUgc291bmQuXG4gICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgfTtcbiAgfSkoU291bmQucHJvdG90eXBlLnJlc2V0KTtcblxuICAvKiogSGVscGVyIE1ldGhvZHMgKiovXG4gIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBwYW5uZXIgbm9kZSBhbmQgc2F2ZSBpdCBvbiB0aGUgc291bmQuXG4gICAqIEBwYXJhbSAge1NvdW5kfSBzb3VuZCBTcGVjaWZpYyBzb3VuZCB0byBzZXR1cCBwYW5uaW5nIG9uLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUeXBlIG9mIHBhbm5lciB0byBjcmVhdGU6ICdzdGVyZW8nIG9yICdzcGF0aWFsJy5cbiAgICovXG4gIHZhciBzZXR1cFBhbm5lciA9IGZ1bmN0aW9uKHNvdW5kLCB0eXBlKSB7XG4gICAgdHlwZSA9IHR5cGUgfHwgJ3NwYXRpYWwnO1xuXG4gICAgLy8gQ3JlYXRlIHRoZSBuZXcgcGFubmVyIG5vZGUuXG4gICAgaWYgKHR5cGUgPT09ICdzcGF0aWFsJykge1xuICAgICAgc291bmQuX3Bhbm5lciA9IEhvd2xlci5jdHguY3JlYXRlUGFubmVyKCk7XG4gICAgICBzb3VuZC5fcGFubmVyLmNvbmVJbm5lckFuZ2xlID0gc291bmQuX3Bhbm5lckF0dHIuY29uZUlubmVyQW5nbGU7XG4gICAgICBzb3VuZC5fcGFubmVyLmNvbmVPdXRlckFuZ2xlID0gc291bmQuX3Bhbm5lckF0dHIuY29uZU91dGVyQW5nbGU7XG4gICAgICBzb3VuZC5fcGFubmVyLmNvbmVPdXRlckdhaW4gPSBzb3VuZC5fcGFubmVyQXR0ci5jb25lT3V0ZXJHYWluO1xuICAgICAgc291bmQuX3Bhbm5lci5kaXN0YW5jZU1vZGVsID0gc291bmQuX3Bhbm5lckF0dHIuZGlzdGFuY2VNb2RlbDtcbiAgICAgIHNvdW5kLl9wYW5uZXIubWF4RGlzdGFuY2UgPSBzb3VuZC5fcGFubmVyQXR0ci5tYXhEaXN0YW5jZTtcbiAgICAgIHNvdW5kLl9wYW5uZXIucmVmRGlzdGFuY2UgPSBzb3VuZC5fcGFubmVyQXR0ci5yZWZEaXN0YW5jZTtcbiAgICAgIHNvdW5kLl9wYW5uZXIucm9sbG9mZkZhY3RvciA9IHNvdW5kLl9wYW5uZXJBdHRyLnJvbGxvZmZGYWN0b3I7XG4gICAgICBzb3VuZC5fcGFubmVyLnBhbm5pbmdNb2RlbCA9IHNvdW5kLl9wYW5uZXJBdHRyLnBhbm5pbmdNb2RlbDtcbiAgICAgIHNvdW5kLl9wYW5uZXIuc2V0UG9zaXRpb24oc291bmQuX3Bvc1swXSwgc291bmQuX3Bvc1sxXSwgc291bmQuX3Bvc1syXSk7XG4gICAgICBzb3VuZC5fcGFubmVyLnNldE9yaWVudGF0aW9uKHNvdW5kLl9vcmllbnRhdGlvblswXSwgc291bmQuX29yaWVudGF0aW9uWzFdLCBzb3VuZC5fb3JpZW50YXRpb25bMl0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBzb3VuZC5fcGFubmVyID0gSG93bGVyLmN0eC5jcmVhdGVTdGVyZW9QYW5uZXIoKTtcbiAgICAgIHNvdW5kLl9wYW5uZXIucGFuLnZhbHVlID0gc291bmQuX3N0ZXJlbztcbiAgICB9XG5cbiAgICBzb3VuZC5fcGFubmVyLmNvbm5lY3Qoc291bmQuX25vZGUpO1xuXG4gICAgLy8gVXBkYXRlIHRoZSBjb25uZWN0aW9ucy5cbiAgICBpZiAoIXNvdW5kLl9wYXVzZWQpIHtcbiAgICAgIHNvdW5kLl9wYXJlbnQucGF1c2Uoc291bmQuX2lkLCB0cnVlKS5wbGF5KHNvdW5kLl9pZCk7XG4gICAgfVxuICB9O1xufSkoKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9ob3dsZXIvZGlzdC9ob3dsZXIuanMiLCIvKlxub2JqZWN0LWFzc2lnblxuKGMpIFNpbmRyZSBTb3JodXNcbkBsaWNlbnNlIE1JVFxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cbnZhciBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBwcm9wSXNFbnVtZXJhYmxlID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuZnVuY3Rpb24gdG9PYmplY3QodmFsKSB7XG5cdGlmICh2YWwgPT09IG51bGwgfHwgdmFsID09PSB1bmRlZmluZWQpIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdPYmplY3QuYXNzaWduIGNhbm5vdCBiZSBjYWxsZWQgd2l0aCBudWxsIG9yIHVuZGVmaW5lZCcpO1xuXHR9XG5cblx0cmV0dXJuIE9iamVjdCh2YWwpO1xufVxuXG5mdW5jdGlvbiBzaG91bGRVc2VOYXRpdmUoKSB7XG5cdHRyeSB7XG5cdFx0aWYgKCFPYmplY3QuYXNzaWduKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gRGV0ZWN0IGJ1Z2d5IHByb3BlcnR5IGVudW1lcmF0aW9uIG9yZGVyIGluIG9sZGVyIFY4IHZlcnNpb25zLlxuXG5cdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9NDExOFxuXHRcdHZhciB0ZXN0MSA9IG5ldyBTdHJpbmcoJ2FiYycpOyAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXctd3JhcHBlcnNcblx0XHR0ZXN0MVs1XSA9ICdkZSc7XG5cdFx0aWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRlc3QxKVswXSA9PT0gJzUnKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzA1NlxuXHRcdHZhciB0ZXN0MiA9IHt9O1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgMTA7IGkrKykge1xuXHRcdFx0dGVzdDJbJ18nICsgU3RyaW5nLmZyb21DaGFyQ29kZShpKV0gPSBpO1xuXHRcdH1cblx0XHR2YXIgb3JkZXIyID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGVzdDIpLm1hcChmdW5jdGlvbiAobikge1xuXHRcdFx0cmV0dXJuIHRlc3QyW25dO1xuXHRcdH0pO1xuXHRcdGlmIChvcmRlcjIuam9pbignJykgIT09ICcwMTIzNDU2Nzg5Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTMwNTZcblx0XHR2YXIgdGVzdDMgPSB7fTtcblx0XHQnYWJjZGVmZ2hpamtsbW5vcHFyc3QnLnNwbGl0KCcnKS5mb3JFYWNoKGZ1bmN0aW9uIChsZXR0ZXIpIHtcblx0XHRcdHRlc3QzW2xldHRlcl0gPSBsZXR0ZXI7XG5cdFx0fSk7XG5cdFx0aWYgKE9iamVjdC5rZXlzKE9iamVjdC5hc3NpZ24oe30sIHRlc3QzKSkuam9pbignJykgIT09XG5cdFx0XHRcdCdhYmNkZWZnaGlqa2xtbm9wcXJzdCcpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0Ly8gV2UgZG9uJ3QgZXhwZWN0IGFueSBvZiB0aGUgYWJvdmUgdG8gdGhyb3csIGJ1dCBiZXR0ZXIgdG8gYmUgc2FmZS5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzaG91bGRVc2VOYXRpdmUoKSA/IE9iamVjdC5hc3NpZ24gOiBmdW5jdGlvbiAodGFyZ2V0LCBzb3VyY2UpIHtcblx0dmFyIGZyb207XG5cdHZhciB0byA9IHRvT2JqZWN0KHRhcmdldCk7XG5cdHZhciBzeW1ib2xzO1xuXG5cdGZvciAodmFyIHMgPSAxOyBzIDwgYXJndW1lbnRzLmxlbmd0aDsgcysrKSB7XG5cdFx0ZnJvbSA9IE9iamVjdChhcmd1bWVudHNbc10pO1xuXG5cdFx0Zm9yICh2YXIga2V5IGluIGZyb20pIHtcblx0XHRcdGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGZyb20sIGtleSkpIHtcblx0XHRcdFx0dG9ba2V5XSA9IGZyb21ba2V5XTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG5cdFx0XHRzeW1ib2xzID0gZ2V0T3duUHJvcGVydHlTeW1ib2xzKGZyb20pO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzeW1ib2xzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGlmIChwcm9wSXNFbnVtZXJhYmxlLmNhbGwoZnJvbSwgc3ltYm9sc1tpXSkpIHtcblx0XHRcdFx0XHR0b1tzeW1ib2xzW2ldXSA9IGZyb21bc3ltYm9sc1tpXV07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gdG87XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL29iamVjdC1hc3NpZ24vaW5kZXguanMiLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRPbmNlTGlzdGVuZXIgPSBub29wO1xuXG5wcm9jZXNzLmxpc3RlbmVycyA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBbXSB9XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG4gIHZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuICB2YXIgUmVhY3RQcm9wVHlwZXNTZWNyZXQgPSByZXF1aXJlKCcuL2xpYi9SZWFjdFByb3BUeXBlc1NlY3JldCcpO1xuICB2YXIgbG9nZ2VkVHlwZUZhaWx1cmVzID0ge307XG59XG5cbi8qKlxuICogQXNzZXJ0IHRoYXQgdGhlIHZhbHVlcyBtYXRjaCB3aXRoIHRoZSB0eXBlIHNwZWNzLlxuICogRXJyb3IgbWVzc2FnZXMgYXJlIG1lbW9yaXplZCBhbmQgd2lsbCBvbmx5IGJlIHNob3duIG9uY2UuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IHR5cGVTcGVjcyBNYXAgb2YgbmFtZSB0byBhIFJlYWN0UHJvcFR5cGVcbiAqIEBwYXJhbSB7b2JqZWN0fSB2YWx1ZXMgUnVudGltZSB2YWx1ZXMgdGhhdCBuZWVkIHRvIGJlIHR5cGUtY2hlY2tlZFxuICogQHBhcmFtIHtzdHJpbmd9IGxvY2F0aW9uIGUuZy4gXCJwcm9wXCIsIFwiY29udGV4dFwiLCBcImNoaWxkIGNvbnRleHRcIlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbXBvbmVudE5hbWUgTmFtZSBvZiB0aGUgY29tcG9uZW50IGZvciBlcnJvciBtZXNzYWdlcy5cbiAqIEBwYXJhbSB7P0Z1bmN0aW9ufSBnZXRTdGFjayBSZXR1cm5zIHRoZSBjb21wb25lbnQgc3RhY2suXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjaGVja1Byb3BUeXBlcyh0eXBlU3BlY3MsIHZhbHVlcywgbG9jYXRpb24sIGNvbXBvbmVudE5hbWUsIGdldFN0YWNrKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgZm9yICh2YXIgdHlwZVNwZWNOYW1lIGluIHR5cGVTcGVjcykge1xuICAgICAgaWYgKHR5cGVTcGVjcy5oYXNPd25Qcm9wZXJ0eSh0eXBlU3BlY05hbWUpKSB7XG4gICAgICAgIHZhciBlcnJvcjtcbiAgICAgICAgLy8gUHJvcCB0eXBlIHZhbGlkYXRpb24gbWF5IHRocm93LiBJbiBjYXNlIHRoZXkgZG8sIHdlIGRvbid0IHdhbnQgdG9cbiAgICAgICAgLy8gZmFpbCB0aGUgcmVuZGVyIHBoYXNlIHdoZXJlIGl0IGRpZG4ndCBmYWlsIGJlZm9yZS4gU28gd2UgbG9nIGl0LlxuICAgICAgICAvLyBBZnRlciB0aGVzZSBoYXZlIGJlZW4gY2xlYW5lZCB1cCwgd2UnbGwgbGV0IHRoZW0gdGhyb3cuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyBpbnRlbnRpb25hbGx5IGFuIGludmFyaWFudCB0aGF0IGdldHMgY2F1Z2h0LiBJdCdzIHRoZSBzYW1lXG4gICAgICAgICAgLy8gYmVoYXZpb3IgYXMgd2l0aG91dCB0aGlzIHN0YXRlbWVudCBleGNlcHQgd2l0aCBhIGJldHRlciBtZXNzYWdlLlxuICAgICAgICAgIGludmFyaWFudCh0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gPT09ICdmdW5jdGlvbicsICclczogJXMgdHlwZSBgJXNgIGlzIGludmFsaWQ7IGl0IG11c3QgYmUgYSBmdW5jdGlvbiwgdXN1YWxseSBmcm9tICcgKyAndGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLCBidXQgcmVjZWl2ZWQgYCVzYC4nLCBjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycsIGxvY2F0aW9uLCB0eXBlU3BlY05hbWUsIHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSk7XG4gICAgICAgICAgZXJyb3IgPSB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSh2YWx1ZXMsIHR5cGVTcGVjTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIG51bGwsIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICBlcnJvciA9IGV4O1xuICAgICAgICB9XG4gICAgICAgIHdhcm5pbmcoIWVycm9yIHx8IGVycm9yIGluc3RhbmNlb2YgRXJyb3IsICclczogdHlwZSBzcGVjaWZpY2F0aW9uIG9mICVzIGAlc2AgaXMgaW52YWxpZDsgdGhlIHR5cGUgY2hlY2tlciAnICsgJ2Z1bmN0aW9uIG11c3QgcmV0dXJuIGBudWxsYCBvciBhbiBgRXJyb3JgIGJ1dCByZXR1cm5lZCBhICVzLiAnICsgJ1lvdSBtYXkgaGF2ZSBmb3Jnb3R0ZW4gdG8gcGFzcyBhbiBhcmd1bWVudCB0byB0aGUgdHlwZSBjaGVja2VyICcgKyAnY3JlYXRvciAoYXJyYXlPZiwgaW5zdGFuY2VPZiwgb2JqZWN0T2YsIG9uZU9mLCBvbmVPZlR5cGUsIGFuZCAnICsgJ3NoYXBlIGFsbCByZXF1aXJlIGFuIGFyZ3VtZW50KS4nLCBjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycsIGxvY2F0aW9uLCB0eXBlU3BlY05hbWUsIHR5cGVvZiBlcnJvcik7XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmICEoZXJyb3IubWVzc2FnZSBpbiBsb2dnZWRUeXBlRmFpbHVyZXMpKSB7XG4gICAgICAgICAgLy8gT25seSBtb25pdG9yIHRoaXMgZmFpbHVyZSBvbmNlIGJlY2F1c2UgdGhlcmUgdGVuZHMgdG8gYmUgYSBsb3Qgb2YgdGhlXG4gICAgICAgICAgLy8gc2FtZSBlcnJvci5cbiAgICAgICAgICBsb2dnZWRUeXBlRmFpbHVyZXNbZXJyb3IubWVzc2FnZV0gPSB0cnVlO1xuXG4gICAgICAgICAgdmFyIHN0YWNrID0gZ2V0U3RhY2sgPyBnZXRTdGFjaygpIDogJyc7XG5cbiAgICAgICAgICB3YXJuaW5nKGZhbHNlLCAnRmFpbGVkICVzIHR5cGU6ICVzJXMnLCBsb2NhdGlvbiwgZXJyb3IubWVzc2FnZSwgc3RhY2sgIT0gbnVsbCA/IHN0YWNrIDogJycpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2hlY2tQcm9wVHlwZXM7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9jaGVja1Byb3BUeXBlcy5qcyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RQcm9wVHlwZXNTZWNyZXQgPSAnU0VDUkVUX0RPX05PVF9QQVNTX1RISVNfT1JfWU9VX1dJTExfQkVfRklSRUQnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0UHJvcFR5cGVzU2VjcmV0O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0LmpzIiwiLyoqIEBsaWNlbnNlIFJlYWN0IHYxNi4yLjBcbiAqIHJlYWN0LXRlc3QtcmVuZGVyZXIuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cblxuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIChmdW5jdGlvbigpIHtcbid1c2Ugc3RyaWN0JztcblxudmFyIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcbnZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG52YXIgZW1wdHlPYmplY3QgPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eU9iamVjdCcpO1xudmFyIGNoZWNrUHJvcFR5cGVzID0gcmVxdWlyZSgncHJvcC10eXBlcy9jaGVja1Byb3BUeXBlcycpO1xudmFyIHNoYWxsb3dFcXVhbCA9IHJlcXVpcmUoJ2ZianMvbGliL3NoYWxsb3dFcXVhbCcpO1xuXG4vKipcbiAqIFdBUk5JTkc6IERPIE5PVCBtYW51YWxseSByZXF1aXJlIHRoaXMgbW9kdWxlLlxuICogVGhpcyBpcyBhIHJlcGxhY2VtZW50IGZvciBgaW52YXJpYW50KC4uLilgIHVzZWQgYnkgdGhlIGVycm9yIGNvZGUgc3lzdGVtXG4gKiBhbmQgd2lsbCBfb25seV8gYmUgcmVxdWlyZWQgYnkgdGhlIGNvcnJlc3BvbmRpbmcgYmFiZWwgcGFzcy5cbiAqIEl0IGFsd2F5cyB0aHJvd3MuXG4gKi9cblxudmFyIGVuYWJsZUFzeW5jU3VidHJlZUFQSSA9IHRydWU7XG5cbi8vIEV4cG9ydHMgUmVhY3RET00uY3JlYXRlUm9vdFxuXG52YXIgZW5hYmxlVXNlclRpbWluZ0FQSSA9IHRydWU7XG5cbi8vIE11dGF0aW5nIG1vZGUgKFJlYWN0IERPTSwgUmVhY3QgQVJULCBSZWFjdCBOYXRpdmUpOlxudmFyIGVuYWJsZU11dGF0aW5nUmVjb25jaWxlciA9IHRydWU7XG4vLyBFeHBlcmltZW50YWwgbm9vcCBtb2RlIChjdXJyZW50bHkgdW51c2VkKTpcbnZhciBlbmFibGVOb29wUmVjb25jaWxlciA9IGZhbHNlO1xuLy8gRXhwZXJpbWVudGFsIHBlcnNpc3RlbnQgbW9kZSAoQ1MpOlxudmFyIGVuYWJsZVBlcnNpc3RlbnRSZWNvbmNpbGVyID0gZmFsc2U7XG5cbi8vIEhlbHBzIGlkZW50aWZ5IHNpZGUgZWZmZWN0cyBpbiBiZWdpbi1waGFzZSBsaWZlY3ljbGUgaG9va3MgYW5kIHNldFN0YXRlIHJlZHVjZXJzOlxudmFyIGRlYnVnUmVuZGVyUGhhc2VTaWRlRWZmZWN0cyA9IGZhbHNlO1xuXG4vLyBPbmx5IHVzZWQgaW4gd3d3IGJ1aWxkcy5cblxuLyoqXG4gKiBgUmVhY3RJbnN0YW5jZU1hcGAgbWFpbnRhaW5zIGEgbWFwcGluZyBmcm9tIGEgcHVibGljIGZhY2luZyBzdGF0ZWZ1bFxuICogaW5zdGFuY2UgKGtleSkgYW5kIHRoZSBpbnRlcm5hbCByZXByZXNlbnRhdGlvbiAodmFsdWUpLiBUaGlzIGFsbG93cyBwdWJsaWNcbiAqIG1ldGhvZHMgdG8gYWNjZXB0IHRoZSB1c2VyIGZhY2luZyBpbnN0YW5jZSBhcyBhbiBhcmd1bWVudCBhbmQgbWFwIHRoZW0gYmFja1xuICogdG8gaW50ZXJuYWwgbWV0aG9kcy5cbiAqXG4gKiBOb3RlIHRoYXQgdGhpcyBtb2R1bGUgaXMgY3VycmVudGx5IHNoYXJlZCBhbmQgYXNzdW1lZCB0byBiZSBzdGF0ZWxlc3MuXG4gKiBJZiB0aGlzIGJlY29tZXMgYW4gYWN0dWFsIE1hcCwgdGhhdCB3aWxsIGJyZWFrLlxuICovXG5cbi8qKlxuICogVGhpcyBBUEkgc2hvdWxkIGJlIGNhbGxlZCBgZGVsZXRlYCBidXQgd2UnZCBoYXZlIHRvIG1ha2Ugc3VyZSB0byBhbHdheXNcbiAqIHRyYW5zZm9ybSB0aGVzZSB0byBzdHJpbmdzIGZvciBJRSBzdXBwb3J0LiBXaGVuIHRoaXMgdHJhbnNmb3JtIGlzIGZ1bGx5XG4gKiBzdXBwb3J0ZWQgd2UgY2FuIHJlbmFtZSBpdC5cbiAqL1xuXG5cbmZ1bmN0aW9uIGdldChrZXkpIHtcbiAgcmV0dXJuIGtleS5fcmVhY3RJbnRlcm5hbEZpYmVyO1xufVxuXG5cblxuZnVuY3Rpb24gc2V0KGtleSwgdmFsdWUpIHtcbiAga2V5Ll9yZWFjdEludGVybmFsRmliZXIgPSB2YWx1ZTtcbn1cblxudmFyIFJlYWN0SW50ZXJuYWxzID0gUmVhY3QuX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQ7XG5cbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IFJlYWN0SW50ZXJuYWxzLlJlYWN0Q3VycmVudE93bmVyO1xudmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSBSZWFjdEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuXG5mdW5jdGlvbiBnZXRDb21wb25lbnROYW1lKGZpYmVyKSB7XG4gIHZhciB0eXBlID0gZmliZXIudHlwZTtcblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG52YXIgSW5kZXRlcm1pbmF0ZUNvbXBvbmVudCA9IDA7IC8vIEJlZm9yZSB3ZSBrbm93IHdoZXRoZXIgaXQgaXMgZnVuY3Rpb25hbCBvciBjbGFzc1xudmFyIEZ1bmN0aW9uYWxDb21wb25lbnQgPSAxO1xudmFyIENsYXNzQ29tcG9uZW50ID0gMjtcbnZhciBIb3N0Um9vdCA9IDM7IC8vIFJvb3Qgb2YgYSBob3N0IHRyZWUuIENvdWxkIGJlIG5lc3RlZCBpbnNpZGUgYW5vdGhlciBub2RlLlxudmFyIEhvc3RQb3J0YWwgPSA0OyAvLyBBIHN1YnRyZWUuIENvdWxkIGJlIGFuIGVudHJ5IHBvaW50IHRvIGEgZGlmZmVyZW50IHJlbmRlcmVyLlxudmFyIEhvc3RDb21wb25lbnQgPSA1O1xudmFyIEhvc3RUZXh0ID0gNjtcbnZhciBDYWxsQ29tcG9uZW50ID0gNztcbnZhciBDYWxsSGFuZGxlclBoYXNlID0gODtcbnZhciBSZXR1cm5Db21wb25lbnQgPSA5O1xudmFyIEZyYWdtZW50ID0gMTA7XG5cbi8vIERvbid0IGNoYW5nZSB0aGVzZSB0d28gdmFsdWVzOlxudmFyIE5vRWZmZWN0ID0gMDsgLy8gICAgICAgICAgIDBiMDAwMDAwMDBcbnZhciBQZXJmb3JtZWRXb3JrID0gMTsgLy8gICAgICAwYjAwMDAwMDAxXG5cbi8vIFlvdSBjYW4gY2hhbmdlIHRoZSByZXN0IChhbmQgYWRkIG1vcmUpLlxudmFyIFBsYWNlbWVudCA9IDI7IC8vICAgICAgICAgIDBiMDAwMDAwMTBcbnZhciBVcGRhdGUgPSA0OyAvLyAgICAgICAgICAgICAwYjAwMDAwMTAwXG52YXIgUGxhY2VtZW50QW5kVXBkYXRlID0gNjsgLy8gMGIwMDAwMDExMFxudmFyIERlbGV0aW9uID0gODsgLy8gICAgICAgICAgIDBiMDAwMDEwMDBcbnZhciBDb250ZW50UmVzZXQgPSAxNjsgLy8gICAgICAwYjAwMDEwMDAwXG52YXIgQ2FsbGJhY2sgPSAzMjsgLy8gICAgICAgICAgMGIwMDEwMDAwMFxudmFyIEVyciA9IDY0OyAvLyAgICAgICAgICAgICAgIDBiMDEwMDAwMDBcbnZhciBSZWYgPSAxMjg7IC8vICAgICAgICAgICAgICAwYjEwMDAwMDAwXG5cbnZhciBNT1VOVElORyA9IDE7XG52YXIgTU9VTlRFRCA9IDI7XG52YXIgVU5NT1VOVEVEID0gMztcblxuZnVuY3Rpb24gaXNGaWJlck1vdW50ZWRJbXBsKGZpYmVyKSB7XG4gIHZhciBub2RlID0gZmliZXI7XG4gIGlmICghZmliZXIuYWx0ZXJuYXRlKSB7XG4gICAgLy8gSWYgdGhlcmUgaXMgbm8gYWx0ZXJuYXRlLCB0aGlzIG1pZ2h0IGJlIGEgbmV3IHRyZWUgdGhhdCBpc24ndCBpbnNlcnRlZFxuICAgIC8vIHlldC4gSWYgaXQgaXMsIHRoZW4gaXQgd2lsbCBoYXZlIGEgcGVuZGluZyBpbnNlcnRpb24gZWZmZWN0IG9uIGl0LlxuICAgIGlmICgobm9kZS5lZmZlY3RUYWcgJiBQbGFjZW1lbnQpICE9PSBOb0VmZmVjdCkge1xuICAgICAgcmV0dXJuIE1PVU5USU5HO1xuICAgIH1cbiAgICB3aGlsZSAobm9kZVsncmV0dXJuJ10pIHtcbiAgICAgIG5vZGUgPSBub2RlWydyZXR1cm4nXTtcbiAgICAgIGlmICgobm9kZS5lZmZlY3RUYWcgJiBQbGFjZW1lbnQpICE9PSBOb0VmZmVjdCkge1xuICAgICAgICByZXR1cm4gTU9VTlRJTkc7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHdoaWxlIChub2RlWydyZXR1cm4nXSkge1xuICAgICAgbm9kZSA9IG5vZGVbJ3JldHVybiddO1xuICAgIH1cbiAgfVxuICBpZiAobm9kZS50YWcgPT09IEhvc3RSb290KSB7XG4gICAgLy8gVE9ETzogQ2hlY2sgaWYgdGhpcyB3YXMgYSBuZXN0ZWQgSG9zdFJvb3Qgd2hlbiB1c2VkIHdpdGhcbiAgICAvLyByZW5kZXJDb250YWluZXJJbnRvU3VidHJlZS5cbiAgICByZXR1cm4gTU9VTlRFRDtcbiAgfVxuICAvLyBJZiB3ZSBkaWRuJ3QgaGl0IHRoZSByb290LCB0aGF0IG1lYW5zIHRoYXQgd2UncmUgaW4gYW4gZGlzY29ubmVjdGVkIHRyZWVcbiAgLy8gdGhhdCBoYXMgYmVlbiB1bm1vdW50ZWQuXG4gIHJldHVybiBVTk1PVU5URUQ7XG59XG5cbmZ1bmN0aW9uIGlzRmliZXJNb3VudGVkKGZpYmVyKSB7XG4gIHJldHVybiBpc0ZpYmVyTW91bnRlZEltcGwoZmliZXIpID09PSBNT1VOVEVEO1xufVxuXG5mdW5jdGlvbiBpc01vdW50ZWQoY29tcG9uZW50KSB7XG4gIHtcbiAgICB2YXIgb3duZXIgPSBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50O1xuICAgIGlmIChvd25lciAhPT0gbnVsbCAmJiBvd25lci50YWcgPT09IENsYXNzQ29tcG9uZW50KSB7XG4gICAgICB2YXIgb3duZXJGaWJlciA9IG93bmVyO1xuICAgICAgdmFyIGluc3RhbmNlID0gb3duZXJGaWJlci5zdGF0ZU5vZGU7XG4gICAgICB3YXJuaW5nKGluc3RhbmNlLl93YXJuZWRBYm91dFJlZnNJblJlbmRlciwgJyVzIGlzIGFjY2Vzc2luZyBpc01vdW50ZWQgaW5zaWRlIGl0cyByZW5kZXIoKSBmdW5jdGlvbi4gJyArICdyZW5kZXIoKSBzaG91bGQgYmUgYSBwdXJlIGZ1bmN0aW9uIG9mIHByb3BzIGFuZCBzdGF0ZS4gSXQgc2hvdWxkICcgKyAnbmV2ZXIgYWNjZXNzIHNvbWV0aGluZyB0aGF0IHJlcXVpcmVzIHN0YWxlIGRhdGEgZnJvbSB0aGUgcHJldmlvdXMgJyArICdyZW5kZXIsIHN1Y2ggYXMgcmVmcy4gTW92ZSB0aGlzIGxvZ2ljIHRvIGNvbXBvbmVudERpZE1vdW50IGFuZCAnICsgJ2NvbXBvbmVudERpZFVwZGF0ZSBpbnN0ZWFkLicsIGdldENvbXBvbmVudE5hbWUob3duZXJGaWJlcikgfHwgJ0EgY29tcG9uZW50Jyk7XG4gICAgICBpbnN0YW5jZS5fd2FybmVkQWJvdXRSZWZzSW5SZW5kZXIgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHZhciBmaWJlciA9IGdldChjb21wb25lbnQpO1xuICBpZiAoIWZpYmVyKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBpc0ZpYmVyTW91bnRlZEltcGwoZmliZXIpID09PSBNT1VOVEVEO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRJc01vdW50ZWQoZmliZXIpIHtcbiAgIShpc0ZpYmVyTW91bnRlZEltcGwoZmliZXIpID09PSBNT1VOVEVEKSA/IGludmFyaWFudChmYWxzZSwgJ1VuYWJsZSB0byBmaW5kIG5vZGUgb24gYW4gdW5tb3VudGVkIGNvbXBvbmVudC4nKSA6IHZvaWQgMDtcbn1cblxuZnVuY3Rpb24gZmluZEN1cnJlbnRGaWJlclVzaW5nU2xvd1BhdGgoZmliZXIpIHtcbiAgdmFyIGFsdGVybmF0ZSA9IGZpYmVyLmFsdGVybmF0ZTtcbiAgaWYgKCFhbHRlcm5hdGUpIHtcbiAgICAvLyBJZiB0aGVyZSBpcyBubyBhbHRlcm5hdGUsIHRoZW4gd2Ugb25seSBuZWVkIHRvIGNoZWNrIGlmIGl0IGlzIG1vdW50ZWQuXG4gICAgdmFyIHN0YXRlID0gaXNGaWJlck1vdW50ZWRJbXBsKGZpYmVyKTtcbiAgICAhKHN0YXRlICE9PSBVTk1PVU5URUQpID8gaW52YXJpYW50KGZhbHNlLCAnVW5hYmxlIHRvIGZpbmQgbm9kZSBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LicpIDogdm9pZCAwO1xuICAgIGlmIChzdGF0ZSA9PT0gTU9VTlRJTkcpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gZmliZXI7XG4gIH1cbiAgLy8gSWYgd2UgaGF2ZSB0d28gcG9zc2libGUgYnJhbmNoZXMsIHdlJ2xsIHdhbGsgYmFja3dhcmRzIHVwIHRvIHRoZSByb290XG4gIC8vIHRvIHNlZSB3aGF0IHBhdGggdGhlIHJvb3QgcG9pbnRzIHRvLiBPbiB0aGUgd2F5IHdlIG1heSBoaXQgb25lIG9mIHRoZVxuICAvLyBzcGVjaWFsIGNhc2VzIGFuZCB3ZSdsbCBkZWFsIHdpdGggdGhlbS5cbiAgdmFyIGEgPSBmaWJlcjtcbiAgdmFyIGIgPSBhbHRlcm5hdGU7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgdmFyIHBhcmVudEEgPSBhWydyZXR1cm4nXTtcbiAgICB2YXIgcGFyZW50QiA9IHBhcmVudEEgPyBwYXJlbnRBLmFsdGVybmF0ZSA6IG51bGw7XG4gICAgaWYgKCFwYXJlbnRBIHx8ICFwYXJlbnRCKSB7XG4gICAgICAvLyBXZSdyZSBhdCB0aGUgcm9vdC5cbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIC8vIElmIGJvdGggY29waWVzIG9mIHRoZSBwYXJlbnQgZmliZXIgcG9pbnQgdG8gdGhlIHNhbWUgY2hpbGQsIHdlIGNhblxuICAgIC8vIGFzc3VtZSB0aGF0IHRoZSBjaGlsZCBpcyBjdXJyZW50LiBUaGlzIGhhcHBlbnMgd2hlbiB3ZSBiYWlsb3V0IG9uIGxvd1xuICAgIC8vIHByaW9yaXR5OiB0aGUgYmFpbGVkIG91dCBmaWJlcidzIGNoaWxkIHJldXNlcyB0aGUgY3VycmVudCBjaGlsZC5cbiAgICBpZiAocGFyZW50QS5jaGlsZCA9PT0gcGFyZW50Qi5jaGlsZCkge1xuICAgICAgdmFyIGNoaWxkID0gcGFyZW50QS5jaGlsZDtcbiAgICAgIHdoaWxlIChjaGlsZCkge1xuICAgICAgICBpZiAoY2hpbGQgPT09IGEpIHtcbiAgICAgICAgICAvLyBXZSd2ZSBkZXRlcm1pbmVkIHRoYXQgQSBpcyB0aGUgY3VycmVudCBicmFuY2guXG4gICAgICAgICAgYXNzZXJ0SXNNb3VudGVkKHBhcmVudEEpO1xuICAgICAgICAgIHJldHVybiBmaWJlcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hpbGQgPT09IGIpIHtcbiAgICAgICAgICAvLyBXZSd2ZSBkZXRlcm1pbmVkIHRoYXQgQiBpcyB0aGUgY3VycmVudCBicmFuY2guXG4gICAgICAgICAgYXNzZXJ0SXNNb3VudGVkKHBhcmVudEEpO1xuICAgICAgICAgIHJldHVybiBhbHRlcm5hdGU7XG4gICAgICAgIH1cbiAgICAgICAgY2hpbGQgPSBjaGlsZC5zaWJsaW5nO1xuICAgICAgfVxuICAgICAgLy8gV2Ugc2hvdWxkIG5ldmVyIGhhdmUgYW4gYWx0ZXJuYXRlIGZvciBhbnkgbW91bnRpbmcgbm9kZS4gU28gdGhlIG9ubHlcbiAgICAgIC8vIHdheSB0aGlzIGNvdWxkIHBvc3NpYmx5IGhhcHBlbiBpcyBpZiB0aGlzIHdhcyB1bm1vdW50ZWQsIGlmIGF0IGFsbC5cbiAgICAgIGludmFyaWFudChmYWxzZSwgJ1VuYWJsZSB0byBmaW5kIG5vZGUgb24gYW4gdW5tb3VudGVkIGNvbXBvbmVudC4nKTtcbiAgICB9XG5cbiAgICBpZiAoYVsncmV0dXJuJ10gIT09IGJbJ3JldHVybiddKSB7XG4gICAgICAvLyBUaGUgcmV0dXJuIHBvaW50ZXIgb2YgQSBhbmQgdGhlIHJldHVybiBwb2ludGVyIG9mIEIgcG9pbnQgdG8gZGlmZmVyZW50XG4gICAgICAvLyBmaWJlcnMuIFdlIGFzc3VtZSB0aGF0IHJldHVybiBwb2ludGVycyBuZXZlciBjcmlzcy1jcm9zcywgc28gQSBtdXN0XG4gICAgICAvLyBiZWxvbmcgdG8gdGhlIGNoaWxkIHNldCBvZiBBLnJldHVybiwgYW5kIEIgbXVzdCBiZWxvbmcgdG8gdGhlIGNoaWxkXG4gICAgICAvLyBzZXQgb2YgQi5yZXR1cm4uXG4gICAgICBhID0gcGFyZW50QTtcbiAgICAgIGIgPSBwYXJlbnRCO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaGUgcmV0dXJuIHBvaW50ZXJzIHBvaW50IHRvIHRoZSBzYW1lIGZpYmVyLiBXZSdsbCBoYXZlIHRvIHVzZSB0aGVcbiAgICAgIC8vIGRlZmF1bHQsIHNsb3cgcGF0aDogc2NhbiB0aGUgY2hpbGQgc2V0cyBvZiBlYWNoIHBhcmVudCBhbHRlcm5hdGUgdG8gc2VlXG4gICAgICAvLyB3aGljaCBjaGlsZCBiZWxvbmdzIHRvIHdoaWNoIHNldC5cbiAgICAgIC8vXG4gICAgICAvLyBTZWFyY2ggcGFyZW50IEEncyBjaGlsZCBzZXRcbiAgICAgIHZhciBkaWRGaW5kQ2hpbGQgPSBmYWxzZTtcbiAgICAgIHZhciBfY2hpbGQgPSBwYXJlbnRBLmNoaWxkO1xuICAgICAgd2hpbGUgKF9jaGlsZCkge1xuICAgICAgICBpZiAoX2NoaWxkID09PSBhKSB7XG4gICAgICAgICAgZGlkRmluZENoaWxkID0gdHJ1ZTtcbiAgICAgICAgICBhID0gcGFyZW50QTtcbiAgICAgICAgICBiID0gcGFyZW50QjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoX2NoaWxkID09PSBiKSB7XG4gICAgICAgICAgZGlkRmluZENoaWxkID0gdHJ1ZTtcbiAgICAgICAgICBiID0gcGFyZW50QTtcbiAgICAgICAgICBhID0gcGFyZW50QjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBfY2hpbGQgPSBfY2hpbGQuc2libGluZztcbiAgICAgIH1cbiAgICAgIGlmICghZGlkRmluZENoaWxkKSB7XG4gICAgICAgIC8vIFNlYXJjaCBwYXJlbnQgQidzIGNoaWxkIHNldFxuICAgICAgICBfY2hpbGQgPSBwYXJlbnRCLmNoaWxkO1xuICAgICAgICB3aGlsZSAoX2NoaWxkKSB7XG4gICAgICAgICAgaWYgKF9jaGlsZCA9PT0gYSkge1xuICAgICAgICAgICAgZGlkRmluZENoaWxkID0gdHJ1ZTtcbiAgICAgICAgICAgIGEgPSBwYXJlbnRCO1xuICAgICAgICAgICAgYiA9IHBhcmVudEE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKF9jaGlsZCA9PT0gYikge1xuICAgICAgICAgICAgZGlkRmluZENoaWxkID0gdHJ1ZTtcbiAgICAgICAgICAgIGIgPSBwYXJlbnRCO1xuICAgICAgICAgICAgYSA9IHBhcmVudEE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgX2NoaWxkID0gX2NoaWxkLnNpYmxpbmc7XG4gICAgICAgIH1cbiAgICAgICAgIWRpZEZpbmRDaGlsZCA/IGludmFyaWFudChmYWxzZSwgJ0NoaWxkIHdhcyBub3QgZm91bmQgaW4gZWl0aGVyIHBhcmVudCBzZXQuIFRoaXMgaW5kaWNhdGVzIGEgYnVnIGluIFJlYWN0IHJlbGF0ZWQgdG8gdGhlIHJldHVybiBwb2ludGVyLiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAhKGEuYWx0ZXJuYXRlID09PSBiKSA/IGludmFyaWFudChmYWxzZSwgJ1JldHVybiBmaWJlcnMgc2hvdWxkIGFsd2F5cyBiZSBlYWNoIG90aGVyc1xcJyBhbHRlcm5hdGVzLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuICB9XG4gIC8vIElmIHRoZSByb290IGlzIG5vdCBhIGhvc3QgY29udGFpbmVyLCB3ZSdyZSBpbiBhIGRpc2Nvbm5lY3RlZCB0cmVlLiBJLmUuXG4gIC8vIHVubW91bnRlZC5cbiAgIShhLnRhZyA9PT0gSG9zdFJvb3QpID8gaW52YXJpYW50KGZhbHNlLCAnVW5hYmxlIHRvIGZpbmQgbm9kZSBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LicpIDogdm9pZCAwO1xuICBpZiAoYS5zdGF0ZU5vZGUuY3VycmVudCA9PT0gYSkge1xuICAgIC8vIFdlJ3ZlIGRldGVybWluZWQgdGhhdCBBIGlzIHRoZSBjdXJyZW50IGJyYW5jaC5cbiAgICByZXR1cm4gZmliZXI7XG4gIH1cbiAgLy8gT3RoZXJ3aXNlIEIgaGFzIHRvIGJlIGN1cnJlbnQgYnJhbmNoLlxuICByZXR1cm4gYWx0ZXJuYXRlO1xufVxuXG5mdW5jdGlvbiBmaW5kQ3VycmVudEhvc3RGaWJlcihwYXJlbnQpIHtcbiAgdmFyIGN1cnJlbnRQYXJlbnQgPSBmaW5kQ3VycmVudEZpYmVyVXNpbmdTbG93UGF0aChwYXJlbnQpO1xuICBpZiAoIWN1cnJlbnRQYXJlbnQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIE5leHQgd2UnbGwgZHJpbGwgZG93biB0aGlzIGNvbXBvbmVudCB0byBmaW5kIHRoZSBmaXJzdCBIb3N0Q29tcG9uZW50L1RleHQuXG4gIHZhciBub2RlID0gY3VycmVudFBhcmVudDtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICBpZiAobm9kZS50YWcgPT09IEhvc3RDb21wb25lbnQgfHwgbm9kZS50YWcgPT09IEhvc3RUZXh0KSB7XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9IGVsc2UgaWYgKG5vZGUuY2hpbGQpIHtcbiAgICAgIG5vZGUuY2hpbGRbJ3JldHVybiddID0gbm9kZTtcbiAgICAgIG5vZGUgPSBub2RlLmNoaWxkO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChub2RlID09PSBjdXJyZW50UGFyZW50KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgd2hpbGUgKCFub2RlLnNpYmxpbmcpIHtcbiAgICAgIGlmICghbm9kZVsncmV0dXJuJ10gfHwgbm9kZVsncmV0dXJuJ10gPT09IGN1cnJlbnRQYXJlbnQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBub2RlID0gbm9kZVsncmV0dXJuJ107XG4gICAgfVxuICAgIG5vZGUuc2libGluZ1sncmV0dXJuJ10gPSBub2RlWydyZXR1cm4nXTtcbiAgICBub2RlID0gbm9kZS5zaWJsaW5nO1xuICB9XG4gIC8vIEZsb3cgbmVlZHMgdGhlIHJldHVybiBudWxsIGhlcmUsIGJ1dCBFU0xpbnQgY29tcGxhaW5zIGFib3V0IGl0LlxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5yZWFjaGFibGVcbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIGZpbmRDdXJyZW50SG9zdEZpYmVyV2l0aE5vUG9ydGFscyhwYXJlbnQpIHtcbiAgdmFyIGN1cnJlbnRQYXJlbnQgPSBmaW5kQ3VycmVudEZpYmVyVXNpbmdTbG93UGF0aChwYXJlbnQpO1xuICBpZiAoIWN1cnJlbnRQYXJlbnQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIE5leHQgd2UnbGwgZHJpbGwgZG93biB0aGlzIGNvbXBvbmVudCB0byBmaW5kIHRoZSBmaXJzdCBIb3N0Q29tcG9uZW50L1RleHQuXG4gIHZhciBub2RlID0gY3VycmVudFBhcmVudDtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICBpZiAobm9kZS50YWcgPT09IEhvc3RDb21wb25lbnQgfHwgbm9kZS50YWcgPT09IEhvc3RUZXh0KSB7XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9IGVsc2UgaWYgKG5vZGUuY2hpbGQgJiYgbm9kZS50YWcgIT09IEhvc3RQb3J0YWwpIHtcbiAgICAgIG5vZGUuY2hpbGRbJ3JldHVybiddID0gbm9kZTtcbiAgICAgIG5vZGUgPSBub2RlLmNoaWxkO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChub2RlID09PSBjdXJyZW50UGFyZW50KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgd2hpbGUgKCFub2RlLnNpYmxpbmcpIHtcbiAgICAgIGlmICghbm9kZVsncmV0dXJuJ10gfHwgbm9kZVsncmV0dXJuJ10gPT09IGN1cnJlbnRQYXJlbnQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBub2RlID0gbm9kZVsncmV0dXJuJ107XG4gICAgfVxuICAgIG5vZGUuc2libGluZ1sncmV0dXJuJ10gPSBub2RlWydyZXR1cm4nXTtcbiAgICBub2RlID0gbm9kZS5zaWJsaW5nO1xuICB9XG4gIC8vIEZsb3cgbmVlZHMgdGhlIHJldHVybiBudWxsIGhlcmUsIGJ1dCBFU0xpbnQgY29tcGxhaW5zIGFib3V0IGl0LlxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5yZWFjaGFibGVcbiAgcmV0dXJuIG51bGw7XG59XG5cbnZhciB2YWx1ZVN0YWNrID0gW107XG5cbntcbiAgdmFyIGZpYmVyU3RhY2sgPSBbXTtcbn1cblxudmFyIGluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNyZWF0ZUN1cnNvcihkZWZhdWx0VmFsdWUpIHtcbiAgcmV0dXJuIHtcbiAgICBjdXJyZW50OiBkZWZhdWx0VmFsdWVcbiAgfTtcbn1cblxuXG5cbmZ1bmN0aW9uIHBvcChjdXJzb3IsIGZpYmVyKSB7XG4gIGlmIChpbmRleCA8IDApIHtcbiAgICB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnVW5leHBlY3RlZCBwb3AuJyk7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuXG4gIHtcbiAgICBpZiAoZmliZXIgIT09IGZpYmVyU3RhY2tbaW5kZXhdKSB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnVW5leHBlY3RlZCBGaWJlciBwb3BwZWQuJyk7XG4gICAgfVxuICB9XG5cbiAgY3Vyc29yLmN1cnJlbnQgPSB2YWx1ZVN0YWNrW2luZGV4XTtcblxuICB2YWx1ZVN0YWNrW2luZGV4XSA9IG51bGw7XG5cbiAge1xuICAgIGZpYmVyU3RhY2tbaW5kZXhdID0gbnVsbDtcbiAgfVxuXG4gIGluZGV4LS07XG59XG5cbmZ1bmN0aW9uIHB1c2goY3Vyc29yLCB2YWx1ZSwgZmliZXIpIHtcbiAgaW5kZXgrKztcblxuICB2YWx1ZVN0YWNrW2luZGV4XSA9IGN1cnNvci5jdXJyZW50O1xuXG4gIHtcbiAgICBmaWJlclN0YWNrW2luZGV4XSA9IGZpYmVyO1xuICB9XG5cbiAgY3Vyc29yLmN1cnJlbnQgPSB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gcmVzZXQoKSB7XG4gIHdoaWxlIChpbmRleCA+IC0xKSB7XG4gICAgdmFsdWVTdGFja1tpbmRleF0gPSBudWxsO1xuXG4gICAge1xuICAgICAgZmliZXJTdGFja1tpbmRleF0gPSBudWxsO1xuICAgIH1cblxuICAgIGluZGV4LS07XG4gIH1cbn1cblxudmFyIGRlc2NyaWJlQ29tcG9uZW50RnJhbWUgPSBmdW5jdGlvbiAobmFtZSwgc291cmNlLCBvd25lck5hbWUpIHtcbiAgcmV0dXJuICdcXG4gICAgaW4gJyArIChuYW1lIHx8ICdVbmtub3duJykgKyAoc291cmNlID8gJyAoYXQgJyArIHNvdXJjZS5maWxlTmFtZS5yZXBsYWNlKC9eLipbXFxcXFxcL10vLCAnJykgKyAnOicgKyBzb3VyY2UubGluZU51bWJlciArICcpJyA6IG93bmVyTmFtZSA/ICcgKGNyZWF0ZWQgYnkgJyArIG93bmVyTmFtZSArICcpJyA6ICcnKTtcbn07XG5cbmZ1bmN0aW9uIGRlc2NyaWJlRmliZXIoZmliZXIpIHtcbiAgc3dpdGNoIChmaWJlci50YWcpIHtcbiAgICBjYXNlIEluZGV0ZXJtaW5hdGVDb21wb25lbnQ6XG4gICAgY2FzZSBGdW5jdGlvbmFsQ29tcG9uZW50OlxuICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgdmFyIG93bmVyID0gZmliZXIuX2RlYnVnT3duZXI7XG4gICAgICB2YXIgc291cmNlID0gZmliZXIuX2RlYnVnU291cmNlO1xuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lKGZpYmVyKTtcbiAgICAgIHZhciBvd25lck5hbWUgPSBudWxsO1xuICAgICAgaWYgKG93bmVyKSB7XG4gICAgICAgIG93bmVyTmFtZSA9IGdldENvbXBvbmVudE5hbWUob3duZXIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRlc2NyaWJlQ29tcG9uZW50RnJhbWUobmFtZSwgc291cmNlLCBvd25lck5hbWUpO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gJyc7XG4gIH1cbn1cblxuLy8gVGhpcyBmdW5jdGlvbiBjYW4gb25seSBiZSBjYWxsZWQgd2l0aCBhIHdvcmstaW4tcHJvZ3Jlc3MgZmliZXIgYW5kXG4vLyBvbmx5IGR1cmluZyBiZWdpbiBvciBjb21wbGV0ZSBwaGFzZS4gRG8gbm90IGNhbGwgaXQgdW5kZXIgYW55IG90aGVyXG4vLyBjaXJjdW1zdGFuY2VzLlxuZnVuY3Rpb24gZ2V0U3RhY2tBZGRlbmR1bUJ5V29ya0luUHJvZ3Jlc3NGaWJlcih3b3JrSW5Qcm9ncmVzcykge1xuICB2YXIgaW5mbyA9ICcnO1xuICB2YXIgbm9kZSA9IHdvcmtJblByb2dyZXNzO1xuICBkbyB7XG4gICAgaW5mbyArPSBkZXNjcmliZUZpYmVyKG5vZGUpO1xuICAgIC8vIE90aGVyd2lzZSB0aGlzIHJldHVybiBwb2ludGVyIG1pZ2h0IHBvaW50IHRvIHRoZSB3cm9uZyB0cmVlOlxuICAgIG5vZGUgPSBub2RlWydyZXR1cm4nXTtcbiAgfSB3aGlsZSAobm9kZSk7XG4gIHJldHVybiBpbmZvO1xufVxuXG5mdW5jdGlvbiBnZXRDdXJyZW50RmliZXJPd25lck5hbWUoKSB7XG4gIHtcbiAgICB2YXIgZmliZXIgPSBSZWFjdERlYnVnQ3VycmVudEZpYmVyLmN1cnJlbnQ7XG4gICAgaWYgKGZpYmVyID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIG93bmVyID0gZmliZXIuX2RlYnVnT3duZXI7XG4gICAgaWYgKG93bmVyICE9PSBudWxsICYmIHR5cGVvZiBvd25lciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lKG93bmVyKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIGdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW0oKSB7XG4gIHtcbiAgICB2YXIgZmliZXIgPSBSZWFjdERlYnVnQ3VycmVudEZpYmVyLmN1cnJlbnQ7XG4gICAgaWYgKGZpYmVyID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLy8gU2FmZSBiZWNhdXNlIGlmIGN1cnJlbnQgZmliZXIgZXhpc3RzLCB3ZSBhcmUgcmVjb25jaWxpbmcsXG4gICAgLy8gYW5kIGl0IGlzIGd1YXJhbnRlZWQgdG8gYmUgdGhlIHdvcmstaW4tcHJvZ3Jlc3MgdmVyc2lvbi5cbiAgICByZXR1cm4gZ2V0U3RhY2tBZGRlbmR1bUJ5V29ya0luUHJvZ3Jlc3NGaWJlcihmaWJlcik7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIHJlc2V0Q3VycmVudEZpYmVyKCkge1xuICBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldEN1cnJlbnRTdGFjayA9IG51bGw7XG4gIFJlYWN0RGVidWdDdXJyZW50RmliZXIuY3VycmVudCA9IG51bGw7XG4gIFJlYWN0RGVidWdDdXJyZW50RmliZXIucGhhc2UgPSBudWxsO1xufVxuXG5mdW5jdGlvbiBzZXRDdXJyZW50RmliZXIoZmliZXIpIHtcbiAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRDdXJyZW50U3RhY2sgPSBnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtO1xuICBSZWFjdERlYnVnQ3VycmVudEZpYmVyLmN1cnJlbnQgPSBmaWJlcjtcbiAgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5waGFzZSA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIHNldEN1cnJlbnRQaGFzZShwaGFzZSkge1xuICBSZWFjdERlYnVnQ3VycmVudEZpYmVyLnBoYXNlID0gcGhhc2U7XG59XG5cbnZhciBSZWFjdERlYnVnQ3VycmVudEZpYmVyID0ge1xuICBjdXJyZW50OiBudWxsLFxuICBwaGFzZTogbnVsbCxcbiAgcmVzZXRDdXJyZW50RmliZXI6IHJlc2V0Q3VycmVudEZpYmVyLFxuICBzZXRDdXJyZW50RmliZXI6IHNldEN1cnJlbnRGaWJlcixcbiAgc2V0Q3VycmVudFBoYXNlOiBzZXRDdXJyZW50UGhhc2UsXG4gIGdldEN1cnJlbnRGaWJlck93bmVyTmFtZTogZ2V0Q3VycmVudEZpYmVyT3duZXJOYW1lLFxuICBnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtOiBnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtXG59O1xuXG4vLyBQcmVmaXggbWVhc3VyZW1lbnRzIHNvIHRoYXQgaXQncyBwb3NzaWJsZSB0byBmaWx0ZXIgdGhlbS5cbi8vIExvbmdlciBwcmVmaXhlcyBhcmUgaGFyZCB0byByZWFkIGluIERldlRvb2xzLlxudmFyIHJlYWN0RW1vamkgPSAnXFx1MjY5Qic7XG52YXIgd2FybmluZ0Vtb2ppID0gJ1xcdTI2RDQnO1xudmFyIHN1cHBvcnRzVXNlclRpbWluZyA9IHR5cGVvZiBwZXJmb3JtYW5jZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHBlcmZvcm1hbmNlLm1hcmsgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHBlcmZvcm1hbmNlLmNsZWFyTWFya3MgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHBlcmZvcm1hbmNlLm1lYXN1cmUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHBlcmZvcm1hbmNlLmNsZWFyTWVhc3VyZXMgPT09ICdmdW5jdGlvbic7XG5cbi8vIEtlZXAgdHJhY2sgb2YgY3VycmVudCBmaWJlciBzbyB0aGF0IHdlIGtub3cgdGhlIHBhdGggdG8gdW53aW5kIG9uIHBhdXNlLlxuLy8gVE9ETzogdGhpcyBsb29rcyB0aGUgc2FtZSBhcyBuZXh0VW5pdE9mV29yayBpbiBzY2hlZHVsZXIuIENhbiB3ZSB1bmlmeSB0aGVtP1xudmFyIGN1cnJlbnRGaWJlciA9IG51bGw7XG4vLyBJZiB3ZSdyZSBpbiB0aGUgbWlkZGxlIG9mIHVzZXIgY29kZSwgd2hpY2ggZmliZXIgYW5kIG1ldGhvZCBpcyBpdD9cbi8vIFJldXNpbmcgYGN1cnJlbnRGaWJlcmAgd291bGQgYmUgY29uZnVzaW5nIGZvciB0aGlzIGJlY2F1c2UgdXNlciBjb2RlIGZpYmVyXG4vLyBjYW4gY2hhbmdlIGR1cmluZyBjb21taXQgcGhhc2UgdG9vLCBidXQgd2UgZG9uJ3QgbmVlZCB0byB1bndpbmQgaXQgKHNpbmNlXG4vLyBsaWZlY3ljbGVzIGluIHRoZSBjb21taXQgcGhhc2UgZG9uJ3QgcmVzZW1ibGUgYSB0cmVlKS5cbnZhciBjdXJyZW50UGhhc2UgPSBudWxsO1xudmFyIGN1cnJlbnRQaGFzZUZpYmVyID0gbnVsbDtcbi8vIERpZCBsaWZlY3ljbGUgaG9vayBzY2hlZHVsZSBhbiB1cGRhdGU/IFRoaXMgaXMgb2Z0ZW4gYSBwZXJmb3JtYW5jZSBwcm9ibGVtLFxuLy8gc28gd2Ugd2lsbCBrZWVwIHRyYWNrIG9mIGl0LCBhbmQgaW5jbHVkZSBpdCBpbiB0aGUgcmVwb3J0LlxuLy8gVHJhY2sgY29tbWl0cyBjYXVzZWQgYnkgY2FzY2FkaW5nIHVwZGF0ZXMuXG52YXIgaXNDb21taXR0aW5nID0gZmFsc2U7XG52YXIgaGFzU2NoZWR1bGVkVXBkYXRlSW5DdXJyZW50Q29tbWl0ID0gZmFsc2U7XG52YXIgaGFzU2NoZWR1bGVkVXBkYXRlSW5DdXJyZW50UGhhc2UgPSBmYWxzZTtcbnZhciBjb21taXRDb3VudEluQ3VycmVudFdvcmtMb29wID0gMDtcbnZhciBlZmZlY3RDb3VudEluQ3VycmVudENvbW1pdCA9IDA7XG52YXIgaXNXYWl0aW5nRm9yQ2FsbGJhY2sgPSBmYWxzZTtcbi8vIER1cmluZyBjb21taXRzLCB3ZSBvbmx5IHNob3cgYSBtZWFzdXJlbWVudCBvbmNlIHBlciBtZXRob2QgbmFtZVxuLy8gdG8gYXZvaWQgc3RyZXRjaCB0aGUgY29tbWl0IHBoYXNlIHdpdGggbWVhc3VyZW1lbnQgb3ZlcmhlYWQuXG52YXIgbGFiZWxzSW5DdXJyZW50Q29tbWl0ID0gbmV3IFNldCgpO1xuXG52YXIgZm9ybWF0TWFya05hbWUgPSBmdW5jdGlvbiAobWFya05hbWUpIHtcbiAgcmV0dXJuIHJlYWN0RW1vamkgKyAnICcgKyBtYXJrTmFtZTtcbn07XG5cbnZhciBmb3JtYXRMYWJlbCA9IGZ1bmN0aW9uIChsYWJlbCwgd2FybmluZyQkMSkge1xuICB2YXIgcHJlZml4ID0gd2FybmluZyQkMSA/IHdhcm5pbmdFbW9qaSArICcgJyA6IHJlYWN0RW1vamkgKyAnICc7XG4gIHZhciBzdWZmaXggPSB3YXJuaW5nJCQxID8gJyBXYXJuaW5nOiAnICsgd2FybmluZyQkMSA6ICcnO1xuICByZXR1cm4gJycgKyBwcmVmaXggKyBsYWJlbCArIHN1ZmZpeDtcbn07XG5cbnZhciBiZWdpbk1hcmsgPSBmdW5jdGlvbiAobWFya05hbWUpIHtcbiAgcGVyZm9ybWFuY2UubWFyayhmb3JtYXRNYXJrTmFtZShtYXJrTmFtZSkpO1xufTtcblxudmFyIGNsZWFyTWFyayA9IGZ1bmN0aW9uIChtYXJrTmFtZSkge1xuICBwZXJmb3JtYW5jZS5jbGVhck1hcmtzKGZvcm1hdE1hcmtOYW1lKG1hcmtOYW1lKSk7XG59O1xuXG52YXIgZW5kTWFyayA9IGZ1bmN0aW9uIChsYWJlbCwgbWFya05hbWUsIHdhcm5pbmckJDEpIHtcbiAgdmFyIGZvcm1hdHRlZE1hcmtOYW1lID0gZm9ybWF0TWFya05hbWUobWFya05hbWUpO1xuICB2YXIgZm9ybWF0dGVkTGFiZWwgPSBmb3JtYXRMYWJlbChsYWJlbCwgd2FybmluZyQkMSk7XG4gIHRyeSB7XG4gICAgcGVyZm9ybWFuY2UubWVhc3VyZShmb3JtYXR0ZWRMYWJlbCwgZm9ybWF0dGVkTWFya05hbWUpO1xuICB9IGNhdGNoIChlcnIpIHt9XG4gIC8vIElmIHByZXZpb3VzIG1hcmsgd2FzIG1pc3NpbmcgZm9yIHNvbWUgcmVhc29uLCB0aGlzIHdpbGwgdGhyb3cuXG4gIC8vIFRoaXMgY291bGQgb25seSBoYXBwZW4gaWYgUmVhY3QgY3Jhc2hlZCBpbiBhbiB1bmV4cGVjdGVkIHBsYWNlIGVhcmxpZXIuXG4gIC8vIERvbid0IHBpbGUgb24gd2l0aCBtb3JlIGVycm9ycy5cblxuICAvLyBDbGVhciBtYXJrcyBpbW1lZGlhdGVseSB0byBhdm9pZCBncm93aW5nIGJ1ZmZlci5cbiAgcGVyZm9ybWFuY2UuY2xlYXJNYXJrcyhmb3JtYXR0ZWRNYXJrTmFtZSk7XG4gIHBlcmZvcm1hbmNlLmNsZWFyTWVhc3VyZXMoZm9ybWF0dGVkTGFiZWwpO1xufTtcblxudmFyIGdldEZpYmVyTWFya05hbWUgPSBmdW5jdGlvbiAobGFiZWwsIGRlYnVnSUQpIHtcbiAgcmV0dXJuIGxhYmVsICsgJyAoIycgKyBkZWJ1Z0lEICsgJyknO1xufTtcblxudmFyIGdldEZpYmVyTGFiZWwgPSBmdW5jdGlvbiAoY29tcG9uZW50TmFtZSwgaXNNb3VudGVkLCBwaGFzZSkge1xuICBpZiAocGhhc2UgPT09IG51bGwpIHtcbiAgICAvLyBUaGVzZSBhcmUgY29tcG9zaXRlIGNvbXBvbmVudCB0b3RhbCB0aW1lIG1lYXN1cmVtZW50cy5cbiAgICByZXR1cm4gY29tcG9uZW50TmFtZSArICcgWycgKyAoaXNNb3VudGVkID8gJ3VwZGF0ZScgOiAnbW91bnQnKSArICddJztcbiAgfSBlbHNlIHtcbiAgICAvLyBDb21wb3NpdGUgY29tcG9uZW50IG1ldGhvZHMuXG4gICAgcmV0dXJuIGNvbXBvbmVudE5hbWUgKyAnLicgKyBwaGFzZTtcbiAgfVxufTtcblxudmFyIGJlZ2luRmliZXJNYXJrID0gZnVuY3Rpb24gKGZpYmVyLCBwaGFzZSkge1xuICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWUoZmliZXIpIHx8ICdVbmtub3duJztcbiAgdmFyIGRlYnVnSUQgPSBmaWJlci5fZGVidWdJRDtcbiAgdmFyIGlzTW91bnRlZCA9IGZpYmVyLmFsdGVybmF0ZSAhPT0gbnVsbDtcbiAgdmFyIGxhYmVsID0gZ2V0RmliZXJMYWJlbChjb21wb25lbnROYW1lLCBpc01vdW50ZWQsIHBoYXNlKTtcblxuICBpZiAoaXNDb21taXR0aW5nICYmIGxhYmVsc0luQ3VycmVudENvbW1pdC5oYXMobGFiZWwpKSB7XG4gICAgLy8gRHVyaW5nIHRoZSBjb21taXQgcGhhc2UsIHdlIGRvbid0IHNob3cgZHVwbGljYXRlIGxhYmVscyBiZWNhdXNlXG4gICAgLy8gdGhlcmUgaXMgYSBmaXhlZCBvdmVyaGVhZCBmb3IgZXZlcnkgbWVhc3VyZW1lbnQsIGFuZCB3ZSBkb24ndFxuICAgIC8vIHdhbnQgdG8gc3RyZXRjaCB0aGUgY29tbWl0IHBoYXNlIGJleW9uZCBuZWNlc3NhcnkuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGxhYmVsc0luQ3VycmVudENvbW1pdC5hZGQobGFiZWwpO1xuXG4gIHZhciBtYXJrTmFtZSA9IGdldEZpYmVyTWFya05hbWUobGFiZWwsIGRlYnVnSUQpO1xuICBiZWdpbk1hcmsobWFya05hbWUpO1xuICByZXR1cm4gdHJ1ZTtcbn07XG5cbnZhciBjbGVhckZpYmVyTWFyayA9IGZ1bmN0aW9uIChmaWJlciwgcGhhc2UpIHtcbiAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lKGZpYmVyKSB8fCAnVW5rbm93bic7XG4gIHZhciBkZWJ1Z0lEID0gZmliZXIuX2RlYnVnSUQ7XG4gIHZhciBpc01vdW50ZWQgPSBmaWJlci5hbHRlcm5hdGUgIT09IG51bGw7XG4gIHZhciBsYWJlbCA9IGdldEZpYmVyTGFiZWwoY29tcG9uZW50TmFtZSwgaXNNb3VudGVkLCBwaGFzZSk7XG4gIHZhciBtYXJrTmFtZSA9IGdldEZpYmVyTWFya05hbWUobGFiZWwsIGRlYnVnSUQpO1xuICBjbGVhck1hcmsobWFya05hbWUpO1xufTtcblxudmFyIGVuZEZpYmVyTWFyayA9IGZ1bmN0aW9uIChmaWJlciwgcGhhc2UsIHdhcm5pbmckJDEpIHtcbiAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lKGZpYmVyKSB8fCAnVW5rbm93bic7XG4gIHZhciBkZWJ1Z0lEID0gZmliZXIuX2RlYnVnSUQ7XG4gIHZhciBpc01vdW50ZWQgPSBmaWJlci5hbHRlcm5hdGUgIT09IG51bGw7XG4gIHZhciBsYWJlbCA9IGdldEZpYmVyTGFiZWwoY29tcG9uZW50TmFtZSwgaXNNb3VudGVkLCBwaGFzZSk7XG4gIHZhciBtYXJrTmFtZSA9IGdldEZpYmVyTWFya05hbWUobGFiZWwsIGRlYnVnSUQpO1xuICBlbmRNYXJrKGxhYmVsLCBtYXJrTmFtZSwgd2FybmluZyQkMSk7XG59O1xuXG52YXIgc2hvdWxkSWdub3JlRmliZXIgPSBmdW5jdGlvbiAoZmliZXIpIHtcbiAgLy8gSG9zdCBjb21wb25lbnRzIHNob3VsZCBiZSBza2lwcGVkIGluIHRoZSB0aW1lbGluZS5cbiAgLy8gV2UgY291bGQgY2hlY2sgdHlwZW9mIGZpYmVyLnR5cGUsIGJ1dCBkb2VzIHRoaXMgd29yayB3aXRoIFJOP1xuICBzd2l0Y2ggKGZpYmVyLnRhZykge1xuICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgIGNhc2UgSG9zdFRleHQ6XG4gICAgY2FzZSBIb3N0UG9ydGFsOlxuICAgIGNhc2UgUmV0dXJuQ29tcG9uZW50OlxuICAgIGNhc2UgRnJhZ21lbnQ6XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuXG52YXIgY2xlYXJQZW5kaW5nUGhhc2VNZWFzdXJlbWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKGN1cnJlbnRQaGFzZSAhPT0gbnVsbCAmJiBjdXJyZW50UGhhc2VGaWJlciAhPT0gbnVsbCkge1xuICAgIGNsZWFyRmliZXJNYXJrKGN1cnJlbnRQaGFzZUZpYmVyLCBjdXJyZW50UGhhc2UpO1xuICB9XG4gIGN1cnJlbnRQaGFzZUZpYmVyID0gbnVsbDtcbiAgY3VycmVudFBoYXNlID0gbnVsbDtcbiAgaGFzU2NoZWR1bGVkVXBkYXRlSW5DdXJyZW50UGhhc2UgPSBmYWxzZTtcbn07XG5cbnZhciBwYXVzZVRpbWVycyA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gU3RvcHMgYWxsIGN1cnJlbnRseSBhY3RpdmUgbWVhc3VyZW1lbnRzIHNvIHRoYXQgdGhleSBjYW4gYmUgcmVzdW1lZFxuICAvLyBpZiB3ZSBjb250aW51ZSBpbiBhIGxhdGVyIGRlZmVycmVkIGxvb3AgZnJvbSB0aGUgc2FtZSB1bml0IG9mIHdvcmsuXG4gIHZhciBmaWJlciA9IGN1cnJlbnRGaWJlcjtcbiAgd2hpbGUgKGZpYmVyKSB7XG4gICAgaWYgKGZpYmVyLl9kZWJ1Z0lzQ3VycmVudGx5VGltaW5nKSB7XG4gICAgICBlbmRGaWJlck1hcmsoZmliZXIsIG51bGwsIG51bGwpO1xuICAgIH1cbiAgICBmaWJlciA9IGZpYmVyWydyZXR1cm4nXTtcbiAgfVxufTtcblxudmFyIHJlc3VtZVRpbWVyc1JlY3Vyc2l2ZWx5ID0gZnVuY3Rpb24gKGZpYmVyKSB7XG4gIGlmIChmaWJlclsncmV0dXJuJ10gIT09IG51bGwpIHtcbiAgICByZXN1bWVUaW1lcnNSZWN1cnNpdmVseShmaWJlclsncmV0dXJuJ10pO1xuICB9XG4gIGlmIChmaWJlci5fZGVidWdJc0N1cnJlbnRseVRpbWluZykge1xuICAgIGJlZ2luRmliZXJNYXJrKGZpYmVyLCBudWxsKTtcbiAgfVxufTtcblxudmFyIHJlc3VtZVRpbWVycyA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gUmVzdW1lcyBhbGwgbWVhc3VyZW1lbnRzIHRoYXQgd2VyZSBhY3RpdmUgZHVyaW5nIHRoZSBsYXN0IGRlZmVycmVkIGxvb3AuXG4gIGlmIChjdXJyZW50RmliZXIgIT09IG51bGwpIHtcbiAgICByZXN1bWVUaW1lcnNSZWN1cnNpdmVseShjdXJyZW50RmliZXIpO1xuICB9XG59O1xuXG5mdW5jdGlvbiByZWNvcmRFZmZlY3QoKSB7XG4gIGlmIChlbmFibGVVc2VyVGltaW5nQVBJKSB7XG4gICAgZWZmZWN0Q291bnRJbkN1cnJlbnRDb21taXQrKztcbiAgfVxufVxuXG5mdW5jdGlvbiByZWNvcmRTY2hlZHVsZVVwZGF0ZSgpIHtcbiAgaWYgKGVuYWJsZVVzZXJUaW1pbmdBUEkpIHtcbiAgICBpZiAoaXNDb21taXR0aW5nKSB7XG4gICAgICBoYXNTY2hlZHVsZWRVcGRhdGVJbkN1cnJlbnRDb21taXQgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoY3VycmVudFBoYXNlICE9PSBudWxsICYmIGN1cnJlbnRQaGFzZSAhPT0gJ2NvbXBvbmVudFdpbGxNb3VudCcgJiYgY3VycmVudFBoYXNlICE9PSAnY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcycpIHtcbiAgICAgIGhhc1NjaGVkdWxlZFVwZGF0ZUluQ3VycmVudFBoYXNlID0gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RhcnRSZXF1ZXN0Q2FsbGJhY2tUaW1lcigpIHtcbiAgaWYgKGVuYWJsZVVzZXJUaW1pbmdBUEkpIHtcbiAgICBpZiAoc3VwcG9ydHNVc2VyVGltaW5nICYmICFpc1dhaXRpbmdGb3JDYWxsYmFjaykge1xuICAgICAgaXNXYWl0aW5nRm9yQ2FsbGJhY2sgPSB0cnVlO1xuICAgICAgYmVnaW5NYXJrKCcoV2FpdGluZyBmb3IgYXN5bmMgY2FsbGJhY2suLi4pJyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHN0b3BSZXF1ZXN0Q2FsbGJhY2tUaW1lcihkaWRFeHBpcmUpIHtcbiAgaWYgKGVuYWJsZVVzZXJUaW1pbmdBUEkpIHtcbiAgICBpZiAoc3VwcG9ydHNVc2VyVGltaW5nKSB7XG4gICAgICBpc1dhaXRpbmdGb3JDYWxsYmFjayA9IGZhbHNlO1xuICAgICAgdmFyIHdhcm5pbmckJDEgPSBkaWRFeHBpcmUgPyAnUmVhY3Qgd2FzIGJsb2NrZWQgYnkgbWFpbiB0aHJlYWQnIDogbnVsbDtcbiAgICAgIGVuZE1hcmsoJyhXYWl0aW5nIGZvciBhc3luYyBjYWxsYmFjay4uLiknLCAnKFdhaXRpbmcgZm9yIGFzeW5jIGNhbGxiYWNrLi4uKScsIHdhcm5pbmckJDEpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBzdGFydFdvcmtUaW1lcihmaWJlcikge1xuICBpZiAoZW5hYmxlVXNlclRpbWluZ0FQSSkge1xuICAgIGlmICghc3VwcG9ydHNVc2VyVGltaW5nIHx8IHNob3VsZElnbm9yZUZpYmVyKGZpYmVyKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBJZiB3ZSBwYXVzZSwgdGhpcyBpcyB0aGUgZmliZXIgdG8gdW53aW5kIGZyb20uXG4gICAgY3VycmVudEZpYmVyID0gZmliZXI7XG4gICAgaWYgKCFiZWdpbkZpYmVyTWFyayhmaWJlciwgbnVsbCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZmliZXIuX2RlYnVnSXNDdXJyZW50bHlUaW1pbmcgPSB0cnVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNhbmNlbFdvcmtUaW1lcihmaWJlcikge1xuICBpZiAoZW5hYmxlVXNlclRpbWluZ0FQSSkge1xuICAgIGlmICghc3VwcG9ydHNVc2VyVGltaW5nIHx8IHNob3VsZElnbm9yZUZpYmVyKGZpYmVyKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBSZW1lbWJlciB3ZSBzaG91bGRuJ3QgY29tcGxldGUgbWVhc3VyZW1lbnQgZm9yIHRoaXMgZmliZXIuXG4gICAgLy8gT3RoZXJ3aXNlIGZsYW1lY2hhcnQgd2lsbCBiZSBkZWVwIGV2ZW4gZm9yIHNtYWxsIHVwZGF0ZXMuXG4gICAgZmliZXIuX2RlYnVnSXNDdXJyZW50bHlUaW1pbmcgPSBmYWxzZTtcbiAgICBjbGVhckZpYmVyTWFyayhmaWJlciwgbnVsbCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RvcFdvcmtUaW1lcihmaWJlcikge1xuICBpZiAoZW5hYmxlVXNlclRpbWluZ0FQSSkge1xuICAgIGlmICghc3VwcG9ydHNVc2VyVGltaW5nIHx8IHNob3VsZElnbm9yZUZpYmVyKGZpYmVyKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBJZiB3ZSBwYXVzZSwgaXRzIHBhcmVudCBpcyB0aGUgZmliZXIgdG8gdW53aW5kIGZyb20uXG4gICAgY3VycmVudEZpYmVyID0gZmliZXJbJ3JldHVybiddO1xuICAgIGlmICghZmliZXIuX2RlYnVnSXNDdXJyZW50bHlUaW1pbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZmliZXIuX2RlYnVnSXNDdXJyZW50bHlUaW1pbmcgPSBmYWxzZTtcbiAgICBlbmRGaWJlck1hcmsoZmliZXIsIG51bGwsIG51bGwpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHN0b3BGYWlsZWRXb3JrVGltZXIoZmliZXIpIHtcbiAgaWYgKGVuYWJsZVVzZXJUaW1pbmdBUEkpIHtcbiAgICBpZiAoIXN1cHBvcnRzVXNlclRpbWluZyB8fCBzaG91bGRJZ25vcmVGaWJlcihmaWJlcikpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gSWYgd2UgcGF1c2UsIGl0cyBwYXJlbnQgaXMgdGhlIGZpYmVyIHRvIHVud2luZCBmcm9tLlxuICAgIGN1cnJlbnRGaWJlciA9IGZpYmVyWydyZXR1cm4nXTtcbiAgICBpZiAoIWZpYmVyLl9kZWJ1Z0lzQ3VycmVudGx5VGltaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZpYmVyLl9kZWJ1Z0lzQ3VycmVudGx5VGltaW5nID0gZmFsc2U7XG4gICAgdmFyIHdhcm5pbmckJDEgPSAnQW4gZXJyb3Igd2FzIHRocm93biBpbnNpZGUgdGhpcyBlcnJvciBib3VuZGFyeSc7XG4gICAgZW5kRmliZXJNYXJrKGZpYmVyLCBudWxsLCB3YXJuaW5nJCQxKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzdGFydFBoYXNlVGltZXIoZmliZXIsIHBoYXNlKSB7XG4gIGlmIChlbmFibGVVc2VyVGltaW5nQVBJKSB7XG4gICAgaWYgKCFzdXBwb3J0c1VzZXJUaW1pbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY2xlYXJQZW5kaW5nUGhhc2VNZWFzdXJlbWVudCgpO1xuICAgIGlmICghYmVnaW5GaWJlck1hcmsoZmliZXIsIHBoYXNlKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjdXJyZW50UGhhc2VGaWJlciA9IGZpYmVyO1xuICAgIGN1cnJlbnRQaGFzZSA9IHBoYXNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHN0b3BQaGFzZVRpbWVyKCkge1xuICBpZiAoZW5hYmxlVXNlclRpbWluZ0FQSSkge1xuICAgIGlmICghc3VwcG9ydHNVc2VyVGltaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChjdXJyZW50UGhhc2UgIT09IG51bGwgJiYgY3VycmVudFBoYXNlRmliZXIgIT09IG51bGwpIHtcbiAgICAgIHZhciB3YXJuaW5nJCQxID0gaGFzU2NoZWR1bGVkVXBkYXRlSW5DdXJyZW50UGhhc2UgPyAnU2NoZWR1bGVkIGEgY2FzY2FkaW5nIHVwZGF0ZScgOiBudWxsO1xuICAgICAgZW5kRmliZXJNYXJrKGN1cnJlbnRQaGFzZUZpYmVyLCBjdXJyZW50UGhhc2UsIHdhcm5pbmckJDEpO1xuICAgIH1cbiAgICBjdXJyZW50UGhhc2UgPSBudWxsO1xuICAgIGN1cnJlbnRQaGFzZUZpYmVyID0gbnVsbDtcbiAgfVxufVxuXG5mdW5jdGlvbiBzdGFydFdvcmtMb29wVGltZXIobmV4dFVuaXRPZldvcmspIHtcbiAgaWYgKGVuYWJsZVVzZXJUaW1pbmdBUEkpIHtcbiAgICBjdXJyZW50RmliZXIgPSBuZXh0VW5pdE9mV29yaztcbiAgICBpZiAoIXN1cHBvcnRzVXNlclRpbWluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb21taXRDb3VudEluQ3VycmVudFdvcmtMb29wID0gMDtcbiAgICAvLyBUaGlzIGlzIHRvcCBsZXZlbCBjYWxsLlxuICAgIC8vIEFueSBvdGhlciBtZWFzdXJlbWVudHMgYXJlIHBlcmZvcm1lZCB3aXRoaW4uXG4gICAgYmVnaW5NYXJrKCcoUmVhY3QgVHJlZSBSZWNvbmNpbGlhdGlvbiknKTtcbiAgICAvLyBSZXN1bWUgYW55IG1lYXN1cmVtZW50cyB0aGF0IHdlcmUgaW4gcHJvZ3Jlc3MgZHVyaW5nIHRoZSBsYXN0IGxvb3AuXG4gICAgcmVzdW1lVGltZXJzKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RvcFdvcmtMb29wVGltZXIoaW50ZXJydXB0ZWRCeSkge1xuICBpZiAoZW5hYmxlVXNlclRpbWluZ0FQSSkge1xuICAgIGlmICghc3VwcG9ydHNVc2VyVGltaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB3YXJuaW5nJCQxID0gbnVsbDtcbiAgICBpZiAoaW50ZXJydXB0ZWRCeSAhPT0gbnVsbCkge1xuICAgICAgaWYgKGludGVycnVwdGVkQnkudGFnID09PSBIb3N0Um9vdCkge1xuICAgICAgICB3YXJuaW5nJCQxID0gJ0EgdG9wLWxldmVsIHVwZGF0ZSBpbnRlcnJ1cHRlZCB0aGUgcHJldmlvdXMgcmVuZGVyJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZShpbnRlcnJ1cHRlZEJ5KSB8fCAnVW5rbm93bic7XG4gICAgICAgIHdhcm5pbmckJDEgPSAnQW4gdXBkYXRlIHRvICcgKyBjb21wb25lbnROYW1lICsgJyBpbnRlcnJ1cHRlZCB0aGUgcHJldmlvdXMgcmVuZGVyJztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGNvbW1pdENvdW50SW5DdXJyZW50V29ya0xvb3AgPiAxKSB7XG4gICAgICB3YXJuaW5nJCQxID0gJ1RoZXJlIHdlcmUgY2FzY2FkaW5nIHVwZGF0ZXMnO1xuICAgIH1cbiAgICBjb21taXRDb3VudEluQ3VycmVudFdvcmtMb29wID0gMDtcbiAgICAvLyBQYXVzZSBhbnkgbWVhc3VyZW1lbnRzIHVudGlsIHRoZSBuZXh0IGxvb3AuXG4gICAgcGF1c2VUaW1lcnMoKTtcbiAgICBlbmRNYXJrKCcoUmVhY3QgVHJlZSBSZWNvbmNpbGlhdGlvbiknLCAnKFJlYWN0IFRyZWUgUmVjb25jaWxpYXRpb24pJywgd2FybmluZyQkMSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RhcnRDb21taXRUaW1lcigpIHtcbiAgaWYgKGVuYWJsZVVzZXJUaW1pbmdBUEkpIHtcbiAgICBpZiAoIXN1cHBvcnRzVXNlclRpbWluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpc0NvbW1pdHRpbmcgPSB0cnVlO1xuICAgIGhhc1NjaGVkdWxlZFVwZGF0ZUluQ3VycmVudENvbW1pdCA9IGZhbHNlO1xuICAgIGxhYmVsc0luQ3VycmVudENvbW1pdC5jbGVhcigpO1xuICAgIGJlZ2luTWFyaygnKENvbW1pdHRpbmcgQ2hhbmdlcyknKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzdG9wQ29tbWl0VGltZXIoKSB7XG4gIGlmIChlbmFibGVVc2VyVGltaW5nQVBJKSB7XG4gICAgaWYgKCFzdXBwb3J0c1VzZXJUaW1pbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgd2FybmluZyQkMSA9IG51bGw7XG4gICAgaWYgKGhhc1NjaGVkdWxlZFVwZGF0ZUluQ3VycmVudENvbW1pdCkge1xuICAgICAgd2FybmluZyQkMSA9ICdMaWZlY3ljbGUgaG9vayBzY2hlZHVsZWQgYSBjYXNjYWRpbmcgdXBkYXRlJztcbiAgICB9IGVsc2UgaWYgKGNvbW1pdENvdW50SW5DdXJyZW50V29ya0xvb3AgPiAwKSB7XG4gICAgICB3YXJuaW5nJCQxID0gJ0NhdXNlZCBieSBhIGNhc2NhZGluZyB1cGRhdGUgaW4gZWFybGllciBjb21taXQnO1xuICAgIH1cbiAgICBoYXNTY2hlZHVsZWRVcGRhdGVJbkN1cnJlbnRDb21taXQgPSBmYWxzZTtcbiAgICBjb21taXRDb3VudEluQ3VycmVudFdvcmtMb29wKys7XG4gICAgaXNDb21taXR0aW5nID0gZmFsc2U7XG4gICAgbGFiZWxzSW5DdXJyZW50Q29tbWl0LmNsZWFyKCk7XG5cbiAgICBlbmRNYXJrKCcoQ29tbWl0dGluZyBDaGFuZ2VzKScsICcoQ29tbWl0dGluZyBDaGFuZ2VzKScsIHdhcm5pbmckJDEpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHN0YXJ0Q29tbWl0SG9zdEVmZmVjdHNUaW1lcigpIHtcbiAgaWYgKGVuYWJsZVVzZXJUaW1pbmdBUEkpIHtcbiAgICBpZiAoIXN1cHBvcnRzVXNlclRpbWluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBlZmZlY3RDb3VudEluQ3VycmVudENvbW1pdCA9IDA7XG4gICAgYmVnaW5NYXJrKCcoQ29tbWl0dGluZyBIb3N0IEVmZmVjdHMpJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RvcENvbW1pdEhvc3RFZmZlY3RzVGltZXIoKSB7XG4gIGlmIChlbmFibGVVc2VyVGltaW5nQVBJKSB7XG4gICAgaWYgKCFzdXBwb3J0c1VzZXJUaW1pbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGNvdW50ID0gZWZmZWN0Q291bnRJbkN1cnJlbnRDb21taXQ7XG4gICAgZWZmZWN0Q291bnRJbkN1cnJlbnRDb21taXQgPSAwO1xuICAgIGVuZE1hcmsoJyhDb21taXR0aW5nIEhvc3QgRWZmZWN0czogJyArIGNvdW50ICsgJyBUb3RhbCknLCAnKENvbW1pdHRpbmcgSG9zdCBFZmZlY3RzKScsIG51bGwpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHN0YXJ0Q29tbWl0TGlmZUN5Y2xlc1RpbWVyKCkge1xuICBpZiAoZW5hYmxlVXNlclRpbWluZ0FQSSkge1xuICAgIGlmICghc3VwcG9ydHNVc2VyVGltaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGVmZmVjdENvdW50SW5DdXJyZW50Q29tbWl0ID0gMDtcbiAgICBiZWdpbk1hcmsoJyhDYWxsaW5nIExpZmVjeWNsZSBNZXRob2RzKScpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHN0b3BDb21taXRMaWZlQ3ljbGVzVGltZXIoKSB7XG4gIGlmIChlbmFibGVVc2VyVGltaW5nQVBJKSB7XG4gICAgaWYgKCFzdXBwb3J0c1VzZXJUaW1pbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGNvdW50ID0gZWZmZWN0Q291bnRJbkN1cnJlbnRDb21taXQ7XG4gICAgZWZmZWN0Q291bnRJbkN1cnJlbnRDb21taXQgPSAwO1xuICAgIGVuZE1hcmsoJyhDYWxsaW5nIExpZmVjeWNsZSBNZXRob2RzOiAnICsgY291bnQgKyAnIFRvdGFsKScsICcoQ2FsbGluZyBMaWZlY3ljbGUgTWV0aG9kcyknLCBudWxsKTtcbiAgfVxufVxuXG57XG4gIHZhciB3YXJuZWRBYm91dE1pc3NpbmdHZXRDaGlsZENvbnRleHQgPSB7fTtcbn1cblxuLy8gQSBjdXJzb3IgdG8gdGhlIGN1cnJlbnQgbWVyZ2VkIGNvbnRleHQgb2JqZWN0IG9uIHRoZSBzdGFjay5cbnZhciBjb250ZXh0U3RhY2tDdXJzb3IgPSBjcmVhdGVDdXJzb3IoZW1wdHlPYmplY3QpO1xuLy8gQSBjdXJzb3IgdG8gYSBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0aGUgY29udGV4dCBoYXMgY2hhbmdlZC5cbnZhciBkaWRQZXJmb3JtV29ya1N0YWNrQ3Vyc29yID0gY3JlYXRlQ3Vyc29yKGZhbHNlKTtcbi8vIEtlZXAgdHJhY2sgb2YgdGhlIHByZXZpb3VzIGNvbnRleHQgb2JqZWN0IHRoYXQgd2FzIG9uIHRoZSBzdGFjay5cbi8vIFdlIHVzZSB0aGlzIHRvIGdldCBhY2Nlc3MgdG8gdGhlIHBhcmVudCBjb250ZXh0IGFmdGVyIHdlIGhhdmUgYWxyZWFkeVxuLy8gcHVzaGVkIHRoZSBuZXh0IGNvbnRleHQgcHJvdmlkZXIsIGFuZCBub3cgbmVlZCB0byBtZXJnZSB0aGVpciBjb250ZXh0cy5cbnZhciBwcmV2aW91c0NvbnRleHQgPSBlbXB0eU9iamVjdDtcblxuZnVuY3Rpb24gZ2V0VW5tYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzKSB7XG4gIHZhciBoYXNPd25Db250ZXh0ID0gaXNDb250ZXh0UHJvdmlkZXIod29ya0luUHJvZ3Jlc3MpO1xuICBpZiAoaGFzT3duQ29udGV4dCkge1xuICAgIC8vIElmIHRoZSBmaWJlciBpcyBhIGNvbnRleHQgcHJvdmlkZXIgaXRzZWxmLCB3aGVuIHdlIHJlYWQgaXRzIGNvbnRleHRcbiAgICAvLyB3ZSBoYXZlIGFscmVhZHkgcHVzaGVkIGl0cyBvd24gY2hpbGQgY29udGV4dCBvbiB0aGUgc3RhY2suIEEgY29udGV4dFxuICAgIC8vIHByb3ZpZGVyIHNob3VsZCBub3QgXCJzZWVcIiBpdHMgb3duIGNoaWxkIGNvbnRleHQuIFRoZXJlZm9yZSB3ZSByZWFkIHRoZVxuICAgIC8vIHByZXZpb3VzIChwYXJlbnQpIGNvbnRleHQgaW5zdGVhZCBmb3IgYSBjb250ZXh0IHByb3ZpZGVyLlxuICAgIHJldHVybiBwcmV2aW91c0NvbnRleHQ7XG4gIH1cbiAgcmV0dXJuIGNvbnRleHRTdGFja0N1cnNvci5jdXJyZW50O1xufVxuXG5mdW5jdGlvbiBjYWNoZUNvbnRleHQod29ya0luUHJvZ3Jlc3MsIHVubWFza2VkQ29udGV4dCwgbWFza2VkQ29udGV4dCkge1xuICB2YXIgaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gIGluc3RhbmNlLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkVW5tYXNrZWRDaGlsZENvbnRleHQgPSB1bm1hc2tlZENvbnRleHQ7XG4gIGluc3RhbmNlLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkTWFza2VkQ2hpbGRDb250ZXh0ID0gbWFza2VkQ29udGV4dDtcbn1cblxuZnVuY3Rpb24gZ2V0TWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgdW5tYXNrZWRDb250ZXh0KSB7XG4gIHZhciB0eXBlID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgdmFyIGNvbnRleHRUeXBlcyA9IHR5cGUuY29udGV4dFR5cGVzO1xuICBpZiAoIWNvbnRleHRUeXBlcykge1xuICAgIHJldHVybiBlbXB0eU9iamVjdDtcbiAgfVxuXG4gIC8vIEF2b2lkIHJlY3JlYXRpbmcgbWFza2VkIGNvbnRleHQgdW5sZXNzIHVubWFza2VkIGNvbnRleHQgaGFzIGNoYW5nZWQuXG4gIC8vIEZhaWxpbmcgdG8gZG8gdGhpcyB3aWxsIHJlc3VsdCBpbiB1bm5lY2Vzc2FyeSBjYWxscyB0byBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzLlxuICAvLyBUaGlzIG1heSB0cmlnZ2VyIGluZmluaXRlIGxvb3BzIGlmIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgY2FsbHMgc2V0U3RhdGUuXG4gIHZhciBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgaWYgKGluc3RhbmNlICYmIGluc3RhbmNlLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkVW5tYXNrZWRDaGlsZENvbnRleHQgPT09IHVubWFza2VkQ29udGV4dCkge1xuICAgIHJldHVybiBpbnN0YW5jZS5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZE1hc2tlZENoaWxkQ29udGV4dDtcbiAgfVxuXG4gIHZhciBjb250ZXh0ID0ge307XG4gIGZvciAodmFyIGtleSBpbiBjb250ZXh0VHlwZXMpIHtcbiAgICBjb250ZXh0W2tleV0gPSB1bm1hc2tlZENvbnRleHRba2V5XTtcbiAgfVxuXG4gIHtcbiAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWUod29ya0luUHJvZ3Jlc3MpIHx8ICdVbmtub3duJztcbiAgICBjaGVja1Byb3BUeXBlcyhjb250ZXh0VHlwZXMsIGNvbnRleHQsICdjb250ZXh0JywgbmFtZSwgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5nZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtKTtcbiAgfVxuXG4gIC8vIENhY2hlIHVubWFza2VkIGNvbnRleHQgc28gd2UgY2FuIGF2b2lkIHJlY3JlYXRpbmcgbWFza2VkIGNvbnRleHQgdW5sZXNzIG5lY2Vzc2FyeS5cbiAgLy8gQ29udGV4dCBpcyBjcmVhdGVkIGJlZm9yZSB0aGUgY2xhc3MgY29tcG9uZW50IGlzIGluc3RhbnRpYXRlZCBzbyBjaGVjayBmb3IgaW5zdGFuY2UuXG4gIGlmIChpbnN0YW5jZSkge1xuICAgIGNhY2hlQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgdW5tYXNrZWRDb250ZXh0LCBjb250ZXh0KTtcbiAgfVxuXG4gIHJldHVybiBjb250ZXh0O1xufVxuXG5mdW5jdGlvbiBoYXNDb250ZXh0Q2hhbmdlZCgpIHtcbiAgcmV0dXJuIGRpZFBlcmZvcm1Xb3JrU3RhY2tDdXJzb3IuY3VycmVudDtcbn1cblxuZnVuY3Rpb24gaXNDb250ZXh0Q29uc3VtZXIoZmliZXIpIHtcbiAgcmV0dXJuIGZpYmVyLnRhZyA9PT0gQ2xhc3NDb21wb25lbnQgJiYgZmliZXIudHlwZS5jb250ZXh0VHlwZXMgIT0gbnVsbDtcbn1cblxuZnVuY3Rpb24gaXNDb250ZXh0UHJvdmlkZXIoZmliZXIpIHtcbiAgcmV0dXJuIGZpYmVyLnRhZyA9PT0gQ2xhc3NDb21wb25lbnQgJiYgZmliZXIudHlwZS5jaGlsZENvbnRleHRUeXBlcyAhPSBudWxsO1xufVxuXG5mdW5jdGlvbiBwb3BDb250ZXh0UHJvdmlkZXIoZmliZXIpIHtcbiAgaWYgKCFpc0NvbnRleHRQcm92aWRlcihmaWJlcikpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBwb3AoZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvciwgZmliZXIpO1xuICBwb3AoY29udGV4dFN0YWNrQ3Vyc29yLCBmaWJlcik7XG59XG5cbmZ1bmN0aW9uIHBvcFRvcExldmVsQ29udGV4dE9iamVjdChmaWJlcikge1xuICBwb3AoZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvciwgZmliZXIpO1xuICBwb3AoY29udGV4dFN0YWNrQ3Vyc29yLCBmaWJlcik7XG59XG5cbmZ1bmN0aW9uIHB1c2hUb3BMZXZlbENvbnRleHRPYmplY3QoZmliZXIsIGNvbnRleHQsIGRpZENoYW5nZSkge1xuICAhKGNvbnRleHRTdGFja0N1cnNvci5jdXJzb3IgPT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdVbmV4cGVjdGVkIGNvbnRleHQgZm91bmQgb24gc3RhY2suIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG5cbiAgcHVzaChjb250ZXh0U3RhY2tDdXJzb3IsIGNvbnRleHQsIGZpYmVyKTtcbiAgcHVzaChkaWRQZXJmb3JtV29ya1N0YWNrQ3Vyc29yLCBkaWRDaGFuZ2UsIGZpYmVyKTtcbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0NoaWxkQ29udGV4dChmaWJlciwgcGFyZW50Q29udGV4dCkge1xuICB2YXIgaW5zdGFuY2UgPSBmaWJlci5zdGF0ZU5vZGU7XG4gIHZhciBjaGlsZENvbnRleHRUeXBlcyA9IGZpYmVyLnR5cGUuY2hpbGRDb250ZXh0VHlwZXM7XG5cbiAgLy8gVE9ETyAoYnZhdWdobikgUmVwbGFjZSB0aGlzIGJlaGF2aW9yIHdpdGggYW4gaW52YXJpYW50KCkgaW4gdGhlIGZ1dHVyZS5cbiAgLy8gSXQgaGFzIG9ubHkgYmVlbiBhZGRlZCBpbiBGaWJlciB0byBtYXRjaCB0aGUgKHVuaW50ZW50aW9uYWwpIGJlaGF2aW9yIGluIFN0YWNrLlxuICBpZiAodHlwZW9mIGluc3RhbmNlLmdldENoaWxkQ29udGV4dCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZShmaWJlcikgfHwgJ1Vua25vd24nO1xuXG4gICAgICBpZiAoIXdhcm5lZEFib3V0TWlzc2luZ0dldENoaWxkQ29udGV4dFtjb21wb25lbnROYW1lXSkge1xuICAgICAgICB3YXJuZWRBYm91dE1pc3NpbmdHZXRDaGlsZENvbnRleHRbY29tcG9uZW50TmFtZV0gPSB0cnVlO1xuICAgICAgICB3YXJuaW5nKGZhbHNlLCAnJXMuY2hpbGRDb250ZXh0VHlwZXMgaXMgc3BlY2lmaWVkIGJ1dCB0aGVyZSBpcyBubyBnZXRDaGlsZENvbnRleHQoKSBtZXRob2QgJyArICdvbiB0aGUgaW5zdGFuY2UuIFlvdSBjYW4gZWl0aGVyIGRlZmluZSBnZXRDaGlsZENvbnRleHQoKSBvbiAlcyBvciByZW1vdmUgJyArICdjaGlsZENvbnRleHRUeXBlcyBmcm9tIGl0LicsIGNvbXBvbmVudE5hbWUsIGNvbXBvbmVudE5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcGFyZW50Q29udGV4dDtcbiAgfVxuXG4gIHZhciBjaGlsZENvbnRleHQgPSB2b2lkIDA7XG4gIHtcbiAgICBSZWFjdERlYnVnQ3VycmVudEZpYmVyLnNldEN1cnJlbnRQaGFzZSgnZ2V0Q2hpbGRDb250ZXh0Jyk7XG4gIH1cbiAgc3RhcnRQaGFzZVRpbWVyKGZpYmVyLCAnZ2V0Q2hpbGRDb250ZXh0Jyk7XG4gIGNoaWxkQ29udGV4dCA9IGluc3RhbmNlLmdldENoaWxkQ29udGV4dCgpO1xuICBzdG9wUGhhc2VUaW1lcigpO1xuICB7XG4gICAgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5zZXRDdXJyZW50UGhhc2UobnVsbCk7XG4gIH1cbiAgZm9yICh2YXIgY29udGV4dEtleSBpbiBjaGlsZENvbnRleHQpIHtcbiAgICAhKGNvbnRleHRLZXkgaW4gY2hpbGRDb250ZXh0VHlwZXMpID8gaW52YXJpYW50KGZhbHNlLCAnJXMuZ2V0Q2hpbGRDb250ZXh0KCk6IGtleSBcIiVzXCIgaXMgbm90IGRlZmluZWQgaW4gY2hpbGRDb250ZXh0VHlwZXMuJywgZ2V0Q29tcG9uZW50TmFtZShmaWJlcikgfHwgJ1Vua25vd24nLCBjb250ZXh0S2V5KSA6IHZvaWQgMDtcbiAgfVxuICB7XG4gICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lKGZpYmVyKSB8fCAnVW5rbm93bic7XG4gICAgY2hlY2tQcm9wVHlwZXMoY2hpbGRDb250ZXh0VHlwZXMsIGNoaWxkQ29udGV4dCwgJ2NoaWxkIGNvbnRleHQnLCBuYW1lLFxuICAgIC8vIEluIHByYWN0aWNlLCB0aGVyZSBpcyBvbmUgY2FzZSBpbiB3aGljaCB3ZSB3b24ndCBnZXQgYSBzdGFjay4gSXQncyB3aGVuXG4gICAgLy8gc29tZWJvZHkgY2FsbHMgdW5zdGFibGVfcmVuZGVyU3VidHJlZUludG9Db250YWluZXIoKSBhbmQgd2UgcHJvY2Vzc1xuICAgIC8vIGNvbnRleHQgZnJvbSB0aGUgcGFyZW50IGNvbXBvbmVudCBpbnN0YW5jZS4gVGhlIHN0YWNrIHdpbGwgYmUgbWlzc2luZ1xuICAgIC8vIGJlY2F1c2UgaXQncyBvdXRzaWRlIG9mIHRoZSByZWNvbmNpbGlhdGlvbiwgYW5kIHNvIHRoZSBwb2ludGVyIGhhcyBub3RcbiAgICAvLyBiZWVuIHNldC4gVGhpcyBpcyByYXJlIGFuZCBkb2Vzbid0IG1hdHRlci4gV2UnbGwgYWxzbyByZW1vdmUgdGhhdCBBUEkuXG4gICAgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5nZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtKTtcbiAgfVxuXG4gIHJldHVybiBfYXNzaWduKHt9LCBwYXJlbnRDb250ZXh0LCBjaGlsZENvbnRleHQpO1xufVxuXG5mdW5jdGlvbiBwdXNoQ29udGV4dFByb3ZpZGVyKHdvcmtJblByb2dyZXNzKSB7XG4gIGlmICghaXNDb250ZXh0UHJvdmlkZXIod29ya0luUHJvZ3Jlc3MpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIGluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAvLyBXZSBwdXNoIHRoZSBjb250ZXh0IGFzIGVhcmx5IGFzIHBvc3NpYmxlIHRvIGVuc3VyZSBzdGFjayBpbnRlZ3JpdHkuXG4gIC8vIElmIHRoZSBpbnN0YW5jZSBkb2VzIG5vdCBleGlzdCB5ZXQsIHdlIHdpbGwgcHVzaCBudWxsIGF0IGZpcnN0LFxuICAvLyBhbmQgcmVwbGFjZSBpdCBvbiB0aGUgc3RhY2sgbGF0ZXIgd2hlbiBpbnZhbGlkYXRpbmcgdGhlIGNvbnRleHQuXG4gIHZhciBtZW1vaXplZE1lcmdlZENoaWxkQ29udGV4dCA9IGluc3RhbmNlICYmIGluc3RhbmNlLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkTWVyZ2VkQ2hpbGRDb250ZXh0IHx8IGVtcHR5T2JqZWN0O1xuXG4gIC8vIFJlbWVtYmVyIHRoZSBwYXJlbnQgY29udGV4dCBzbyB3ZSBjYW4gbWVyZ2Ugd2l0aCBpdCBsYXRlci5cbiAgLy8gSW5oZXJpdCB0aGUgcGFyZW50J3MgZGlkLXBlcmZvcm0td29yayB2YWx1ZSB0byBhdm9pZCBpbmFkdmVydGVudGx5IGJsb2NraW5nIHVwZGF0ZXMuXG4gIHByZXZpb3VzQ29udGV4dCA9IGNvbnRleHRTdGFja0N1cnNvci5jdXJyZW50O1xuICBwdXNoKGNvbnRleHRTdGFja0N1cnNvciwgbWVtb2l6ZWRNZXJnZWRDaGlsZENvbnRleHQsIHdvcmtJblByb2dyZXNzKTtcbiAgcHVzaChkaWRQZXJmb3JtV29ya1N0YWNrQ3Vyc29yLCBkaWRQZXJmb3JtV29ya1N0YWNrQ3Vyc29yLmN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gaW52YWxpZGF0ZUNvbnRleHRQcm92aWRlcih3b3JrSW5Qcm9ncmVzcywgZGlkQ2hhbmdlKSB7XG4gIHZhciBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgIWluc3RhbmNlID8gaW52YXJpYW50KGZhbHNlLCAnRXhwZWN0ZWQgdG8gaGF2ZSBhbiBpbnN0YW5jZSBieSB0aGlzIHBvaW50LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuXG4gIGlmIChkaWRDaGFuZ2UpIHtcbiAgICAvLyBNZXJnZSBwYXJlbnQgYW5kIG93biBjb250ZXh0LlxuICAgIC8vIFNraXAgdGhpcyBpZiB3ZSdyZSBub3QgdXBkYXRpbmcgZHVlIHRvIHNDVS5cbiAgICAvLyBUaGlzIGF2b2lkcyB1bm5lY2Vzc2FyaWx5IHJlY29tcHV0aW5nIG1lbW9pemVkIHZhbHVlcy5cbiAgICB2YXIgbWVyZ2VkQ29udGV4dCA9IHByb2Nlc3NDaGlsZENvbnRleHQod29ya0luUHJvZ3Jlc3MsIHByZXZpb3VzQ29udGV4dCk7XG4gICAgaW5zdGFuY2UuX19yZWFjdEludGVybmFsTWVtb2l6ZWRNZXJnZWRDaGlsZENvbnRleHQgPSBtZXJnZWRDb250ZXh0O1xuXG4gICAgLy8gUmVwbGFjZSB0aGUgb2xkIChvciBlbXB0eSkgY29udGV4dCB3aXRoIHRoZSBuZXcgb25lLlxuICAgIC8vIEl0IGlzIGltcG9ydGFudCB0byB1bndpbmQgdGhlIGNvbnRleHQgaW4gdGhlIHJldmVyc2Ugb3JkZXIuXG4gICAgcG9wKGRpZFBlcmZvcm1Xb3JrU3RhY2tDdXJzb3IsIHdvcmtJblByb2dyZXNzKTtcbiAgICBwb3AoY29udGV4dFN0YWNrQ3Vyc29yLCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgLy8gTm93IHB1c2ggdGhlIG5ldyBjb250ZXh0IGFuZCBtYXJrIHRoYXQgaXQgaGFzIGNoYW5nZWQuXG4gICAgcHVzaChjb250ZXh0U3RhY2tDdXJzb3IsIG1lcmdlZENvbnRleHQsIHdvcmtJblByb2dyZXNzKTtcbiAgICBwdXNoKGRpZFBlcmZvcm1Xb3JrU3RhY2tDdXJzb3IsIGRpZENoYW5nZSwgd29ya0luUHJvZ3Jlc3MpO1xuICB9IGVsc2Uge1xuICAgIHBvcChkaWRQZXJmb3JtV29ya1N0YWNrQ3Vyc29yLCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgcHVzaChkaWRQZXJmb3JtV29ya1N0YWNrQ3Vyc29yLCBkaWRDaGFuZ2UsIHdvcmtJblByb2dyZXNzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXNldENvbnRleHQoKSB7XG4gIHByZXZpb3VzQ29udGV4dCA9IGVtcHR5T2JqZWN0O1xuICBjb250ZXh0U3RhY2tDdXJzb3IuY3VycmVudCA9IGVtcHR5T2JqZWN0O1xuICBkaWRQZXJmb3JtV29ya1N0YWNrQ3Vyc29yLmN1cnJlbnQgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gZmluZEN1cnJlbnRVbm1hc2tlZENvbnRleHQoZmliZXIpIHtcbiAgLy8gQ3VycmVudGx5IHRoaXMgaXMgb25seSB1c2VkIHdpdGggcmVuZGVyU3VidHJlZUludG9Db250YWluZXI7IG5vdCBzdXJlIGlmIGl0XG4gIC8vIG1ha2VzIHNlbnNlIGVsc2V3aGVyZVxuICAhKGlzRmliZXJNb3VudGVkKGZpYmVyKSAmJiBmaWJlci50YWcgPT09IENsYXNzQ29tcG9uZW50KSA/IGludmFyaWFudChmYWxzZSwgJ0V4cGVjdGVkIHN1YnRyZWUgcGFyZW50IHRvIGJlIGEgbW91bnRlZCBjbGFzcyBjb21wb25lbnQuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG5cbiAgdmFyIG5vZGUgPSBmaWJlcjtcbiAgd2hpbGUgKG5vZGUudGFnICE9PSBIb3N0Um9vdCkge1xuICAgIGlmIChpc0NvbnRleHRQcm92aWRlcihub2RlKSkge1xuICAgICAgcmV0dXJuIG5vZGUuc3RhdGVOb2RlLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkTWVyZ2VkQ2hpbGRDb250ZXh0O1xuICAgIH1cbiAgICB2YXIgcGFyZW50ID0gbm9kZVsncmV0dXJuJ107XG4gICAgIXBhcmVudCA/IGludmFyaWFudChmYWxzZSwgJ0ZvdW5kIHVuZXhwZWN0ZWQgZGV0YWNoZWQgc3VidHJlZSBwYXJlbnQuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gICAgbm9kZSA9IHBhcmVudDtcbiAgfVxuICByZXR1cm4gbm9kZS5zdGF0ZU5vZGUuY29udGV4dDtcbn1cblxudmFyIE5vV29yayA9IDA7IC8vIFRPRE86IFVzZSBhbiBvcGFxdWUgdHlwZSBvbmNlIEVTTGludCBldCBhbCBzdXBwb3J0IHRoZSBzeW50YXhcblxudmFyIFN5bmMgPSAxO1xudmFyIE5ldmVyID0gMjE0NzQ4MzY0NzsgLy8gTWF4IGludDMyOiBNYXRoLnBvdygyLCAzMSkgLSAxXG5cbnZhciBVTklUX1NJWkUgPSAxMDtcbnZhciBNQUdJQ19OVU1CRVJfT0ZGU0VUID0gMjtcblxuLy8gMSB1bml0IG9mIGV4cGlyYXRpb24gdGltZSByZXByZXNlbnRzIDEwbXMuXG5mdW5jdGlvbiBtc1RvRXhwaXJhdGlvblRpbWUobXMpIHtcbiAgLy8gQWx3YXlzIGFkZCBhbiBvZmZzZXQgc28gdGhhdCB3ZSBkb24ndCBjbGFzaCB3aXRoIHRoZSBtYWdpYyBudW1iZXIgZm9yIE5vV29yay5cbiAgcmV0dXJuIChtcyAvIFVOSVRfU0laRSB8IDApICsgTUFHSUNfTlVNQkVSX09GRlNFVDtcbn1cblxuZnVuY3Rpb24gZXhwaXJhdGlvblRpbWVUb01zKGV4cGlyYXRpb25UaW1lKSB7XG4gIHJldHVybiAoZXhwaXJhdGlvblRpbWUgLSBNQUdJQ19OVU1CRVJfT0ZGU0VUKSAqIFVOSVRfU0laRTtcbn1cblxuZnVuY3Rpb24gY2VpbGluZyhudW0sIHByZWNpc2lvbikge1xuICByZXR1cm4gKChudW0gLyBwcmVjaXNpb24gfCAwKSArIDEpICogcHJlY2lzaW9uO1xufVxuXG5mdW5jdGlvbiBjb21wdXRlRXhwaXJhdGlvbkJ1Y2tldChjdXJyZW50VGltZSwgZXhwaXJhdGlvbkluTXMsIGJ1Y2tldFNpemVNcykge1xuICByZXR1cm4gY2VpbGluZyhjdXJyZW50VGltZSArIGV4cGlyYXRpb25Jbk1zIC8gVU5JVF9TSVpFLCBidWNrZXRTaXplTXMgLyBVTklUX1NJWkUpO1xufVxuXG52YXIgTm9Db250ZXh0ID0gMDtcbnZhciBBc3luY1VwZGF0ZXMgPSAxO1xuXG57XG4gIHZhciBoYXNCYWRNYXBQb2x5ZmlsbCA9IGZhbHNlO1xuICB0cnkge1xuICAgIHZhciBub25FeHRlbnNpYmxlT2JqZWN0ID0gT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zKHt9KTtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1uZXcgKi9cbiAgICBcbiAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLW5ldyAqL1xuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gVE9ETzogQ29uc2lkZXIgd2FybmluZyBhYm91dCBiYWQgcG9seWZpbGxzXG4gICAgaGFzQmFkTWFwUG9seWZpbGwgPSB0cnVlO1xuICB9XG59XG5cbi8vIEEgRmliZXIgaXMgd29yayBvbiBhIENvbXBvbmVudCB0aGF0IG5lZWRzIHRvIGJlIGRvbmUgb3Igd2FzIGRvbmUuIFRoZXJlIGNhblxuLy8gYmUgbW9yZSB0aGFuIG9uZSBwZXIgY29tcG9uZW50LlxuXG5cbntcbiAgdmFyIGRlYnVnQ291bnRlciA9IDE7XG59XG5cbmZ1bmN0aW9uIEZpYmVyTm9kZSh0YWcsIGtleSwgaW50ZXJuYWxDb250ZXh0VGFnKSB7XG4gIC8vIEluc3RhbmNlXG4gIHRoaXMudGFnID0gdGFnO1xuICB0aGlzLmtleSA9IGtleTtcbiAgdGhpcy50eXBlID0gbnVsbDtcbiAgdGhpcy5zdGF0ZU5vZGUgPSBudWxsO1xuXG4gIC8vIEZpYmVyXG4gIHRoaXNbJ3JldHVybiddID0gbnVsbDtcbiAgdGhpcy5jaGlsZCA9IG51bGw7XG4gIHRoaXMuc2libGluZyA9IG51bGw7XG4gIHRoaXMuaW5kZXggPSAwO1xuXG4gIHRoaXMucmVmID0gbnVsbDtcblxuICB0aGlzLnBlbmRpbmdQcm9wcyA9IG51bGw7XG4gIHRoaXMubWVtb2l6ZWRQcm9wcyA9IG51bGw7XG4gIHRoaXMudXBkYXRlUXVldWUgPSBudWxsO1xuICB0aGlzLm1lbW9pemVkU3RhdGUgPSBudWxsO1xuXG4gIHRoaXMuaW50ZXJuYWxDb250ZXh0VGFnID0gaW50ZXJuYWxDb250ZXh0VGFnO1xuXG4gIC8vIEVmZmVjdHNcbiAgdGhpcy5lZmZlY3RUYWcgPSBOb0VmZmVjdDtcbiAgdGhpcy5uZXh0RWZmZWN0ID0gbnVsbDtcblxuICB0aGlzLmZpcnN0RWZmZWN0ID0gbnVsbDtcbiAgdGhpcy5sYXN0RWZmZWN0ID0gbnVsbDtcblxuICB0aGlzLmV4cGlyYXRpb25UaW1lID0gTm9Xb3JrO1xuXG4gIHRoaXMuYWx0ZXJuYXRlID0gbnVsbDtcblxuICB7XG4gICAgdGhpcy5fZGVidWdJRCA9IGRlYnVnQ291bnRlcisrO1xuICAgIHRoaXMuX2RlYnVnU291cmNlID0gbnVsbDtcbiAgICB0aGlzLl9kZWJ1Z093bmVyID0gbnVsbDtcbiAgICB0aGlzLl9kZWJ1Z0lzQ3VycmVudGx5VGltaW5nID0gZmFsc2U7XG4gICAgaWYgKCFoYXNCYWRNYXBQb2x5ZmlsbCAmJiB0eXBlb2YgT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBPYmplY3QucHJldmVudEV4dGVuc2lvbnModGhpcyk7XG4gICAgfVxuICB9XG59XG5cbi8vIFRoaXMgaXMgYSBjb25zdHJ1Y3RvciBmdW5jdGlvbiwgcmF0aGVyIHRoYW4gYSBQT0pPIGNvbnN0cnVjdG9yLCBzdGlsbFxuLy8gcGxlYXNlIGVuc3VyZSB3ZSBkbyB0aGUgZm9sbG93aW5nOlxuLy8gMSkgTm9ib2R5IHNob3VsZCBhZGQgYW55IGluc3RhbmNlIG1ldGhvZHMgb24gdGhpcy4gSW5zdGFuY2UgbWV0aG9kcyBjYW4gYmVcbi8vICAgIG1vcmUgZGlmZmljdWx0IHRvIHByZWRpY3Qgd2hlbiB0aGV5IGdldCBvcHRpbWl6ZWQgYW5kIHRoZXkgYXJlIGFsbW9zdFxuLy8gICAgbmV2ZXIgaW5saW5lZCBwcm9wZXJseSBpbiBzdGF0aWMgY29tcGlsZXJzLlxuLy8gMikgTm9ib2R5IHNob3VsZCByZWx5IG9uIGBpbnN0YW5jZW9mIEZpYmVyYCBmb3IgdHlwZSB0ZXN0aW5nLiBXZSBzaG91bGRcbi8vICAgIGFsd2F5cyBrbm93IHdoZW4gaXQgaXMgYSBmaWJlci5cbi8vIDMpIFdlIG1pZ2h0IHdhbnQgdG8gZXhwZXJpbWVudCB3aXRoIHVzaW5nIG51bWVyaWMga2V5cyBzaW5jZSB0aGV5IGFyZSBlYXNpZXJcbi8vICAgIHRvIG9wdGltaXplIGluIGEgbm9uLUpJVCBlbnZpcm9ubWVudC5cbi8vIDQpIFdlIGNhbiBlYXNpbHkgZ28gZnJvbSBhIGNvbnN0cnVjdG9yIHRvIGEgY3JlYXRlRmliZXIgb2JqZWN0IGxpdGVyYWwgaWYgdGhhdFxuLy8gICAgaXMgZmFzdGVyLlxuLy8gNSkgSXQgc2hvdWxkIGJlIGVhc3kgdG8gcG9ydCB0aGlzIHRvIGEgQyBzdHJ1Y3QgYW5kIGtlZXAgYSBDIGltcGxlbWVudGF0aW9uXG4vLyAgICBjb21wYXRpYmxlLlxudmFyIGNyZWF0ZUZpYmVyID0gZnVuY3Rpb24gKHRhZywga2V5LCBpbnRlcm5hbENvbnRleHRUYWcpIHtcbiAgLy8gJEZsb3dGaXhNZTogdGhlIHNoYXBlcyBhcmUgZXhhY3QgaGVyZSBidXQgRmxvdyBkb2Vzbid0IGxpa2UgY29uc3RydWN0b3JzXG4gIHJldHVybiBuZXcgRmliZXJOb2RlKHRhZywga2V5LCBpbnRlcm5hbENvbnRleHRUYWcpO1xufTtcblxuZnVuY3Rpb24gc2hvdWxkQ29uc3RydWN0KENvbXBvbmVudCkge1xuICByZXR1cm4gISEoQ29tcG9uZW50LnByb3RvdHlwZSAmJiBDb21wb25lbnQucHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQpO1xufVxuXG4vLyBUaGlzIGlzIHVzZWQgdG8gY3JlYXRlIGFuIGFsdGVybmF0ZSBmaWJlciB0byBkbyB3b3JrIG9uLlxuZnVuY3Rpb24gY3JlYXRlV29ya0luUHJvZ3Jlc3MoY3VycmVudCwgcGVuZGluZ1Byb3BzLCBleHBpcmF0aW9uVGltZSkge1xuICB2YXIgd29ya0luUHJvZ3Jlc3MgPSBjdXJyZW50LmFsdGVybmF0ZTtcbiAgaWYgKHdvcmtJblByb2dyZXNzID09PSBudWxsKSB7XG4gICAgLy8gV2UgdXNlIGEgZG91YmxlIGJ1ZmZlcmluZyBwb29saW5nIHRlY2huaXF1ZSBiZWNhdXNlIHdlIGtub3cgdGhhdCB3ZSdsbFxuICAgIC8vIG9ubHkgZXZlciBuZWVkIGF0IG1vc3QgdHdvIHZlcnNpb25zIG9mIGEgdHJlZS4gV2UgcG9vbCB0aGUgXCJvdGhlclwiIHVudXNlZFxuICAgIC8vIG5vZGUgdGhhdCB3ZSdyZSBmcmVlIHRvIHJldXNlLiBUaGlzIGlzIGxhemlseSBjcmVhdGVkIHRvIGF2b2lkIGFsbG9jYXRpbmdcbiAgICAvLyBleHRyYSBvYmplY3RzIGZvciB0aGluZ3MgdGhhdCBhcmUgbmV2ZXIgdXBkYXRlZC4gSXQgYWxzbyBhbGxvdyB1cyB0b1xuICAgIC8vIHJlY2xhaW0gdGhlIGV4dHJhIG1lbW9yeSBpZiBuZWVkZWQuXG4gICAgd29ya0luUHJvZ3Jlc3MgPSBjcmVhdGVGaWJlcihjdXJyZW50LnRhZywgY3VycmVudC5rZXksIGN1cnJlbnQuaW50ZXJuYWxDb250ZXh0VGFnKTtcbiAgICB3b3JrSW5Qcm9ncmVzcy50eXBlID0gY3VycmVudC50eXBlO1xuICAgIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IGN1cnJlbnQuc3RhdGVOb2RlO1xuXG4gICAge1xuICAgICAgLy8gREVWLW9ubHkgZmllbGRzXG4gICAgICB3b3JrSW5Qcm9ncmVzcy5fZGVidWdJRCA9IGN1cnJlbnQuX2RlYnVnSUQ7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5fZGVidWdTb3VyY2UgPSBjdXJyZW50Ll9kZWJ1Z1NvdXJjZTtcbiAgICAgIHdvcmtJblByb2dyZXNzLl9kZWJ1Z093bmVyID0gY3VycmVudC5fZGVidWdPd25lcjtcbiAgICB9XG5cbiAgICB3b3JrSW5Qcm9ncmVzcy5hbHRlcm5hdGUgPSBjdXJyZW50O1xuICAgIGN1cnJlbnQuYWx0ZXJuYXRlID0gd29ya0luUHJvZ3Jlc3M7XG4gIH0gZWxzZSB7XG4gICAgLy8gV2UgYWxyZWFkeSBoYXZlIGFuIGFsdGVybmF0ZS5cbiAgICAvLyBSZXNldCB0aGUgZWZmZWN0IHRhZy5cbiAgICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgPSBOb0VmZmVjdDtcblxuICAgIC8vIFRoZSBlZmZlY3QgbGlzdCBpcyBubyBsb25nZXIgdmFsaWQuXG4gICAgd29ya0luUHJvZ3Jlc3MubmV4dEVmZmVjdCA9IG51bGw7XG4gICAgd29ya0luUHJvZ3Jlc3MuZmlyc3RFZmZlY3QgPSBudWxsO1xuICAgIHdvcmtJblByb2dyZXNzLmxhc3RFZmZlY3QgPSBudWxsO1xuICB9XG5cbiAgd29ya0luUHJvZ3Jlc3MuZXhwaXJhdGlvblRpbWUgPSBleHBpcmF0aW9uVGltZTtcbiAgd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzID0gcGVuZGluZ1Byb3BzO1xuXG4gIHdvcmtJblByb2dyZXNzLmNoaWxkID0gY3VycmVudC5jaGlsZDtcbiAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcyA9IGN1cnJlbnQubWVtb2l6ZWRQcm9wcztcbiAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZTtcbiAgd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgPSBjdXJyZW50LnVwZGF0ZVF1ZXVlO1xuXG4gIC8vIFRoZXNlIHdpbGwgYmUgb3ZlcnJpZGRlbiBkdXJpbmcgdGhlIHBhcmVudCdzIHJlY29uY2lsaWF0aW9uXG4gIHdvcmtJblByb2dyZXNzLnNpYmxpbmcgPSBjdXJyZW50LnNpYmxpbmc7XG4gIHdvcmtJblByb2dyZXNzLmluZGV4ID0gY3VycmVudC5pbmRleDtcbiAgd29ya0luUHJvZ3Jlc3MucmVmID0gY3VycmVudC5yZWY7XG5cbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVIb3N0Um9vdEZpYmVyKCkge1xuICB2YXIgZmliZXIgPSBjcmVhdGVGaWJlcihIb3N0Um9vdCwgbnVsbCwgTm9Db250ZXh0KTtcbiAgcmV0dXJuIGZpYmVyO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVGaWJlckZyb21FbGVtZW50KGVsZW1lbnQsIGludGVybmFsQ29udGV4dFRhZywgZXhwaXJhdGlvblRpbWUpIHtcbiAgdmFyIG93bmVyID0gbnVsbDtcbiAge1xuICAgIG93bmVyID0gZWxlbWVudC5fb3duZXI7XG4gIH1cblxuICB2YXIgZmliZXIgPSB2b2lkIDA7XG4gIHZhciB0eXBlID0gZWxlbWVudC50eXBlLFxuICAgICAga2V5ID0gZWxlbWVudC5rZXk7XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgZmliZXIgPSBzaG91bGRDb25zdHJ1Y3QodHlwZSkgPyBjcmVhdGVGaWJlcihDbGFzc0NvbXBvbmVudCwga2V5LCBpbnRlcm5hbENvbnRleHRUYWcpIDogY3JlYXRlRmliZXIoSW5kZXRlcm1pbmF0ZUNvbXBvbmVudCwga2V5LCBpbnRlcm5hbENvbnRleHRUYWcpO1xuICAgIGZpYmVyLnR5cGUgPSB0eXBlO1xuICAgIGZpYmVyLnBlbmRpbmdQcm9wcyA9IGVsZW1lbnQucHJvcHM7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgZmliZXIgPSBjcmVhdGVGaWJlcihIb3N0Q29tcG9uZW50LCBrZXksIGludGVybmFsQ29udGV4dFRhZyk7XG4gICAgZmliZXIudHlwZSA9IHR5cGU7XG4gICAgZmliZXIucGVuZGluZ1Byb3BzID0gZWxlbWVudC5wcm9wcztcbiAgfSBlbHNlIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCAmJiB0eXBlb2YgdHlwZS50YWcgPT09ICdudW1iZXInKSB7XG4gICAgLy8gQ3VycmVudGx5IGFzc3VtZWQgdG8gYmUgYSBjb250aW51YXRpb24gYW5kIHRoZXJlZm9yZSBpcyBhIGZpYmVyIGFscmVhZHkuXG4gICAgLy8gVE9ETzogVGhlIHlpZWxkIHN5c3RlbSBpcyBjdXJyZW50bHkgYnJva2VuIGZvciB1cGRhdGVzIGluIHNvbWUgY2FzZXMuXG4gICAgLy8gVGhlIHJlaWZpZWQgeWllbGQgc3RvcmVzIGEgZmliZXIsIGJ1dCB3ZSBkb24ndCBrbm93IHdoaWNoIGZpYmVyIHRoYXQgaXM7XG4gICAgLy8gdGhlIGN1cnJlbnQgb3IgYSB3b3JrSW5Qcm9ncmVzcz8gV2hlbiB0aGUgY29udGludWF0aW9uIGdldHMgcmVuZGVyZWQgaGVyZVxuICAgIC8vIHdlIGRvbid0IGtub3cgaWYgd2UgY2FuIHJldXNlIHRoYXQgZmliZXIgb3IgaWYgd2UgbmVlZCB0byBjbG9uZSBpdC5cbiAgICAvLyBUaGVyZSBpcyBwcm9iYWJseSBhIGNsZXZlciB3YXkgdG8gcmVzdHJ1Y3R1cmUgdGhpcy5cbiAgICBmaWJlciA9IHR5cGU7XG4gICAgZmliZXIucGVuZGluZ1Byb3BzID0gZWxlbWVudC5wcm9wcztcbiAgfSBlbHNlIHtcbiAgICB2YXIgaW5mbyA9ICcnO1xuICAgIHtcbiAgICAgIGlmICh0eXBlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwgJiYgT2JqZWN0LmtleXModHlwZSkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGluZm8gKz0gJyBZb3UgbGlrZWx5IGZvcmdvdCB0byBleHBvcnQgeW91ciBjb21wb25lbnQgZnJvbSB0aGUgZmlsZSAnICsgXCJpdCdzIGRlZmluZWQgaW4sIG9yIHlvdSBtaWdodCBoYXZlIG1peGVkIHVwIGRlZmF1bHQgYW5kIG5hbWVkIGltcG9ydHMuXCI7XG4gICAgICB9XG4gICAgICB2YXIgb3duZXJOYW1lID0gb3duZXIgPyBnZXRDb21wb25lbnROYW1lKG93bmVyKSA6IG51bGw7XG4gICAgICBpZiAob3duZXJOYW1lKSB7XG4gICAgICAgIGluZm8gKz0gJ1xcblxcbkNoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGAnICsgb3duZXJOYW1lICsgJ2AuJztcbiAgICAgIH1cbiAgICB9XG4gICAgaW52YXJpYW50KGZhbHNlLCAnRWxlbWVudCB0eXBlIGlzIGludmFsaWQ6IGV4cGVjdGVkIGEgc3RyaW5nIChmb3IgYnVpbHQtaW4gY29tcG9uZW50cykgb3IgYSBjbGFzcy9mdW5jdGlvbiAoZm9yIGNvbXBvc2l0ZSBjb21wb25lbnRzKSBidXQgZ290OiAlcy4lcycsIHR5cGUgPT0gbnVsbCA/IHR5cGUgOiB0eXBlb2YgdHlwZSwgaW5mbyk7XG4gIH1cblxuICB7XG4gICAgZmliZXIuX2RlYnVnU291cmNlID0gZWxlbWVudC5fc291cmNlO1xuICAgIGZpYmVyLl9kZWJ1Z093bmVyID0gZWxlbWVudC5fb3duZXI7XG4gIH1cblxuICBmaWJlci5leHBpcmF0aW9uVGltZSA9IGV4cGlyYXRpb25UaW1lO1xuXG4gIHJldHVybiBmaWJlcjtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRmliZXJGcm9tRnJhZ21lbnQoZWxlbWVudHMsIGludGVybmFsQ29udGV4dFRhZywgZXhwaXJhdGlvblRpbWUsIGtleSkge1xuICB2YXIgZmliZXIgPSBjcmVhdGVGaWJlcihGcmFnbWVudCwga2V5LCBpbnRlcm5hbENvbnRleHRUYWcpO1xuICBmaWJlci5wZW5kaW5nUHJvcHMgPSBlbGVtZW50cztcbiAgZmliZXIuZXhwaXJhdGlvblRpbWUgPSBleHBpcmF0aW9uVGltZTtcbiAgcmV0dXJuIGZpYmVyO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVGaWJlckZyb21UZXh0KGNvbnRlbnQsIGludGVybmFsQ29udGV4dFRhZywgZXhwaXJhdGlvblRpbWUpIHtcbiAgdmFyIGZpYmVyID0gY3JlYXRlRmliZXIoSG9zdFRleHQsIG51bGwsIGludGVybmFsQ29udGV4dFRhZyk7XG4gIGZpYmVyLnBlbmRpbmdQcm9wcyA9IGNvbnRlbnQ7XG4gIGZpYmVyLmV4cGlyYXRpb25UaW1lID0gZXhwaXJhdGlvblRpbWU7XG4gIHJldHVybiBmaWJlcjtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRmliZXJGcm9tSG9zdEluc3RhbmNlRm9yRGVsZXRpb24oKSB7XG4gIHZhciBmaWJlciA9IGNyZWF0ZUZpYmVyKEhvc3RDb21wb25lbnQsIG51bGwsIE5vQ29udGV4dCk7XG4gIGZpYmVyLnR5cGUgPSAnREVMRVRFRCc7XG4gIHJldHVybiBmaWJlcjtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRmliZXJGcm9tQ2FsbChjYWxsLCBpbnRlcm5hbENvbnRleHRUYWcsIGV4cGlyYXRpb25UaW1lKSB7XG4gIHZhciBmaWJlciA9IGNyZWF0ZUZpYmVyKENhbGxDb21wb25lbnQsIGNhbGwua2V5LCBpbnRlcm5hbENvbnRleHRUYWcpO1xuICBmaWJlci50eXBlID0gY2FsbC5oYW5kbGVyO1xuICBmaWJlci5wZW5kaW5nUHJvcHMgPSBjYWxsO1xuICBmaWJlci5leHBpcmF0aW9uVGltZSA9IGV4cGlyYXRpb25UaW1lO1xuICByZXR1cm4gZmliZXI7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUZpYmVyRnJvbVJldHVybihyZXR1cm5Ob2RlLCBpbnRlcm5hbENvbnRleHRUYWcsIGV4cGlyYXRpb25UaW1lKSB7XG4gIHZhciBmaWJlciA9IGNyZWF0ZUZpYmVyKFJldHVybkNvbXBvbmVudCwgbnVsbCwgaW50ZXJuYWxDb250ZXh0VGFnKTtcbiAgZmliZXIuZXhwaXJhdGlvblRpbWUgPSBleHBpcmF0aW9uVGltZTtcbiAgcmV0dXJuIGZpYmVyO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVGaWJlckZyb21Qb3J0YWwocG9ydGFsLCBpbnRlcm5hbENvbnRleHRUYWcsIGV4cGlyYXRpb25UaW1lKSB7XG4gIHZhciBmaWJlciA9IGNyZWF0ZUZpYmVyKEhvc3RQb3J0YWwsIHBvcnRhbC5rZXksIGludGVybmFsQ29udGV4dFRhZyk7XG4gIGZpYmVyLnBlbmRpbmdQcm9wcyA9IHBvcnRhbC5jaGlsZHJlbiB8fCBbXTtcbiAgZmliZXIuZXhwaXJhdGlvblRpbWUgPSBleHBpcmF0aW9uVGltZTtcbiAgZmliZXIuc3RhdGVOb2RlID0ge1xuICAgIGNvbnRhaW5lckluZm86IHBvcnRhbC5jb250YWluZXJJbmZvLFxuICAgIHBlbmRpbmdDaGlsZHJlbjogbnVsbCwgLy8gVXNlZCBieSBwZXJzaXN0ZW50IHVwZGF0ZXNcbiAgICBpbXBsZW1lbnRhdGlvbjogcG9ydGFsLmltcGxlbWVudGF0aW9uXG4gIH07XG4gIHJldHVybiBmaWJlcjtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRmliZXJSb290KGNvbnRhaW5lckluZm8sIGh5ZHJhdGUpIHtcbiAgLy8gQ3ljbGljIGNvbnN0cnVjdGlvbi4gVGhpcyBjaGVhdHMgdGhlIHR5cGUgc3lzdGVtIHJpZ2h0IG5vdyBiZWNhdXNlXG4gIC8vIHN0YXRlTm9kZSBpcyBhbnkuXG4gIHZhciB1bmluaXRpYWxpemVkRmliZXIgPSBjcmVhdGVIb3N0Um9vdEZpYmVyKCk7XG4gIHZhciByb290ID0ge1xuICAgIGN1cnJlbnQ6IHVuaW5pdGlhbGl6ZWRGaWJlcixcbiAgICBjb250YWluZXJJbmZvOiBjb250YWluZXJJbmZvLFxuICAgIHBlbmRpbmdDaGlsZHJlbjogbnVsbCxcbiAgICByZW1haW5pbmdFeHBpcmF0aW9uVGltZTogTm9Xb3JrLFxuICAgIGlzUmVhZHlGb3JDb21taXQ6IGZhbHNlLFxuICAgIGZpbmlzaGVkV29yazogbnVsbCxcbiAgICBjb250ZXh0OiBudWxsLFxuICAgIHBlbmRpbmdDb250ZXh0OiBudWxsLFxuICAgIGh5ZHJhdGU6IGh5ZHJhdGUsXG4gICAgbmV4dFNjaGVkdWxlZFJvb3Q6IG51bGxcbiAgfTtcbiAgdW5pbml0aWFsaXplZEZpYmVyLnN0YXRlTm9kZSA9IHJvb3Q7XG4gIHJldHVybiByb290O1xufVxuXG52YXIgb25Db21taXRGaWJlclJvb3QgPSBudWxsO1xudmFyIG9uQ29tbWl0RmliZXJVbm1vdW50ID0gbnVsbDtcbnZhciBoYXNMb2dnZWRFcnJvciA9IGZhbHNlO1xuXG5mdW5jdGlvbiBjYXRjaEVycm9ycyhmbikge1xuICByZXR1cm4gZnVuY3Rpb24gKGFyZykge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZm4oYXJnKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGlmICh0cnVlICYmICFoYXNMb2dnZWRFcnJvcikge1xuICAgICAgICBoYXNMb2dnZWRFcnJvciA9IHRydWU7XG4gICAgICAgIHdhcm5pbmcoZmFsc2UsICdSZWFjdCBEZXZUb29scyBlbmNvdW50ZXJlZCBhbiBlcnJvcjogJXMnLCBlcnIpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gaW5qZWN0SW50ZXJuYWxzKGludGVybmFscykge1xuICBpZiAodHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAvLyBObyBEZXZUb29sc1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgaG9vayA9IF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXztcbiAgaWYgKGhvb2suaXNEaXNhYmxlZCkge1xuICAgIC8vIFRoaXMgaXNuJ3QgYSByZWFsIHByb3BlcnR5IG9uIHRoZSBob29rLCBidXQgaXQgY2FuIGJlIHNldCB0byBvcHQgb3V0XG4gICAgLy8gb2YgRGV2VG9vbHMgaW50ZWdyYXRpb24gYW5kIGFzc29jaWF0ZWQgd2FybmluZ3MgYW5kIGxvZ3MuXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8zODc3XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKCFob29rLnN1cHBvcnRzRmliZXIpIHtcbiAgICB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnVGhlIGluc3RhbGxlZCB2ZXJzaW9uIG9mIFJlYWN0IERldlRvb2xzIGlzIHRvbyBvbGQgYW5kIHdpbGwgbm90IHdvcmsgJyArICd3aXRoIHRoZSBjdXJyZW50IHZlcnNpb24gb2YgUmVhY3QuIFBsZWFzZSB1cGRhdGUgUmVhY3QgRGV2VG9vbHMuICcgKyAnaHR0cHM6Ly9mYi5tZS9yZWFjdC1kZXZ0b29scycpO1xuICAgIH1cbiAgICAvLyBEZXZUb29scyBleGlzdHMsIGV2ZW4gdGhvdWdoIGl0IGRvZXNuJ3Qgc3VwcG9ydCBGaWJlci5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICB0cnkge1xuICAgIHZhciByZW5kZXJlcklEID0gaG9vay5pbmplY3QoaW50ZXJuYWxzKTtcbiAgICAvLyBXZSBoYXZlIHN1Y2Nlc3NmdWxseSBpbmplY3RlZCwgc28gbm93IGl0IGlzIHNhZmUgdG8gc2V0IHVwIGhvb2tzLlxuICAgIG9uQ29tbWl0RmliZXJSb290ID0gY2F0Y2hFcnJvcnMoZnVuY3Rpb24gKHJvb3QpIHtcbiAgICAgIHJldHVybiBob29rLm9uQ29tbWl0RmliZXJSb290KHJlbmRlcmVySUQsIHJvb3QpO1xuICAgIH0pO1xuICAgIG9uQ29tbWl0RmliZXJVbm1vdW50ID0gY2F0Y2hFcnJvcnMoZnVuY3Rpb24gKGZpYmVyKSB7XG4gICAgICByZXR1cm4gaG9vay5vbkNvbW1pdEZpYmVyVW5tb3VudChyZW5kZXJlcklELCBmaWJlcik7XG4gICAgfSk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIC8vIENhdGNoIGFsbCBlcnJvcnMgYmVjYXVzZSBpdCBpcyB1bnNhZmUgdG8gdGhyb3cgZHVyaW5nIGluaXRpYWxpemF0aW9uLlxuICAgIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICdSZWFjdCBEZXZUb29scyBlbmNvdW50ZXJlZCBhbiBlcnJvcjogJXMuJywgZXJyKTtcbiAgICB9XG4gIH1cbiAgLy8gRGV2VG9vbHMgZXhpc3RzXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBvbkNvbW1pdFJvb3Qocm9vdCkge1xuICBpZiAodHlwZW9mIG9uQ29tbWl0RmliZXJSb290ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgb25Db21taXRGaWJlclJvb3Qocm9vdCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gb25Db21taXRVbm1vdW50KGZpYmVyKSB7XG4gIGlmICh0eXBlb2Ygb25Db21taXRGaWJlclVubW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICBvbkNvbW1pdEZpYmVyVW5tb3VudChmaWJlcik7XG4gIH1cbn1cblxudmFyIFJlYWN0RXJyb3JVdGlscyA9IHtcbiAgLy8gVXNlZCBieSBGaWJlciB0byBzaW11bGF0ZSBhIHRyeS1jYXRjaC5cbiAgX2NhdWdodEVycm9yOiBudWxsLFxuICBfaGFzQ2F1Z2h0RXJyb3I6IGZhbHNlLFxuXG4gIC8vIFVzZWQgYnkgZXZlbnQgc3lzdGVtIHRvIGNhcHR1cmUvcmV0aHJvdyB0aGUgZmlyc3QgZXJyb3IuXG4gIF9yZXRocm93RXJyb3I6IG51bGwsXG4gIF9oYXNSZXRocm93RXJyb3I6IGZhbHNlLFxuXG4gIGluamVjdGlvbjoge1xuICAgIGluamVjdEVycm9yVXRpbHM6IGZ1bmN0aW9uIChpbmplY3RlZEVycm9yVXRpbHMpIHtcbiAgICAgICEodHlwZW9mIGluamVjdGVkRXJyb3JVdGlscy5pbnZva2VHdWFyZGVkQ2FsbGJhY2sgPT09ICdmdW5jdGlvbicpID8gaW52YXJpYW50KGZhbHNlLCAnSW5qZWN0ZWQgaW52b2tlR3VhcmRlZENhbGxiYWNrKCkgbXVzdCBiZSBhIGZ1bmN0aW9uLicpIDogdm9pZCAwO1xuICAgICAgaW52b2tlR3VhcmRlZENhbGxiYWNrJDEgPSBpbmplY3RlZEVycm9yVXRpbHMuaW52b2tlR3VhcmRlZENhbGxiYWNrO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQ2FsbCBhIGZ1bmN0aW9uIHdoaWxlIGd1YXJkaW5nIGFnYWluc3QgZXJyb3JzIHRoYXQgaGFwcGVucyB3aXRoaW4gaXQuXG4gICAqIFJldHVybnMgYW4gZXJyb3IgaWYgaXQgdGhyb3dzLCBvdGhlcndpc2UgbnVsbC5cbiAgICpcbiAgICogSW4gcHJvZHVjdGlvbiwgdGhpcyBpcyBpbXBsZW1lbnRlZCB1c2luZyBhIHRyeS1jYXRjaC4gVGhlIHJlYXNvbiB3ZSBkb24ndFxuICAgKiB1c2UgYSB0cnktY2F0Y2ggZGlyZWN0bHkgaXMgc28gdGhhdCB3ZSBjYW4gc3dhcCBvdXQgYSBkaWZmZXJlbnRcbiAgICogaW1wbGVtZW50YXRpb24gaW4gREVWIG1vZGUuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIG9mIHRoZSBndWFyZCB0byB1c2UgZm9yIGxvZ2dpbmcgb3IgZGVidWdnaW5nXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGludm9rZVxuICAgKiBAcGFyYW0geyp9IGNvbnRleHQgVGhlIGNvbnRleHQgdG8gdXNlIHdoZW4gY2FsbGluZyB0aGUgZnVuY3Rpb25cbiAgICogQHBhcmFtIHsuLi4qfSBhcmdzIEFyZ3VtZW50cyBmb3IgZnVuY3Rpb25cbiAgICovXG4gIGludm9rZUd1YXJkZWRDYWxsYmFjazogZnVuY3Rpb24gKG5hbWUsIGZ1bmMsIGNvbnRleHQsIGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgICBpbnZva2VHdWFyZGVkQ2FsbGJhY2skMS5hcHBseShSZWFjdEVycm9yVXRpbHMsIGFyZ3VtZW50cyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNhbWUgYXMgaW52b2tlR3VhcmRlZENhbGxiYWNrLCBidXQgaW5zdGVhZCBvZiByZXR1cm5pbmcgYW4gZXJyb3IsIGl0IHN0b3Jlc1xuICAgKiBpdCBpbiBhIGdsb2JhbCBzbyBpdCBjYW4gYmUgcmV0aHJvd24gYnkgYHJldGhyb3dDYXVnaHRFcnJvcmAgbGF0ZXIuXG4gICAqIFRPRE86IFNlZSBpZiBfY2F1Z2h0RXJyb3IgYW5kIF9yZXRocm93RXJyb3IgY2FuIGJlIHVuaWZpZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIG9mIHRoZSBndWFyZCB0byB1c2UgZm9yIGxvZ2dpbmcgb3IgZGVidWdnaW5nXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGludm9rZVxuICAgKiBAcGFyYW0geyp9IGNvbnRleHQgVGhlIGNvbnRleHQgdG8gdXNlIHdoZW4gY2FsbGluZyB0aGUgZnVuY3Rpb25cbiAgICogQHBhcmFtIHsuLi4qfSBhcmdzIEFyZ3VtZW50cyBmb3IgZnVuY3Rpb25cbiAgICovXG4gIGludm9rZUd1YXJkZWRDYWxsYmFja0FuZENhdGNoRmlyc3RFcnJvcjogZnVuY3Rpb24gKG5hbWUsIGZ1bmMsIGNvbnRleHQsIGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgICBSZWFjdEVycm9yVXRpbHMuaW52b2tlR3VhcmRlZENhbGxiYWNrLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgaWYgKFJlYWN0RXJyb3JVdGlscy5oYXNDYXVnaHRFcnJvcigpKSB7XG4gICAgICB2YXIgZXJyb3IgPSBSZWFjdEVycm9yVXRpbHMuY2xlYXJDYXVnaHRFcnJvcigpO1xuICAgICAgaWYgKCFSZWFjdEVycm9yVXRpbHMuX2hhc1JldGhyb3dFcnJvcikge1xuICAgICAgICBSZWFjdEVycm9yVXRpbHMuX2hhc1JldGhyb3dFcnJvciA9IHRydWU7XG4gICAgICAgIFJlYWN0RXJyb3JVdGlscy5fcmV0aHJvd0Vycm9yID0gZXJyb3I7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBEdXJpbmcgZXhlY3V0aW9uIG9mIGd1YXJkZWQgZnVuY3Rpb25zIHdlIHdpbGwgY2FwdHVyZSB0aGUgZmlyc3QgZXJyb3Igd2hpY2hcbiAgICogd2Ugd2lsbCByZXRocm93IHRvIGJlIGhhbmRsZWQgYnkgdGhlIHRvcCBsZXZlbCBlcnJvciBoYW5kbGVyLlxuICAgKi9cbiAgcmV0aHJvd0NhdWdodEVycm9yOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHJldGhyb3dDYXVnaHRFcnJvci5hcHBseShSZWFjdEVycm9yVXRpbHMsIGFyZ3VtZW50cyk7XG4gIH0sXG5cbiAgaGFzQ2F1Z2h0RXJyb3I6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gUmVhY3RFcnJvclV0aWxzLl9oYXNDYXVnaHRFcnJvcjtcbiAgfSxcblxuICBjbGVhckNhdWdodEVycm9yOiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKFJlYWN0RXJyb3JVdGlscy5faGFzQ2F1Z2h0RXJyb3IpIHtcbiAgICAgIHZhciBlcnJvciA9IFJlYWN0RXJyb3JVdGlscy5fY2F1Z2h0RXJyb3I7XG4gICAgICBSZWFjdEVycm9yVXRpbHMuX2NhdWdodEVycm9yID0gbnVsbDtcbiAgICAgIFJlYWN0RXJyb3JVdGlscy5faGFzQ2F1Z2h0RXJyb3IgPSBmYWxzZTtcbiAgICAgIHJldHVybiBlcnJvcjtcbiAgICB9IGVsc2Uge1xuICAgICAgaW52YXJpYW50KGZhbHNlLCAnY2xlYXJDYXVnaHRFcnJvciB3YXMgY2FsbGVkIGJ1dCBubyBlcnJvciB3YXMgY2FwdHVyZWQuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgfVxuICB9XG59O1xuXG52YXIgaW52b2tlR3VhcmRlZENhbGxiYWNrJDEgPSBmdW5jdGlvbiAobmFtZSwgZnVuYywgY29udGV4dCwgYSwgYiwgYywgZCwgZSwgZikge1xuICBSZWFjdEVycm9yVXRpbHMuX2hhc0NhdWdodEVycm9yID0gZmFsc2U7XG4gIFJlYWN0RXJyb3JVdGlscy5fY2F1Z2h0RXJyb3IgPSBudWxsO1xuICB2YXIgZnVuY0FyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDMpO1xuICB0cnkge1xuICAgIGZ1bmMuYXBwbHkoY29udGV4dCwgZnVuY0FyZ3MpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIFJlYWN0RXJyb3JVdGlscy5fY2F1Z2h0RXJyb3IgPSBlcnJvcjtcbiAgICBSZWFjdEVycm9yVXRpbHMuX2hhc0NhdWdodEVycm9yID0gdHJ1ZTtcbiAgfVxufTtcblxue1xuICAvLyBJbiBERVYgbW9kZSwgd2Ugc3dhcCBvdXQgaW52b2tlR3VhcmRlZENhbGxiYWNrIGZvciBhIHNwZWNpYWwgdmVyc2lvblxuICAvLyB0aGF0IHBsYXlzIG1vcmUgbmljZWx5IHdpdGggdGhlIGJyb3dzZXIncyBEZXZUb29scy4gVGhlIGlkZWEgaXMgdG8gcHJlc2VydmVcbiAgLy8gXCJQYXVzZSBvbiBleGNlcHRpb25zXCIgYmVoYXZpb3IuIEJlY2F1c2UgUmVhY3Qgd3JhcHMgYWxsIHVzZXItcHJvdmlkZWRcbiAgLy8gZnVuY3Rpb25zIGluIGludm9rZUd1YXJkZWRDYWxsYmFjaywgYW5kIHRoZSBwcm9kdWN0aW9uIHZlcnNpb24gb2ZcbiAgLy8gaW52b2tlR3VhcmRlZENhbGxiYWNrIHVzZXMgYSB0cnktY2F0Y2gsIGFsbCB1c2VyIGV4Y2VwdGlvbnMgYXJlIHRyZWF0ZWRcbiAgLy8gbGlrZSBjYXVnaHQgZXhjZXB0aW9ucywgYW5kIHRoZSBEZXZUb29scyB3b24ndCBwYXVzZSB1bmxlc3MgdGhlIGRldmVsb3BlclxuICAvLyB0YWtlcyB0aGUgZXh0cmEgc3RlcCBvZiBlbmFibGluZyBwYXVzZSBvbiBjYXVnaHQgZXhjZXB0aW9ucy4gVGhpcyBpc1xuICAvLyB1bnRpbnR1aXRpdmUsIHRob3VnaCwgYmVjYXVzZSBldmVuIHRob3VnaCBSZWFjdCBoYXMgY2F1Z2h0IHRoZSBlcnJvciwgZnJvbVxuICAvLyB0aGUgZGV2ZWxvcGVyJ3MgcGVyc3BlY3RpdmUsIHRoZSBlcnJvciBpcyB1bmNhdWdodC5cbiAgLy9cbiAgLy8gVG8gcHJlc2VydmUgdGhlIGV4cGVjdGVkIFwiUGF1c2Ugb24gZXhjZXB0aW9uc1wiIGJlaGF2aW9yLCB3ZSBkb24ndCB1c2UgYVxuICAvLyB0cnktY2F0Y2ggaW4gREVWLiBJbnN0ZWFkLCB3ZSBzeW5jaHJvbm91c2x5IGRpc3BhdGNoIGEgZmFrZSBldmVudCB0byBhIGZha2VcbiAgLy8gRE9NIG5vZGUsIGFuZCBjYWxsIHRoZSB1c2VyLXByb3ZpZGVkIGNhbGxiYWNrIGZyb20gaW5zaWRlIGFuIGV2ZW50IGhhbmRsZXJcbiAgLy8gZm9yIHRoYXQgZmFrZSBldmVudC4gSWYgdGhlIGNhbGxiYWNrIHRocm93cywgdGhlIGVycm9yIGlzIFwiY2FwdHVyZWRcIiB1c2luZ1xuICAvLyBhIGdsb2JhbCBldmVudCBoYW5kbGVyLiBCdXQgYmVjYXVzZSB0aGUgZXJyb3IgaGFwcGVucyBpbiBhIGRpZmZlcmVudFxuICAvLyBldmVudCBsb29wIGNvbnRleHQsIGl0IGRvZXMgbm90IGludGVycnVwdCB0aGUgbm9ybWFsIHByb2dyYW0gZmxvdy5cbiAgLy8gRWZmZWN0aXZlbHksIHRoaXMgZ2l2ZXMgdXMgdHJ5LWNhdGNoIGJlaGF2aW9yIHdpdGhvdXQgYWN0dWFsbHkgdXNpbmdcbiAgLy8gdHJ5LWNhdGNoLiBOZWF0IVxuXG4gIC8vIENoZWNrIHRoYXQgdGhlIGJyb3dzZXIgc3VwcG9ydHMgdGhlIEFQSXMgd2UgbmVlZCB0byBpbXBsZW1lbnQgb3VyIHNwZWNpYWxcbiAgLy8gREVWIHZlcnNpb24gb2YgaW52b2tlR3VhcmRlZENhbGxiYWNrXG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93LmRpc3BhdGNoRXZlbnQgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgZG9jdW1lbnQuY3JlYXRlRXZlbnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgZmFrZU5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdyZWFjdCcpO1xuXG4gICAgdmFyIGludm9rZUd1YXJkZWRDYWxsYmFja0RldiA9IGZ1bmN0aW9uIChuYW1lLCBmdW5jLCBjb250ZXh0LCBhLCBiLCBjLCBkLCBlLCBmKSB7XG4gICAgICAvLyBLZWVwcyB0cmFjayBvZiB3aGV0aGVyIHRoZSB1c2VyLXByb3ZpZGVkIGNhbGxiYWNrIHRocmV3IGFuIGVycm9yLiBXZVxuICAgICAgLy8gc2V0IHRoaXMgdG8gdHJ1ZSBhdCB0aGUgYmVnaW5uaW5nLCB0aGVuIHNldCBpdCB0byBmYWxzZSByaWdodCBhZnRlclxuICAgICAgLy8gY2FsbGluZyB0aGUgZnVuY3Rpb24uIElmIHRoZSBmdW5jdGlvbiBlcnJvcnMsIGBkaWRFcnJvcmAgd2lsbCBuZXZlciBiZVxuICAgICAgLy8gc2V0IHRvIGZhbHNlLiBUaGlzIHN0cmF0ZWd5IHdvcmtzIGV2ZW4gaWYgdGhlIGJyb3dzZXIgaXMgZmxha3kgYW5kXG4gICAgICAvLyBmYWlscyB0byBjYWxsIG91ciBnbG9iYWwgZXJyb3IgaGFuZGxlciwgYmVjYXVzZSBpdCBkb2Vzbid0IHJlbHkgb25cbiAgICAgIC8vIHRoZSBlcnJvciBldmVudCBhdCBhbGwuXG4gICAgICB2YXIgZGlkRXJyb3IgPSB0cnVlO1xuXG4gICAgICAvLyBDcmVhdGUgYW4gZXZlbnQgaGFuZGxlciBmb3Igb3VyIGZha2UgZXZlbnQuIFdlIHdpbGwgc3luY2hyb25vdXNseVxuICAgICAgLy8gZGlzcGF0Y2ggb3VyIGZha2UgZXZlbnQgdXNpbmcgYGRpc3BhdGNoRXZlbnRgLiBJbnNpZGUgdGhlIGhhbmRsZXIsIHdlXG4gICAgICAvLyBjYWxsIHRoZSB1c2VyLXByb3ZpZGVkIGNhbGxiYWNrLlxuICAgICAgdmFyIGZ1bmNBcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAzKTtcbiAgICAgIGZ1bmN0aW9uIGNhbGxDYWxsYmFjaygpIHtcbiAgICAgICAgLy8gV2UgaW1tZWRpYXRlbHkgcmVtb3ZlIHRoZSBjYWxsYmFjayBmcm9tIGV2ZW50IGxpc3RlbmVycyBzbyB0aGF0XG4gICAgICAgIC8vIG5lc3RlZCBgaW52b2tlR3VhcmRlZENhbGxiYWNrYCBjYWxscyBkbyBub3QgY2xhc2guIE90aGVyd2lzZSwgYVxuICAgICAgICAvLyBuZXN0ZWQgY2FsbCB3b3VsZCB0cmlnZ2VyIHRoZSBmYWtlIGV2ZW50IGhhbmRsZXJzIG9mIGFueSBjYWxsIGhpZ2hlclxuICAgICAgICAvLyBpbiB0aGUgc3RhY2suXG4gICAgICAgIGZha2VOb2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZ0VHlwZSwgY2FsbENhbGxiYWNrLCBmYWxzZSk7XG4gICAgICAgIGZ1bmMuYXBwbHkoY29udGV4dCwgZnVuY0FyZ3MpO1xuICAgICAgICBkaWRFcnJvciA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICAvLyBDcmVhdGUgYSBnbG9iYWwgZXJyb3IgZXZlbnQgaGFuZGxlci4gV2UgdXNlIHRoaXMgdG8gY2FwdHVyZSB0aGUgdmFsdWVcbiAgICAgIC8vIHRoYXQgd2FzIHRocm93bi4gSXQncyBwb3NzaWJsZSB0aGF0IHRoaXMgZXJyb3IgaGFuZGxlciB3aWxsIGZpcmUgbW9yZVxuICAgICAgLy8gdGhhbiBvbmNlOyBmb3IgZXhhbXBsZSwgaWYgbm9uLVJlYWN0IGNvZGUgYWxzbyBjYWxscyBgZGlzcGF0Y2hFdmVudGBcbiAgICAgIC8vIGFuZCBhIGhhbmRsZXIgZm9yIHRoYXQgZXZlbnQgdGhyb3dzLiBXZSBzaG91bGQgYmUgcmVzaWxpZW50IHRvIG1vc3Qgb2ZcbiAgICAgIC8vIHRob3NlIGNhc2VzLiBFdmVuIGlmIG91ciBlcnJvciBldmVudCBoYW5kbGVyIGZpcmVzIG1vcmUgdGhhbiBvbmNlLCB0aGVcbiAgICAgIC8vIGxhc3QgZXJyb3IgZXZlbnQgaXMgYWx3YXlzIHVzZWQuIElmIHRoZSBjYWxsYmFjayBhY3R1YWxseSBkb2VzIGVycm9yLFxuICAgICAgLy8gd2Uga25vdyB0aGF0IHRoZSBsYXN0IGVycm9yIGV2ZW50IGlzIHRoZSBjb3JyZWN0IG9uZSwgYmVjYXVzZSBpdCdzIG5vdFxuICAgICAgLy8gcG9zc2libGUgZm9yIGFueXRoaW5nIGVsc2UgdG8gaGF2ZSBoYXBwZW5lZCBpbiBiZXR3ZWVuIG91ciBjYWxsYmFja1xuICAgICAgLy8gZXJyb3JpbmcgYW5kIHRoZSBjb2RlIHRoYXQgZm9sbG93cyB0aGUgYGRpc3BhdGNoRXZlbnRgIGNhbGwgYmVsb3cuIElmXG4gICAgICAvLyB0aGUgY2FsbGJhY2sgZG9lc24ndCBlcnJvciwgYnV0IHRoZSBlcnJvciBldmVudCB3YXMgZmlyZWQsIHdlIGtub3cgdG9cbiAgICAgIC8vIGlnbm9yZSBpdCBiZWNhdXNlIGBkaWRFcnJvcmAgd2lsbCBiZSBmYWxzZSwgYXMgZGVzY3JpYmVkIGFib3ZlLlxuICAgICAgdmFyIGVycm9yID0gdm9pZCAwO1xuICAgICAgLy8gVXNlIHRoaXMgdG8gdHJhY2sgd2hldGhlciB0aGUgZXJyb3IgZXZlbnQgaXMgZXZlciBjYWxsZWQuXG4gICAgICB2YXIgZGlkU2V0RXJyb3IgPSBmYWxzZTtcbiAgICAgIHZhciBpc0Nyb3NzT3JpZ2luRXJyb3IgPSBmYWxzZTtcblxuICAgICAgZnVuY3Rpb24gb25FcnJvcihldmVudCkge1xuICAgICAgICBlcnJvciA9IGV2ZW50LmVycm9yO1xuICAgICAgICBkaWRTZXRFcnJvciA9IHRydWU7XG4gICAgICAgIGlmIChlcnJvciA9PT0gbnVsbCAmJiBldmVudC5jb2xubyA9PT0gMCAmJiBldmVudC5saW5lbm8gPT09IDApIHtcbiAgICAgICAgICBpc0Nyb3NzT3JpZ2luRXJyb3IgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIENyZWF0ZSBhIGZha2UgZXZlbnQgdHlwZS5cbiAgICAgIHZhciBldnRUeXBlID0gJ3JlYWN0LScgKyAobmFtZSA/IG5hbWUgOiAnaW52b2tlZ3VhcmRlZGNhbGxiYWNrJyk7XG5cbiAgICAgIC8vIEF0dGFjaCBvdXIgZXZlbnQgaGFuZGxlcnNcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIG9uRXJyb3IpO1xuICAgICAgZmFrZU5vZGUuYWRkRXZlbnRMaXN0ZW5lcihldnRUeXBlLCBjYWxsQ2FsbGJhY2ssIGZhbHNlKTtcblxuICAgICAgLy8gU3luY2hyb25vdXNseSBkaXNwYXRjaCBvdXIgZmFrZSBldmVudC4gSWYgdGhlIHVzZXItcHJvdmlkZWQgZnVuY3Rpb25cbiAgICAgIC8vIGVycm9ycywgaXQgd2lsbCB0cmlnZ2VyIG91ciBnbG9iYWwgZXJyb3IgaGFuZGxlci5cbiAgICAgIHZhciBldnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnQnKTtcbiAgICAgIGV2dC5pbml0RXZlbnQoZXZ0VHlwZSwgZmFsc2UsIGZhbHNlKTtcbiAgICAgIGZha2VOb2RlLmRpc3BhdGNoRXZlbnQoZXZ0KTtcblxuICAgICAgaWYgKGRpZEVycm9yKSB7XG4gICAgICAgIGlmICghZGlkU2V0RXJyb3IpIHtcbiAgICAgICAgICAvLyBUaGUgY2FsbGJhY2sgZXJyb3JlZCwgYnV0IHRoZSBlcnJvciBldmVudCBuZXZlciBmaXJlZC5cbiAgICAgICAgICBlcnJvciA9IG5ldyBFcnJvcignQW4gZXJyb3Igd2FzIHRocm93biBpbnNpZGUgb25lIG9mIHlvdXIgY29tcG9uZW50cywgYnV0IFJlYWN0ICcgKyBcImRvZXNuJ3Qga25vdyB3aGF0IGl0IHdhcy4gVGhpcyBpcyBsaWtlbHkgZHVlIHRvIGJyb3dzZXIgXCIgKyAnZmxha2luZXNzLiBSZWFjdCBkb2VzIGl0cyBiZXN0IHRvIHByZXNlcnZlIHRoZSBcIlBhdXNlIG9uICcgKyAnZXhjZXB0aW9uc1wiIGJlaGF2aW9yIG9mIHRoZSBEZXZUb29scywgd2hpY2ggcmVxdWlyZXMgc29tZSAnICsgXCJERVYtbW9kZSBvbmx5IHRyaWNrcy4gSXQncyBwb3NzaWJsZSB0aGF0IHRoZXNlIGRvbid0IHdvcmsgaW4gXCIgKyAneW91ciBicm93c2VyLiBUcnkgdHJpZ2dlcmluZyB0aGUgZXJyb3IgaW4gcHJvZHVjdGlvbiBtb2RlLCAnICsgJ29yIHN3aXRjaGluZyB0byBhIG1vZGVybiBicm93c2VyLiBJZiB5b3Ugc3VzcGVjdCB0aGF0IHRoaXMgaXMgJyArICdhY3R1YWxseSBhbiBpc3N1ZSB3aXRoIFJlYWN0LCBwbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0Nyb3NzT3JpZ2luRXJyb3IpIHtcbiAgICAgICAgICBlcnJvciA9IG5ldyBFcnJvcihcIkEgY3Jvc3Mtb3JpZ2luIGVycm9yIHdhcyB0aHJvd24uIFJlYWN0IGRvZXNuJ3QgaGF2ZSBhY2Nlc3MgdG8gXCIgKyAndGhlIGFjdHVhbCBlcnJvciBvYmplY3QgaW4gZGV2ZWxvcG1lbnQuICcgKyAnU2VlIGh0dHBzOi8vZmIubWUvcmVhY3QtY3Jvc3NvcmlnaW4tZXJyb3IgZm9yIG1vcmUgaW5mb3JtYXRpb24uJyk7XG4gICAgICAgIH1cbiAgICAgICAgUmVhY3RFcnJvclV0aWxzLl9oYXNDYXVnaHRFcnJvciA9IHRydWU7XG4gICAgICAgIFJlYWN0RXJyb3JVdGlscy5fY2F1Z2h0RXJyb3IgPSBlcnJvcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIFJlYWN0RXJyb3JVdGlscy5faGFzQ2F1Z2h0RXJyb3IgPSBmYWxzZTtcbiAgICAgICAgUmVhY3RFcnJvclV0aWxzLl9jYXVnaHRFcnJvciA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIC8vIFJlbW92ZSBvdXIgZXZlbnQgbGlzdGVuZXJzXG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignZXJyb3InLCBvbkVycm9yKTtcbiAgICB9O1xuXG4gICAgaW52b2tlR3VhcmRlZENhbGxiYWNrJDEgPSBpbnZva2VHdWFyZGVkQ2FsbGJhY2tEZXY7XG4gIH1cbn1cblxudmFyIHJldGhyb3dDYXVnaHRFcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKFJlYWN0RXJyb3JVdGlscy5faGFzUmV0aHJvd0Vycm9yKSB7XG4gICAgdmFyIGVycm9yID0gUmVhY3RFcnJvclV0aWxzLl9yZXRocm93RXJyb3I7XG4gICAgUmVhY3RFcnJvclV0aWxzLl9yZXRocm93RXJyb3IgPSBudWxsO1xuICAgIFJlYWN0RXJyb3JVdGlscy5faGFzUmV0aHJvd0Vycm9yID0gZmFsc2U7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn07XG5cbntcbiAgdmFyIGRpZFdhcm5VcGRhdGVJbnNpZGVVcGRhdGUgPSBmYWxzZTtcbn1cblxuLy8gQ2FsbGJhY2tzIGFyZSBub3QgdmFsaWRhdGVkIHVudGlsIGludm9jYXRpb25cblxuXG4vLyBTaW5nbHkgbGlua2VkLWxpc3Qgb2YgdXBkYXRlcy4gV2hlbiBhbiB1cGRhdGUgaXMgc2NoZWR1bGVkLCBpdCBpcyBhZGRlZCB0b1xuLy8gdGhlIHF1ZXVlIG9mIHRoZSBjdXJyZW50IGZpYmVyIGFuZCB0aGUgd29yay1pbi1wcm9ncmVzcyBmaWJlci4gVGhlIHR3byBxdWV1ZXNcbi8vIGFyZSBzZXBhcmF0ZSBidXQgdGhleSBzaGFyZSBhIHBlcnNpc3RlbnQgc3RydWN0dXJlLlxuLy9cbi8vIER1cmluZyByZWNvbmNpbGlhdGlvbiwgdXBkYXRlcyBhcmUgcmVtb3ZlZCBmcm9tIHRoZSB3b3JrLWluLXByb2dyZXNzIGZpYmVyLFxuLy8gYnV0IHRoZXkgcmVtYWluIG9uIHRoZSBjdXJyZW50IGZpYmVyLiBUaGF0IGVuc3VyZXMgdGhhdCBpZiBhIHdvcmstaW4tcHJvZ3Jlc3Ncbi8vIGlzIGFib3J0ZWQsIHRoZSBhYm9ydGVkIHVwZGF0ZXMgYXJlIHJlY292ZXJlZCBieSBjbG9uaW5nIGZyb20gY3VycmVudC5cbi8vXG4vLyBUaGUgd29yay1pbi1wcm9ncmVzcyBxdWV1ZSBpcyBhbHdheXMgYSBzdWJzZXQgb2YgdGhlIGN1cnJlbnQgcXVldWUuXG4vL1xuLy8gV2hlbiB0aGUgdHJlZSBpcyBjb21taXR0ZWQsIHRoZSB3b3JrLWluLXByb2dyZXNzIGJlY29tZXMgdGhlIGN1cnJlbnQuXG5cblxuZnVuY3Rpb24gY3JlYXRlVXBkYXRlUXVldWUoYmFzZVN0YXRlKSB7XG4gIHZhciBxdWV1ZSA9IHtcbiAgICBiYXNlU3RhdGU6IGJhc2VTdGF0ZSxcbiAgICBleHBpcmF0aW9uVGltZTogTm9Xb3JrLFxuICAgIGZpcnN0OiBudWxsLFxuICAgIGxhc3Q6IG51bGwsXG4gICAgY2FsbGJhY2tMaXN0OiBudWxsLFxuICAgIGhhc0ZvcmNlVXBkYXRlOiBmYWxzZSxcbiAgICBpc0luaXRpYWxpemVkOiBmYWxzZVxuICB9O1xuICB7XG4gICAgcXVldWUuaXNQcm9jZXNzaW5nID0gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHF1ZXVlO1xufVxuXG5mdW5jdGlvbiBpbnNlcnRVcGRhdGVJbnRvUXVldWUocXVldWUsIHVwZGF0ZSkge1xuICAvLyBBcHBlbmQgdGhlIHVwZGF0ZSB0byB0aGUgZW5kIG9mIHRoZSBsaXN0LlxuICBpZiAocXVldWUubGFzdCA9PT0gbnVsbCkge1xuICAgIC8vIFF1ZXVlIGlzIGVtcHR5XG4gICAgcXVldWUuZmlyc3QgPSBxdWV1ZS5sYXN0ID0gdXBkYXRlO1xuICB9IGVsc2Uge1xuICAgIHF1ZXVlLmxhc3QubmV4dCA9IHVwZGF0ZTtcbiAgICBxdWV1ZS5sYXN0ID0gdXBkYXRlO1xuICB9XG4gIGlmIChxdWV1ZS5leHBpcmF0aW9uVGltZSA9PT0gTm9Xb3JrIHx8IHF1ZXVlLmV4cGlyYXRpb25UaW1lID4gdXBkYXRlLmV4cGlyYXRpb25UaW1lKSB7XG4gICAgcXVldWUuZXhwaXJhdGlvblRpbWUgPSB1cGRhdGUuZXhwaXJhdGlvblRpbWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5zZXJ0VXBkYXRlSW50b0ZpYmVyKGZpYmVyLCB1cGRhdGUpIHtcbiAgLy8gV2UnbGwgaGF2ZSBhdCBsZWFzdCBvbmUgYW5kIGF0IG1vc3QgdHdvIGRpc3RpbmN0IHVwZGF0ZSBxdWV1ZXMuXG4gIHZhciBhbHRlcm5hdGVGaWJlciA9IGZpYmVyLmFsdGVybmF0ZTtcbiAgdmFyIHF1ZXVlMSA9IGZpYmVyLnVwZGF0ZVF1ZXVlO1xuICBpZiAocXVldWUxID09PSBudWxsKSB7XG4gICAgLy8gVE9ETzogV2UgZG9uJ3Qga25vdyB3aGF0IHRoZSBiYXNlIHN0YXRlIHdpbGwgYmUgdW50aWwgd2UgYmVnaW4gd29yay5cbiAgICAvLyBJdCBkZXBlbmRzIG9uIHdoaWNoIGZpYmVyIGlzIHRoZSBuZXh0IGN1cnJlbnQuIEluaXRpYWxpemUgd2l0aCBhbiBlbXB0eVxuICAgIC8vIGJhc2Ugc3RhdGUsIHRoZW4gc2V0IHRvIHRoZSBtZW1vaXplZFN0YXRlIHdoZW4gcmVuZGVyaW5nLiBOb3Qgc3VwZXJcbiAgICAvLyBoYXBweSB3aXRoIHRoaXMgYXBwcm9hY2guXG4gICAgcXVldWUxID0gZmliZXIudXBkYXRlUXVldWUgPSBjcmVhdGVVcGRhdGVRdWV1ZShudWxsKTtcbiAgfVxuXG4gIHZhciBxdWV1ZTIgPSB2b2lkIDA7XG4gIGlmIChhbHRlcm5hdGVGaWJlciAhPT0gbnVsbCkge1xuICAgIHF1ZXVlMiA9IGFsdGVybmF0ZUZpYmVyLnVwZGF0ZVF1ZXVlO1xuICAgIGlmIChxdWV1ZTIgPT09IG51bGwpIHtcbiAgICAgIHF1ZXVlMiA9IGFsdGVybmF0ZUZpYmVyLnVwZGF0ZVF1ZXVlID0gY3JlYXRlVXBkYXRlUXVldWUobnVsbCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHF1ZXVlMiA9IG51bGw7XG4gIH1cbiAgcXVldWUyID0gcXVldWUyICE9PSBxdWV1ZTEgPyBxdWV1ZTIgOiBudWxsO1xuXG4gIC8vIFdhcm4gaWYgYW4gdXBkYXRlIGlzIHNjaGVkdWxlZCBmcm9tIGluc2lkZSBhbiB1cGRhdGVyIGZ1bmN0aW9uLlxuICB7XG4gICAgaWYgKChxdWV1ZTEuaXNQcm9jZXNzaW5nIHx8IHF1ZXVlMiAhPT0gbnVsbCAmJiBxdWV1ZTIuaXNQcm9jZXNzaW5nKSAmJiAhZGlkV2FyblVwZGF0ZUluc2lkZVVwZGF0ZSkge1xuICAgICAgd2FybmluZyhmYWxzZSwgJ0FuIHVwZGF0ZSAoc2V0U3RhdGUsIHJlcGxhY2VTdGF0ZSwgb3IgZm9yY2VVcGRhdGUpIHdhcyBzY2hlZHVsZWQgJyArICdmcm9tIGluc2lkZSBhbiB1cGRhdGUgZnVuY3Rpb24uIFVwZGF0ZSBmdW5jdGlvbnMgc2hvdWxkIGJlIHB1cmUsICcgKyAnd2l0aCB6ZXJvIHNpZGUtZWZmZWN0cy4gQ29uc2lkZXIgdXNpbmcgY29tcG9uZW50RGlkVXBkYXRlIG9yIGEgJyArICdjYWxsYmFjay4nKTtcbiAgICAgIGRpZFdhcm5VcGRhdGVJbnNpZGVVcGRhdGUgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIC8vIElmIHRoZXJlJ3Mgb25seSBvbmUgcXVldWUsIGFkZCB0aGUgdXBkYXRlIHRvIHRoYXQgcXVldWUgYW5kIGV4aXQuXG4gIGlmIChxdWV1ZTIgPT09IG51bGwpIHtcbiAgICBpbnNlcnRVcGRhdGVJbnRvUXVldWUocXVldWUxLCB1cGRhdGUpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIElmIGVpdGhlciBxdWV1ZSBpcyBlbXB0eSwgd2UgbmVlZCB0byBhZGQgdG8gYm90aCBxdWV1ZXMuXG4gIGlmIChxdWV1ZTEubGFzdCA9PT0gbnVsbCB8fCBxdWV1ZTIubGFzdCA9PT0gbnVsbCkge1xuICAgIGluc2VydFVwZGF0ZUludG9RdWV1ZShxdWV1ZTEsIHVwZGF0ZSk7XG4gICAgaW5zZXJ0VXBkYXRlSW50b1F1ZXVlKHF1ZXVlMiwgdXBkYXRlKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBJZiBib3RoIGxpc3RzIGFyZSBub3QgZW1wdHksIHRoZSBsYXN0IHVwZGF0ZSBpcyB0aGUgc2FtZSBmb3IgYm90aCBsaXN0c1xuICAvLyBiZWNhdXNlIG9mIHN0cnVjdHVyYWwgc2hhcmluZy4gU28sIHdlIHNob3VsZCBvbmx5IGFwcGVuZCB0byBvbmUgb2ZcbiAgLy8gdGhlIGxpc3RzLlxuICBpbnNlcnRVcGRhdGVJbnRvUXVldWUocXVldWUxLCB1cGRhdGUpO1xuICAvLyBCdXQgd2Ugc3RpbGwgbmVlZCB0byB1cGRhdGUgdGhlIGBsYXN0YCBwb2ludGVyIG9mIHF1ZXVlMi5cbiAgcXVldWUyLmxhc3QgPSB1cGRhdGU7XG59XG5cbmZ1bmN0aW9uIGdldFVwZGF0ZUV4cGlyYXRpb25UaW1lKGZpYmVyKSB7XG4gIGlmIChmaWJlci50YWcgIT09IENsYXNzQ29tcG9uZW50ICYmIGZpYmVyLnRhZyAhPT0gSG9zdFJvb3QpIHtcbiAgICByZXR1cm4gTm9Xb3JrO1xuICB9XG4gIHZhciB1cGRhdGVRdWV1ZSA9IGZpYmVyLnVwZGF0ZVF1ZXVlO1xuICBpZiAodXBkYXRlUXVldWUgPT09IG51bGwpIHtcbiAgICByZXR1cm4gTm9Xb3JrO1xuICB9XG4gIHJldHVybiB1cGRhdGVRdWV1ZS5leHBpcmF0aW9uVGltZTtcbn1cblxuZnVuY3Rpb24gZ2V0U3RhdGVGcm9tVXBkYXRlKHVwZGF0ZSwgaW5zdGFuY2UsIHByZXZTdGF0ZSwgcHJvcHMpIHtcbiAgdmFyIHBhcnRpYWxTdGF0ZSA9IHVwZGF0ZS5wYXJ0aWFsU3RhdGU7XG4gIGlmICh0eXBlb2YgcGFydGlhbFN0YXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIHVwZGF0ZUZuID0gcGFydGlhbFN0YXRlO1xuXG4gICAgLy8gSW52b2tlIHNldFN0YXRlIGNhbGxiYWNrIGFuIGV4dHJhIHRpbWUgdG8gaGVscCBkZXRlY3Qgc2lkZS1lZmZlY3RzLlxuICAgIGlmIChkZWJ1Z1JlbmRlclBoYXNlU2lkZUVmZmVjdHMpIHtcbiAgICAgIHVwZGF0ZUZuLmNhbGwoaW5zdGFuY2UsIHByZXZTdGF0ZSwgcHJvcHMpO1xuICAgIH1cblxuICAgIHJldHVybiB1cGRhdGVGbi5jYWxsKGluc3RhbmNlLCBwcmV2U3RhdGUsIHByb3BzKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcGFydGlhbFN0YXRlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NVcGRhdGVRdWV1ZShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcXVldWUsIGluc3RhbmNlLCBwcm9wcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgaWYgKGN1cnJlbnQgIT09IG51bGwgJiYgY3VycmVudC51cGRhdGVRdWV1ZSA9PT0gcXVldWUpIHtcbiAgICAvLyBXZSBuZWVkIHRvIGNyZWF0ZSBhIHdvcmstaW4tcHJvZ3Jlc3MgcXVldWUsIGJ5IGNsb25pbmcgdGhlIGN1cnJlbnQgcXVldWUuXG4gICAgdmFyIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgIHF1ZXVlID0gd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgPSB7XG4gICAgICBiYXNlU3RhdGU6IGN1cnJlbnRRdWV1ZS5iYXNlU3RhdGUsXG4gICAgICBleHBpcmF0aW9uVGltZTogY3VycmVudFF1ZXVlLmV4cGlyYXRpb25UaW1lLFxuICAgICAgZmlyc3Q6IGN1cnJlbnRRdWV1ZS5maXJzdCxcbiAgICAgIGxhc3Q6IGN1cnJlbnRRdWV1ZS5sYXN0LFxuICAgICAgaXNJbml0aWFsaXplZDogY3VycmVudFF1ZXVlLmlzSW5pdGlhbGl6ZWQsXG4gICAgICAvLyBUaGVzZSBmaWVsZHMgYXJlIG5vIGxvbmdlciB2YWxpZCBiZWNhdXNlIHRoZXkgd2VyZSBhbHJlYWR5IGNvbW1pdHRlZC5cbiAgICAgIC8vIFJlc2V0IHRoZW0uXG4gICAgICBjYWxsYmFja0xpc3Q6IG51bGwsXG4gICAgICBoYXNGb3JjZVVwZGF0ZTogZmFsc2VcbiAgICB9O1xuICB9XG5cbiAge1xuICAgIC8vIFNldCB0aGlzIGZsYWcgc28gd2UgY2FuIHdhcm4gaWYgc2V0U3RhdGUgaXMgY2FsbGVkIGluc2lkZSB0aGUgdXBkYXRlXG4gICAgLy8gZnVuY3Rpb24gb2YgYW5vdGhlciBzZXRTdGF0ZS5cbiAgICBxdWV1ZS5pc1Byb2Nlc3NpbmcgPSB0cnVlO1xuICB9XG5cbiAgLy8gUmVzZXQgdGhlIHJlbWFpbmluZyBleHBpcmF0aW9uIHRpbWUuIElmIHdlIHNraXAgb3ZlciBhbnkgdXBkYXRlcywgd2UnbGxcbiAgLy8gaW5jcmVhc2UgdGhpcyBhY2NvcmRpbmdseS5cbiAgcXVldWUuZXhwaXJhdGlvblRpbWUgPSBOb1dvcms7XG5cbiAgLy8gVE9ETzogV2UgZG9uJ3Qga25vdyB3aGF0IHRoZSBiYXNlIHN0YXRlIHdpbGwgYmUgdW50aWwgd2UgYmVnaW4gd29yay5cbiAgLy8gSXQgZGVwZW5kcyBvbiB3aGljaCBmaWJlciBpcyB0aGUgbmV4dCBjdXJyZW50LiBJbml0aWFsaXplIHdpdGggYW4gZW1wdHlcbiAgLy8gYmFzZSBzdGF0ZSwgdGhlbiBzZXQgdG8gdGhlIG1lbW9pemVkU3RhdGUgd2hlbiByZW5kZXJpbmcuIE5vdCBzdXBlclxuICAvLyBoYXBweSB3aXRoIHRoaXMgYXBwcm9hY2guXG4gIHZhciBzdGF0ZSA9IHZvaWQgMDtcbiAgaWYgKHF1ZXVlLmlzSW5pdGlhbGl6ZWQpIHtcbiAgICBzdGF0ZSA9IHF1ZXVlLmJhc2VTdGF0ZTtcbiAgfSBlbHNlIHtcbiAgICBzdGF0ZSA9IHF1ZXVlLmJhc2VTdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gICAgcXVldWUuaXNJbml0aWFsaXplZCA9IHRydWU7XG4gIH1cbiAgdmFyIGRvbnRNdXRhdGVQcmV2U3RhdGUgPSB0cnVlO1xuICB2YXIgdXBkYXRlID0gcXVldWUuZmlyc3Q7XG4gIHZhciBkaWRTa2lwID0gZmFsc2U7XG4gIHdoaWxlICh1cGRhdGUgIT09IG51bGwpIHtcbiAgICB2YXIgdXBkYXRlRXhwaXJhdGlvblRpbWUgPSB1cGRhdGUuZXhwaXJhdGlvblRpbWU7XG4gICAgaWYgKHVwZGF0ZUV4cGlyYXRpb25UaW1lID4gcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgICAgIC8vIFRoaXMgdXBkYXRlIGRvZXMgbm90IGhhdmUgc3VmZmljaWVudCBwcmlvcml0eS4gU2tpcCBpdC5cbiAgICAgIHZhciByZW1haW5pbmdFeHBpcmF0aW9uVGltZSA9IHF1ZXVlLmV4cGlyYXRpb25UaW1lO1xuICAgICAgaWYgKHJlbWFpbmluZ0V4cGlyYXRpb25UaW1lID09PSBOb1dvcmsgfHwgcmVtYWluaW5nRXhwaXJhdGlvblRpbWUgPiB1cGRhdGVFeHBpcmF0aW9uVGltZSkge1xuICAgICAgICAvLyBVcGRhdGUgdGhlIHJlbWFpbmluZyBleHBpcmF0aW9uIHRpbWUuXG4gICAgICAgIHF1ZXVlLmV4cGlyYXRpb25UaW1lID0gdXBkYXRlRXhwaXJhdGlvblRpbWU7XG4gICAgICB9XG4gICAgICBpZiAoIWRpZFNraXApIHtcbiAgICAgICAgZGlkU2tpcCA9IHRydWU7XG4gICAgICAgIHF1ZXVlLmJhc2VTdGF0ZSA9IHN0YXRlO1xuICAgICAgfVxuICAgICAgLy8gQ29udGludWUgdG8gdGhlIG5leHQgdXBkYXRlLlxuICAgICAgdXBkYXRlID0gdXBkYXRlLm5leHQ7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBUaGlzIHVwZGF0ZSBkb2VzIGhhdmUgc3VmZmljaWVudCBwcmlvcml0eS5cblxuICAgIC8vIElmIG5vIHByZXZpb3VzIHVwZGF0ZXMgd2VyZSBza2lwcGVkLCBkcm9wIHRoaXMgdXBkYXRlIGZyb20gdGhlIHF1ZXVlIGJ5XG4gICAgLy8gYWR2YW5jaW5nIHRoZSBoZWFkIG9mIHRoZSBsaXN0LlxuICAgIGlmICghZGlkU2tpcCkge1xuICAgICAgcXVldWUuZmlyc3QgPSB1cGRhdGUubmV4dDtcbiAgICAgIGlmIChxdWV1ZS5maXJzdCA9PT0gbnVsbCkge1xuICAgICAgICBxdWV1ZS5sYXN0ID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBQcm9jZXNzIHRoZSB1cGRhdGVcbiAgICB2YXIgX3BhcnRpYWxTdGF0ZSA9IHZvaWQgMDtcbiAgICBpZiAodXBkYXRlLmlzUmVwbGFjZSkge1xuICAgICAgc3RhdGUgPSBnZXRTdGF0ZUZyb21VcGRhdGUodXBkYXRlLCBpbnN0YW5jZSwgc3RhdGUsIHByb3BzKTtcbiAgICAgIGRvbnRNdXRhdGVQcmV2U3RhdGUgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBfcGFydGlhbFN0YXRlID0gZ2V0U3RhdGVGcm9tVXBkYXRlKHVwZGF0ZSwgaW5zdGFuY2UsIHN0YXRlLCBwcm9wcyk7XG4gICAgICBpZiAoX3BhcnRpYWxTdGF0ZSkge1xuICAgICAgICBpZiAoZG9udE11dGF0ZVByZXZTdGF0ZSkge1xuICAgICAgICAgIC8vICRGbG93Rml4TWU6IElkayBob3cgdG8gdHlwZSB0aGlzIHByb3Blcmx5LlxuICAgICAgICAgIHN0YXRlID0gX2Fzc2lnbih7fSwgc3RhdGUsIF9wYXJ0aWFsU3RhdGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0YXRlID0gX2Fzc2lnbihzdGF0ZSwgX3BhcnRpYWxTdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZG9udE11dGF0ZVByZXZTdGF0ZSA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodXBkYXRlLmlzRm9yY2VkKSB7XG4gICAgICBxdWV1ZS5oYXNGb3JjZVVwZGF0ZSA9IHRydWU7XG4gICAgfVxuICAgIGlmICh1cGRhdGUuY2FsbGJhY2sgIT09IG51bGwpIHtcbiAgICAgIC8vIEFwcGVuZCB0byBsaXN0IG9mIGNhbGxiYWNrcy5cbiAgICAgIHZhciBfY2FsbGJhY2tMaXN0ID0gcXVldWUuY2FsbGJhY2tMaXN0O1xuICAgICAgaWYgKF9jYWxsYmFja0xpc3QgPT09IG51bGwpIHtcbiAgICAgICAgX2NhbGxiYWNrTGlzdCA9IHF1ZXVlLmNhbGxiYWNrTGlzdCA9IFtdO1xuICAgICAgfVxuICAgICAgX2NhbGxiYWNrTGlzdC5wdXNoKHVwZGF0ZSk7XG4gICAgfVxuICAgIHVwZGF0ZSA9IHVwZGF0ZS5uZXh0O1xuICB9XG5cbiAgaWYgKHF1ZXVlLmNhbGxiYWNrTGlzdCAhPT0gbnVsbCkge1xuICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBDYWxsYmFjaztcbiAgfSBlbHNlIGlmIChxdWV1ZS5maXJzdCA9PT0gbnVsbCAmJiAhcXVldWUuaGFzRm9yY2VVcGRhdGUpIHtcbiAgICAvLyBUaGUgcXVldWUgaXMgZW1wdHkuIFdlIGNhbiByZXNldCBpdC5cbiAgICB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSA9IG51bGw7XG4gIH1cblxuICBpZiAoIWRpZFNraXApIHtcbiAgICBkaWRTa2lwID0gdHJ1ZTtcbiAgICBxdWV1ZS5iYXNlU3RhdGUgPSBzdGF0ZTtcbiAgfVxuXG4gIHtcbiAgICAvLyBObyBsb25nZXIgcHJvY2Vzc2luZy5cbiAgICBxdWV1ZS5pc1Byb2Nlc3NpbmcgPSBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBzdGF0ZTtcbn1cblxuZnVuY3Rpb24gY29tbWl0Q2FsbGJhY2tzKHF1ZXVlLCBjb250ZXh0KSB7XG4gIHZhciBjYWxsYmFja0xpc3QgPSBxdWV1ZS5jYWxsYmFja0xpc3Q7XG4gIGlmIChjYWxsYmFja0xpc3QgPT09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgLy8gU2V0IHRoZSBsaXN0IHRvIG51bGwgdG8gbWFrZSBzdXJlIHRoZXkgZG9uJ3QgZ2V0IGNhbGxlZCBtb3JlIHRoYW4gb25jZS5cbiAgcXVldWUuY2FsbGJhY2tMaXN0ID0gbnVsbDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYWxsYmFja0xpc3QubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgdXBkYXRlID0gY2FsbGJhY2tMaXN0W2ldO1xuICAgIHZhciBfY2FsbGJhY2sgPSB1cGRhdGUuY2FsbGJhY2s7XG4gICAgLy8gVGhpcyB1cGRhdGUgbWlnaHQgYmUgcHJvY2Vzc2VkIGFnYWluLiBDbGVhciB0aGUgY2FsbGJhY2sgc28gaXQncyBvbmx5XG4gICAgLy8gY2FsbGVkIG9uY2UuXG4gICAgdXBkYXRlLmNhbGxiYWNrID0gbnVsbDtcbiAgICAhKHR5cGVvZiBfY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpID8gaW52YXJpYW50KGZhbHNlLCAnSW52YWxpZCBhcmd1bWVudCBwYXNzZWQgYXMgY2FsbGJhY2suIEV4cGVjdGVkIGEgZnVuY3Rpb24uIEluc3RlYWQgcmVjZWl2ZWQ6ICVzJywgX2NhbGxiYWNrKSA6IHZvaWQgMDtcbiAgICBfY2FsbGJhY2suY2FsbChjb250ZXh0KTtcbiAgfVxufVxuXG52YXIgZmFrZUludGVybmFsSW5zdGFuY2UgPSB7fTtcbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcblxue1xuICB2YXIgZGlkV2FybkFib3V0U3RhdGVBc3NpZ25tZW50Rm9yQ29tcG9uZW50ID0ge307XG5cbiAgdmFyIHdhcm5PbkludmFsaWRDYWxsYmFjayA9IGZ1bmN0aW9uIChjYWxsYmFjaywgY2FsbGVyTmFtZSkge1xuICAgIHdhcm5pbmcoY2FsbGJhY2sgPT09IG51bGwgfHwgdHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nLCAnJXMoLi4uKTogRXhwZWN0ZWQgdGhlIGxhc3Qgb3B0aW9uYWwgYGNhbGxiYWNrYCBhcmd1bWVudCB0byBiZSBhICcgKyAnZnVuY3Rpb24uIEluc3RlYWQgcmVjZWl2ZWQ6ICVzLicsIGNhbGxlck5hbWUsIGNhbGxiYWNrKTtcbiAgfTtcblxuICAvLyBUaGlzIGlzIHNvIGdyb3NzIGJ1dCBpdCdzIGF0IGxlYXN0IG5vbi1jcml0aWNhbCBhbmQgY2FuIGJlIHJlbW92ZWQgaWZcbiAgLy8gaXQgY2F1c2VzIHByb2JsZW1zLiBUaGlzIGlzIG1lYW50IHRvIGdpdmUgYSBuaWNlciBlcnJvciBtZXNzYWdlIGZvclxuICAvLyBSZWFjdERPTTE1LnVuc3RhYmxlX3JlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyKHJlYWN0RE9NMTZDb21wb25lbnQsXG4gIC8vIC4uLikpIHdoaWNoIG90aGVyd2lzZSB0aHJvd3MgYSBcIl9wcm9jZXNzQ2hpbGRDb250ZXh0IGlzIG5vdCBhIGZ1bmN0aW9uXCJcbiAgLy8gZXhjZXB0aW9uLlxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZmFrZUludGVybmFsSW5zdGFuY2UsICdfcHJvY2Vzc0NoaWxkQ29udGV4dCcsIHtcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgaW52YXJpYW50KGZhbHNlLCAnX3Byb2Nlc3NDaGlsZENvbnRleHQgaXMgbm90IGF2YWlsYWJsZSBpbiBSZWFjdCAxNisuIFRoaXMgbGlrZWx5IG1lYW5zIHlvdSBoYXZlIG11bHRpcGxlIGNvcGllcyBvZiBSZWFjdCBhbmQgYXJlIGF0dGVtcHRpbmcgdG8gbmVzdCBhIFJlYWN0IDE1IHRyZWUgaW5zaWRlIGEgUmVhY3QgMTYgdHJlZSB1c2luZyB1bnN0YWJsZV9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lciwgd2hpY2ggaXNuXFwndCBzdXBwb3J0ZWQuIFRyeSB0byBtYWtlIHN1cmUgeW91IGhhdmUgb25seSBvbmUgY29weSBvZiBSZWFjdCAoYW5kIGlkZWFsbHksIHN3aXRjaCB0byBSZWFjdERPTS5jcmVhdGVQb3J0YWwpLicpO1xuICAgIH1cbiAgfSk7XG4gIE9iamVjdC5mcmVlemUoZmFrZUludGVybmFsSW5zdGFuY2UpO1xufVxuXG52YXIgUmVhY3RGaWJlckNsYXNzQ29tcG9uZW50ID0gZnVuY3Rpb24gKHNjaGVkdWxlV29yaywgY29tcHV0ZUV4cGlyYXRpb25Gb3JGaWJlciwgbWVtb2l6ZVByb3BzLCBtZW1vaXplU3RhdGUpIHtcbiAgLy8gQ2xhc3MgY29tcG9uZW50IHN0YXRlIHVwZGF0ZXJcbiAgdmFyIHVwZGF0ZXIgPSB7XG4gICAgaXNNb3VudGVkOiBpc01vdW50ZWQsXG4gICAgZW5xdWV1ZVNldFN0YXRlOiBmdW5jdGlvbiAoaW5zdGFuY2UsIHBhcnRpYWxTdGF0ZSwgY2FsbGJhY2spIHtcbiAgICAgIHZhciBmaWJlciA9IGdldChpbnN0YW5jZSk7XG4gICAgICBjYWxsYmFjayA9IGNhbGxiYWNrID09PSB1bmRlZmluZWQgPyBudWxsIDogY2FsbGJhY2s7XG4gICAgICB7XG4gICAgICAgIHdhcm5PbkludmFsaWRDYWxsYmFjayhjYWxsYmFjaywgJ3NldFN0YXRlJyk7XG4gICAgICB9XG4gICAgICB2YXIgZXhwaXJhdGlvblRpbWUgPSBjb21wdXRlRXhwaXJhdGlvbkZvckZpYmVyKGZpYmVyKTtcbiAgICAgIHZhciB1cGRhdGUgPSB7XG4gICAgICAgIGV4cGlyYXRpb25UaW1lOiBleHBpcmF0aW9uVGltZSxcbiAgICAgICAgcGFydGlhbFN0YXRlOiBwYXJ0aWFsU3RhdGUsXG4gICAgICAgIGNhbGxiYWNrOiBjYWxsYmFjayxcbiAgICAgICAgaXNSZXBsYWNlOiBmYWxzZSxcbiAgICAgICAgaXNGb3JjZWQ6IGZhbHNlLFxuICAgICAgICBuZXh0Q2FsbGJhY2s6IG51bGwsXG4gICAgICAgIG5leHQ6IG51bGxcbiAgICAgIH07XG4gICAgICBpbnNlcnRVcGRhdGVJbnRvRmliZXIoZmliZXIsIHVwZGF0ZSk7XG4gICAgICBzY2hlZHVsZVdvcmsoZmliZXIsIGV4cGlyYXRpb25UaW1lKTtcbiAgICB9LFxuICAgIGVucXVldWVSZXBsYWNlU3RhdGU6IGZ1bmN0aW9uIChpbnN0YW5jZSwgc3RhdGUsIGNhbGxiYWNrKSB7XG4gICAgICB2YXIgZmliZXIgPSBnZXQoaW5zdGFuY2UpO1xuICAgICAgY2FsbGJhY2sgPSBjYWxsYmFjayA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGNhbGxiYWNrO1xuICAgICAge1xuICAgICAgICB3YXJuT25JbnZhbGlkQ2FsbGJhY2soY2FsbGJhY2ssICdyZXBsYWNlU3RhdGUnKTtcbiAgICAgIH1cbiAgICAgIHZhciBleHBpcmF0aW9uVGltZSA9IGNvbXB1dGVFeHBpcmF0aW9uRm9yRmliZXIoZmliZXIpO1xuICAgICAgdmFyIHVwZGF0ZSA9IHtcbiAgICAgICAgZXhwaXJhdGlvblRpbWU6IGV4cGlyYXRpb25UaW1lLFxuICAgICAgICBwYXJ0aWFsU3RhdGU6IHN0YXRlLFxuICAgICAgICBjYWxsYmFjazogY2FsbGJhY2ssXG4gICAgICAgIGlzUmVwbGFjZTogdHJ1ZSxcbiAgICAgICAgaXNGb3JjZWQ6IGZhbHNlLFxuICAgICAgICBuZXh0Q2FsbGJhY2s6IG51bGwsXG4gICAgICAgIG5leHQ6IG51bGxcbiAgICAgIH07XG4gICAgICBpbnNlcnRVcGRhdGVJbnRvRmliZXIoZmliZXIsIHVwZGF0ZSk7XG4gICAgICBzY2hlZHVsZVdvcmsoZmliZXIsIGV4cGlyYXRpb25UaW1lKTtcbiAgICB9LFxuICAgIGVucXVldWVGb3JjZVVwZGF0ZTogZnVuY3Rpb24gKGluc3RhbmNlLCBjYWxsYmFjaykge1xuICAgICAgdmFyIGZpYmVyID0gZ2V0KGluc3RhbmNlKTtcbiAgICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBjYWxsYmFjaztcbiAgICAgIHtcbiAgICAgICAgd2Fybk9uSW52YWxpZENhbGxiYWNrKGNhbGxiYWNrLCAnZm9yY2VVcGRhdGUnKTtcbiAgICAgIH1cbiAgICAgIHZhciBleHBpcmF0aW9uVGltZSA9IGNvbXB1dGVFeHBpcmF0aW9uRm9yRmliZXIoZmliZXIpO1xuICAgICAgdmFyIHVwZGF0ZSA9IHtcbiAgICAgICAgZXhwaXJhdGlvblRpbWU6IGV4cGlyYXRpb25UaW1lLFxuICAgICAgICBwYXJ0aWFsU3RhdGU6IG51bGwsXG4gICAgICAgIGNhbGxiYWNrOiBjYWxsYmFjayxcbiAgICAgICAgaXNSZXBsYWNlOiBmYWxzZSxcbiAgICAgICAgaXNGb3JjZWQ6IHRydWUsXG4gICAgICAgIG5leHRDYWxsYmFjazogbnVsbCxcbiAgICAgICAgbmV4dDogbnVsbFxuICAgICAgfTtcbiAgICAgIGluc2VydFVwZGF0ZUludG9GaWJlcihmaWJlciwgdXBkYXRlKTtcbiAgICAgIHNjaGVkdWxlV29yayhmaWJlciwgZXhwaXJhdGlvblRpbWUpO1xuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBjaGVja1Nob3VsZENvbXBvbmVudFVwZGF0ZSh3b3JrSW5Qcm9ncmVzcywgb2xkUHJvcHMsIG5ld1Byb3BzLCBvbGRTdGF0ZSwgbmV3U3RhdGUsIG5ld0NvbnRleHQpIHtcbiAgICBpZiAob2xkUHJvcHMgPT09IG51bGwgfHwgd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgIT09IG51bGwgJiYgd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUuaGFzRm9yY2VVcGRhdGUpIHtcbiAgICAgIC8vIElmIHRoZSB3b3JrSW5Qcm9ncmVzcyBhbHJlYWR5IGhhcyBhbiBVcGRhdGUgZWZmZWN0LCByZXR1cm4gdHJ1ZVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgdmFyIGluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAgIHZhciB0eXBlID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLnNob3VsZENvbXBvbmVudFVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgc3RhcnRQaGFzZVRpbWVyKHdvcmtJblByb2dyZXNzLCAnc2hvdWxkQ29tcG9uZW50VXBkYXRlJyk7XG4gICAgICB2YXIgc2hvdWxkVXBkYXRlID0gaW5zdGFuY2Uuc2hvdWxkQ29tcG9uZW50VXBkYXRlKG5ld1Byb3BzLCBuZXdTdGF0ZSwgbmV3Q29udGV4dCk7XG4gICAgICBzdG9wUGhhc2VUaW1lcigpO1xuXG4gICAgICAvLyBTaW11bGF0ZSBhbiBhc3luYyBiYWlsb3V0L2ludGVycnVwdGlvbiBieSBpbnZva2luZyBsaWZlY3ljbGUgdHdpY2UuXG4gICAgICBpZiAoZGVidWdSZW5kZXJQaGFzZVNpZGVFZmZlY3RzKSB7XG4gICAgICAgIGluc3RhbmNlLnNob3VsZENvbXBvbmVudFVwZGF0ZShuZXdQcm9wcywgbmV3U3RhdGUsIG5ld0NvbnRleHQpO1xuICAgICAgfVxuXG4gICAgICB7XG4gICAgICAgIHdhcm5pbmcoc2hvdWxkVXBkYXRlICE9PSB1bmRlZmluZWQsICclcy5zaG91bGRDb21wb25lbnRVcGRhdGUoKTogUmV0dXJuZWQgdW5kZWZpbmVkIGluc3RlYWQgb2YgYSAnICsgJ2Jvb2xlYW4gdmFsdWUuIE1ha2Ugc3VyZSB0byByZXR1cm4gdHJ1ZSBvciBmYWxzZS4nLCBnZXRDb21wb25lbnROYW1lKHdvcmtJblByb2dyZXNzKSB8fCAnVW5rbm93bicpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2hvdWxkVXBkYXRlO1xuICAgIH1cblxuICAgIGlmICh0eXBlLnByb3RvdHlwZSAmJiB0eXBlLnByb3RvdHlwZS5pc1B1cmVSZWFjdENvbXBvbmVudCkge1xuICAgICAgcmV0dXJuICFzaGFsbG93RXF1YWwob2xkUHJvcHMsIG5ld1Byb3BzKSB8fCAhc2hhbGxvd0VxdWFsKG9sZFN0YXRlLCBuZXdTdGF0ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBmdW5jdGlvbiBjaGVja0NsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MpIHtcbiAgICB2YXIgaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICAgdmFyIHR5cGUgPSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuICAgIHtcbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICB2YXIgcmVuZGVyUHJlc2VudCA9IGluc3RhbmNlLnJlbmRlcjtcblxuICAgICAgaWYgKCFyZW5kZXJQcmVzZW50KSB7XG4gICAgICAgIGlmICh0eXBlLnByb3RvdHlwZSAmJiB0eXBlb2YgdHlwZS5wcm90b3R5cGUucmVuZGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgd2FybmluZyhmYWxzZSwgJyVzKC4uLik6IE5vIGByZW5kZXJgIG1ldGhvZCBmb3VuZCBvbiB0aGUgcmV0dXJuZWQgY29tcG9uZW50ICcgKyAnaW5zdGFuY2U6IGRpZCB5b3UgYWNjaWRlbnRhbGx5IHJldHVybiBhbiBvYmplY3QgZnJvbSB0aGUgY29uc3RydWN0b3I/JywgbmFtZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgd2FybmluZyhmYWxzZSwgJyVzKC4uLik6IE5vIGByZW5kZXJgIG1ldGhvZCBmb3VuZCBvbiB0aGUgcmV0dXJuZWQgY29tcG9uZW50ICcgKyAnaW5zdGFuY2U6IHlvdSBtYXkgaGF2ZSBmb3Jnb3R0ZW4gdG8gZGVmaW5lIGByZW5kZXJgLicsIG5hbWUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBub0dldEluaXRpYWxTdGF0ZU9uRVM2ID0gIWluc3RhbmNlLmdldEluaXRpYWxTdGF0ZSB8fCBpbnN0YW5jZS5nZXRJbml0aWFsU3RhdGUuaXNSZWFjdENsYXNzQXBwcm92ZWQgfHwgaW5zdGFuY2Uuc3RhdGU7XG4gICAgICB3YXJuaW5nKG5vR2V0SW5pdGlhbFN0YXRlT25FUzYsICdnZXRJbml0aWFsU3RhdGUgd2FzIGRlZmluZWQgb24gJXMsIGEgcGxhaW4gSmF2YVNjcmlwdCBjbGFzcy4gJyArICdUaGlzIGlzIG9ubHkgc3VwcG9ydGVkIGZvciBjbGFzc2VzIGNyZWF0ZWQgdXNpbmcgUmVhY3QuY3JlYXRlQ2xhc3MuICcgKyAnRGlkIHlvdSBtZWFuIHRvIGRlZmluZSBhIHN0YXRlIHByb3BlcnR5IGluc3RlYWQ/JywgbmFtZSk7XG4gICAgICB2YXIgbm9HZXREZWZhdWx0UHJvcHNPbkVTNiA9ICFpbnN0YW5jZS5nZXREZWZhdWx0UHJvcHMgfHwgaW5zdGFuY2UuZ2V0RGVmYXVsdFByb3BzLmlzUmVhY3RDbGFzc0FwcHJvdmVkO1xuICAgICAgd2FybmluZyhub0dldERlZmF1bHRQcm9wc09uRVM2LCAnZ2V0RGVmYXVsdFByb3BzIHdhcyBkZWZpbmVkIG9uICVzLCBhIHBsYWluIEphdmFTY3JpcHQgY2xhc3MuICcgKyAnVGhpcyBpcyBvbmx5IHN1cHBvcnRlZCBmb3IgY2xhc3NlcyBjcmVhdGVkIHVzaW5nIFJlYWN0LmNyZWF0ZUNsYXNzLiAnICsgJ1VzZSBhIHN0YXRpYyBwcm9wZXJ0eSB0byBkZWZpbmUgZGVmYXVsdFByb3BzIGluc3RlYWQuJywgbmFtZSk7XG4gICAgICB2YXIgbm9JbnN0YW5jZVByb3BUeXBlcyA9ICFpbnN0YW5jZS5wcm9wVHlwZXM7XG4gICAgICB3YXJuaW5nKG5vSW5zdGFuY2VQcm9wVHlwZXMsICdwcm9wVHlwZXMgd2FzIGRlZmluZWQgYXMgYW4gaW5zdGFuY2UgcHJvcGVydHkgb24gJXMuIFVzZSBhIHN0YXRpYyAnICsgJ3Byb3BlcnR5IHRvIGRlZmluZSBwcm9wVHlwZXMgaW5zdGVhZC4nLCBuYW1lKTtcbiAgICAgIHZhciBub0luc3RhbmNlQ29udGV4dFR5cGVzID0gIWluc3RhbmNlLmNvbnRleHRUeXBlcztcbiAgICAgIHdhcm5pbmcobm9JbnN0YW5jZUNvbnRleHRUeXBlcywgJ2NvbnRleHRUeXBlcyB3YXMgZGVmaW5lZCBhcyBhbiBpbnN0YW5jZSBwcm9wZXJ0eSBvbiAlcy4gVXNlIGEgc3RhdGljICcgKyAncHJvcGVydHkgdG8gZGVmaW5lIGNvbnRleHRUeXBlcyBpbnN0ZWFkLicsIG5hbWUpO1xuICAgICAgdmFyIG5vQ29tcG9uZW50U2hvdWxkVXBkYXRlID0gdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFNob3VsZFVwZGF0ZSAhPT0gJ2Z1bmN0aW9uJztcbiAgICAgIHdhcm5pbmcobm9Db21wb25lbnRTaG91bGRVcGRhdGUsICclcyBoYXMgYSBtZXRob2QgY2FsbGVkICcgKyAnY29tcG9uZW50U2hvdWxkVXBkYXRlKCkuIERpZCB5b3UgbWVhbiBzaG91bGRDb21wb25lbnRVcGRhdGUoKT8gJyArICdUaGUgbmFtZSBpcyBwaHJhc2VkIGFzIGEgcXVlc3Rpb24gYmVjYXVzZSB0aGUgZnVuY3Rpb24gaXMgJyArICdleHBlY3RlZCB0byByZXR1cm4gYSB2YWx1ZS4nLCBuYW1lKTtcbiAgICAgIGlmICh0eXBlLnByb3RvdHlwZSAmJiB0eXBlLnByb3RvdHlwZS5pc1B1cmVSZWFjdENvbXBvbmVudCAmJiB0eXBlb2YgaW5zdGFuY2Uuc2hvdWxkQ29tcG9uZW50VXBkYXRlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICB3YXJuaW5nKGZhbHNlLCAnJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCBzaG91bGRDb21wb25lbnRVcGRhdGUoKS4gJyArICdzaG91bGRDb21wb25lbnRVcGRhdGUgc2hvdWxkIG5vdCBiZSB1c2VkIHdoZW4gZXh0ZW5kaW5nIFJlYWN0LlB1cmVDb21wb25lbnQuICcgKyAnUGxlYXNlIGV4dGVuZCBSZWFjdC5Db21wb25lbnQgaWYgc2hvdWxkQ29tcG9uZW50VXBkYXRlIGlzIHVzZWQuJywgZ2V0Q29tcG9uZW50TmFtZSh3b3JrSW5Qcm9ncmVzcykgfHwgJ0EgcHVyZSBjb21wb25lbnQnKTtcbiAgICAgIH1cbiAgICAgIHZhciBub0NvbXBvbmVudERpZFVubW91bnQgPSB0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkVW5tb3VudCAhPT0gJ2Z1bmN0aW9uJztcbiAgICAgIHdhcm5pbmcobm9Db21wb25lbnREaWRVbm1vdW50LCAnJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCAnICsgJ2NvbXBvbmVudERpZFVubW91bnQoKS4gQnV0IHRoZXJlIGlzIG5vIHN1Y2ggbGlmZWN5Y2xlIG1ldGhvZC4gJyArICdEaWQgeW91IG1lYW4gY29tcG9uZW50V2lsbFVubW91bnQoKT8nLCBuYW1lKTtcbiAgICAgIHZhciBub0NvbXBvbmVudERpZFJlY2VpdmVQcm9wcyA9IHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRSZWNlaXZlUHJvcHMgIT09ICdmdW5jdGlvbic7XG4gICAgICB3YXJuaW5nKG5vQ29tcG9uZW50RGlkUmVjZWl2ZVByb3BzLCAnJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCAnICsgJ2NvbXBvbmVudERpZFJlY2VpdmVQcm9wcygpLiBCdXQgdGhlcmUgaXMgbm8gc3VjaCBsaWZlY3ljbGUgbWV0aG9kLiAnICsgJ0lmIHlvdSBtZWFudCB0byB1cGRhdGUgdGhlIHN0YXRlIGluIHJlc3BvbnNlIHRvIGNoYW5naW5nIHByb3BzLCAnICsgJ3VzZSBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKCkuIElmIHlvdSBtZWFudCB0byBmZXRjaCBkYXRhIG9yICcgKyAncnVuIHNpZGUtZWZmZWN0cyBvciBtdXRhdGlvbnMgYWZ0ZXIgUmVhY3QgaGFzIHVwZGF0ZWQgdGhlIFVJLCB1c2UgY29tcG9uZW50RGlkVXBkYXRlKCkuJywgbmFtZSk7XG4gICAgICB2YXIgbm9Db21wb25lbnRXaWxsUmVjaWV2ZVByb3BzID0gdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMgIT09ICdmdW5jdGlvbic7XG4gICAgICB3YXJuaW5nKG5vQ29tcG9uZW50V2lsbFJlY2lldmVQcm9wcywgJyVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgJyArICdjb21wb25lbnRXaWxsUmVjaWV2ZVByb3BzKCkuIERpZCB5b3UgbWVhbiBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKCk/JywgbmFtZSk7XG4gICAgICB2YXIgaGFzTXV0YXRlZFByb3BzID0gaW5zdGFuY2UucHJvcHMgIT09IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcbiAgICAgIHdhcm5pbmcoaW5zdGFuY2UucHJvcHMgPT09IHVuZGVmaW5lZCB8fCAhaGFzTXV0YXRlZFByb3BzLCAnJXMoLi4uKTogV2hlbiBjYWxsaW5nIHN1cGVyKCkgaW4gYCVzYCwgbWFrZSBzdXJlIHRvIHBhc3MgJyArIFwidXAgdGhlIHNhbWUgcHJvcHMgdGhhdCB5b3VyIGNvbXBvbmVudCdzIGNvbnN0cnVjdG9yIHdhcyBwYXNzZWQuXCIsIG5hbWUsIG5hbWUpO1xuICAgICAgdmFyIG5vSW5zdGFuY2VEZWZhdWx0UHJvcHMgPSAhaW5zdGFuY2UuZGVmYXVsdFByb3BzO1xuICAgICAgd2FybmluZyhub0luc3RhbmNlRGVmYXVsdFByb3BzLCAnU2V0dGluZyBkZWZhdWx0UHJvcHMgYXMgYW4gaW5zdGFuY2UgcHJvcGVydHkgb24gJXMgaXMgbm90IHN1cHBvcnRlZCBhbmQgd2lsbCBiZSBpZ25vcmVkLicgKyAnIEluc3RlYWQsIGRlZmluZSBkZWZhdWx0UHJvcHMgYXMgYSBzdGF0aWMgcHJvcGVydHkgb24gJXMuJywgbmFtZSwgbmFtZSk7XG4gICAgfVxuXG4gICAgdmFyIHN0YXRlID0gaW5zdGFuY2Uuc3RhdGU7XG4gICAgaWYgKHN0YXRlICYmICh0eXBlb2Ygc3RhdGUgIT09ICdvYmplY3QnIHx8IGlzQXJyYXkoc3RhdGUpKSkge1xuICAgICAgd2FybmluZyhmYWxzZSwgJyVzLnN0YXRlOiBtdXN0IGJlIHNldCB0byBhbiBvYmplY3Qgb3IgbnVsbCcsIGdldENvbXBvbmVudE5hbWUod29ya0luUHJvZ3Jlc3MpKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5nZXRDaGlsZENvbnRleHQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHdhcm5pbmcodHlwZW9mIHdvcmtJblByb2dyZXNzLnR5cGUuY2hpbGRDb250ZXh0VHlwZXMgPT09ICdvYmplY3QnLCAnJXMuZ2V0Q2hpbGRDb250ZXh0KCk6IGNoaWxkQ29udGV4dFR5cGVzIG11c3QgYmUgZGVmaW5lZCBpbiBvcmRlciB0byAnICsgJ3VzZSBnZXRDaGlsZENvbnRleHQoKS4nLCBnZXRDb21wb25lbnROYW1lKHdvcmtJblByb2dyZXNzKSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVzZXRJbnB1dFBvaW50ZXJzKHdvcmtJblByb2dyZXNzLCBpbnN0YW5jZSkge1xuICAgIGluc3RhbmNlLnByb3BzID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcztcbiAgICBpbnN0YW5jZS5zdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gIH1cblxuICBmdW5jdGlvbiBhZG9wdENsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIGluc3RhbmNlKSB7XG4gICAgaW5zdGFuY2UudXBkYXRlciA9IHVwZGF0ZXI7XG4gICAgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gaW5zdGFuY2U7XG4gICAgLy8gVGhlIGluc3RhbmNlIG5lZWRzIGFjY2VzcyB0byB0aGUgZmliZXIgc28gdGhhdCBpdCBjYW4gc2NoZWR1bGUgdXBkYXRlc1xuICAgIHNldChpbnN0YW5jZSwgd29ya0luUHJvZ3Jlc3MpO1xuICAgIHtcbiAgICAgIGluc3RhbmNlLl9yZWFjdEludGVybmFsSW5zdGFuY2UgPSBmYWtlSW50ZXJuYWxJbnN0YW5jZTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjb25zdHJ1Y3RDbGFzc0luc3RhbmNlKHdvcmtJblByb2dyZXNzLCBwcm9wcykge1xuICAgIHZhciBjdG9yID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgICB2YXIgdW5tYXNrZWRDb250ZXh0ID0gZ2V0VW5tYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcbiAgICB2YXIgbmVlZHNDb250ZXh0ID0gaXNDb250ZXh0Q29uc3VtZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgIHZhciBjb250ZXh0ID0gbmVlZHNDb250ZXh0ID8gZ2V0TWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgdW5tYXNrZWRDb250ZXh0KSA6IGVtcHR5T2JqZWN0O1xuICAgIHZhciBpbnN0YW5jZSA9IG5ldyBjdG9yKHByb3BzLCBjb250ZXh0KTtcbiAgICBhZG9wdENsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIGluc3RhbmNlKTtcblxuICAgIC8vIENhY2hlIHVubWFza2VkIGNvbnRleHQgc28gd2UgY2FuIGF2b2lkIHJlY3JlYXRpbmcgbWFza2VkIGNvbnRleHQgdW5sZXNzIG5lY2Vzc2FyeS5cbiAgICAvLyBSZWFjdEZpYmVyQ29udGV4dCB1c3VhbGx5IHVwZGF0ZXMgdGhpcyBjYWNoZSBidXQgY2FuJ3QgZm9yIG5ld2x5LWNyZWF0ZWQgaW5zdGFuY2VzLlxuICAgIGlmIChuZWVkc0NvbnRleHQpIHtcbiAgICAgIGNhY2hlQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgdW5tYXNrZWRDb250ZXh0LCBjb250ZXh0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH1cblxuICBmdW5jdGlvbiBjYWxsQ29tcG9uZW50V2lsbE1vdW50KHdvcmtJblByb2dyZXNzLCBpbnN0YW5jZSkge1xuICAgIHN0YXJ0UGhhc2VUaW1lcih3b3JrSW5Qcm9ncmVzcywgJ2NvbXBvbmVudFdpbGxNb3VudCcpO1xuICAgIHZhciBvbGRTdGF0ZSA9IGluc3RhbmNlLnN0YXRlO1xuICAgIGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudCgpO1xuICAgIHN0b3BQaGFzZVRpbWVyKCk7XG5cbiAgICAvLyBTaW11bGF0ZSBhbiBhc3luYyBiYWlsb3V0L2ludGVycnVwdGlvbiBieSBpbnZva2luZyBsaWZlY3ljbGUgdHdpY2UuXG4gICAgaWYgKGRlYnVnUmVuZGVyUGhhc2VTaWRlRWZmZWN0cykge1xuICAgICAgaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50KCk7XG4gICAgfVxuXG4gICAgaWYgKG9sZFN0YXRlICE9PSBpbnN0YW5jZS5zdGF0ZSkge1xuICAgICAge1xuICAgICAgICB3YXJuaW5nKGZhbHNlLCAnJXMuY29tcG9uZW50V2lsbE1vdW50KCk6IEFzc2lnbmluZyBkaXJlY3RseSB0byB0aGlzLnN0YXRlIGlzICcgKyBcImRlcHJlY2F0ZWQgKGV4Y2VwdCBpbnNpZGUgYSBjb21wb25lbnQncyBcIiArICdjb25zdHJ1Y3RvcikuIFVzZSBzZXRTdGF0ZSBpbnN0ZWFkLicsIGdldENvbXBvbmVudE5hbWUod29ya0luUHJvZ3Jlc3MpKTtcbiAgICAgIH1cbiAgICAgIHVwZGF0ZXIuZW5xdWV1ZVJlcGxhY2VTdGF0ZShpbnN0YW5jZSwgaW5zdGFuY2Uuc3RhdGUsIG51bGwpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNhbGxDb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKHdvcmtJblByb2dyZXNzLCBpbnN0YW5jZSwgbmV3UHJvcHMsIG5ld0NvbnRleHQpIHtcbiAgICBzdGFydFBoYXNlVGltZXIod29ya0luUHJvZ3Jlc3MsICdjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzJyk7XG4gICAgdmFyIG9sZFN0YXRlID0gaW5zdGFuY2Uuc3RhdGU7XG4gICAgaW5zdGFuY2UuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXdQcm9wcywgbmV3Q29udGV4dCk7XG4gICAgc3RvcFBoYXNlVGltZXIoKTtcblxuICAgIC8vIFNpbXVsYXRlIGFuIGFzeW5jIGJhaWxvdXQvaW50ZXJydXB0aW9uIGJ5IGludm9raW5nIGxpZmVjeWNsZSB0d2ljZS5cbiAgICBpZiAoZGVidWdSZW5kZXJQaGFzZVNpZGVFZmZlY3RzKSB7XG4gICAgICBpbnN0YW5jZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5ld1Byb3BzLCBuZXdDb250ZXh0KTtcbiAgICB9XG5cbiAgICBpZiAoaW5zdGFuY2Uuc3RhdGUgIT09IG9sZFN0YXRlKSB7XG4gICAgICB7XG4gICAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZSh3b3JrSW5Qcm9ncmVzcykgfHwgJ0NvbXBvbmVudCc7XG4gICAgICAgIGlmICghZGlkV2FybkFib3V0U3RhdGVBc3NpZ25tZW50Rm9yQ29tcG9uZW50W2NvbXBvbmVudE5hbWVdKSB7XG4gICAgICAgICAgd2FybmluZyhmYWxzZSwgJyVzLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMoKTogQXNzaWduaW5nIGRpcmVjdGx5IHRvICcgKyBcInRoaXMuc3RhdGUgaXMgZGVwcmVjYXRlZCAoZXhjZXB0IGluc2lkZSBhIGNvbXBvbmVudCdzIFwiICsgJ2NvbnN0cnVjdG9yKS4gVXNlIHNldFN0YXRlIGluc3RlYWQuJywgY29tcG9uZW50TmFtZSk7XG4gICAgICAgICAgZGlkV2FybkFib3V0U3RhdGVBc3NpZ25tZW50Rm9yQ29tcG9uZW50W2NvbXBvbmVudE5hbWVdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdXBkYXRlci5lbnF1ZXVlUmVwbGFjZVN0YXRlKGluc3RhbmNlLCBpbnN0YW5jZS5zdGF0ZSwgbnVsbCk7XG4gICAgfVxuICB9XG5cbiAgLy8gSW52b2tlcyB0aGUgbW91bnQgbGlmZS1jeWNsZXMgb24gYSBwcmV2aW91c2x5IG5ldmVyIHJlbmRlcmVkIGluc3RhbmNlLlxuICBmdW5jdGlvbiBtb3VudENsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gICAgdmFyIGN1cnJlbnQgPSB3b3JrSW5Qcm9ncmVzcy5hbHRlcm5hdGU7XG5cbiAgICB7XG4gICAgICBjaGVja0NsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MpO1xuICAgIH1cblxuICAgIHZhciBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgICB2YXIgc3RhdGUgPSBpbnN0YW5jZS5zdGF0ZSB8fCBudWxsO1xuXG4gICAgdmFyIHByb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICAgICFwcm9wcyA/IGludmFyaWFudChmYWxzZSwgJ1RoZXJlIG11c3QgYmUgcGVuZGluZyBwcm9wcyBmb3IgYW4gaW5pdGlhbCBtb3VudC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcblxuICAgIHZhciB1bm1hc2tlZENvbnRleHQgPSBnZXRVbm1hc2tlZENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuXG4gICAgaW5zdGFuY2UucHJvcHMgPSBwcm9wcztcbiAgICBpbnN0YW5jZS5zdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBzdGF0ZTtcbiAgICBpbnN0YW5jZS5yZWZzID0gZW1wdHlPYmplY3Q7XG4gICAgaW5zdGFuY2UuY29udGV4dCA9IGdldE1hc2tlZENvbnRleHQod29ya0luUHJvZ3Jlc3MsIHVubWFza2VkQ29udGV4dCk7XG5cbiAgICBpZiAoZW5hYmxlQXN5bmNTdWJ0cmVlQVBJICYmIHdvcmtJblByb2dyZXNzLnR5cGUgIT0gbnVsbCAmJiB3b3JrSW5Qcm9ncmVzcy50eXBlLnByb3RvdHlwZSAhPSBudWxsICYmIHdvcmtJblByb2dyZXNzLnR5cGUucHJvdG90eXBlLnVuc3RhYmxlX2lzQXN5bmNSZWFjdENvbXBvbmVudCA9PT0gdHJ1ZSkge1xuICAgICAgd29ya0luUHJvZ3Jlc3MuaW50ZXJuYWxDb250ZXh0VGFnIHw9IEFzeW5jVXBkYXRlcztcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2FsbENvbXBvbmVudFdpbGxNb3VudCh3b3JrSW5Qcm9ncmVzcywgaW5zdGFuY2UpO1xuICAgICAgLy8gSWYgd2UgaGFkIGFkZGl0aW9uYWwgc3RhdGUgdXBkYXRlcyBkdXJpbmcgdGhpcyBsaWZlLWN5Y2xlLCBsZXQnc1xuICAgICAgLy8gcHJvY2VzcyB0aGVtIG5vdy5cbiAgICAgIHZhciB1cGRhdGVRdWV1ZSA9IHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlO1xuICAgICAgaWYgKHVwZGF0ZVF1ZXVlICE9PSBudWxsKSB7XG4gICAgICAgIGluc3RhbmNlLnN0YXRlID0gcHJvY2Vzc1VwZGF0ZVF1ZXVlKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCB1cGRhdGVRdWV1ZSwgaW5zdGFuY2UsIHByb3BzLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkTW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBVcGRhdGU7XG4gICAgfVxuICB9XG5cbiAgLy8gQ2FsbGVkIG9uIGEgcHJlZXhpc3RpbmcgY2xhc3MgaW5zdGFuY2UuIFJldHVybnMgZmFsc2UgaWYgYSByZXN1bWVkIHJlbmRlclxuICAvLyBjb3VsZCBiZSByZXVzZWQuXG4gIC8vIGZ1bmN0aW9uIHJlc3VtZU1vdW50Q2xhc3NJbnN0YW5jZShcbiAgLy8gICB3b3JrSW5Qcm9ncmVzczogRmliZXIsXG4gIC8vICAgcHJpb3JpdHlMZXZlbDogUHJpb3JpdHlMZXZlbCxcbiAgLy8gKTogYm9vbGVhbiB7XG4gIC8vICAgY29uc3QgaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gIC8vICAgcmVzZXRJbnB1dFBvaW50ZXJzKHdvcmtJblByb2dyZXNzLCBpbnN0YW5jZSk7XG5cbiAgLy8gICBsZXQgbmV3U3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICAvLyAgIGxldCBuZXdQcm9wcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcbiAgLy8gICBpZiAoIW5ld1Byb3BzKSB7XG4gIC8vICAgICAvLyBJZiB0aGVyZSBpc24ndCBhbnkgbmV3IHByb3BzLCB0aGVuIHdlJ2xsIHJldXNlIHRoZSBtZW1vaXplZCBwcm9wcy5cbiAgLy8gICAgIC8vIFRoaXMgY291bGQgYmUgZnJvbSBhbHJlYWR5IGNvbXBsZXRlZCB3b3JrLlxuICAvLyAgICAgbmV3UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzO1xuICAvLyAgICAgaW52YXJpYW50KFxuICAvLyAgICAgICBuZXdQcm9wcyAhPSBudWxsLFxuICAvLyAgICAgICAnVGhlcmUgc2hvdWxkIGFsd2F5cyBiZSBwZW5kaW5nIG9yIG1lbW9pemVkIHByb3BzLiBUaGlzIGVycm9yIGlzICcgK1xuICAvLyAgICAgICAgICdsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nLFxuICAvLyAgICAgKTtcbiAgLy8gICB9XG4gIC8vICAgY29uc3QgbmV3VW5tYXNrZWRDb250ZXh0ID0gZ2V0VW5tYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcbiAgLy8gICBjb25zdCBuZXdDb250ZXh0ID0gZ2V0TWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgbmV3VW5tYXNrZWRDb250ZXh0KTtcblxuICAvLyAgIGNvbnN0IG9sZENvbnRleHQgPSBpbnN0YW5jZS5jb250ZXh0O1xuICAvLyAgIGNvbnN0IG9sZFByb3BzID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcztcblxuICAvLyAgIGlmIChcbiAgLy8gICAgIHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzID09PSAnZnVuY3Rpb24nICYmXG4gIC8vICAgICAob2xkUHJvcHMgIT09IG5ld1Byb3BzIHx8IG9sZENvbnRleHQgIT09IG5ld0NvbnRleHQpXG4gIC8vICAgKSB7XG4gIC8vICAgICBjYWxsQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhcbiAgLy8gICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gIC8vICAgICAgIGluc3RhbmNlLFxuICAvLyAgICAgICBuZXdQcm9wcyxcbiAgLy8gICAgICAgbmV3Q29udGV4dCxcbiAgLy8gICAgICk7XG4gIC8vICAgfVxuXG4gIC8vICAgLy8gUHJvY2VzcyB0aGUgdXBkYXRlIHF1ZXVlIGJlZm9yZSBjYWxsaW5nIHNob3VsZENvbXBvbmVudFVwZGF0ZVxuICAvLyAgIGNvbnN0IHVwZGF0ZVF1ZXVlID0gd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWU7XG4gIC8vICAgaWYgKHVwZGF0ZVF1ZXVlICE9PSBudWxsKSB7XG4gIC8vICAgICBuZXdTdGF0ZSA9IHByb2Nlc3NVcGRhdGVRdWV1ZShcbiAgLy8gICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gIC8vICAgICAgIHVwZGF0ZVF1ZXVlLFxuICAvLyAgICAgICBpbnN0YW5jZSxcbiAgLy8gICAgICAgbmV3U3RhdGUsXG4gIC8vICAgICAgIG5ld1Byb3BzLFxuICAvLyAgICAgICBwcmlvcml0eUxldmVsLFxuICAvLyAgICAgKTtcbiAgLy8gICB9XG5cbiAgLy8gICAvLyBUT0RPOiBTaG91bGQgd2UgZGVhbCB3aXRoIGEgc2V0U3RhdGUgdGhhdCBoYXBwZW5lZCBhZnRlciB0aGUgbGFzdFxuICAvLyAgIC8vIGNvbXBvbmVudFdpbGxNb3VudCBhbmQgYmVmb3JlIHRoaXMgY29tcG9uZW50V2lsbE1vdW50PyBQcm9iYWJseVxuICAvLyAgIC8vIHVuc3VwcG9ydGVkIGFueXdheS5cblxuICAvLyAgIGlmIChcbiAgLy8gICAgICFjaGVja1Nob3VsZENvbXBvbmVudFVwZGF0ZShcbiAgLy8gICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gIC8vICAgICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHMsXG4gIC8vICAgICAgIG5ld1Byb3BzLFxuICAvLyAgICAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlLFxuICAvLyAgICAgICBuZXdTdGF0ZSxcbiAgLy8gICAgICAgbmV3Q29udGV4dCxcbiAgLy8gICAgIClcbiAgLy8gICApIHtcbiAgLy8gICAgIC8vIFVwZGF0ZSB0aGUgZXhpc3RpbmcgaW5zdGFuY2UncyBzdGF0ZSwgcHJvcHMsIGFuZCBjb250ZXh0IHBvaW50ZXJzIGV2ZW5cbiAgLy8gICAgIC8vIHRob3VnaCB3ZSdyZSBiYWlsaW5nIG91dC5cbiAgLy8gICAgIGluc3RhbmNlLnByb3BzID0gbmV3UHJvcHM7XG4gIC8vICAgICBpbnN0YW5jZS5zdGF0ZSA9IG5ld1N0YXRlO1xuICAvLyAgICAgaW5zdGFuY2UuY29udGV4dCA9IG5ld0NvbnRleHQ7XG4gIC8vICAgICByZXR1cm4gZmFsc2U7XG4gIC8vICAgfVxuXG4gIC8vICAgLy8gVXBkYXRlIHRoZSBpbnB1dCBwb2ludGVycyBub3cgc28gdGhhdCB0aGV5IGFyZSBjb3JyZWN0IHdoZW4gd2UgY2FsbFxuICAvLyAgIC8vIGNvbXBvbmVudFdpbGxNb3VudFxuICAvLyAgIGluc3RhbmNlLnByb3BzID0gbmV3UHJvcHM7XG4gIC8vICAgaW5zdGFuY2Uuc3RhdGUgPSBuZXdTdGF0ZTtcbiAgLy8gICBpbnN0YW5jZS5jb250ZXh0ID0gbmV3Q29udGV4dDtcblxuICAvLyAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gIC8vICAgICBjYWxsQ29tcG9uZW50V2lsbE1vdW50KHdvcmtJblByb2dyZXNzLCBpbnN0YW5jZSk7XG4gIC8vICAgICAvLyBjb21wb25lbnRXaWxsTW91bnQgbWF5IGhhdmUgY2FsbGVkIHNldFN0YXRlLiBQcm9jZXNzIHRoZSB1cGRhdGUgcXVldWUuXG4gIC8vICAgICBjb25zdCBuZXdVcGRhdGVRdWV1ZSA9IHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlO1xuICAvLyAgICAgaWYgKG5ld1VwZGF0ZVF1ZXVlICE9PSBudWxsKSB7XG4gIC8vICAgICAgIG5ld1N0YXRlID0gcHJvY2Vzc1VwZGF0ZVF1ZXVlKFxuICAvLyAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAvLyAgICAgICAgIG5ld1VwZGF0ZVF1ZXVlLFxuICAvLyAgICAgICAgIGluc3RhbmNlLFxuICAvLyAgICAgICAgIG5ld1N0YXRlLFxuICAvLyAgICAgICAgIG5ld1Byb3BzLFxuICAvLyAgICAgICAgIHByaW9yaXR5TGV2ZWwsXG4gIC8vICAgICAgICk7XG4gIC8vICAgICB9XG4gIC8vICAgfVxuXG4gIC8vICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRNb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAvLyAgICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IFVwZGF0ZTtcbiAgLy8gICB9XG5cbiAgLy8gICBpbnN0YW5jZS5zdGF0ZSA9IG5ld1N0YXRlO1xuXG4gIC8vICAgcmV0dXJuIHRydWU7XG4gIC8vIH1cblxuICAvLyBJbnZva2VzIHRoZSB1cGRhdGUgbGlmZS1jeWNsZXMgYW5kIHJldHVybnMgZmFsc2UgaWYgaXQgc2hvdWxkbid0IHJlcmVuZGVyLlxuICBmdW5jdGlvbiB1cGRhdGVDbGFzc0luc3RhbmNlKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSkge1xuICAgIHZhciBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgICByZXNldElucHV0UG9pbnRlcnMod29ya0luUHJvZ3Jlc3MsIGluc3RhbmNlKTtcblxuICAgIHZhciBvbGRQcm9wcyA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHM7XG4gICAgdmFyIG5ld1Byb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICAgIGlmICghbmV3UHJvcHMpIHtcbiAgICAgIC8vIElmIHRoZXJlIGFyZW4ndCBhbnkgbmV3IHByb3BzLCB0aGVuIHdlJ2xsIHJldXNlIHRoZSBtZW1vaXplZCBwcm9wcy5cbiAgICAgIC8vIFRoaXMgY291bGQgYmUgZnJvbSBhbHJlYWR5IGNvbXBsZXRlZCB3b3JrLlxuICAgICAgbmV3UHJvcHMgPSBvbGRQcm9wcztcbiAgICAgICEobmV3UHJvcHMgIT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdUaGVyZSBzaG91bGQgYWx3YXlzIGJlIHBlbmRpbmcgb3IgbWVtb2l6ZWQgcHJvcHMuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gICAgfVxuICAgIHZhciBvbGRDb250ZXh0ID0gaW5zdGFuY2UuY29udGV4dDtcbiAgICB2YXIgbmV3VW5tYXNrZWRDb250ZXh0ID0gZ2V0VW5tYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcbiAgICB2YXIgbmV3Q29udGV4dCA9IGdldE1hc2tlZENvbnRleHQod29ya0luUHJvZ3Jlc3MsIG5ld1VubWFza2VkQ29udGV4dCk7XG5cbiAgICAvLyBOb3RlOiBEdXJpbmcgdGhlc2UgbGlmZS1jeWNsZXMsIGluc3RhbmNlLnByb3BzL2luc3RhbmNlLnN0YXRlIGFyZSB3aGF0XG4gICAgLy8gZXZlciB0aGUgcHJldmlvdXNseSBhdHRlbXB0ZWQgdG8gcmVuZGVyIC0gbm90IHRoZSBcImN1cnJlbnRcIi4gSG93ZXZlcixcbiAgICAvLyBkdXJpbmcgY29tcG9uZW50RGlkVXBkYXRlIHdlIHBhc3MgdGhlIFwiY3VycmVudFwiIHByb3BzLlxuXG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzID09PSAnZnVuY3Rpb24nICYmIChvbGRQcm9wcyAhPT0gbmV3UHJvcHMgfHwgb2xkQ29udGV4dCAhPT0gbmV3Q29udGV4dCkpIHtcbiAgICAgIGNhbGxDb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKHdvcmtJblByb2dyZXNzLCBpbnN0YW5jZSwgbmV3UHJvcHMsIG5ld0NvbnRleHQpO1xuICAgIH1cblxuICAgIC8vIENvbXB1dGUgdGhlIG5leHQgc3RhdGUgdXNpbmcgdGhlIG1lbW9pemVkIHN0YXRlIGFuZCB0aGUgdXBkYXRlIHF1ZXVlLlxuICAgIHZhciBvbGRTdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gICAgLy8gVE9ETzogUHJldmlvdXMgc3RhdGUgY2FuIGJlIG51bGwuXG4gICAgdmFyIG5ld1N0YXRlID0gdm9pZCAwO1xuICAgIGlmICh3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSAhPT0gbnVsbCkge1xuICAgICAgbmV3U3RhdGUgPSBwcm9jZXNzVXBkYXRlUXVldWUoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlLCBpbnN0YW5jZSwgbmV3UHJvcHMsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmV3U3RhdGUgPSBvbGRTdGF0ZTtcbiAgICB9XG5cbiAgICBpZiAob2xkUHJvcHMgPT09IG5ld1Byb3BzICYmIG9sZFN0YXRlID09PSBuZXdTdGF0ZSAmJiAhaGFzQ29udGV4dENoYW5nZWQoKSAmJiAhKHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlICE9PSBudWxsICYmIHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlLmhhc0ZvcmNlVXBkYXRlKSkge1xuICAgICAgLy8gSWYgYW4gdXBkYXRlIHdhcyBhbHJlYWR5IGluIHByb2dyZXNzLCB3ZSBzaG91bGQgc2NoZWR1bGUgYW4gVXBkYXRlXG4gICAgICAvLyBlZmZlY3QgZXZlbiB0aG91Z2ggd2UncmUgYmFpbGluZyBvdXQsIHNvIHRoYXQgY1dVL2NEVSBhcmUgY2FsbGVkLlxuICAgICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRVcGRhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgaWYgKG9sZFByb3BzICE9PSBjdXJyZW50Lm1lbW9pemVkUHJvcHMgfHwgb2xkU3RhdGUgIT09IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZSkge1xuICAgICAgICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBVcGRhdGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgc2hvdWxkVXBkYXRlID0gY2hlY2tTaG91bGRDb21wb25lbnRVcGRhdGUod29ya0luUHJvZ3Jlc3MsIG9sZFByb3BzLCBuZXdQcm9wcywgb2xkU3RhdGUsIG5ld1N0YXRlLCBuZXdDb250ZXh0KTtcblxuICAgIGlmIChzaG91bGRVcGRhdGUpIHtcbiAgICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbFVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBzdGFydFBoYXNlVGltZXIod29ya0luUHJvZ3Jlc3MsICdjb21wb25lbnRXaWxsVXBkYXRlJyk7XG4gICAgICAgIGluc3RhbmNlLmNvbXBvbmVudFdpbGxVcGRhdGUobmV3UHJvcHMsIG5ld1N0YXRlLCBuZXdDb250ZXh0KTtcbiAgICAgICAgc3RvcFBoYXNlVGltZXIoKTtcblxuICAgICAgICAvLyBTaW11bGF0ZSBhbiBhc3luYyBiYWlsb3V0L2ludGVycnVwdGlvbiBieSBpbnZva2luZyBsaWZlY3ljbGUgdHdpY2UuXG4gICAgICAgIGlmIChkZWJ1Z1JlbmRlclBoYXNlU2lkZUVmZmVjdHMpIHtcbiAgICAgICAgICBpbnN0YW5jZS5jb21wb25lbnRXaWxsVXBkYXRlKG5ld1Byb3BzLCBuZXdTdGF0ZSwgbmV3Q29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkVXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBVcGRhdGU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIGFuIHVwZGF0ZSB3YXMgYWxyZWFkeSBpbiBwcm9ncmVzcywgd2Ugc2hvdWxkIHNjaGVkdWxlIGFuIFVwZGF0ZVxuICAgICAgLy8gZWZmZWN0IGV2ZW4gdGhvdWdoIHdlJ3JlIGJhaWxpbmcgb3V0LCBzbyB0aGF0IGNXVS9jRFUgYXJlIGNhbGxlZC5cbiAgICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkVXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGlmIChvbGRQcm9wcyAhPT0gY3VycmVudC5tZW1vaXplZFByb3BzIHx8IG9sZFN0YXRlICE9PSBjdXJyZW50Lm1lbW9pemVkU3RhdGUpIHtcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgfD0gVXBkYXRlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIElmIHNob3VsZENvbXBvbmVudFVwZGF0ZSByZXR1cm5lZCBmYWxzZSwgd2Ugc2hvdWxkIHN0aWxsIHVwZGF0ZSB0aGVcbiAgICAgIC8vIG1lbW9pemVkIHByb3BzL3N0YXRlIHRvIGluZGljYXRlIHRoYXQgdGhpcyB3b3JrIGNhbiBiZSByZXVzZWQuXG4gICAgICBtZW1vaXplUHJvcHMod29ya0luUHJvZ3Jlc3MsIG5ld1Byb3BzKTtcbiAgICAgIG1lbW9pemVTdGF0ZSh3b3JrSW5Qcm9ncmVzcywgbmV3U3RhdGUpO1xuICAgIH1cblxuICAgIC8vIFVwZGF0ZSB0aGUgZXhpc3RpbmcgaW5zdGFuY2UncyBzdGF0ZSwgcHJvcHMsIGFuZCBjb250ZXh0IHBvaW50ZXJzIGV2ZW5cbiAgICAvLyBpZiBzaG91bGRDb21wb25lbnRVcGRhdGUgcmV0dXJucyBmYWxzZS5cbiAgICBpbnN0YW5jZS5wcm9wcyA9IG5ld1Byb3BzO1xuICAgIGluc3RhbmNlLnN0YXRlID0gbmV3U3RhdGU7XG4gICAgaW5zdGFuY2UuY29udGV4dCA9IG5ld0NvbnRleHQ7XG5cbiAgICByZXR1cm4gc2hvdWxkVXBkYXRlO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBhZG9wdENsYXNzSW5zdGFuY2U6IGFkb3B0Q2xhc3NJbnN0YW5jZSxcbiAgICBjb25zdHJ1Y3RDbGFzc0luc3RhbmNlOiBjb25zdHJ1Y3RDbGFzc0luc3RhbmNlLFxuICAgIG1vdW50Q2xhc3NJbnN0YW5jZTogbW91bnRDbGFzc0luc3RhbmNlLFxuICAgIC8vIHJlc3VtZU1vdW50Q2xhc3NJbnN0YW5jZSxcbiAgICB1cGRhdGVDbGFzc0luc3RhbmNlOiB1cGRhdGVDbGFzc0luc3RhbmNlXG4gIH07XG59O1xuXG4vLyBUaGUgU3ltYm9sIHVzZWQgdG8gdGFnIHRoZSBSZWFjdEVsZW1lbnQtbGlrZSB0eXBlcy4gSWYgdGhlcmUgaXMgbm8gbmF0aXZlIFN5bWJvbFxuLy8gbm9yIHBvbHlmaWxsLCB0aGVuIGEgcGxhaW4gbnVtYmVyIGlzIHVzZWQgZm9yIHBlcmZvcm1hbmNlLlxudmFyIGhhc1N5bWJvbCA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sWydmb3InXTtcblxudmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbFsnZm9yJ10oJ3JlYWN0LmVsZW1lbnQnKSA6IDB4ZWFjNztcbnZhciBSRUFDVF9DQUxMX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2xbJ2ZvciddKCdyZWFjdC5jYWxsJykgOiAweGVhYzg7XG52YXIgUkVBQ1RfUkVUVVJOX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2xbJ2ZvciddKCdyZWFjdC5yZXR1cm4nKSA6IDB4ZWFjOTtcbnZhciBSRUFDVF9QT1JUQUxfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbFsnZm9yJ10oJ3JlYWN0LnBvcnRhbCcpIDogMHhlYWNhO1xudmFyIFJFQUNUX0ZSQUdNRU5UX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2xbJ2ZvciddKCdyZWFjdC5mcmFnbWVudCcpIDogMHhlYWNiO1xuXG52YXIgTUFZQkVfSVRFUkFUT1JfU1lNQk9MID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuaXRlcmF0b3I7XG52YXIgRkFVWF9JVEVSQVRPUl9TWU1CT0wgPSAnQEBpdGVyYXRvcic7XG5cbmZ1bmN0aW9uIGdldEl0ZXJhdG9yRm4obWF5YmVJdGVyYWJsZSkge1xuICBpZiAobWF5YmVJdGVyYWJsZSA9PT0gbnVsbCB8fCB0eXBlb2YgbWF5YmVJdGVyYWJsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB2YXIgbWF5YmVJdGVyYXRvciA9IE1BWUJFX0lURVJBVE9SX1NZTUJPTCAmJiBtYXliZUl0ZXJhYmxlW01BWUJFX0lURVJBVE9SX1NZTUJPTF0gfHwgbWF5YmVJdGVyYWJsZVtGQVVYX0lURVJBVE9SX1NZTUJPTF07XG4gIGlmICh0eXBlb2YgbWF5YmVJdGVyYXRvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBtYXliZUl0ZXJhdG9yO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG52YXIgZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQxID0gUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5nZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtO1xuXG5cbntcbiAgdmFyIGRpZFdhcm5BYm91dE1hcHMgPSBmYWxzZTtcbiAgLyoqXG4gICAqIFdhcm4gaWYgdGhlcmUncyBubyBrZXkgZXhwbGljaXRseSBzZXQgb24gZHluYW1pYyBhcnJheXMgb2YgY2hpbGRyZW4gb3JcbiAgICogb2JqZWN0IGtleXMgYXJlIG5vdCB2YWxpZC4gVGhpcyBhbGxvd3MgdXMgdG8ga2VlcCB0cmFjayBvZiBjaGlsZHJlbiBiZXR3ZWVuXG4gICAqIHVwZGF0ZXMuXG4gICAqL1xuICB2YXIgb3duZXJIYXNLZXlVc2VXYXJuaW5nID0ge307XG4gIHZhciBvd25lckhhc0Z1bmN0aW9uVHlwZVdhcm5pbmcgPSB7fTtcblxuICB2YXIgd2FybkZvck1pc3NpbmdLZXkgPSBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICBpZiAoY2hpbGQgPT09IG51bGwgfHwgdHlwZW9mIGNoaWxkICE9PSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIWNoaWxkLl9zdG9yZSB8fCBjaGlsZC5fc3RvcmUudmFsaWRhdGVkIHx8IGNoaWxkLmtleSAhPSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgICEodHlwZW9mIGNoaWxkLl9zdG9yZSA9PT0gJ29iamVjdCcpID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3QgQ29tcG9uZW50IGluIHdhcm5Gb3JNaXNzaW5nS2V5IHNob3VsZCBoYXZlIGEgX3N0b3JlLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuICAgIGNoaWxkLl9zdG9yZS52YWxpZGF0ZWQgPSB0cnVlO1xuXG4gICAgdmFyIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8gPSAnRWFjaCBjaGlsZCBpbiBhbiBhcnJheSBvciBpdGVyYXRvciBzaG91bGQgaGF2ZSBhIHVuaXF1ZSAnICsgJ1wia2V5XCIgcHJvcC4gU2VlIGh0dHBzOi8vZmIubWUvcmVhY3Qtd2FybmluZy1rZXlzIGZvciAnICsgJ21vcmUgaW5mb3JtYXRpb24uJyArIChnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtJDEoKSB8fCAnJyk7XG4gICAgaWYgKG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBvd25lckhhc0tleVVzZVdhcm5pbmdbY3VycmVudENvbXBvbmVudEVycm9ySW5mb10gPSB0cnVlO1xuXG4gICAgd2FybmluZyhmYWxzZSwgJ0VhY2ggY2hpbGQgaW4gYW4gYXJyYXkgb3IgaXRlcmF0b3Igc2hvdWxkIGhhdmUgYSB1bmlxdWUgJyArICdcImtleVwiIHByb3AuIFNlZSBodHRwczovL2ZiLm1lL3JlYWN0LXdhcm5pbmcta2V5cyBmb3IgJyArICdtb3JlIGluZm9ybWF0aW9uLiVzJywgZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQxKCkpO1xuICB9O1xufVxuXG52YXIgaXNBcnJheSQxID0gQXJyYXkuaXNBcnJheTtcblxuZnVuY3Rpb24gY29lcmNlUmVmKGN1cnJlbnQsIGVsZW1lbnQpIHtcbiAgdmFyIG1peGVkUmVmID0gZWxlbWVudC5yZWY7XG4gIGlmIChtaXhlZFJlZiAhPT0gbnVsbCAmJiB0eXBlb2YgbWl4ZWRSZWYgIT09ICdmdW5jdGlvbicpIHtcbiAgICBpZiAoZWxlbWVudC5fb3duZXIpIHtcbiAgICAgIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgdmFyIGluc3QgPSB2b2lkIDA7XG4gICAgICBpZiAob3duZXIpIHtcbiAgICAgICAgdmFyIG93bmVyRmliZXIgPSBvd25lcjtcbiAgICAgICAgIShvd25lckZpYmVyLnRhZyA9PT0gQ2xhc3NDb21wb25lbnQpID8gaW52YXJpYW50KGZhbHNlLCAnU3RhdGVsZXNzIGZ1bmN0aW9uIGNvbXBvbmVudHMgY2Fubm90IGhhdmUgcmVmcy4nKSA6IHZvaWQgMDtcbiAgICAgICAgaW5zdCA9IG93bmVyRmliZXIuc3RhdGVOb2RlO1xuICAgICAgfVxuICAgICAgIWluc3QgPyBpbnZhcmlhbnQoZmFsc2UsICdNaXNzaW5nIG93bmVyIGZvciBzdHJpbmcgcmVmICVzLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicsIG1peGVkUmVmKSA6IHZvaWQgMDtcbiAgICAgIHZhciBzdHJpbmdSZWYgPSAnJyArIG1peGVkUmVmO1xuICAgICAgLy8gQ2hlY2sgaWYgcHJldmlvdXMgc3RyaW5nIHJlZiBtYXRjaGVzIG5ldyBzdHJpbmcgcmVmXG4gICAgICBpZiAoY3VycmVudCAhPT0gbnVsbCAmJiBjdXJyZW50LnJlZiAhPT0gbnVsbCAmJiBjdXJyZW50LnJlZi5fc3RyaW5nUmVmID09PSBzdHJpbmdSZWYpIHtcbiAgICAgICAgcmV0dXJuIGN1cnJlbnQucmVmO1xuICAgICAgfVxuICAgICAgdmFyIHJlZiA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgcmVmcyA9IGluc3QucmVmcyA9PT0gZW1wdHlPYmplY3QgPyBpbnN0LnJlZnMgPSB7fSA6IGluc3QucmVmcztcbiAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgZGVsZXRlIHJlZnNbc3RyaW5nUmVmXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZWZzW3N0cmluZ1JlZl0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHJlZi5fc3RyaW5nUmVmID0gc3RyaW5nUmVmO1xuICAgICAgcmV0dXJuIHJlZjtcbiAgICB9IGVsc2Uge1xuICAgICAgISh0eXBlb2YgbWl4ZWRSZWYgPT09ICdzdHJpbmcnKSA/IGludmFyaWFudChmYWxzZSwgJ0V4cGVjdGVkIHJlZiB0byBiZSBhIGZ1bmN0aW9uIG9yIGEgc3RyaW5nLicpIDogdm9pZCAwO1xuICAgICAgIWVsZW1lbnQuX293bmVyID8gaW52YXJpYW50KGZhbHNlLCAnRWxlbWVudCByZWYgd2FzIHNwZWNpZmllZCBhcyBhIHN0cmluZyAoJXMpIGJ1dCBubyBvd25lciB3YXMgc2V0LiBZb3UgbWF5IGhhdmUgbXVsdGlwbGUgY29waWVzIG9mIFJlYWN0IGxvYWRlZC4gKGRldGFpbHM6IGh0dHBzOi8vZmIubWUvcmVhY3QtcmVmcy1tdXN0LWhhdmUtb3duZXIpLicsIG1peGVkUmVmKSA6IHZvaWQgMDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1peGVkUmVmO1xufVxuXG5mdW5jdGlvbiB0aHJvd09uSW52YWxpZE9iamVjdFR5cGUocmV0dXJuRmliZXIsIG5ld0NoaWxkKSB7XG4gIGlmIChyZXR1cm5GaWJlci50eXBlICE9PSAndGV4dGFyZWEnKSB7XG4gICAgdmFyIGFkZGVuZHVtID0gJyc7XG4gICAge1xuICAgICAgYWRkZW5kdW0gPSAnIElmIHlvdSBtZWFudCB0byByZW5kZXIgYSBjb2xsZWN0aW9uIG9mIGNoaWxkcmVuLCB1c2UgYW4gYXJyYXkgJyArICdpbnN0ZWFkLicgKyAoZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQxKCkgfHwgJycpO1xuICAgIH1cbiAgICBpbnZhcmlhbnQoZmFsc2UsICdPYmplY3RzIGFyZSBub3QgdmFsaWQgYXMgYSBSZWFjdCBjaGlsZCAoZm91bmQ6ICVzKS4lcycsIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChuZXdDaGlsZCkgPT09ICdbb2JqZWN0IE9iamVjdF0nID8gJ29iamVjdCB3aXRoIGtleXMgeycgKyBPYmplY3Qua2V5cyhuZXdDaGlsZCkuam9pbignLCAnKSArICd9JyA6IG5ld0NoaWxkLCBhZGRlbmR1bSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gd2Fybk9uRnVuY3Rpb25UeXBlKCkge1xuICB2YXIgY3VycmVudENvbXBvbmVudEVycm9ySW5mbyA9ICdGdW5jdGlvbnMgYXJlIG5vdCB2YWxpZCBhcyBhIFJlYWN0IGNoaWxkLiBUaGlzIG1heSBoYXBwZW4gaWYgJyArICd5b3UgcmV0dXJuIGEgQ29tcG9uZW50IGluc3RlYWQgb2YgPENvbXBvbmVudCAvPiBmcm9tIHJlbmRlci4gJyArICdPciBtYXliZSB5b3UgbWVhbnQgdG8gY2FsbCB0aGlzIGZ1bmN0aW9uIHJhdGhlciB0aGFuIHJldHVybiBpdC4nICsgKGdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW0kMSgpIHx8ICcnKTtcblxuICBpZiAob3duZXJIYXNGdW5jdGlvblR5cGVXYXJuaW5nW2N1cnJlbnRDb21wb25lbnRFcnJvckluZm9dKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIG93bmVySGFzRnVuY3Rpb25UeXBlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSA9IHRydWU7XG5cbiAgd2FybmluZyhmYWxzZSwgJ0Z1bmN0aW9ucyBhcmUgbm90IHZhbGlkIGFzIGEgUmVhY3QgY2hpbGQuIFRoaXMgbWF5IGhhcHBlbiBpZiAnICsgJ3lvdSByZXR1cm4gYSBDb21wb25lbnQgaW5zdGVhZCBvZiA8Q29tcG9uZW50IC8+IGZyb20gcmVuZGVyLiAnICsgJ09yIG1heWJlIHlvdSBtZWFudCB0byBjYWxsIHRoaXMgZnVuY3Rpb24gcmF0aGVyIHRoYW4gcmV0dXJuIGl0LiVzJywgZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQxKCkgfHwgJycpO1xufVxuXG4vLyBUaGlzIHdyYXBwZXIgZnVuY3Rpb24gZXhpc3RzIGJlY2F1c2UgSSBleHBlY3QgdG8gY2xvbmUgdGhlIGNvZGUgaW4gZWFjaCBwYXRoXG4vLyB0byBiZSBhYmxlIHRvIG9wdGltaXplIGVhY2ggcGF0aCBpbmRpdmlkdWFsbHkgYnkgYnJhbmNoaW5nIGVhcmx5LiBUaGlzIG5lZWRzXG4vLyBhIGNvbXBpbGVyIG9yIHdlIGNhbiBkbyBpdCBtYW51YWxseS4gSGVscGVycyB0aGF0IGRvbid0IG5lZWQgdGhpcyBicmFuY2hpbmdcbi8vIGxpdmUgb3V0c2lkZSBvZiB0aGlzIGZ1bmN0aW9uLlxuZnVuY3Rpb24gQ2hpbGRSZWNvbmNpbGVyKHNob3VsZFRyYWNrU2lkZUVmZmVjdHMpIHtcbiAgZnVuY3Rpb24gZGVsZXRlQ2hpbGQocmV0dXJuRmliZXIsIGNoaWxkVG9EZWxldGUpIHtcbiAgICBpZiAoIXNob3VsZFRyYWNrU2lkZUVmZmVjdHMpIHtcbiAgICAgIC8vIE5vb3AuXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIERlbGV0aW9ucyBhcmUgYWRkZWQgaW4gcmV2ZXJzZWQgb3JkZXIgc28gd2UgYWRkIGl0IHRvIHRoZSBmcm9udC5cbiAgICAvLyBBdCB0aGlzIHBvaW50LCB0aGUgcmV0dXJuIGZpYmVyJ3MgZWZmZWN0IGxpc3QgaXMgZW1wdHkgZXhjZXB0IGZvclxuICAgIC8vIGRlbGV0aW9ucywgc28gd2UgY2FuIGp1c3QgYXBwZW5kIHRoZSBkZWxldGlvbiB0byB0aGUgbGlzdC4gVGhlIHJlbWFpbmluZ1xuICAgIC8vIGVmZmVjdHMgYXJlbid0IGFkZGVkIHVudGlsIHRoZSBjb21wbGV0ZSBwaGFzZS4gT25jZSB3ZSBpbXBsZW1lbnRcbiAgICAvLyByZXN1bWluZywgdGhpcyBtYXkgbm90IGJlIHRydWUuXG4gICAgdmFyIGxhc3QgPSByZXR1cm5GaWJlci5sYXN0RWZmZWN0O1xuICAgIGlmIChsYXN0ICE9PSBudWxsKSB7XG4gICAgICBsYXN0Lm5leHRFZmZlY3QgPSBjaGlsZFRvRGVsZXRlO1xuICAgICAgcmV0dXJuRmliZXIubGFzdEVmZmVjdCA9IGNoaWxkVG9EZWxldGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybkZpYmVyLmZpcnN0RWZmZWN0ID0gcmV0dXJuRmliZXIubGFzdEVmZmVjdCA9IGNoaWxkVG9EZWxldGU7XG4gICAgfVxuICAgIGNoaWxkVG9EZWxldGUubmV4dEVmZmVjdCA9IG51bGw7XG4gICAgY2hpbGRUb0RlbGV0ZS5lZmZlY3RUYWcgPSBEZWxldGlvbjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCkge1xuICAgIGlmICghc2hvdWxkVHJhY2tTaWRlRWZmZWN0cykge1xuICAgICAgLy8gTm9vcC5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8vIFRPRE86IEZvciB0aGUgc2hvdWxkQ2xvbmUgY2FzZSwgdGhpcyBjb3VsZCBiZSBtaWNyby1vcHRpbWl6ZWQgYSBiaXQgYnlcbiAgICAvLyBhc3N1bWluZyB0aGF0IGFmdGVyIHRoZSBmaXJzdCBjaGlsZCB3ZSd2ZSBhbHJlYWR5IGFkZGVkIGV2ZXJ5dGhpbmcuXG4gICAgdmFyIGNoaWxkVG9EZWxldGUgPSBjdXJyZW50Rmlyc3RDaGlsZDtcbiAgICB3aGlsZSAoY2hpbGRUb0RlbGV0ZSAhPT0gbnVsbCkge1xuICAgICAgZGVsZXRlQ2hpbGQocmV0dXJuRmliZXIsIGNoaWxkVG9EZWxldGUpO1xuICAgICAgY2hpbGRUb0RlbGV0ZSA9IGNoaWxkVG9EZWxldGUuc2libGluZztcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiBtYXBSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQpIHtcbiAgICAvLyBBZGQgdGhlIHJlbWFpbmluZyBjaGlsZHJlbiB0byBhIHRlbXBvcmFyeSBtYXAgc28gdGhhdCB3ZSBjYW4gZmluZCB0aGVtIGJ5XG4gICAgLy8ga2V5cyBxdWlja2x5LiBJbXBsaWNpdCAobnVsbCkga2V5cyBnZXQgYWRkZWQgdG8gdGhpcyBzZXQgd2l0aCB0aGVpciBpbmRleFxuICAgIHZhciBleGlzdGluZ0NoaWxkcmVuID0gbmV3IE1hcCgpO1xuXG4gICAgdmFyIGV4aXN0aW5nQ2hpbGQgPSBjdXJyZW50Rmlyc3RDaGlsZDtcbiAgICB3aGlsZSAoZXhpc3RpbmdDaGlsZCAhPT0gbnVsbCkge1xuICAgICAgaWYgKGV4aXN0aW5nQ2hpbGQua2V5ICE9PSBudWxsKSB7XG4gICAgICAgIGV4aXN0aW5nQ2hpbGRyZW4uc2V0KGV4aXN0aW5nQ2hpbGQua2V5LCBleGlzdGluZ0NoaWxkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGV4aXN0aW5nQ2hpbGRyZW4uc2V0KGV4aXN0aW5nQ2hpbGQuaW5kZXgsIGV4aXN0aW5nQ2hpbGQpO1xuICAgICAgfVxuICAgICAgZXhpc3RpbmdDaGlsZCA9IGV4aXN0aW5nQ2hpbGQuc2libGluZztcbiAgICB9XG4gICAgcmV0dXJuIGV4aXN0aW5nQ2hpbGRyZW47XG4gIH1cblxuICBmdW5jdGlvbiB1c2VGaWJlcihmaWJlciwgcGVuZGluZ1Byb3BzLCBleHBpcmF0aW9uVGltZSkge1xuICAgIC8vIFdlIGN1cnJlbnRseSBzZXQgc2libGluZyB0byBudWxsIGFuZCBpbmRleCB0byAwIGhlcmUgYmVjYXVzZSBpdCBpcyBlYXN5XG4gICAgLy8gdG8gZm9yZ2V0IHRvIGRvIGJlZm9yZSByZXR1cm5pbmcgaXQuIEUuZy4gZm9yIHRoZSBzaW5nbGUgY2hpbGQgY2FzZS5cbiAgICB2YXIgY2xvbmUgPSBjcmVhdGVXb3JrSW5Qcm9ncmVzcyhmaWJlciwgcGVuZGluZ1Byb3BzLCBleHBpcmF0aW9uVGltZSk7XG4gICAgY2xvbmUuaW5kZXggPSAwO1xuICAgIGNsb25lLnNpYmxpbmcgPSBudWxsO1xuICAgIHJldHVybiBjbG9uZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBsYWNlQ2hpbGQobmV3RmliZXIsIGxhc3RQbGFjZWRJbmRleCwgbmV3SW5kZXgpIHtcbiAgICBuZXdGaWJlci5pbmRleCA9IG5ld0luZGV4O1xuICAgIGlmICghc2hvdWxkVHJhY2tTaWRlRWZmZWN0cykge1xuICAgICAgLy8gTm9vcC5cbiAgICAgIHJldHVybiBsYXN0UGxhY2VkSW5kZXg7XG4gICAgfVxuICAgIHZhciBjdXJyZW50ID0gbmV3RmliZXIuYWx0ZXJuYXRlO1xuICAgIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICB2YXIgb2xkSW5kZXggPSBjdXJyZW50LmluZGV4O1xuICAgICAgaWYgKG9sZEluZGV4IDwgbGFzdFBsYWNlZEluZGV4KSB7XG4gICAgICAgIC8vIFRoaXMgaXMgYSBtb3ZlLlxuICAgICAgICBuZXdGaWJlci5lZmZlY3RUYWcgPSBQbGFjZW1lbnQ7XG4gICAgICAgIHJldHVybiBsYXN0UGxhY2VkSW5kZXg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUaGlzIGl0ZW0gY2FuIHN0YXkgaW4gcGxhY2UuXG4gICAgICAgIHJldHVybiBvbGRJbmRleDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhpcyBpcyBhbiBpbnNlcnRpb24uXG4gICAgICBuZXdGaWJlci5lZmZlY3RUYWcgPSBQbGFjZW1lbnQ7XG4gICAgICByZXR1cm4gbGFzdFBsYWNlZEluZGV4O1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHBsYWNlU2luZ2xlQ2hpbGQobmV3RmliZXIpIHtcbiAgICAvLyBUaGlzIGlzIHNpbXBsZXIgZm9yIHRoZSBzaW5nbGUgY2hpbGQgY2FzZS4gV2Ugb25seSBuZWVkIHRvIGRvIGFcbiAgICAvLyBwbGFjZW1lbnQgZm9yIGluc2VydGluZyBuZXcgY2hpbGRyZW4uXG4gICAgaWYgKHNob3VsZFRyYWNrU2lkZUVmZmVjdHMgJiYgbmV3RmliZXIuYWx0ZXJuYXRlID09PSBudWxsKSB7XG4gICAgICBuZXdGaWJlci5lZmZlY3RUYWcgPSBQbGFjZW1lbnQ7XG4gICAgfVxuICAgIHJldHVybiBuZXdGaWJlcjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZVRleHROb2RlKHJldHVybkZpYmVyLCBjdXJyZW50LCB0ZXh0Q29udGVudCwgZXhwaXJhdGlvblRpbWUpIHtcbiAgICBpZiAoY3VycmVudCA9PT0gbnVsbCB8fCBjdXJyZW50LnRhZyAhPT0gSG9zdFRleHQpIHtcbiAgICAgIC8vIEluc2VydFxuICAgICAgdmFyIGNyZWF0ZWQgPSBjcmVhdGVGaWJlckZyb21UZXh0KHRleHRDb250ZW50LCByZXR1cm5GaWJlci5pbnRlcm5hbENvbnRleHRUYWcsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGNyZWF0ZWRbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgICByZXR1cm4gY3JlYXRlZDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVXBkYXRlXG4gICAgICB2YXIgZXhpc3RpbmcgPSB1c2VGaWJlcihjdXJyZW50LCB0ZXh0Q29udGVudCwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgZXhpc3RpbmdbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgICByZXR1cm4gZXhpc3Rpbmc7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlRWxlbWVudChyZXR1cm5GaWJlciwgY3VycmVudCwgZWxlbWVudCwgZXhwaXJhdGlvblRpbWUpIHtcbiAgICBpZiAoY3VycmVudCAhPT0gbnVsbCAmJiBjdXJyZW50LnR5cGUgPT09IGVsZW1lbnQudHlwZSkge1xuICAgICAgLy8gTW92ZSBiYXNlZCBvbiBpbmRleFxuICAgICAgdmFyIGV4aXN0aW5nID0gdXNlRmliZXIoY3VycmVudCwgZWxlbWVudC5wcm9wcywgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgZXhpc3RpbmcucmVmID0gY29lcmNlUmVmKGN1cnJlbnQsIGVsZW1lbnQpO1xuICAgICAgZXhpc3RpbmdbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgICB7XG4gICAgICAgIGV4aXN0aW5nLl9kZWJ1Z1NvdXJjZSA9IGVsZW1lbnQuX3NvdXJjZTtcbiAgICAgICAgZXhpc3RpbmcuX2RlYnVnT3duZXIgPSBlbGVtZW50Ll9vd25lcjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBleGlzdGluZztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSW5zZXJ0XG4gICAgICB2YXIgY3JlYXRlZCA9IGNyZWF0ZUZpYmVyRnJvbUVsZW1lbnQoZWxlbWVudCwgcmV0dXJuRmliZXIuaW50ZXJuYWxDb250ZXh0VGFnLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICBjcmVhdGVkLnJlZiA9IGNvZXJjZVJlZihjdXJyZW50LCBlbGVtZW50KTtcbiAgICAgIGNyZWF0ZWRbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgICByZXR1cm4gY3JlYXRlZDtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVDYWxsKHJldHVybkZpYmVyLCBjdXJyZW50LCBjYWxsLCBleHBpcmF0aW9uVGltZSkge1xuICAgIC8vIFRPRE86IFNob3VsZCB0aGlzIGFsc28gY29tcGFyZSBoYW5kbGVyIHRvIGRldGVybWluZSB3aGV0aGVyIHRvIHJldXNlP1xuICAgIGlmIChjdXJyZW50ID09PSBudWxsIHx8IGN1cnJlbnQudGFnICE9PSBDYWxsQ29tcG9uZW50KSB7XG4gICAgICAvLyBJbnNlcnRcbiAgICAgIHZhciBjcmVhdGVkID0gY3JlYXRlRmliZXJGcm9tQ2FsbChjYWxsLCByZXR1cm5GaWJlci5pbnRlcm5hbENvbnRleHRUYWcsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGNyZWF0ZWRbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgICByZXR1cm4gY3JlYXRlZDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTW92ZSBiYXNlZCBvbiBpbmRleFxuICAgICAgdmFyIGV4aXN0aW5nID0gdXNlRmliZXIoY3VycmVudCwgY2FsbCwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgZXhpc3RpbmdbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgICByZXR1cm4gZXhpc3Rpbmc7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlUmV0dXJuKHJldHVybkZpYmVyLCBjdXJyZW50LCByZXR1cm5Ob2RlLCBleHBpcmF0aW9uVGltZSkge1xuICAgIGlmIChjdXJyZW50ID09PSBudWxsIHx8IGN1cnJlbnQudGFnICE9PSBSZXR1cm5Db21wb25lbnQpIHtcbiAgICAgIC8vIEluc2VydFxuICAgICAgdmFyIGNyZWF0ZWQgPSBjcmVhdGVGaWJlckZyb21SZXR1cm4ocmV0dXJuTm9kZSwgcmV0dXJuRmliZXIuaW50ZXJuYWxDb250ZXh0VGFnLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICBjcmVhdGVkLnR5cGUgPSByZXR1cm5Ob2RlLnZhbHVlO1xuICAgICAgY3JlYXRlZFsncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICAgIHJldHVybiBjcmVhdGVkO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBNb3ZlIGJhc2VkIG9uIGluZGV4XG4gICAgICB2YXIgZXhpc3RpbmcgPSB1c2VGaWJlcihjdXJyZW50LCBudWxsLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICBleGlzdGluZy50eXBlID0gcmV0dXJuTm9kZS52YWx1ZTtcbiAgICAgIGV4aXN0aW5nWydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgICAgcmV0dXJuIGV4aXN0aW5nO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZVBvcnRhbChyZXR1cm5GaWJlciwgY3VycmVudCwgcG9ydGFsLCBleHBpcmF0aW9uVGltZSkge1xuICAgIGlmIChjdXJyZW50ID09PSBudWxsIHx8IGN1cnJlbnQudGFnICE9PSBIb3N0UG9ydGFsIHx8IGN1cnJlbnQuc3RhdGVOb2RlLmNvbnRhaW5lckluZm8gIT09IHBvcnRhbC5jb250YWluZXJJbmZvIHx8IGN1cnJlbnQuc3RhdGVOb2RlLmltcGxlbWVudGF0aW9uICE9PSBwb3J0YWwuaW1wbGVtZW50YXRpb24pIHtcbiAgICAgIC8vIEluc2VydFxuICAgICAgdmFyIGNyZWF0ZWQgPSBjcmVhdGVGaWJlckZyb21Qb3J0YWwocG9ydGFsLCByZXR1cm5GaWJlci5pbnRlcm5hbENvbnRleHRUYWcsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGNyZWF0ZWRbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgICByZXR1cm4gY3JlYXRlZDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVXBkYXRlXG4gICAgICB2YXIgZXhpc3RpbmcgPSB1c2VGaWJlcihjdXJyZW50LCBwb3J0YWwuY2hpbGRyZW4gfHwgW10sIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGV4aXN0aW5nWydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgICAgcmV0dXJuIGV4aXN0aW5nO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUZyYWdtZW50KHJldHVybkZpYmVyLCBjdXJyZW50LCBmcmFnbWVudCwgZXhwaXJhdGlvblRpbWUsIGtleSkge1xuICAgIGlmIChjdXJyZW50ID09PSBudWxsIHx8IGN1cnJlbnQudGFnICE9PSBGcmFnbWVudCkge1xuICAgICAgLy8gSW5zZXJ0XG4gICAgICB2YXIgY3JlYXRlZCA9IGNyZWF0ZUZpYmVyRnJvbUZyYWdtZW50KGZyYWdtZW50LCByZXR1cm5GaWJlci5pbnRlcm5hbENvbnRleHRUYWcsIGV4cGlyYXRpb25UaW1lLCBrZXkpO1xuICAgICAgY3JlYXRlZFsncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICAgIHJldHVybiBjcmVhdGVkO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBVcGRhdGVcbiAgICAgIHZhciBleGlzdGluZyA9IHVzZUZpYmVyKGN1cnJlbnQsIGZyYWdtZW50LCBleHBpcmF0aW9uVGltZSk7XG4gICAgICBleGlzdGluZ1sncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICAgIHJldHVybiBleGlzdGluZztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVDaGlsZChyZXR1cm5GaWJlciwgbmV3Q2hpbGQsIGV4cGlyYXRpb25UaW1lKSB7XG4gICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIG5ld0NoaWxkID09PSAnbnVtYmVyJykge1xuICAgICAgLy8gVGV4dCBub2RlcyBkb24ndCBoYXZlIGtleXMuIElmIHRoZSBwcmV2aW91cyBub2RlIGlzIGltcGxpY2l0bHkga2V5ZWRcbiAgICAgIC8vIHdlIGNhbiBjb250aW51ZSB0byByZXBsYWNlIGl0IHdpdGhvdXQgYWJvcnRpbmcgZXZlbiBpZiBpdCBpcyBub3QgYSB0ZXh0XG4gICAgICAvLyBub2RlLlxuICAgICAgdmFyIGNyZWF0ZWQgPSBjcmVhdGVGaWJlckZyb21UZXh0KCcnICsgbmV3Q2hpbGQsIHJldHVybkZpYmVyLmludGVybmFsQ29udGV4dFRhZywgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgY3JlYXRlZFsncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICAgIHJldHVybiBjcmVhdGVkO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09ICdvYmplY3QnICYmIG5ld0NoaWxkICE9PSBudWxsKSB7XG4gICAgICBzd2l0Y2ggKG5ld0NoaWxkLiQkdHlwZW9mKSB7XG4gICAgICAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmIChuZXdDaGlsZC50eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFKSB7XG4gICAgICAgICAgICAgIHZhciBfY3JlYXRlZCA9IGNyZWF0ZUZpYmVyRnJvbUZyYWdtZW50KG5ld0NoaWxkLnByb3BzLmNoaWxkcmVuLCByZXR1cm5GaWJlci5pbnRlcm5hbENvbnRleHRUYWcsIGV4cGlyYXRpb25UaW1lLCBuZXdDaGlsZC5rZXkpO1xuICAgICAgICAgICAgICBfY3JlYXRlZFsncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICAgICAgICAgICAgcmV0dXJuIF9jcmVhdGVkO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIF9jcmVhdGVkMiA9IGNyZWF0ZUZpYmVyRnJvbUVsZW1lbnQobmV3Q2hpbGQsIHJldHVybkZpYmVyLmludGVybmFsQ29udGV4dFRhZywgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgICAgICAgICBfY3JlYXRlZDIucmVmID0gY29lcmNlUmVmKG51bGwsIG5ld0NoaWxkKTtcbiAgICAgICAgICAgICAgX2NyZWF0ZWQyWydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgICAgICAgICAgICByZXR1cm4gX2NyZWF0ZWQyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlIFJFQUNUX0NBTExfVFlQRTpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgX2NyZWF0ZWQzID0gY3JlYXRlRmliZXJGcm9tQ2FsbChuZXdDaGlsZCwgcmV0dXJuRmliZXIuaW50ZXJuYWxDb250ZXh0VGFnLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICAgICAgICBfY3JlYXRlZDNbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgICAgICAgICByZXR1cm4gX2NyZWF0ZWQzO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlIFJFQUNUX1JFVFVSTl9UWVBFOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBfY3JlYXRlZDQgPSBjcmVhdGVGaWJlckZyb21SZXR1cm4obmV3Q2hpbGQsIHJldHVybkZpYmVyLmludGVybmFsQ29udGV4dFRhZywgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgICAgICAgX2NyZWF0ZWQ0LnR5cGUgPSBuZXdDaGlsZC52YWx1ZTtcbiAgICAgICAgICAgIF9jcmVhdGVkNFsncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICAgICAgICAgIHJldHVybiBfY3JlYXRlZDQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIF9jcmVhdGVkNSA9IGNyZWF0ZUZpYmVyRnJvbVBvcnRhbChuZXdDaGlsZCwgcmV0dXJuRmliZXIuaW50ZXJuYWxDb250ZXh0VGFnLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICAgICAgICBfY3JlYXRlZDVbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgICAgICAgICByZXR1cm4gX2NyZWF0ZWQ1O1xuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGlzQXJyYXkkMShuZXdDaGlsZCkgfHwgZ2V0SXRlcmF0b3JGbihuZXdDaGlsZCkpIHtcbiAgICAgICAgdmFyIF9jcmVhdGVkNiA9IGNyZWF0ZUZpYmVyRnJvbUZyYWdtZW50KG5ld0NoaWxkLCByZXR1cm5GaWJlci5pbnRlcm5hbENvbnRleHRUYWcsIGV4cGlyYXRpb25UaW1lLCBudWxsKTtcbiAgICAgICAgX2NyZWF0ZWQ2WydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgICAgICByZXR1cm4gX2NyZWF0ZWQ2O1xuICAgICAgfVxuXG4gICAgICB0aHJvd09uSW52YWxpZE9iamVjdFR5cGUocmV0dXJuRmliZXIsIG5ld0NoaWxkKTtcbiAgICB9XG5cbiAgICB7XG4gICAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHdhcm5PbkZ1bmN0aW9uVHlwZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlU2xvdChyZXR1cm5GaWJlciwgb2xkRmliZXIsIG5ld0NoaWxkLCBleHBpcmF0aW9uVGltZSkge1xuICAgIC8vIFVwZGF0ZSB0aGUgZmliZXIgaWYgdGhlIGtleXMgbWF0Y2gsIG90aGVyd2lzZSByZXR1cm4gbnVsbC5cblxuICAgIHZhciBrZXkgPSBvbGRGaWJlciAhPT0gbnVsbCA/IG9sZEZpYmVyLmtleSA6IG51bGw7XG5cbiAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgbmV3Q2hpbGQgPT09ICdudW1iZXInKSB7XG4gICAgICAvLyBUZXh0IG5vZGVzIGRvbid0IGhhdmUga2V5cy4gSWYgdGhlIHByZXZpb3VzIG5vZGUgaXMgaW1wbGljaXRseSBrZXllZFxuICAgICAgLy8gd2UgY2FuIGNvbnRpbnVlIHRvIHJlcGxhY2UgaXQgd2l0aG91dCBhYm9ydGluZyBldmVuIGlmIGl0IGlzIG5vdCBhIHRleHRcbiAgICAgIC8vIG5vZGUuXG4gICAgICBpZiAoa2V5ICE9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHVwZGF0ZVRleHROb2RlKHJldHVybkZpYmVyLCBvbGRGaWJlciwgJycgKyBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09ICdvYmplY3QnICYmIG5ld0NoaWxkICE9PSBudWxsKSB7XG4gICAgICBzd2l0Y2ggKG5ld0NoaWxkLiQkdHlwZW9mKSB7XG4gICAgICAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmIChuZXdDaGlsZC5rZXkgPT09IGtleSkge1xuICAgICAgICAgICAgICBpZiAobmV3Q2hpbGQudHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB1cGRhdGVGcmFnbWVudChyZXR1cm5GaWJlciwgb2xkRmliZXIsIG5ld0NoaWxkLnByb3BzLmNoaWxkcmVuLCBleHBpcmF0aW9uVGltZSwga2V5KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gdXBkYXRlRWxlbWVudChyZXR1cm5GaWJlciwgb2xkRmliZXIsIG5ld0NoaWxkLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSBSRUFDVF9DQUxMX1RZUEU6XG4gICAgICAgICAge1xuICAgICAgICAgICAgaWYgKG5ld0NoaWxkLmtleSA9PT0ga2V5KSB7XG4gICAgICAgICAgICAgIHJldHVybiB1cGRhdGVDYWxsKHJldHVybkZpYmVyLCBvbGRGaWJlciwgbmV3Q2hpbGQsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlIFJFQUNUX1JFVFVSTl9UWVBFOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIC8vIFJldHVybnMgZG9uJ3QgaGF2ZSBrZXlzLiBJZiB0aGUgcHJldmlvdXMgbm9kZSBpcyBpbXBsaWNpdGx5IGtleWVkXG4gICAgICAgICAgICAvLyB3ZSBjYW4gY29udGludWUgdG8gcmVwbGFjZSBpdCB3aXRob3V0IGFib3J0aW5nIGV2ZW4gaWYgaXQgaXMgbm90IGFcbiAgICAgICAgICAgIC8vIHlpZWxkLlxuICAgICAgICAgICAgaWYgKGtleSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICByZXR1cm4gdXBkYXRlUmV0dXJuKHJldHVybkZpYmVyLCBvbGRGaWJlciwgbmV3Q2hpbGQsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmIChuZXdDaGlsZC5rZXkgPT09IGtleSkge1xuICAgICAgICAgICAgICByZXR1cm4gdXBkYXRlUG9ydGFsKHJldHVybkZpYmVyLCBvbGRGaWJlciwgbmV3Q2hpbGQsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGlzQXJyYXkkMShuZXdDaGlsZCkgfHwgZ2V0SXRlcmF0b3JGbihuZXdDaGlsZCkpIHtcbiAgICAgICAgaWYgKGtleSAhPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHVwZGF0ZUZyYWdtZW50KHJldHVybkZpYmVyLCBvbGRGaWJlciwgbmV3Q2hpbGQsIGV4cGlyYXRpb25UaW1lLCBudWxsKTtcbiAgICAgIH1cblxuICAgICAgdGhyb3dPbkludmFsaWRPYmplY3RUeXBlKHJldHVybkZpYmVyLCBuZXdDaGlsZCk7XG4gICAgfVxuXG4gICAge1xuICAgICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB3YXJuT25GdW5jdGlvblR5cGUoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUZyb21NYXAoZXhpc3RpbmdDaGlsZHJlbiwgcmV0dXJuRmliZXIsIG5ld0lkeCwgbmV3Q2hpbGQsIGV4cGlyYXRpb25UaW1lKSB7XG4gICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIG5ld0NoaWxkID09PSAnbnVtYmVyJykge1xuICAgICAgLy8gVGV4dCBub2RlcyBkb24ndCBoYXZlIGtleXMsIHNvIHdlIG5laXRoZXIgaGF2ZSB0byBjaGVjayB0aGUgb2xkIG5vclxuICAgICAgLy8gbmV3IG5vZGUgZm9yIHRoZSBrZXkuIElmIGJvdGggYXJlIHRleHQgbm9kZXMsIHRoZXkgbWF0Y2guXG4gICAgICB2YXIgbWF0Y2hlZEZpYmVyID0gZXhpc3RpbmdDaGlsZHJlbi5nZXQobmV3SWR4KSB8fCBudWxsO1xuICAgICAgcmV0dXJuIHVwZGF0ZVRleHROb2RlKHJldHVybkZpYmVyLCBtYXRjaGVkRmliZXIsICcnICsgbmV3Q2hpbGQsIGV4cGlyYXRpb25UaW1lKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnb2JqZWN0JyAmJiBuZXdDaGlsZCAhPT0gbnVsbCkge1xuICAgICAgc3dpdGNoIChuZXdDaGlsZC4kJHR5cGVvZikge1xuICAgICAgICBjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRTpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgX21hdGNoZWRGaWJlciA9IGV4aXN0aW5nQ2hpbGRyZW4uZ2V0KG5ld0NoaWxkLmtleSA9PT0gbnVsbCA/IG5ld0lkeCA6IG5ld0NoaWxkLmtleSkgfHwgbnVsbDtcbiAgICAgICAgICAgIGlmIChuZXdDaGlsZC50eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFKSB7XG4gICAgICAgICAgICAgIHJldHVybiB1cGRhdGVGcmFnbWVudChyZXR1cm5GaWJlciwgX21hdGNoZWRGaWJlciwgbmV3Q2hpbGQucHJvcHMuY2hpbGRyZW4sIGV4cGlyYXRpb25UaW1lLCBuZXdDaGlsZC5rZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZUVsZW1lbnQocmV0dXJuRmliZXIsIF9tYXRjaGVkRmliZXIsIG5ld0NoaWxkLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgUkVBQ1RfQ0FMTF9UWVBFOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBfbWF0Y2hlZEZpYmVyMiA9IGV4aXN0aW5nQ2hpbGRyZW4uZ2V0KG5ld0NoaWxkLmtleSA9PT0gbnVsbCA/IG5ld0lkeCA6IG5ld0NoaWxkLmtleSkgfHwgbnVsbDtcbiAgICAgICAgICAgIHJldHVybiB1cGRhdGVDYWxsKHJldHVybkZpYmVyLCBfbWF0Y2hlZEZpYmVyMiwgbmV3Q2hpbGQsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSBSRUFDVF9SRVRVUk5fVFlQRTpcbiAgICAgICAgICB7XG4gICAgICAgICAgICAvLyBSZXR1cm5zIGRvbid0IGhhdmUga2V5cywgc28gd2UgbmVpdGhlciBoYXZlIHRvIGNoZWNrIHRoZSBvbGQgbm9yXG4gICAgICAgICAgICAvLyBuZXcgbm9kZSBmb3IgdGhlIGtleS4gSWYgYm90aCBhcmUgcmV0dXJucywgdGhleSBtYXRjaC5cbiAgICAgICAgICAgIHZhciBfbWF0Y2hlZEZpYmVyMyA9IGV4aXN0aW5nQ2hpbGRyZW4uZ2V0KG5ld0lkeCkgfHwgbnVsbDtcbiAgICAgICAgICAgIHJldHVybiB1cGRhdGVSZXR1cm4ocmV0dXJuRmliZXIsIF9tYXRjaGVkRmliZXIzLCBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBfbWF0Y2hlZEZpYmVyNCA9IGV4aXN0aW5nQ2hpbGRyZW4uZ2V0KG5ld0NoaWxkLmtleSA9PT0gbnVsbCA/IG5ld0lkeCA6IG5ld0NoaWxkLmtleSkgfHwgbnVsbDtcbiAgICAgICAgICAgIHJldHVybiB1cGRhdGVQb3J0YWwocmV0dXJuRmliZXIsIF9tYXRjaGVkRmliZXI0LCBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGlzQXJyYXkkMShuZXdDaGlsZCkgfHwgZ2V0SXRlcmF0b3JGbihuZXdDaGlsZCkpIHtcbiAgICAgICAgdmFyIF9tYXRjaGVkRmliZXI1ID0gZXhpc3RpbmdDaGlsZHJlbi5nZXQobmV3SWR4KSB8fCBudWxsO1xuICAgICAgICByZXR1cm4gdXBkYXRlRnJhZ21lbnQocmV0dXJuRmliZXIsIF9tYXRjaGVkRmliZXI1LCBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUsIG51bGwpO1xuICAgICAgfVxuXG4gICAgICB0aHJvd09uSW52YWxpZE9iamVjdFR5cGUocmV0dXJuRmliZXIsIG5ld0NoaWxkKTtcbiAgICB9XG5cbiAgICB7XG4gICAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHdhcm5PbkZ1bmN0aW9uVHlwZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIFdhcm5zIGlmIHRoZXJlIGlzIGEgZHVwbGljYXRlIG9yIG1pc3Npbmcga2V5XG4gICAqL1xuICBmdW5jdGlvbiB3YXJuT25JbnZhbGlkS2V5KGNoaWxkLCBrbm93bktleXMpIHtcbiAgICB7XG4gICAgICBpZiAodHlwZW9mIGNoaWxkICE9PSAnb2JqZWN0JyB8fCBjaGlsZCA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4ga25vd25LZXlzO1xuICAgICAgfVxuICAgICAgc3dpdGNoIChjaGlsZC4kJHR5cGVvZikge1xuICAgICAgICBjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRTpcbiAgICAgICAgY2FzZSBSRUFDVF9DQUxMX1RZUEU6XG4gICAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICAgICAgd2FybkZvck1pc3NpbmdLZXkoY2hpbGQpO1xuICAgICAgICAgIHZhciBrZXkgPSBjaGlsZC5rZXk7XG4gICAgICAgICAgaWYgKHR5cGVvZiBrZXkgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGtub3duS2V5cyA9PT0gbnVsbCkge1xuICAgICAgICAgICAga25vd25LZXlzID0gbmV3IFNldCgpO1xuICAgICAgICAgICAga25vd25LZXlzLmFkZChrZXkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICgha25vd25LZXlzLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICBrbm93bktleXMuYWRkKGtleSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgd2FybmluZyhmYWxzZSwgJ0VuY291bnRlcmVkIHR3byBjaGlsZHJlbiB3aXRoIHRoZSBzYW1lIGtleSwgYCVzYC4gJyArICdLZXlzIHNob3VsZCBiZSB1bmlxdWUgc28gdGhhdCBjb21wb25lbnRzIG1haW50YWluIHRoZWlyIGlkZW50aXR5ICcgKyAnYWNyb3NzIHVwZGF0ZXMuIE5vbi11bmlxdWUga2V5cyBtYXkgY2F1c2UgY2hpbGRyZW4gdG8gYmUgJyArICdkdXBsaWNhdGVkIGFuZC9vciBvbWl0dGVkIOKAlCB0aGUgYmVoYXZpb3IgaXMgdW5zdXBwb3J0ZWQgYW5kICcgKyAnY291bGQgY2hhbmdlIGluIGEgZnV0dXJlIHZlcnNpb24uJXMnLCBrZXksIGdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW0kMSgpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGtub3duS2V5cztcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlY29uY2lsZUNoaWxkcmVuQXJyYXkocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBuZXdDaGlsZHJlbiwgZXhwaXJhdGlvblRpbWUpIHtcbiAgICAvLyBUaGlzIGFsZ29yaXRobSBjYW4ndCBvcHRpbWl6ZSBieSBzZWFyY2hpbmcgZnJvbSBib3RocyBlbmRzIHNpbmNlIHdlXG4gICAgLy8gZG9uJ3QgaGF2ZSBiYWNrcG9pbnRlcnMgb24gZmliZXJzLiBJJ20gdHJ5aW5nIHRvIHNlZSBob3cgZmFyIHdlIGNhbiBnZXRcbiAgICAvLyB3aXRoIHRoYXQgbW9kZWwuIElmIGl0IGVuZHMgdXAgbm90IGJlaW5nIHdvcnRoIHRoZSB0cmFkZW9mZnMsIHdlIGNhblxuICAgIC8vIGFkZCBpdCBsYXRlci5cblxuICAgIC8vIEV2ZW4gd2l0aCBhIHR3byBlbmRlZCBvcHRpbWl6YXRpb24sIHdlJ2Qgd2FudCB0byBvcHRpbWl6ZSBmb3IgdGhlIGNhc2VcbiAgICAvLyB3aGVyZSB0aGVyZSBhcmUgZmV3IGNoYW5nZXMgYW5kIGJydXRlIGZvcmNlIHRoZSBjb21wYXJpc29uIGluc3RlYWQgb2ZcbiAgICAvLyBnb2luZyBmb3IgdGhlIE1hcC4gSXQnZCBsaWtlIHRvIGV4cGxvcmUgaGl0dGluZyB0aGF0IHBhdGggZmlyc3QgaW5cbiAgICAvLyBmb3J3YXJkLW9ubHkgbW9kZSBhbmQgb25seSBnbyBmb3IgdGhlIE1hcCBvbmNlIHdlIG5vdGljZSB0aGF0IHdlIG5lZWRcbiAgICAvLyBsb3RzIG9mIGxvb2sgYWhlYWQuIFRoaXMgZG9lc24ndCBoYW5kbGUgcmV2ZXJzYWwgYXMgd2VsbCBhcyB0d28gZW5kZWRcbiAgICAvLyBzZWFyY2ggYnV0IHRoYXQncyB1bnVzdWFsLiBCZXNpZGVzLCBmb3IgdGhlIHR3byBlbmRlZCBvcHRpbWl6YXRpb24gdG9cbiAgICAvLyB3b3JrIG9uIEl0ZXJhYmxlcywgd2UnZCBuZWVkIHRvIGNvcHkgdGhlIHdob2xlIHNldC5cblxuICAgIC8vIEluIHRoaXMgZmlyc3QgaXRlcmF0aW9uLCB3ZSdsbCBqdXN0IGxpdmUgd2l0aCBoaXR0aW5nIHRoZSBiYWQgY2FzZVxuICAgIC8vIChhZGRpbmcgZXZlcnl0aGluZyB0byBhIE1hcCkgaW4gZm9yIGV2ZXJ5IGluc2VydC9tb3ZlLlxuXG4gICAgLy8gSWYgeW91IGNoYW5nZSB0aGlzIGNvZGUsIGFsc28gdXBkYXRlIHJlY29uY2lsZUNoaWxkcmVuSXRlcmF0b3IoKSB3aGljaFxuICAgIC8vIHVzZXMgdGhlIHNhbWUgYWxnb3JpdGhtLlxuXG4gICAge1xuICAgICAgLy8gRmlyc3QsIHZhbGlkYXRlIGtleXMuXG4gICAgICB2YXIga25vd25LZXlzID0gbnVsbDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmV3Q2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNoaWxkID0gbmV3Q2hpbGRyZW5baV07XG4gICAgICAgIGtub3duS2V5cyA9IHdhcm5PbkludmFsaWRLZXkoY2hpbGQsIGtub3duS2V5cyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHJlc3VsdGluZ0ZpcnN0Q2hpbGQgPSBudWxsO1xuICAgIHZhciBwcmV2aW91c05ld0ZpYmVyID0gbnVsbDtcblxuICAgIHZhciBvbGRGaWJlciA9IGN1cnJlbnRGaXJzdENoaWxkO1xuICAgIHZhciBsYXN0UGxhY2VkSW5kZXggPSAwO1xuICAgIHZhciBuZXdJZHggPSAwO1xuICAgIHZhciBuZXh0T2xkRmliZXIgPSBudWxsO1xuICAgIGZvciAoOyBvbGRGaWJlciAhPT0gbnVsbCAmJiBuZXdJZHggPCBuZXdDaGlsZHJlbi5sZW5ndGg7IG5ld0lkeCsrKSB7XG4gICAgICBpZiAob2xkRmliZXIuaW5kZXggPiBuZXdJZHgpIHtcbiAgICAgICAgbmV4dE9sZEZpYmVyID0gb2xkRmliZXI7XG4gICAgICAgIG9sZEZpYmVyID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5leHRPbGRGaWJlciA9IG9sZEZpYmVyLnNpYmxpbmc7XG4gICAgICB9XG4gICAgICB2YXIgbmV3RmliZXIgPSB1cGRhdGVTbG90KHJldHVybkZpYmVyLCBvbGRGaWJlciwgbmV3Q2hpbGRyZW5bbmV3SWR4XSwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgaWYgKG5ld0ZpYmVyID09PSBudWxsKSB7XG4gICAgICAgIC8vIFRPRE86IFRoaXMgYnJlYWtzIG9uIGVtcHR5IHNsb3RzIGxpa2UgbnVsbCBjaGlsZHJlbi4gVGhhdCdzXG4gICAgICAgIC8vIHVuZm9ydHVuYXRlIGJlY2F1c2UgaXQgdHJpZ2dlcnMgdGhlIHNsb3cgcGF0aCBhbGwgdGhlIHRpbWUuIFdlIG5lZWRcbiAgICAgICAgLy8gYSBiZXR0ZXIgd2F5IHRvIGNvbW11bmljYXRlIHdoZXRoZXIgdGhpcyB3YXMgYSBtaXNzIG9yIG51bGwsXG4gICAgICAgIC8vIGJvb2xlYW4sIHVuZGVmaW5lZCwgZXRjLlxuICAgICAgICBpZiAob2xkRmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgICBvbGRGaWJlciA9IG5leHRPbGRGaWJlcjtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChzaG91bGRUcmFja1NpZGVFZmZlY3RzKSB7XG4gICAgICAgIGlmIChvbGRGaWJlciAmJiBuZXdGaWJlci5hbHRlcm5hdGUgPT09IG51bGwpIHtcbiAgICAgICAgICAvLyBXZSBtYXRjaGVkIHRoZSBzbG90LCBidXQgd2UgZGlkbid0IHJldXNlIHRoZSBleGlzdGluZyBmaWJlciwgc28gd2VcbiAgICAgICAgICAvLyBuZWVkIHRvIGRlbGV0ZSB0aGUgZXhpc3RpbmcgY2hpbGQuXG4gICAgICAgICAgZGVsZXRlQ2hpbGQocmV0dXJuRmliZXIsIG9sZEZpYmVyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbGFzdFBsYWNlZEluZGV4ID0gcGxhY2VDaGlsZChuZXdGaWJlciwgbGFzdFBsYWNlZEluZGV4LCBuZXdJZHgpO1xuICAgICAgaWYgKHByZXZpb3VzTmV3RmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgLy8gVE9ETzogTW92ZSBvdXQgb2YgdGhlIGxvb3AuIFRoaXMgb25seSBoYXBwZW5zIGZvciB0aGUgZmlyc3QgcnVuLlxuICAgICAgICByZXN1bHRpbmdGaXJzdENoaWxkID0gbmV3RmliZXI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUT0RPOiBEZWZlciBzaWJsaW5ncyBpZiB3ZSdyZSBub3QgYXQgdGhlIHJpZ2h0IGluZGV4IGZvciB0aGlzIHNsb3QuXG4gICAgICAgIC8vIEkuZS4gaWYgd2UgaGFkIG51bGwgdmFsdWVzIGJlZm9yZSwgdGhlbiB3ZSB3YW50IHRvIGRlZmVyIHRoaXNcbiAgICAgICAgLy8gZm9yIGVhY2ggbnVsbCB2YWx1ZS4gSG93ZXZlciwgd2UgYWxzbyBkb24ndCB3YW50IHRvIGNhbGwgdXBkYXRlU2xvdFxuICAgICAgICAvLyB3aXRoIHRoZSBwcmV2aW91cyBvbmUuXG4gICAgICAgIHByZXZpb3VzTmV3RmliZXIuc2libGluZyA9IG5ld0ZpYmVyO1xuICAgICAgfVxuICAgICAgcHJldmlvdXNOZXdGaWJlciA9IG5ld0ZpYmVyO1xuICAgICAgb2xkRmliZXIgPSBuZXh0T2xkRmliZXI7XG4gICAgfVxuXG4gICAgaWYgKG5ld0lkeCA9PT0gbmV3Q2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAvLyBXZSd2ZSByZWFjaGVkIHRoZSBlbmQgb2YgdGhlIG5ldyBjaGlsZHJlbi4gV2UgY2FuIGRlbGV0ZSB0aGUgcmVzdC5cbiAgICAgIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBvbGRGaWJlcik7XG4gICAgICByZXR1cm4gcmVzdWx0aW5nRmlyc3RDaGlsZDtcbiAgICB9XG5cbiAgICBpZiAob2xkRmliZXIgPT09IG51bGwpIHtcbiAgICAgIC8vIElmIHdlIGRvbid0IGhhdmUgYW55IG1vcmUgZXhpc3RpbmcgY2hpbGRyZW4gd2UgY2FuIGNob29zZSBhIGZhc3QgcGF0aFxuICAgICAgLy8gc2luY2UgdGhlIHJlc3Qgd2lsbCBhbGwgYmUgaW5zZXJ0aW9ucy5cbiAgICAgIGZvciAoOyBuZXdJZHggPCBuZXdDaGlsZHJlbi5sZW5ndGg7IG5ld0lkeCsrKSB7XG4gICAgICAgIHZhciBfbmV3RmliZXIgPSBjcmVhdGVDaGlsZChyZXR1cm5GaWJlciwgbmV3Q2hpbGRyZW5bbmV3SWR4XSwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgICBpZiAoIV9uZXdGaWJlcikge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGxhc3RQbGFjZWRJbmRleCA9IHBsYWNlQ2hpbGQoX25ld0ZpYmVyLCBsYXN0UGxhY2VkSW5kZXgsIG5ld0lkeCk7XG4gICAgICAgIGlmIChwcmV2aW91c05ld0ZpYmVyID09PSBudWxsKSB7XG4gICAgICAgICAgLy8gVE9ETzogTW92ZSBvdXQgb2YgdGhlIGxvb3AuIFRoaXMgb25seSBoYXBwZW5zIGZvciB0aGUgZmlyc3QgcnVuLlxuICAgICAgICAgIHJlc3VsdGluZ0ZpcnN0Q2hpbGQgPSBfbmV3RmliZXI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJldmlvdXNOZXdGaWJlci5zaWJsaW5nID0gX25ld0ZpYmVyO1xuICAgICAgICB9XG4gICAgICAgIHByZXZpb3VzTmV3RmliZXIgPSBfbmV3RmliZXI7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0aW5nRmlyc3RDaGlsZDtcbiAgICB9XG5cbiAgICAvLyBBZGQgYWxsIGNoaWxkcmVuIHRvIGEga2V5IG1hcCBmb3IgcXVpY2sgbG9va3Vwcy5cbiAgICB2YXIgZXhpc3RpbmdDaGlsZHJlbiA9IG1hcFJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBvbGRGaWJlcik7XG5cbiAgICAvLyBLZWVwIHNjYW5uaW5nIGFuZCB1c2UgdGhlIG1hcCB0byByZXN0b3JlIGRlbGV0ZWQgaXRlbXMgYXMgbW92ZXMuXG4gICAgZm9yICg7IG5ld0lkeCA8IG5ld0NoaWxkcmVuLmxlbmd0aDsgbmV3SWR4KyspIHtcbiAgICAgIHZhciBfbmV3RmliZXIyID0gdXBkYXRlRnJvbU1hcChleGlzdGluZ0NoaWxkcmVuLCByZXR1cm5GaWJlciwgbmV3SWR4LCBuZXdDaGlsZHJlbltuZXdJZHhdLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICBpZiAoX25ld0ZpYmVyMikge1xuICAgICAgICBpZiAoc2hvdWxkVHJhY2tTaWRlRWZmZWN0cykge1xuICAgICAgICAgIGlmIChfbmV3RmliZXIyLmFsdGVybmF0ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gVGhlIG5ldyBmaWJlciBpcyBhIHdvcmsgaW4gcHJvZ3Jlc3MsIGJ1dCBpZiB0aGVyZSBleGlzdHMgYVxuICAgICAgICAgICAgLy8gY3VycmVudCwgdGhhdCBtZWFucyB0aGF0IHdlIHJldXNlZCB0aGUgZmliZXIuIFdlIG5lZWQgdG8gZGVsZXRlXG4gICAgICAgICAgICAvLyBpdCBmcm9tIHRoZSBjaGlsZCBsaXN0IHNvIHRoYXQgd2UgZG9uJ3QgYWRkIGl0IHRvIHRoZSBkZWxldGlvblxuICAgICAgICAgICAgLy8gbGlzdC5cbiAgICAgICAgICAgIGV4aXN0aW5nQ2hpbGRyZW5bJ2RlbGV0ZSddKF9uZXdGaWJlcjIua2V5ID09PSBudWxsID8gbmV3SWR4IDogX25ld0ZpYmVyMi5rZXkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsYXN0UGxhY2VkSW5kZXggPSBwbGFjZUNoaWxkKF9uZXdGaWJlcjIsIGxhc3RQbGFjZWRJbmRleCwgbmV3SWR4KTtcbiAgICAgICAgaWYgKHByZXZpb3VzTmV3RmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgICByZXN1bHRpbmdGaXJzdENoaWxkID0gX25ld0ZpYmVyMjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcmV2aW91c05ld0ZpYmVyLnNpYmxpbmcgPSBfbmV3RmliZXIyO1xuICAgICAgICB9XG4gICAgICAgIHByZXZpb3VzTmV3RmliZXIgPSBfbmV3RmliZXIyO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzaG91bGRUcmFja1NpZGVFZmZlY3RzKSB7XG4gICAgICAvLyBBbnkgZXhpc3RpbmcgY2hpbGRyZW4gdGhhdCB3ZXJlbid0IGNvbnN1bWVkIGFib3ZlIHdlcmUgZGVsZXRlZC4gV2UgbmVlZFxuICAgICAgLy8gdG8gYWRkIHRoZW0gdG8gdGhlIGRlbGV0aW9uIGxpc3QuXG4gICAgICBleGlzdGluZ0NoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgIHJldHVybiBkZWxldGVDaGlsZChyZXR1cm5GaWJlciwgY2hpbGQpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdGluZ0ZpcnN0Q2hpbGQ7XG4gIH1cblxuICBmdW5jdGlvbiByZWNvbmNpbGVDaGlsZHJlbkl0ZXJhdG9yKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgbmV3Q2hpbGRyZW5JdGVyYWJsZSwgZXhwaXJhdGlvblRpbWUpIHtcbiAgICAvLyBUaGlzIGlzIHRoZSBzYW1lIGltcGxlbWVudGF0aW9uIGFzIHJlY29uY2lsZUNoaWxkcmVuQXJyYXkoKSxcbiAgICAvLyBidXQgdXNpbmcgdGhlIGl0ZXJhdG9yIGluc3RlYWQuXG5cbiAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4obmV3Q2hpbGRyZW5JdGVyYWJsZSk7XG4gICAgISh0eXBlb2YgaXRlcmF0b3JGbiA9PT0gJ2Z1bmN0aW9uJykgPyBpbnZhcmlhbnQoZmFsc2UsICdBbiBvYmplY3QgaXMgbm90IGFuIGl0ZXJhYmxlLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuXG4gICAge1xuICAgICAgLy8gV2FybiBhYm91dCB1c2luZyBNYXBzIGFzIGNoaWxkcmVuXG4gICAgICBpZiAodHlwZW9mIG5ld0NoaWxkcmVuSXRlcmFibGUuZW50cmllcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB2YXIgcG9zc2libGVNYXAgPSBuZXdDaGlsZHJlbkl0ZXJhYmxlO1xuICAgICAgICBpZiAocG9zc2libGVNYXAuZW50cmllcyA9PT0gaXRlcmF0b3JGbikge1xuICAgICAgICAgIHdhcm5pbmcoZGlkV2FybkFib3V0TWFwcywgJ1VzaW5nIE1hcHMgYXMgY2hpbGRyZW4gaXMgdW5zdXBwb3J0ZWQgYW5kIHdpbGwgbGlrZWx5IHlpZWxkICcgKyAndW5leHBlY3RlZCByZXN1bHRzLiBDb252ZXJ0IGl0IHRvIGEgc2VxdWVuY2UvaXRlcmFibGUgb2Yga2V5ZWQgJyArICdSZWFjdEVsZW1lbnRzIGluc3RlYWQuJXMnLCBnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtJDEoKSk7XG4gICAgICAgICAgZGlkV2FybkFib3V0TWFwcyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gRmlyc3QsIHZhbGlkYXRlIGtleXMuXG4gICAgICAvLyBXZSdsbCBnZXQgYSBkaWZmZXJlbnQgaXRlcmF0b3IgbGF0ZXIgZm9yIHRoZSBtYWluIHBhc3MuXG4gICAgICB2YXIgX25ld0NoaWxkcmVuID0gaXRlcmF0b3JGbi5jYWxsKG5ld0NoaWxkcmVuSXRlcmFibGUpO1xuICAgICAgaWYgKF9uZXdDaGlsZHJlbikge1xuICAgICAgICB2YXIga25vd25LZXlzID0gbnVsbDtcbiAgICAgICAgdmFyIF9zdGVwID0gX25ld0NoaWxkcmVuLm5leHQoKTtcbiAgICAgICAgZm9yICg7ICFfc3RlcC5kb25lOyBfc3RlcCA9IF9uZXdDaGlsZHJlbi5uZXh0KCkpIHtcbiAgICAgICAgICB2YXIgY2hpbGQgPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgICBrbm93bktleXMgPSB3YXJuT25JbnZhbGlkS2V5KGNoaWxkLCBrbm93bktleXMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIG5ld0NoaWxkcmVuID0gaXRlcmF0b3JGbi5jYWxsKG5ld0NoaWxkcmVuSXRlcmFibGUpO1xuICAgICEobmV3Q2hpbGRyZW4gIT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdBbiBpdGVyYWJsZSBvYmplY3QgcHJvdmlkZWQgbm8gaXRlcmF0b3IuJykgOiB2b2lkIDA7XG5cbiAgICB2YXIgcmVzdWx0aW5nRmlyc3RDaGlsZCA9IG51bGw7XG4gICAgdmFyIHByZXZpb3VzTmV3RmliZXIgPSBudWxsO1xuXG4gICAgdmFyIG9sZEZpYmVyID0gY3VycmVudEZpcnN0Q2hpbGQ7XG4gICAgdmFyIGxhc3RQbGFjZWRJbmRleCA9IDA7XG4gICAgdmFyIG5ld0lkeCA9IDA7XG4gICAgdmFyIG5leHRPbGRGaWJlciA9IG51bGw7XG5cbiAgICB2YXIgc3RlcCA9IG5ld0NoaWxkcmVuLm5leHQoKTtcbiAgICBmb3IgKDsgb2xkRmliZXIgIT09IG51bGwgJiYgIXN0ZXAuZG9uZTsgbmV3SWR4KyssIHN0ZXAgPSBuZXdDaGlsZHJlbi5uZXh0KCkpIHtcbiAgICAgIGlmIChvbGRGaWJlci5pbmRleCA+IG5ld0lkeCkge1xuICAgICAgICBuZXh0T2xkRmliZXIgPSBvbGRGaWJlcjtcbiAgICAgICAgb2xkRmliZXIgPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV4dE9sZEZpYmVyID0gb2xkRmliZXIuc2libGluZztcbiAgICAgIH1cbiAgICAgIHZhciBuZXdGaWJlciA9IHVwZGF0ZVNsb3QocmV0dXJuRmliZXIsIG9sZEZpYmVyLCBzdGVwLnZhbHVlLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICBpZiAobmV3RmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgLy8gVE9ETzogVGhpcyBicmVha3Mgb24gZW1wdHkgc2xvdHMgbGlrZSBudWxsIGNoaWxkcmVuLiBUaGF0J3NcbiAgICAgICAgLy8gdW5mb3J0dW5hdGUgYmVjYXVzZSBpdCB0cmlnZ2VycyB0aGUgc2xvdyBwYXRoIGFsbCB0aGUgdGltZS4gV2UgbmVlZFxuICAgICAgICAvLyBhIGJldHRlciB3YXkgdG8gY29tbXVuaWNhdGUgd2hldGhlciB0aGlzIHdhcyBhIG1pc3Mgb3IgbnVsbCxcbiAgICAgICAgLy8gYm9vbGVhbiwgdW5kZWZpbmVkLCBldGMuXG4gICAgICAgIGlmICghb2xkRmliZXIpIHtcbiAgICAgICAgICBvbGRGaWJlciA9IG5leHRPbGRGaWJlcjtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChzaG91bGRUcmFja1NpZGVFZmZlY3RzKSB7XG4gICAgICAgIGlmIChvbGRGaWJlciAmJiBuZXdGaWJlci5hbHRlcm5hdGUgPT09IG51bGwpIHtcbiAgICAgICAgICAvLyBXZSBtYXRjaGVkIHRoZSBzbG90LCBidXQgd2UgZGlkbid0IHJldXNlIHRoZSBleGlzdGluZyBmaWJlciwgc28gd2VcbiAgICAgICAgICAvLyBuZWVkIHRvIGRlbGV0ZSB0aGUgZXhpc3RpbmcgY2hpbGQuXG4gICAgICAgICAgZGVsZXRlQ2hpbGQocmV0dXJuRmliZXIsIG9sZEZpYmVyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbGFzdFBsYWNlZEluZGV4ID0gcGxhY2VDaGlsZChuZXdGaWJlciwgbGFzdFBsYWNlZEluZGV4LCBuZXdJZHgpO1xuICAgICAgaWYgKHByZXZpb3VzTmV3RmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgLy8gVE9ETzogTW92ZSBvdXQgb2YgdGhlIGxvb3AuIFRoaXMgb25seSBoYXBwZW5zIGZvciB0aGUgZmlyc3QgcnVuLlxuICAgICAgICByZXN1bHRpbmdGaXJzdENoaWxkID0gbmV3RmliZXI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUT0RPOiBEZWZlciBzaWJsaW5ncyBpZiB3ZSdyZSBub3QgYXQgdGhlIHJpZ2h0IGluZGV4IGZvciB0aGlzIHNsb3QuXG4gICAgICAgIC8vIEkuZS4gaWYgd2UgaGFkIG51bGwgdmFsdWVzIGJlZm9yZSwgdGhlbiB3ZSB3YW50IHRvIGRlZmVyIHRoaXNcbiAgICAgICAgLy8gZm9yIGVhY2ggbnVsbCB2YWx1ZS4gSG93ZXZlciwgd2UgYWxzbyBkb24ndCB3YW50IHRvIGNhbGwgdXBkYXRlU2xvdFxuICAgICAgICAvLyB3aXRoIHRoZSBwcmV2aW91cyBvbmUuXG4gICAgICAgIHByZXZpb3VzTmV3RmliZXIuc2libGluZyA9IG5ld0ZpYmVyO1xuICAgICAgfVxuICAgICAgcHJldmlvdXNOZXdGaWJlciA9IG5ld0ZpYmVyO1xuICAgICAgb2xkRmliZXIgPSBuZXh0T2xkRmliZXI7XG4gICAgfVxuXG4gICAgaWYgKHN0ZXAuZG9uZSkge1xuICAgICAgLy8gV2UndmUgcmVhY2hlZCB0aGUgZW5kIG9mIHRoZSBuZXcgY2hpbGRyZW4uIFdlIGNhbiBkZWxldGUgdGhlIHJlc3QuXG4gICAgICBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgb2xkRmliZXIpO1xuICAgICAgcmV0dXJuIHJlc3VsdGluZ0ZpcnN0Q2hpbGQ7XG4gICAgfVxuXG4gICAgaWYgKG9sZEZpYmVyID09PSBudWxsKSB7XG4gICAgICAvLyBJZiB3ZSBkb24ndCBoYXZlIGFueSBtb3JlIGV4aXN0aW5nIGNoaWxkcmVuIHdlIGNhbiBjaG9vc2UgYSBmYXN0IHBhdGhcbiAgICAgIC8vIHNpbmNlIHRoZSByZXN0IHdpbGwgYWxsIGJlIGluc2VydGlvbnMuXG4gICAgICBmb3IgKDsgIXN0ZXAuZG9uZTsgbmV3SWR4KyssIHN0ZXAgPSBuZXdDaGlsZHJlbi5uZXh0KCkpIHtcbiAgICAgICAgdmFyIF9uZXdGaWJlcjMgPSBjcmVhdGVDaGlsZChyZXR1cm5GaWJlciwgc3RlcC52YWx1ZSwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgICBpZiAoX25ld0ZpYmVyMyA9PT0gbnVsbCkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGxhc3RQbGFjZWRJbmRleCA9IHBsYWNlQ2hpbGQoX25ld0ZpYmVyMywgbGFzdFBsYWNlZEluZGV4LCBuZXdJZHgpO1xuICAgICAgICBpZiAocHJldmlvdXNOZXdGaWJlciA9PT0gbnVsbCkge1xuICAgICAgICAgIC8vIFRPRE86IE1vdmUgb3V0IG9mIHRoZSBsb29wLiBUaGlzIG9ubHkgaGFwcGVucyBmb3IgdGhlIGZpcnN0IHJ1bi5cbiAgICAgICAgICByZXN1bHRpbmdGaXJzdENoaWxkID0gX25ld0ZpYmVyMztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcmV2aW91c05ld0ZpYmVyLnNpYmxpbmcgPSBfbmV3RmliZXIzO1xuICAgICAgICB9XG4gICAgICAgIHByZXZpb3VzTmV3RmliZXIgPSBfbmV3RmliZXIzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdGluZ0ZpcnN0Q2hpbGQ7XG4gICAgfVxuXG4gICAgLy8gQWRkIGFsbCBjaGlsZHJlbiB0byBhIGtleSBtYXAgZm9yIHF1aWNrIGxvb2t1cHMuXG4gICAgdmFyIGV4aXN0aW5nQ2hpbGRyZW4gPSBtYXBSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgb2xkRmliZXIpO1xuXG4gICAgLy8gS2VlcCBzY2FubmluZyBhbmQgdXNlIHRoZSBtYXAgdG8gcmVzdG9yZSBkZWxldGVkIGl0ZW1zIGFzIG1vdmVzLlxuICAgIGZvciAoOyAhc3RlcC5kb25lOyBuZXdJZHgrKywgc3RlcCA9IG5ld0NoaWxkcmVuLm5leHQoKSkge1xuICAgICAgdmFyIF9uZXdGaWJlcjQgPSB1cGRhdGVGcm9tTWFwKGV4aXN0aW5nQ2hpbGRyZW4sIHJldHVybkZpYmVyLCBuZXdJZHgsIHN0ZXAudmFsdWUsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGlmIChfbmV3RmliZXI0ICE9PSBudWxsKSB7XG4gICAgICAgIGlmIChzaG91bGRUcmFja1NpZGVFZmZlY3RzKSB7XG4gICAgICAgICAgaWYgKF9uZXdGaWJlcjQuYWx0ZXJuYXRlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBUaGUgbmV3IGZpYmVyIGlzIGEgd29yayBpbiBwcm9ncmVzcywgYnV0IGlmIHRoZXJlIGV4aXN0cyBhXG4gICAgICAgICAgICAvLyBjdXJyZW50LCB0aGF0IG1lYW5zIHRoYXQgd2UgcmV1c2VkIHRoZSBmaWJlci4gV2UgbmVlZCB0byBkZWxldGVcbiAgICAgICAgICAgIC8vIGl0IGZyb20gdGhlIGNoaWxkIGxpc3Qgc28gdGhhdCB3ZSBkb24ndCBhZGQgaXQgdG8gdGhlIGRlbGV0aW9uXG4gICAgICAgICAgICAvLyBsaXN0LlxuICAgICAgICAgICAgZXhpc3RpbmdDaGlsZHJlblsnZGVsZXRlJ10oX25ld0ZpYmVyNC5rZXkgPT09IG51bGwgPyBuZXdJZHggOiBfbmV3RmliZXI0LmtleSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxhc3RQbGFjZWRJbmRleCA9IHBsYWNlQ2hpbGQoX25ld0ZpYmVyNCwgbGFzdFBsYWNlZEluZGV4LCBuZXdJZHgpO1xuICAgICAgICBpZiAocHJldmlvdXNOZXdGaWJlciA9PT0gbnVsbCkge1xuICAgICAgICAgIHJlc3VsdGluZ0ZpcnN0Q2hpbGQgPSBfbmV3RmliZXI0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByZXZpb3VzTmV3RmliZXIuc2libGluZyA9IF9uZXdGaWJlcjQ7XG4gICAgICAgIH1cbiAgICAgICAgcHJldmlvdXNOZXdGaWJlciA9IF9uZXdGaWJlcjQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHNob3VsZFRyYWNrU2lkZUVmZmVjdHMpIHtcbiAgICAgIC8vIEFueSBleGlzdGluZyBjaGlsZHJlbiB0aGF0IHdlcmVuJ3QgY29uc3VtZWQgYWJvdmUgd2VyZSBkZWxldGVkLiBXZSBuZWVkXG4gICAgICAvLyB0byBhZGQgdGhlbSB0byB0aGUgZGVsZXRpb24gbGlzdC5cbiAgICAgIGV4aXN0aW5nQ2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgcmV0dXJuIGRlbGV0ZUNoaWxkKHJldHVybkZpYmVyLCBjaGlsZCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0aW5nRmlyc3RDaGlsZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlY29uY2lsZVNpbmdsZVRleHROb2RlKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgdGV4dENvbnRlbnQsIGV4cGlyYXRpb25UaW1lKSB7XG4gICAgLy8gVGhlcmUncyBubyBuZWVkIHRvIGNoZWNrIGZvciBrZXlzIG9uIHRleHQgbm9kZXMgc2luY2Ugd2UgZG9uJ3QgaGF2ZSBhXG4gICAgLy8gd2F5IHRvIGRlZmluZSB0aGVtLlxuICAgIGlmIChjdXJyZW50Rmlyc3RDaGlsZCAhPT0gbnVsbCAmJiBjdXJyZW50Rmlyc3RDaGlsZC50YWcgPT09IEhvc3RUZXh0KSB7XG4gICAgICAvLyBXZSBhbHJlYWR5IGhhdmUgYW4gZXhpc3Rpbmcgbm9kZSBzbyBsZXQncyBqdXN0IHVwZGF0ZSBpdCBhbmQgZGVsZXRlXG4gICAgICAvLyB0aGUgcmVzdC5cbiAgICAgIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZC5zaWJsaW5nKTtcbiAgICAgIHZhciBleGlzdGluZyA9IHVzZUZpYmVyKGN1cnJlbnRGaXJzdENoaWxkLCB0ZXh0Q29udGVudCwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgZXhpc3RpbmdbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgICByZXR1cm4gZXhpc3Rpbmc7XG4gICAgfVxuICAgIC8vIFRoZSBleGlzdGluZyBmaXJzdCBjaGlsZCBpcyBub3QgYSB0ZXh0IG5vZGUgc28gd2UgbmVlZCB0byBjcmVhdGUgb25lXG4gICAgLy8gYW5kIGRlbGV0ZSB0aGUgZXhpc3Rpbmcgb25lcy5cbiAgICBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQpO1xuICAgIHZhciBjcmVhdGVkID0gY3JlYXRlRmliZXJGcm9tVGV4dCh0ZXh0Q29udGVudCwgcmV0dXJuRmliZXIuaW50ZXJuYWxDb250ZXh0VGFnLCBleHBpcmF0aW9uVGltZSk7XG4gICAgY3JlYXRlZFsncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICByZXR1cm4gY3JlYXRlZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlY29uY2lsZVNpbmdsZUVsZW1lbnQocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBlbGVtZW50LCBleHBpcmF0aW9uVGltZSkge1xuICAgIHZhciBrZXkgPSBlbGVtZW50LmtleTtcbiAgICB2YXIgY2hpbGQgPSBjdXJyZW50Rmlyc3RDaGlsZDtcbiAgICB3aGlsZSAoY2hpbGQgIT09IG51bGwpIHtcbiAgICAgIC8vIFRPRE86IElmIGtleSA9PT0gbnVsbCBhbmQgY2hpbGQua2V5ID09PSBudWxsLCB0aGVuIHRoaXMgb25seSBhcHBsaWVzIHRvXG4gICAgICAvLyB0aGUgZmlyc3QgaXRlbSBpbiB0aGUgbGlzdC5cbiAgICAgIGlmIChjaGlsZC5rZXkgPT09IGtleSkge1xuICAgICAgICBpZiAoY2hpbGQudGFnID09PSBGcmFnbWVudCA/IGVsZW1lbnQudHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSA6IGNoaWxkLnR5cGUgPT09IGVsZW1lbnQudHlwZSkge1xuICAgICAgICAgIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBjaGlsZC5zaWJsaW5nKTtcbiAgICAgICAgICB2YXIgZXhpc3RpbmcgPSB1c2VGaWJlcihjaGlsZCwgZWxlbWVudC50eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFID8gZWxlbWVudC5wcm9wcy5jaGlsZHJlbiA6IGVsZW1lbnQucHJvcHMsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgICBleGlzdGluZy5yZWYgPSBjb2VyY2VSZWYoY2hpbGQsIGVsZW1lbnQpO1xuICAgICAgICAgIGV4aXN0aW5nWydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIGV4aXN0aW5nLl9kZWJ1Z1NvdXJjZSA9IGVsZW1lbnQuX3NvdXJjZTtcbiAgICAgICAgICAgIGV4aXN0aW5nLl9kZWJ1Z093bmVyID0gZWxlbWVudC5fb3duZXI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBleGlzdGluZztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY2hpbGQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWxldGVDaGlsZChyZXR1cm5GaWJlciwgY2hpbGQpO1xuICAgICAgfVxuICAgICAgY2hpbGQgPSBjaGlsZC5zaWJsaW5nO1xuICAgIH1cblxuICAgIGlmIChlbGVtZW50LnR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUpIHtcbiAgICAgIHZhciBjcmVhdGVkID0gY3JlYXRlRmliZXJGcm9tRnJhZ21lbnQoZWxlbWVudC5wcm9wcy5jaGlsZHJlbiwgcmV0dXJuRmliZXIuaW50ZXJuYWxDb250ZXh0VGFnLCBleHBpcmF0aW9uVGltZSwgZWxlbWVudC5rZXkpO1xuICAgICAgY3JlYXRlZFsncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICAgIHJldHVybiBjcmVhdGVkO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgX2NyZWF0ZWQ3ID0gY3JlYXRlRmliZXJGcm9tRWxlbWVudChlbGVtZW50LCByZXR1cm5GaWJlci5pbnRlcm5hbENvbnRleHRUYWcsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgIF9jcmVhdGVkNy5yZWYgPSBjb2VyY2VSZWYoY3VycmVudEZpcnN0Q2hpbGQsIGVsZW1lbnQpO1xuICAgICAgX2NyZWF0ZWQ3WydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgICAgcmV0dXJuIF9jcmVhdGVkNztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWNvbmNpbGVTaW5nbGVDYWxsKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgY2FsbCwgZXhwaXJhdGlvblRpbWUpIHtcbiAgICB2YXIga2V5ID0gY2FsbC5rZXk7XG4gICAgdmFyIGNoaWxkID0gY3VycmVudEZpcnN0Q2hpbGQ7XG4gICAgd2hpbGUgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgICAvLyBUT0RPOiBJZiBrZXkgPT09IG51bGwgYW5kIGNoaWxkLmtleSA9PT0gbnVsbCwgdGhlbiB0aGlzIG9ubHkgYXBwbGllcyB0b1xuICAgICAgLy8gdGhlIGZpcnN0IGl0ZW0gaW4gdGhlIGxpc3QuXG4gICAgICBpZiAoY2hpbGQua2V5ID09PSBrZXkpIHtcbiAgICAgICAgaWYgKGNoaWxkLnRhZyA9PT0gQ2FsbENvbXBvbmVudCkge1xuICAgICAgICAgIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBjaGlsZC5zaWJsaW5nKTtcbiAgICAgICAgICB2YXIgZXhpc3RpbmcgPSB1c2VGaWJlcihjaGlsZCwgY2FsbCwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgICAgIGV4aXN0aW5nWydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgICAgICAgIHJldHVybiBleGlzdGluZztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY2hpbGQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWxldGVDaGlsZChyZXR1cm5GaWJlciwgY2hpbGQpO1xuICAgICAgfVxuICAgICAgY2hpbGQgPSBjaGlsZC5zaWJsaW5nO1xuICAgIH1cblxuICAgIHZhciBjcmVhdGVkID0gY3JlYXRlRmliZXJGcm9tQ2FsbChjYWxsLCByZXR1cm5GaWJlci5pbnRlcm5hbENvbnRleHRUYWcsIGV4cGlyYXRpb25UaW1lKTtcbiAgICBjcmVhdGVkWydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgIHJldHVybiBjcmVhdGVkO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVjb25jaWxlU2luZ2xlUmV0dXJuKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgcmV0dXJuTm9kZSwgZXhwaXJhdGlvblRpbWUpIHtcbiAgICAvLyBUaGVyZSdzIG5vIG5lZWQgdG8gY2hlY2sgZm9yIGtleXMgb24geWllbGRzIHNpbmNlIHRoZXkncmUgc3RhdGVsZXNzLlxuICAgIHZhciBjaGlsZCA9IGN1cnJlbnRGaXJzdENoaWxkO1xuICAgIGlmIChjaGlsZCAhPT0gbnVsbCkge1xuICAgICAgaWYgKGNoaWxkLnRhZyA9PT0gUmV0dXJuQ29tcG9uZW50KSB7XG4gICAgICAgIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBjaGlsZC5zaWJsaW5nKTtcbiAgICAgICAgdmFyIGV4aXN0aW5nID0gdXNlRmliZXIoY2hpbGQsIG51bGwsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgZXhpc3RpbmcudHlwZSA9IHJldHVybk5vZGUudmFsdWU7XG4gICAgICAgIGV4aXN0aW5nWydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgICAgICByZXR1cm4gZXhpc3Rpbmc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY2hpbGQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBjcmVhdGVkID0gY3JlYXRlRmliZXJGcm9tUmV0dXJuKHJldHVybk5vZGUsIHJldHVybkZpYmVyLmludGVybmFsQ29udGV4dFRhZywgZXhwaXJhdGlvblRpbWUpO1xuICAgIGNyZWF0ZWQudHlwZSA9IHJldHVybk5vZGUudmFsdWU7XG4gICAgY3JlYXRlZFsncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICByZXR1cm4gY3JlYXRlZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlY29uY2lsZVNpbmdsZVBvcnRhbChyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIHBvcnRhbCwgZXhwaXJhdGlvblRpbWUpIHtcbiAgICB2YXIga2V5ID0gcG9ydGFsLmtleTtcbiAgICB2YXIgY2hpbGQgPSBjdXJyZW50Rmlyc3RDaGlsZDtcbiAgICB3aGlsZSAoY2hpbGQgIT09IG51bGwpIHtcbiAgICAgIC8vIFRPRE86IElmIGtleSA9PT0gbnVsbCBhbmQgY2hpbGQua2V5ID09PSBudWxsLCB0aGVuIHRoaXMgb25seSBhcHBsaWVzIHRvXG4gICAgICAvLyB0aGUgZmlyc3QgaXRlbSBpbiB0aGUgbGlzdC5cbiAgICAgIGlmIChjaGlsZC5rZXkgPT09IGtleSkge1xuICAgICAgICBpZiAoY2hpbGQudGFnID09PSBIb3N0UG9ydGFsICYmIGNoaWxkLnN0YXRlTm9kZS5jb250YWluZXJJbmZvID09PSBwb3J0YWwuY29udGFpbmVySW5mbyAmJiBjaGlsZC5zdGF0ZU5vZGUuaW1wbGVtZW50YXRpb24gPT09IHBvcnRhbC5pbXBsZW1lbnRhdGlvbikge1xuICAgICAgICAgIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBjaGlsZC5zaWJsaW5nKTtcbiAgICAgICAgICB2YXIgZXhpc3RpbmcgPSB1c2VGaWJlcihjaGlsZCwgcG9ydGFsLmNoaWxkcmVuIHx8IFtdLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICAgICAgZXhpc3RpbmdbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgICAgICAgcmV0dXJuIGV4aXN0aW5nO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBjaGlsZCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlbGV0ZUNoaWxkKHJldHVybkZpYmVyLCBjaGlsZCk7XG4gICAgICB9XG4gICAgICBjaGlsZCA9IGNoaWxkLnNpYmxpbmc7XG4gICAgfVxuXG4gICAgdmFyIGNyZWF0ZWQgPSBjcmVhdGVGaWJlckZyb21Qb3J0YWwocG9ydGFsLCByZXR1cm5GaWJlci5pbnRlcm5hbENvbnRleHRUYWcsIGV4cGlyYXRpb25UaW1lKTtcbiAgICBjcmVhdGVkWydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgIHJldHVybiBjcmVhdGVkO1xuICB9XG5cbiAgLy8gVGhpcyBBUEkgd2lsbCB0YWcgdGhlIGNoaWxkcmVuIHdpdGggdGhlIHNpZGUtZWZmZWN0IG9mIHRoZSByZWNvbmNpbGlhdGlvblxuICAvLyBpdHNlbGYuIFRoZXkgd2lsbCBiZSBhZGRlZCB0byB0aGUgc2lkZS1lZmZlY3QgbGlzdCBhcyB3ZSBwYXNzIHRocm91Z2ggdGhlXG4gIC8vIGNoaWxkcmVuIGFuZCB0aGUgcGFyZW50LlxuICBmdW5jdGlvbiByZWNvbmNpbGVDaGlsZEZpYmVycyhyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIG5ld0NoaWxkLCBleHBpcmF0aW9uVGltZSkge1xuICAgIC8vIFRoaXMgZnVuY3Rpb24gaXMgbm90IHJlY3Vyc2l2ZS5cbiAgICAvLyBJZiB0aGUgdG9wIGxldmVsIGl0ZW0gaXMgYW4gYXJyYXksIHdlIHRyZWF0IGl0IGFzIGEgc2V0IG9mIGNoaWxkcmVuLFxuICAgIC8vIG5vdCBhcyBhIGZyYWdtZW50LiBOZXN0ZWQgYXJyYXlzIG9uIHRoZSBvdGhlciBoYW5kIHdpbGwgYmUgdHJlYXRlZCBhc1xuICAgIC8vIGZyYWdtZW50IG5vZGVzLiBSZWN1cnNpb24gaGFwcGVucyBhdCB0aGUgbm9ybWFsIGZsb3cuXG5cbiAgICAvLyBIYW5kbGUgdG9wIGxldmVsIHVua2V5ZWQgZnJhZ21lbnRzIGFzIGlmIHRoZXkgd2VyZSBhcnJheXMuXG4gICAgLy8gVGhpcyBsZWFkcyB0byBhbiBhbWJpZ3VpdHkgYmV0d2VlbiA8PntbLi4uXX08Lz4gYW5kIDw+Li4uPC8+LlxuICAgIC8vIFdlIHRyZWF0IHRoZSBhbWJpZ3VvdXMgY2FzZXMgYWJvdmUgdGhlIHNhbWUuXG4gICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ29iamVjdCcgJiYgbmV3Q2hpbGQgIT09IG51bGwgJiYgbmV3Q2hpbGQudHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSAmJiBuZXdDaGlsZC5rZXkgPT09IG51bGwpIHtcbiAgICAgIG5ld0NoaWxkID0gbmV3Q2hpbGQucHJvcHMuY2hpbGRyZW47XG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIG9iamVjdCB0eXBlc1xuICAgIHZhciBpc09iamVjdCA9IHR5cGVvZiBuZXdDaGlsZCA9PT0gJ29iamVjdCcgJiYgbmV3Q2hpbGQgIT09IG51bGw7XG5cbiAgICBpZiAoaXNPYmplY3QpIHtcbiAgICAgIHN3aXRjaCAobmV3Q2hpbGQuJCR0eXBlb2YpIHtcbiAgICAgICAgY2FzZSBSRUFDVF9FTEVNRU5UX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIHBsYWNlU2luZ2xlQ2hpbGQocmVjb25jaWxlU2luZ2xlRWxlbWVudChyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIG5ld0NoaWxkLCBleHBpcmF0aW9uVGltZSkpO1xuXG4gICAgICAgIGNhc2UgUkVBQ1RfQ0FMTF9UWVBFOlxuICAgICAgICAgIHJldHVybiBwbGFjZVNpbmdsZUNoaWxkKHJlY29uY2lsZVNpbmdsZUNhbGwocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUpKTtcbiAgICAgICAgY2FzZSBSRUFDVF9SRVRVUk5fVFlQRTpcbiAgICAgICAgICByZXR1cm4gcGxhY2VTaW5nbGVDaGlsZChyZWNvbmNpbGVTaW5nbGVSZXR1cm4ocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUpKTtcbiAgICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgICAgICByZXR1cm4gcGxhY2VTaW5nbGVDaGlsZChyZWNvbmNpbGVTaW5nbGVQb3J0YWwocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgbmV3Q2hpbGQgPT09ICdudW1iZXInKSB7XG4gICAgICByZXR1cm4gcGxhY2VTaW5nbGVDaGlsZChyZWNvbmNpbGVTaW5nbGVUZXh0Tm9kZShyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsICcnICsgbmV3Q2hpbGQsIGV4cGlyYXRpb25UaW1lKSk7XG4gICAgfVxuXG4gICAgaWYgKGlzQXJyYXkkMShuZXdDaGlsZCkpIHtcbiAgICAgIHJldHVybiByZWNvbmNpbGVDaGlsZHJlbkFycmF5KHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgbmV3Q2hpbGQsIGV4cGlyYXRpb25UaW1lKTtcbiAgICB9XG5cbiAgICBpZiAoZ2V0SXRlcmF0b3JGbihuZXdDaGlsZCkpIHtcbiAgICAgIHJldHVybiByZWNvbmNpbGVDaGlsZHJlbkl0ZXJhdG9yKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgbmV3Q2hpbGQsIGV4cGlyYXRpb25UaW1lKTtcbiAgICB9XG5cbiAgICBpZiAoaXNPYmplY3QpIHtcbiAgICAgIHRocm93T25JbnZhbGlkT2JqZWN0VHlwZShyZXR1cm5GaWJlciwgbmV3Q2hpbGQpO1xuICAgIH1cblxuICAgIHtcbiAgICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgd2Fybk9uRnVuY3Rpb25UeXBlKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAvLyBJZiB0aGUgbmV3IGNoaWxkIGlzIHVuZGVmaW5lZCwgYW5kIHRoZSByZXR1cm4gZmliZXIgaXMgYSBjb21wb3NpdGVcbiAgICAgIC8vIGNvbXBvbmVudCwgdGhyb3cgYW4gZXJyb3IuIElmIEZpYmVyIHJldHVybiB0eXBlcyBhcmUgZGlzYWJsZWQsXG4gICAgICAvLyB3ZSBhbHJlYWR5IHRocmV3IGFib3ZlLlxuICAgICAgc3dpdGNoIChyZXR1cm5GaWJlci50YWcpIHtcbiAgICAgICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHZhciBpbnN0YW5jZSA9IHJldHVybkZpYmVyLnN0YXRlTm9kZTtcbiAgICAgICAgICAgICAgaWYgKGluc3RhbmNlLnJlbmRlci5faXNNb2NrRnVuY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBhbGxvdyBhdXRvLW1vY2tzIHRvIHByb2NlZWQgYXMgaWYgdGhleSdyZSByZXR1cm5pbmcgbnVsbC5cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgLy8gSW50ZW50aW9uYWxseSBmYWxsIHRocm91Z2ggdG8gdGhlIG5leHQgY2FzZSwgd2hpY2ggaGFuZGxlcyBib3RoXG4gICAgICAgIC8vIGZ1bmN0aW9ucyBhbmQgY2xhc3Nlc1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVkIG5vLWZhbGx0aHJvdWdoXG4gICAgICAgIGNhc2UgRnVuY3Rpb25hbENvbXBvbmVudDpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgQ29tcG9uZW50ID0gcmV0dXJuRmliZXIudHlwZTtcbiAgICAgICAgICAgIGludmFyaWFudChmYWxzZSwgJyVzKC4uLik6IE5vdGhpbmcgd2FzIHJldHVybmVkIGZyb20gcmVuZGVyLiBUaGlzIHVzdWFsbHkgbWVhbnMgYSByZXR1cm4gc3RhdGVtZW50IGlzIG1pc3NpbmcuIE9yLCB0byByZW5kZXIgbm90aGluZywgcmV0dXJuIG51bGwuJywgQ29tcG9uZW50LmRpc3BsYXlOYW1lIHx8IENvbXBvbmVudC5uYW1lIHx8ICdDb21wb25lbnQnKTtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUmVtYWluaW5nIGNhc2VzIGFyZSBhbGwgdHJlYXRlZCBhcyBlbXB0eS5cbiAgICByZXR1cm4gZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkKTtcbiAgfVxuXG4gIHJldHVybiByZWNvbmNpbGVDaGlsZEZpYmVycztcbn1cblxudmFyIHJlY29uY2lsZUNoaWxkRmliZXJzID0gQ2hpbGRSZWNvbmNpbGVyKHRydWUpO1xudmFyIG1vdW50Q2hpbGRGaWJlcnMgPSBDaGlsZFJlY29uY2lsZXIoZmFsc2UpO1xuXG5mdW5jdGlvbiBjbG9uZUNoaWxkRmliZXJzKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKSB7XG4gICEoY3VycmVudCA9PT0gbnVsbCB8fCB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9PT0gY3VycmVudC5jaGlsZCkgPyBpbnZhcmlhbnQoZmFsc2UsICdSZXN1bWluZyB3b3JrIG5vdCB5ZXQgaW1wbGVtZW50ZWQuJykgOiB2b2lkIDA7XG5cbiAgaWYgKHdvcmtJblByb2dyZXNzLmNoaWxkID09PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGN1cnJlbnRDaGlsZCA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICB2YXIgbmV3Q2hpbGQgPSBjcmVhdGVXb3JrSW5Qcm9ncmVzcyhjdXJyZW50Q2hpbGQsIGN1cnJlbnRDaGlsZC5wZW5kaW5nUHJvcHMsIGN1cnJlbnRDaGlsZC5leHBpcmF0aW9uVGltZSk7XG4gIHdvcmtJblByb2dyZXNzLmNoaWxkID0gbmV3Q2hpbGQ7XG5cbiAgbmV3Q2hpbGRbJ3JldHVybiddID0gd29ya0luUHJvZ3Jlc3M7XG4gIHdoaWxlIChjdXJyZW50Q2hpbGQuc2libGluZyAhPT0gbnVsbCkge1xuICAgIGN1cnJlbnRDaGlsZCA9IGN1cnJlbnRDaGlsZC5zaWJsaW5nO1xuICAgIG5ld0NoaWxkID0gbmV3Q2hpbGQuc2libGluZyA9IGNyZWF0ZVdvcmtJblByb2dyZXNzKGN1cnJlbnRDaGlsZCwgY3VycmVudENoaWxkLnBlbmRpbmdQcm9wcywgY3VycmVudENoaWxkLmV4cGlyYXRpb25UaW1lKTtcbiAgICBuZXdDaGlsZFsncmV0dXJuJ10gPSB3b3JrSW5Qcm9ncmVzcztcbiAgfVxuICBuZXdDaGlsZC5zaWJsaW5nID0gbnVsbDtcbn1cblxue1xuICB2YXIgd2FybmVkQWJvdXRTdGF0ZWxlc3NSZWZzID0ge307XG59XG5cbnZhciBSZWFjdEZpYmVyQmVnaW5Xb3JrID0gZnVuY3Rpb24gKGNvbmZpZywgaG9zdENvbnRleHQsIGh5ZHJhdGlvbkNvbnRleHQsIHNjaGVkdWxlV29yaywgY29tcHV0ZUV4cGlyYXRpb25Gb3JGaWJlcikge1xuICB2YXIgc2hvdWxkU2V0VGV4dENvbnRlbnQgPSBjb25maWcuc2hvdWxkU2V0VGV4dENvbnRlbnQsXG4gICAgICB1c2VTeW5jU2NoZWR1bGluZyA9IGNvbmZpZy51c2VTeW5jU2NoZWR1bGluZyxcbiAgICAgIHNob3VsZERlcHJpb3JpdGl6ZVN1YnRyZWUgPSBjb25maWcuc2hvdWxkRGVwcmlvcml0aXplU3VidHJlZTtcbiAgdmFyIHB1c2hIb3N0Q29udGV4dCA9IGhvc3RDb250ZXh0LnB1c2hIb3N0Q29udGV4dCxcbiAgICAgIHB1c2hIb3N0Q29udGFpbmVyID0gaG9zdENvbnRleHQucHVzaEhvc3RDb250YWluZXI7XG4gIHZhciBlbnRlckh5ZHJhdGlvblN0YXRlID0gaHlkcmF0aW9uQ29udGV4dC5lbnRlckh5ZHJhdGlvblN0YXRlLFxuICAgICAgcmVzZXRIeWRyYXRpb25TdGF0ZSA9IGh5ZHJhdGlvbkNvbnRleHQucmVzZXRIeWRyYXRpb25TdGF0ZSxcbiAgICAgIHRyeVRvQ2xhaW1OZXh0SHlkcmF0YWJsZUluc3RhbmNlID0gaHlkcmF0aW9uQ29udGV4dC50cnlUb0NsYWltTmV4dEh5ZHJhdGFibGVJbnN0YW5jZTtcblxuICB2YXIgX1JlYWN0RmliZXJDbGFzc0NvbXBvID0gUmVhY3RGaWJlckNsYXNzQ29tcG9uZW50KHNjaGVkdWxlV29yaywgY29tcHV0ZUV4cGlyYXRpb25Gb3JGaWJlciwgbWVtb2l6ZVByb3BzLCBtZW1vaXplU3RhdGUpLFxuICAgICAgYWRvcHRDbGFzc0luc3RhbmNlID0gX1JlYWN0RmliZXJDbGFzc0NvbXBvLmFkb3B0Q2xhc3NJbnN0YW5jZSxcbiAgICAgIGNvbnN0cnVjdENsYXNzSW5zdGFuY2UgPSBfUmVhY3RGaWJlckNsYXNzQ29tcG8uY29uc3RydWN0Q2xhc3NJbnN0YW5jZSxcbiAgICAgIG1vdW50Q2xhc3NJbnN0YW5jZSA9IF9SZWFjdEZpYmVyQ2xhc3NDb21wby5tb3VudENsYXNzSW5zdGFuY2UsXG4gICAgICB1cGRhdGVDbGFzc0luc3RhbmNlID0gX1JlYWN0RmliZXJDbGFzc0NvbXBvLnVwZGF0ZUNsYXNzSW5zdGFuY2U7XG5cbiAgLy8gVE9ETzogUmVtb3ZlIHRoaXMgYW5kIHVzZSByZWNvbmNpbGVDaGlsZHJlbkF0RXhwaXJhdGlvblRpbWUgZGlyZWN0bHkuXG5cblxuICBmdW5jdGlvbiByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuKSB7XG4gICAgcmVjb25jaWxlQ2hpbGRyZW5BdEV4cGlyYXRpb25UaW1lKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4sIHdvcmtJblByb2dyZXNzLmV4cGlyYXRpb25UaW1lKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlY29uY2lsZUNoaWxkcmVuQXRFeHBpcmF0aW9uVGltZShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuLCByZW5kZXJFeHBpcmF0aW9uVGltZSkge1xuICAgIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG4gICAgICAvLyBJZiB0aGlzIGlzIGEgZnJlc2ggbmV3IGNvbXBvbmVudCB0aGF0IGhhc24ndCBiZWVuIHJlbmRlcmVkIHlldCwgd2VcbiAgICAgIC8vIHdvbid0IHVwZGF0ZSBpdHMgY2hpbGQgc2V0IGJ5IGFwcGx5aW5nIG1pbmltYWwgc2lkZS1lZmZlY3RzLiBJbnN0ZWFkLFxuICAgICAgLy8gd2Ugd2lsbCBhZGQgdGhlbSBhbGwgdG8gdGhlIGNoaWxkIGJlZm9yZSBpdCBnZXRzIHJlbmRlcmVkLiBUaGF0IG1lYW5zXG4gICAgICAvLyB3ZSBjYW4gb3B0aW1pemUgdGhpcyByZWNvbmNpbGlhdGlvbiBwYXNzIGJ5IG5vdCB0cmFja2luZyBzaWRlLWVmZmVjdHMuXG4gICAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IG1vdW50Q2hpbGRGaWJlcnMod29ya0luUHJvZ3Jlc3MsIG51bGwsIG5leHRDaGlsZHJlbiwgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiB0aGUgY3VycmVudCBjaGlsZCBpcyB0aGUgc2FtZSBhcyB0aGUgd29yayBpbiBwcm9ncmVzcywgaXQgbWVhbnMgdGhhdFxuICAgICAgLy8gd2UgaGF2ZW4ndCB5ZXQgc3RhcnRlZCBhbnkgd29yayBvbiB0aGVzZSBjaGlsZHJlbi4gVGhlcmVmb3JlLCB3ZSB1c2VcbiAgICAgIC8vIHRoZSBjbG9uZSBhbGdvcml0aG0gdG8gY3JlYXRlIGEgY29weSBvZiBhbGwgdGhlIGN1cnJlbnQgY2hpbGRyZW4uXG5cbiAgICAgIC8vIElmIHdlIGhhZCBhbnkgcHJvZ3Jlc3NlZCB3b3JrIGFscmVhZHksIHRoYXQgaXMgaW52YWxpZCBhdCB0aGlzIHBvaW50IHNvXG4gICAgICAvLyBsZXQncyB0aHJvdyBpdCBvdXQuXG4gICAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IHJlY29uY2lsZUNoaWxkRmliZXJzKHdvcmtJblByb2dyZXNzLCBjdXJyZW50LmNoaWxkLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVGcmFnbWVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcykge1xuICAgIHZhciBuZXh0Q2hpbGRyZW4gPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gICAgaWYgKGhhc0NvbnRleHRDaGFuZ2VkKCkpIHtcbiAgICAgIC8vIE5vcm1hbGx5IHdlIGNhbiBiYWlsIG91dCBvbiBwcm9wcyBlcXVhbGl0eSBidXQgaWYgY29udGV4dCBoYXMgY2hhbmdlZFxuICAgICAgLy8gd2UgZG9uJ3QgZG8gdGhlIGJhaWxvdXQgYW5kIHdlIGhhdmUgdG8gcmV1c2UgZXhpc3RpbmcgcHJvcHMgaW5zdGVhZC5cbiAgICAgIGlmIChuZXh0Q2hpbGRyZW4gPT09IG51bGwpIHtcbiAgICAgICAgbmV4dENoaWxkcmVuID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG5leHRDaGlsZHJlbiA9PT0gbnVsbCB8fCB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzID09PSBuZXh0Q2hpbGRyZW4pIHtcbiAgICAgIHJldHVybiBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgICB9XG4gICAgcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbik7XG4gICAgbWVtb2l6ZVByb3BzKHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4pO1xuICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1hcmtSZWYoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpIHtcbiAgICB2YXIgcmVmID0gd29ya0luUHJvZ3Jlc3MucmVmO1xuICAgIGlmIChyZWYgIT09IG51bGwgJiYgKCFjdXJyZW50IHx8IGN1cnJlbnQucmVmICE9PSByZWYpKSB7XG4gICAgICAvLyBTY2hlZHVsZSBhIFJlZiBlZmZlY3RcbiAgICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBSZWY7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlRnVuY3Rpb25hbENvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcykge1xuICAgIHZhciBmbiA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG4gICAgdmFyIG5leHRQcm9wcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcblxuICAgIHZhciBtZW1vaXplZFByb3BzID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcztcbiAgICBpZiAoaGFzQ29udGV4dENoYW5nZWQoKSkge1xuICAgICAgLy8gTm9ybWFsbHkgd2UgY2FuIGJhaWwgb3V0IG9uIHByb3BzIGVxdWFsaXR5IGJ1dCBpZiBjb250ZXh0IGhhcyBjaGFuZ2VkXG4gICAgICAvLyB3ZSBkb24ndCBkbyB0aGUgYmFpbG91dCBhbmQgd2UgaGF2ZSB0byByZXVzZSBleGlzdGluZyBwcm9wcyBpbnN0ZWFkLlxuICAgICAgaWYgKG5leHRQcm9wcyA9PT0gbnVsbCkge1xuICAgICAgICBuZXh0UHJvcHMgPSBtZW1vaXplZFByb3BzO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAobmV4dFByb3BzID09PSBudWxsIHx8IG1lbW9pemVkUHJvcHMgPT09IG5leHRQcm9wcykge1xuICAgICAgICByZXR1cm4gYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICB9XG4gICAgICAvLyBUT0RPOiBjb25zaWRlciBicmluZ2luZyBmbi5zaG91bGRDb21wb25lbnRVcGRhdGUoKSBiYWNrLlxuICAgICAgLy8gSXQgdXNlZCB0byBiZSBoZXJlLlxuICAgIH1cblxuICAgIHZhciB1bm1hc2tlZENvbnRleHQgPSBnZXRVbm1hc2tlZENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICAgIHZhciBjb250ZXh0ID0gZ2V0TWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgdW5tYXNrZWRDb250ZXh0KTtcblxuICAgIHZhciBuZXh0Q2hpbGRyZW47XG5cbiAgICB7XG4gICAgICBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ID0gd29ya0luUHJvZ3Jlc3M7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZpYmVyLnNldEN1cnJlbnRQaGFzZSgncmVuZGVyJyk7XG4gICAgICBuZXh0Q2hpbGRyZW4gPSBmbihuZXh0UHJvcHMsIGNvbnRleHQpO1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5zZXRDdXJyZW50UGhhc2UobnVsbCk7XG4gICAgfVxuICAgIC8vIFJlYWN0IERldlRvb2xzIHJlYWRzIHRoaXMgZmxhZy5cbiAgICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgfD0gUGVyZm9ybWVkV29yaztcbiAgICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuKTtcbiAgICBtZW1vaXplUHJvcHMod29ya0luUHJvZ3Jlc3MsIG5leHRQcm9wcyk7XG4gICAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlQ2xhc3NDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gICAgLy8gUHVzaCBjb250ZXh0IHByb3ZpZGVycyBlYXJseSB0byBwcmV2ZW50IGNvbnRleHQgc3RhY2sgbWlzbWF0Y2hlcy5cbiAgICAvLyBEdXJpbmcgbW91bnRpbmcgd2UgZG9uJ3Qga25vdyB0aGUgY2hpbGQgY29udGV4dCB5ZXQgYXMgdGhlIGluc3RhbmNlIGRvZXNuJ3QgZXhpc3QuXG4gICAgLy8gV2Ugd2lsbCBpbnZhbGlkYXRlIHRoZSBjaGlsZCBjb250ZXh0IGluIGZpbmlzaENsYXNzQ29tcG9uZW50KCkgcmlnaHQgYWZ0ZXIgcmVuZGVyaW5nLlxuICAgIHZhciBoYXNDb250ZXh0ID0gcHVzaENvbnRleHRQcm92aWRlcih3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgICB2YXIgc2hvdWxkVXBkYXRlID0gdm9pZCAwO1xuICAgIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG4gICAgICBpZiAoIXdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSkge1xuICAgICAgICAvLyBJbiB0aGUgaW5pdGlhbCBwYXNzIHdlIG1pZ2h0IG5lZWQgdG8gY29uc3RydWN0IHRoZSBpbnN0YW5jZS5cbiAgICAgICAgY29uc3RydWN0Q2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzKTtcbiAgICAgICAgbW91bnRDbGFzc0luc3RhbmNlKHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgICAgIHNob3VsZFVwZGF0ZSA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbnZhcmlhbnQoZmFsc2UsICdSZXN1bWluZyB3b3JrIG5vdCB5ZXQgaW1wbGVtZW50ZWQuJyk7XG4gICAgICAgIC8vIEluIGEgcmVzdW1lLCB3ZSdsbCBhbHJlYWR5IGhhdmUgYW4gaW5zdGFuY2Ugd2UgY2FuIHJldXNlLlxuICAgICAgICAvLyBzaG91bGRVcGRhdGUgPSByZXN1bWVNb3VudENsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc2hvdWxkVXBkYXRlID0gdXBkYXRlQ2xhc3NJbnN0YW5jZShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgIH1cbiAgICByZXR1cm4gZmluaXNoQ2xhc3NDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHNob3VsZFVwZGF0ZSwgaGFzQ29udGV4dCk7XG4gIH1cblxuICBmdW5jdGlvbiBmaW5pc2hDbGFzc0NvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgc2hvdWxkVXBkYXRlLCBoYXNDb250ZXh0KSB7XG4gICAgLy8gUmVmcyBzaG91bGQgdXBkYXRlIGV2ZW4gaWYgc2hvdWxkQ29tcG9uZW50VXBkYXRlIHJldHVybnMgZmFsc2VcbiAgICBtYXJrUmVmKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcblxuICAgIGlmICghc2hvdWxkVXBkYXRlKSB7XG4gICAgICAvLyBDb250ZXh0IHByb3ZpZGVycyBzaG91bGQgZGVmZXIgdG8gc0NVIGZvciByZW5kZXJpbmdcbiAgICAgIGlmIChoYXNDb250ZXh0KSB7XG4gICAgICAgIGludmFsaWRhdGVDb250ZXh0UHJvdmlkZXIod29ya0luUHJvZ3Jlc3MsIGZhbHNlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgIH1cblxuICAgIHZhciBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcblxuICAgIC8vIFJlcmVuZGVyXG4gICAgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCA9IHdvcmtJblByb2dyZXNzO1xuICAgIHZhciBuZXh0Q2hpbGRyZW4gPSB2b2lkIDA7XG4gICAge1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5zZXRDdXJyZW50UGhhc2UoJ3JlbmRlcicpO1xuICAgICAgbmV4dENoaWxkcmVuID0gaW5zdGFuY2UucmVuZGVyKCk7XG4gICAgICBpZiAoZGVidWdSZW5kZXJQaGFzZVNpZGVFZmZlY3RzKSB7XG4gICAgICAgIGluc3RhbmNlLnJlbmRlcigpO1xuICAgICAgfVxuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5zZXRDdXJyZW50UGhhc2UobnVsbCk7XG4gICAgfVxuICAgIC8vIFJlYWN0IERldlRvb2xzIHJlYWRzIHRoaXMgZmxhZy5cbiAgICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgfD0gUGVyZm9ybWVkV29yaztcbiAgICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuKTtcbiAgICAvLyBNZW1vaXplIHByb3BzIGFuZCBzdGF0ZSB1c2luZyB0aGUgdmFsdWVzIHdlIGp1c3QgdXNlZCB0byByZW5kZXIuXG4gICAgLy8gVE9ETzogUmVzdHJ1Y3R1cmUgc28gd2UgbmV2ZXIgcmVhZCB2YWx1ZXMgZnJvbSB0aGUgaW5zdGFuY2UuXG4gICAgbWVtb2l6ZVN0YXRlKHdvcmtJblByb2dyZXNzLCBpbnN0YW5jZS5zdGF0ZSk7XG4gICAgbWVtb2l6ZVByb3BzKHdvcmtJblByb2dyZXNzLCBpbnN0YW5jZS5wcm9wcyk7XG5cbiAgICAvLyBUaGUgY29udGV4dCBtaWdodCBoYXZlIGNoYW5nZWQgc28gd2UgbmVlZCB0byByZWNhbGN1bGF0ZSBpdC5cbiAgICBpZiAoaGFzQ29udGV4dCkge1xuICAgICAgaW52YWxpZGF0ZUNvbnRleHRQcm92aWRlcih3b3JrSW5Qcm9ncmVzcywgdHJ1ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICB9XG5cbiAgZnVuY3Rpb24gcHVzaEhvc3RSb290Q29udGV4dCh3b3JrSW5Qcm9ncmVzcykge1xuICAgIHZhciByb290ID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAgIGlmIChyb290LnBlbmRpbmdDb250ZXh0KSB7XG4gICAgICBwdXNoVG9wTGV2ZWxDb250ZXh0T2JqZWN0KHdvcmtJblByb2dyZXNzLCByb290LnBlbmRpbmdDb250ZXh0LCByb290LnBlbmRpbmdDb250ZXh0ICE9PSByb290LmNvbnRleHQpO1xuICAgIH0gZWxzZSBpZiAocm9vdC5jb250ZXh0KSB7XG4gICAgICAvLyBTaG91bGQgYWx3YXlzIGJlIHNldFxuICAgICAgcHVzaFRvcExldmVsQ29udGV4dE9iamVjdCh3b3JrSW5Qcm9ncmVzcywgcm9vdC5jb250ZXh0LCBmYWxzZSk7XG4gICAgfVxuICAgIHB1c2hIb3N0Q29udGFpbmVyKHdvcmtJblByb2dyZXNzLCByb290LmNvbnRhaW5lckluZm8pO1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlSG9zdFJvb3QoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gICAgcHVzaEhvc3RSb290Q29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgdmFyIHVwZGF0ZVF1ZXVlID0gd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWU7XG4gICAgaWYgKHVwZGF0ZVF1ZXVlICE9PSBudWxsKSB7XG4gICAgICB2YXIgcHJldlN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgICAgIHZhciBzdGF0ZSA9IHByb2Nlc3NVcGRhdGVRdWV1ZShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgdXBkYXRlUXVldWUsIG51bGwsIG51bGwsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGlmIChwcmV2U3RhdGUgPT09IHN0YXRlKSB7XG4gICAgICAgIC8vIElmIHRoZSBzdGF0ZSBpcyB0aGUgc2FtZSBhcyBiZWZvcmUsIHRoYXQncyBhIGJhaWxvdXQgYmVjYXVzZSB3ZSBoYWRcbiAgICAgICAgLy8gbm8gd29yayB0aGF0IGV4cGlyZXMgYXQgdGhpcyB0aW1lLlxuICAgICAgICByZXNldEh5ZHJhdGlvblN0YXRlKCk7XG4gICAgICAgIHJldHVybiBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgICAgIH1cbiAgICAgIHZhciBlbGVtZW50ID0gc3RhdGUuZWxlbWVudDtcbiAgICAgIHZhciByb290ID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAgICAgaWYgKChjdXJyZW50ID09PSBudWxsIHx8IGN1cnJlbnQuY2hpbGQgPT09IG51bGwpICYmIHJvb3QuaHlkcmF0ZSAmJiBlbnRlckh5ZHJhdGlvblN0YXRlKHdvcmtJblByb2dyZXNzKSkge1xuICAgICAgICAvLyBJZiB3ZSBkb24ndCBoYXZlIGFueSBjdXJyZW50IGNoaWxkcmVuIHRoaXMgbWlnaHQgYmUgdGhlIGZpcnN0IHBhc3MuXG4gICAgICAgIC8vIFdlIGFsd2F5cyB0cnkgdG8gaHlkcmF0ZS4gSWYgdGhpcyBpc24ndCBhIGh5ZHJhdGlvbiBwYXNzIHRoZXJlIHdvbid0XG4gICAgICAgIC8vIGJlIGFueSBjaGlsZHJlbiB0byBoeWRyYXRlIHdoaWNoIGlzIGVmZmVjdGl2ZWx5IHRoZSBzYW1lIHRoaW5nIGFzXG4gICAgICAgIC8vIG5vdCBoeWRyYXRpbmcuXG5cbiAgICAgICAgLy8gVGhpcyBpcyBhIGJpdCBvZiBhIGhhY2suIFdlIHRyYWNrIHRoZSBob3N0IHJvb3QgYXMgYSBwbGFjZW1lbnQgdG9cbiAgICAgICAgLy8ga25vdyB0aGF0IHdlJ3JlIGN1cnJlbnRseSBpbiBhIG1vdW50aW5nIHN0YXRlLiBUaGF0IHdheSBpc01vdW50ZWRcbiAgICAgICAgLy8gd29ya3MgYXMgZXhwZWN0ZWQuIFdlIG11c3QgcmVzZXQgdGhpcyBiZWZvcmUgY29tbWl0dGluZy5cbiAgICAgICAgLy8gVE9ETzogRGVsZXRlIHRoaXMgd2hlbiB3ZSBkZWxldGUgaXNNb3VudGVkIGFuZCBmaW5kRE9NTm9kZS5cbiAgICAgICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IFBsYWNlbWVudDtcblxuICAgICAgICAvLyBFbnN1cmUgdGhhdCBjaGlsZHJlbiBtb3VudCBpbnRvIHRoaXMgcm9vdCB3aXRob3V0IHRyYWNraW5nXG4gICAgICAgIC8vIHNpZGUtZWZmZWN0cy4gVGhpcyBlbnN1cmVzIHRoYXQgd2UgZG9uJ3Qgc3RvcmUgUGxhY2VtZW50IGVmZmVjdHMgb25cbiAgICAgICAgLy8gbm9kZXMgdGhhdCB3aWxsIGJlIGh5ZHJhdGVkLlxuICAgICAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IG1vdW50Q2hpbGRGaWJlcnMod29ya0luUHJvZ3Jlc3MsIG51bGwsIGVsZW1lbnQsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE90aGVyd2lzZSByZXNldCBoeWRyYXRpb24gc3RhdGUgaW4gY2FzZSB3ZSBhYm9ydGVkIGFuZCByZXN1bWVkIGFub3RoZXJcbiAgICAgICAgLy8gcm9vdC5cbiAgICAgICAgcmVzZXRIeWRyYXRpb25TdGF0ZSgpO1xuICAgICAgICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgZWxlbWVudCk7XG4gICAgICB9XG4gICAgICBtZW1vaXplU3RhdGUod29ya0luUHJvZ3Jlc3MsIHN0YXRlKTtcbiAgICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgICB9XG4gICAgcmVzZXRIeWRyYXRpb25TdGF0ZSgpO1xuICAgIC8vIElmIHRoZXJlIGlzIG5vIHVwZGF0ZSBxdWV1ZSwgdGhhdCdzIGEgYmFpbG91dCBiZWNhdXNlIHRoZSByb290IGhhcyBubyBwcm9wcy5cbiAgICByZXR1cm4gYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVIb3N0Q29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSkge1xuICAgIHB1c2hIb3N0Q29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgICBpZiAoY3VycmVudCA9PT0gbnVsbCkge1xuICAgICAgdHJ5VG9DbGFpbU5leHRIeWRyYXRhYmxlSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MpO1xuICAgIH1cblxuICAgIHZhciB0eXBlID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgICB2YXIgbWVtb2l6ZWRQcm9wcyA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHM7XG4gICAgdmFyIG5leHRQcm9wcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcbiAgICBpZiAobmV4dFByb3BzID09PSBudWxsKSB7XG4gICAgICBuZXh0UHJvcHMgPSBtZW1vaXplZFByb3BzO1xuICAgICAgIShuZXh0UHJvcHMgIT09IG51bGwpID8gaW52YXJpYW50KGZhbHNlLCAnV2Ugc2hvdWxkIGFsd2F5cyBoYXZlIHBlbmRpbmcgb3IgY3VycmVudCBwcm9wcy4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcbiAgICB9XG4gICAgdmFyIHByZXZQcm9wcyA9IGN1cnJlbnQgIT09IG51bGwgPyBjdXJyZW50Lm1lbW9pemVkUHJvcHMgOiBudWxsO1xuXG4gICAgaWYgKGhhc0NvbnRleHRDaGFuZ2VkKCkpIHtcbiAgICAgIC8vIE5vcm1hbGx5IHdlIGNhbiBiYWlsIG91dCBvbiBwcm9wcyBlcXVhbGl0eSBidXQgaWYgY29udGV4dCBoYXMgY2hhbmdlZFxuICAgICAgLy8gd2UgZG9uJ3QgZG8gdGhlIGJhaWxvdXQgYW5kIHdlIGhhdmUgdG8gcmV1c2UgZXhpc3RpbmcgcHJvcHMgaW5zdGVhZC5cbiAgICB9IGVsc2UgaWYgKG5leHRQcm9wcyA9PT0gbnVsbCB8fCBtZW1vaXplZFByb3BzID09PSBuZXh0UHJvcHMpIHtcbiAgICAgIHJldHVybiBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgICB9XG5cbiAgICB2YXIgbmV4dENoaWxkcmVuID0gbmV4dFByb3BzLmNoaWxkcmVuO1xuICAgIHZhciBpc0RpcmVjdFRleHRDaGlsZCA9IHNob3VsZFNldFRleHRDb250ZW50KHR5cGUsIG5leHRQcm9wcyk7XG5cbiAgICBpZiAoaXNEaXJlY3RUZXh0Q2hpbGQpIHtcbiAgICAgIC8vIFdlIHNwZWNpYWwgY2FzZSBhIGRpcmVjdCB0ZXh0IGNoaWxkIG9mIGEgaG9zdCBub2RlLiBUaGlzIGlzIGEgY29tbW9uXG4gICAgICAvLyBjYXNlLiBXZSB3b24ndCBoYW5kbGUgaXQgYXMgYSByZWlmaWVkIGNoaWxkLiBXZSB3aWxsIGluc3RlYWQgaGFuZGxlXG4gICAgICAvLyB0aGlzIGluIHRoZSBob3N0IGVudmlyb25tZW50IHRoYXQgYWxzbyBoYXZlIGFjY2VzcyB0byB0aGlzIHByb3AuIFRoYXRcbiAgICAgIC8vIGF2b2lkcyBhbGxvY2F0aW5nIGFub3RoZXIgSG9zdFRleHQgZmliZXIgYW5kIHRyYXZlcnNpbmcgaXQuXG4gICAgICBuZXh0Q2hpbGRyZW4gPSBudWxsO1xuICAgIH0gZWxzZSBpZiAocHJldlByb3BzICYmIHNob3VsZFNldFRleHRDb250ZW50KHR5cGUsIHByZXZQcm9wcykpIHtcbiAgICAgIC8vIElmIHdlJ3JlIHN3aXRjaGluZyBmcm9tIGEgZGlyZWN0IHRleHQgY2hpbGQgdG8gYSBub3JtYWwgY2hpbGQsIG9yIHRvXG4gICAgICAvLyBlbXB0eSwgd2UgbmVlZCB0byBzY2hlZHVsZSB0aGUgdGV4dCBjb250ZW50IHRvIGJlIHJlc2V0LlxuICAgICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IENvbnRlbnRSZXNldDtcbiAgICB9XG5cbiAgICBtYXJrUmVmKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcblxuICAgIC8vIENoZWNrIHRoZSBob3N0IGNvbmZpZyB0byBzZWUgaWYgdGhlIGNoaWxkcmVuIGFyZSBvZmZzY3JlZW4vaGlkZGVuLlxuICAgIGlmIChyZW5kZXJFeHBpcmF0aW9uVGltZSAhPT0gTmV2ZXIgJiYgIXVzZVN5bmNTY2hlZHVsaW5nICYmIHNob3VsZERlcHJpb3JpdGl6ZVN1YnRyZWUodHlwZSwgbmV4dFByb3BzKSkge1xuICAgICAgLy8gRG93bi1wcmlvcml0aXplIHRoZSBjaGlsZHJlbi5cbiAgICAgIHdvcmtJblByb2dyZXNzLmV4cGlyYXRpb25UaW1lID0gTmV2ZXI7XG4gICAgICAvLyBCYWlsb3V0IGFuZCBjb21lIGJhY2sgdG8gdGhpcyBmaWJlciBsYXRlci5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4pO1xuICAgIG1lbW9pemVQcm9wcyh3b3JrSW5Qcm9ncmVzcywgbmV4dFByb3BzKTtcbiAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVIb3N0VGV4dChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcykge1xuICAgIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG4gICAgICB0cnlUb0NsYWltTmV4dEh5ZHJhdGFibGVJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgfVxuICAgIHZhciBuZXh0UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gICAgaWYgKG5leHRQcm9wcyA9PT0gbnVsbCkge1xuICAgICAgbmV4dFByb3BzID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcztcbiAgICB9XG4gICAgbWVtb2l6ZVByb3BzKHdvcmtJblByb2dyZXNzLCBuZXh0UHJvcHMpO1xuICAgIC8vIE5vdGhpbmcgdG8gZG8gaGVyZS4gVGhpcyBpcyB0ZXJtaW5hbC4gV2UnbGwgZG8gdGhlIGNvbXBsZXRpb24gc3RlcFxuICAgIC8vIGltbWVkaWF0ZWx5IGFmdGVyLlxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gbW91bnRJbmRldGVybWluYXRlQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSkge1xuICAgICEoY3VycmVudCA9PT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdBbiBpbmRldGVybWluYXRlIGNvbXBvbmVudCBzaG91bGQgbmV2ZXIgaGF2ZSBtb3VudGVkLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuICAgIHZhciBmbiA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG4gICAgdmFyIHByb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICAgIHZhciB1bm1hc2tlZENvbnRleHQgPSBnZXRVbm1hc2tlZENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICAgIHZhciBjb250ZXh0ID0gZ2V0TWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgdW5tYXNrZWRDb250ZXh0KTtcblxuICAgIHZhciB2YWx1ZTtcblxuICAgIHtcbiAgICAgIGlmIChmbi5wcm90b3R5cGUgJiYgdHlwZW9mIGZuLnByb3RvdHlwZS5yZW5kZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgd2FybmluZyhmYWxzZSwgXCJUaGUgPCVzIC8+IGNvbXBvbmVudCBhcHBlYXJzIHRvIGhhdmUgYSByZW5kZXIgbWV0aG9kLCBidXQgZG9lc24ndCBleHRlbmQgUmVhY3QuQ29tcG9uZW50LiBcIiArICdUaGlzIGlzIGxpa2VseSB0byBjYXVzZSBlcnJvcnMuIENoYW5nZSAlcyB0byBleHRlbmQgUmVhY3QuQ29tcG9uZW50IGluc3RlYWQuJywgY29tcG9uZW50TmFtZSwgY29tcG9uZW50TmFtZSk7XG4gICAgICB9XG4gICAgICBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ID0gd29ya0luUHJvZ3Jlc3M7XG4gICAgICB2YWx1ZSA9IGZuKHByb3BzLCBjb250ZXh0KTtcbiAgICB9XG4gICAgLy8gUmVhY3QgRGV2VG9vbHMgcmVhZHMgdGhpcyBmbGFnLlxuICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBQZXJmb3JtZWRXb3JrO1xuXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgIT09IG51bGwgJiYgdHlwZW9mIHZhbHVlLnJlbmRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gUHJvY2VlZCB1bmRlciB0aGUgYXNzdW1wdGlvbiB0aGF0IHRoaXMgaXMgYSBjbGFzcyBpbnN0YW5jZVxuICAgICAgd29ya0luUHJvZ3Jlc3MudGFnID0gQ2xhc3NDb21wb25lbnQ7XG5cbiAgICAgIC8vIFB1c2ggY29udGV4dCBwcm92aWRlcnMgZWFybHkgdG8gcHJldmVudCBjb250ZXh0IHN0YWNrIG1pc21hdGNoZXMuXG4gICAgICAvLyBEdXJpbmcgbW91bnRpbmcgd2UgZG9uJ3Qga25vdyB0aGUgY2hpbGQgY29udGV4dCB5ZXQgYXMgdGhlIGluc3RhbmNlIGRvZXNuJ3QgZXhpc3QuXG4gICAgICAvLyBXZSB3aWxsIGludmFsaWRhdGUgdGhlIGNoaWxkIGNvbnRleHQgaW4gZmluaXNoQ2xhc3NDb21wb25lbnQoKSByaWdodCBhZnRlciByZW5kZXJpbmcuXG4gICAgICB2YXIgaGFzQ29udGV4dCA9IHB1c2hDb250ZXh0UHJvdmlkZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgYWRvcHRDbGFzc0luc3RhbmNlKHdvcmtJblByb2dyZXNzLCB2YWx1ZSk7XG4gICAgICBtb3VudENsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICAgIHJldHVybiBmaW5pc2hDbGFzc0NvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgdHJ1ZSwgaGFzQ29udGV4dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFByb2NlZWQgdW5kZXIgdGhlIGFzc3VtcHRpb24gdGhhdCB0aGlzIGlzIGEgZnVuY3Rpb25hbCBjb21wb25lbnRcbiAgICAgIHdvcmtJblByb2dyZXNzLnRhZyA9IEZ1bmN0aW9uYWxDb21wb25lbnQ7XG4gICAgICB7XG4gICAgICAgIHZhciBDb21wb25lbnQgPSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuXG4gICAgICAgIGlmIChDb21wb25lbnQpIHtcbiAgICAgICAgICB3YXJuaW5nKCFDb21wb25lbnQuY2hpbGRDb250ZXh0VHlwZXMsICclcyguLi4pOiBjaGlsZENvbnRleHRUeXBlcyBjYW5ub3QgYmUgZGVmaW5lZCBvbiBhIGZ1bmN0aW9uYWwgY29tcG9uZW50LicsIENvbXBvbmVudC5kaXNwbGF5TmFtZSB8fCBDb21wb25lbnQubmFtZSB8fCAnQ29tcG9uZW50Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHdvcmtJblByb2dyZXNzLnJlZiAhPT0gbnVsbCkge1xuICAgICAgICAgIHZhciBpbmZvID0gJyc7XG4gICAgICAgICAgdmFyIG93bmVyTmFtZSA9IFJlYWN0RGVidWdDdXJyZW50RmliZXIuZ2V0Q3VycmVudEZpYmVyT3duZXJOYW1lKCk7XG4gICAgICAgICAgaWYgKG93bmVyTmFtZSkge1xuICAgICAgICAgICAgaW5mbyArPSAnXFxuXFxuQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgYCcgKyBvd25lck5hbWUgKyAnYC4nO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciB3YXJuaW5nS2V5ID0gb3duZXJOYW1lIHx8IHdvcmtJblByb2dyZXNzLl9kZWJ1Z0lEIHx8ICcnO1xuICAgICAgICAgIHZhciBkZWJ1Z1NvdXJjZSA9IHdvcmtJblByb2dyZXNzLl9kZWJ1Z1NvdXJjZTtcbiAgICAgICAgICBpZiAoZGVidWdTb3VyY2UpIHtcbiAgICAgICAgICAgIHdhcm5pbmdLZXkgPSBkZWJ1Z1NvdXJjZS5maWxlTmFtZSArICc6JyArIGRlYnVnU291cmNlLmxpbmVOdW1iZXI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghd2FybmVkQWJvdXRTdGF0ZWxlc3NSZWZzW3dhcm5pbmdLZXldKSB7XG4gICAgICAgICAgICB3YXJuZWRBYm91dFN0YXRlbGVzc1JlZnNbd2FybmluZ0tleV0gPSB0cnVlO1xuICAgICAgICAgICAgd2FybmluZyhmYWxzZSwgJ1N0YXRlbGVzcyBmdW5jdGlvbiBjb21wb25lbnRzIGNhbm5vdCBiZSBnaXZlbiByZWZzLiAnICsgJ0F0dGVtcHRzIHRvIGFjY2VzcyB0aGlzIHJlZiB3aWxsIGZhaWwuJXMlcycsIGluZm8sIFJlYWN0RGVidWdDdXJyZW50RmliZXIuZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSgpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCB2YWx1ZSk7XG4gICAgICBtZW1vaXplUHJvcHMod29ya0luUHJvZ3Jlc3MsIHByb3BzKTtcbiAgICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVDYWxsQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSkge1xuICAgIHZhciBuZXh0Q2FsbCA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcbiAgICBpZiAoaGFzQ29udGV4dENoYW5nZWQoKSkge1xuICAgICAgLy8gTm9ybWFsbHkgd2UgY2FuIGJhaWwgb3V0IG9uIHByb3BzIGVxdWFsaXR5IGJ1dCBpZiBjb250ZXh0IGhhcyBjaGFuZ2VkXG4gICAgICAvLyB3ZSBkb24ndCBkbyB0aGUgYmFpbG91dCBhbmQgd2UgaGF2ZSB0byByZXVzZSBleGlzdGluZyBwcm9wcyBpbnN0ZWFkLlxuICAgICAgaWYgKG5leHRDYWxsID09PSBudWxsKSB7XG4gICAgICAgIG5leHRDYWxsID0gY3VycmVudCAmJiBjdXJyZW50Lm1lbW9pemVkUHJvcHM7XG4gICAgICAgICEobmV4dENhbGwgIT09IG51bGwpID8gaW52YXJpYW50KGZhbHNlLCAnV2Ugc2hvdWxkIGFsd2F5cyBoYXZlIHBlbmRpbmcgb3IgY3VycmVudCBwcm9wcy4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG5leHRDYWxsID09PSBudWxsIHx8IHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHMgPT09IG5leHRDYWxsKSB7XG4gICAgICBuZXh0Q2FsbCA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHM7XG4gICAgICAvLyBUT0RPOiBXaGVuIGJhaWxpbmcgb3V0LCB3ZSBtaWdodCBuZWVkIHRvIHJldHVybiB0aGUgc3RhdGVOb2RlIGluc3RlYWRcbiAgICAgIC8vIG9mIHRoZSBjaGlsZC4gVG8gY2hlY2sgaXQgZm9yIHdvcmsuXG4gICAgICAvLyByZXR1cm4gYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgfVxuXG4gICAgdmFyIG5leHRDaGlsZHJlbiA9IG5leHRDYWxsLmNoaWxkcmVuO1xuXG4gICAgLy8gVGhlIGZvbGxvd2luZyBpcyBhIGZvcmsgb2YgcmVjb25jaWxlQ2hpbGRyZW5BdEV4cGlyYXRpb25UaW1lIGJ1dCB1c2luZ1xuICAgIC8vIHN0YXRlTm9kZSB0byBzdG9yZSB0aGUgY2hpbGQuXG4gICAgaWYgKGN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAgIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IG1vdW50Q2hpbGRGaWJlcnMod29ya0luUHJvZ3Jlc3MsIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSwgbmV4dENoaWxkcmVuLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IHJlY29uY2lsZUNoaWxkRmliZXJzKHdvcmtJblByb2dyZXNzLCB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUsIG5leHRDaGlsZHJlbiwgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgIH1cblxuICAgIG1lbW9pemVQcm9wcyh3b3JrSW5Qcm9ncmVzcywgbmV4dENhbGwpO1xuICAgIC8vIFRoaXMgZG9lc24ndCB0YWtlIGFyYml0cmFyeSB0aW1lIHNvIHdlIGNvdWxkIHN5bmNocm9ub3VzbHkganVzdCBiZWdpblxuICAgIC8vIGVhZ2VybHkgZG8gdGhlIHdvcmsgb2Ygd29ya0luUHJvZ3Jlc3MuY2hpbGQgYXMgYW4gb3B0aW1pemF0aW9uLlxuICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVQb3J0YWxDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gICAgcHVzaEhvc3RDb250YWluZXIod29ya0luUHJvZ3Jlc3MsIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZS5jb250YWluZXJJbmZvKTtcbiAgICB2YXIgbmV4dENoaWxkcmVuID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICAgIGlmIChoYXNDb250ZXh0Q2hhbmdlZCgpKSB7XG4gICAgICAvLyBOb3JtYWxseSB3ZSBjYW4gYmFpbCBvdXQgb24gcHJvcHMgZXF1YWxpdHkgYnV0IGlmIGNvbnRleHQgaGFzIGNoYW5nZWRcbiAgICAgIC8vIHdlIGRvbid0IGRvIHRoZSBiYWlsb3V0IGFuZCB3ZSBoYXZlIHRvIHJldXNlIGV4aXN0aW5nIHByb3BzIGluc3RlYWQuXG4gICAgICBpZiAobmV4dENoaWxkcmVuID09PSBudWxsKSB7XG4gICAgICAgIG5leHRDaGlsZHJlbiA9IGN1cnJlbnQgJiYgY3VycmVudC5tZW1vaXplZFByb3BzO1xuICAgICAgICAhKG5leHRDaGlsZHJlbiAhPSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJ1dlIHNob3VsZCBhbHdheXMgaGF2ZSBwZW5kaW5nIG9yIGN1cnJlbnQgcHJvcHMuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChuZXh0Q2hpbGRyZW4gPT09IG51bGwgfHwgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcyA9PT0gbmV4dENoaWxkcmVuKSB7XG4gICAgICByZXR1cm4gYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgfVxuXG4gICAgaWYgKGN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAgIC8vIFBvcnRhbHMgYXJlIHNwZWNpYWwgYmVjYXVzZSB3ZSBkb24ndCBhcHBlbmQgdGhlIGNoaWxkcmVuIGR1cmluZyBtb3VudFxuICAgICAgLy8gYnV0IGF0IGNvbW1pdC4gVGhlcmVmb3JlIHdlIG5lZWQgdG8gdHJhY2sgaW5zZXJ0aW9ucyB3aGljaCB0aGUgbm9ybWFsXG4gICAgICAvLyBmbG93IGRvZXNuJ3QgZG8gZHVyaW5nIG1vdW50LiBUaGlzIGRvZXNuJ3QgaGFwcGVuIGF0IHRoZSByb290IGJlY2F1c2VcbiAgICAgIC8vIHRoZSByb290IGFsd2F5cyBzdGFydHMgd2l0aCBhIFwiY3VycmVudFwiIHdpdGggYSBudWxsIGNoaWxkLlxuICAgICAgLy8gVE9ETzogQ29uc2lkZXIgdW5pZnlpbmcgdGhpcyB3aXRoIGhvdyB0aGUgcm9vdCB3b3Jrcy5cbiAgICAgIHdvcmtJblByb2dyZXNzLmNoaWxkID0gcmVjb25jaWxlQ2hpbGRGaWJlcnMod29ya0luUHJvZ3Jlc3MsIG51bGwsIG5leHRDaGlsZHJlbiwgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgICAgbWVtb2l6ZVByb3BzKHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuKTtcbiAgICAgIG1lbW9pemVQcm9wcyh3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuKTtcbiAgICB9XG4gICAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICB9XG5cbiAgLypcbiAgZnVuY3Rpb24gcmV1c2VDaGlsZHJlbkVmZmVjdHMocmV0dXJuRmliZXIgOiBGaWJlciwgZmlyc3RDaGlsZCA6IEZpYmVyKSB7XG4gICAgbGV0IGNoaWxkID0gZmlyc3RDaGlsZDtcbiAgICBkbyB7XG4gICAgICAvLyBFbnN1cmUgdGhhdCB0aGUgZmlyc3QgYW5kIGxhc3QgZWZmZWN0IG9mIHRoZSBwYXJlbnQgY29ycmVzcG9uZHNcbiAgICAgIC8vIHRvIHRoZSBjaGlsZHJlbidzIGZpcnN0IGFuZCBsYXN0IGVmZmVjdC5cbiAgICAgIGlmICghcmV0dXJuRmliZXIuZmlyc3RFZmZlY3QpIHtcbiAgICAgICAgcmV0dXJuRmliZXIuZmlyc3RFZmZlY3QgPSBjaGlsZC5maXJzdEVmZmVjdDtcbiAgICAgIH1cbiAgICAgIGlmIChjaGlsZC5sYXN0RWZmZWN0KSB7XG4gICAgICAgIGlmIChyZXR1cm5GaWJlci5sYXN0RWZmZWN0KSB7XG4gICAgICAgICAgcmV0dXJuRmliZXIubGFzdEVmZmVjdC5uZXh0RWZmZWN0ID0gY2hpbGQuZmlyc3RFZmZlY3Q7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuRmliZXIubGFzdEVmZmVjdCA9IGNoaWxkLmxhc3RFZmZlY3Q7XG4gICAgICB9XG4gICAgfSB3aGlsZSAoY2hpbGQgPSBjaGlsZC5zaWJsaW5nKTtcbiAgfVxuICAqL1xuXG4gIGZ1bmN0aW9uIGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpIHtcbiAgICBjYW5jZWxXb3JrVGltZXIod29ya0luUHJvZ3Jlc3MpO1xuXG4gICAgLy8gVE9ETzogV2Ugc2hvdWxkIGlkZWFsbHkgYmUgYWJsZSB0byBiYWlsIG91dCBlYXJseSBpZiB0aGUgY2hpbGRyZW4gaGF2ZSBub1xuICAgIC8vIG1vcmUgd29yayB0byBkby4gSG93ZXZlciwgc2luY2Ugd2UgZG9uJ3QgaGF2ZSBhIHNlcGFyYXRpb24gb2YgdGhpc1xuICAgIC8vIEZpYmVyJ3MgcHJpb3JpdHkgYW5kIGl0cyBjaGlsZHJlbiB5ZXQgLSB3ZSBkb24ndCBrbm93IHdpdGhvdXQgZG9pbmcgbG90c1xuICAgIC8vIG9mIHRoZSBzYW1lIHdvcmsgd2UgZG8gYW55d2F5LiBPbmNlIHdlIGhhdmUgdGhhdCBzZXBhcmF0aW9uIHdlIGNhbiBqdXN0XG4gICAgLy8gYmFpbCBvdXQgaGVyZSBpZiB0aGUgY2hpbGRyZW4gaGFzIG5vIG1vcmUgd29yayBhdCB0aGlzIHByaW9yaXR5IGxldmVsLlxuICAgIC8vIGlmICh3b3JrSW5Qcm9ncmVzcy5wcmlvcml0eU9mQ2hpbGRyZW4gPD0gcHJpb3JpdHlMZXZlbCkge1xuICAgIC8vICAgLy8gSWYgdGhlcmUgYXJlIHNpZGUtZWZmZWN0cyBpbiB0aGVzZSBjaGlsZHJlbiB0aGF0IGhhdmUgbm90IHlldCBiZWVuXG4gICAgLy8gICAvLyBjb21taXR0ZWQgd2UgbmVlZCB0byBlbnN1cmUgdGhhdCB0aGV5IGdldCBwcm9wZXJseSB0cmFuc2ZlcnJlZCB1cC5cbiAgICAvLyAgIGlmIChjdXJyZW50ICYmIGN1cnJlbnQuY2hpbGQgIT09IHdvcmtJblByb2dyZXNzLmNoaWxkKSB7XG4gICAgLy8gICAgIHJldXNlQ2hpbGRyZW5FZmZlY3RzKHdvcmtJblByb2dyZXNzLCBjaGlsZCk7XG4gICAgLy8gICB9XG4gICAgLy8gICByZXR1cm4gbnVsbDtcbiAgICAvLyB9XG5cbiAgICBjbG9uZUNoaWxkRmliZXJzKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gIH1cblxuICBmdW5jdGlvbiBiYWlsb3V0T25Mb3dQcmlvcml0eShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcykge1xuICAgIGNhbmNlbFdvcmtUaW1lcih3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgICAvLyBUT0RPOiBIYW5kbGUgSG9zdENvbXBvbmVudCB0YWdzIGhlcmUgYXMgd2VsbCBhbmQgY2FsbCBwdXNoSG9zdENvbnRleHQoKT9cbiAgICAvLyBTZWUgUFIgODU5MCBkaXNjdXNzaW9uIGZvciBjb250ZXh0XG4gICAgc3dpdGNoICh3b3JrSW5Qcm9ncmVzcy50YWcpIHtcbiAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgIHB1c2hIb3N0Um9vdENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICAgIHB1c2hDb250ZXh0UHJvdmlkZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICAgICAgcHVzaEhvc3RDb250YWluZXIod29ya0luUHJvZ3Jlc3MsIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZS5jb250YWluZXJJbmZvKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIC8vIFRPRE86IFdoYXQgaWYgdGhpcyBpcyBjdXJyZW50bHkgaW4gcHJvZ3Jlc3M/XG4gICAgLy8gSG93IGNhbiB0aGF0IGhhcHBlbj8gSG93IGlzIHRoaXMgbm90IGJlaW5nIGNsb25lZD9cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIFRPRE86IERlbGV0ZSBtZW1vaXplUHJvcHMvU3RhdGUgYW5kIG1vdmUgdG8gcmVjb25jaWxlL2JhaWxvdXQgaW5zdGVhZFxuICBmdW5jdGlvbiBtZW1vaXplUHJvcHMod29ya0luUHJvZ3Jlc3MsIG5leHRQcm9wcykge1xuICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHMgPSBuZXh0UHJvcHM7XG4gIH1cblxuICBmdW5jdGlvbiBtZW1vaXplU3RhdGUod29ya0luUHJvZ3Jlc3MsIG5leHRTdGF0ZSkge1xuICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBuZXh0U3RhdGU7XG4gICAgLy8gRG9uJ3QgcmVzZXQgdGhlIHVwZGF0ZVF1ZXVlLCBpbiBjYXNlIHRoZXJlIGFyZSBwZW5kaW5nIHVwZGF0ZXMuIFJlc2V0dGluZ1xuICAgIC8vIGlzIGhhbmRsZWQgYnkgcHJvY2Vzc1VwZGF0ZVF1ZXVlLlxuICB9XG5cbiAgZnVuY3Rpb24gYmVnaW5Xb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSkge1xuICAgIGlmICh3b3JrSW5Qcm9ncmVzcy5leHBpcmF0aW9uVGltZSA9PT0gTm9Xb3JrIHx8IHdvcmtJblByb2dyZXNzLmV4cGlyYXRpb25UaW1lID4gcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgICAgIHJldHVybiBiYWlsb3V0T25Mb3dQcmlvcml0eShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgfVxuXG4gICAgc3dpdGNoICh3b3JrSW5Qcm9ncmVzcy50YWcpIHtcbiAgICAgIGNhc2UgSW5kZXRlcm1pbmF0ZUNvbXBvbmVudDpcbiAgICAgICAgcmV0dXJuIG1vdW50SW5kZXRlcm1pbmF0ZUNvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgICAgY2FzZSBGdW5jdGlvbmFsQ29tcG9uZW50OlxuICAgICAgICByZXR1cm4gdXBkYXRlRnVuY3Rpb25hbENvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAgICByZXR1cm4gdXBkYXRlQ2xhc3NDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgIHJldHVybiB1cGRhdGVIb3N0Um9vdChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICByZXR1cm4gdXBkYXRlSG9zdENvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgICAgY2FzZSBIb3N0VGV4dDpcbiAgICAgICAgcmV0dXJuIHVwZGF0ZUhvc3RUZXh0KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgICAgIGNhc2UgQ2FsbEhhbmRsZXJQaGFzZTpcbiAgICAgICAgLy8gVGhpcyBpcyBhIHJlc3RhcnQuIFJlc2V0IHRoZSB0YWcgdG8gdGhlIGluaXRpYWwgcGhhc2UuXG4gICAgICAgIHdvcmtJblByb2dyZXNzLnRhZyA9IENhbGxDb21wb25lbnQ7XG4gICAgICAvLyBJbnRlbnRpb25hbGx5IGZhbGwgdGhyb3VnaCBzaW5jZSB0aGlzIGlzIG5vdyB0aGUgc2FtZS5cbiAgICAgIGNhc2UgQ2FsbENvbXBvbmVudDpcbiAgICAgICAgcmV0dXJuIHVwZGF0ZUNhbGxDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGNhc2UgUmV0dXJuQ29tcG9uZW50OlxuICAgICAgICAvLyBBIHJldHVybiBjb21wb25lbnQgaXMganVzdCBhIHBsYWNlaG9sZGVyLCB3ZSBjYW4ganVzdCBydW4gdGhyb3VnaCB0aGVcbiAgICAgICAgLy8gbmV4dCBvbmUgaW1tZWRpYXRlbHkuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgY2FzZSBIb3N0UG9ydGFsOlxuICAgICAgICByZXR1cm4gdXBkYXRlUG9ydGFsQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgICBjYXNlIEZyYWdtZW50OlxuICAgICAgICByZXR1cm4gdXBkYXRlRnJhZ21lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaW52YXJpYW50KGZhbHNlLCAnVW5rbm93biB1bml0IG9mIHdvcmsgdGFnLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGJlZ2luRmFpbGVkV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgICAvLyBQdXNoIGNvbnRleHQgcHJvdmlkZXJzIGhlcmUgdG8gYXZvaWQgYSBwdXNoL3BvcCBjb250ZXh0IG1pc21hdGNoLlxuICAgIHN3aXRjaCAod29ya0luUHJvZ3Jlc3MudGFnKSB7XG4gICAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAgICBwdXNoQ29udGV4dFByb3ZpZGVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgICBwdXNoSG9zdFJvb3RDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpbnZhcmlhbnQoZmFsc2UsICdJbnZhbGlkIHR5cGUgb2Ygd29yay4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9XG5cbiAgICAvLyBBZGQgYW4gZXJyb3IgZWZmZWN0IHNvIHdlIGNhbiBoYW5kbGUgdGhlIGVycm9yIGR1cmluZyB0aGUgY29tbWl0IHBoYXNlXG4gICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IEVycjtcblxuICAgIC8vIFRoaXMgaXMgYSB3ZWlyZCBjYXNlIHdoZXJlIHdlIGRvIFwicmVzdW1lXCIgd29yayDigJQgd29yayB0aGF0IGZhaWxlZCBvblxuICAgIC8vIG91ciBmaXJzdCBhdHRlbXB0LiBCZWNhdXNlIHdlIG5vIGxvbmdlciBoYXZlIGEgbm90aW9uIG9mIFwicHJvZ3Jlc3NlZFxuICAgIC8vIGRlbGV0aW9ucyxcIiByZXNldCB0aGUgY2hpbGQgdG8gdGhlIGN1cnJlbnQgY2hpbGQgdG8gbWFrZSBzdXJlIHdlIGRlbGV0ZVxuICAgIC8vIGl0IGFnYWluLiBUT0RPOiBGaW5kIGEgYmV0dGVyIHdheSB0byBoYW5kbGUgdGhpcywgcGVyaGFwcyBkdXJpbmcgYSBtb3JlXG4gICAgLy8gZ2VuZXJhbCBvdmVyaGF1bCBvZiBlcnJvciBoYW5kbGluZy5cbiAgICBpZiAoY3VycmVudCA9PT0gbnVsbCkge1xuICAgICAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBudWxsO1xuICAgIH0gZWxzZSBpZiAod29ya0luUHJvZ3Jlc3MuY2hpbGQgIT09IGN1cnJlbnQuY2hpbGQpIHtcbiAgICAgIHdvcmtJblByb2dyZXNzLmNoaWxkID0gY3VycmVudC5jaGlsZDtcbiAgICB9XG5cbiAgICBpZiAod29ya0luUHJvZ3Jlc3MuZXhwaXJhdGlvblRpbWUgPT09IE5vV29yayB8fCB3b3JrSW5Qcm9ncmVzcy5leHBpcmF0aW9uVGltZSA+IHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gICAgICByZXR1cm4gYmFpbG91dE9uTG93UHJpb3JpdHkoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgIH1cblxuICAgIC8vIElmIHdlIGRvbid0IGJhaWwgb3V0LCB3ZSdyZSBnb2luZyBiZSByZWNvbXB1dGluZyBvdXIgY2hpbGRyZW4gc28gd2UgbmVlZFxuICAgIC8vIHRvIGRyb3Agb3VyIGVmZmVjdCBsaXN0LlxuICAgIHdvcmtJblByb2dyZXNzLmZpcnN0RWZmZWN0ID0gbnVsbDtcbiAgICB3b3JrSW5Qcm9ncmVzcy5sYXN0RWZmZWN0ID0gbnVsbDtcblxuICAgIC8vIFVubW91bnQgdGhlIGN1cnJlbnQgY2hpbGRyZW4gYXMgaWYgdGhlIGNvbXBvbmVudCByZW5kZXJlZCBudWxsXG4gICAgdmFyIG5leHRDaGlsZHJlbiA9IG51bGw7XG4gICAgcmVjb25jaWxlQ2hpbGRyZW5BdEV4cGlyYXRpb25UaW1lKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcblxuICAgIGlmICh3b3JrSW5Qcm9ncmVzcy50YWcgPT09IENsYXNzQ29tcG9uZW50KSB7XG4gICAgICB2YXIgaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzID0gaW5zdGFuY2UucHJvcHM7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gaW5zdGFuY2Uuc3RhdGU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBiZWdpbldvcms6IGJlZ2luV29yayxcbiAgICBiZWdpbkZhaWxlZFdvcms6IGJlZ2luRmFpbGVkV29ya1xuICB9O1xufTtcblxudmFyIFJlYWN0RmliZXJDb21wbGV0ZVdvcmsgPSBmdW5jdGlvbiAoY29uZmlnLCBob3N0Q29udGV4dCwgaHlkcmF0aW9uQ29udGV4dCkge1xuICB2YXIgY3JlYXRlSW5zdGFuY2UgPSBjb25maWcuY3JlYXRlSW5zdGFuY2UsXG4gICAgICBjcmVhdGVUZXh0SW5zdGFuY2UgPSBjb25maWcuY3JlYXRlVGV4dEluc3RhbmNlLFxuICAgICAgYXBwZW5kSW5pdGlhbENoaWxkID0gY29uZmlnLmFwcGVuZEluaXRpYWxDaGlsZCxcbiAgICAgIGZpbmFsaXplSW5pdGlhbENoaWxkcmVuID0gY29uZmlnLmZpbmFsaXplSW5pdGlhbENoaWxkcmVuLFxuICAgICAgcHJlcGFyZVVwZGF0ZSA9IGNvbmZpZy5wcmVwYXJlVXBkYXRlLFxuICAgICAgbXV0YXRpb24gPSBjb25maWcubXV0YXRpb24sXG4gICAgICBwZXJzaXN0ZW5jZSA9IGNvbmZpZy5wZXJzaXN0ZW5jZTtcbiAgdmFyIGdldFJvb3RIb3N0Q29udGFpbmVyID0gaG9zdENvbnRleHQuZ2V0Um9vdEhvc3RDb250YWluZXIsXG4gICAgICBwb3BIb3N0Q29udGV4dCA9IGhvc3RDb250ZXh0LnBvcEhvc3RDb250ZXh0LFxuICAgICAgZ2V0SG9zdENvbnRleHQgPSBob3N0Q29udGV4dC5nZXRIb3N0Q29udGV4dCxcbiAgICAgIHBvcEhvc3RDb250YWluZXIgPSBob3N0Q29udGV4dC5wb3BIb3N0Q29udGFpbmVyO1xuICB2YXIgcHJlcGFyZVRvSHlkcmF0ZUhvc3RJbnN0YW5jZSA9IGh5ZHJhdGlvbkNvbnRleHQucHJlcGFyZVRvSHlkcmF0ZUhvc3RJbnN0YW5jZSxcbiAgICAgIHByZXBhcmVUb0h5ZHJhdGVIb3N0VGV4dEluc3RhbmNlID0gaHlkcmF0aW9uQ29udGV4dC5wcmVwYXJlVG9IeWRyYXRlSG9zdFRleHRJbnN0YW5jZSxcbiAgICAgIHBvcEh5ZHJhdGlvblN0YXRlID0gaHlkcmF0aW9uQ29udGV4dC5wb3BIeWRyYXRpb25TdGF0ZTtcblxuXG4gIGZ1bmN0aW9uIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpIHtcbiAgICAvLyBUYWcgdGhlIGZpYmVyIHdpdGggYW4gdXBkYXRlIGVmZmVjdC4gVGhpcyB0dXJucyBhIFBsYWNlbWVudCBpbnRvXG4gICAgLy8gYW4gVXBkYXRlQW5kUGxhY2VtZW50LlxuICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBVcGRhdGU7XG4gIH1cblxuICBmdW5jdGlvbiBtYXJrUmVmKHdvcmtJblByb2dyZXNzKSB7XG4gICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IFJlZjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFwcGVuZEFsbFJldHVybnMocmV0dXJucywgd29ya0luUHJvZ3Jlc3MpIHtcbiAgICB2YXIgbm9kZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgICBpZiAobm9kZSkge1xuICAgICAgbm9kZVsncmV0dXJuJ10gPSB3b3JrSW5Qcm9ncmVzcztcbiAgICB9XG4gICAgd2hpbGUgKG5vZGUgIT09IG51bGwpIHtcbiAgICAgIGlmIChub2RlLnRhZyA9PT0gSG9zdENvbXBvbmVudCB8fCBub2RlLnRhZyA9PT0gSG9zdFRleHQgfHwgbm9kZS50YWcgPT09IEhvc3RQb3J0YWwpIHtcbiAgICAgICAgaW52YXJpYW50KGZhbHNlLCAnQSBjYWxsIGNhbm5vdCBoYXZlIGhvc3QgY29tcG9uZW50IGNoaWxkcmVuLicpO1xuICAgICAgfSBlbHNlIGlmIChub2RlLnRhZyA9PT0gUmV0dXJuQ29tcG9uZW50KSB7XG4gICAgICAgIHJldHVybnMucHVzaChub2RlLnR5cGUpO1xuICAgICAgfSBlbHNlIGlmIChub2RlLmNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgIG5vZGUuY2hpbGRbJ3JldHVybiddID0gbm9kZTtcbiAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGQ7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgd2hpbGUgKG5vZGUuc2libGluZyA9PT0gbnVsbCkge1xuICAgICAgICBpZiAobm9kZVsncmV0dXJuJ10gPT09IG51bGwgfHwgbm9kZVsncmV0dXJuJ10gPT09IHdvcmtJblByb2dyZXNzKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUgPSBub2RlWydyZXR1cm4nXTtcbiAgICAgIH1cbiAgICAgIG5vZGUuc2libGluZ1sncmV0dXJuJ10gPSBub2RlWydyZXR1cm4nXTtcbiAgICAgIG5vZGUgPSBub2RlLnNpYmxpbmc7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbW92ZUNhbGxUb0hhbmRsZXJQaGFzZShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgICB2YXIgY2FsbCA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHM7XG4gICAgIWNhbGwgPyBpbnZhcmlhbnQoZmFsc2UsICdTaG91bGQgYmUgcmVzb2x2ZWQgYnkgbm93LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuXG4gICAgLy8gRmlyc3Qgc3RlcCBvZiB0aGUgY2FsbCBoYXMgY29tcGxldGVkLiBOb3cgd2UgbmVlZCB0byBkbyB0aGUgc2Vjb25kLlxuICAgIC8vIFRPRE86IEl0IHdvdWxkIGJlIG5pY2UgdG8gaGF2ZSBhIG11bHRpIHN0YWdlIGNhbGwgcmVwcmVzZW50ZWQgYnkgYVxuICAgIC8vIHNpbmdsZSBjb21wb25lbnQsIG9yIGF0IGxlYXN0IHRhaWwgY2FsbCBvcHRpbWl6ZSBuZXN0ZWQgb25lcy4gQ3VycmVudGx5XG4gICAgLy8gdGhhdCByZXF1aXJlcyBhZGRpdGlvbmFsIGZpZWxkcyB0aGF0IHdlIGRvbid0IHdhbnQgdG8gYWRkIHRvIHRoZSBmaWJlci5cbiAgICAvLyBTbyB0aGlzIHJlcXVpcmVzIG5lc3RlZCBoYW5kbGVycy5cbiAgICAvLyBOb3RlOiBUaGlzIGRvZXNuJ3QgbXV0YXRlIHRoZSBhbHRlcm5hdGUgbm9kZS4gSSBkb24ndCB0aGluayBpdCBuZWVkcyB0b1xuICAgIC8vIHNpbmNlIHRoaXMgc3RhZ2UgaXMgcmVzZXQgZm9yIGV2ZXJ5IHBhc3MuXG4gICAgd29ya0luUHJvZ3Jlc3MudGFnID0gQ2FsbEhhbmRsZXJQaGFzZTtcblxuICAgIC8vIEJ1aWxkIHVwIHRoZSByZXR1cm5zLlxuICAgIC8vIFRPRE86IENvbXBhcmUgdGhpcyB0byBhIGdlbmVyYXRvciBvciBvcGFxdWUgaGVscGVycyBsaWtlIENoaWxkcmVuLlxuICAgIHZhciByZXR1cm5zID0gW107XG4gICAgYXBwZW5kQWxsUmV0dXJucyhyZXR1cm5zLCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgdmFyIGZuID0gY2FsbC5oYW5kbGVyO1xuICAgIHZhciBwcm9wcyA9IGNhbGwucHJvcHM7XG4gICAgdmFyIG5leHRDaGlsZHJlbiA9IGZuKHByb3BzLCByZXR1cm5zKTtcblxuICAgIHZhciBjdXJyZW50Rmlyc3RDaGlsZCA9IGN1cnJlbnQgIT09IG51bGwgPyBjdXJyZW50LmNoaWxkIDogbnVsbDtcbiAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IHJlY29uY2lsZUNoaWxkRmliZXJzKHdvcmtJblByb2dyZXNzLCBjdXJyZW50Rmlyc3RDaGlsZCwgbmV4dENoaWxkcmVuLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICB9XG5cbiAgZnVuY3Rpb24gYXBwZW5kQWxsQ2hpbGRyZW4ocGFyZW50LCB3b3JrSW5Qcm9ncmVzcykge1xuICAgIC8vIFdlIG9ubHkgaGF2ZSB0aGUgdG9wIEZpYmVyIHRoYXQgd2FzIGNyZWF0ZWQgYnV0IHdlIG5lZWQgcmVjdXJzZSBkb3duIGl0c1xuICAgIC8vIGNoaWxkcmVuIHRvIGZpbmQgYWxsIHRoZSB0ZXJtaW5hbCBub2Rlcy5cbiAgICB2YXIgbm9kZSA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICAgIHdoaWxlIChub2RlICE9PSBudWxsKSB7XG4gICAgICBpZiAobm9kZS50YWcgPT09IEhvc3RDb21wb25lbnQgfHwgbm9kZS50YWcgPT09IEhvc3RUZXh0KSB7XG4gICAgICAgIGFwcGVuZEluaXRpYWxDaGlsZChwYXJlbnQsIG5vZGUuc3RhdGVOb2RlKTtcbiAgICAgIH0gZWxzZSBpZiAobm9kZS50YWcgPT09IEhvc3RQb3J0YWwpIHtcbiAgICAgICAgLy8gSWYgd2UgaGF2ZSBhIHBvcnRhbCBjaGlsZCwgdGhlbiB3ZSBkb24ndCB3YW50IHRvIHRyYXZlcnNlXG4gICAgICAgIC8vIGRvd24gaXRzIGNoaWxkcmVuLiBJbnN0ZWFkLCB3ZSdsbCBnZXQgaW5zZXJ0aW9ucyBmcm9tIGVhY2ggY2hpbGQgaW5cbiAgICAgICAgLy8gdGhlIHBvcnRhbCBkaXJlY3RseS5cbiAgICAgIH0gZWxzZSBpZiAobm9kZS5jaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICBub2RlLmNoaWxkWydyZXR1cm4nXSA9IG5vZGU7XG4gICAgICAgIG5vZGUgPSBub2RlLmNoaWxkO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChub2RlID09PSB3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB3aGlsZSAobm9kZS5zaWJsaW5nID09PSBudWxsKSB7XG4gICAgICAgIGlmIChub2RlWydyZXR1cm4nXSA9PT0gbnVsbCB8fCBub2RlWydyZXR1cm4nXSA9PT0gd29ya0luUHJvZ3Jlc3MpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbm9kZSA9IG5vZGVbJ3JldHVybiddO1xuICAgICAgfVxuICAgICAgbm9kZS5zaWJsaW5nWydyZXR1cm4nXSA9IG5vZGVbJ3JldHVybiddO1xuICAgICAgbm9kZSA9IG5vZGUuc2libGluZztcbiAgICB9XG4gIH1cblxuICB2YXIgdXBkYXRlSG9zdENvbnRhaW5lciA9IHZvaWQgMDtcbiAgdmFyIHVwZGF0ZUhvc3RDb21wb25lbnQgPSB2b2lkIDA7XG4gIHZhciB1cGRhdGVIb3N0VGV4dCA9IHZvaWQgMDtcbiAgaWYgKG11dGF0aW9uKSB7XG4gICAgaWYgKGVuYWJsZU11dGF0aW5nUmVjb25jaWxlcikge1xuICAgICAgLy8gTXV0YXRpb24gbW9kZVxuICAgICAgdXBkYXRlSG9zdENvbnRhaW5lciA9IGZ1bmN0aW9uICh3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgICAvLyBOb29wXG4gICAgICB9O1xuICAgICAgdXBkYXRlSG9zdENvbXBvbmVudCA9IGZ1bmN0aW9uIChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgdXBkYXRlUGF5bG9hZCwgdHlwZSwgb2xkUHJvcHMsIG5ld1Byb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UpIHtcbiAgICAgICAgLy8gVE9ETzogVHlwZSB0aGlzIHNwZWNpZmljIHRvIHRoaXMgdHlwZSBvZiBjb21wb25lbnQuXG4gICAgICAgIHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlID0gdXBkYXRlUGF5bG9hZDtcbiAgICAgICAgLy8gSWYgdGhlIHVwZGF0ZSBwYXlsb2FkIGluZGljYXRlcyB0aGF0IHRoZXJlIGlzIGEgY2hhbmdlIG9yIGlmIHRoZXJlXG4gICAgICAgIC8vIGlzIGEgbmV3IHJlZiB3ZSBtYXJrIHRoaXMgYXMgYW4gdXBkYXRlLiBBbGwgdGhlIHdvcmsgaXMgZG9uZSBpbiBjb21taXRXb3JrLlxuICAgICAgICBpZiAodXBkYXRlUGF5bG9hZCkge1xuICAgICAgICAgIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgdXBkYXRlSG9zdFRleHQgPSBmdW5jdGlvbiAoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG9sZFRleHQsIG5ld1RleHQpIHtcbiAgICAgICAgLy8gSWYgdGhlIHRleHQgZGlmZmVycywgbWFyayBpdCBhcyBhbiB1cGRhdGUuIEFsbCB0aGUgd29yayBpbiBkb25lIGluIGNvbW1pdFdvcmsuXG4gICAgICAgIGlmIChvbGRUZXh0ICE9PSBuZXdUZXh0KSB7XG4gICAgICAgICAgbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGludmFyaWFudChmYWxzZSwgJ011dGF0aW5nIHJlY29uY2lsZXIgaXMgZGlzYWJsZWQuJyk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHBlcnNpc3RlbmNlKSB7XG4gICAgaWYgKGVuYWJsZVBlcnNpc3RlbnRSZWNvbmNpbGVyKSB7XG4gICAgICAvLyBQZXJzaXN0ZW50IGhvc3QgdHJlZSBtb2RlXG4gICAgICB2YXIgY2xvbmVJbnN0YW5jZSA9IHBlcnNpc3RlbmNlLmNsb25lSW5zdGFuY2UsXG4gICAgICAgICAgY3JlYXRlQ29udGFpbmVyQ2hpbGRTZXQgPSBwZXJzaXN0ZW5jZS5jcmVhdGVDb250YWluZXJDaGlsZFNldCxcbiAgICAgICAgICBhcHBlbmRDaGlsZFRvQ29udGFpbmVyQ2hpbGRTZXQgPSBwZXJzaXN0ZW5jZS5hcHBlbmRDaGlsZFRvQ29udGFpbmVyQ2hpbGRTZXQsXG4gICAgICAgICAgZmluYWxpemVDb250YWluZXJDaGlsZHJlbiA9IHBlcnNpc3RlbmNlLmZpbmFsaXplQ29udGFpbmVyQ2hpbGRyZW47XG5cbiAgICAgIC8vIEFuIHVuZm9ydHVuYXRlIGZvcmsgb2YgYXBwZW5kQWxsQ2hpbGRyZW4gYmVjYXVzZSB3ZSBoYXZlIHR3byBkaWZmZXJlbnQgcGFyZW50IHR5cGVzLlxuXG4gICAgICB2YXIgYXBwZW5kQWxsQ2hpbGRyZW5Ub0NvbnRhaW5lciA9IGZ1bmN0aW9uIChjb250YWluZXJDaGlsZFNldCwgd29ya0luUHJvZ3Jlc3MpIHtcbiAgICAgICAgLy8gV2Ugb25seSBoYXZlIHRoZSB0b3AgRmliZXIgdGhhdCB3YXMgY3JlYXRlZCBidXQgd2UgbmVlZCByZWN1cnNlIGRvd24gaXRzXG4gICAgICAgIC8vIGNoaWxkcmVuIHRvIGZpbmQgYWxsIHRoZSB0ZXJtaW5hbCBub2Rlcy5cbiAgICAgICAgdmFyIG5vZGUgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgICAgICAgd2hpbGUgKG5vZGUgIT09IG51bGwpIHtcbiAgICAgICAgICBpZiAobm9kZS50YWcgPT09IEhvc3RDb21wb25lbnQgfHwgbm9kZS50YWcgPT09IEhvc3RUZXh0KSB7XG4gICAgICAgICAgICBhcHBlbmRDaGlsZFRvQ29udGFpbmVyQ2hpbGRTZXQoY29udGFpbmVyQ2hpbGRTZXQsIG5vZGUuc3RhdGVOb2RlKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKG5vZGUudGFnID09PSBIb3N0UG9ydGFsKSB7XG4gICAgICAgICAgICAvLyBJZiB3ZSBoYXZlIGEgcG9ydGFsIGNoaWxkLCB0aGVuIHdlIGRvbid0IHdhbnQgdG8gdHJhdmVyc2VcbiAgICAgICAgICAgIC8vIGRvd24gaXRzIGNoaWxkcmVuLiBJbnN0ZWFkLCB3ZSdsbCBnZXQgaW5zZXJ0aW9ucyBmcm9tIGVhY2ggY2hpbGQgaW5cbiAgICAgICAgICAgIC8vIHRoZSBwb3J0YWwgZGlyZWN0bHkuXG4gICAgICAgICAgfSBlbHNlIGlmIChub2RlLmNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgICAgICBub2RlLmNoaWxkWydyZXR1cm4nXSA9IG5vZGU7XG4gICAgICAgICAgICBub2RlID0gbm9kZS5jaGlsZDtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobm9kZSA9PT0gd29ya0luUHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgd2hpbGUgKG5vZGUuc2libGluZyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKG5vZGVbJ3JldHVybiddID09PSBudWxsIHx8IG5vZGVbJ3JldHVybiddID09PSB3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBub2RlID0gbm9kZVsncmV0dXJuJ107XG4gICAgICAgICAgfVxuICAgICAgICAgIG5vZGUuc2libGluZ1sncmV0dXJuJ10gPSBub2RlWydyZXR1cm4nXTtcbiAgICAgICAgICBub2RlID0gbm9kZS5zaWJsaW5nO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgdXBkYXRlSG9zdENvbnRhaW5lciA9IGZ1bmN0aW9uICh3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgICB2YXIgcG9ydGFsT3JSb290ID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAgICAgICB2YXIgY2hpbGRyZW5VbmNoYW5nZWQgPSB3b3JrSW5Qcm9ncmVzcy5maXJzdEVmZmVjdCA9PT0gbnVsbDtcbiAgICAgICAgaWYgKGNoaWxkcmVuVW5jaGFuZ2VkKSB7XG4gICAgICAgICAgLy8gTm8gY2hhbmdlcywganVzdCByZXVzZSB0aGUgZXhpc3RpbmcgaW5zdGFuY2UuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGNvbnRhaW5lciA9IHBvcnRhbE9yUm9vdC5jb250YWluZXJJbmZvO1xuICAgICAgICAgIHZhciBuZXdDaGlsZFNldCA9IGNyZWF0ZUNvbnRhaW5lckNoaWxkU2V0KGNvbnRhaW5lcik7XG4gICAgICAgICAgaWYgKGZpbmFsaXplQ29udGFpbmVyQ2hpbGRyZW4oY29udGFpbmVyLCBuZXdDaGlsZFNldCkpIHtcbiAgICAgICAgICAgIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwb3J0YWxPclJvb3QucGVuZGluZ0NoaWxkcmVuID0gbmV3Q2hpbGRTZXQ7XG4gICAgICAgICAgLy8gSWYgY2hpbGRyZW4gbWlnaHQgaGF2ZSBjaGFuZ2VkLCB3ZSBoYXZlIHRvIGFkZCB0aGVtIGFsbCB0byB0aGUgc2V0LlxuICAgICAgICAgIGFwcGVuZEFsbENoaWxkcmVuVG9Db250YWluZXIobmV3Q2hpbGRTZXQsIHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAvLyBTY2hlZHVsZSBhbiB1cGRhdGUgb24gdGhlIGNvbnRhaW5lciB0byBzd2FwIG91dCB0aGUgY29udGFpbmVyLlxuICAgICAgICAgIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgdXBkYXRlSG9zdENvbXBvbmVudCA9IGZ1bmN0aW9uIChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgdXBkYXRlUGF5bG9hZCwgdHlwZSwgb2xkUHJvcHMsIG5ld1Byb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UpIHtcbiAgICAgICAgLy8gSWYgdGhlcmUgYXJlIG5vIGVmZmVjdHMgYXNzb2NpYXRlZCB3aXRoIHRoaXMgbm9kZSwgdGhlbiBub25lIG9mIG91ciBjaGlsZHJlbiBoYWQgYW55IHVwZGF0ZXMuXG4gICAgICAgIC8vIFRoaXMgZ3VhcmFudGVlcyB0aGF0IHdlIGNhbiByZXVzZSBhbGwgb2YgdGhlbS5cbiAgICAgICAgdmFyIGNoaWxkcmVuVW5jaGFuZ2VkID0gd29ya0luUHJvZ3Jlc3MuZmlyc3RFZmZlY3QgPT09IG51bGw7XG4gICAgICAgIHZhciBjdXJyZW50SW5zdGFuY2UgPSBjdXJyZW50LnN0YXRlTm9kZTtcbiAgICAgICAgaWYgKGNoaWxkcmVuVW5jaGFuZ2VkICYmIHVwZGF0ZVBheWxvYWQgPT09IG51bGwpIHtcbiAgICAgICAgICAvLyBObyBjaGFuZ2VzLCBqdXN0IHJldXNlIHRoZSBleGlzdGluZyBpbnN0YW5jZS5cbiAgICAgICAgICAvLyBOb3RlIHRoYXQgdGhpcyBtaWdodCByZWxlYXNlIGEgcHJldmlvdXMgY2xvbmUuXG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gY3VycmVudEluc3RhbmNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciByZWN5Y2xhYmxlSW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICAgICAgICAgdmFyIG5ld0luc3RhbmNlID0gY2xvbmVJbnN0YW5jZShjdXJyZW50SW5zdGFuY2UsIHVwZGF0ZVBheWxvYWQsIHR5cGUsIG9sZFByb3BzLCBuZXdQcm9wcywgd29ya0luUHJvZ3Jlc3MsIGNoaWxkcmVuVW5jaGFuZ2VkLCByZWN5Y2xhYmxlSW5zdGFuY2UpO1xuICAgICAgICAgIGlmIChmaW5hbGl6ZUluaXRpYWxDaGlsZHJlbihuZXdJbnN0YW5jZSwgdHlwZSwgbmV3UHJvcHMsIHJvb3RDb250YWluZXJJbnN0YW5jZSkpIHtcbiAgICAgICAgICAgIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgPSBuZXdJbnN0YW5jZTtcbiAgICAgICAgICBpZiAoY2hpbGRyZW5VbmNoYW5nZWQpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZXJlIGFyZSBubyBvdGhlciBlZmZlY3RzIGluIHRoaXMgdHJlZSwgd2UgbmVlZCB0byBmbGFnIHRoaXMgbm9kZSBhcyBoYXZpbmcgb25lLlxuICAgICAgICAgICAgLy8gRXZlbiB0aG91Z2ggd2UncmUgbm90IGdvaW5nIHRvIHVzZSBpdCBmb3IgYW55dGhpbmcuXG4gICAgICAgICAgICAvLyBPdGhlcndpc2UgcGFyZW50cyB3b24ndCBrbm93IHRoYXQgdGhlcmUgYXJlIG5ldyBjaGlsZHJlbiB0byBwcm9wYWdhdGUgdXB3YXJkcy5cbiAgICAgICAgICAgIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBJZiBjaGlsZHJlbiBtaWdodCBoYXZlIGNoYW5nZWQsIHdlIGhhdmUgdG8gYWRkIHRoZW0gYWxsIHRvIHRoZSBzZXQuXG4gICAgICAgICAgICBhcHBlbmRBbGxDaGlsZHJlbihuZXdJbnN0YW5jZSwgd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHVwZGF0ZUhvc3RUZXh0ID0gZnVuY3Rpb24gKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBvbGRUZXh0LCBuZXdUZXh0KSB7XG4gICAgICAgIGlmIChvbGRUZXh0ICE9PSBuZXdUZXh0KSB7XG4gICAgICAgICAgLy8gSWYgdGhlIHRleHQgY29udGVudCBkaWZmZXJzLCB3ZSdsbCBjcmVhdGUgYSBuZXcgdGV4dCBpbnN0YW5jZSBmb3IgaXQuXG4gICAgICAgICAgdmFyIHJvb3RDb250YWluZXJJbnN0YW5jZSA9IGdldFJvb3RIb3N0Q29udGFpbmVyKCk7XG4gICAgICAgICAgdmFyIGN1cnJlbnRIb3N0Q29udGV4dCA9IGdldEhvc3RDb250ZXh0KCk7XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gY3JlYXRlVGV4dEluc3RhbmNlKG5ld1RleHQsIHJvb3RDb250YWluZXJJbnN0YW5jZSwgY3VycmVudEhvc3RDb250ZXh0LCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgLy8gV2UnbGwgaGF2ZSB0byBtYXJrIGl0IGFzIGhhdmluZyBhbiBlZmZlY3QsIGV2ZW4gdGhvdWdoIHdlIHdvbid0IHVzZSB0aGUgZWZmZWN0IGZvciBhbnl0aGluZy5cbiAgICAgICAgICAvLyBUaGlzIGxldHMgdGhlIHBhcmVudHMga25vdyB0aGF0IGF0IGxlYXN0IG9uZSBvZiB0aGVpciBjaGlsZHJlbiBoYXMgY2hhbmdlZC5cbiAgICAgICAgICBtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW52YXJpYW50KGZhbHNlLCAnUGVyc2lzdGVudCByZWNvbmNpbGVyIGlzIGRpc2FibGVkLicpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoZW5hYmxlTm9vcFJlY29uY2lsZXIpIHtcbiAgICAgIC8vIE5vIGhvc3Qgb3BlcmF0aW9uc1xuICAgICAgdXBkYXRlSG9zdENvbnRhaW5lciA9IGZ1bmN0aW9uICh3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgICAvLyBOb29wXG4gICAgICB9O1xuICAgICAgdXBkYXRlSG9zdENvbXBvbmVudCA9IGZ1bmN0aW9uIChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgdXBkYXRlUGF5bG9hZCwgdHlwZSwgb2xkUHJvcHMsIG5ld1Byb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UpIHtcbiAgICAgICAgLy8gTm9vcFxuICAgICAgfTtcbiAgICAgIHVwZGF0ZUhvc3RUZXh0ID0gZnVuY3Rpb24gKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBvbGRUZXh0LCBuZXdUZXh0KSB7XG4gICAgICAgIC8vIE5vb3BcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGludmFyaWFudChmYWxzZSwgJ05vb3AgcmVjb25jaWxlciBpcyBkaXNhYmxlZC4nKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjb21wbGV0ZVdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gICAgLy8gR2V0IHRoZSBsYXRlc3QgcHJvcHMuXG4gICAgdmFyIG5ld1Byb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICAgIGlmIChuZXdQcm9wcyA9PT0gbnVsbCkge1xuICAgICAgbmV3UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzO1xuICAgIH0gZWxzZSBpZiAod29ya0luUHJvZ3Jlc3MuZXhwaXJhdGlvblRpbWUgIT09IE5ldmVyIHx8IHJlbmRlckV4cGlyYXRpb25UaW1lID09PSBOZXZlcikge1xuICAgICAgLy8gUmVzZXQgdGhlIHBlbmRpbmcgcHJvcHMsIHVubGVzcyB0aGlzIHdhcyBhIGRvd24tcHJpb3JpdGl6YXRpb24uXG4gICAgICB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHMgPSBudWxsO1xuICAgIH1cblxuICAgIHN3aXRjaCAod29ya0luUHJvZ3Jlc3MudGFnKSB7XG4gICAgICBjYXNlIEZ1bmN0aW9uYWxDb21wb25lbnQ6XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgICAge1xuICAgICAgICAgIC8vIFdlIGFyZSBsZWF2aW5nIHRoaXMgc3VidHJlZSwgc28gcG9wIGNvbnRleHQgaWYgYW55LlxuICAgICAgICAgIHBvcENvbnRleHRQcm92aWRlcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgIHtcbiAgICAgICAgICBwb3BIb3N0Q29udGFpbmVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICBwb3BUb3BMZXZlbENvbnRleHRPYmplY3Qod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIHZhciBmaWJlclJvb3QgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICAgICAgICAgaWYgKGZpYmVyUm9vdC5wZW5kaW5nQ29udGV4dCkge1xuICAgICAgICAgICAgZmliZXJSb290LmNvbnRleHQgPSBmaWJlclJvb3QucGVuZGluZ0NvbnRleHQ7XG4gICAgICAgICAgICBmaWJlclJvb3QucGVuZGluZ0NvbnRleHQgPSBudWxsO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChjdXJyZW50ID09PSBudWxsIHx8IGN1cnJlbnQuY2hpbGQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIElmIHdlIGh5ZHJhdGVkLCBwb3Agc28gdGhhdCB3ZSBjYW4gZGVsZXRlIGFueSByZW1haW5pbmcgY2hpbGRyZW5cbiAgICAgICAgICAgIC8vIHRoYXQgd2VyZW4ndCBoeWRyYXRlZC5cbiAgICAgICAgICAgIHBvcEh5ZHJhdGlvblN0YXRlKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAgIC8vIFRoaXMgcmVzZXRzIHRoZSBoYWNreSBzdGF0ZSB0byBmaXggaXNNb3VudGVkIGJlZm9yZSBjb21taXR0aW5nLlxuICAgICAgICAgICAgLy8gVE9ETzogRGVsZXRlIHRoaXMgd2hlbiB3ZSBkZWxldGUgaXNNb3VudGVkIGFuZCBmaW5kRE9NTm9kZS5cbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyAmPSB+UGxhY2VtZW50O1xuICAgICAgICAgIH1cbiAgICAgICAgICB1cGRhdGVIb3N0Q29udGFpbmVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICB7XG4gICAgICAgICAgcG9wSG9zdENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIHZhciByb290Q29udGFpbmVySW5zdGFuY2UgPSBnZXRSb290SG9zdENvbnRhaW5lcigpO1xuICAgICAgICAgIHZhciB0eXBlID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgICAgICAgICBpZiAoY3VycmVudCAhPT0gbnVsbCAmJiB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gSWYgd2UgaGF2ZSBhbiBhbHRlcm5hdGUsIHRoYXQgbWVhbnMgdGhpcyBpcyBhbiB1cGRhdGUgYW5kIHdlIG5lZWQgdG9cbiAgICAgICAgICAgIC8vIHNjaGVkdWxlIGEgc2lkZS1lZmZlY3QgdG8gZG8gdGhlIHVwZGF0ZXMuXG4gICAgICAgICAgICB2YXIgb2xkUHJvcHMgPSBjdXJyZW50Lm1lbW9pemVkUHJvcHM7XG4gICAgICAgICAgICAvLyBJZiB3ZSBnZXQgdXBkYXRlZCBiZWNhdXNlIG9uZSBvZiBvdXIgY2hpbGRyZW4gdXBkYXRlZCwgd2UgZG9uJ3RcbiAgICAgICAgICAgIC8vIGhhdmUgbmV3UHJvcHMgc28gd2UnbGwgaGF2ZSB0byByZXVzZSB0aGVtLlxuICAgICAgICAgICAgLy8gVE9ETzogU3BsaXQgdGhlIHVwZGF0ZSBBUEkgYXMgc2VwYXJhdGUgZm9yIHRoZSBwcm9wcyB2cy4gY2hpbGRyZW4uXG4gICAgICAgICAgICAvLyBFdmVuIGJldHRlciB3b3VsZCBiZSBpZiBjaGlsZHJlbiB3ZXJlbid0IHNwZWNpYWwgY2FzZWQgYXQgYWxsIHRoby5cbiAgICAgICAgICAgIHZhciBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgICAgICAgICAgIHZhciBjdXJyZW50SG9zdENvbnRleHQgPSBnZXRIb3N0Q29udGV4dCgpO1xuICAgICAgICAgICAgdmFyIHVwZGF0ZVBheWxvYWQgPSBwcmVwYXJlVXBkYXRlKGluc3RhbmNlLCB0eXBlLCBvbGRQcm9wcywgbmV3UHJvcHMsIHJvb3RDb250YWluZXJJbnN0YW5jZSwgY3VycmVudEhvc3RDb250ZXh0KTtcblxuICAgICAgICAgICAgdXBkYXRlSG9zdENvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgdXBkYXRlUGF5bG9hZCwgdHlwZSwgb2xkUHJvcHMsIG5ld1Byb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UpO1xuXG4gICAgICAgICAgICBpZiAoY3VycmVudC5yZWYgIT09IHdvcmtJblByb2dyZXNzLnJlZikge1xuICAgICAgICAgICAgICBtYXJrUmVmKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFuZXdQcm9wcykge1xuICAgICAgICAgICAgICAhKHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSAhPT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdXZSBtdXN0IGhhdmUgbmV3IHByb3BzIGZvciBuZXcgbW91bnRzLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuICAgICAgICAgICAgICAvLyBUaGlzIGNhbiBoYXBwZW4gd2hlbiB3ZSBhYm9ydCB3b3JrLlxuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIF9jdXJyZW50SG9zdENvbnRleHQgPSBnZXRIb3N0Q29udGV4dCgpO1xuICAgICAgICAgICAgLy8gVE9ETzogTW92ZSBjcmVhdGVJbnN0YW5jZSB0byBiZWdpbldvcmsgYW5kIGtlZXAgaXQgb24gYSBjb250ZXh0XG4gICAgICAgICAgICAvLyBcInN0YWNrXCIgYXMgdGhlIHBhcmVudC4gVGhlbiBhcHBlbmQgY2hpbGRyZW4gYXMgd2UgZ28gaW4gYmVnaW5Xb3JrXG4gICAgICAgICAgICAvLyBvciBjb21wbGV0ZVdvcmsgZGVwZW5kaW5nIG9uIHdlIHdhbnQgdG8gYWRkIHRoZW4gdG9wLT5kb3duIG9yXG4gICAgICAgICAgICAvLyBib3R0b20tPnVwLiBUb3AtPmRvd24gaXMgZmFzdGVyIGluIElFMTEuXG4gICAgICAgICAgICB2YXIgd2FzSHlkcmF0ZWQgPSBwb3BIeWRyYXRpb25TdGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgICBpZiAod2FzSHlkcmF0ZWQpIHtcbiAgICAgICAgICAgICAgLy8gVE9ETzogTW92ZSB0aGlzIGFuZCBjcmVhdGVJbnN0YW5jZSBzdGVwIGludG8gdGhlIGJlZ2luUGhhc2VcbiAgICAgICAgICAgICAgLy8gdG8gY29uc29saWRhdGUuXG4gICAgICAgICAgICAgIGlmIChwcmVwYXJlVG9IeWRyYXRlSG9zdEluc3RhbmNlKHdvcmtJblByb2dyZXNzLCByb290Q29udGFpbmVySW5zdGFuY2UsIF9jdXJyZW50SG9zdENvbnRleHQpKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgY2hhbmdlcyB0byB0aGUgaHlkcmF0ZWQgbm9kZSBuZWVkcyB0byBiZSBhcHBsaWVkIGF0IHRoZVxuICAgICAgICAgICAgICAgIC8vIGNvbW1pdC1waGFzZSB3ZSBtYXJrIHRoaXMgYXMgc3VjaC5cbiAgICAgICAgICAgICAgICBtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIF9pbnN0YW5jZSA9IGNyZWF0ZUluc3RhbmNlKHR5cGUsIG5ld1Byb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UsIF9jdXJyZW50SG9zdENvbnRleHQsIHdvcmtJblByb2dyZXNzKTtcblxuICAgICAgICAgICAgICBhcHBlbmRBbGxDaGlsZHJlbihfaW5zdGFuY2UsIHdvcmtJblByb2dyZXNzKTtcblxuICAgICAgICAgICAgICAvLyBDZXJ0YWluIHJlbmRlcmVycyByZXF1aXJlIGNvbW1pdC10aW1lIGVmZmVjdHMgZm9yIGluaXRpYWwgbW91bnQuXG4gICAgICAgICAgICAgIC8vIChlZyBET00gcmVuZGVyZXIgc3VwcG9ydHMgYXV0by1mb2N1cyBmb3IgY2VydGFpbiBlbGVtZW50cykuXG4gICAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSBzdWNoIHJlbmRlcmVycyBnZXQgc2NoZWR1bGVkIGZvciBsYXRlciB3b3JrLlxuICAgICAgICAgICAgICBpZiAoZmluYWxpemVJbml0aWFsQ2hpbGRyZW4oX2luc3RhbmNlLCB0eXBlLCBuZXdQcm9wcywgcm9vdENvbnRhaW5lckluc3RhbmNlKSkge1xuICAgICAgICAgICAgICAgIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IF9pbnN0YW5jZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHdvcmtJblByb2dyZXNzLnJlZiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAvLyBJZiB0aGVyZSBpcyBhIHJlZiBvbiBhIGhvc3Qgbm9kZSB3ZSBuZWVkIHRvIHNjaGVkdWxlIGEgY2FsbGJhY2tcbiAgICAgICAgICAgICAgbWFya1JlZih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICBjYXNlIEhvc3RUZXh0OlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIG5ld1RleHQgPSBuZXdQcm9wcztcbiAgICAgICAgICBpZiAoY3VycmVudCAmJiB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIG9sZFRleHQgPSBjdXJyZW50Lm1lbW9pemVkUHJvcHM7XG4gICAgICAgICAgICAvLyBJZiB3ZSBoYXZlIGFuIGFsdGVybmF0ZSwgdGhhdCBtZWFucyB0aGlzIGlzIGFuIHVwZGF0ZSBhbmQgd2UgbmVlZFxuICAgICAgICAgICAgLy8gdG8gc2NoZWR1bGUgYSBzaWRlLWVmZmVjdCB0byBkbyB0aGUgdXBkYXRlcy5cbiAgICAgICAgICAgIHVwZGF0ZUhvc3RUZXh0KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBvbGRUZXh0LCBuZXdUZXh0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBuZXdUZXh0ICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAhKHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSAhPT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdXZSBtdXN0IGhhdmUgbmV3IHByb3BzIGZvciBuZXcgbW91bnRzLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuICAgICAgICAgICAgICAvLyBUaGlzIGNhbiBoYXBwZW4gd2hlbiB3ZSBhYm9ydCB3b3JrLlxuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBfcm9vdENvbnRhaW5lckluc3RhbmNlID0gZ2V0Um9vdEhvc3RDb250YWluZXIoKTtcbiAgICAgICAgICAgIHZhciBfY3VycmVudEhvc3RDb250ZXh0MiA9IGdldEhvc3RDb250ZXh0KCk7XG4gICAgICAgICAgICB2YXIgX3dhc0h5ZHJhdGVkID0gcG9wSHlkcmF0aW9uU3RhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgICAgaWYgKF93YXNIeWRyYXRlZCkge1xuICAgICAgICAgICAgICBpZiAocHJlcGFyZVRvSHlkcmF0ZUhvc3RUZXh0SW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MpKSB7XG4gICAgICAgICAgICAgICAgbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IGNyZWF0ZVRleHRJbnN0YW5jZShuZXdUZXh0LCBfcm9vdENvbnRhaW5lckluc3RhbmNlLCBfY3VycmVudEhvc3RDb250ZXh0Miwgd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgY2FzZSBDYWxsQ29tcG9uZW50OlxuICAgICAgICByZXR1cm4gbW92ZUNhbGxUb0hhbmRsZXJQaGFzZShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgICAgY2FzZSBDYWxsSGFuZGxlclBoYXNlOlxuICAgICAgICAvLyBSZXNldCB0aGUgdGFnIHRvIG5vdyBiZSBhIGZpcnN0IHBoYXNlIGNhbGwuXG4gICAgICAgIHdvcmtJblByb2dyZXNzLnRhZyA9IENhbGxDb21wb25lbnQ7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgY2FzZSBSZXR1cm5Db21wb25lbnQ6XG4gICAgICAgIC8vIERvZXMgbm90aGluZy5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICBjYXNlIEZyYWdtZW50OlxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICAgICAgcG9wSG9zdENvbnRhaW5lcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIHVwZGF0ZUhvc3RDb250YWluZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIC8vIEVycm9yIGNhc2VzXG4gICAgICBjYXNlIEluZGV0ZXJtaW5hdGVDb21wb25lbnQ6XG4gICAgICAgIGludmFyaWFudChmYWxzZSwgJ0FuIGluZGV0ZXJtaW5hdGUgY29tcG9uZW50IHNob3VsZCBoYXZlIGJlY29tZSBkZXRlcm1pbmF0ZSBiZWZvcmUgY29tcGxldGluZy4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1mYWxsdGhyb3VnaFxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaW52YXJpYW50KGZhbHNlLCAnVW5rbm93biB1bml0IG9mIHdvcmsgdGFnLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgY29tcGxldGVXb3JrOiBjb21wbGV0ZVdvcmtcbiAgfTtcbn07XG5cbnZhciBpbnZva2VHdWFyZGVkQ2FsbGJhY2skMiA9IFJlYWN0RXJyb3JVdGlscy5pbnZva2VHdWFyZGVkQ2FsbGJhY2s7XG52YXIgaGFzQ2F1Z2h0RXJyb3IkMSA9IFJlYWN0RXJyb3JVdGlscy5oYXNDYXVnaHRFcnJvcjtcbnZhciBjbGVhckNhdWdodEVycm9yJDEgPSBSZWFjdEVycm9yVXRpbHMuY2xlYXJDYXVnaHRFcnJvcjtcblxuXG52YXIgUmVhY3RGaWJlckNvbW1pdFdvcmsgPSBmdW5jdGlvbiAoY29uZmlnLCBjYXB0dXJlRXJyb3IpIHtcbiAgdmFyIGdldFB1YmxpY0luc3RhbmNlID0gY29uZmlnLmdldFB1YmxpY0luc3RhbmNlLFxuICAgICAgbXV0YXRpb24gPSBjb25maWcubXV0YXRpb24sXG4gICAgICBwZXJzaXN0ZW5jZSA9IGNvbmZpZy5wZXJzaXN0ZW5jZTtcblxuXG4gIHZhciBjYWxsQ29tcG9uZW50V2lsbFVubW91bnRXaXRoVGltZXIgPSBmdW5jdGlvbiAoY3VycmVudCwgaW5zdGFuY2UpIHtcbiAgICBzdGFydFBoYXNlVGltZXIoY3VycmVudCwgJ2NvbXBvbmVudFdpbGxVbm1vdW50Jyk7XG4gICAgaW5zdGFuY2UucHJvcHMgPSBjdXJyZW50Lm1lbW9pemVkUHJvcHM7XG4gICAgaW5zdGFuY2Uuc3RhdGUgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGU7XG4gICAgaW5zdGFuY2UuY29tcG9uZW50V2lsbFVubW91bnQoKTtcbiAgICBzdG9wUGhhc2VUaW1lcigpO1xuICB9O1xuXG4gIC8vIENhcHR1cmUgZXJyb3JzIHNvIHRoZXkgZG9uJ3QgaW50ZXJydXB0IHVubW91bnRpbmcuXG4gIGZ1bmN0aW9uIHNhZmVseUNhbGxDb21wb25lbnRXaWxsVW5tb3VudChjdXJyZW50LCBpbnN0YW5jZSkge1xuICAgIHtcbiAgICAgIGludm9rZUd1YXJkZWRDYWxsYmFjayQyKG51bGwsIGNhbGxDb21wb25lbnRXaWxsVW5tb3VudFdpdGhUaW1lciwgbnVsbCwgY3VycmVudCwgaW5zdGFuY2UpO1xuICAgICAgaWYgKGhhc0NhdWdodEVycm9yJDEoKSkge1xuICAgICAgICB2YXIgdW5tb3VudEVycm9yID0gY2xlYXJDYXVnaHRFcnJvciQxKCk7XG4gICAgICAgIGNhcHR1cmVFcnJvcihjdXJyZW50LCB1bm1vdW50RXJyb3IpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNhZmVseURldGFjaFJlZihjdXJyZW50KSB7XG4gICAgdmFyIHJlZiA9IGN1cnJlbnQucmVmO1xuICAgIGlmIChyZWYgIT09IG51bGwpIHtcbiAgICAgIHtcbiAgICAgICAgaW52b2tlR3VhcmRlZENhbGxiYWNrJDIobnVsbCwgcmVmLCBudWxsLCBudWxsKTtcbiAgICAgICAgaWYgKGhhc0NhdWdodEVycm9yJDEoKSkge1xuICAgICAgICAgIHZhciByZWZFcnJvciA9IGNsZWFyQ2F1Z2h0RXJyb3IkMSgpO1xuICAgICAgICAgIGNhcHR1cmVFcnJvcihjdXJyZW50LCByZWZFcnJvcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjb21taXRMaWZlQ3ljbGVzKGN1cnJlbnQsIGZpbmlzaGVkV29yaykge1xuICAgIHN3aXRjaCAoZmluaXNoZWRXb3JrLnRhZykge1xuICAgICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBpbnN0YW5jZSA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG4gICAgICAgICAgaWYgKGZpbmlzaGVkV29yay5lZmZlY3RUYWcgJiBVcGRhdGUpIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIHN0YXJ0UGhhc2VUaW1lcihmaW5pc2hlZFdvcmssICdjb21wb25lbnREaWRNb3VudCcpO1xuICAgICAgICAgICAgICBpbnN0YW5jZS5wcm9wcyA9IGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzO1xuICAgICAgICAgICAgICBpbnN0YW5jZS5zdGF0ZSA9IGZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlO1xuICAgICAgICAgICAgICBpbnN0YW5jZS5jb21wb25lbnREaWRNb3VudCgpO1xuICAgICAgICAgICAgICBzdG9wUGhhc2VUaW1lcigpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIHByZXZQcm9wcyA9IGN1cnJlbnQubWVtb2l6ZWRQcm9wcztcbiAgICAgICAgICAgICAgdmFyIHByZXZTdGF0ZSA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgICAgICAgc3RhcnRQaGFzZVRpbWVyKGZpbmlzaGVkV29yaywgJ2NvbXBvbmVudERpZFVwZGF0ZScpO1xuICAgICAgICAgICAgICBpbnN0YW5jZS5wcm9wcyA9IGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzO1xuICAgICAgICAgICAgICBpbnN0YW5jZS5zdGF0ZSA9IGZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlO1xuICAgICAgICAgICAgICBpbnN0YW5jZS5jb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzLCBwcmV2U3RhdGUpO1xuICAgICAgICAgICAgICBzdG9wUGhhc2VUaW1lcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgdXBkYXRlUXVldWUgPSBmaW5pc2hlZFdvcmsudXBkYXRlUXVldWU7XG4gICAgICAgICAgaWYgKHVwZGF0ZVF1ZXVlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjb21taXRDYWxsYmFja3ModXBkYXRlUXVldWUsIGluc3RhbmNlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIF91cGRhdGVRdWV1ZSA9IGZpbmlzaGVkV29yay51cGRhdGVRdWV1ZTtcbiAgICAgICAgICBpZiAoX3VwZGF0ZVF1ZXVlICE9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgX2luc3RhbmNlID0gZmluaXNoZWRXb3JrLmNoaWxkICE9PSBudWxsID8gZmluaXNoZWRXb3JrLmNoaWxkLnN0YXRlTm9kZSA6IG51bGw7XG4gICAgICAgICAgICBjb21taXRDYWxsYmFja3MoX3VwZGF0ZVF1ZXVlLCBfaW5zdGFuY2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBfaW5zdGFuY2UyID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcblxuICAgICAgICAgIC8vIFJlbmRlcmVycyBtYXkgc2NoZWR1bGUgd29yayB0byBiZSBkb25lIGFmdGVyIGhvc3QgY29tcG9uZW50cyBhcmUgbW91bnRlZFxuICAgICAgICAgIC8vIChlZyBET00gcmVuZGVyZXIgbWF5IHNjaGVkdWxlIGF1dG8tZm9jdXMgZm9yIGlucHV0cyBhbmQgZm9ybSBjb250cm9scykuXG4gICAgICAgICAgLy8gVGhlc2UgZWZmZWN0cyBzaG91bGQgb25seSBiZSBjb21taXR0ZWQgd2hlbiBjb21wb25lbnRzIGFyZSBmaXJzdCBtb3VudGVkLFxuICAgICAgICAgIC8vIGFrYSB3aGVuIHRoZXJlIGlzIG5vIGN1cnJlbnQvYWx0ZXJuYXRlLlxuICAgICAgICAgIGlmIChjdXJyZW50ID09PSBudWxsICYmIGZpbmlzaGVkV29yay5lZmZlY3RUYWcgJiBVcGRhdGUpIHtcbiAgICAgICAgICAgIHZhciB0eXBlID0gZmluaXNoZWRXb3JrLnR5cGU7XG4gICAgICAgICAgICB2YXIgcHJvcHMgPSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcztcbiAgICAgICAgICAgIGNvbW1pdE1vdW50KF9pbnN0YW5jZTIsIHR5cGUsIHByb3BzLCBmaW5pc2hlZFdvcmspO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgY2FzZSBIb3N0VGV4dDpcbiAgICAgICAge1xuICAgICAgICAgIC8vIFdlIGhhdmUgbm8gbGlmZS1jeWNsZXMgYXNzb2NpYXRlZCB3aXRoIHRleHQuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICBjYXNlIEhvc3RQb3J0YWw6XG4gICAgICAgIHtcbiAgICAgICAgICAvLyBXZSBoYXZlIG5vIGxpZmUtY3ljbGVzIGFzc29jaWF0ZWQgd2l0aCBwb3J0YWxzLlxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAge1xuICAgICAgICAgIGludmFyaWFudChmYWxzZSwgJ1RoaXMgdW5pdCBvZiB3b3JrIHRhZyBzaG91bGQgbm90IGhhdmUgc2lkZS1lZmZlY3RzLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY29tbWl0QXR0YWNoUmVmKGZpbmlzaGVkV29yaykge1xuICAgIHZhciByZWYgPSBmaW5pc2hlZFdvcmsucmVmO1xuICAgIGlmIChyZWYgIT09IG51bGwpIHtcbiAgICAgIHZhciBpbnN0YW5jZSA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG4gICAgICBzd2l0Y2ggKGZpbmlzaGVkV29yay50YWcpIHtcbiAgICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICAgIHJlZihnZXRQdWJsaWNJbnN0YW5jZShpbnN0YW5jZSkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJlZihpbnN0YW5jZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY29tbWl0RGV0YWNoUmVmKGN1cnJlbnQpIHtcbiAgICB2YXIgY3VycmVudFJlZiA9IGN1cnJlbnQucmVmO1xuICAgIGlmIChjdXJyZW50UmVmICE9PSBudWxsKSB7XG4gICAgICBjdXJyZW50UmVmKG51bGwpO1xuICAgIH1cbiAgfVxuXG4gIC8vIFVzZXItb3JpZ2luYXRpbmcgZXJyb3JzIChsaWZlY3ljbGVzIGFuZCByZWZzKSBzaG91bGQgbm90IGludGVycnVwdFxuICAvLyBkZWxldGlvbiwgc28gZG9uJ3QgbGV0IHRoZW0gdGhyb3cuIEhvc3Qtb3JpZ2luYXRpbmcgZXJyb3JzIHNob3VsZFxuICAvLyBpbnRlcnJ1cHQgZGVsZXRpb24sIHNvIGl0J3Mgb2theVxuICBmdW5jdGlvbiBjb21taXRVbm1vdW50KGN1cnJlbnQpIHtcbiAgICBpZiAodHlwZW9mIG9uQ29tbWl0VW5tb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgb25Db21taXRVbm1vdW50KGN1cnJlbnQpO1xuICAgIH1cblxuICAgIHN3aXRjaCAoY3VycmVudC50YWcpIHtcbiAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICAgIHtcbiAgICAgICAgICBzYWZlbHlEZXRhY2hSZWYoY3VycmVudCk7XG4gICAgICAgICAgdmFyIGluc3RhbmNlID0gY3VycmVudC5zdGF0ZU5vZGU7XG4gICAgICAgICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsVW5tb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgc2FmZWx5Q2FsbENvbXBvbmVudFdpbGxVbm1vdW50KGN1cnJlbnQsIGluc3RhbmNlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgIHtcbiAgICAgICAgICBzYWZlbHlEZXRhY2hSZWYoY3VycmVudCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICBjYXNlIENhbGxDb21wb25lbnQ6XG4gICAgICAgIHtcbiAgICAgICAgICBjb21taXROZXN0ZWRVbm1vdW50cyhjdXJyZW50LnN0YXRlTm9kZSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICBjYXNlIEhvc3RQb3J0YWw6XG4gICAgICAgIHtcbiAgICAgICAgICAvLyBUT0RPOiB0aGlzIGlzIHJlY3Vyc2l2ZS5cbiAgICAgICAgICAvLyBXZSBhcmUgYWxzbyBub3QgdXNpbmcgdGhpcyBwYXJlbnQgYmVjYXVzZVxuICAgICAgICAgIC8vIHRoZSBwb3J0YWwgd2lsbCBnZXQgcHVzaGVkIGltbWVkaWF0ZWx5LlxuICAgICAgICAgIGlmIChlbmFibGVNdXRhdGluZ1JlY29uY2lsZXIgJiYgbXV0YXRpb24pIHtcbiAgICAgICAgICAgIHVubW91bnRIb3N0Q29tcG9uZW50cyhjdXJyZW50KTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGVuYWJsZVBlcnNpc3RlbnRSZWNvbmNpbGVyICYmIHBlcnNpc3RlbmNlKSB7XG4gICAgICAgICAgICBlbXB0eVBvcnRhbENvbnRhaW5lcihjdXJyZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY29tbWl0TmVzdGVkVW5tb3VudHMocm9vdCkge1xuICAgIC8vIFdoaWxlIHdlJ3JlIGluc2lkZSBhIHJlbW92ZWQgaG9zdCBub2RlIHdlIGRvbid0IHdhbnQgdG8gY2FsbFxuICAgIC8vIHJlbW92ZUNoaWxkIG9uIHRoZSBpbm5lciBub2RlcyBiZWNhdXNlIHRoZXkncmUgcmVtb3ZlZCBieSB0aGUgdG9wXG4gICAgLy8gY2FsbCBhbnl3YXkuIFdlIGFsc28gd2FudCB0byBjYWxsIGNvbXBvbmVudFdpbGxVbm1vdW50IG9uIGFsbFxuICAgIC8vIGNvbXBvc2l0ZXMgYmVmb3JlIHRoaXMgaG9zdCBub2RlIGlzIHJlbW92ZWQgZnJvbSB0aGUgdHJlZS4gVGhlcmVmb3JlXG4gICAgdmFyIG5vZGUgPSByb290O1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBjb21taXRVbm1vdW50KG5vZGUpO1xuICAgICAgLy8gVmlzaXQgY2hpbGRyZW4gYmVjYXVzZSB0aGV5IG1heSBjb250YWluIG1vcmUgY29tcG9zaXRlIG9yIGhvc3Qgbm9kZXMuXG4gICAgICAvLyBTa2lwIHBvcnRhbHMgYmVjYXVzZSBjb21taXRVbm1vdW50KCkgY3VycmVudGx5IHZpc2l0cyB0aGVtIHJlY3Vyc2l2ZWx5LlxuICAgICAgaWYgKG5vZGUuY2hpbGQgIT09IG51bGwgJiYgKFxuICAgICAgLy8gSWYgd2UgdXNlIG11dGF0aW9uIHdlIGRyaWxsIGRvd24gaW50byBwb3J0YWxzIHVzaW5nIGNvbW1pdFVubW91bnQgYWJvdmUuXG4gICAgICAvLyBJZiB3ZSBkb24ndCB1c2UgbXV0YXRpb24gd2UgZHJpbGwgZG93biBpbnRvIHBvcnRhbHMgaGVyZSBpbnN0ZWFkLlxuICAgICAgIW11dGF0aW9uIHx8IG5vZGUudGFnICE9PSBIb3N0UG9ydGFsKSkge1xuICAgICAgICBub2RlLmNoaWxkWydyZXR1cm4nXSA9IG5vZGU7XG4gICAgICAgIG5vZGUgPSBub2RlLmNoaWxkO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChub2RlID09PSByb290KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHdoaWxlIChub2RlLnNpYmxpbmcgPT09IG51bGwpIHtcbiAgICAgICAgaWYgKG5vZGVbJ3JldHVybiddID09PSBudWxsIHx8IG5vZGVbJ3JldHVybiddID09PSByb290KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUgPSBub2RlWydyZXR1cm4nXTtcbiAgICAgIH1cbiAgICAgIG5vZGUuc2libGluZ1sncmV0dXJuJ10gPSBub2RlWydyZXR1cm4nXTtcbiAgICAgIG5vZGUgPSBub2RlLnNpYmxpbmc7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZGV0YWNoRmliZXIoY3VycmVudCkge1xuICAgIC8vIEN1dCBvZmYgdGhlIHJldHVybiBwb2ludGVycyB0byBkaXNjb25uZWN0IGl0IGZyb20gdGhlIHRyZWUuIElkZWFsbHksIHdlXG4gICAgLy8gc2hvdWxkIGNsZWFyIHRoZSBjaGlsZCBwb2ludGVyIG9mIHRoZSBwYXJlbnQgYWx0ZXJuYXRlIHRvIGxldCB0aGlzXG4gICAgLy8gZ2V0IEdDOmVkIGJ1dCB3ZSBkb24ndCBrbm93IHdoaWNoIGZvciBzdXJlIHdoaWNoIHBhcmVudCBpcyB0aGUgY3VycmVudFxuICAgIC8vIG9uZSBzbyB3ZSdsbCBzZXR0bGUgZm9yIEdDOmluZyB0aGUgc3VidHJlZSBvZiB0aGlzIGNoaWxkLiBUaGlzIGNoaWxkXG4gICAgLy8gaXRzZWxmIHdpbGwgYmUgR0M6ZWQgd2hlbiB0aGUgcGFyZW50IHVwZGF0ZXMgdGhlIG5leHQgdGltZS5cbiAgICBjdXJyZW50WydyZXR1cm4nXSA9IG51bGw7XG4gICAgY3VycmVudC5jaGlsZCA9IG51bGw7XG4gICAgaWYgKGN1cnJlbnQuYWx0ZXJuYXRlKSB7XG4gICAgICBjdXJyZW50LmFsdGVybmF0ZS5jaGlsZCA9IG51bGw7XG4gICAgICBjdXJyZW50LmFsdGVybmF0ZVsncmV0dXJuJ10gPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIGlmICghbXV0YXRpb24pIHtcbiAgICB2YXIgY29tbWl0Q29udGFpbmVyID0gdm9pZCAwO1xuICAgIGlmIChwZXJzaXN0ZW5jZSkge1xuICAgICAgdmFyIHJlcGxhY2VDb250YWluZXJDaGlsZHJlbiA9IHBlcnNpc3RlbmNlLnJlcGxhY2VDb250YWluZXJDaGlsZHJlbixcbiAgICAgICAgICBjcmVhdGVDb250YWluZXJDaGlsZFNldCA9IHBlcnNpc3RlbmNlLmNyZWF0ZUNvbnRhaW5lckNoaWxkU2V0O1xuXG4gICAgICB2YXIgZW1wdHlQb3J0YWxDb250YWluZXIgPSBmdW5jdGlvbiAoY3VycmVudCkge1xuICAgICAgICB2YXIgcG9ydGFsID0gY3VycmVudC5zdGF0ZU5vZGU7XG4gICAgICAgIHZhciBjb250YWluZXJJbmZvID0gcG9ydGFsLmNvbnRhaW5lckluZm87XG5cbiAgICAgICAgdmFyIGVtcHR5Q2hpbGRTZXQgPSBjcmVhdGVDb250YWluZXJDaGlsZFNldChjb250YWluZXJJbmZvKTtcbiAgICAgICAgcmVwbGFjZUNvbnRhaW5lckNoaWxkcmVuKGNvbnRhaW5lckluZm8sIGVtcHR5Q2hpbGRTZXQpO1xuICAgICAgfTtcbiAgICAgIGNvbW1pdENvbnRhaW5lciA9IGZ1bmN0aW9uIChmaW5pc2hlZFdvcmspIHtcbiAgICAgICAgc3dpdGNoIChmaW5pc2hlZFdvcmsudGFnKSB7XG4gICAgICAgICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgSG9zdFRleHQ6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdmFyIHBvcnRhbE9yUm9vdCA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG4gICAgICAgICAgICAgIHZhciBjb250YWluZXJJbmZvID0gcG9ydGFsT3JSb290LmNvbnRhaW5lckluZm8sXG4gICAgICAgICAgICAgICAgICBfcGVuZGluZ0NoaWxkcmVuID0gcG9ydGFsT3JSb290LnBlbmRpbmdDaGlsZHJlbjtcblxuICAgICAgICAgICAgICByZXBsYWNlQ29udGFpbmVyQ2hpbGRyZW4oY29udGFpbmVySW5mbywgX3BlbmRpbmdDaGlsZHJlbik7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBpbnZhcmlhbnQoZmFsc2UsICdUaGlzIHVuaXQgb2Ygd29yayB0YWcgc2hvdWxkIG5vdCBoYXZlIHNpZGUtZWZmZWN0cy4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29tbWl0Q29udGFpbmVyID0gZnVuY3Rpb24gKGZpbmlzaGVkV29yaykge1xuICAgICAgICAvLyBOb29wXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAoZW5hYmxlUGVyc2lzdGVudFJlY29uY2lsZXIgfHwgZW5hYmxlTm9vcFJlY29uY2lsZXIpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNvbW1pdFJlc2V0VGV4dENvbnRlbnQ6IGZ1bmN0aW9uIChmaW5pc2hlZFdvcmspIHt9LFxuICAgICAgICBjb21taXRQbGFjZW1lbnQ6IGZ1bmN0aW9uIChmaW5pc2hlZFdvcmspIHt9LFxuICAgICAgICBjb21taXREZWxldGlvbjogZnVuY3Rpb24gKGN1cnJlbnQpIHtcbiAgICAgICAgICAvLyBEZXRhY2ggcmVmcyBhbmQgY2FsbCBjb21wb25lbnRXaWxsVW5tb3VudCgpIG9uIHRoZSB3aG9sZSBzdWJ0cmVlLlxuICAgICAgICAgIGNvbW1pdE5lc3RlZFVubW91bnRzKGN1cnJlbnQpO1xuICAgICAgICAgIGRldGFjaEZpYmVyKGN1cnJlbnQpO1xuICAgICAgICB9LFxuICAgICAgICBjb21taXRXb3JrOiBmdW5jdGlvbiAoY3VycmVudCwgZmluaXNoZWRXb3JrKSB7XG4gICAgICAgICAgY29tbWl0Q29udGFpbmVyKGZpbmlzaGVkV29yayk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY29tbWl0TGlmZUN5Y2xlczogY29tbWl0TGlmZUN5Y2xlcyxcbiAgICAgICAgY29tbWl0QXR0YWNoUmVmOiBjb21taXRBdHRhY2hSZWYsXG4gICAgICAgIGNvbW1pdERldGFjaFJlZjogY29tbWl0RGV0YWNoUmVmXG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAocGVyc2lzdGVuY2UpIHtcbiAgICAgIGludmFyaWFudChmYWxzZSwgJ1BlcnNpc3RlbnQgcmVjb25jaWxlciBpcyBkaXNhYmxlZC4nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW52YXJpYW50KGZhbHNlLCAnTm9vcCByZWNvbmNpbGVyIGlzIGRpc2FibGVkLicpO1xuICAgIH1cbiAgfVxuICB2YXIgY29tbWl0TW91bnQgPSBtdXRhdGlvbi5jb21taXRNb3VudCxcbiAgICAgIGNvbW1pdFVwZGF0ZSA9IG11dGF0aW9uLmNvbW1pdFVwZGF0ZSxcbiAgICAgIHJlc2V0VGV4dENvbnRlbnQgPSBtdXRhdGlvbi5yZXNldFRleHRDb250ZW50LFxuICAgICAgY29tbWl0VGV4dFVwZGF0ZSA9IG11dGF0aW9uLmNvbW1pdFRleHRVcGRhdGUsXG4gICAgICBhcHBlbmRDaGlsZCA9IG11dGF0aW9uLmFwcGVuZENoaWxkLFxuICAgICAgYXBwZW5kQ2hpbGRUb0NvbnRhaW5lciA9IG11dGF0aW9uLmFwcGVuZENoaWxkVG9Db250YWluZXIsXG4gICAgICBpbnNlcnRCZWZvcmUgPSBtdXRhdGlvbi5pbnNlcnRCZWZvcmUsXG4gICAgICBpbnNlcnRJbkNvbnRhaW5lckJlZm9yZSA9IG11dGF0aW9uLmluc2VydEluQ29udGFpbmVyQmVmb3JlLFxuICAgICAgcmVtb3ZlQ2hpbGQgPSBtdXRhdGlvbi5yZW1vdmVDaGlsZCxcbiAgICAgIHJlbW92ZUNoaWxkRnJvbUNvbnRhaW5lciA9IG11dGF0aW9uLnJlbW92ZUNoaWxkRnJvbUNvbnRhaW5lcjtcblxuXG4gIGZ1bmN0aW9uIGdldEhvc3RQYXJlbnRGaWJlcihmaWJlcikge1xuICAgIHZhciBwYXJlbnQgPSBmaWJlclsncmV0dXJuJ107XG4gICAgd2hpbGUgKHBhcmVudCAhPT0gbnVsbCkge1xuICAgICAgaWYgKGlzSG9zdFBhcmVudChwYXJlbnQpKSB7XG4gICAgICAgIHJldHVybiBwYXJlbnQ7XG4gICAgICB9XG4gICAgICBwYXJlbnQgPSBwYXJlbnRbJ3JldHVybiddO1xuICAgIH1cbiAgICBpbnZhcmlhbnQoZmFsc2UsICdFeHBlY3RlZCB0byBmaW5kIGEgaG9zdCBwYXJlbnQuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gIH1cblxuICBmdW5jdGlvbiBpc0hvc3RQYXJlbnQoZmliZXIpIHtcbiAgICByZXR1cm4gZmliZXIudGFnID09PSBIb3N0Q29tcG9uZW50IHx8IGZpYmVyLnRhZyA9PT0gSG9zdFJvb3QgfHwgZmliZXIudGFnID09PSBIb3N0UG9ydGFsO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0SG9zdFNpYmxpbmcoZmliZXIpIHtcbiAgICAvLyBXZSdyZSBnb2luZyB0byBzZWFyY2ggZm9yd2FyZCBpbnRvIHRoZSB0cmVlIHVudGlsIHdlIGZpbmQgYSBzaWJsaW5nIGhvc3RcbiAgICAvLyBub2RlLiBVbmZvcnR1bmF0ZWx5LCBpZiBtdWx0aXBsZSBpbnNlcnRpb25zIGFyZSBkb25lIGluIGEgcm93IHdlIGhhdmUgdG9cbiAgICAvLyBzZWFyY2ggcGFzdCB0aGVtLiBUaGlzIGxlYWRzIHRvIGV4cG9uZW50aWFsIHNlYXJjaCBmb3IgdGhlIG5leHQgc2libGluZy5cbiAgICB2YXIgbm9kZSA9IGZpYmVyO1xuICAgIHNpYmxpbmdzOiB3aGlsZSAodHJ1ZSkge1xuICAgICAgLy8gSWYgd2UgZGlkbid0IGZpbmQgYW55dGhpbmcsIGxldCdzIHRyeSB0aGUgbmV4dCBzaWJsaW5nLlxuICAgICAgd2hpbGUgKG5vZGUuc2libGluZyA9PT0gbnVsbCkge1xuICAgICAgICBpZiAobm9kZVsncmV0dXJuJ10gPT09IG51bGwgfHwgaXNIb3N0UGFyZW50KG5vZGVbJ3JldHVybiddKSkge1xuICAgICAgICAgIC8vIElmIHdlIHBvcCBvdXQgb2YgdGhlIHJvb3Qgb3IgaGl0IHRoZSBwYXJlbnQgdGhlIGZpYmVyIHdlIGFyZSB0aGVcbiAgICAgICAgICAvLyBsYXN0IHNpYmxpbmcuXG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZSA9IG5vZGVbJ3JldHVybiddO1xuICAgICAgfVxuICAgICAgbm9kZS5zaWJsaW5nWydyZXR1cm4nXSA9IG5vZGVbJ3JldHVybiddO1xuICAgICAgbm9kZSA9IG5vZGUuc2libGluZztcbiAgICAgIHdoaWxlIChub2RlLnRhZyAhPT0gSG9zdENvbXBvbmVudCAmJiBub2RlLnRhZyAhPT0gSG9zdFRleHQpIHtcbiAgICAgICAgLy8gSWYgaXQgaXMgbm90IGhvc3Qgbm9kZSBhbmQsIHdlIG1pZ2h0IGhhdmUgYSBob3N0IG5vZGUgaW5zaWRlIGl0LlxuICAgICAgICAvLyBUcnkgdG8gc2VhcmNoIGRvd24gdW50aWwgd2UgZmluZCBvbmUuXG4gICAgICAgIGlmIChub2RlLmVmZmVjdFRhZyAmIFBsYWNlbWVudCkge1xuICAgICAgICAgIC8vIElmIHdlIGRvbid0IGhhdmUgYSBjaGlsZCwgdHJ5IHRoZSBzaWJsaW5ncyBpbnN0ZWFkLlxuICAgICAgICAgIGNvbnRpbnVlIHNpYmxpbmdzO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHdlIGRvbid0IGhhdmUgYSBjaGlsZCwgdHJ5IHRoZSBzaWJsaW5ncyBpbnN0ZWFkLlxuICAgICAgICAvLyBXZSBhbHNvIHNraXAgcG9ydGFscyBiZWNhdXNlIHRoZXkgYXJlIG5vdCBwYXJ0IG9mIHRoaXMgaG9zdCB0cmVlLlxuICAgICAgICBpZiAobm9kZS5jaGlsZCA9PT0gbnVsbCB8fCBub2RlLnRhZyA9PT0gSG9zdFBvcnRhbCkge1xuICAgICAgICAgIGNvbnRpbnVlIHNpYmxpbmdzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5vZGUuY2hpbGRbJ3JldHVybiddID0gbm9kZTtcbiAgICAgICAgICBub2RlID0gbm9kZS5jaGlsZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gQ2hlY2sgaWYgdGhpcyBob3N0IG5vZGUgaXMgc3RhYmxlIG9yIGFib3V0IHRvIGJlIHBsYWNlZC5cbiAgICAgIGlmICghKG5vZGUuZWZmZWN0VGFnICYgUGxhY2VtZW50KSkge1xuICAgICAgICAvLyBGb3VuZCBpdCFcbiAgICAgICAgcmV0dXJuIG5vZGUuc3RhdGVOb2RlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbW1pdFBsYWNlbWVudChmaW5pc2hlZFdvcmspIHtcbiAgICAvLyBSZWN1cnNpdmVseSBpbnNlcnQgYWxsIGhvc3Qgbm9kZXMgaW50byB0aGUgcGFyZW50LlxuICAgIHZhciBwYXJlbnRGaWJlciA9IGdldEhvc3RQYXJlbnRGaWJlcihmaW5pc2hlZFdvcmspO1xuICAgIHZhciBwYXJlbnQgPSB2b2lkIDA7XG4gICAgdmFyIGlzQ29udGFpbmVyID0gdm9pZCAwO1xuICAgIHN3aXRjaCAocGFyZW50RmliZXIudGFnKSB7XG4gICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgIHBhcmVudCA9IHBhcmVudEZpYmVyLnN0YXRlTm9kZTtcbiAgICAgICAgaXNDb250YWluZXIgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgICBwYXJlbnQgPSBwYXJlbnRGaWJlci5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztcbiAgICAgICAgaXNDb250YWluZXIgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICAgICAgcGFyZW50ID0gcGFyZW50RmliZXIuc3RhdGVOb2RlLmNvbnRhaW5lckluZm87XG4gICAgICAgIGlzQ29udGFpbmVyID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpbnZhcmlhbnQoZmFsc2UsICdJbnZhbGlkIGhvc3QgcGFyZW50IGZpYmVyLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgICBpZiAocGFyZW50RmliZXIuZWZmZWN0VGFnICYgQ29udGVudFJlc2V0KSB7XG4gICAgICAvLyBSZXNldCB0aGUgdGV4dCBjb250ZW50IG9mIHRoZSBwYXJlbnQgYmVmb3JlIGRvaW5nIGFueSBpbnNlcnRpb25zXG4gICAgICByZXNldFRleHRDb250ZW50KHBhcmVudCk7XG4gICAgICAvLyBDbGVhciBDb250ZW50UmVzZXQgZnJvbSB0aGUgZWZmZWN0IHRhZ1xuICAgICAgcGFyZW50RmliZXIuZWZmZWN0VGFnICY9IH5Db250ZW50UmVzZXQ7XG4gICAgfVxuXG4gICAgdmFyIGJlZm9yZSA9IGdldEhvc3RTaWJsaW5nKGZpbmlzaGVkV29yayk7XG4gICAgLy8gV2Ugb25seSBoYXZlIHRoZSB0b3AgRmliZXIgdGhhdCB3YXMgaW5zZXJ0ZWQgYnV0IHdlIG5lZWQgcmVjdXJzZSBkb3duIGl0c1xuICAgIC8vIGNoaWxkcmVuIHRvIGZpbmQgYWxsIHRoZSB0ZXJtaW5hbCBub2Rlcy5cbiAgICB2YXIgbm9kZSA9IGZpbmlzaGVkV29yaztcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgaWYgKG5vZGUudGFnID09PSBIb3N0Q29tcG9uZW50IHx8IG5vZGUudGFnID09PSBIb3N0VGV4dCkge1xuICAgICAgICBpZiAoYmVmb3JlKSB7XG4gICAgICAgICAgaWYgKGlzQ29udGFpbmVyKSB7XG4gICAgICAgICAgICBpbnNlcnRJbkNvbnRhaW5lckJlZm9yZShwYXJlbnQsIG5vZGUuc3RhdGVOb2RlLCBiZWZvcmUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpbnNlcnRCZWZvcmUocGFyZW50LCBub2RlLnN0YXRlTm9kZSwgYmVmb3JlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGlzQ29udGFpbmVyKSB7XG4gICAgICAgICAgICBhcHBlbmRDaGlsZFRvQ29udGFpbmVyKHBhcmVudCwgbm9kZS5zdGF0ZU5vZGUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhcHBlbmRDaGlsZChwYXJlbnQsIG5vZGUuc3RhdGVOb2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAobm9kZS50YWcgPT09IEhvc3RQb3J0YWwpIHtcbiAgICAgICAgLy8gSWYgdGhlIGluc2VydGlvbiBpdHNlbGYgaXMgYSBwb3J0YWwsIHRoZW4gd2UgZG9uJ3Qgd2FudCB0byB0cmF2ZXJzZVxuICAgICAgICAvLyBkb3duIGl0cyBjaGlsZHJlbi4gSW5zdGVhZCwgd2UnbGwgZ2V0IGluc2VydGlvbnMgZnJvbSBlYWNoIGNoaWxkIGluXG4gICAgICAgIC8vIHRoZSBwb3J0YWwgZGlyZWN0bHkuXG4gICAgICB9IGVsc2UgaWYgKG5vZGUuY2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgbm9kZS5jaGlsZFsncmV0dXJuJ10gPSBub2RlO1xuICAgICAgICBub2RlID0gbm9kZS5jaGlsZDtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAobm9kZSA9PT0gZmluaXNoZWRXb3JrKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHdoaWxlIChub2RlLnNpYmxpbmcgPT09IG51bGwpIHtcbiAgICAgICAgaWYgKG5vZGVbJ3JldHVybiddID09PSBudWxsIHx8IG5vZGVbJ3JldHVybiddID09PSBmaW5pc2hlZFdvcmspIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbm9kZSA9IG5vZGVbJ3JldHVybiddO1xuICAgICAgfVxuICAgICAgbm9kZS5zaWJsaW5nWydyZXR1cm4nXSA9IG5vZGVbJ3JldHVybiddO1xuICAgICAgbm9kZSA9IG5vZGUuc2libGluZztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1bm1vdW50SG9zdENvbXBvbmVudHMoY3VycmVudCkge1xuICAgIC8vIFdlIG9ubHkgaGF2ZSB0aGUgdG9wIEZpYmVyIHRoYXQgd2FzIGluc2VydGVkIGJ1dCB3ZSBuZWVkIHJlY3Vyc2UgZG93biBpdHNcbiAgICB2YXIgbm9kZSA9IGN1cnJlbnQ7XG5cbiAgICAvLyBFYWNoIGl0ZXJhdGlvbiwgY3VycmVudFBhcmVudCBpcyBwb3B1bGF0ZWQgd2l0aCBub2RlJ3MgaG9zdCBwYXJlbnQgaWYgbm90XG4gICAgLy8gY3VycmVudFBhcmVudElzVmFsaWQuXG4gICAgdmFyIGN1cnJlbnRQYXJlbnRJc1ZhbGlkID0gZmFsc2U7XG4gICAgdmFyIGN1cnJlbnRQYXJlbnQgPSB2b2lkIDA7XG4gICAgdmFyIGN1cnJlbnRQYXJlbnRJc0NvbnRhaW5lciA9IHZvaWQgMDtcblxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBpZiAoIWN1cnJlbnRQYXJlbnRJc1ZhbGlkKSB7XG4gICAgICAgIHZhciBwYXJlbnQgPSBub2RlWydyZXR1cm4nXTtcbiAgICAgICAgZmluZFBhcmVudDogd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAhKHBhcmVudCAhPT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdFeHBlY3RlZCB0byBmaW5kIGEgaG9zdCBwYXJlbnQuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gICAgICAgICAgc3dpdGNoIChwYXJlbnQudGFnKSB7XG4gICAgICAgICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgICAgICAgIGN1cnJlbnRQYXJlbnQgPSBwYXJlbnQuc3RhdGVOb2RlO1xuICAgICAgICAgICAgICBjdXJyZW50UGFyZW50SXNDb250YWluZXIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgYnJlYWsgZmluZFBhcmVudDtcbiAgICAgICAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgICAgICAgIGN1cnJlbnRQYXJlbnQgPSBwYXJlbnQuc3RhdGVOb2RlLmNvbnRhaW5lckluZm87XG4gICAgICAgICAgICAgIGN1cnJlbnRQYXJlbnRJc0NvbnRhaW5lciA9IHRydWU7XG4gICAgICAgICAgICAgIGJyZWFrIGZpbmRQYXJlbnQ7XG4gICAgICAgICAgICBjYXNlIEhvc3RQb3J0YWw6XG4gICAgICAgICAgICAgIGN1cnJlbnRQYXJlbnQgPSBwYXJlbnQuc3RhdGVOb2RlLmNvbnRhaW5lckluZm87XG4gICAgICAgICAgICAgIGN1cnJlbnRQYXJlbnRJc0NvbnRhaW5lciA9IHRydWU7XG4gICAgICAgICAgICAgIGJyZWFrIGZpbmRQYXJlbnQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIHBhcmVudCA9IHBhcmVudFsncmV0dXJuJ107XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudFBhcmVudElzVmFsaWQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAobm9kZS50YWcgPT09IEhvc3RDb21wb25lbnQgfHwgbm9kZS50YWcgPT09IEhvc3RUZXh0KSB7XG4gICAgICAgIGNvbW1pdE5lc3RlZFVubW91bnRzKG5vZGUpO1xuICAgICAgICAvLyBBZnRlciBhbGwgdGhlIGNoaWxkcmVuIGhhdmUgdW5tb3VudGVkLCBpdCBpcyBub3cgc2FmZSB0byByZW1vdmUgdGhlXG4gICAgICAgIC8vIG5vZGUgZnJvbSB0aGUgdHJlZS5cbiAgICAgICAgaWYgKGN1cnJlbnRQYXJlbnRJc0NvbnRhaW5lcikge1xuICAgICAgICAgIHJlbW92ZUNoaWxkRnJvbUNvbnRhaW5lcihjdXJyZW50UGFyZW50LCBub2RlLnN0YXRlTm9kZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVtb3ZlQ2hpbGQoY3VycmVudFBhcmVudCwgbm9kZS5zdGF0ZU5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIERvbid0IHZpc2l0IGNoaWxkcmVuIGJlY2F1c2Ugd2UgYWxyZWFkeSB2aXNpdGVkIHRoZW0uXG4gICAgICB9IGVsc2UgaWYgKG5vZGUudGFnID09PSBIb3N0UG9ydGFsKSB7XG4gICAgICAgIC8vIFdoZW4gd2UgZ28gaW50byBhIHBvcnRhbCwgaXQgYmVjb21lcyB0aGUgcGFyZW50IHRvIHJlbW92ZSBmcm9tLlxuICAgICAgICAvLyBXZSB3aWxsIHJlYXNzaWduIGl0IGJhY2sgd2hlbiB3ZSBwb3AgdGhlIHBvcnRhbCBvbiB0aGUgd2F5IHVwLlxuICAgICAgICBjdXJyZW50UGFyZW50ID0gbm9kZS5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztcbiAgICAgICAgLy8gVmlzaXQgY2hpbGRyZW4gYmVjYXVzZSBwb3J0YWxzIG1pZ2h0IGNvbnRhaW4gaG9zdCBjb21wb25lbnRzLlxuICAgICAgICBpZiAobm9kZS5jaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICAgIG5vZGUuY2hpbGRbJ3JldHVybiddID0gbm9kZTtcbiAgICAgICAgICBub2RlID0gbm9kZS5jaGlsZDtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29tbWl0VW5tb3VudChub2RlKTtcbiAgICAgICAgLy8gVmlzaXQgY2hpbGRyZW4gYmVjYXVzZSB3ZSBtYXkgZmluZCBtb3JlIGhvc3QgY29tcG9uZW50cyBiZWxvdy5cbiAgICAgICAgaWYgKG5vZGUuY2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgICBub2RlLmNoaWxkWydyZXR1cm4nXSA9IG5vZGU7XG4gICAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGQ7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChub2RlID09PSBjdXJyZW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHdoaWxlIChub2RlLnNpYmxpbmcgPT09IG51bGwpIHtcbiAgICAgICAgaWYgKG5vZGVbJ3JldHVybiddID09PSBudWxsIHx8IG5vZGVbJ3JldHVybiddID09PSBjdXJyZW50KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUgPSBub2RlWydyZXR1cm4nXTtcbiAgICAgICAgaWYgKG5vZGUudGFnID09PSBIb3N0UG9ydGFsKSB7XG4gICAgICAgICAgLy8gV2hlbiB3ZSBnbyBvdXQgb2YgdGhlIHBvcnRhbCwgd2UgbmVlZCB0byByZXN0b3JlIHRoZSBwYXJlbnQuXG4gICAgICAgICAgLy8gU2luY2Ugd2UgZG9uJ3Qga2VlcCBhIHN0YWNrIG9mIHRoZW0sIHdlIHdpbGwgc2VhcmNoIGZvciBpdC5cbiAgICAgICAgICBjdXJyZW50UGFyZW50SXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBub2RlLnNpYmxpbmdbJ3JldHVybiddID0gbm9kZVsncmV0dXJuJ107XG4gICAgICBub2RlID0gbm9kZS5zaWJsaW5nO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbW1pdERlbGV0aW9uKGN1cnJlbnQpIHtcbiAgICAvLyBSZWN1cnNpdmVseSBkZWxldGUgYWxsIGhvc3Qgbm9kZXMgZnJvbSB0aGUgcGFyZW50LlxuICAgIC8vIERldGFjaCByZWZzIGFuZCBjYWxsIGNvbXBvbmVudFdpbGxVbm1vdW50KCkgb24gdGhlIHdob2xlIHN1YnRyZWUuXG4gICAgdW5tb3VudEhvc3RDb21wb25lbnRzKGN1cnJlbnQpO1xuICAgIGRldGFjaEZpYmVyKGN1cnJlbnQpO1xuICB9XG5cbiAgZnVuY3Rpb24gY29tbWl0V29yayhjdXJyZW50LCBmaW5pc2hlZFdvcmspIHtcbiAgICBzd2l0Y2ggKGZpbmlzaGVkV29yay50YWcpIHtcbiAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBpbnN0YW5jZSA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG4gICAgICAgICAgaWYgKGluc3RhbmNlICE9IG51bGwpIHtcbiAgICAgICAgICAgIC8vIENvbW1pdCB0aGUgd29yayBwcmVwYXJlZCBlYXJsaWVyLlxuICAgICAgICAgICAgdmFyIG5ld1Byb3BzID0gZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHM7XG4gICAgICAgICAgICAvLyBGb3IgaHlkcmF0aW9uIHdlIHJldXNlIHRoZSB1cGRhdGUgcGF0aCBidXQgd2UgdHJlYXQgdGhlIG9sZFByb3BzXG4gICAgICAgICAgICAvLyBhcyB0aGUgbmV3UHJvcHMuIFRoZSB1cGRhdGVQYXlsb2FkIHdpbGwgY29udGFpbiB0aGUgcmVhbCBjaGFuZ2UgaW5cbiAgICAgICAgICAgIC8vIHRoaXMgY2FzZS5cbiAgICAgICAgICAgIHZhciBvbGRQcm9wcyA9IGN1cnJlbnQgIT09IG51bGwgPyBjdXJyZW50Lm1lbW9pemVkUHJvcHMgOiBuZXdQcm9wcztcbiAgICAgICAgICAgIHZhciB0eXBlID0gZmluaXNoZWRXb3JrLnR5cGU7XG4gICAgICAgICAgICAvLyBUT0RPOiBUeXBlIHRoZSB1cGRhdGVRdWV1ZSB0byBiZSBzcGVjaWZpYyB0byBob3N0IGNvbXBvbmVudHMuXG4gICAgICAgICAgICB2YXIgdXBkYXRlUGF5bG9hZCA9IGZpbmlzaGVkV29yay51cGRhdGVRdWV1ZTtcbiAgICAgICAgICAgIGZpbmlzaGVkV29yay51cGRhdGVRdWV1ZSA9IG51bGw7XG4gICAgICAgICAgICBpZiAodXBkYXRlUGF5bG9hZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICBjb21taXRVcGRhdGUoaW5zdGFuY2UsIHVwZGF0ZVBheWxvYWQsIHR5cGUsIG9sZFByb3BzLCBuZXdQcm9wcywgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICBjYXNlIEhvc3RUZXh0OlxuICAgICAgICB7XG4gICAgICAgICAgIShmaW5pc2hlZFdvcmsuc3RhdGVOb2RlICE9PSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJ1RoaXMgc2hvdWxkIGhhdmUgYSB0ZXh0IG5vZGUgaW5pdGlhbGl6ZWQuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gICAgICAgICAgdmFyIHRleHRJbnN0YW5jZSA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG4gICAgICAgICAgdmFyIG5ld1RleHQgPSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcztcbiAgICAgICAgICAvLyBGb3IgaHlkcmF0aW9uIHdlIHJldXNlIHRoZSB1cGRhdGUgcGF0aCBidXQgd2UgdHJlYXQgdGhlIG9sZFByb3BzXG4gICAgICAgICAgLy8gYXMgdGhlIG5ld1Byb3BzLiBUaGUgdXBkYXRlUGF5bG9hZCB3aWxsIGNvbnRhaW4gdGhlIHJlYWwgY2hhbmdlIGluXG4gICAgICAgICAgLy8gdGhpcyBjYXNlLlxuICAgICAgICAgIHZhciBvbGRUZXh0ID0gY3VycmVudCAhPT0gbnVsbCA/IGN1cnJlbnQubWVtb2l6ZWRQcm9wcyA6IG5ld1RleHQ7XG4gICAgICAgICAgY29tbWl0VGV4dFVwZGF0ZSh0ZXh0SW5zdGFuY2UsIG9sZFRleHQsIG5ld1RleHQpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAge1xuICAgICAgICAgIGludmFyaWFudChmYWxzZSwgJ1RoaXMgdW5pdCBvZiB3b3JrIHRhZyBzaG91bGQgbm90IGhhdmUgc2lkZS1lZmZlY3RzLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY29tbWl0UmVzZXRUZXh0Q29udGVudChjdXJyZW50KSB7XG4gICAgcmVzZXRUZXh0Q29udGVudChjdXJyZW50LnN0YXRlTm9kZSk7XG4gIH1cblxuICBpZiAoZW5hYmxlTXV0YXRpbmdSZWNvbmNpbGVyKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbW1pdFJlc2V0VGV4dENvbnRlbnQ6IGNvbW1pdFJlc2V0VGV4dENvbnRlbnQsXG4gICAgICBjb21taXRQbGFjZW1lbnQ6IGNvbW1pdFBsYWNlbWVudCxcbiAgICAgIGNvbW1pdERlbGV0aW9uOiBjb21taXREZWxldGlvbixcbiAgICAgIGNvbW1pdFdvcms6IGNvbW1pdFdvcmssXG4gICAgICBjb21taXRMaWZlQ3ljbGVzOiBjb21taXRMaWZlQ3ljbGVzLFxuICAgICAgY29tbWl0QXR0YWNoUmVmOiBjb21taXRBdHRhY2hSZWYsXG4gICAgICBjb21taXREZXRhY2hSZWY6IGNvbW1pdERldGFjaFJlZlxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgaW52YXJpYW50KGZhbHNlLCAnTXV0YXRpbmcgcmVjb25jaWxlciBpcyBkaXNhYmxlZC4nKTtcbiAgfVxufTtcblxudmFyIE5PX0NPTlRFWFQgPSB7fTtcblxudmFyIFJlYWN0RmliZXJIb3N0Q29udGV4dCA9IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgdmFyIGdldENoaWxkSG9zdENvbnRleHQgPSBjb25maWcuZ2V0Q2hpbGRIb3N0Q29udGV4dCxcbiAgICAgIGdldFJvb3RIb3N0Q29udGV4dCA9IGNvbmZpZy5nZXRSb290SG9zdENvbnRleHQ7XG5cblxuICB2YXIgY29udGV4dFN0YWNrQ3Vyc29yID0gY3JlYXRlQ3Vyc29yKE5PX0NPTlRFWFQpO1xuICB2YXIgY29udGV4dEZpYmVyU3RhY2tDdXJzb3IgPSBjcmVhdGVDdXJzb3IoTk9fQ09OVEVYVCk7XG4gIHZhciByb290SW5zdGFuY2VTdGFja0N1cnNvciA9IGNyZWF0ZUN1cnNvcihOT19DT05URVhUKTtcblxuICBmdW5jdGlvbiByZXF1aXJlZENvbnRleHQoYykge1xuICAgICEoYyAhPT0gTk9fQ09OVEVYVCkgPyBpbnZhcmlhbnQoZmFsc2UsICdFeHBlY3RlZCBob3N0IGNvbnRleHQgdG8gZXhpc3QuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gICAgcmV0dXJuIGM7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRSb290SG9zdENvbnRhaW5lcigpIHtcbiAgICB2YXIgcm9vdEluc3RhbmNlID0gcmVxdWlyZWRDb250ZXh0KHJvb3RJbnN0YW5jZVN0YWNrQ3Vyc29yLmN1cnJlbnQpO1xuICAgIHJldHVybiByb290SW5zdGFuY2U7XG4gIH1cblxuICBmdW5jdGlvbiBwdXNoSG9zdENvbnRhaW5lcihmaWJlciwgbmV4dFJvb3RJbnN0YW5jZSkge1xuICAgIC8vIFB1c2ggY3VycmVudCByb290IGluc3RhbmNlIG9udG8gdGhlIHN0YWNrO1xuICAgIC8vIFRoaXMgYWxsb3dzIHVzIHRvIHJlc2V0IHJvb3Qgd2hlbiBwb3J0YWxzIGFyZSBwb3BwZWQuXG4gICAgcHVzaChyb290SW5zdGFuY2VTdGFja0N1cnNvciwgbmV4dFJvb3RJbnN0YW5jZSwgZmliZXIpO1xuXG4gICAgdmFyIG5leHRSb290Q29udGV4dCA9IGdldFJvb3RIb3N0Q29udGV4dChuZXh0Um9vdEluc3RhbmNlKTtcblxuICAgIC8vIFRyYWNrIHRoZSBjb250ZXh0IGFuZCB0aGUgRmliZXIgdGhhdCBwcm92aWRlZCBpdC5cbiAgICAvLyBUaGlzIGVuYWJsZXMgdXMgdG8gcG9wIG9ubHkgRmliZXJzIHRoYXQgcHJvdmlkZSB1bmlxdWUgY29udGV4dHMuXG4gICAgcHVzaChjb250ZXh0RmliZXJTdGFja0N1cnNvciwgZmliZXIsIGZpYmVyKTtcbiAgICBwdXNoKGNvbnRleHRTdGFja0N1cnNvciwgbmV4dFJvb3RDb250ZXh0LCBmaWJlcik7XG4gIH1cblxuICBmdW5jdGlvbiBwb3BIb3N0Q29udGFpbmVyKGZpYmVyKSB7XG4gICAgcG9wKGNvbnRleHRTdGFja0N1cnNvciwgZmliZXIpO1xuICAgIHBvcChjb250ZXh0RmliZXJTdGFja0N1cnNvciwgZmliZXIpO1xuICAgIHBvcChyb290SW5zdGFuY2VTdGFja0N1cnNvciwgZmliZXIpO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0SG9zdENvbnRleHQoKSB7XG4gICAgdmFyIGNvbnRleHQgPSByZXF1aXJlZENvbnRleHQoY29udGV4dFN0YWNrQ3Vyc29yLmN1cnJlbnQpO1xuICAgIHJldHVybiBjb250ZXh0O1xuICB9XG5cbiAgZnVuY3Rpb24gcHVzaEhvc3RDb250ZXh0KGZpYmVyKSB7XG4gICAgdmFyIHJvb3RJbnN0YW5jZSA9IHJlcXVpcmVkQ29udGV4dChyb290SW5zdGFuY2VTdGFja0N1cnNvci5jdXJyZW50KTtcbiAgICB2YXIgY29udGV4dCA9IHJlcXVpcmVkQ29udGV4dChjb250ZXh0U3RhY2tDdXJzb3IuY3VycmVudCk7XG4gICAgdmFyIG5leHRDb250ZXh0ID0gZ2V0Q2hpbGRIb3N0Q29udGV4dChjb250ZXh0LCBmaWJlci50eXBlLCByb290SW5zdGFuY2UpO1xuXG4gICAgLy8gRG9uJ3QgcHVzaCB0aGlzIEZpYmVyJ3MgY29udGV4dCB1bmxlc3MgaXQncyB1bmlxdWUuXG4gICAgaWYgKGNvbnRleHQgPT09IG5leHRDb250ZXh0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gVHJhY2sgdGhlIGNvbnRleHQgYW5kIHRoZSBGaWJlciB0aGF0IHByb3ZpZGVkIGl0LlxuICAgIC8vIFRoaXMgZW5hYmxlcyB1cyB0byBwb3Agb25seSBGaWJlcnMgdGhhdCBwcm92aWRlIHVuaXF1ZSBjb250ZXh0cy5cbiAgICBwdXNoKGNvbnRleHRGaWJlclN0YWNrQ3Vyc29yLCBmaWJlciwgZmliZXIpO1xuICAgIHB1c2goY29udGV4dFN0YWNrQ3Vyc29yLCBuZXh0Q29udGV4dCwgZmliZXIpO1xuICB9XG5cbiAgZnVuY3Rpb24gcG9wSG9zdENvbnRleHQoZmliZXIpIHtcbiAgICAvLyBEbyBub3QgcG9wIHVubGVzcyB0aGlzIEZpYmVyIHByb3ZpZGVkIHRoZSBjdXJyZW50IGNvbnRleHQuXG4gICAgLy8gcHVzaEhvc3RDb250ZXh0KCkgb25seSBwdXNoZXMgRmliZXJzIHRoYXQgcHJvdmlkZSB1bmlxdWUgY29udGV4dHMuXG4gICAgaWYgKGNvbnRleHRGaWJlclN0YWNrQ3Vyc29yLmN1cnJlbnQgIT09IGZpYmVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgcG9wKGNvbnRleHRTdGFja0N1cnNvciwgZmliZXIpO1xuICAgIHBvcChjb250ZXh0RmliZXJTdGFja0N1cnNvciwgZmliZXIpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVzZXRIb3N0Q29udGFpbmVyKCkge1xuICAgIGNvbnRleHRTdGFja0N1cnNvci5jdXJyZW50ID0gTk9fQ09OVEVYVDtcbiAgICByb290SW5zdGFuY2VTdGFja0N1cnNvci5jdXJyZW50ID0gTk9fQ09OVEVYVDtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgZ2V0SG9zdENvbnRleHQ6IGdldEhvc3RDb250ZXh0LFxuICAgIGdldFJvb3RIb3N0Q29udGFpbmVyOiBnZXRSb290SG9zdENvbnRhaW5lcixcbiAgICBwb3BIb3N0Q29udGFpbmVyOiBwb3BIb3N0Q29udGFpbmVyLFxuICAgIHBvcEhvc3RDb250ZXh0OiBwb3BIb3N0Q29udGV4dCxcbiAgICBwdXNoSG9zdENvbnRhaW5lcjogcHVzaEhvc3RDb250YWluZXIsXG4gICAgcHVzaEhvc3RDb250ZXh0OiBwdXNoSG9zdENvbnRleHQsXG4gICAgcmVzZXRIb3N0Q29udGFpbmVyOiByZXNldEhvc3RDb250YWluZXJcbiAgfTtcbn07XG5cbnZhciBSZWFjdEZpYmVySHlkcmF0aW9uQ29udGV4dCA9IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgdmFyIHNob3VsZFNldFRleHRDb250ZW50ID0gY29uZmlnLnNob3VsZFNldFRleHRDb250ZW50LFxuICAgICAgaHlkcmF0aW9uID0gY29uZmlnLmh5ZHJhdGlvbjtcblxuICAvLyBJZiB0aGlzIGRvZXNuJ3QgaGF2ZSBoeWRyYXRpb24gbW9kZS5cblxuICBpZiAoIWh5ZHJhdGlvbikge1xuICAgIHJldHVybiB7XG4gICAgICBlbnRlckh5ZHJhdGlvblN0YXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0sXG4gICAgICByZXNldEh5ZHJhdGlvblN0YXRlOiBmdW5jdGlvbiAoKSB7fSxcbiAgICAgIHRyeVRvQ2xhaW1OZXh0SHlkcmF0YWJsZUluc3RhbmNlOiBmdW5jdGlvbiAoKSB7fSxcbiAgICAgIHByZXBhcmVUb0h5ZHJhdGVIb3N0SW5zdGFuY2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaW52YXJpYW50KGZhbHNlLCAnRXhwZWN0ZWQgcHJlcGFyZVRvSHlkcmF0ZUhvc3RJbnN0YW5jZSgpIHRvIG5ldmVyIGJlIGNhbGxlZC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICAgIH0sXG4gICAgICBwcmVwYXJlVG9IeWRyYXRlSG9zdFRleHRJbnN0YW5jZTogZnVuY3Rpb24gKCkge1xuICAgICAgICBpbnZhcmlhbnQoZmFsc2UsICdFeHBlY3RlZCBwcmVwYXJlVG9IeWRyYXRlSG9zdFRleHRJbnN0YW5jZSgpIHRvIG5ldmVyIGJlIGNhbGxlZC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICAgIH0sXG4gICAgICBwb3BIeWRyYXRpb25TdGF0ZTogZnVuY3Rpb24gKGZpYmVyKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgdmFyIGNhbkh5ZHJhdGVJbnN0YW5jZSA9IGh5ZHJhdGlvbi5jYW5IeWRyYXRlSW5zdGFuY2UsXG4gICAgICBjYW5IeWRyYXRlVGV4dEluc3RhbmNlID0gaHlkcmF0aW9uLmNhbkh5ZHJhdGVUZXh0SW5zdGFuY2UsXG4gICAgICBnZXROZXh0SHlkcmF0YWJsZVNpYmxpbmcgPSBoeWRyYXRpb24uZ2V0TmV4dEh5ZHJhdGFibGVTaWJsaW5nLFxuICAgICAgZ2V0Rmlyc3RIeWRyYXRhYmxlQ2hpbGQgPSBoeWRyYXRpb24uZ2V0Rmlyc3RIeWRyYXRhYmxlQ2hpbGQsXG4gICAgICBoeWRyYXRlSW5zdGFuY2UgPSBoeWRyYXRpb24uaHlkcmF0ZUluc3RhbmNlLFxuICAgICAgaHlkcmF0ZVRleHRJbnN0YW5jZSA9IGh5ZHJhdGlvbi5oeWRyYXRlVGV4dEluc3RhbmNlLFxuICAgICAgZGlkTm90TWF0Y2hIeWRyYXRlZENvbnRhaW5lclRleHRJbnN0YW5jZSA9IGh5ZHJhdGlvbi5kaWROb3RNYXRjaEh5ZHJhdGVkQ29udGFpbmVyVGV4dEluc3RhbmNlLFxuICAgICAgZGlkTm90TWF0Y2hIeWRyYXRlZFRleHRJbnN0YW5jZSA9IGh5ZHJhdGlvbi5kaWROb3RNYXRjaEh5ZHJhdGVkVGV4dEluc3RhbmNlLFxuICAgICAgZGlkTm90SHlkcmF0ZUNvbnRhaW5lckluc3RhbmNlID0gaHlkcmF0aW9uLmRpZE5vdEh5ZHJhdGVDb250YWluZXJJbnN0YW5jZSxcbiAgICAgIGRpZE5vdEh5ZHJhdGVJbnN0YW5jZSA9IGh5ZHJhdGlvbi5kaWROb3RIeWRyYXRlSW5zdGFuY2UsXG4gICAgICBkaWROb3RGaW5kSHlkcmF0YWJsZUNvbnRhaW5lckluc3RhbmNlID0gaHlkcmF0aW9uLmRpZE5vdEZpbmRIeWRyYXRhYmxlQ29udGFpbmVySW5zdGFuY2UsXG4gICAgICBkaWROb3RGaW5kSHlkcmF0YWJsZUNvbnRhaW5lclRleHRJbnN0YW5jZSA9IGh5ZHJhdGlvbi5kaWROb3RGaW5kSHlkcmF0YWJsZUNvbnRhaW5lclRleHRJbnN0YW5jZSxcbiAgICAgIGRpZE5vdEZpbmRIeWRyYXRhYmxlSW5zdGFuY2UgPSBoeWRyYXRpb24uZGlkTm90RmluZEh5ZHJhdGFibGVJbnN0YW5jZSxcbiAgICAgIGRpZE5vdEZpbmRIeWRyYXRhYmxlVGV4dEluc3RhbmNlID0gaHlkcmF0aW9uLmRpZE5vdEZpbmRIeWRyYXRhYmxlVGV4dEluc3RhbmNlO1xuXG4gIC8vIFRoZSBkZWVwZXN0IEZpYmVyIG9uIHRoZSBzdGFjayBpbnZvbHZlZCBpbiBhIGh5ZHJhdGlvbiBjb250ZXh0LlxuICAvLyBUaGlzIG1heSBoYXZlIGJlZW4gYW4gaW5zZXJ0aW9uIG9yIGEgaHlkcmF0aW9uLlxuXG4gIHZhciBoeWRyYXRpb25QYXJlbnRGaWJlciA9IG51bGw7XG4gIHZhciBuZXh0SHlkcmF0YWJsZUluc3RhbmNlID0gbnVsbDtcbiAgdmFyIGlzSHlkcmF0aW5nID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gZW50ZXJIeWRyYXRpb25TdGF0ZShmaWJlcikge1xuICAgIHZhciBwYXJlbnRJbnN0YW5jZSA9IGZpYmVyLnN0YXRlTm9kZS5jb250YWluZXJJbmZvO1xuICAgIG5leHRIeWRyYXRhYmxlSW5zdGFuY2UgPSBnZXRGaXJzdEh5ZHJhdGFibGVDaGlsZChwYXJlbnRJbnN0YW5jZSk7XG4gICAgaHlkcmF0aW9uUGFyZW50RmliZXIgPSBmaWJlcjtcbiAgICBpc0h5ZHJhdGluZyA9IHRydWU7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBmdW5jdGlvbiBkZWxldGVIeWRyYXRhYmxlSW5zdGFuY2UocmV0dXJuRmliZXIsIGluc3RhbmNlKSB7XG4gICAge1xuICAgICAgc3dpdGNoIChyZXR1cm5GaWJlci50YWcpIHtcbiAgICAgICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgICAgICBkaWROb3RIeWRyYXRlQ29udGFpbmVySW5zdGFuY2UocmV0dXJuRmliZXIuc3RhdGVOb2RlLmNvbnRhaW5lckluZm8sIGluc3RhbmNlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICAgIGRpZE5vdEh5ZHJhdGVJbnN0YW5jZShyZXR1cm5GaWJlci50eXBlLCByZXR1cm5GaWJlci5tZW1vaXplZFByb3BzLCByZXR1cm5GaWJlci5zdGF0ZU5vZGUsIGluc3RhbmNlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgY2hpbGRUb0RlbGV0ZSA9IGNyZWF0ZUZpYmVyRnJvbUhvc3RJbnN0YW5jZUZvckRlbGV0aW9uKCk7XG4gICAgY2hpbGRUb0RlbGV0ZS5zdGF0ZU5vZGUgPSBpbnN0YW5jZTtcbiAgICBjaGlsZFRvRGVsZXRlWydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgIGNoaWxkVG9EZWxldGUuZWZmZWN0VGFnID0gRGVsZXRpb247XG5cbiAgICAvLyBUaGlzIG1pZ2h0IHNlZW0gbGlrZSBpdCBiZWxvbmdzIG9uIHByb2dyZXNzZWRGaXJzdERlbGV0aW9uLiBIb3dldmVyLFxuICAgIC8vIHRoZXNlIGNoaWxkcmVuIGFyZSBub3QgcGFydCBvZiB0aGUgcmVjb25jaWxpYXRpb24gbGlzdCBvZiBjaGlsZHJlbi5cbiAgICAvLyBFdmVuIGlmIHdlIGFib3J0IGFuZCByZXJlY29uY2lsZSB0aGUgY2hpbGRyZW4sIHRoYXQgd2lsbCB0cnkgdG8gaHlkcmF0ZVxuICAgIC8vIGFnYWluIGFuZCB0aGUgbm9kZXMgYXJlIHN0aWxsIGluIHRoZSBob3N0IHRyZWUgc28gdGhlc2Ugd2lsbCBiZVxuICAgIC8vIHJlY3JlYXRlZC5cbiAgICBpZiAocmV0dXJuRmliZXIubGFzdEVmZmVjdCAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuRmliZXIubGFzdEVmZmVjdC5uZXh0RWZmZWN0ID0gY2hpbGRUb0RlbGV0ZTtcbiAgICAgIHJldHVybkZpYmVyLmxhc3RFZmZlY3QgPSBjaGlsZFRvRGVsZXRlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm5GaWJlci5maXJzdEVmZmVjdCA9IHJldHVybkZpYmVyLmxhc3RFZmZlY3QgPSBjaGlsZFRvRGVsZXRlO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGluc2VydE5vbkh5ZHJhdGVkSW5zdGFuY2UocmV0dXJuRmliZXIsIGZpYmVyKSB7XG4gICAgZmliZXIuZWZmZWN0VGFnIHw9IFBsYWNlbWVudDtcbiAgICB7XG4gICAgICBzd2l0Y2ggKHJldHVybkZpYmVyLnRhZykge1xuICAgICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBwYXJlbnRDb250YWluZXIgPSByZXR1cm5GaWJlci5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztcbiAgICAgICAgICAgIHN3aXRjaCAoZmliZXIudGFnKSB7XG4gICAgICAgICAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAgICAgICAgICB2YXIgdHlwZSA9IGZpYmVyLnR5cGU7XG4gICAgICAgICAgICAgICAgdmFyIHByb3BzID0gZmliZXIucGVuZGluZ1Byb3BzO1xuICAgICAgICAgICAgICAgIGRpZE5vdEZpbmRIeWRyYXRhYmxlQ29udGFpbmVySW5zdGFuY2UocGFyZW50Q29udGFpbmVyLCB0eXBlLCBwcm9wcyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgSG9zdFRleHQ6XG4gICAgICAgICAgICAgICAgdmFyIHRleHQgPSBmaWJlci5wZW5kaW5nUHJvcHM7XG4gICAgICAgICAgICAgICAgZGlkTm90RmluZEh5ZHJhdGFibGVDb250YWluZXJUZXh0SW5zdGFuY2UocGFyZW50Q29udGFpbmVyLCB0ZXh0KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBwYXJlbnRUeXBlID0gcmV0dXJuRmliZXIudHlwZTtcbiAgICAgICAgICAgIHZhciBwYXJlbnRQcm9wcyA9IHJldHVybkZpYmVyLm1lbW9pemVkUHJvcHM7XG4gICAgICAgICAgICB2YXIgcGFyZW50SW5zdGFuY2UgPSByZXR1cm5GaWJlci5zdGF0ZU5vZGU7XG4gICAgICAgICAgICBzd2l0Y2ggKGZpYmVyLnRhZykge1xuICAgICAgICAgICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgICAgICAgICAgdmFyIF90eXBlID0gZmliZXIudHlwZTtcbiAgICAgICAgICAgICAgICB2YXIgX3Byb3BzID0gZmliZXIucGVuZGluZ1Byb3BzO1xuICAgICAgICAgICAgICAgIGRpZE5vdEZpbmRIeWRyYXRhYmxlSW5zdGFuY2UocGFyZW50VHlwZSwgcGFyZW50UHJvcHMsIHBhcmVudEluc3RhbmNlLCBfdHlwZSwgX3Byb3BzKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBIb3N0VGV4dDpcbiAgICAgICAgICAgICAgICB2YXIgX3RleHQgPSBmaWJlci5wZW5kaW5nUHJvcHM7XG4gICAgICAgICAgICAgICAgZGlkTm90RmluZEh5ZHJhdGFibGVUZXh0SW5zdGFuY2UocGFyZW50VHlwZSwgcGFyZW50UHJvcHMsIHBhcmVudEluc3RhbmNlLCBfdGV4dCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHRyeUh5ZHJhdGUoZmliZXIsIG5leHRJbnN0YW5jZSkge1xuICAgIHN3aXRjaCAoZmliZXIudGFnKSB7XG4gICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgdHlwZSA9IGZpYmVyLnR5cGU7XG4gICAgICAgICAgdmFyIHByb3BzID0gZmliZXIucGVuZGluZ1Byb3BzO1xuICAgICAgICAgIHZhciBpbnN0YW5jZSA9IGNhbkh5ZHJhdGVJbnN0YW5jZShuZXh0SW5zdGFuY2UsIHR5cGUsIHByb3BzKTtcbiAgICAgICAgICBpZiAoaW5zdGFuY2UgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGZpYmVyLnN0YXRlTm9kZSA9IGluc3RhbmNlO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgY2FzZSBIb3N0VGV4dDpcbiAgICAgICAge1xuICAgICAgICAgIHZhciB0ZXh0ID0gZmliZXIucGVuZGluZ1Byb3BzO1xuICAgICAgICAgIHZhciB0ZXh0SW5zdGFuY2UgPSBjYW5IeWRyYXRlVGV4dEluc3RhbmNlKG5leHRJbnN0YW5jZSwgdGV4dCk7XG4gICAgICAgICAgaWYgKHRleHRJbnN0YW5jZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgZmliZXIuc3RhdGVOb2RlID0gdGV4dEluc3RhbmNlO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHRyeVRvQ2xhaW1OZXh0SHlkcmF0YWJsZUluc3RhbmNlKGZpYmVyKSB7XG4gICAgaWYgKCFpc0h5ZHJhdGluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgbmV4dEluc3RhbmNlID0gbmV4dEh5ZHJhdGFibGVJbnN0YW5jZTtcbiAgICBpZiAoIW5leHRJbnN0YW5jZSkge1xuICAgICAgLy8gTm90aGluZyB0byBoeWRyYXRlLiBNYWtlIGl0IGFuIGluc2VydGlvbi5cbiAgICAgIGluc2VydE5vbkh5ZHJhdGVkSW5zdGFuY2UoaHlkcmF0aW9uUGFyZW50RmliZXIsIGZpYmVyKTtcbiAgICAgIGlzSHlkcmF0aW5nID0gZmFsc2U7XG4gICAgICBoeWRyYXRpb25QYXJlbnRGaWJlciA9IGZpYmVyO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXRyeUh5ZHJhdGUoZmliZXIsIG5leHRJbnN0YW5jZSkpIHtcbiAgICAgIC8vIElmIHdlIGNhbid0IGh5ZHJhdGUgdGhpcyBpbnN0YW5jZSBsZXQncyB0cnkgdGhlIG5leHQgb25lLlxuICAgICAgLy8gV2UgdXNlIHRoaXMgYXMgYSBoZXVyaXN0aWMuIEl0J3MgYmFzZWQgb24gaW50dWl0aW9uIGFuZCBub3QgZGF0YSBzbyBpdFxuICAgICAgLy8gbWlnaHQgYmUgZmxhd2VkIG9yIHVubmVjZXNzYXJ5LlxuICAgICAgbmV4dEluc3RhbmNlID0gZ2V0TmV4dEh5ZHJhdGFibGVTaWJsaW5nKG5leHRJbnN0YW5jZSk7XG4gICAgICBpZiAoIW5leHRJbnN0YW5jZSB8fCAhdHJ5SHlkcmF0ZShmaWJlciwgbmV4dEluc3RhbmNlKSkge1xuICAgICAgICAvLyBOb3RoaW5nIHRvIGh5ZHJhdGUuIE1ha2UgaXQgYW4gaW5zZXJ0aW9uLlxuICAgICAgICBpbnNlcnROb25IeWRyYXRlZEluc3RhbmNlKGh5ZHJhdGlvblBhcmVudEZpYmVyLCBmaWJlcik7XG4gICAgICAgIGlzSHlkcmF0aW5nID0gZmFsc2U7XG4gICAgICAgIGh5ZHJhdGlvblBhcmVudEZpYmVyID0gZmliZXI7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIC8vIFdlIG1hdGNoZWQgdGhlIG5leHQgb25lLCB3ZSdsbCBub3cgYXNzdW1lIHRoYXQgdGhlIGZpcnN0IG9uZSB3YXNcbiAgICAgIC8vIHN1cGVyZmx1b3VzIGFuZCB3ZSdsbCBkZWxldGUgaXQuIFNpbmNlIHdlIGNhbid0IGVhZ2VybHkgZGVsZXRlIGl0XG4gICAgICAvLyB3ZSdsbCBoYXZlIHRvIHNjaGVkdWxlIGEgZGVsZXRpb24uIFRvIGRvIHRoYXQsIHRoaXMgbm9kZSBuZWVkcyBhIGR1bW15XG4gICAgICAvLyBmaWJlciBhc3NvY2lhdGVkIHdpdGggaXQuXG4gICAgICBkZWxldGVIeWRyYXRhYmxlSW5zdGFuY2UoaHlkcmF0aW9uUGFyZW50RmliZXIsIG5leHRIeWRyYXRhYmxlSW5zdGFuY2UpO1xuICAgIH1cbiAgICBoeWRyYXRpb25QYXJlbnRGaWJlciA9IGZpYmVyO1xuICAgIG5leHRIeWRyYXRhYmxlSW5zdGFuY2UgPSBnZXRGaXJzdEh5ZHJhdGFibGVDaGlsZChuZXh0SW5zdGFuY2UpO1xuICB9XG5cbiAgZnVuY3Rpb24gcHJlcGFyZVRvSHlkcmF0ZUhvc3RJbnN0YW5jZShmaWJlciwgcm9vdENvbnRhaW5lckluc3RhbmNlLCBob3N0Q29udGV4dCkge1xuICAgIHZhciBpbnN0YW5jZSA9IGZpYmVyLnN0YXRlTm9kZTtcbiAgICB2YXIgdXBkYXRlUGF5bG9hZCA9IGh5ZHJhdGVJbnN0YW5jZShpbnN0YW5jZSwgZmliZXIudHlwZSwgZmliZXIubWVtb2l6ZWRQcm9wcywgcm9vdENvbnRhaW5lckluc3RhbmNlLCBob3N0Q29udGV4dCwgZmliZXIpO1xuICAgIC8vIFRPRE86IFR5cGUgdGhpcyBzcGVjaWZpYyB0byB0aGlzIHR5cGUgb2YgY29tcG9uZW50LlxuICAgIGZpYmVyLnVwZGF0ZVF1ZXVlID0gdXBkYXRlUGF5bG9hZDtcbiAgICAvLyBJZiB0aGUgdXBkYXRlIHBheWxvYWQgaW5kaWNhdGVzIHRoYXQgdGhlcmUgaXMgYSBjaGFuZ2Ugb3IgaWYgdGhlcmVcbiAgICAvLyBpcyBhIG5ldyByZWYgd2UgbWFyayB0aGlzIGFzIGFuIHVwZGF0ZS5cbiAgICBpZiAodXBkYXRlUGF5bG9hZCAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHByZXBhcmVUb0h5ZHJhdGVIb3N0VGV4dEluc3RhbmNlKGZpYmVyKSB7XG4gICAgdmFyIHRleHRJbnN0YW5jZSA9IGZpYmVyLnN0YXRlTm9kZTtcbiAgICB2YXIgdGV4dENvbnRlbnQgPSBmaWJlci5tZW1vaXplZFByb3BzO1xuICAgIHZhciBzaG91bGRVcGRhdGUgPSBoeWRyYXRlVGV4dEluc3RhbmNlKHRleHRJbnN0YW5jZSwgdGV4dENvbnRlbnQsIGZpYmVyKTtcbiAgICB7XG4gICAgICBpZiAoc2hvdWxkVXBkYXRlKSB7XG4gICAgICAgIC8vIFdlIGFzc3VtZSB0aGF0IHByZXBhcmVUb0h5ZHJhdGVIb3N0VGV4dEluc3RhbmNlIGlzIGNhbGxlZCBpbiBhIGNvbnRleHQgd2hlcmUgdGhlXG4gICAgICAgIC8vIGh5ZHJhdGlvbiBwYXJlbnQgaXMgdGhlIHBhcmVudCBob3N0IGNvbXBvbmVudCBvZiB0aGlzIGhvc3QgdGV4dC5cbiAgICAgICAgdmFyIHJldHVybkZpYmVyID0gaHlkcmF0aW9uUGFyZW50RmliZXI7XG4gICAgICAgIGlmIChyZXR1cm5GaWJlciAhPT0gbnVsbCkge1xuICAgICAgICAgIHN3aXRjaCAocmV0dXJuRmliZXIudGFnKSB7XG4gICAgICAgICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdmFyIHBhcmVudENvbnRhaW5lciA9IHJldHVybkZpYmVyLnN0YXRlTm9kZS5jb250YWluZXJJbmZvO1xuICAgICAgICAgICAgICAgIGRpZE5vdE1hdGNoSHlkcmF0ZWRDb250YWluZXJUZXh0SW5zdGFuY2UocGFyZW50Q29udGFpbmVyLCB0ZXh0SW5zdGFuY2UsIHRleHRDb250ZW50KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdmFyIHBhcmVudFR5cGUgPSByZXR1cm5GaWJlci50eXBlO1xuICAgICAgICAgICAgICAgIHZhciBwYXJlbnRQcm9wcyA9IHJldHVybkZpYmVyLm1lbW9pemVkUHJvcHM7XG4gICAgICAgICAgICAgICAgdmFyIHBhcmVudEluc3RhbmNlID0gcmV0dXJuRmliZXIuc3RhdGVOb2RlO1xuICAgICAgICAgICAgICAgIGRpZE5vdE1hdGNoSHlkcmF0ZWRUZXh0SW5zdGFuY2UocGFyZW50VHlwZSwgcGFyZW50UHJvcHMsIHBhcmVudEluc3RhbmNlLCB0ZXh0SW5zdGFuY2UsIHRleHRDb250ZW50KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc2hvdWxkVXBkYXRlO1xuICB9XG5cbiAgZnVuY3Rpb24gcG9wVG9OZXh0SG9zdFBhcmVudChmaWJlcikge1xuICAgIHZhciBwYXJlbnQgPSBmaWJlclsncmV0dXJuJ107XG4gICAgd2hpbGUgKHBhcmVudCAhPT0gbnVsbCAmJiBwYXJlbnQudGFnICE9PSBIb3N0Q29tcG9uZW50ICYmIHBhcmVudC50YWcgIT09IEhvc3RSb290KSB7XG4gICAgICBwYXJlbnQgPSBwYXJlbnRbJ3JldHVybiddO1xuICAgIH1cbiAgICBoeWRyYXRpb25QYXJlbnRGaWJlciA9IHBhcmVudDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBvcEh5ZHJhdGlvblN0YXRlKGZpYmVyKSB7XG4gICAgaWYgKGZpYmVyICE9PSBoeWRyYXRpb25QYXJlbnRGaWJlcikge1xuICAgICAgLy8gV2UncmUgZGVlcGVyIHRoYW4gdGhlIGN1cnJlbnQgaHlkcmF0aW9uIGNvbnRleHQsIGluc2lkZSBhbiBpbnNlcnRlZFxuICAgICAgLy8gdHJlZS5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKCFpc0h5ZHJhdGluZykge1xuICAgICAgLy8gSWYgd2UncmUgbm90IGN1cnJlbnRseSBoeWRyYXRpbmcgYnV0IHdlJ3JlIGluIGEgaHlkcmF0aW9uIGNvbnRleHQsIHRoZW5cbiAgICAgIC8vIHdlIHdlcmUgYW4gaW5zZXJ0aW9uIGFuZCBub3cgbmVlZCB0byBwb3AgdXAgcmVlbnRlciBoeWRyYXRpb24gb2Ygb3VyXG4gICAgICAvLyBzaWJsaW5ncy5cbiAgICAgIHBvcFRvTmV4dEhvc3RQYXJlbnQoZmliZXIpO1xuICAgICAgaXNIeWRyYXRpbmcgPSB0cnVlO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciB0eXBlID0gZmliZXIudHlwZTtcblxuICAgIC8vIElmIHdlIGhhdmUgYW55IHJlbWFpbmluZyBoeWRyYXRhYmxlIG5vZGVzLCB3ZSBuZWVkIHRvIGRlbGV0ZSB0aGVtIG5vdy5cbiAgICAvLyBXZSBvbmx5IGRvIHRoaXMgZGVlcGVyIHRoYW4gaGVhZCBhbmQgYm9keSBzaW5jZSB0aGV5IHRlbmQgdG8gaGF2ZSByYW5kb21cbiAgICAvLyBvdGhlciBub2RlcyBpbiB0aGVtLiBXZSBhbHNvIGlnbm9yZSBjb21wb25lbnRzIHdpdGggcHVyZSB0ZXh0IGNvbnRlbnQgaW5cbiAgICAvLyBzaWRlIG9mIHRoZW0uXG4gICAgLy8gVE9ETzogQmV0dGVyIGhldXJpc3RpYy5cbiAgICBpZiAoZmliZXIudGFnICE9PSBIb3N0Q29tcG9uZW50IHx8IHR5cGUgIT09ICdoZWFkJyAmJiB0eXBlICE9PSAnYm9keScgJiYgIXNob3VsZFNldFRleHRDb250ZW50KHR5cGUsIGZpYmVyLm1lbW9pemVkUHJvcHMpKSB7XG4gICAgICB2YXIgbmV4dEluc3RhbmNlID0gbmV4dEh5ZHJhdGFibGVJbnN0YW5jZTtcbiAgICAgIHdoaWxlIChuZXh0SW5zdGFuY2UpIHtcbiAgICAgICAgZGVsZXRlSHlkcmF0YWJsZUluc3RhbmNlKGZpYmVyLCBuZXh0SW5zdGFuY2UpO1xuICAgICAgICBuZXh0SW5zdGFuY2UgPSBnZXROZXh0SHlkcmF0YWJsZVNpYmxpbmcobmV4dEluc3RhbmNlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBwb3BUb05leHRIb3N0UGFyZW50KGZpYmVyKTtcbiAgICBuZXh0SHlkcmF0YWJsZUluc3RhbmNlID0gaHlkcmF0aW9uUGFyZW50RmliZXIgPyBnZXROZXh0SHlkcmF0YWJsZVNpYmxpbmcoZmliZXIuc3RhdGVOb2RlKSA6IG51bGw7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBmdW5jdGlvbiByZXNldEh5ZHJhdGlvblN0YXRlKCkge1xuICAgIGh5ZHJhdGlvblBhcmVudEZpYmVyID0gbnVsbDtcbiAgICBuZXh0SHlkcmF0YWJsZUluc3RhbmNlID0gbnVsbDtcbiAgICBpc0h5ZHJhdGluZyA9IGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBlbnRlckh5ZHJhdGlvblN0YXRlOiBlbnRlckh5ZHJhdGlvblN0YXRlLFxuICAgIHJlc2V0SHlkcmF0aW9uU3RhdGU6IHJlc2V0SHlkcmF0aW9uU3RhdGUsXG4gICAgdHJ5VG9DbGFpbU5leHRIeWRyYXRhYmxlSW5zdGFuY2U6IHRyeVRvQ2xhaW1OZXh0SHlkcmF0YWJsZUluc3RhbmNlLFxuICAgIHByZXBhcmVUb0h5ZHJhdGVIb3N0SW5zdGFuY2U6IHByZXBhcmVUb0h5ZHJhdGVIb3N0SW5zdGFuY2UsXG4gICAgcHJlcGFyZVRvSHlkcmF0ZUhvc3RUZXh0SW5zdGFuY2U6IHByZXBhcmVUb0h5ZHJhdGVIb3N0VGV4dEluc3RhbmNlLFxuICAgIHBvcEh5ZHJhdGlvblN0YXRlOiBwb3BIeWRyYXRpb25TdGF0ZVxuICB9O1xufTtcblxuLy8gVGhpcyBsZXRzIHVzIGhvb2sgaW50byBGaWJlciB0byBkZWJ1ZyB3aGF0IGl0J3MgZG9pbmcuXG4vLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvODAzMy5cbi8vIFRoaXMgaXMgbm90IHBhcnQgb2YgdGhlIHB1YmxpYyBBUEksIG5vdCBldmVuIGZvciBSZWFjdCBEZXZUb29scy5cbi8vIFlvdSBtYXkgb25seSBpbmplY3QgYSBkZWJ1Z1Rvb2wgaWYgeW91IHdvcmsgb24gUmVhY3QgRmliZXIgaXRzZWxmLlxudmFyIFJlYWN0RmliZXJJbnN0cnVtZW50YXRpb24gPSB7XG4gIGRlYnVnVG9vbDogbnVsbFxufTtcblxudmFyIFJlYWN0RmliZXJJbnN0cnVtZW50YXRpb25fMSA9IFJlYWN0RmliZXJJbnN0cnVtZW50YXRpb247XG5cbnZhciBkZWZhdWx0U2hvd0RpYWxvZyA9IGZ1bmN0aW9uIChjYXB0dXJlZEVycm9yKSB7XG4gIHJldHVybiB0cnVlO1xufTtcblxudmFyIHNob3dEaWFsb2cgPSBkZWZhdWx0U2hvd0RpYWxvZztcblxuZnVuY3Rpb24gbG9nQ2FwdHVyZWRFcnJvcihjYXB0dXJlZEVycm9yKSB7XG4gIHZhciBsb2dFcnJvciA9IHNob3dEaWFsb2coY2FwdHVyZWRFcnJvcik7XG5cbiAgLy8gQWxsb3cgaW5qZWN0ZWQgc2hvd0RpYWxvZygpIHRvIHByZXZlbnQgZGVmYXVsdCBjb25zb2xlLmVycm9yIGxvZ2dpbmcuXG4gIC8vIFRoaXMgZW5hYmxlcyByZW5kZXJlcnMgbGlrZSBSZWFjdE5hdGl2ZSB0byBiZXR0ZXIgbWFuYWdlIHJlZGJveCBiZWhhdmlvci5cbiAgaWYgKGxvZ0Vycm9yID09PSBmYWxzZSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBlcnJvciA9IGNhcHR1cmVkRXJyb3IuZXJyb3I7XG4gIHZhciBzdXBwcmVzc0xvZ2dpbmcgPSBlcnJvciAmJiBlcnJvci5zdXBwcmVzc1JlYWN0RXJyb3JMb2dnaW5nO1xuICBpZiAoc3VwcHJlc3NMb2dnaW5nKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAge1xuICAgIHZhciBjb21wb25lbnROYW1lID0gY2FwdHVyZWRFcnJvci5jb21wb25lbnROYW1lLFxuICAgICAgICBjb21wb25lbnRTdGFjayA9IGNhcHR1cmVkRXJyb3IuY29tcG9uZW50U3RhY2ssXG4gICAgICAgIGVycm9yQm91bmRhcnlOYW1lID0gY2FwdHVyZWRFcnJvci5lcnJvckJvdW5kYXJ5TmFtZSxcbiAgICAgICAgZXJyb3JCb3VuZGFyeUZvdW5kID0gY2FwdHVyZWRFcnJvci5lcnJvckJvdW5kYXJ5Rm91bmQsXG4gICAgICAgIHdpbGxSZXRyeSA9IGNhcHR1cmVkRXJyb3Iud2lsbFJldHJ5O1xuXG5cbiAgICB2YXIgY29tcG9uZW50TmFtZU1lc3NhZ2UgPSBjb21wb25lbnROYW1lID8gJ1RoZSBhYm92ZSBlcnJvciBvY2N1cnJlZCBpbiB0aGUgPCcgKyBjb21wb25lbnROYW1lICsgJz4gY29tcG9uZW50OicgOiAnVGhlIGFib3ZlIGVycm9yIG9jY3VycmVkIGluIG9uZSBvZiB5b3VyIFJlYWN0IGNvbXBvbmVudHM6JztcblxuICAgIHZhciBlcnJvckJvdW5kYXJ5TWVzc2FnZSA9IHZvaWQgMDtcbiAgICAvLyBlcnJvckJvdW5kYXJ5Rm91bmQgY2hlY2sgaXMgc3VmZmljaWVudDsgZXJyb3JCb3VuZGFyeU5hbWUgY2hlY2sgaXMgdG8gc2F0aXNmeSBGbG93LlxuICAgIGlmIChlcnJvckJvdW5kYXJ5Rm91bmQgJiYgZXJyb3JCb3VuZGFyeU5hbWUpIHtcbiAgICAgIGlmICh3aWxsUmV0cnkpIHtcbiAgICAgICAgZXJyb3JCb3VuZGFyeU1lc3NhZ2UgPSAnUmVhY3Qgd2lsbCB0cnkgdG8gcmVjcmVhdGUgdGhpcyBjb21wb25lbnQgdHJlZSBmcm9tIHNjcmF0Y2ggJyArICgndXNpbmcgdGhlIGVycm9yIGJvdW5kYXJ5IHlvdSBwcm92aWRlZCwgJyArIGVycm9yQm91bmRhcnlOYW1lICsgJy4nKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVycm9yQm91bmRhcnlNZXNzYWdlID0gJ1RoaXMgZXJyb3Igd2FzIGluaXRpYWxseSBoYW5kbGVkIGJ5IHRoZSBlcnJvciBib3VuZGFyeSAnICsgZXJyb3JCb3VuZGFyeU5hbWUgKyAnLlxcbicgKyAnUmVjcmVhdGluZyB0aGUgdHJlZSBmcm9tIHNjcmF0Y2ggZmFpbGVkIHNvIFJlYWN0IHdpbGwgdW5tb3VudCB0aGUgdHJlZS4nO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBlcnJvckJvdW5kYXJ5TWVzc2FnZSA9ICdDb25zaWRlciBhZGRpbmcgYW4gZXJyb3IgYm91bmRhcnkgdG8geW91ciB0cmVlIHRvIGN1c3RvbWl6ZSBlcnJvciBoYW5kbGluZyBiZWhhdmlvci5cXG4nICsgJ1Zpc2l0IGh0dHBzOi8vZmIubWUvcmVhY3QtZXJyb3ItYm91bmRhcmllcyB0byBsZWFybiBtb3JlIGFib3V0IGVycm9yIGJvdW5kYXJpZXMuJztcbiAgICB9XG4gICAgdmFyIGNvbWJpbmVkTWVzc2FnZSA9ICcnICsgY29tcG9uZW50TmFtZU1lc3NhZ2UgKyBjb21wb25lbnRTdGFjayArICdcXG5cXG4nICsgKCcnICsgZXJyb3JCb3VuZGFyeU1lc3NhZ2UpO1xuXG4gICAgLy8gSW4gZGV2ZWxvcG1lbnQsIHdlIHByb3ZpZGUgb3VyIG93biBtZXNzYWdlIHdpdGgganVzdCB0aGUgY29tcG9uZW50IHN0YWNrLlxuICAgIC8vIFdlIGRvbid0IGluY2x1ZGUgdGhlIG9yaWdpbmFsIGVycm9yIG1lc3NhZ2UgYW5kIEpTIHN0YWNrIGJlY2F1c2UgdGhlIGJyb3dzZXJcbiAgICAvLyBoYXMgYWxyZWFkeSBwcmludGVkIGl0LiBFdmVuIGlmIHRoZSBhcHBsaWNhdGlvbiBzd2FsbG93cyB0aGUgZXJyb3IsIGl0IGlzIHN0aWxsXG4gICAgLy8gZGlzcGxheWVkIGJ5IHRoZSBicm93c2VyIHRoYW5rcyB0byB0aGUgREVWLW9ubHkgZmFrZSBldmVudCB0cmljayBpbiBSZWFjdEVycm9yVXRpbHMuXG4gICAgY29uc29sZS5lcnJvcihjb21iaW5lZE1lc3NhZ2UpO1xuICB9XG59XG5cbnZhciBpbnZva2VHdWFyZGVkQ2FsbGJhY2sgPSBSZWFjdEVycm9yVXRpbHMuaW52b2tlR3VhcmRlZENhbGxiYWNrO1xudmFyIGhhc0NhdWdodEVycm9yID0gUmVhY3RFcnJvclV0aWxzLmhhc0NhdWdodEVycm9yO1xudmFyIGNsZWFyQ2F1Z2h0RXJyb3IgPSBSZWFjdEVycm9yVXRpbHMuY2xlYXJDYXVnaHRFcnJvcjtcblxuXG57XG4gIHZhciBkaWRXYXJuQWJvdXRTdGF0ZVRyYW5zaXRpb24gPSBmYWxzZTtcbiAgdmFyIGRpZFdhcm5TZXRTdGF0ZUNoaWxkQ29udGV4dCA9IGZhbHNlO1xuICB2YXIgZGlkV2FyblN0YXRlVXBkYXRlRm9yVW5tb3VudGVkQ29tcG9uZW50ID0ge307XG5cbiAgdmFyIHdhcm5BYm91dFVwZGF0ZU9uVW5tb3VudGVkID0gZnVuY3Rpb24gKGZpYmVyKSB7XG4gICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lKGZpYmVyKSB8fCAnUmVhY3RDbGFzcyc7XG4gICAgaWYgKGRpZFdhcm5TdGF0ZVVwZGF0ZUZvclVubW91bnRlZENvbXBvbmVudFtjb21wb25lbnROYW1lXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB3YXJuaW5nKGZhbHNlLCAnQ2FuIG9ubHkgdXBkYXRlIGEgbW91bnRlZCBvciBtb3VudGluZyAnICsgJ2NvbXBvbmVudC4gVGhpcyB1c3VhbGx5IG1lYW5zIHlvdSBjYWxsZWQgc2V0U3RhdGUsIHJlcGxhY2VTdGF0ZSwgJyArICdvciBmb3JjZVVwZGF0ZSBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LiBUaGlzIGlzIGEgbm8tb3AuXFxuXFxuUGxlYXNlICcgKyAnY2hlY2sgdGhlIGNvZGUgZm9yIHRoZSAlcyBjb21wb25lbnQuJywgY29tcG9uZW50TmFtZSk7XG4gICAgZGlkV2FyblN0YXRlVXBkYXRlRm9yVW5tb3VudGVkQ29tcG9uZW50W2NvbXBvbmVudE5hbWVdID0gdHJ1ZTtcbiAgfTtcblxuICB2YXIgd2FybkFib3V0SW52YWxpZFVwZGF0ZXMgPSBmdW5jdGlvbiAoaW5zdGFuY2UpIHtcbiAgICBzd2l0Y2ggKFJlYWN0RGVidWdDdXJyZW50RmliZXIucGhhc2UpIHtcbiAgICAgIGNhc2UgJ2dldENoaWxkQ29udGV4dCc6XG4gICAgICAgIGlmIChkaWRXYXJuU2V0U3RhdGVDaGlsZENvbnRleHQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgd2FybmluZyhmYWxzZSwgJ3NldFN0YXRlKC4uLik6IENhbm5vdCBjYWxsIHNldFN0YXRlKCkgaW5zaWRlIGdldENoaWxkQ29udGV4dCgpJyk7XG4gICAgICAgIGRpZFdhcm5TZXRTdGF0ZUNoaWxkQ29udGV4dCA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAncmVuZGVyJzpcbiAgICAgICAgaWYgKGRpZFdhcm5BYm91dFN0YXRlVHJhbnNpdGlvbikge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB3YXJuaW5nKGZhbHNlLCAnQ2Fubm90IHVwZGF0ZSBkdXJpbmcgYW4gZXhpc3Rpbmcgc3RhdGUgdHJhbnNpdGlvbiAoc3VjaCBhcyB3aXRoaW4gJyArIFwiYHJlbmRlcmAgb3IgYW5vdGhlciBjb21wb25lbnQncyBjb25zdHJ1Y3RvcikuIFJlbmRlciBtZXRob2RzIHNob3VsZCBcIiArICdiZSBhIHB1cmUgZnVuY3Rpb24gb2YgcHJvcHMgYW5kIHN0YXRlOyBjb25zdHJ1Y3RvciBzaWRlLWVmZmVjdHMgYXJlICcgKyAnYW4gYW50aS1wYXR0ZXJuLCBidXQgY2FuIGJlIG1vdmVkIHRvIGBjb21wb25lbnRXaWxsTW91bnRgLicpO1xuICAgICAgICBkaWRXYXJuQWJvdXRTdGF0ZVRyYW5zaXRpb24gPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH07XG59XG5cbnZhciBSZWFjdEZpYmVyU2NoZWR1bGVyID0gZnVuY3Rpb24gKGNvbmZpZykge1xuICB2YXIgaG9zdENvbnRleHQgPSBSZWFjdEZpYmVySG9zdENvbnRleHQoY29uZmlnKTtcbiAgdmFyIGh5ZHJhdGlvbkNvbnRleHQgPSBSZWFjdEZpYmVySHlkcmF0aW9uQ29udGV4dChjb25maWcpO1xuICB2YXIgcG9wSG9zdENvbnRhaW5lciA9IGhvc3RDb250ZXh0LnBvcEhvc3RDb250YWluZXIsXG4gICAgICBwb3BIb3N0Q29udGV4dCA9IGhvc3RDb250ZXh0LnBvcEhvc3RDb250ZXh0LFxuICAgICAgcmVzZXRIb3N0Q29udGFpbmVyID0gaG9zdENvbnRleHQucmVzZXRIb3N0Q29udGFpbmVyO1xuXG4gIHZhciBfUmVhY3RGaWJlckJlZ2luV29yayA9IFJlYWN0RmliZXJCZWdpbldvcmsoY29uZmlnLCBob3N0Q29udGV4dCwgaHlkcmF0aW9uQ29udGV4dCwgc2NoZWR1bGVXb3JrLCBjb21wdXRlRXhwaXJhdGlvbkZvckZpYmVyKSxcbiAgICAgIGJlZ2luV29yayA9IF9SZWFjdEZpYmVyQmVnaW5Xb3JrLmJlZ2luV29yayxcbiAgICAgIGJlZ2luRmFpbGVkV29yayA9IF9SZWFjdEZpYmVyQmVnaW5Xb3JrLmJlZ2luRmFpbGVkV29yaztcblxuICB2YXIgX1JlYWN0RmliZXJDb21wbGV0ZVdvID0gUmVhY3RGaWJlckNvbXBsZXRlV29yayhjb25maWcsIGhvc3RDb250ZXh0LCBoeWRyYXRpb25Db250ZXh0KSxcbiAgICAgIGNvbXBsZXRlV29yayA9IF9SZWFjdEZpYmVyQ29tcGxldGVXby5jb21wbGV0ZVdvcms7XG5cbiAgdmFyIF9SZWFjdEZpYmVyQ29tbWl0V29yayA9IFJlYWN0RmliZXJDb21taXRXb3JrKGNvbmZpZywgY2FwdHVyZUVycm9yKSxcbiAgICAgIGNvbW1pdFJlc2V0VGV4dENvbnRlbnQgPSBfUmVhY3RGaWJlckNvbW1pdFdvcmsuY29tbWl0UmVzZXRUZXh0Q29udGVudCxcbiAgICAgIGNvbW1pdFBsYWNlbWVudCA9IF9SZWFjdEZpYmVyQ29tbWl0V29yay5jb21taXRQbGFjZW1lbnQsXG4gICAgICBjb21taXREZWxldGlvbiA9IF9SZWFjdEZpYmVyQ29tbWl0V29yay5jb21taXREZWxldGlvbixcbiAgICAgIGNvbW1pdFdvcmsgPSBfUmVhY3RGaWJlckNvbW1pdFdvcmsuY29tbWl0V29yayxcbiAgICAgIGNvbW1pdExpZmVDeWNsZXMgPSBfUmVhY3RGaWJlckNvbW1pdFdvcmsuY29tbWl0TGlmZUN5Y2xlcyxcbiAgICAgIGNvbW1pdEF0dGFjaFJlZiA9IF9SZWFjdEZpYmVyQ29tbWl0V29yay5jb21taXRBdHRhY2hSZWYsXG4gICAgICBjb21taXREZXRhY2hSZWYgPSBfUmVhY3RGaWJlckNvbW1pdFdvcmsuY29tbWl0RGV0YWNoUmVmO1xuXG4gIHZhciBub3cgPSBjb25maWcubm93LFxuICAgICAgc2NoZWR1bGVEZWZlcnJlZENhbGxiYWNrID0gY29uZmlnLnNjaGVkdWxlRGVmZXJyZWRDYWxsYmFjayxcbiAgICAgIGNhbmNlbERlZmVycmVkQ2FsbGJhY2sgPSBjb25maWcuY2FuY2VsRGVmZXJyZWRDYWxsYmFjayxcbiAgICAgIHVzZVN5bmNTY2hlZHVsaW5nID0gY29uZmlnLnVzZVN5bmNTY2hlZHVsaW5nLFxuICAgICAgcHJlcGFyZUZvckNvbW1pdCA9IGNvbmZpZy5wcmVwYXJlRm9yQ29tbWl0LFxuICAgICAgcmVzZXRBZnRlckNvbW1pdCA9IGNvbmZpZy5yZXNldEFmdGVyQ29tbWl0O1xuXG4gIC8vIFJlcHJlc2VudHMgdGhlIGN1cnJlbnQgdGltZSBpbiBtcy5cblxuICB2YXIgc3RhcnRUaW1lID0gbm93KCk7XG4gIHZhciBtb3N0UmVjZW50Q3VycmVudFRpbWUgPSBtc1RvRXhwaXJhdGlvblRpbWUoMCk7XG5cbiAgLy8gUmVwcmVzZW50cyB0aGUgZXhwaXJhdGlvbiB0aW1lIHRoYXQgaW5jb21pbmcgdXBkYXRlcyBzaG91bGQgdXNlLiAoSWYgdGhpc1xuICAvLyBpcyBOb1dvcmssIHVzZSB0aGUgZGVmYXVsdCBzdHJhdGVneTogYXN5bmMgdXBkYXRlcyBpbiBhc3luYyBtb2RlLCBzeW5jXG4gIC8vIHVwZGF0ZXMgaW4gc3luYyBtb2RlLilcbiAgdmFyIGV4cGlyYXRpb25Db250ZXh0ID0gTm9Xb3JrO1xuXG4gIHZhciBpc1dvcmtpbmcgPSBmYWxzZTtcblxuICAvLyBUaGUgbmV4dCB3b3JrIGluIHByb2dyZXNzIGZpYmVyIHRoYXQgd2UncmUgY3VycmVudGx5IHdvcmtpbmcgb24uXG4gIHZhciBuZXh0VW5pdE9mV29yayA9IG51bGw7XG4gIHZhciBuZXh0Um9vdCA9IG51bGw7XG4gIC8vIFRoZSB0aW1lIGF0IHdoaWNoIHdlJ3JlIGN1cnJlbnRseSByZW5kZXJpbmcgd29yay5cbiAgdmFyIG5leHRSZW5kZXJFeHBpcmF0aW9uVGltZSA9IE5vV29yaztcblxuICAvLyBUaGUgbmV4dCBmaWJlciB3aXRoIGFuIGVmZmVjdCB0aGF0IHdlJ3JlIGN1cnJlbnRseSBjb21taXR0aW5nLlxuICB2YXIgbmV4dEVmZmVjdCA9IG51bGw7XG5cbiAgLy8gS2VlcCB0cmFjayBvZiB3aGljaCBmaWJlcnMgaGF2ZSBjYXB0dXJlZCBhbiBlcnJvciB0aGF0IG5lZWQgdG8gYmUgaGFuZGxlZC5cbiAgLy8gV29yayBpcyByZW1vdmVkIGZyb20gdGhpcyBjb2xsZWN0aW9uIGFmdGVyIGNvbXBvbmVudERpZENhdGNoIGlzIGNhbGxlZC5cbiAgdmFyIGNhcHR1cmVkRXJyb3JzID0gbnVsbDtcbiAgLy8gS2VlcCB0cmFjayBvZiB3aGljaCBmaWJlcnMgaGF2ZSBmYWlsZWQgZHVyaW5nIHRoZSBjdXJyZW50IGJhdGNoIG9mIHdvcmsuXG4gIC8vIFRoaXMgaXMgYSBkaWZmZXJlbnQgc2V0IHRoYW4gY2FwdHVyZWRFcnJvcnMsIGJlY2F1c2UgaXQgaXMgbm90IHJlc2V0IHVudGlsXG4gIC8vIHRoZSBlbmQgb2YgdGhlIGJhdGNoLiBUaGlzIGlzIG5lZWRlZCB0byBwcm9wYWdhdGUgZXJyb3JzIGNvcnJlY3RseSBpZiBhXG4gIC8vIHN1YnRyZWUgZmFpbHMgbW9yZSB0aGFuIG9uY2UuXG4gIHZhciBmYWlsZWRCb3VuZGFyaWVzID0gbnVsbDtcbiAgLy8gRXJyb3IgYm91bmRhcmllcyB0aGF0IGNhcHR1cmVkIGFuIGVycm9yIGR1cmluZyB0aGUgY3VycmVudCBjb21taXQuXG4gIHZhciBjb21taXRQaGFzZUJvdW5kYXJpZXMgPSBudWxsO1xuICB2YXIgZmlyc3RVbmNhdWdodEVycm9yID0gbnVsbDtcbiAgdmFyIGRpZEZhdGFsID0gZmFsc2U7XG5cbiAgdmFyIGlzQ29tbWl0dGluZyA9IGZhbHNlO1xuICB2YXIgaXNVbm1vdW50aW5nID0gZmFsc2U7XG5cbiAgLy8gVXNlZCBmb3IgcGVyZm9ybWFuY2UgdHJhY2tpbmcuXG4gIHZhciBpbnRlcnJ1cHRlZEJ5ID0gbnVsbDtcblxuICBmdW5jdGlvbiByZXNldENvbnRleHRTdGFjaygpIHtcbiAgICAvLyBSZXNldCB0aGUgc3RhY2tcbiAgICByZXNldCgpO1xuICAgIC8vIFJlc2V0IHRoZSBjdXJzb3JzXG4gICAgcmVzZXRDb250ZXh0KCk7XG4gICAgcmVzZXRIb3N0Q29udGFpbmVyKCk7XG4gIH1cblxuICBmdW5jdGlvbiBjb21taXRBbGxIb3N0RWZmZWN0cygpIHtcbiAgICB3aGlsZSAobmV4dEVmZmVjdCAhPT0gbnVsbCkge1xuICAgICAge1xuICAgICAgICBSZWFjdERlYnVnQ3VycmVudEZpYmVyLnNldEN1cnJlbnRGaWJlcihuZXh0RWZmZWN0KTtcbiAgICAgIH1cbiAgICAgIHJlY29yZEVmZmVjdCgpO1xuXG4gICAgICB2YXIgZWZmZWN0VGFnID0gbmV4dEVmZmVjdC5lZmZlY3RUYWc7XG4gICAgICBpZiAoZWZmZWN0VGFnICYgQ29udGVudFJlc2V0KSB7XG4gICAgICAgIGNvbW1pdFJlc2V0VGV4dENvbnRlbnQobmV4dEVmZmVjdCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChlZmZlY3RUYWcgJiBSZWYpIHtcbiAgICAgICAgdmFyIGN1cnJlbnQgPSBuZXh0RWZmZWN0LmFsdGVybmF0ZTtcbiAgICAgICAgaWYgKGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgICBjb21taXREZXRhY2hSZWYoY3VycmVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVGhlIGZvbGxvd2luZyBzd2l0Y2ggc3RhdGVtZW50IGlzIG9ubHkgY29uY2VybmVkIGFib3V0IHBsYWNlbWVudCxcbiAgICAgIC8vIHVwZGF0ZXMsIGFuZCBkZWxldGlvbnMuIFRvIGF2b2lkIG5lZWRpbmcgdG8gYWRkIGEgY2FzZSBmb3IgZXZlcnlcbiAgICAgIC8vIHBvc3NpYmxlIGJpdG1hcCB2YWx1ZSwgd2UgcmVtb3ZlIHRoZSBzZWNvbmRhcnkgZWZmZWN0cyBmcm9tIHRoZVxuICAgICAgLy8gZWZmZWN0IHRhZyBhbmQgc3dpdGNoIG9uIHRoYXQgdmFsdWUuXG4gICAgICB2YXIgcHJpbWFyeUVmZmVjdFRhZyA9IGVmZmVjdFRhZyAmIH4oQ2FsbGJhY2sgfCBFcnIgfCBDb250ZW50UmVzZXQgfCBSZWYgfCBQZXJmb3JtZWRXb3JrKTtcbiAgICAgIHN3aXRjaCAocHJpbWFyeUVmZmVjdFRhZykge1xuICAgICAgICBjYXNlIFBsYWNlbWVudDpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjb21taXRQbGFjZW1lbnQobmV4dEVmZmVjdCk7XG4gICAgICAgICAgICAvLyBDbGVhciB0aGUgXCJwbGFjZW1lbnRcIiBmcm9tIGVmZmVjdCB0YWcgc28gdGhhdCB3ZSBrbm93IHRoYXQgdGhpcyBpcyBpbnNlcnRlZCwgYmVmb3JlXG4gICAgICAgICAgICAvLyBhbnkgbGlmZS1jeWNsZXMgbGlrZSBjb21wb25lbnREaWRNb3VudCBnZXRzIGNhbGxlZC5cbiAgICAgICAgICAgIC8vIFRPRE86IGZpbmRET01Ob2RlIGRvZXNuJ3QgcmVseSBvbiB0aGlzIGFueSBtb3JlIGJ1dCBpc01vdW50ZWRcbiAgICAgICAgICAgIC8vIGRvZXMgYW5kIGlzTW91bnRlZCBpcyBkZXByZWNhdGVkIGFueXdheSBzbyB3ZSBzaG91bGQgYmUgYWJsZVxuICAgICAgICAgICAgLy8gdG8ga2lsbCB0aGlzLlxuICAgICAgICAgICAgbmV4dEVmZmVjdC5lZmZlY3RUYWcgJj0gflBsYWNlbWVudDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSBQbGFjZW1lbnRBbmRVcGRhdGU6XG4gICAgICAgICAge1xuICAgICAgICAgICAgLy8gUGxhY2VtZW50XG4gICAgICAgICAgICBjb21taXRQbGFjZW1lbnQobmV4dEVmZmVjdCk7XG4gICAgICAgICAgICAvLyBDbGVhciB0aGUgXCJwbGFjZW1lbnRcIiBmcm9tIGVmZmVjdCB0YWcgc28gdGhhdCB3ZSBrbm93IHRoYXQgdGhpcyBpcyBpbnNlcnRlZCwgYmVmb3JlXG4gICAgICAgICAgICAvLyBhbnkgbGlmZS1jeWNsZXMgbGlrZSBjb21wb25lbnREaWRNb3VudCBnZXRzIGNhbGxlZC5cbiAgICAgICAgICAgIG5leHRFZmZlY3QuZWZmZWN0VGFnICY9IH5QbGFjZW1lbnQ7XG5cbiAgICAgICAgICAgIC8vIFVwZGF0ZVxuICAgICAgICAgICAgdmFyIF9jdXJyZW50ID0gbmV4dEVmZmVjdC5hbHRlcm5hdGU7XG4gICAgICAgICAgICBjb21taXRXb3JrKF9jdXJyZW50LCBuZXh0RWZmZWN0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSBVcGRhdGU6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIF9jdXJyZW50MiA9IG5leHRFZmZlY3QuYWx0ZXJuYXRlO1xuICAgICAgICAgICAgY29tbWl0V29yayhfY3VycmVudDIsIG5leHRFZmZlY3QpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlIERlbGV0aW9uOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlzVW5tb3VudGluZyA9IHRydWU7XG4gICAgICAgICAgICBjb21taXREZWxldGlvbihuZXh0RWZmZWN0KTtcbiAgICAgICAgICAgIGlzVW5tb3VudGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgICAgbmV4dEVmZmVjdCA9IG5leHRFZmZlY3QubmV4dEVmZmVjdDtcbiAgICB9XG5cbiAgICB7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZpYmVyLnJlc2V0Q3VycmVudEZpYmVyKCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY29tbWl0QWxsTGlmZUN5Y2xlcygpIHtcbiAgICB3aGlsZSAobmV4dEVmZmVjdCAhPT0gbnVsbCkge1xuICAgICAgdmFyIGVmZmVjdFRhZyA9IG5leHRFZmZlY3QuZWZmZWN0VGFnO1xuXG4gICAgICBpZiAoZWZmZWN0VGFnICYgKFVwZGF0ZSB8IENhbGxiYWNrKSkge1xuICAgICAgICByZWNvcmRFZmZlY3QoKTtcbiAgICAgICAgdmFyIGN1cnJlbnQgPSBuZXh0RWZmZWN0LmFsdGVybmF0ZTtcbiAgICAgICAgY29tbWl0TGlmZUN5Y2xlcyhjdXJyZW50LCBuZXh0RWZmZWN0KTtcbiAgICAgIH1cblxuICAgICAgaWYgKGVmZmVjdFRhZyAmIFJlZikge1xuICAgICAgICByZWNvcmRFZmZlY3QoKTtcbiAgICAgICAgY29tbWl0QXR0YWNoUmVmKG5leHRFZmZlY3QpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZWZmZWN0VGFnICYgRXJyKSB7XG4gICAgICAgIHJlY29yZEVmZmVjdCgpO1xuICAgICAgICBjb21taXRFcnJvckhhbmRsaW5nKG5leHRFZmZlY3QpO1xuICAgICAgfVxuXG4gICAgICB2YXIgbmV4dCA9IG5leHRFZmZlY3QubmV4dEVmZmVjdDtcbiAgICAgIC8vIEVuc3VyZSB0aGF0IHdlIGNsZWFuIHRoZXNlIHVwIHNvIHRoYXQgd2UgZG9uJ3QgYWNjaWRlbnRhbGx5IGtlZXAgdGhlbS5cbiAgICAgIC8vIEknbSBub3QgYWN0dWFsbHkgc3VyZSB0aGlzIG1hdHRlcnMgYmVjYXVzZSB3ZSBjYW4ndCByZXNldCBmaXJzdEVmZmVjdFxuICAgICAgLy8gYW5kIGxhc3RFZmZlY3Qgc2luY2UgdGhleSdyZSBvbiBldmVyeSBub2RlLCBub3QganVzdCB0aGUgZWZmZWN0ZnVsXG4gICAgICAvLyBvbmVzLiBTbyB3ZSBoYXZlIHRvIGNsZWFuIGV2ZXJ5dGhpbmcgYXMgd2UgcmV1c2Ugbm9kZXMgYW55d2F5LlxuICAgICAgbmV4dEVmZmVjdC5uZXh0RWZmZWN0ID0gbnVsbDtcbiAgICAgIC8vIEVuc3VyZSB0aGF0IHdlIHJlc2V0IHRoZSBlZmZlY3RUYWcgaGVyZSBzbyB0aGF0IHdlIGNhbiByZWx5IG9uIGVmZmVjdFxuICAgICAgLy8gdGFncyB0byByZWFzb24gYWJvdXQgdGhlIGN1cnJlbnQgbGlmZS1jeWNsZS5cbiAgICAgIG5leHRFZmZlY3QgPSBuZXh0O1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbW1pdFJvb3QoZmluaXNoZWRXb3JrKSB7XG4gICAgLy8gV2Uga2VlcCB0cmFjayBvZiB0aGlzIHNvIHRoYXQgY2FwdHVyZUVycm9yIGNhbiBjb2xsZWN0IGFueSBib3VuZGFyaWVzXG4gICAgLy8gdGhhdCBjYXB0dXJlIGFuIGVycm9yIGR1cmluZyB0aGUgY29tbWl0IHBoYXNlLiBUaGUgcmVhc29uIHRoZXNlIGFyZW4ndFxuICAgIC8vIGxvY2FsIHRvIHRoaXMgZnVuY3Rpb24gaXMgYmVjYXVzZSBlcnJvcnMgdGhhdCBvY2N1ciBkdXJpbmcgY1dVIGFyZVxuICAgIC8vIGNhcHR1cmVkIGVsc2V3aGVyZSwgdG8gcHJldmVudCB0aGUgdW5tb3VudCBmcm9tIGJlaW5nIGludGVycnVwdGVkLlxuICAgIGlzV29ya2luZyA9IHRydWU7XG4gICAgaXNDb21taXR0aW5nID0gdHJ1ZTtcbiAgICBzdGFydENvbW1pdFRpbWVyKCk7XG5cbiAgICB2YXIgcm9vdCA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG4gICAgIShyb290LmN1cnJlbnQgIT09IGZpbmlzaGVkV29yaykgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW5ub3QgY29tbWl0IHRoZSBzYW1lIHRyZWUgYXMgYmVmb3JlLiBUaGlzIGlzIHByb2JhYmx5IGEgYnVnIHJlbGF0ZWQgdG8gdGhlIHJldHVybiBmaWVsZC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcbiAgICByb290LmlzUmVhZHlGb3JDb21taXQgPSBmYWxzZTtcblxuICAgIC8vIFJlc2V0IHRoaXMgdG8gbnVsbCBiZWZvcmUgY2FsbGluZyBsaWZlY3ljbGVzXG4gICAgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCA9IG51bGw7XG5cbiAgICB2YXIgZmlyc3RFZmZlY3QgPSB2b2lkIDA7XG4gICAgaWYgKGZpbmlzaGVkV29yay5lZmZlY3RUYWcgPiBQZXJmb3JtZWRXb3JrKSB7XG4gICAgICAvLyBBIGZpYmVyJ3MgZWZmZWN0IGxpc3QgY29uc2lzdHMgb25seSBvZiBpdHMgY2hpbGRyZW4sIG5vdCBpdHNlbGYuIFNvIGlmXG4gICAgICAvLyB0aGUgcm9vdCBoYXMgYW4gZWZmZWN0LCB3ZSBuZWVkIHRvIGFkZCBpdCB0byB0aGUgZW5kIG9mIHRoZSBsaXN0LiBUaGVcbiAgICAgIC8vIHJlc3VsdGluZyBsaXN0IGlzIHRoZSBzZXQgdGhhdCB3b3VsZCBiZWxvbmcgdG8gdGhlIHJvb3QncyBwYXJlbnQsIGlmXG4gICAgICAvLyBpdCBoYWQgb25lOyB0aGF0IGlzLCBhbGwgdGhlIGVmZmVjdHMgaW4gdGhlIHRyZWUgaW5jbHVkaW5nIHRoZSByb290LlxuICAgICAgaWYgKGZpbmlzaGVkV29yay5sYXN0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgICAgIGZpbmlzaGVkV29yay5sYXN0RWZmZWN0Lm5leHRFZmZlY3QgPSBmaW5pc2hlZFdvcms7XG4gICAgICAgIGZpcnN0RWZmZWN0ID0gZmluaXNoZWRXb3JrLmZpcnN0RWZmZWN0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZmlyc3RFZmZlY3QgPSBmaW5pc2hlZFdvcms7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoZXJlIGlzIG5vIGVmZmVjdCBvbiB0aGUgcm9vdC5cbiAgICAgIGZpcnN0RWZmZWN0ID0gZmluaXNoZWRXb3JrLmZpcnN0RWZmZWN0O1xuICAgIH1cblxuICAgIHByZXBhcmVGb3JDb21taXQoKTtcblxuICAgIC8vIENvbW1pdCBhbGwgdGhlIHNpZGUtZWZmZWN0cyB3aXRoaW4gYSB0cmVlLiBXZSdsbCBkbyB0aGlzIGluIHR3byBwYXNzZXMuXG4gICAgLy8gVGhlIGZpcnN0IHBhc3MgcGVyZm9ybXMgYWxsIHRoZSBob3N0IGluc2VydGlvbnMsIHVwZGF0ZXMsIGRlbGV0aW9ucyBhbmRcbiAgICAvLyByZWYgdW5tb3VudHMuXG4gICAgbmV4dEVmZmVjdCA9IGZpcnN0RWZmZWN0O1xuICAgIHN0YXJ0Q29tbWl0SG9zdEVmZmVjdHNUaW1lcigpO1xuICAgIHdoaWxlIChuZXh0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgICB2YXIgZGlkRXJyb3IgPSBmYWxzZTtcbiAgICAgIHZhciBfZXJyb3IgPSB2b2lkIDA7XG4gICAgICB7XG4gICAgICAgIGludm9rZUd1YXJkZWRDYWxsYmFjayhudWxsLCBjb21taXRBbGxIb3N0RWZmZWN0cywgbnVsbCk7XG4gICAgICAgIGlmIChoYXNDYXVnaHRFcnJvcigpKSB7XG4gICAgICAgICAgZGlkRXJyb3IgPSB0cnVlO1xuICAgICAgICAgIF9lcnJvciA9IGNsZWFyQ2F1Z2h0RXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGRpZEVycm9yKSB7XG4gICAgICAgICEobmV4dEVmZmVjdCAhPT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdTaG91bGQgaGF2ZSBuZXh0IGVmZmVjdC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcbiAgICAgICAgY2FwdHVyZUVycm9yKG5leHRFZmZlY3QsIF9lcnJvcik7XG4gICAgICAgIC8vIENsZWFuLXVwXG4gICAgICAgIGlmIChuZXh0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgICAgICAgbmV4dEVmZmVjdCA9IG5leHRFZmZlY3QubmV4dEVmZmVjdDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBzdG9wQ29tbWl0SG9zdEVmZmVjdHNUaW1lcigpO1xuXG4gICAgcmVzZXRBZnRlckNvbW1pdCgpO1xuXG4gICAgLy8gVGhlIHdvcmstaW4tcHJvZ3Jlc3MgdHJlZSBpcyBub3cgdGhlIGN1cnJlbnQgdHJlZS4gVGhpcyBtdXN0IGNvbWUgYWZ0ZXJcbiAgICAvLyB0aGUgZmlyc3QgcGFzcyBvZiB0aGUgY29tbWl0IHBoYXNlLCBzbyB0aGF0IHRoZSBwcmV2aW91cyB0cmVlIGlzIHN0aWxsXG4gICAgLy8gY3VycmVudCBkdXJpbmcgY29tcG9uZW50V2lsbFVubW91bnQsIGJ1dCBiZWZvcmUgdGhlIHNlY29uZCBwYXNzLCBzbyB0aGF0XG4gICAgLy8gdGhlIGZpbmlzaGVkIHdvcmsgaXMgY3VycmVudCBkdXJpbmcgY29tcG9uZW50RGlkTW91bnQvVXBkYXRlLlxuICAgIHJvb3QuY3VycmVudCA9IGZpbmlzaGVkV29yaztcblxuICAgIC8vIEluIHRoZSBzZWNvbmQgcGFzcyB3ZSdsbCBwZXJmb3JtIGFsbCBsaWZlLWN5Y2xlcyBhbmQgcmVmIGNhbGxiYWNrcy5cbiAgICAvLyBMaWZlLWN5Y2xlcyBoYXBwZW4gYXMgYSBzZXBhcmF0ZSBwYXNzIHNvIHRoYXQgYWxsIHBsYWNlbWVudHMsIHVwZGF0ZXMsXG4gICAgLy8gYW5kIGRlbGV0aW9ucyBpbiB0aGUgZW50aXJlIHRyZWUgaGF2ZSBhbHJlYWR5IGJlZW4gaW52b2tlZC5cbiAgICAvLyBUaGlzIHBhc3MgYWxzbyB0cmlnZ2VycyBhbnkgcmVuZGVyZXItc3BlY2lmaWMgaW5pdGlhbCBlZmZlY3RzLlxuICAgIG5leHRFZmZlY3QgPSBmaXJzdEVmZmVjdDtcbiAgICBzdGFydENvbW1pdExpZmVDeWNsZXNUaW1lcigpO1xuICAgIHdoaWxlIChuZXh0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgICB2YXIgX2RpZEVycm9yID0gZmFsc2U7XG4gICAgICB2YXIgX2Vycm9yMiA9IHZvaWQgMDtcbiAgICAgIHtcbiAgICAgICAgaW52b2tlR3VhcmRlZENhbGxiYWNrKG51bGwsIGNvbW1pdEFsbExpZmVDeWNsZXMsIG51bGwpO1xuICAgICAgICBpZiAoaGFzQ2F1Z2h0RXJyb3IoKSkge1xuICAgICAgICAgIF9kaWRFcnJvciA9IHRydWU7XG4gICAgICAgICAgX2Vycm9yMiA9IGNsZWFyQ2F1Z2h0RXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKF9kaWRFcnJvcikge1xuICAgICAgICAhKG5leHRFZmZlY3QgIT09IG51bGwpID8gaW52YXJpYW50KGZhbHNlLCAnU2hvdWxkIGhhdmUgbmV4dCBlZmZlY3QuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gICAgICAgIGNhcHR1cmVFcnJvcihuZXh0RWZmZWN0LCBfZXJyb3IyKTtcbiAgICAgICAgaWYgKG5leHRFZmZlY3QgIT09IG51bGwpIHtcbiAgICAgICAgICBuZXh0RWZmZWN0ID0gbmV4dEVmZmVjdC5uZXh0RWZmZWN0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaXNDb21taXR0aW5nID0gZmFsc2U7XG4gICAgaXNXb3JraW5nID0gZmFsc2U7XG4gICAgc3RvcENvbW1pdExpZmVDeWNsZXNUaW1lcigpO1xuICAgIHN0b3BDb21taXRUaW1lcigpO1xuICAgIGlmICh0eXBlb2Ygb25Db21taXRSb290ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBvbkNvbW1pdFJvb3QoZmluaXNoZWRXb3JrLnN0YXRlTm9kZSk7XG4gICAgfVxuICAgIGlmICh0cnVlICYmIFJlYWN0RmliZXJJbnN0cnVtZW50YXRpb25fMS5kZWJ1Z1Rvb2wpIHtcbiAgICAgIFJlYWN0RmliZXJJbnN0cnVtZW50YXRpb25fMS5kZWJ1Z1Rvb2wub25Db21taXRXb3JrKGZpbmlzaGVkV29yayk7XG4gICAgfVxuXG4gICAgLy8gSWYgd2UgY2F1Z2h0IGFueSBlcnJvcnMgZHVyaW5nIHRoaXMgY29tbWl0LCBzY2hlZHVsZSB0aGVpciBib3VuZGFyaWVzXG4gICAgLy8gdG8gdXBkYXRlLlxuICAgIGlmIChjb21taXRQaGFzZUJvdW5kYXJpZXMpIHtcbiAgICAgIGNvbW1pdFBoYXNlQm91bmRhcmllcy5mb3JFYWNoKHNjaGVkdWxlRXJyb3JSZWNvdmVyeSk7XG4gICAgICBjb21taXRQaGFzZUJvdW5kYXJpZXMgPSBudWxsO1xuICAgIH1cblxuICAgIGlmIChmaXJzdFVuY2F1Z2h0RXJyb3IgIT09IG51bGwpIHtcbiAgICAgIHZhciBfZXJyb3IzID0gZmlyc3RVbmNhdWdodEVycm9yO1xuICAgICAgZmlyc3RVbmNhdWdodEVycm9yID0gbnVsbDtcbiAgICAgIG9uVW5jYXVnaHRFcnJvcihfZXJyb3IzKTtcbiAgICB9XG5cbiAgICB2YXIgcmVtYWluaW5nVGltZSA9IHJvb3QuY3VycmVudC5leHBpcmF0aW9uVGltZTtcblxuICAgIGlmIChyZW1haW5pbmdUaW1lID09PSBOb1dvcmspIHtcbiAgICAgIGNhcHR1cmVkRXJyb3JzID0gbnVsbDtcbiAgICAgIGZhaWxlZEJvdW5kYXJpZXMgPSBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiByZW1haW5pbmdUaW1lO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVzZXRFeHBpcmF0aW9uVGltZSh3b3JrSW5Qcm9ncmVzcywgcmVuZGVyVGltZSkge1xuICAgIGlmIChyZW5kZXJUaW1lICE9PSBOZXZlciAmJiB3b3JrSW5Qcm9ncmVzcy5leHBpcmF0aW9uVGltZSA9PT0gTmV2ZXIpIHtcbiAgICAgIC8vIFRoZSBjaGlsZHJlbiBvZiB0aGlzIGNvbXBvbmVudCBhcmUgaGlkZGVuLiBEb24ndCBidWJibGUgdGhlaXJcbiAgICAgIC8vIGV4cGlyYXRpb24gdGltZXMuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgZm9yIHBlbmRpbmcgdXBkYXRlcy5cbiAgICB2YXIgbmV3RXhwaXJhdGlvblRpbWUgPSBnZXRVcGRhdGVFeHBpcmF0aW9uVGltZSh3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgICAvLyBUT0RPOiBDYWxscyBuZWVkIHRvIHZpc2l0IHN0YXRlTm9kZVxuXG4gICAgLy8gQnViYmxlIHVwIHRoZSBlYXJsaWVzdCBleHBpcmF0aW9uIHRpbWUuXG4gICAgdmFyIGNoaWxkID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gICAgd2hpbGUgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgICBpZiAoY2hpbGQuZXhwaXJhdGlvblRpbWUgIT09IE5vV29yayAmJiAobmV3RXhwaXJhdGlvblRpbWUgPT09IE5vV29yayB8fCBuZXdFeHBpcmF0aW9uVGltZSA+IGNoaWxkLmV4cGlyYXRpb25UaW1lKSkge1xuICAgICAgICBuZXdFeHBpcmF0aW9uVGltZSA9IGNoaWxkLmV4cGlyYXRpb25UaW1lO1xuICAgICAgfVxuICAgICAgY2hpbGQgPSBjaGlsZC5zaWJsaW5nO1xuICAgIH1cbiAgICB3b3JrSW5Qcm9ncmVzcy5leHBpcmF0aW9uVGltZSA9IG5ld0V4cGlyYXRpb25UaW1lO1xuICB9XG5cbiAgZnVuY3Rpb24gY29tcGxldGVVbml0T2ZXb3JrKHdvcmtJblByb2dyZXNzKSB7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIC8vIFRoZSBjdXJyZW50LCBmbHVzaGVkLCBzdGF0ZSBvZiB0aGlzIGZpYmVyIGlzIHRoZSBhbHRlcm5hdGUuXG4gICAgICAvLyBJZGVhbGx5IG5vdGhpbmcgc2hvdWxkIHJlbHkgb24gdGhpcywgYnV0IHJlbHlpbmcgb24gaXQgaGVyZVxuICAgICAgLy8gbWVhbnMgdGhhdCB3ZSBkb24ndCBuZWVkIGFuIGFkZGl0aW9uYWwgZmllbGQgb24gdGhlIHdvcmsgaW5cbiAgICAgIC8vIHByb2dyZXNzLlxuICAgICAgdmFyIGN1cnJlbnQgPSB3b3JrSW5Qcm9ncmVzcy5hbHRlcm5hdGU7XG4gICAgICB7XG4gICAgICAgIFJlYWN0RGVidWdDdXJyZW50RmliZXIuc2V0Q3VycmVudEZpYmVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgIH1cbiAgICAgIHZhciBuZXh0ID0gY29tcGxldGVXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0UmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgICAge1xuICAgICAgICBSZWFjdERlYnVnQ3VycmVudEZpYmVyLnJlc2V0Q3VycmVudEZpYmVyKCk7XG4gICAgICB9XG5cbiAgICAgIHZhciByZXR1cm5GaWJlciA9IHdvcmtJblByb2dyZXNzWydyZXR1cm4nXTtcbiAgICAgIHZhciBzaWJsaW5nRmliZXIgPSB3b3JrSW5Qcm9ncmVzcy5zaWJsaW5nO1xuXG4gICAgICByZXNldEV4cGlyYXRpb25UaW1lKHdvcmtJblByb2dyZXNzLCBuZXh0UmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuXG4gICAgICBpZiAobmV4dCAhPT0gbnVsbCkge1xuICAgICAgICBzdG9wV29ya1RpbWVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgaWYgKHRydWUgJiYgUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbl8xLmRlYnVnVG9vbCkge1xuICAgICAgICAgIFJlYWN0RmliZXJJbnN0cnVtZW50YXRpb25fMS5kZWJ1Z1Rvb2wub25Db21wbGV0ZVdvcmsod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIGNvbXBsZXRpbmcgdGhpcyB3b3JrIHNwYXduZWQgbmV3IHdvcmssIGRvIHRoYXQgbmV4dC4gV2UnbGwgY29tZVxuICAgICAgICAvLyBiYWNrIGhlcmUgYWdhaW4uXG4gICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgfVxuXG4gICAgICBpZiAocmV0dXJuRmliZXIgIT09IG51bGwpIHtcbiAgICAgICAgLy8gQXBwZW5kIGFsbCB0aGUgZWZmZWN0cyBvZiB0aGUgc3VidHJlZSBhbmQgdGhpcyBmaWJlciBvbnRvIHRoZSBlZmZlY3RcbiAgICAgICAgLy8gbGlzdCBvZiB0aGUgcGFyZW50LiBUaGUgY29tcGxldGlvbiBvcmRlciBvZiB0aGUgY2hpbGRyZW4gYWZmZWN0cyB0aGVcbiAgICAgICAgLy8gc2lkZS1lZmZlY3Qgb3JkZXIuXG4gICAgICAgIGlmIChyZXR1cm5GaWJlci5maXJzdEVmZmVjdCA9PT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybkZpYmVyLmZpcnN0RWZmZWN0ID0gd29ya0luUHJvZ3Jlc3MuZmlyc3RFZmZlY3Q7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHdvcmtJblByb2dyZXNzLmxhc3RFZmZlY3QgIT09IG51bGwpIHtcbiAgICAgICAgICBpZiAocmV0dXJuRmliZXIubGFzdEVmZmVjdCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuRmliZXIubGFzdEVmZmVjdC5uZXh0RWZmZWN0ID0gd29ya0luUHJvZ3Jlc3MuZmlyc3RFZmZlY3Q7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybkZpYmVyLmxhc3RFZmZlY3QgPSB3b3JrSW5Qcm9ncmVzcy5sYXN0RWZmZWN0O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgdGhpcyBmaWJlciBoYWQgc2lkZS1lZmZlY3RzLCB3ZSBhcHBlbmQgaXQgQUZURVIgdGhlIGNoaWxkcmVuJ3NcbiAgICAgICAgLy8gc2lkZS1lZmZlY3RzLiBXZSBjYW4gcGVyZm9ybSBjZXJ0YWluIHNpZGUtZWZmZWN0cyBlYXJsaWVyIGlmXG4gICAgICAgIC8vIG5lZWRlZCwgYnkgZG9pbmcgbXVsdGlwbGUgcGFzc2VzIG92ZXIgdGhlIGVmZmVjdCBsaXN0LiBXZSBkb24ndCB3YW50XG4gICAgICAgIC8vIHRvIHNjaGVkdWxlIG91ciBvd24gc2lkZS1lZmZlY3Qgb24gb3VyIG93biBsaXN0IGJlY2F1c2UgaWYgZW5kIHVwXG4gICAgICAgIC8vIHJldXNpbmcgY2hpbGRyZW4gd2UnbGwgc2NoZWR1bGUgdGhpcyBlZmZlY3Qgb250byBpdHNlbGYgc2luY2Ugd2UncmVcbiAgICAgICAgLy8gYXQgdGhlIGVuZC5cbiAgICAgICAgdmFyIGVmZmVjdFRhZyA9IHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZztcbiAgICAgICAgLy8gU2tpcCBib3RoIE5vV29yayBhbmQgUGVyZm9ybWVkV29yayB0YWdzIHdoZW4gY3JlYXRpbmcgdGhlIGVmZmVjdCBsaXN0LlxuICAgICAgICAvLyBQZXJmb3JtZWRXb3JrIGVmZmVjdCBpcyByZWFkIGJ5IFJlYWN0IERldlRvb2xzIGJ1dCBzaG91bGRuJ3QgYmUgY29tbWl0dGVkLlxuICAgICAgICBpZiAoZWZmZWN0VGFnID4gUGVyZm9ybWVkV29yaykge1xuICAgICAgICAgIGlmIChyZXR1cm5GaWJlci5sYXN0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm5GaWJlci5sYXN0RWZmZWN0Lm5leHRFZmZlY3QgPSB3b3JrSW5Qcm9ncmVzcztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuRmliZXIuZmlyc3RFZmZlY3QgPSB3b3JrSW5Qcm9ncmVzcztcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuRmliZXIubGFzdEVmZmVjdCA9IHdvcmtJblByb2dyZXNzO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHN0b3BXb3JrVGltZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgaWYgKHRydWUgJiYgUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbl8xLmRlYnVnVG9vbCkge1xuICAgICAgICBSZWFjdEZpYmVySW5zdHJ1bWVudGF0aW9uXzEuZGVidWdUb29sLm9uQ29tcGxldGVXb3JrKHdvcmtJblByb2dyZXNzKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNpYmxpbmdGaWJlciAhPT0gbnVsbCkge1xuICAgICAgICAvLyBJZiB0aGVyZSBpcyBtb3JlIHdvcmsgdG8gZG8gaW4gdGhpcyByZXR1cm5GaWJlciwgZG8gdGhhdCBuZXh0LlxuICAgICAgICByZXR1cm4gc2libGluZ0ZpYmVyO1xuICAgICAgfSBlbHNlIGlmIChyZXR1cm5GaWJlciAhPT0gbnVsbCkge1xuICAgICAgICAvLyBJZiB0aGVyZSdzIG5vIG1vcmUgd29yayBpbiB0aGlzIHJldHVybkZpYmVyLiBDb21wbGV0ZSB0aGUgcmV0dXJuRmliZXIuXG4gICAgICAgIHdvcmtJblByb2dyZXNzID0gcmV0dXJuRmliZXI7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gV2UndmUgcmVhY2hlZCB0aGUgcm9vdC5cbiAgICAgICAgdmFyIHJvb3QgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICAgICAgIHJvb3QuaXNSZWFkeUZvckNvbW1pdCA9IHRydWU7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFdpdGhvdXQgdGhpcyBleHBsaWNpdCBudWxsIHJldHVybiBGbG93IGNvbXBsYWlucyBvZiBpbnZhbGlkIHJldHVybiB0eXBlXG4gICAgLy8gVE9ETyBSZW1vdmUgdGhlIGFib3ZlIHdoaWxlKHRydWUpIGxvb3BcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5yZWFjaGFibGVcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlcmZvcm1Vbml0T2ZXb3JrKHdvcmtJblByb2dyZXNzKSB7XG4gICAgLy8gVGhlIGN1cnJlbnQsIGZsdXNoZWQsIHN0YXRlIG9mIHRoaXMgZmliZXIgaXMgdGhlIGFsdGVybmF0ZS5cbiAgICAvLyBJZGVhbGx5IG5vdGhpbmcgc2hvdWxkIHJlbHkgb24gdGhpcywgYnV0IHJlbHlpbmcgb24gaXQgaGVyZVxuICAgIC8vIG1lYW5zIHRoYXQgd2UgZG9uJ3QgbmVlZCBhbiBhZGRpdGlvbmFsIGZpZWxkIG9uIHRoZSB3b3JrIGluXG4gICAgLy8gcHJvZ3Jlc3MuXG4gICAgdmFyIGN1cnJlbnQgPSB3b3JrSW5Qcm9ncmVzcy5hbHRlcm5hdGU7XG5cbiAgICAvLyBTZWUgaWYgYmVnaW5uaW5nIHRoaXMgd29yayBzcGF3bnMgbW9yZSB3b3JrLlxuICAgIHN0YXJ0V29ya1RpbWVyKHdvcmtJblByb2dyZXNzKTtcbiAgICB7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZpYmVyLnNldEN1cnJlbnRGaWJlcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgfVxuXG4gICAgdmFyIG5leHQgPSBiZWdpbldvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRSZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAge1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5yZXNldEN1cnJlbnRGaWJlcigpO1xuICAgIH1cbiAgICBpZiAodHJ1ZSAmJiBSZWFjdEZpYmVySW5zdHJ1bWVudGF0aW9uXzEuZGVidWdUb29sKSB7XG4gICAgICBSZWFjdEZpYmVySW5zdHJ1bWVudGF0aW9uXzEuZGVidWdUb29sLm9uQmVnaW5Xb3JrKHdvcmtJblByb2dyZXNzKTtcbiAgICB9XG5cbiAgICBpZiAobmV4dCA9PT0gbnVsbCkge1xuICAgICAgLy8gSWYgdGhpcyBkb2Vzbid0IHNwYXduIG5ldyB3b3JrLCBjb21wbGV0ZSB0aGUgY3VycmVudCB3b3JrLlxuICAgICAgbmV4dCA9IGNvbXBsZXRlVW5pdE9mV29yayh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgfVxuXG4gICAgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCA9IG51bGw7XG5cbiAgICByZXR1cm4gbmV4dDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlcmZvcm1GYWlsZWRVbml0T2ZXb3JrKHdvcmtJblByb2dyZXNzKSB7XG4gICAgLy8gVGhlIGN1cnJlbnQsIGZsdXNoZWQsIHN0YXRlIG9mIHRoaXMgZmliZXIgaXMgdGhlIGFsdGVybmF0ZS5cbiAgICAvLyBJZGVhbGx5IG5vdGhpbmcgc2hvdWxkIHJlbHkgb24gdGhpcywgYnV0IHJlbHlpbmcgb24gaXQgaGVyZVxuICAgIC8vIG1lYW5zIHRoYXQgd2UgZG9uJ3QgbmVlZCBhbiBhZGRpdGlvbmFsIGZpZWxkIG9uIHRoZSB3b3JrIGluXG4gICAgLy8gcHJvZ3Jlc3MuXG4gICAgdmFyIGN1cnJlbnQgPSB3b3JrSW5Qcm9ncmVzcy5hbHRlcm5hdGU7XG5cbiAgICAvLyBTZWUgaWYgYmVnaW5uaW5nIHRoaXMgd29yayBzcGF3bnMgbW9yZSB3b3JrLlxuICAgIHN0YXJ0V29ya1RpbWVyKHdvcmtJblByb2dyZXNzKTtcbiAgICB7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZpYmVyLnNldEN1cnJlbnRGaWJlcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgfVxuICAgIHZhciBuZXh0ID0gYmVnaW5GYWlsZWRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0UmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgIHtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RmliZXIucmVzZXRDdXJyZW50RmliZXIoKTtcbiAgICB9XG4gICAgaWYgKHRydWUgJiYgUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbl8xLmRlYnVnVG9vbCkge1xuICAgICAgUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbl8xLmRlYnVnVG9vbC5vbkJlZ2luV29yayh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgfVxuXG4gICAgaWYgKG5leHQgPT09IG51bGwpIHtcbiAgICAgIC8vIElmIHRoaXMgZG9lc24ndCBzcGF3biBuZXcgd29yaywgY29tcGxldGUgdGhlIGN1cnJlbnQgd29yay5cbiAgICAgIG5leHQgPSBjb21wbGV0ZVVuaXRPZldvcmsod29ya0luUHJvZ3Jlc3MpO1xuICAgIH1cblxuICAgIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgPSBudWxsO1xuXG4gICAgcmV0dXJuIG5leHQ7XG4gIH1cblxuICBmdW5jdGlvbiB3b3JrTG9vcChleHBpcmF0aW9uVGltZSkge1xuICAgIGlmIChjYXB0dXJlZEVycm9ycyAhPT0gbnVsbCkge1xuICAgICAgLy8gSWYgdGhlcmUgYXJlIHVuaGFuZGxlZCBlcnJvcnMsIHN3aXRjaCB0byB0aGUgc2xvdyB3b3JrIGxvb3AuXG4gICAgICAvLyBUT0RPOiBIb3cgdG8gYXZvaWQgdGhpcyBjaGVjayBpbiB0aGUgZmFzdCBwYXRoPyBNYXliZSB0aGUgcmVuZGVyZXJcbiAgICAgIC8vIGNvdWxkIGtlZXAgdHJhY2sgb2Ygd2hpY2ggcm9vdHMgaGF2ZSB1bmhhbmRsZWQgZXJyb3JzIGFuZCBjYWxsIGFcbiAgICAgIC8vIGZvcmtlZCB2ZXJzaW9uIG9mIHJlbmRlclJvb3QuXG4gICAgICBzbG93V29ya0xvb3BUaGF0Q2hlY2tzRm9yRmFpbGVkV29yayhleHBpcmF0aW9uVGltZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChuZXh0UmVuZGVyRXhwaXJhdGlvblRpbWUgPT09IE5vV29yayB8fCBuZXh0UmVuZGVyRXhwaXJhdGlvblRpbWUgPiBleHBpcmF0aW9uVGltZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChuZXh0UmVuZGVyRXhwaXJhdGlvblRpbWUgPD0gbW9zdFJlY2VudEN1cnJlbnRUaW1lKSB7XG4gICAgICAvLyBGbHVzaCBhbGwgZXhwaXJlZCB3b3JrLlxuICAgICAgd2hpbGUgKG5leHRVbml0T2ZXb3JrICE9PSBudWxsKSB7XG4gICAgICAgIG5leHRVbml0T2ZXb3JrID0gcGVyZm9ybVVuaXRPZldvcmsobmV4dFVuaXRPZldvcmspO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBGbHVzaCBhc3luY2hyb25vdXMgd29yayB1bnRpbCB0aGUgZGVhZGxpbmUgcnVucyBvdXQgb2YgdGltZS5cbiAgICAgIHdoaWxlIChuZXh0VW5pdE9mV29yayAhPT0gbnVsbCAmJiAhc2hvdWxkWWllbGQoKSkge1xuICAgICAgICBuZXh0VW5pdE9mV29yayA9IHBlcmZvcm1Vbml0T2ZXb3JrKG5leHRVbml0T2ZXb3JrKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzbG93V29ya0xvb3BUaGF0Q2hlY2tzRm9yRmFpbGVkV29yayhleHBpcmF0aW9uVGltZSkge1xuICAgIGlmIChuZXh0UmVuZGVyRXhwaXJhdGlvblRpbWUgPT09IE5vV29yayB8fCBuZXh0UmVuZGVyRXhwaXJhdGlvblRpbWUgPiBleHBpcmF0aW9uVGltZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChuZXh0UmVuZGVyRXhwaXJhdGlvblRpbWUgPD0gbW9zdFJlY2VudEN1cnJlbnRUaW1lKSB7XG4gICAgICAvLyBGbHVzaCBhbGwgZXhwaXJlZCB3b3JrLlxuICAgICAgd2hpbGUgKG5leHRVbml0T2ZXb3JrICE9PSBudWxsKSB7XG4gICAgICAgIGlmIChoYXNDYXB0dXJlZEVycm9yKG5leHRVbml0T2ZXb3JrKSkge1xuICAgICAgICAgIC8vIFVzZSBhIGZvcmtlZCB2ZXJzaW9uIG9mIHBlcmZvcm1Vbml0T2ZXb3JrXG4gICAgICAgICAgbmV4dFVuaXRPZldvcmsgPSBwZXJmb3JtRmFpbGVkVW5pdE9mV29yayhuZXh0VW5pdE9mV29yayk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV4dFVuaXRPZldvcmsgPSBwZXJmb3JtVW5pdE9mV29yayhuZXh0VW5pdE9mV29yayk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRmx1c2ggYXN5bmNocm9ub3VzIHdvcmsgdW50aWwgdGhlIGRlYWRsaW5lIHJ1bnMgb3V0IG9mIHRpbWUuXG4gICAgICB3aGlsZSAobmV4dFVuaXRPZldvcmsgIT09IG51bGwgJiYgIXNob3VsZFlpZWxkKCkpIHtcbiAgICAgICAgaWYgKGhhc0NhcHR1cmVkRXJyb3IobmV4dFVuaXRPZldvcmspKSB7XG4gICAgICAgICAgLy8gVXNlIGEgZm9ya2VkIHZlcnNpb24gb2YgcGVyZm9ybVVuaXRPZldvcmtcbiAgICAgICAgICBuZXh0VW5pdE9mV29yayA9IHBlcmZvcm1GYWlsZWRVbml0T2ZXb3JrKG5leHRVbml0T2ZXb3JrKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXh0VW5pdE9mV29yayA9IHBlcmZvcm1Vbml0T2ZXb3JrKG5leHRVbml0T2ZXb3JrKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbmRlclJvb3RDYXRjaEJsb2NrKHJvb3QsIGZhaWxlZFdvcmssIGJvdW5kYXJ5LCBleHBpcmF0aW9uVGltZSkge1xuICAgIC8vIFdlJ3JlIGdvaW5nIHRvIHJlc3RhcnQgdGhlIGVycm9yIGJvdW5kYXJ5IHRoYXQgY2FwdHVyZWQgdGhlIGVycm9yLlxuICAgIC8vIENvbmNlcHR1YWxseSwgd2UncmUgdW53aW5kaW5nIHRoZSBzdGFjay4gV2UgbmVlZCB0byB1bndpbmQgdGhlXG4gICAgLy8gY29udGV4dCBzdGFjaywgdG9vLlxuICAgIHVud2luZENvbnRleHRzKGZhaWxlZFdvcmssIGJvdW5kYXJ5KTtcblxuICAgIC8vIFJlc3RhcnQgdGhlIGVycm9yIGJvdW5kYXJ5IHVzaW5nIGEgZm9ya2VkIHZlcnNpb24gb2ZcbiAgICAvLyBwZXJmb3JtVW5pdE9mV29yayB0aGF0IGRlbGV0ZXMgdGhlIGJvdW5kYXJ5J3MgY2hpbGRyZW4uIFRoZSBlbnRpcmVcbiAgICAvLyBmYWlsZWQgc3VicmVlIHdpbGwgYmUgdW5tb3VudGVkLiBEdXJpbmcgdGhlIGNvbW1pdCBwaGFzZSwgYSBzcGVjaWFsXG4gICAgLy8gbGlmZWN5Y2xlIG1ldGhvZCBpcyBjYWxsZWQgb24gdGhlIGVycm9yIGJvdW5kYXJ5LCB3aGljaCB0cmlnZ2Vyc1xuICAgIC8vIGEgcmUtcmVuZGVyLlxuICAgIG5leHRVbml0T2ZXb3JrID0gcGVyZm9ybUZhaWxlZFVuaXRPZldvcmsoYm91bmRhcnkpO1xuXG4gICAgLy8gQ29udGludWUgd29ya2luZy5cbiAgICB3b3JrTG9vcChleHBpcmF0aW9uVGltZSk7XG4gIH1cblxuICBmdW5jdGlvbiByZW5kZXJSb290KHJvb3QsIGV4cGlyYXRpb25UaW1lKSB7XG4gICAgISFpc1dvcmtpbmcgPyBpbnZhcmlhbnQoZmFsc2UsICdyZW5kZXJSb290IHdhcyBjYWxsZWQgcmVjdXJzaXZlbHkuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gICAgaXNXb3JraW5nID0gdHJ1ZTtcblxuICAgIC8vIFdlJ3JlIGFib3V0IHRvIG11dGF0ZSB0aGUgd29yay1pbi1wcm9ncmVzcyB0cmVlLiBJZiB0aGUgcm9vdCB3YXMgcGVuZGluZ1xuICAgIC8vIGNvbW1pdCwgaXQgbm8gbG9uZ2VyIGlzOiB3ZSdsbCBuZWVkIHRvIGNvbXBsZXRlIGl0IGFnYWluLlxuICAgIHJvb3QuaXNSZWFkeUZvckNvbW1pdCA9IGZhbHNlO1xuXG4gICAgLy8gQ2hlY2sgaWYgd2UncmUgc3RhcnRpbmcgZnJvbSBhIGZyZXNoIHN0YWNrLCBvciBpZiB3ZSdyZSByZXN1bWluZyBmcm9tXG4gICAgLy8gcHJldmlvdXNseSB5aWVsZGVkIHdvcmsuXG4gICAgaWYgKHJvb3QgIT09IG5leHRSb290IHx8IGV4cGlyYXRpb25UaW1lICE9PSBuZXh0UmVuZGVyRXhwaXJhdGlvblRpbWUgfHwgbmV4dFVuaXRPZldvcmsgPT09IG51bGwpIHtcbiAgICAgIC8vIFJlc2V0IHRoZSBzdGFjayBhbmQgc3RhcnQgd29ya2luZyBmcm9tIHRoZSByb290LlxuICAgICAgcmVzZXRDb250ZXh0U3RhY2soKTtcbiAgICAgIG5leHRSb290ID0gcm9vdDtcbiAgICAgIG5leHRSZW5kZXJFeHBpcmF0aW9uVGltZSA9IGV4cGlyYXRpb25UaW1lO1xuICAgICAgbmV4dFVuaXRPZldvcmsgPSBjcmVhdGVXb3JrSW5Qcm9ncmVzcyhuZXh0Um9vdC5jdXJyZW50LCBudWxsLCBleHBpcmF0aW9uVGltZSk7XG4gICAgfVxuXG4gICAgc3RhcnRXb3JrTG9vcFRpbWVyKG5leHRVbml0T2ZXb3JrKTtcblxuICAgIHZhciBkaWRFcnJvciA9IGZhbHNlO1xuICAgIHZhciBlcnJvciA9IG51bGw7XG4gICAge1xuICAgICAgaW52b2tlR3VhcmRlZENhbGxiYWNrKG51bGwsIHdvcmtMb29wLCBudWxsLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICBpZiAoaGFzQ2F1Z2h0RXJyb3IoKSkge1xuICAgICAgICBkaWRFcnJvciA9IHRydWU7XG4gICAgICAgIGVycm9yID0gY2xlYXJDYXVnaHRFcnJvcigpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEFuIGVycm9yIHdhcyB0aHJvd24gZHVyaW5nIHRoZSByZW5kZXIgcGhhc2UuXG4gICAgd2hpbGUgKGRpZEVycm9yKSB7XG4gICAgICBpZiAoZGlkRmF0YWwpIHtcbiAgICAgICAgLy8gVGhpcyB3YXMgYSBmYXRhbCBlcnJvci4gRG9uJ3QgYXR0ZW1wdCB0byByZWNvdmVyIGZyb20gaXQuXG4gICAgICAgIGZpcnN0VW5jYXVnaHRFcnJvciA9IGVycm9yO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgdmFyIGZhaWxlZFdvcmsgPSBuZXh0VW5pdE9mV29yaztcbiAgICAgIGlmIChmYWlsZWRXb3JrID09PSBudWxsKSB7XG4gICAgICAgIC8vIEFuIGVycm9yIHdhcyB0aHJvd24gYnV0IHRoZXJlJ3Mgbm8gY3VycmVudCB1bml0IG9mIHdvcmsuIFRoaXMgY2FuXG4gICAgICAgIC8vIGhhcHBlbiBkdXJpbmcgdGhlIGNvbW1pdCBwaGFzZSBpZiB0aGVyZSdzIGEgYnVnIGluIHRoZSByZW5kZXJlci5cbiAgICAgICAgZGlkRmF0YWwgPSB0cnVlO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gXCJDYXB0dXJlXCIgdGhlIGVycm9yIGJ5IGZpbmRpbmcgdGhlIG5lYXJlc3QgYm91bmRhcnkuIElmIHRoZXJlIGlzIG5vXG4gICAgICAvLyBlcnJvciBib3VuZGFyeSwgd2UgdXNlIHRoZSByb290LlxuICAgICAgdmFyIGJvdW5kYXJ5ID0gY2FwdHVyZUVycm9yKGZhaWxlZFdvcmssIGVycm9yKTtcbiAgICAgICEoYm91bmRhcnkgIT09IG51bGwpID8gaW52YXJpYW50KGZhbHNlLCAnU2hvdWxkIGhhdmUgZm91bmQgYW4gZXJyb3IgYm91bmRhcnkuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG5cbiAgICAgIGlmIChkaWRGYXRhbCkge1xuICAgICAgICAvLyBUaGUgZXJyb3Igd2UganVzdCBjYXB0dXJlZCB3YXMgYSBmYXRhbCBlcnJvci4gVGhpcyBoYXBwZW5zXG4gICAgICAgIC8vIHdoZW4gdGhlIGVycm9yIHByb3BhZ2F0ZXMgdG8gdGhlIHJvb3QgbW9yZSB0aGFuIG9uY2UuXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBkaWRFcnJvciA9IGZhbHNlO1xuICAgICAgZXJyb3IgPSBudWxsO1xuICAgICAge1xuICAgICAgICBpbnZva2VHdWFyZGVkQ2FsbGJhY2sobnVsbCwgcmVuZGVyUm9vdENhdGNoQmxvY2ssIG51bGwsIHJvb3QsIGZhaWxlZFdvcmssIGJvdW5kYXJ5LCBleHBpcmF0aW9uVGltZSk7XG4gICAgICAgIGlmIChoYXNDYXVnaHRFcnJvcigpKSB7XG4gICAgICAgICAgZGlkRXJyb3IgPSB0cnVlO1xuICAgICAgICAgIGVycm9yID0gY2xlYXJDYXVnaHRFcnJvcigpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBXZSdyZSBmaW5pc2hlZCB3b3JraW5nLiBFeGl0IHRoZSBlcnJvciBsb29wLlxuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgdmFyIHVuY2F1Z2h0RXJyb3IgPSBmaXJzdFVuY2F1Z2h0RXJyb3I7XG5cbiAgICAvLyBXZSdyZSBkb25lIHBlcmZvcm1pbmcgd29yay4gVGltZSB0byBjbGVhbiB1cC5cbiAgICBzdG9wV29ya0xvb3BUaW1lcihpbnRlcnJ1cHRlZEJ5KTtcbiAgICBpbnRlcnJ1cHRlZEJ5ID0gbnVsbDtcbiAgICBpc1dvcmtpbmcgPSBmYWxzZTtcbiAgICBkaWRGYXRhbCA9IGZhbHNlO1xuICAgIGZpcnN0VW5jYXVnaHRFcnJvciA9IG51bGw7XG5cbiAgICBpZiAodW5jYXVnaHRFcnJvciAhPT0gbnVsbCkge1xuICAgICAgb25VbmNhdWdodEVycm9yKHVuY2F1Z2h0RXJyb3IpO1xuICAgIH1cblxuICAgIHJldHVybiByb290LmlzUmVhZHlGb3JDb21taXQgPyByb290LmN1cnJlbnQuYWx0ZXJuYXRlIDogbnVsbDtcbiAgfVxuXG4gIC8vIFJldHVybnMgdGhlIGJvdW5kYXJ5IHRoYXQgY2FwdHVyZWQgdGhlIGVycm9yLCBvciBudWxsIGlmIHRoZSBlcnJvciBpcyBpZ25vcmVkXG4gIGZ1bmN0aW9uIGNhcHR1cmVFcnJvcihmYWlsZWRXb3JrLCBlcnJvcikge1xuICAgIC8vIEl0IGlzIG5vIGxvbmdlciB2YWxpZCBiZWNhdXNlIHdlIGV4aXRlZCB0aGUgdXNlciBjb2RlLlxuICAgIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgPSBudWxsO1xuICAgIHtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RmliZXIucmVzZXRDdXJyZW50RmliZXIoKTtcbiAgICB9XG5cbiAgICAvLyBTZWFyY2ggZm9yIHRoZSBuZWFyZXN0IGVycm9yIGJvdW5kYXJ5LlxuICAgIHZhciBib3VuZGFyeSA9IG51bGw7XG5cbiAgICAvLyBQYXNzZWQgdG8gbG9nQ2FwdHVyZWRFcnJvcigpXG4gICAgdmFyIGVycm9yQm91bmRhcnlGb3VuZCA9IGZhbHNlO1xuICAgIHZhciB3aWxsUmV0cnkgPSBmYWxzZTtcbiAgICB2YXIgZXJyb3JCb3VuZGFyeU5hbWUgPSBudWxsO1xuXG4gICAgLy8gSG9zdCBjb250YWluZXJzIGFyZSBhIHNwZWNpYWwgY2FzZS4gSWYgdGhlIGZhaWxlZCB3b3JrIGl0c2VsZiBpcyBhIGhvc3RcbiAgICAvLyBjb250YWluZXIsIHRoZW4gaXQgYWN0cyBhcyBpdHMgb3duIGJvdW5kYXJ5LiBJbiBhbGwgb3RoZXIgY2FzZXMsIHdlXG4gICAgLy8gaWdub3JlIHRoZSB3b3JrIGl0c2VsZiBhbmQgb25seSBzZWFyY2ggdGhyb3VnaCB0aGUgcGFyZW50cy5cbiAgICBpZiAoZmFpbGVkV29yay50YWcgPT09IEhvc3RSb290KSB7XG4gICAgICBib3VuZGFyeSA9IGZhaWxlZFdvcms7XG5cbiAgICAgIGlmIChpc0ZhaWxlZEJvdW5kYXJ5KGZhaWxlZFdvcmspKSB7XG4gICAgICAgIC8vIElmIHRoaXMgcm9vdCBhbHJlYWR5IGZhaWxlZCwgdGhlcmUgbXVzdCBoYXZlIGJlZW4gYW4gZXJyb3Igd2hlblxuICAgICAgICAvLyBhdHRlbXB0aW5nIHRvIHVubW91bnQgaXQuIFRoaXMgaXMgYSB3b3JzdC1jYXNlIHNjZW5hcmlvIGFuZFxuICAgICAgICAvLyBzaG91bGQgb25seSBiZSBwb3NzaWJsZSBpZiB0aGVyZSdzIGEgYnVnIGluIHRoZSByZW5kZXJlci5cbiAgICAgICAgZGlkRmF0YWwgPSB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbm9kZSA9IGZhaWxlZFdvcmtbJ3JldHVybiddO1xuICAgICAgd2hpbGUgKG5vZGUgIT09IG51bGwgJiYgYm91bmRhcnkgPT09IG51bGwpIHtcbiAgICAgICAgaWYgKG5vZGUudGFnID09PSBDbGFzc0NvbXBvbmVudCkge1xuICAgICAgICAgIHZhciBpbnN0YW5jZSA9IG5vZGUuc3RhdGVOb2RlO1xuICAgICAgICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkQ2F0Y2ggPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGVycm9yQm91bmRhcnlGb3VuZCA9IHRydWU7XG4gICAgICAgICAgICBlcnJvckJvdW5kYXJ5TmFtZSA9IGdldENvbXBvbmVudE5hbWUobm9kZSk7XG5cbiAgICAgICAgICAgIC8vIEZvdW5kIGFuIGVycm9yIGJvdW5kYXJ5IVxuICAgICAgICAgICAgYm91bmRhcnkgPSBub2RlO1xuICAgICAgICAgICAgd2lsbFJldHJ5ID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAobm9kZS50YWcgPT09IEhvc3RSb290KSB7XG4gICAgICAgICAgLy8gVHJlYXQgdGhlIHJvb3QgbGlrZSBhIG5vLW9wIGVycm9yIGJvdW5kYXJ5XG4gICAgICAgICAgYm91bmRhcnkgPSBub2RlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzRmFpbGVkQm91bmRhcnkobm9kZSkpIHtcbiAgICAgICAgICAvLyBUaGlzIGJvdW5kYXJ5IGlzIGFscmVhZHkgaW4gYSBmYWlsZWQgc3RhdGUuXG5cbiAgICAgICAgICAvLyBJZiB3ZSdyZSBjdXJyZW50bHkgdW5tb3VudGluZywgdGhhdCBtZWFucyB0aGlzIGVycm9yIHdhc1xuICAgICAgICAgIC8vIHRocm93biB3aGlsZSB1bm1vdW50aW5nIGEgZmFpbGVkIHN1YnRyZWUuIFdlIHNob3VsZCBpZ25vcmVcbiAgICAgICAgICAvLyB0aGUgZXJyb3IuXG4gICAgICAgICAgaWYgKGlzVW5tb3VudGluZykge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gSWYgd2UncmUgaW4gdGhlIGNvbW1pdCBwaGFzZSwgd2Ugc2hvdWxkIGNoZWNrIHRvIHNlZSBpZlxuICAgICAgICAgIC8vIHRoaXMgYm91bmRhcnkgYWxyZWFkeSBjYXB0dXJlZCBhbiBlcnJvciBkdXJpbmcgdGhpcyBjb21taXQuXG4gICAgICAgICAgLy8gVGhpcyBjYXNlIGV4aXN0cyBiZWNhdXNlIG11bHRpcGxlIGVycm9ycyBjYW4gYmUgdGhyb3duIGR1cmluZ1xuICAgICAgICAgIC8vIGEgc2luZ2xlIGNvbW1pdCB3aXRob3V0IGludGVycnVwdGlvbi5cbiAgICAgICAgICBpZiAoY29tbWl0UGhhc2VCb3VuZGFyaWVzICE9PSBudWxsICYmIChjb21taXRQaGFzZUJvdW5kYXJpZXMuaGFzKG5vZGUpIHx8IG5vZGUuYWx0ZXJuYXRlICE9PSBudWxsICYmIGNvbW1pdFBoYXNlQm91bmRhcmllcy5oYXMobm9kZS5hbHRlcm5hdGUpKSkge1xuICAgICAgICAgICAgLy8gSWYgc28sIHdlIHNob3VsZCBpZ25vcmUgdGhpcyBlcnJvci5cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFRoZSBlcnJvciBzaG91bGQgcHJvcGFnYXRlIHRvIHRoZSBuZXh0IGJvdW5kYXJ5IC3igJQgd2Uga2VlcCBsb29raW5nLlxuICAgICAgICAgIGJvdW5kYXJ5ID0gbnVsbDtcbiAgICAgICAgICB3aWxsUmV0cnkgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIG5vZGUgPSBub2RlWydyZXR1cm4nXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoYm91bmRhcnkgIT09IG51bGwpIHtcbiAgICAgIC8vIEFkZCB0byB0aGUgY29sbGVjdGlvbiBvZiBmYWlsZWQgYm91bmRhcmllcy4gVGhpcyBsZXRzIHVzIGtub3cgdGhhdFxuICAgICAgLy8gc3Vic2VxdWVudCBlcnJvcnMgaW4gdGhpcyBzdWJ0cmVlIHNob3VsZCBwcm9wYWdhdGUgdG8gdGhlIG5leHQgYm91bmRhcnkuXG4gICAgICBpZiAoZmFpbGVkQm91bmRhcmllcyA9PT0gbnVsbCkge1xuICAgICAgICBmYWlsZWRCb3VuZGFyaWVzID0gbmV3IFNldCgpO1xuICAgICAgfVxuICAgICAgZmFpbGVkQm91bmRhcmllcy5hZGQoYm91bmRhcnkpO1xuXG4gICAgICAvLyBUaGlzIG1ldGhvZCBpcyB1bnNhZmUgb3V0c2lkZSBvZiB0aGUgYmVnaW4gYW5kIGNvbXBsZXRlIHBoYXNlcy5cbiAgICAgIC8vIFdlIG1pZ2h0IGJlIGluIHRoZSBjb21taXQgcGhhc2Ugd2hlbiBhbiBlcnJvciBpcyBjYXB0dXJlZC5cbiAgICAgIC8vIFRoZSByaXNrIGlzIHRoYXQgdGhlIHJldHVybiBwYXRoIGZyb20gdGhpcyBGaWJlciBtYXkgbm90IGJlIGFjY3VyYXRlLlxuICAgICAgLy8gVGhhdCByaXNrIGlzIGFjY2VwdGFibGUgZ2l2ZW4gdGhlIGJlbmVmaXQgb2YgcHJvdmlkaW5nIHVzZXJzIG1vcmUgY29udGV4dC5cbiAgICAgIHZhciBfY29tcG9uZW50U3RhY2sgPSBnZXRTdGFja0FkZGVuZHVtQnlXb3JrSW5Qcm9ncmVzc0ZpYmVyKGZhaWxlZFdvcmspO1xuICAgICAgdmFyIF9jb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZShmYWlsZWRXb3JrKTtcblxuICAgICAgLy8gQWRkIHRvIHRoZSBjb2xsZWN0aW9uIG9mIGNhcHR1cmVkIGVycm9ycy4gVGhpcyBpcyBzdG9yZWQgYXMgYSBnbG9iYWxcbiAgICAgIC8vIG1hcCBvZiBlcnJvcnMgYW5kIHRoZWlyIGNvbXBvbmVudCBzdGFjayBsb2NhdGlvbiBrZXllZCBieSB0aGUgYm91bmRhcmllc1xuICAgICAgLy8gdGhhdCBjYXB0dXJlIHRoZW0uIFdlIG1vc3RseSB1c2UgdGhpcyBNYXAgYXMgYSBTZXQ7IGl0J3MgYSBNYXAgb25seSB0b1xuICAgICAgLy8gYXZvaWQgYWRkaW5nIGEgZmllbGQgdG8gRmliZXIgdG8gc3RvcmUgdGhlIGVycm9yLlxuICAgICAgaWYgKGNhcHR1cmVkRXJyb3JzID09PSBudWxsKSB7XG4gICAgICAgIGNhcHR1cmVkRXJyb3JzID0gbmV3IE1hcCgpO1xuICAgICAgfVxuXG4gICAgICB2YXIgY2FwdHVyZWRFcnJvciA9IHtcbiAgICAgICAgY29tcG9uZW50TmFtZTogX2NvbXBvbmVudE5hbWUsXG4gICAgICAgIGNvbXBvbmVudFN0YWNrOiBfY29tcG9uZW50U3RhY2ssXG4gICAgICAgIGVycm9yOiBlcnJvcixcbiAgICAgICAgZXJyb3JCb3VuZGFyeTogZXJyb3JCb3VuZGFyeUZvdW5kID8gYm91bmRhcnkuc3RhdGVOb2RlIDogbnVsbCxcbiAgICAgICAgZXJyb3JCb3VuZGFyeUZvdW5kOiBlcnJvckJvdW5kYXJ5Rm91bmQsXG4gICAgICAgIGVycm9yQm91bmRhcnlOYW1lOiBlcnJvckJvdW5kYXJ5TmFtZSxcbiAgICAgICAgd2lsbFJldHJ5OiB3aWxsUmV0cnlcbiAgICAgIH07XG5cbiAgICAgIGNhcHR1cmVkRXJyb3JzLnNldChib3VuZGFyeSwgY2FwdHVyZWRFcnJvcik7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGxvZ0NhcHR1cmVkRXJyb3IoY2FwdHVyZWRFcnJvcik7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8vIFByZXZlbnQgY3ljbGUgaWYgbG9nQ2FwdHVyZWRFcnJvcigpIHRocm93cy5cbiAgICAgICAgLy8gQSBjeWNsZSBtYXkgc3RpbGwgb2NjdXIgaWYgbG9nQ2FwdHVyZWRFcnJvciByZW5kZXJzIGEgY29tcG9uZW50IHRoYXQgdGhyb3dzLlxuICAgICAgICB2YXIgc3VwcHJlc3NMb2dnaW5nID0gZSAmJiBlLnN1cHByZXNzUmVhY3RFcnJvckxvZ2dpbmc7XG4gICAgICAgIGlmICghc3VwcHJlc3NMb2dnaW5nKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBJZiB3ZSdyZSBpbiB0aGUgY29tbWl0IHBoYXNlLCBkZWZlciBzY2hlZHVsaW5nIGFuIHVwZGF0ZSBvbiB0aGVcbiAgICAgIC8vIGJvdW5kYXJ5IHVudGlsIGFmdGVyIHRoZSBjb21taXQgaXMgY29tcGxldGVcbiAgICAgIGlmIChpc0NvbW1pdHRpbmcpIHtcbiAgICAgICAgaWYgKGNvbW1pdFBoYXNlQm91bmRhcmllcyA9PT0gbnVsbCkge1xuICAgICAgICAgIGNvbW1pdFBoYXNlQm91bmRhcmllcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgfVxuICAgICAgICBjb21taXRQaGFzZUJvdW5kYXJpZXMuYWRkKGJvdW5kYXJ5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE90aGVyd2lzZSwgc2NoZWR1bGUgYW4gdXBkYXRlIG5vdy5cbiAgICAgICAgLy8gVE9ETzogSXMgdGhpcyBhY3R1YWxseSBuZWNlc3NhcnkgZHVyaW5nIHRoZSByZW5kZXIgcGhhc2U/IElzIGl0XG4gICAgICAgIC8vIHBvc3NpYmxlIHRvIHVud2luZCBhbmQgY29udGludWUgcmVuZGVyaW5nIGF0IHRoZSBzYW1lIHByaW9yaXR5LFxuICAgICAgICAvLyB3aXRob3V0IGNvcnJ1cHRpbmcgaW50ZXJuYWwgc3RhdGU/XG4gICAgICAgIHNjaGVkdWxlRXJyb3JSZWNvdmVyeShib3VuZGFyeSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYm91bmRhcnk7XG4gICAgfSBlbHNlIGlmIChmaXJzdFVuY2F1Z2h0RXJyb3IgPT09IG51bGwpIHtcbiAgICAgIC8vIElmIG5vIGJvdW5kYXJ5IGlzIGZvdW5kLCB3ZSdsbCBuZWVkIHRvIHRocm93IHRoZSBlcnJvclxuICAgICAgZmlyc3RVbmNhdWdodEVycm9yID0gZXJyb3I7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFzQ2FwdHVyZWRFcnJvcihmaWJlcikge1xuICAgIC8vIFRPRE86IGNhcHR1cmVkRXJyb3JzIHNob3VsZCBzdG9yZSB0aGUgYm91bmRhcnkgaW5zdGFuY2UsIHRvIGF2b2lkIG5lZWRpbmdcbiAgICAvLyB0byBjaGVjayB0aGUgYWx0ZXJuYXRlLlxuICAgIHJldHVybiBjYXB0dXJlZEVycm9ycyAhPT0gbnVsbCAmJiAoY2FwdHVyZWRFcnJvcnMuaGFzKGZpYmVyKSB8fCBmaWJlci5hbHRlcm5hdGUgIT09IG51bGwgJiYgY2FwdHVyZWRFcnJvcnMuaGFzKGZpYmVyLmFsdGVybmF0ZSkpO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNGYWlsZWRCb3VuZGFyeShmaWJlcikge1xuICAgIC8vIFRPRE86IGZhaWxlZEJvdW5kYXJpZXMgc2hvdWxkIHN0b3JlIHRoZSBib3VuZGFyeSBpbnN0YW5jZSwgdG8gYXZvaWRcbiAgICAvLyBuZWVkaW5nIHRvIGNoZWNrIHRoZSBhbHRlcm5hdGUuXG4gICAgcmV0dXJuIGZhaWxlZEJvdW5kYXJpZXMgIT09IG51bGwgJiYgKGZhaWxlZEJvdW5kYXJpZXMuaGFzKGZpYmVyKSB8fCBmaWJlci5hbHRlcm5hdGUgIT09IG51bGwgJiYgZmFpbGVkQm91bmRhcmllcy5oYXMoZmliZXIuYWx0ZXJuYXRlKSk7XG4gIH1cblxuICBmdW5jdGlvbiBjb21taXRFcnJvckhhbmRsaW5nKGVmZmVjdGZ1bEZpYmVyKSB7XG4gICAgdmFyIGNhcHR1cmVkRXJyb3IgPSB2b2lkIDA7XG4gICAgaWYgKGNhcHR1cmVkRXJyb3JzICE9PSBudWxsKSB7XG4gICAgICBjYXB0dXJlZEVycm9yID0gY2FwdHVyZWRFcnJvcnMuZ2V0KGVmZmVjdGZ1bEZpYmVyKTtcbiAgICAgIGNhcHR1cmVkRXJyb3JzWydkZWxldGUnXShlZmZlY3RmdWxGaWJlcik7XG4gICAgICBpZiAoY2FwdHVyZWRFcnJvciA9PSBudWxsKSB7XG4gICAgICAgIGlmIChlZmZlY3RmdWxGaWJlci5hbHRlcm5hdGUgIT09IG51bGwpIHtcbiAgICAgICAgICBlZmZlY3RmdWxGaWJlciA9IGVmZmVjdGZ1bEZpYmVyLmFsdGVybmF0ZTtcbiAgICAgICAgICBjYXB0dXJlZEVycm9yID0gY2FwdHVyZWRFcnJvcnMuZ2V0KGVmZmVjdGZ1bEZpYmVyKTtcbiAgICAgICAgICBjYXB0dXJlZEVycm9yc1snZGVsZXRlJ10oZWZmZWN0ZnVsRmliZXIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgIShjYXB0dXJlZEVycm9yICE9IG51bGwpID8gaW52YXJpYW50KGZhbHNlLCAnTm8gZXJyb3IgZm9yIGdpdmVuIHVuaXQgb2Ygd29yay4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcblxuICAgIHN3aXRjaCAoZWZmZWN0ZnVsRmliZXIudGFnKSB7XG4gICAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAgICB2YXIgaW5zdGFuY2UgPSBlZmZlY3RmdWxGaWJlci5zdGF0ZU5vZGU7XG5cbiAgICAgICAgdmFyIGluZm8gPSB7XG4gICAgICAgICAgY29tcG9uZW50U3RhY2s6IGNhcHR1cmVkRXJyb3IuY29tcG9uZW50U3RhY2tcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBBbGxvdyB0aGUgYm91bmRhcnkgdG8gaGFuZGxlIHRoZSBlcnJvciwgdXN1YWxseSBieSBzY2hlZHVsaW5nXG4gICAgICAgIC8vIGFuIHVwZGF0ZSB0byBpdHNlbGZcbiAgICAgICAgaW5zdGFuY2UuY29tcG9uZW50RGlkQ2F0Y2goY2FwdHVyZWRFcnJvci5lcnJvciwgaW5mbyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgIGlmIChmaXJzdFVuY2F1Z2h0RXJyb3IgPT09IG51bGwpIHtcbiAgICAgICAgICBmaXJzdFVuY2F1Z2h0RXJyb3IgPSBjYXB0dXJlZEVycm9yLmVycm9yO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGludmFyaWFudChmYWxzZSwgJ0ludmFsaWQgdHlwZSBvZiB3b3JrLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHVud2luZENvbnRleHRzKGZyb20sIHRvKSB7XG4gICAgdmFyIG5vZGUgPSBmcm9tO1xuICAgIHdoaWxlIChub2RlICE9PSBudWxsKSB7XG4gICAgICBzd2l0Y2ggKG5vZGUudGFnKSB7XG4gICAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICAgICAgcG9wQ29udGV4dFByb3ZpZGVyKG5vZGUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgICAgcG9wSG9zdENvbnRleHQobm9kZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgICAgcG9wSG9zdENvbnRhaW5lcihub2RlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBIb3N0UG9ydGFsOlxuICAgICAgICAgIHBvcEhvc3RDb250YWluZXIobm9kZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAobm9kZSA9PT0gdG8gfHwgbm9kZS5hbHRlcm5hdGUgPT09IHRvKSB7XG4gICAgICAgIHN0b3BGYWlsZWRXb3JrVGltZXIobm9kZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RvcFdvcmtUaW1lcihub2RlKTtcbiAgICAgIH1cbiAgICAgIG5vZGUgPSBub2RlWydyZXR1cm4nXTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjb21wdXRlQXN5bmNFeHBpcmF0aW9uKCkge1xuICAgIC8vIEdpdmVuIHRoZSBjdXJyZW50IGNsb2NrIHRpbWUsIHJldHVybnMgYW4gZXhwaXJhdGlvbiB0aW1lLiBXZSB1c2Ugcm91bmRpbmdcbiAgICAvLyB0byBiYXRjaCBsaWtlIHVwZGF0ZXMgdG9nZXRoZXIuXG4gICAgLy8gU2hvdWxkIGNvbXBsZXRlIHdpdGhpbiB+MTAwMG1zLiAxMjAwbXMgbWF4LlxuICAgIHZhciBjdXJyZW50VGltZSA9IHJlY2FsY3VsYXRlQ3VycmVudFRpbWUoKTtcbiAgICB2YXIgZXhwaXJhdGlvbk1zID0gMTAwMDtcbiAgICB2YXIgYnVja2V0U2l6ZU1zID0gMjAwO1xuICAgIHJldHVybiBjb21wdXRlRXhwaXJhdGlvbkJ1Y2tldChjdXJyZW50VGltZSwgZXhwaXJhdGlvbk1zLCBidWNrZXRTaXplTXMpO1xuICB9XG5cbiAgZnVuY3Rpb24gY29tcHV0ZUV4cGlyYXRpb25Gb3JGaWJlcihmaWJlcikge1xuICAgIHZhciBleHBpcmF0aW9uVGltZSA9IHZvaWQgMDtcbiAgICBpZiAoZXhwaXJhdGlvbkNvbnRleHQgIT09IE5vV29yaykge1xuICAgICAgLy8gQW4gZXhwbGljaXQgZXhwaXJhdGlvbiBjb250ZXh0IHdhcyBzZXQ7XG4gICAgICBleHBpcmF0aW9uVGltZSA9IGV4cGlyYXRpb25Db250ZXh0O1xuICAgIH0gZWxzZSBpZiAoaXNXb3JraW5nKSB7XG4gICAgICBpZiAoaXNDb21taXR0aW5nKSB7XG4gICAgICAgIC8vIFVwZGF0ZXMgdGhhdCBvY2N1ciBkdXJpbmcgdGhlIGNvbW1pdCBwaGFzZSBzaG91bGQgaGF2ZSBzeW5jIHByaW9yaXR5XG4gICAgICAgIC8vIGJ5IGRlZmF1bHQuXG4gICAgICAgIGV4cGlyYXRpb25UaW1lID0gU3luYztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFVwZGF0ZXMgZHVyaW5nIHRoZSByZW5kZXIgcGhhc2Ugc2hvdWxkIGV4cGlyZSBhdCB0aGUgc2FtZSB0aW1lIGFzXG4gICAgICAgIC8vIHRoZSB3b3JrIHRoYXQgaXMgYmVpbmcgcmVuZGVyZWQuXG4gICAgICAgIGV4cGlyYXRpb25UaW1lID0gbmV4dFJlbmRlckV4cGlyYXRpb25UaW1lO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBObyBleHBsaWNpdCBleHBpcmF0aW9uIGNvbnRleHQgd2FzIHNldCwgYW5kIHdlJ3JlIG5vdCBjdXJyZW50bHlcbiAgICAgIC8vIHBlcmZvcm1pbmcgd29yay4gQ2FsY3VsYXRlIGEgbmV3IGV4cGlyYXRpb24gdGltZS5cbiAgICAgIGlmICh1c2VTeW5jU2NoZWR1bGluZyAmJiAhKGZpYmVyLmludGVybmFsQ29udGV4dFRhZyAmIEFzeW5jVXBkYXRlcykpIHtcbiAgICAgICAgLy8gVGhpcyBpcyBhIHN5bmMgdXBkYXRlXG4gICAgICAgIGV4cGlyYXRpb25UaW1lID0gU3luYztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRoaXMgaXMgYW4gYXN5bmMgdXBkYXRlXG4gICAgICAgIGV4cGlyYXRpb25UaW1lID0gY29tcHV0ZUFzeW5jRXhwaXJhdGlvbigpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZXhwaXJhdGlvblRpbWU7XG4gIH1cblxuICBmdW5jdGlvbiBzY2hlZHVsZVdvcmsoZmliZXIsIGV4cGlyYXRpb25UaW1lKSB7XG4gICAgcmV0dXJuIHNjaGVkdWxlV29ya0ltcGwoZmliZXIsIGV4cGlyYXRpb25UaW1lLCBmYWxzZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjaGVja1Jvb3ROZWVkc0NsZWFyaW5nKHJvb3QsIGZpYmVyLCBleHBpcmF0aW9uVGltZSkge1xuICAgIGlmICghaXNXb3JraW5nICYmIHJvb3QgPT09IG5leHRSb290ICYmIGV4cGlyYXRpb25UaW1lIDwgbmV4dFJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gICAgICAvLyBSZXN0YXJ0IHRoZSByb290IGZyb20gdGhlIHRvcC5cbiAgICAgIGlmIChuZXh0VW5pdE9mV29yayAhPT0gbnVsbCkge1xuICAgICAgICAvLyBUaGlzIGlzIGFuIGludGVycnVwdGlvbi4gKFVzZWQgZm9yIHBlcmZvcm1hbmNlIHRyYWNraW5nLilcbiAgICAgICAgaW50ZXJydXB0ZWRCeSA9IGZpYmVyO1xuICAgICAgfVxuICAgICAgbmV4dFJvb3QgPSBudWxsO1xuICAgICAgbmV4dFVuaXRPZldvcmsgPSBudWxsO1xuICAgICAgbmV4dFJlbmRlckV4cGlyYXRpb25UaW1lID0gTm9Xb3JrO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNjaGVkdWxlV29ya0ltcGwoZmliZXIsIGV4cGlyYXRpb25UaW1lLCBpc0Vycm9yUmVjb3ZlcnkpIHtcbiAgICByZWNvcmRTY2hlZHVsZVVwZGF0ZSgpO1xuXG4gICAge1xuICAgICAgaWYgKCFpc0Vycm9yUmVjb3ZlcnkgJiYgZmliZXIudGFnID09PSBDbGFzc0NvbXBvbmVudCkge1xuICAgICAgICB2YXIgaW5zdGFuY2UgPSBmaWJlci5zdGF0ZU5vZGU7XG4gICAgICAgIHdhcm5BYm91dEludmFsaWRVcGRhdGVzKGluc3RhbmNlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgbm9kZSA9IGZpYmVyO1xuICAgIHdoaWxlIChub2RlICE9PSBudWxsKSB7XG4gICAgICAvLyBXYWxrIHRoZSBwYXJlbnQgcGF0aCB0byB0aGUgcm9vdCBhbmQgdXBkYXRlIGVhY2ggbm9kZSdzXG4gICAgICAvLyBleHBpcmF0aW9uIHRpbWUuXG4gICAgICBpZiAobm9kZS5leHBpcmF0aW9uVGltZSA9PT0gTm9Xb3JrIHx8IG5vZGUuZXhwaXJhdGlvblRpbWUgPiBleHBpcmF0aW9uVGltZSkge1xuICAgICAgICBub2RlLmV4cGlyYXRpb25UaW1lID0gZXhwaXJhdGlvblRpbWU7XG4gICAgICB9XG4gICAgICBpZiAobm9kZS5hbHRlcm5hdGUgIT09IG51bGwpIHtcbiAgICAgICAgaWYgKG5vZGUuYWx0ZXJuYXRlLmV4cGlyYXRpb25UaW1lID09PSBOb1dvcmsgfHwgbm9kZS5hbHRlcm5hdGUuZXhwaXJhdGlvblRpbWUgPiBleHBpcmF0aW9uVGltZSkge1xuICAgICAgICAgIG5vZGUuYWx0ZXJuYXRlLmV4cGlyYXRpb25UaW1lID0gZXhwaXJhdGlvblRpbWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChub2RlWydyZXR1cm4nXSA9PT0gbnVsbCkge1xuICAgICAgICBpZiAobm9kZS50YWcgPT09IEhvc3RSb290KSB7XG4gICAgICAgICAgdmFyIHJvb3QgPSBub2RlLnN0YXRlTm9kZTtcblxuICAgICAgICAgIGNoZWNrUm9vdE5lZWRzQ2xlYXJpbmcocm9vdCwgZmliZXIsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgICByZXF1ZXN0V29yayhyb290LCBleHBpcmF0aW9uVGltZSk7XG4gICAgICAgICAgY2hlY2tSb290TmVlZHNDbGVhcmluZyhyb290LCBmaWJlciwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmICghaXNFcnJvclJlY292ZXJ5ICYmIGZpYmVyLnRhZyA9PT0gQ2xhc3NDb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgd2FybkFib3V0VXBkYXRlT25Vbm1vdW50ZWQoZmliZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG5vZGUgPSBub2RlWydyZXR1cm4nXTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzY2hlZHVsZUVycm9yUmVjb3ZlcnkoZmliZXIpIHtcbiAgICBzY2hlZHVsZVdvcmtJbXBsKGZpYmVyLCBTeW5jLCB0cnVlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlY2FsY3VsYXRlQ3VycmVudFRpbWUoKSB7XG4gICAgLy8gU3VidHJhY3QgaW5pdGlhbCB0aW1lIHNvIGl0IGZpdHMgaW5zaWRlIDMyYml0c1xuICAgIHZhciBtcyA9IG5vdygpIC0gc3RhcnRUaW1lO1xuICAgIG1vc3RSZWNlbnRDdXJyZW50VGltZSA9IG1zVG9FeHBpcmF0aW9uVGltZShtcyk7XG4gICAgcmV0dXJuIG1vc3RSZWNlbnRDdXJyZW50VGltZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlZmVycmVkVXBkYXRlcyhmbikge1xuICAgIHZhciBwcmV2aW91c0V4cGlyYXRpb25Db250ZXh0ID0gZXhwaXJhdGlvbkNvbnRleHQ7XG4gICAgZXhwaXJhdGlvbkNvbnRleHQgPSBjb21wdXRlQXN5bmNFeHBpcmF0aW9uKCk7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBmbigpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBleHBpcmF0aW9uQ29udGV4dCA9IHByZXZpb3VzRXhwaXJhdGlvbkNvbnRleHQ7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc3luY1VwZGF0ZXMoZm4pIHtcbiAgICB2YXIgcHJldmlvdXNFeHBpcmF0aW9uQ29udGV4dCA9IGV4cGlyYXRpb25Db250ZXh0O1xuICAgIGV4cGlyYXRpb25Db250ZXh0ID0gU3luYztcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGZuKCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGV4cGlyYXRpb25Db250ZXh0ID0gcHJldmlvdXNFeHBpcmF0aW9uQ29udGV4dDtcbiAgICB9XG4gIH1cblxuICAvLyBUT0RPOiBFdmVyeXRoaW5nIGJlbG93IHRoaXMgaXMgd3JpdHRlbiBhcyBpZiBpdCBoYXMgYmVlbiBsaWZ0ZWQgdG8gdGhlXG4gIC8vIHJlbmRlcmVycy4gSSdsbCBkbyB0aGlzIGluIGEgZm9sbG93LXVwLlxuXG4gIC8vIExpbmtlZC1saXN0IG9mIHJvb3RzXG4gIHZhciBmaXJzdFNjaGVkdWxlZFJvb3QgPSBudWxsO1xuICB2YXIgbGFzdFNjaGVkdWxlZFJvb3QgPSBudWxsO1xuXG4gIHZhciBjYWxsYmFja0V4cGlyYXRpb25UaW1lID0gTm9Xb3JrO1xuICB2YXIgY2FsbGJhY2tJRCA9IC0xO1xuICB2YXIgaXNSZW5kZXJpbmcgPSBmYWxzZTtcbiAgdmFyIG5leHRGbHVzaGVkUm9vdCA9IG51bGw7XG4gIHZhciBuZXh0Rmx1c2hlZEV4cGlyYXRpb25UaW1lID0gTm9Xb3JrO1xuICB2YXIgZGVhZGxpbmVEaWRFeHBpcmUgPSBmYWxzZTtcbiAgdmFyIGhhc1VuaGFuZGxlZEVycm9yID0gZmFsc2U7XG4gIHZhciB1bmhhbmRsZWRFcnJvciA9IG51bGw7XG4gIHZhciBkZWFkbGluZSA9IG51bGw7XG5cbiAgdmFyIGlzQmF0Y2hpbmdVcGRhdGVzID0gZmFsc2U7XG4gIHZhciBpc1VuYmF0Y2hpbmdVcGRhdGVzID0gZmFsc2U7XG5cbiAgLy8gVXNlIHRoZXNlIHRvIHByZXZlbnQgYW4gaW5maW5pdGUgbG9vcCBvZiBuZXN0ZWQgdXBkYXRlc1xuICB2YXIgTkVTVEVEX1VQREFURV9MSU1JVCA9IDEwMDA7XG4gIHZhciBuZXN0ZWRVcGRhdGVDb3VudCA9IDA7XG5cbiAgdmFyIHRpbWVIZXVyaXN0aWNGb3JVbml0T2ZXb3JrID0gMTtcblxuICBmdW5jdGlvbiBzY2hlZHVsZUNhbGxiYWNrV2l0aEV4cGlyYXRpb24oZXhwaXJhdGlvblRpbWUpIHtcbiAgICBpZiAoY2FsbGJhY2tFeHBpcmF0aW9uVGltZSAhPT0gTm9Xb3JrKSB7XG4gICAgICAvLyBBIGNhbGxiYWNrIGlzIGFscmVhZHkgc2NoZWR1bGVkLiBDaGVjayBpdHMgZXhwaXJhdGlvbiB0aW1lICh0aW1lb3V0KS5cbiAgICAgIGlmIChleHBpcmF0aW9uVGltZSA+IGNhbGxiYWNrRXhwaXJhdGlvblRpbWUpIHtcbiAgICAgICAgLy8gRXhpc3RpbmcgY2FsbGJhY2sgaGFzIHN1ZmZpY2llbnQgdGltZW91dC4gRXhpdC5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRXhpc3RpbmcgY2FsbGJhY2sgaGFzIGluc3VmZmljaWVudCB0aW1lb3V0LiBDYW5jZWwgYW5kIHNjaGVkdWxlIGFcbiAgICAgICAgLy8gbmV3IG9uZS5cbiAgICAgICAgY2FuY2VsRGVmZXJyZWRDYWxsYmFjayhjYWxsYmFja0lEKTtcbiAgICAgIH1cbiAgICAgIC8vIFRoZSByZXF1ZXN0IGNhbGxiYWNrIHRpbWVyIGlzIGFscmVhZHkgcnVubmluZy4gRG9uJ3Qgc3RhcnQgYSBuZXcgb25lLlxuICAgIH0gZWxzZSB7XG4gICAgICBzdGFydFJlcXVlc3RDYWxsYmFja1RpbWVyKCk7XG4gICAgfVxuXG4gICAgLy8gQ29tcHV0ZSBhIHRpbWVvdXQgZm9yIHRoZSBnaXZlbiBleHBpcmF0aW9uIHRpbWUuXG4gICAgdmFyIGN1cnJlbnRNcyA9IG5vdygpIC0gc3RhcnRUaW1lO1xuICAgIHZhciBleHBpcmF0aW9uTXMgPSBleHBpcmF0aW9uVGltZVRvTXMoZXhwaXJhdGlvblRpbWUpO1xuICAgIHZhciB0aW1lb3V0ID0gZXhwaXJhdGlvbk1zIC0gY3VycmVudE1zO1xuXG4gICAgY2FsbGJhY2tFeHBpcmF0aW9uVGltZSA9IGV4cGlyYXRpb25UaW1lO1xuICAgIGNhbGxiYWNrSUQgPSBzY2hlZHVsZURlZmVycmVkQ2FsbGJhY2socGVyZm9ybUFzeW5jV29yaywgeyB0aW1lb3V0OiB0aW1lb3V0IH0pO1xuICB9XG5cbiAgLy8gcmVxdWVzdFdvcmsgaXMgY2FsbGVkIGJ5IHRoZSBzY2hlZHVsZXIgd2hlbmV2ZXIgYSByb290IHJlY2VpdmVzIGFuIHVwZGF0ZS5cbiAgLy8gSXQncyB1cCB0byB0aGUgcmVuZGVyZXIgdG8gY2FsbCByZW5kZXJSb290IGF0IHNvbWUgcG9pbnQgaW4gdGhlIGZ1dHVyZS5cbiAgZnVuY3Rpb24gcmVxdWVzdFdvcmsocm9vdCwgZXhwaXJhdGlvblRpbWUpIHtcbiAgICBpZiAobmVzdGVkVXBkYXRlQ291bnQgPiBORVNURURfVVBEQVRFX0xJTUlUKSB7XG4gICAgICBpbnZhcmlhbnQoZmFsc2UsICdNYXhpbXVtIHVwZGF0ZSBkZXB0aCBleGNlZWRlZC4gVGhpcyBjYW4gaGFwcGVuIHdoZW4gYSBjb21wb25lbnQgcmVwZWF0ZWRseSBjYWxscyBzZXRTdGF0ZSBpbnNpZGUgY29tcG9uZW50V2lsbFVwZGF0ZSBvciBjb21wb25lbnREaWRVcGRhdGUuIFJlYWN0IGxpbWl0cyB0aGUgbnVtYmVyIG9mIG5lc3RlZCB1cGRhdGVzIHRvIHByZXZlbnQgaW5maW5pdGUgbG9vcHMuJyk7XG4gICAgfVxuXG4gICAgLy8gQWRkIHRoZSByb290IHRvIHRoZSBzY2hlZHVsZS5cbiAgICAvLyBDaGVjayBpZiB0aGlzIHJvb3QgaXMgYWxyZWFkeSBwYXJ0IG9mIHRoZSBzY2hlZHVsZS5cbiAgICBpZiAocm9vdC5uZXh0U2NoZWR1bGVkUm9vdCA9PT0gbnVsbCkge1xuICAgICAgLy8gVGhpcyByb290IGlzIG5vdCBhbHJlYWR5IHNjaGVkdWxlZC4gQWRkIGl0LlxuICAgICAgcm9vdC5yZW1haW5pbmdFeHBpcmF0aW9uVGltZSA9IGV4cGlyYXRpb25UaW1lO1xuICAgICAgaWYgKGxhc3RTY2hlZHVsZWRSb290ID09PSBudWxsKSB7XG4gICAgICAgIGZpcnN0U2NoZWR1bGVkUm9vdCA9IGxhc3RTY2hlZHVsZWRSb290ID0gcm9vdDtcbiAgICAgICAgcm9vdC5uZXh0U2NoZWR1bGVkUm9vdCA9IHJvb3Q7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsYXN0U2NoZWR1bGVkUm9vdC5uZXh0U2NoZWR1bGVkUm9vdCA9IHJvb3Q7XG4gICAgICAgIGxhc3RTY2hlZHVsZWRSb290ID0gcm9vdDtcbiAgICAgICAgbGFzdFNjaGVkdWxlZFJvb3QubmV4dFNjaGVkdWxlZFJvb3QgPSBmaXJzdFNjaGVkdWxlZFJvb3Q7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoaXMgcm9vdCBpcyBhbHJlYWR5IHNjaGVkdWxlZCwgYnV0IGl0cyBwcmlvcml0eSBtYXkgaGF2ZSBpbmNyZWFzZWQuXG4gICAgICB2YXIgcmVtYWluaW5nRXhwaXJhdGlvblRpbWUgPSByb290LnJlbWFpbmluZ0V4cGlyYXRpb25UaW1lO1xuICAgICAgaWYgKHJlbWFpbmluZ0V4cGlyYXRpb25UaW1lID09PSBOb1dvcmsgfHwgZXhwaXJhdGlvblRpbWUgPCByZW1haW5pbmdFeHBpcmF0aW9uVGltZSkge1xuICAgICAgICAvLyBVcGRhdGUgdGhlIHByaW9yaXR5LlxuICAgICAgICByb290LnJlbWFpbmluZ0V4cGlyYXRpb25UaW1lID0gZXhwaXJhdGlvblRpbWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGlzUmVuZGVyaW5nKSB7XG4gICAgICAvLyBQcmV2ZW50IHJlZW50cmFuY3kuIFJlbWFpbmluZyB3b3JrIHdpbGwgYmUgc2NoZWR1bGVkIGF0IHRoZSBlbmQgb2ZcbiAgICAgIC8vIHRoZSBjdXJyZW50bHkgcmVuZGVyaW5nIGJhdGNoLlxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChpc0JhdGNoaW5nVXBkYXRlcykge1xuICAgICAgLy8gRmx1c2ggd29yayBhdCB0aGUgZW5kIG9mIHRoZSBiYXRjaC5cbiAgICAgIGlmIChpc1VuYmF0Y2hpbmdVcGRhdGVzKSB7XG4gICAgICAgIC8vIC4uLnVubGVzcyB3ZSdyZSBpbnNpZGUgdW5iYXRjaGVkVXBkYXRlcywgaW4gd2hpY2ggY2FzZSB3ZSBzaG91bGRcbiAgICAgICAgLy8gZmx1c2ggaXQgbm93LlxuICAgICAgICBuZXh0Rmx1c2hlZFJvb3QgPSByb290O1xuICAgICAgICBuZXh0Rmx1c2hlZEV4cGlyYXRpb25UaW1lID0gU3luYztcbiAgICAgICAgcGVyZm9ybVdvcmtPblJvb3QobmV4dEZsdXNoZWRSb290LCBuZXh0Rmx1c2hlZEV4cGlyYXRpb25UaW1lKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBUT0RPOiBHZXQgcmlkIG9mIFN5bmMgYW5kIHVzZSBjdXJyZW50IHRpbWU/XG4gICAgaWYgKGV4cGlyYXRpb25UaW1lID09PSBTeW5jKSB7XG4gICAgICBwZXJmb3JtV29yayhTeW5jLCBudWxsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2NoZWR1bGVDYWxsYmFja1dpdGhFeHBpcmF0aW9uKGV4cGlyYXRpb25UaW1lKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBmaW5kSGlnaGVzdFByaW9yaXR5Um9vdCgpIHtcbiAgICB2YXIgaGlnaGVzdFByaW9yaXR5V29yayA9IE5vV29yaztcbiAgICB2YXIgaGlnaGVzdFByaW9yaXR5Um9vdCA9IG51bGw7XG5cbiAgICBpZiAobGFzdFNjaGVkdWxlZFJvb3QgIT09IG51bGwpIHtcbiAgICAgIHZhciBwcmV2aW91c1NjaGVkdWxlZFJvb3QgPSBsYXN0U2NoZWR1bGVkUm9vdDtcbiAgICAgIHZhciByb290ID0gZmlyc3RTY2hlZHVsZWRSb290O1xuICAgICAgd2hpbGUgKHJvb3QgIT09IG51bGwpIHtcbiAgICAgICAgdmFyIHJlbWFpbmluZ0V4cGlyYXRpb25UaW1lID0gcm9vdC5yZW1haW5pbmdFeHBpcmF0aW9uVGltZTtcbiAgICAgICAgaWYgKHJlbWFpbmluZ0V4cGlyYXRpb25UaW1lID09PSBOb1dvcmspIHtcbiAgICAgICAgICAvLyBUaGlzIHJvb3Qgbm8gbG9uZ2VyIGhhcyB3b3JrLiBSZW1vdmUgaXQgZnJvbSB0aGUgc2NoZWR1bGVyLlxuXG4gICAgICAgICAgLy8gVE9ETzogVGhpcyBjaGVjayBpcyByZWR1ZGFudCwgYnV0IEZsb3cgaXMgY29uZnVzZWQgYnkgdGhlIGJyYW5jaFxuICAgICAgICAgIC8vIGJlbG93IHdoZXJlIHdlIHNldCBsYXN0U2NoZWR1bGVkUm9vdCB0byBudWxsLCBldmVuIHRob3VnaCB3ZSBicmVha1xuICAgICAgICAgIC8vIGZyb20gdGhlIGxvb3AgcmlnaHQgYWZ0ZXIuXG4gICAgICAgICAgIShwcmV2aW91c1NjaGVkdWxlZFJvb3QgIT09IG51bGwgJiYgbGFzdFNjaGVkdWxlZFJvb3QgIT09IG51bGwpID8gaW52YXJpYW50KGZhbHNlLCAnU2hvdWxkIGhhdmUgYSBwcmV2aW91cyBhbmQgbGFzdCByb290LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuICAgICAgICAgIGlmIChyb290ID09PSByb290Lm5leHRTY2hlZHVsZWRSb290KSB7XG4gICAgICAgICAgICAvLyBUaGlzIGlzIHRoZSBvbmx5IHJvb3QgaW4gdGhlIGxpc3QuXG4gICAgICAgICAgICByb290Lm5leHRTY2hlZHVsZWRSb290ID0gbnVsbDtcbiAgICAgICAgICAgIGZpcnN0U2NoZWR1bGVkUm9vdCA9IGxhc3RTY2hlZHVsZWRSb290ID0gbnVsbDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH0gZWxzZSBpZiAocm9vdCA9PT0gZmlyc3RTY2hlZHVsZWRSb290KSB7XG4gICAgICAgICAgICAvLyBUaGlzIGlzIHRoZSBmaXJzdCByb290IGluIHRoZSBsaXN0LlxuICAgICAgICAgICAgdmFyIG5leHQgPSByb290Lm5leHRTY2hlZHVsZWRSb290O1xuICAgICAgICAgICAgZmlyc3RTY2hlZHVsZWRSb290ID0gbmV4dDtcbiAgICAgICAgICAgIGxhc3RTY2hlZHVsZWRSb290Lm5leHRTY2hlZHVsZWRSb290ID0gbmV4dDtcbiAgICAgICAgICAgIHJvb3QubmV4dFNjaGVkdWxlZFJvb3QgPSBudWxsO1xuICAgICAgICAgIH0gZWxzZSBpZiAocm9vdCA9PT0gbGFzdFNjaGVkdWxlZFJvb3QpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgdGhlIGxhc3Qgcm9vdCBpbiB0aGUgbGlzdC5cbiAgICAgICAgICAgIGxhc3RTY2hlZHVsZWRSb290ID0gcHJldmlvdXNTY2hlZHVsZWRSb290O1xuICAgICAgICAgICAgbGFzdFNjaGVkdWxlZFJvb3QubmV4dFNjaGVkdWxlZFJvb3QgPSBmaXJzdFNjaGVkdWxlZFJvb3Q7XG4gICAgICAgICAgICByb290Lm5leHRTY2hlZHVsZWRSb290ID0gbnVsbDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwcmV2aW91c1NjaGVkdWxlZFJvb3QubmV4dFNjaGVkdWxlZFJvb3QgPSByb290Lm5leHRTY2hlZHVsZWRSb290O1xuICAgICAgICAgICAgcm9vdC5uZXh0U2NoZWR1bGVkUm9vdCA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJvb3QgPSBwcmV2aW91c1NjaGVkdWxlZFJvb3QubmV4dFNjaGVkdWxlZFJvb3Q7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGhpZ2hlc3RQcmlvcml0eVdvcmsgPT09IE5vV29yayB8fCByZW1haW5pbmdFeHBpcmF0aW9uVGltZSA8IGhpZ2hlc3RQcmlvcml0eVdvcmspIHtcbiAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgcHJpb3JpdHksIGlmIGl0J3MgaGlnaGVyXG4gICAgICAgICAgICBoaWdoZXN0UHJpb3JpdHlXb3JrID0gcmVtYWluaW5nRXhwaXJhdGlvblRpbWU7XG4gICAgICAgICAgICBoaWdoZXN0UHJpb3JpdHlSb290ID0gcm9vdDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHJvb3QgPT09IGxhc3RTY2hlZHVsZWRSb290KSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgcHJldmlvdXNTY2hlZHVsZWRSb290ID0gcm9vdDtcbiAgICAgICAgICByb290ID0gcm9vdC5uZXh0U2NoZWR1bGVkUm9vdDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIElmIHRoZSBuZXh0IHJvb3QgaXMgdGhlIHNhbWUgYXMgdGhlIHByZXZpb3VzIHJvb3QsIHRoaXMgaXMgYSBuZXN0ZWRcbiAgICAvLyB1cGRhdGUuIFRvIHByZXZlbnQgYW4gaW5maW5pdGUgbG9vcCwgaW5jcmVtZW50IHRoZSBuZXN0ZWQgdXBkYXRlIGNvdW50LlxuICAgIHZhciBwcmV2aW91c0ZsdXNoZWRSb290ID0gbmV4dEZsdXNoZWRSb290O1xuICAgIGlmIChwcmV2aW91c0ZsdXNoZWRSb290ICE9PSBudWxsICYmIHByZXZpb3VzRmx1c2hlZFJvb3QgPT09IGhpZ2hlc3RQcmlvcml0eVJvb3QpIHtcbiAgICAgIG5lc3RlZFVwZGF0ZUNvdW50Kys7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJlc2V0IHdoZW5ldmVyIHdlIHN3aXRjaCByb290cy5cbiAgICAgIG5lc3RlZFVwZGF0ZUNvdW50ID0gMDtcbiAgICB9XG4gICAgbmV4dEZsdXNoZWRSb290ID0gaGlnaGVzdFByaW9yaXR5Um9vdDtcbiAgICBuZXh0Rmx1c2hlZEV4cGlyYXRpb25UaW1lID0gaGlnaGVzdFByaW9yaXR5V29yaztcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlcmZvcm1Bc3luY1dvcmsoZGwpIHtcbiAgICBwZXJmb3JtV29yayhOb1dvcmssIGRsKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlcmZvcm1Xb3JrKG1pbkV4cGlyYXRpb25UaW1lLCBkbCkge1xuICAgIGRlYWRsaW5lID0gZGw7XG5cbiAgICAvLyBLZWVwIHdvcmtpbmcgb24gcm9vdHMgdW50aWwgdGhlcmUncyBubyBtb3JlIHdvcmssIG9yIHVudGlsIHRoZSB3ZSByZWFjaFxuICAgIC8vIHRoZSBkZWFkbGluZS5cbiAgICBmaW5kSGlnaGVzdFByaW9yaXR5Um9vdCgpO1xuXG4gICAgaWYgKGVuYWJsZVVzZXJUaW1pbmdBUEkgJiYgZGVhZGxpbmUgIT09IG51bGwpIHtcbiAgICAgIHZhciBkaWRFeHBpcmUgPSBuZXh0Rmx1c2hlZEV4cGlyYXRpb25UaW1lIDwgcmVjYWxjdWxhdGVDdXJyZW50VGltZSgpO1xuICAgICAgc3RvcFJlcXVlc3RDYWxsYmFja1RpbWVyKGRpZEV4cGlyZSk7XG4gICAgfVxuXG4gICAgd2hpbGUgKG5leHRGbHVzaGVkUm9vdCAhPT0gbnVsbCAmJiBuZXh0Rmx1c2hlZEV4cGlyYXRpb25UaW1lICE9PSBOb1dvcmsgJiYgKG1pbkV4cGlyYXRpb25UaW1lID09PSBOb1dvcmsgfHwgbmV4dEZsdXNoZWRFeHBpcmF0aW9uVGltZSA8PSBtaW5FeHBpcmF0aW9uVGltZSkgJiYgIWRlYWRsaW5lRGlkRXhwaXJlKSB7XG4gICAgICBwZXJmb3JtV29ya09uUm9vdChuZXh0Rmx1c2hlZFJvb3QsIG5leHRGbHVzaGVkRXhwaXJhdGlvblRpbWUpO1xuICAgICAgLy8gRmluZCB0aGUgbmV4dCBoaWdoZXN0IHByaW9yaXR5IHdvcmsuXG4gICAgICBmaW5kSGlnaGVzdFByaW9yaXR5Um9vdCgpO1xuICAgIH1cblxuICAgIC8vIFdlJ3JlIGRvbmUgZmx1c2hpbmcgd29yay4gRWl0aGVyIHdlIHJhbiBvdXQgb2YgdGltZSBpbiB0aGlzIGNhbGxiYWNrLFxuICAgIC8vIG9yIHRoZXJlJ3Mgbm8gbW9yZSB3b3JrIGxlZnQgd2l0aCBzdWZmaWNpZW50IHByaW9yaXR5LlxuXG4gICAgLy8gSWYgd2UncmUgaW5zaWRlIGEgY2FsbGJhY2ssIHNldCB0aGlzIHRvIGZhbHNlIHNpbmNlIHdlIGp1c3QgY29tcGxldGVkIGl0LlxuICAgIGlmIChkZWFkbGluZSAhPT0gbnVsbCkge1xuICAgICAgY2FsbGJhY2tFeHBpcmF0aW9uVGltZSA9IE5vV29yaztcbiAgICAgIGNhbGxiYWNrSUQgPSAtMTtcbiAgICB9XG4gICAgLy8gSWYgdGhlcmUncyB3b3JrIGxlZnQgb3Zlciwgc2NoZWR1bGUgYSBuZXcgY2FsbGJhY2suXG4gICAgaWYgKG5leHRGbHVzaGVkRXhwaXJhdGlvblRpbWUgIT09IE5vV29yaykge1xuICAgICAgc2NoZWR1bGVDYWxsYmFja1dpdGhFeHBpcmF0aW9uKG5leHRGbHVzaGVkRXhwaXJhdGlvblRpbWUpO1xuICAgIH1cblxuICAgIC8vIENsZWFuLXVwLlxuICAgIGRlYWRsaW5lID0gbnVsbDtcbiAgICBkZWFkbGluZURpZEV4cGlyZSA9IGZhbHNlO1xuICAgIG5lc3RlZFVwZGF0ZUNvdW50ID0gMDtcblxuICAgIGlmIChoYXNVbmhhbmRsZWRFcnJvcikge1xuICAgICAgdmFyIF9lcnJvcjQgPSB1bmhhbmRsZWRFcnJvcjtcbiAgICAgIHVuaGFuZGxlZEVycm9yID0gbnVsbDtcbiAgICAgIGhhc1VuaGFuZGxlZEVycm9yID0gZmFsc2U7XG4gICAgICB0aHJvdyBfZXJyb3I0O1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHBlcmZvcm1Xb3JrT25Sb290KHJvb3QsIGV4cGlyYXRpb25UaW1lKSB7XG4gICAgISFpc1JlbmRlcmluZyA/IGludmFyaWFudChmYWxzZSwgJ3BlcmZvcm1Xb3JrT25Sb290IHdhcyBjYWxsZWQgcmVjdXJzaXZlbHkuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG5cbiAgICBpc1JlbmRlcmluZyA9IHRydWU7XG5cbiAgICAvLyBDaGVjayBpZiB0aGlzIGlzIGFzeW5jIHdvcmsgb3Igc3luYy9leHBpcmVkIHdvcmsuXG4gICAgLy8gVE9ETzogUGFzcyBjdXJyZW50IHRpbWUgYXMgYXJndW1lbnQgdG8gcmVuZGVyUm9vdCwgY29tbWl0Um9vdFxuICAgIGlmIChleHBpcmF0aW9uVGltZSA8PSByZWNhbGN1bGF0ZUN1cnJlbnRUaW1lKCkpIHtcbiAgICAgIC8vIEZsdXNoIHN5bmMgd29yay5cbiAgICAgIHZhciBmaW5pc2hlZFdvcmsgPSByb290LmZpbmlzaGVkV29yaztcbiAgICAgIGlmIChmaW5pc2hlZFdvcmsgIT09IG51bGwpIHtcbiAgICAgICAgLy8gVGhpcyByb290IGlzIGFscmVhZHkgY29tcGxldGUuIFdlIGNhbiBjb21taXQgaXQuXG4gICAgICAgIHJvb3QuZmluaXNoZWRXb3JrID0gbnVsbDtcbiAgICAgICAgcm9vdC5yZW1haW5pbmdFeHBpcmF0aW9uVGltZSA9IGNvbW1pdFJvb3QoZmluaXNoZWRXb3JrKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJvb3QuZmluaXNoZWRXb3JrID0gbnVsbDtcbiAgICAgICAgZmluaXNoZWRXb3JrID0gcmVuZGVyUm9vdChyb290LCBleHBpcmF0aW9uVGltZSk7XG4gICAgICAgIGlmIChmaW5pc2hlZFdvcmsgIT09IG51bGwpIHtcbiAgICAgICAgICAvLyBXZSd2ZSBjb21wbGV0ZWQgdGhlIHJvb3QuIENvbW1pdCBpdC5cbiAgICAgICAgICByb290LnJlbWFpbmluZ0V4cGlyYXRpb25UaW1lID0gY29tbWl0Um9vdChmaW5pc2hlZFdvcmspO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEZsdXNoIGFzeW5jIHdvcmsuXG4gICAgICB2YXIgX2ZpbmlzaGVkV29yayA9IHJvb3QuZmluaXNoZWRXb3JrO1xuICAgICAgaWYgKF9maW5pc2hlZFdvcmsgIT09IG51bGwpIHtcbiAgICAgICAgLy8gVGhpcyByb290IGlzIGFscmVhZHkgY29tcGxldGUuIFdlIGNhbiBjb21taXQgaXQuXG4gICAgICAgIHJvb3QuZmluaXNoZWRXb3JrID0gbnVsbDtcbiAgICAgICAgcm9vdC5yZW1haW5pbmdFeHBpcmF0aW9uVGltZSA9IGNvbW1pdFJvb3QoX2ZpbmlzaGVkV29yayk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByb290LmZpbmlzaGVkV29yayA9IG51bGw7XG4gICAgICAgIF9maW5pc2hlZFdvcmsgPSByZW5kZXJSb290KHJvb3QsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgaWYgKF9maW5pc2hlZFdvcmsgIT09IG51bGwpIHtcbiAgICAgICAgICAvLyBXZSd2ZSBjb21wbGV0ZWQgdGhlIHJvb3QuIENoZWNrIHRoZSBkZWFkbGluZSBvbmUgbW9yZSB0aW1lXG4gICAgICAgICAgLy8gYmVmb3JlIGNvbW1pdHRpbmcuXG4gICAgICAgICAgaWYgKCFzaG91bGRZaWVsZCgpKSB7XG4gICAgICAgICAgICAvLyBTdGlsbCB0aW1lIGxlZnQuIENvbW1pdCB0aGUgcm9vdC5cbiAgICAgICAgICAgIHJvb3QucmVtYWluaW5nRXhwaXJhdGlvblRpbWUgPSBjb21taXRSb290KF9maW5pc2hlZFdvcmspO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBUaGVyZSdzIG5vIHRpbWUgbGVmdC4gTWFyayB0aGlzIHJvb3QgYXMgY29tcGxldGUuIFdlJ2xsIGNvbWVcbiAgICAgICAgICAgIC8vIGJhY2sgYW5kIGNvbW1pdCBpdCBsYXRlci5cbiAgICAgICAgICAgIHJvb3QuZmluaXNoZWRXb3JrID0gX2ZpbmlzaGVkV29yaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpc1JlbmRlcmluZyA9IGZhbHNlO1xuICB9XG5cbiAgLy8gV2hlbiB3b3JraW5nIG9uIGFzeW5jIHdvcmssIHRoZSByZWNvbmNpbGVyIGFza3MgdGhlIHJlbmRlcmVyIGlmIGl0IHNob3VsZFxuICAvLyB5aWVsZCBleGVjdXRpb24uIEZvciBET00sIHdlIGltcGxlbWVudCB0aGlzIHdpdGggcmVxdWVzdElkbGVDYWxsYmFjay5cbiAgZnVuY3Rpb24gc2hvdWxkWWllbGQoKSB7XG4gICAgaWYgKGRlYWRsaW5lID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChkZWFkbGluZS50aW1lUmVtYWluaW5nKCkgPiB0aW1lSGV1cmlzdGljRm9yVW5pdE9mV29yaykge1xuICAgICAgLy8gRGlzcmVnYXJkIGRlYWRsaW5lLmRpZFRpbWVvdXQuIE9ubHkgZXhwaXJlZCB3b3JrIHNob3VsZCBiZSBmbHVzaGVkXG4gICAgICAvLyBkdXJpbmcgYSB0aW1lb3V0LiBUaGlzIHBhdGggaXMgb25seSBoaXQgZm9yIG5vbi1leHBpcmVkIHdvcmsuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGRlYWRsaW5lRGlkRXhwaXJlID0gdHJ1ZTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIFRPRE86IE5vdCBoYXBweSBhYm91dCB0aGlzIGhvb2suIENvbmNlcHR1YWxseSwgcmVuZGVyUm9vdCBzaG91bGQgcmV0dXJuIGFcbiAgLy8gdHVwbGUgb2YgKGlzUmVhZHlGb3JDb21taXQsIGRpZEVycm9yLCBlcnJvcilcbiAgZnVuY3Rpb24gb25VbmNhdWdodEVycm9yKGVycm9yKSB7XG4gICAgIShuZXh0Rmx1c2hlZFJvb3QgIT09IG51bGwpID8gaW52YXJpYW50KGZhbHNlLCAnU2hvdWxkIGJlIHdvcmtpbmcgb24gYSByb290LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuICAgIC8vIFVuc2NoZWR1bGUgdGhpcyByb290IHNvIHdlIGRvbid0IHdvcmsgb24gaXQgYWdhaW4gdW50aWwgdGhlcmUnc1xuICAgIC8vIGFub3RoZXIgdXBkYXRlLlxuICAgIG5leHRGbHVzaGVkUm9vdC5yZW1haW5pbmdFeHBpcmF0aW9uVGltZSA9IE5vV29yaztcbiAgICBpZiAoIWhhc1VuaGFuZGxlZEVycm9yKSB7XG4gICAgICBoYXNVbmhhbmRsZWRFcnJvciA9IHRydWU7XG4gICAgICB1bmhhbmRsZWRFcnJvciA9IGVycm9yO1xuICAgIH1cbiAgfVxuXG4gIC8vIFRPRE86IEJhdGNoaW5nIHNob3VsZCBiZSBpbXBsZW1lbnRlZCBhdCB0aGUgcmVuZGVyZXIgbGV2ZWwsIG5vdCBpbnNpZGVcbiAgLy8gdGhlIHJlY29uY2lsZXIuXG4gIGZ1bmN0aW9uIGJhdGNoZWRVcGRhdGVzKGZuLCBhKSB7XG4gICAgdmFyIHByZXZpb3VzSXNCYXRjaGluZ1VwZGF0ZXMgPSBpc0JhdGNoaW5nVXBkYXRlcztcbiAgICBpc0JhdGNoaW5nVXBkYXRlcyA9IHRydWU7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBmbihhKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaXNCYXRjaGluZ1VwZGF0ZXMgPSBwcmV2aW91c0lzQmF0Y2hpbmdVcGRhdGVzO1xuICAgICAgaWYgKCFpc0JhdGNoaW5nVXBkYXRlcyAmJiAhaXNSZW5kZXJpbmcpIHtcbiAgICAgICAgcGVyZm9ybVdvcmsoU3luYywgbnVsbCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gVE9ETzogQmF0Y2hpbmcgc2hvdWxkIGJlIGltcGxlbWVudGVkIGF0IHRoZSByZW5kZXJlciBsZXZlbCwgbm90IGluc2lkZVxuICAvLyB0aGUgcmVjb25jaWxlci5cbiAgZnVuY3Rpb24gdW5iYXRjaGVkVXBkYXRlcyhmbikge1xuICAgIGlmIChpc0JhdGNoaW5nVXBkYXRlcyAmJiAhaXNVbmJhdGNoaW5nVXBkYXRlcykge1xuICAgICAgaXNVbmJhdGNoaW5nVXBkYXRlcyA9IHRydWU7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gZm4oKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlzVW5iYXRjaGluZ1VwZGF0ZXMgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZuKCk7XG4gIH1cblxuICAvLyBUT0RPOiBCYXRjaGluZyBzaG91bGQgYmUgaW1wbGVtZW50ZWQgYXQgdGhlIHJlbmRlcmVyIGxldmVsLCBub3Qgd2l0aGluXG4gIC8vIHRoZSByZWNvbmNpbGVyLlxuICBmdW5jdGlvbiBmbHVzaFN5bmMoZm4pIHtcbiAgICB2YXIgcHJldmlvdXNJc0JhdGNoaW5nVXBkYXRlcyA9IGlzQmF0Y2hpbmdVcGRhdGVzO1xuICAgIGlzQmF0Y2hpbmdVcGRhdGVzID0gdHJ1ZTtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHN5bmNVcGRhdGVzKGZuKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaXNCYXRjaGluZ1VwZGF0ZXMgPSBwcmV2aW91c0lzQmF0Y2hpbmdVcGRhdGVzO1xuICAgICAgISFpc1JlbmRlcmluZyA/IGludmFyaWFudChmYWxzZSwgJ2ZsdXNoU3luYyB3YXMgY2FsbGVkIGZyb20gaW5zaWRlIGEgbGlmZWN5Y2xlIG1ldGhvZC4gSXQgY2Fubm90IGJlIGNhbGxlZCB3aGVuIFJlYWN0IGlzIGFscmVhZHkgcmVuZGVyaW5nLicpIDogdm9pZCAwO1xuICAgICAgcGVyZm9ybVdvcmsoU3luYywgbnVsbCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBjb21wdXRlQXN5bmNFeHBpcmF0aW9uOiBjb21wdXRlQXN5bmNFeHBpcmF0aW9uLFxuICAgIGNvbXB1dGVFeHBpcmF0aW9uRm9yRmliZXI6IGNvbXB1dGVFeHBpcmF0aW9uRm9yRmliZXIsXG4gICAgc2NoZWR1bGVXb3JrOiBzY2hlZHVsZVdvcmssXG4gICAgYmF0Y2hlZFVwZGF0ZXM6IGJhdGNoZWRVcGRhdGVzLFxuICAgIHVuYmF0Y2hlZFVwZGF0ZXM6IHVuYmF0Y2hlZFVwZGF0ZXMsXG4gICAgZmx1c2hTeW5jOiBmbHVzaFN5bmMsXG4gICAgZGVmZXJyZWRVcGRhdGVzOiBkZWZlcnJlZFVwZGF0ZXNcbiAgfTtcbn07XG5cbntcbiAgdmFyIGRpZFdhcm5BYm91dE5lc3RlZFVwZGF0ZXMgPSBmYWxzZTtcbn1cblxuLy8gMCBpcyBQUk9ELCAxIGlzIERFVi5cbi8vIE1pZ2h0IGFkZCBQUk9GSUxFIGxhdGVyLlxuXG5cbmZ1bmN0aW9uIGdldENvbnRleHRGb3JTdWJ0cmVlKHBhcmVudENvbXBvbmVudCkge1xuICBpZiAoIXBhcmVudENvbXBvbmVudCkge1xuICAgIHJldHVybiBlbXB0eU9iamVjdDtcbiAgfVxuXG4gIHZhciBmaWJlciA9IGdldChwYXJlbnRDb21wb25lbnQpO1xuICB2YXIgcGFyZW50Q29udGV4dCA9IGZpbmRDdXJyZW50VW5tYXNrZWRDb250ZXh0KGZpYmVyKTtcbiAgcmV0dXJuIGlzQ29udGV4dFByb3ZpZGVyKGZpYmVyKSA/IHByb2Nlc3NDaGlsZENvbnRleHQoZmliZXIsIHBhcmVudENvbnRleHQpIDogcGFyZW50Q29udGV4dDtcbn1cblxudmFyIFJlYWN0RmliZXJSZWNvbmNpbGVyJDEgPSBmdW5jdGlvbiAoY29uZmlnKSB7XG4gIHZhciBnZXRQdWJsaWNJbnN0YW5jZSA9IGNvbmZpZy5nZXRQdWJsaWNJbnN0YW5jZTtcblxuICB2YXIgX1JlYWN0RmliZXJTY2hlZHVsZXIgPSBSZWFjdEZpYmVyU2NoZWR1bGVyKGNvbmZpZyksXG4gICAgICBjb21wdXRlQXN5bmNFeHBpcmF0aW9uID0gX1JlYWN0RmliZXJTY2hlZHVsZXIuY29tcHV0ZUFzeW5jRXhwaXJhdGlvbixcbiAgICAgIGNvbXB1dGVFeHBpcmF0aW9uRm9yRmliZXIgPSBfUmVhY3RGaWJlclNjaGVkdWxlci5jb21wdXRlRXhwaXJhdGlvbkZvckZpYmVyLFxuICAgICAgc2NoZWR1bGVXb3JrID0gX1JlYWN0RmliZXJTY2hlZHVsZXIuc2NoZWR1bGVXb3JrLFxuICAgICAgYmF0Y2hlZFVwZGF0ZXMgPSBfUmVhY3RGaWJlclNjaGVkdWxlci5iYXRjaGVkVXBkYXRlcyxcbiAgICAgIHVuYmF0Y2hlZFVwZGF0ZXMgPSBfUmVhY3RGaWJlclNjaGVkdWxlci51bmJhdGNoZWRVcGRhdGVzLFxuICAgICAgZmx1c2hTeW5jID0gX1JlYWN0RmliZXJTY2hlZHVsZXIuZmx1c2hTeW5jLFxuICAgICAgZGVmZXJyZWRVcGRhdGVzID0gX1JlYWN0RmliZXJTY2hlZHVsZXIuZGVmZXJyZWRVcGRhdGVzO1xuXG4gIGZ1bmN0aW9uIHNjaGVkdWxlVG9wTGV2ZWxVcGRhdGUoY3VycmVudCwgZWxlbWVudCwgY2FsbGJhY2spIHtcbiAgICB7XG4gICAgICBpZiAoUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5waGFzZSA9PT0gJ3JlbmRlcicgJiYgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5jdXJyZW50ICE9PSBudWxsICYmICFkaWRXYXJuQWJvdXROZXN0ZWRVcGRhdGVzKSB7XG4gICAgICAgIGRpZFdhcm5BYm91dE5lc3RlZFVwZGF0ZXMgPSB0cnVlO1xuICAgICAgICB3YXJuaW5nKGZhbHNlLCAnUmVuZGVyIG1ldGhvZHMgc2hvdWxkIGJlIGEgcHVyZSBmdW5jdGlvbiBvZiBwcm9wcyBhbmQgc3RhdGU7ICcgKyAndHJpZ2dlcmluZyBuZXN0ZWQgY29tcG9uZW50IHVwZGF0ZXMgZnJvbSByZW5kZXIgaXMgbm90IGFsbG93ZWQuICcgKyAnSWYgbmVjZXNzYXJ5LCB0cmlnZ2VyIG5lc3RlZCB1cGRhdGVzIGluIGNvbXBvbmVudERpZFVwZGF0ZS5cXG5cXG4nICsgJ0NoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mICVzLicsIGdldENvbXBvbmVudE5hbWUoUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5jdXJyZW50KSB8fCAnVW5rbm93bicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBjYWxsYmFjaztcbiAgICB7XG4gICAgICB3YXJuaW5nKGNhbGxiYWNrID09PSBudWxsIHx8IHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJywgJ3JlbmRlciguLi4pOiBFeHBlY3RlZCB0aGUgbGFzdCBvcHRpb25hbCBgY2FsbGJhY2tgIGFyZ3VtZW50IHRvIGJlIGEgJyArICdmdW5jdGlvbi4gSW5zdGVhZCByZWNlaXZlZDogJXMuJywgY2FsbGJhY2spO1xuICAgIH1cblxuICAgIHZhciBleHBpcmF0aW9uVGltZSA9IHZvaWQgMDtcbiAgICAvLyBDaGVjayBpZiB0aGUgdG9wLWxldmVsIGVsZW1lbnQgaXMgYW4gYXN5bmMgd3JhcHBlciBjb21wb25lbnQuIElmIHNvLFxuICAgIC8vIHRyZWF0IHVwZGF0ZXMgdG8gdGhlIHJvb3QgYXMgYXN5bmMuIFRoaXMgaXMgYSBiaXQgd2VpcmQgYnV0IGxldHMgdXNcbiAgICAvLyBhdm9pZCBhIHNlcGFyYXRlIGByZW5kZXJBc3luY2AgQVBJLlxuICAgIGlmIChlbmFibGVBc3luY1N1YnRyZWVBUEkgJiYgZWxlbWVudCAhPSBudWxsICYmIGVsZW1lbnQudHlwZSAhPSBudWxsICYmIGVsZW1lbnQudHlwZS5wcm90b3R5cGUgIT0gbnVsbCAmJiBlbGVtZW50LnR5cGUucHJvdG90eXBlLnVuc3RhYmxlX2lzQXN5bmNSZWFjdENvbXBvbmVudCA9PT0gdHJ1ZSkge1xuICAgICAgZXhwaXJhdGlvblRpbWUgPSBjb21wdXRlQXN5bmNFeHBpcmF0aW9uKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4cGlyYXRpb25UaW1lID0gY29tcHV0ZUV4cGlyYXRpb25Gb3JGaWJlcihjdXJyZW50KTtcbiAgICB9XG5cbiAgICB2YXIgdXBkYXRlID0ge1xuICAgICAgZXhwaXJhdGlvblRpbWU6IGV4cGlyYXRpb25UaW1lLFxuICAgICAgcGFydGlhbFN0YXRlOiB7IGVsZW1lbnQ6IGVsZW1lbnQgfSxcbiAgICAgIGNhbGxiYWNrOiBjYWxsYmFjayxcbiAgICAgIGlzUmVwbGFjZTogZmFsc2UsXG4gICAgICBpc0ZvcmNlZDogZmFsc2UsXG4gICAgICBuZXh0Q2FsbGJhY2s6IG51bGwsXG4gICAgICBuZXh0OiBudWxsXG4gICAgfTtcbiAgICBpbnNlcnRVcGRhdGVJbnRvRmliZXIoY3VycmVudCwgdXBkYXRlKTtcbiAgICBzY2hlZHVsZVdvcmsoY3VycmVudCwgZXhwaXJhdGlvblRpbWUpO1xuICB9XG5cbiAgZnVuY3Rpb24gZmluZEhvc3RJbnN0YW5jZShmaWJlcikge1xuICAgIHZhciBob3N0RmliZXIgPSBmaW5kQ3VycmVudEhvc3RGaWJlcihmaWJlcik7XG4gICAgaWYgKGhvc3RGaWJlciA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBob3N0RmliZXIuc3RhdGVOb2RlO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBjcmVhdGVDb250YWluZXI6IGZ1bmN0aW9uIChjb250YWluZXJJbmZvLCBoeWRyYXRlKSB7XG4gICAgICByZXR1cm4gY3JlYXRlRmliZXJSb290KGNvbnRhaW5lckluZm8sIGh5ZHJhdGUpO1xuICAgIH0sXG4gICAgdXBkYXRlQ29udGFpbmVyOiBmdW5jdGlvbiAoZWxlbWVudCwgY29udGFpbmVyLCBwYXJlbnRDb21wb25lbnQsIGNhbGxiYWNrKSB7XG4gICAgICAvLyBUT0RPOiBJZiB0aGlzIGlzIGEgbmVzdGVkIGNvbnRhaW5lciwgdGhpcyB3b24ndCBiZSB0aGUgcm9vdC5cbiAgICAgIHZhciBjdXJyZW50ID0gY29udGFpbmVyLmN1cnJlbnQ7XG5cbiAgICAgIHtcbiAgICAgICAgaWYgKFJlYWN0RmliZXJJbnN0cnVtZW50YXRpb25fMS5kZWJ1Z1Rvb2wpIHtcbiAgICAgICAgICBpZiAoY3VycmVudC5hbHRlcm5hdGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIFJlYWN0RmliZXJJbnN0cnVtZW50YXRpb25fMS5kZWJ1Z1Rvb2wub25Nb3VudENvbnRhaW5lcihjb250YWluZXIpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZWxlbWVudCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbl8xLmRlYnVnVG9vbC5vblVubW91bnRDb250YWluZXIoY29udGFpbmVyKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbl8xLmRlYnVnVG9vbC5vblVwZGF0ZUNvbnRhaW5lcihjb250YWluZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgY29udGV4dCA9IGdldENvbnRleHRGb3JTdWJ0cmVlKHBhcmVudENvbXBvbmVudCk7XG4gICAgICBpZiAoY29udGFpbmVyLmNvbnRleHQgPT09IG51bGwpIHtcbiAgICAgICAgY29udGFpbmVyLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udGFpbmVyLnBlbmRpbmdDb250ZXh0ID0gY29udGV4dDtcbiAgICAgIH1cblxuICAgICAgc2NoZWR1bGVUb3BMZXZlbFVwZGF0ZShjdXJyZW50LCBlbGVtZW50LCBjYWxsYmFjayk7XG4gICAgfSxcblxuXG4gICAgYmF0Y2hlZFVwZGF0ZXM6IGJhdGNoZWRVcGRhdGVzLFxuXG4gICAgdW5iYXRjaGVkVXBkYXRlczogdW5iYXRjaGVkVXBkYXRlcyxcblxuICAgIGRlZmVycmVkVXBkYXRlczogZGVmZXJyZWRVcGRhdGVzLFxuXG4gICAgZmx1c2hTeW5jOiBmbHVzaFN5bmMsXG5cbiAgICBnZXRQdWJsaWNSb290SW5zdGFuY2U6IGZ1bmN0aW9uIChjb250YWluZXIpIHtcbiAgICAgIHZhciBjb250YWluZXJGaWJlciA9IGNvbnRhaW5lci5jdXJyZW50O1xuICAgICAgaWYgKCFjb250YWluZXJGaWJlci5jaGlsZCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAoY29udGFpbmVyRmliZXIuY2hpbGQudGFnKSB7XG4gICAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAgICByZXR1cm4gZ2V0UHVibGljSW5zdGFuY2UoY29udGFpbmVyRmliZXIuY2hpbGQuc3RhdGVOb2RlKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gY29udGFpbmVyRmliZXIuY2hpbGQuc3RhdGVOb2RlO1xuICAgICAgfVxuICAgIH0sXG5cblxuICAgIGZpbmRIb3N0SW5zdGFuY2U6IGZpbmRIb3N0SW5zdGFuY2UsXG5cbiAgICBmaW5kSG9zdEluc3RhbmNlV2l0aE5vUG9ydGFsczogZnVuY3Rpb24gKGZpYmVyKSB7XG4gICAgICB2YXIgaG9zdEZpYmVyID0gZmluZEN1cnJlbnRIb3N0RmliZXJXaXRoTm9Qb3J0YWxzKGZpYmVyKTtcbiAgICAgIGlmIChob3N0RmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gaG9zdEZpYmVyLnN0YXRlTm9kZTtcbiAgICB9LFxuICAgIGluamVjdEludG9EZXZUb29sczogZnVuY3Rpb24gKGRldlRvb2xzQ29uZmlnKSB7XG4gICAgICB2YXIgZmluZEZpYmVyQnlIb3N0SW5zdGFuY2UgPSBkZXZUb29sc0NvbmZpZy5maW5kRmliZXJCeUhvc3RJbnN0YW5jZTtcblxuICAgICAgcmV0dXJuIGluamVjdEludGVybmFscyhfYXNzaWduKHt9LCBkZXZUb29sc0NvbmZpZywge1xuICAgICAgICBmaW5kSG9zdEluc3RhbmNlQnlGaWJlcjogZnVuY3Rpb24gKGZpYmVyKSB7XG4gICAgICAgICAgcmV0dXJuIGZpbmRIb3N0SW5zdGFuY2UoZmliZXIpO1xuICAgICAgICB9LFxuICAgICAgICBmaW5kRmliZXJCeUhvc3RJbnN0YW5jZTogZnVuY3Rpb24gKGluc3RhbmNlKSB7XG4gICAgICAgICAgaWYgKCFmaW5kRmliZXJCeUhvc3RJbnN0YW5jZSkge1xuICAgICAgICAgICAgLy8gTWlnaHQgbm90IGJlIGltcGxlbWVudGVkIGJ5IHRoZSByZW5kZXJlci5cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZmluZEZpYmVyQnlIb3N0SW5zdGFuY2UoaW5zdGFuY2UpO1xuICAgICAgICB9XG4gICAgICB9KSk7XG4gICAgfVxuICB9O1xufTtcblxudmFyIFJlYWN0RmliZXJSZWNvbmNpbGVyJDIgPSBPYmplY3QuZnJlZXplKHtcblx0ZGVmYXVsdDogUmVhY3RGaWJlclJlY29uY2lsZXIkMVxufSk7XG5cbnZhciBSZWFjdEZpYmVyUmVjb25jaWxlciQzID0gKCBSZWFjdEZpYmVyUmVjb25jaWxlciQyICYmIFJlYWN0RmliZXJSZWNvbmNpbGVyJDEgKSB8fCBSZWFjdEZpYmVyUmVjb25jaWxlciQyO1xuXG4vLyBUT0RPOiBidW5kbGUgRmxvdyB0eXBlcyB3aXRoIHRoZSBwYWNrYWdlLlxuXG5cblxuLy8gVE9ETzogZGVjaWRlIG9uIHRoZSB0b3AtbGV2ZWwgZXhwb3J0IGZvcm0uXG4vLyBUaGlzIGlzIGhhY2t5IGJ1dCBtYWtlcyBpdCB3b3JrIHdpdGggYm90aCBSb2xsdXAgYW5kIEplc3QuXG52YXIgcmVhY3RSZWNvbmNpbGVyID0gUmVhY3RGaWJlclJlY29uY2lsZXIkM1snZGVmYXVsdCddID8gUmVhY3RGaWJlclJlY29uY2lsZXIkM1snZGVmYXVsdCddIDogUmVhY3RGaWJlclJlY29uY2lsZXIkMztcblxudmFyIGdldEZpYmVyQ3VycmVudFByb3BzRnJvbU5vZGUgPSBudWxsO1xudmFyIGdldEluc3RhbmNlRnJvbU5vZGUgPSBudWxsO1xuXG5cblxuXG5cblxuXG5cblxue1xuICBcbn1cblxuLyoqXG4gKiBTdGFuZGFyZC9zaW1wbGUgaXRlcmF0aW9uIHRocm91Z2ggYW4gZXZlbnQncyBjb2xsZWN0ZWQgZGlzcGF0Y2hlcy5cbiAqL1xuXG5cbi8qKlxuICogQHNlZSBleGVjdXRlRGlzcGF0Y2hlc0luT3JkZXJTdG9wQXRUcnVlSW1wbFxuICovXG5cblxuLyoqXG4gKiBFeGVjdXRpb24gb2YgYSBcImRpcmVjdFwiIGRpc3BhdGNoIC0gdGhlcmUgbXVzdCBiZSBhdCBtb3N0IG9uZSBkaXNwYXRjaFxuICogYWNjdW11bGF0ZWQgb24gdGhlIGV2ZW50IG9yIGl0IGlzIGNvbnNpZGVyZWQgYW4gZXJyb3IuIEl0IGRvZXNuJ3QgcmVhbGx5IG1ha2VcbiAqIHNlbnNlIGZvciBhbiBldmVudCB3aXRoIG11bHRpcGxlIGRpc3BhdGNoZXMgKGJ1YmJsZWQpIHRvIGtlZXAgdHJhY2sgb2YgdGhlXG4gKiByZXR1cm4gdmFsdWVzIGF0IGVhY2ggZGlzcGF0Y2ggZXhlY3V0aW9uLCBidXQgaXQgZG9lcyB0ZW5kIHRvIG1ha2Ugc2Vuc2Ugd2hlblxuICogZGVhbGluZyB3aXRoIFwiZGlyZWN0XCIgZGlzcGF0Y2hlcy5cbiAqXG4gKiBAcmV0dXJuIHsqfSBUaGUgcmV0dXJuIHZhbHVlIG9mIGV4ZWN1dGluZyB0aGUgc2luZ2xlIGRpc3BhdGNoLlxuICovXG5cblxuLyoqXG4gKiBAcGFyYW0ge1N5bnRoZXRpY0V2ZW50fSBldmVudFxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZmYgbnVtYmVyIG9mIGRpc3BhdGNoZXMgYWNjdW11bGF0ZWQgaXMgZ3JlYXRlciB0aGFuIDAuXG4gKi9cblxuLy8gVXNlIHRvIHJlc3RvcmUgY29udHJvbGxlZCBzdGF0ZSBhZnRlciBhIGNoYW5nZSBldmVudCBoYXMgZmlyZWQuXG5cbnZhciBmaWJlckhvc3RDb21wb25lbnQgPSBudWxsO1xuXG52YXIgcmVzdG9yZVRhcmdldCA9IG51bGw7XG52YXIgcmVzdG9yZVF1ZXVlID0gbnVsbDtcblxuZnVuY3Rpb24gcmVzdG9yZVN0YXRlT2ZUYXJnZXQodGFyZ2V0KSB7XG4gIC8vIFdlIHBlcmZvcm0gdGhpcyB0cmFuc2xhdGlvbiBhdCB0aGUgZW5kIG9mIHRoZSBldmVudCBsb29wIHNvIHRoYXQgd2VcbiAgLy8gYWx3YXlzIHJlY2VpdmUgdGhlIGNvcnJlY3QgZmliZXIgaGVyZVxuICB2YXIgaW50ZXJuYWxJbnN0YW5jZSA9IGdldEluc3RhbmNlRnJvbU5vZGUodGFyZ2V0KTtcbiAgaWYgKCFpbnRlcm5hbEluc3RhbmNlKSB7XG4gICAgLy8gVW5tb3VudGVkXG4gICAgcmV0dXJuO1xuICB9XG4gICEoZmliZXJIb3N0Q29tcG9uZW50ICYmIHR5cGVvZiBmaWJlckhvc3RDb21wb25lbnQucmVzdG9yZUNvbnRyb2xsZWRTdGF0ZSA9PT0gJ2Z1bmN0aW9uJykgPyBpbnZhcmlhbnQoZmFsc2UsICdGaWJlciBuZWVkcyB0byBiZSBpbmplY3RlZCB0byBoYW5kbGUgYSBmaWJlciB0YXJnZXQgZm9yIGNvbnRyb2xsZWQgZXZlbnRzLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuICB2YXIgcHJvcHMgPSBnZXRGaWJlckN1cnJlbnRQcm9wc0Zyb21Ob2RlKGludGVybmFsSW5zdGFuY2Uuc3RhdGVOb2RlKTtcbiAgZmliZXJIb3N0Q29tcG9uZW50LnJlc3RvcmVDb250cm9sbGVkU3RhdGUoaW50ZXJuYWxJbnN0YW5jZS5zdGF0ZU5vZGUsIGludGVybmFsSW5zdGFuY2UudHlwZSwgcHJvcHMpO1xufVxuXG5cblxuXG5cbmZ1bmN0aW9uIHJlc3RvcmVTdGF0ZUlmTmVlZGVkKCkge1xuICBpZiAoIXJlc3RvcmVUYXJnZXQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIHRhcmdldCA9IHJlc3RvcmVUYXJnZXQ7XG4gIHZhciBxdWV1ZWRUYXJnZXRzID0gcmVzdG9yZVF1ZXVlO1xuICByZXN0b3JlVGFyZ2V0ID0gbnVsbDtcbiAgcmVzdG9yZVF1ZXVlID0gbnVsbDtcblxuICByZXN0b3JlU3RhdGVPZlRhcmdldCh0YXJnZXQpO1xuICBpZiAocXVldWVkVGFyZ2V0cykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcXVldWVkVGFyZ2V0cy5sZW5ndGg7IGkrKykge1xuICAgICAgcmVzdG9yZVN0YXRlT2ZUYXJnZXQocXVldWVkVGFyZ2V0c1tpXSk7XG4gICAgfVxuICB9XG59XG5cbi8vIFVzZWQgYXMgYSB3YXkgdG8gY2FsbCBiYXRjaGVkVXBkYXRlcyB3aGVuIHdlIGRvbid0IGhhdmUgYSByZWZlcmVuY2UgdG9cbi8vIHRoZSByZW5kZXJlci4gU3VjaCBhcyB3aGVuIHdlJ3JlIGRpc3BhdGNoaW5nIGV2ZW50cyBvciBpZiB0aGlyZCBwYXJ0eVxuLy8gbGlicmFyaWVzIG5lZWQgdG8gY2FsbCBiYXRjaGVkVXBkYXRlcy4gRXZlbnR1YWxseSwgdGhpcyBBUEkgd2lsbCBnbyBhd2F5IHdoZW5cbi8vIGV2ZXJ5dGhpbmcgaXMgYmF0Y2hlZCBieSBkZWZhdWx0LiBXZSdsbCB0aGVuIGhhdmUgYSBzaW1pbGFyIEFQSSB0byBvcHQtb3V0IG9mXG4vLyBzY2hlZHVsZWQgd29yayBhbmQgaW5zdGVhZCBkbyBzeW5jaHJvbm91cyB3b3JrLlxuXG4vLyBEZWZhdWx0c1xudmFyIGZpYmVyQmF0Y2hlZFVwZGF0ZXMgPSBmdW5jdGlvbiAoZm4sIGJvb2trZWVwaW5nKSB7XG4gIHJldHVybiBmbihib29ra2VlcGluZyk7XG59O1xuXG52YXIgaXNOZXN0aW5nQmF0Y2hlZCA9IGZhbHNlO1xuZnVuY3Rpb24gYmF0Y2hlZFVwZGF0ZXMoZm4sIGJvb2trZWVwaW5nKSB7XG4gIGlmIChpc05lc3RpbmdCYXRjaGVkKSB7XG4gICAgLy8gSWYgd2UgYXJlIGN1cnJlbnRseSBpbnNpZGUgYW5vdGhlciBiYXRjaCwgd2UgbmVlZCB0byB3YWl0IHVudGlsIGl0XG4gICAgLy8gZnVsbHkgY29tcGxldGVzIGJlZm9yZSByZXN0b3Jpbmcgc3RhdGUuIFRoZXJlZm9yZSwgd2UgYWRkIHRoZSB0YXJnZXQgdG9cbiAgICAvLyBhIHF1ZXVlIG9mIHdvcmsuXG4gICAgcmV0dXJuIGZpYmVyQmF0Y2hlZFVwZGF0ZXMoZm4sIGJvb2trZWVwaW5nKTtcbiAgfVxuICBpc05lc3RpbmdCYXRjaGVkID0gdHJ1ZTtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZmliZXJCYXRjaGVkVXBkYXRlcyhmbiwgYm9va2tlZXBpbmcpO1xuICB9IGZpbmFsbHkge1xuICAgIC8vIEhlcmUgd2Ugd2FpdCB1bnRpbCBhbGwgdXBkYXRlcyBoYXZlIHByb3BhZ2F0ZWQsIHdoaWNoIGlzIGltcG9ydGFudFxuICAgIC8vIHdoZW4gdXNpbmcgY29udHJvbGxlZCBjb21wb25lbnRzIHdpdGhpbiBsYXllcnM6XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xNjk4XG4gICAgLy8gVGhlbiB3ZSByZXN0b3JlIHN0YXRlIG9mIGFueSBjb250cm9sbGVkIGNvbXBvbmVudC5cbiAgICBpc05lc3RpbmdCYXRjaGVkID0gZmFsc2U7XG4gICAgcmVzdG9yZVN0YXRlSWZOZWVkZWQoKTtcbiAgfVxufVxuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMob2JqLCBrZXlzKSB7IHZhciB0YXJnZXQgPSB7fTsgZm9yICh2YXIgaSBpbiBvYmopIHsgaWYgKGtleXMuaW5kZXhPZihpKSA+PSAwKSBjb250aW51ZTsgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBpKSkgY29udGludWU7IHRhcmdldFtpXSA9IG9ialtpXTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5cbnZhciBVUERBVEVfU0lHTkFMID0ge307XG5cbmZ1bmN0aW9uIGdldFB1YmxpY0luc3RhbmNlKGluc3QpIHtcbiAgc3dpdGNoIChpbnN0LnRhZykge1xuICAgIGNhc2UgJ0lOU1RBTkNFJzpcbiAgICAgIHZhciBfY3JlYXRlTm9kZU1vY2sgPSBpbnN0LnJvb3RDb250YWluZXJJbnN0YW5jZS5jcmVhdGVOb2RlTW9jaztcbiAgICAgIHJldHVybiBfY3JlYXRlTm9kZU1vY2soe1xuICAgICAgICB0eXBlOiBpbnN0LnR5cGUsXG4gICAgICAgIHByb3BzOiBpbnN0LnByb3BzXG4gICAgICB9KTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGluc3Q7XG4gIH1cbn1cblxuZnVuY3Rpb24gYXBwZW5kQ2hpbGQocGFyZW50SW5zdGFuY2UsIGNoaWxkKSB7XG4gIHZhciBpbmRleCA9IHBhcmVudEluc3RhbmNlLmNoaWxkcmVuLmluZGV4T2YoY2hpbGQpO1xuICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgcGFyZW50SW5zdGFuY2UuY2hpbGRyZW4uc3BsaWNlKGluZGV4LCAxKTtcbiAgfVxuICBwYXJlbnRJbnN0YW5jZS5jaGlsZHJlbi5wdXNoKGNoaWxkKTtcbn1cblxuZnVuY3Rpb24gaW5zZXJ0QmVmb3JlKHBhcmVudEluc3RhbmNlLCBjaGlsZCwgYmVmb3JlQ2hpbGQpIHtcbiAgdmFyIGluZGV4ID0gcGFyZW50SW5zdGFuY2UuY2hpbGRyZW4uaW5kZXhPZihjaGlsZCk7XG4gIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICBwYXJlbnRJbnN0YW5jZS5jaGlsZHJlbi5zcGxpY2UoaW5kZXgsIDEpO1xuICB9XG4gIHZhciBiZWZvcmVJbmRleCA9IHBhcmVudEluc3RhbmNlLmNoaWxkcmVuLmluZGV4T2YoYmVmb3JlQ2hpbGQpO1xuICBwYXJlbnRJbnN0YW5jZS5jaGlsZHJlbi5zcGxpY2UoYmVmb3JlSW5kZXgsIDAsIGNoaWxkKTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlQ2hpbGQocGFyZW50SW5zdGFuY2UsIGNoaWxkKSB7XG4gIHZhciBpbmRleCA9IHBhcmVudEluc3RhbmNlLmNoaWxkcmVuLmluZGV4T2YoY2hpbGQpO1xuICBwYXJlbnRJbnN0YW5jZS5jaGlsZHJlbi5zcGxpY2UoaW5kZXgsIDEpO1xufVxuXG52YXIgVGVzdFJlbmRlcmVyID0gcmVhY3RSZWNvbmNpbGVyKHtcbiAgZ2V0Um9vdEhvc3RDb250ZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGVtcHR5T2JqZWN0O1xuICB9LFxuICBnZXRDaGlsZEhvc3RDb250ZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGVtcHR5T2JqZWN0O1xuICB9LFxuICBwcmVwYXJlRm9yQ29tbWl0OiBmdW5jdGlvbiAoKSB7XG4gICAgLy8gbm9vcFxuICB9LFxuICByZXNldEFmdGVyQ29tbWl0OiBmdW5jdGlvbiAoKSB7XG4gICAgLy8gbm9vcFxuICB9LFxuICBjcmVhdGVJbnN0YW5jZTogZnVuY3Rpb24gKHR5cGUsIHByb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UsIGhvc3RDb250ZXh0LCBpbnRlcm5hbEluc3RhbmNlSGFuZGxlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IHR5cGUsXG4gICAgICBwcm9wczogcHJvcHMsXG4gICAgICBjaGlsZHJlbjogW10sXG4gICAgICByb290Q29udGFpbmVySW5zdGFuY2U6IHJvb3RDb250YWluZXJJbnN0YW5jZSxcbiAgICAgIHRhZzogJ0lOU1RBTkNFJ1xuICAgIH07XG4gIH0sXG4gIGFwcGVuZEluaXRpYWxDaGlsZDogZnVuY3Rpb24gKHBhcmVudEluc3RhbmNlLCBjaGlsZCkge1xuICAgIHZhciBpbmRleCA9IHBhcmVudEluc3RhbmNlLmNoaWxkcmVuLmluZGV4T2YoY2hpbGQpO1xuICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgIHBhcmVudEluc3RhbmNlLmNoaWxkcmVuLnNwbGljZShpbmRleCwgMSk7XG4gICAgfVxuICAgIHBhcmVudEluc3RhbmNlLmNoaWxkcmVuLnB1c2goY2hpbGQpO1xuICB9LFxuICBmaW5hbGl6ZUluaXRpYWxDaGlsZHJlbjogZnVuY3Rpb24gKHRlc3RFbGVtZW50LCB0eXBlLCBwcm9wcywgcm9vdENvbnRhaW5lckluc3RhbmNlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LFxuICBwcmVwYXJlVXBkYXRlOiBmdW5jdGlvbiAodGVzdEVsZW1lbnQsIHR5cGUsIG9sZFByb3BzLCBuZXdQcm9wcywgcm9vdENvbnRhaW5lckluc3RhbmNlLCBob3N0Q29udGV4dCkge1xuICAgIHJldHVybiBVUERBVEVfU0lHTkFMO1xuICB9LFxuICBzaG91bGRTZXRUZXh0Q29udGVudDogZnVuY3Rpb24gKHR5cGUsIHByb3BzKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LFxuICBzaG91bGREZXByaW9yaXRpemVTdWJ0cmVlOiBmdW5jdGlvbiAodHlwZSwgcHJvcHMpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sXG4gIGNyZWF0ZVRleHRJbnN0YW5jZTogZnVuY3Rpb24gKHRleHQsIHJvb3RDb250YWluZXJJbnN0YW5jZSwgaG9zdENvbnRleHQsIGludGVybmFsSW5zdGFuY2VIYW5kbGUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdGV4dDogdGV4dCxcbiAgICAgIHRhZzogJ1RFWFQnXG4gICAgfTtcbiAgfSxcbiAgc2NoZWR1bGVEZWZlcnJlZENhbGxiYWNrOiBmdW5jdGlvbiAoZm4pIHtcbiAgICByZXR1cm4gc2V0VGltZW91dChmbiwgMCwgeyB0aW1lUmVtYWluaW5nOiBJbmZpbml0eSB9KTtcbiAgfSxcbiAgY2FuY2VsRGVmZXJyZWRDYWxsYmFjazogZnVuY3Rpb24gKHRpbWVvdXRJRCkge1xuICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SUQpO1xuICB9LFxuXG5cbiAgdXNlU3luY1NjaGVkdWxpbmc6IHRydWUsXG5cbiAgZ2V0UHVibGljSW5zdGFuY2U6IGdldFB1YmxpY0luc3RhbmNlLFxuXG4gIG5vdzogZnVuY3Rpb24gKCkge1xuICAgIC8vIFRlc3QgcmVuZGVyZXIgZG9lcyBub3QgdXNlIGV4cGlyYXRpb25cbiAgICByZXR1cm4gMDtcbiAgfSxcblxuXG4gIG11dGF0aW9uOiB7XG4gICAgY29tbWl0VXBkYXRlOiBmdW5jdGlvbiAoaW5zdGFuY2UsIHVwZGF0ZVBheWxvYWQsIHR5cGUsIG9sZFByb3BzLCBuZXdQcm9wcywgaW50ZXJuYWxJbnN0YW5jZUhhbmRsZSkge1xuICAgICAgaW5zdGFuY2UudHlwZSA9IHR5cGU7XG4gICAgICBpbnN0YW5jZS5wcm9wcyA9IG5ld1Byb3BzO1xuICAgIH0sXG4gICAgY29tbWl0TW91bnQ6IGZ1bmN0aW9uIChpbnN0YW5jZSwgdHlwZSwgbmV3UHJvcHMsIGludGVybmFsSW5zdGFuY2VIYW5kbGUpIHtcbiAgICAgIC8vIG5vb3BcbiAgICB9LFxuICAgIGNvbW1pdFRleHRVcGRhdGU6IGZ1bmN0aW9uICh0ZXh0SW5zdGFuY2UsIG9sZFRleHQsIG5ld1RleHQpIHtcbiAgICAgIHRleHRJbnN0YW5jZS50ZXh0ID0gbmV3VGV4dDtcbiAgICB9LFxuICAgIHJlc2V0VGV4dENvbnRlbnQ6IGZ1bmN0aW9uICh0ZXN0RWxlbWVudCkge1xuICAgICAgLy8gbm9vcFxuICAgIH0sXG5cblxuICAgIGFwcGVuZENoaWxkOiBhcHBlbmRDaGlsZCxcbiAgICBhcHBlbmRDaGlsZFRvQ29udGFpbmVyOiBhcHBlbmRDaGlsZCxcbiAgICBpbnNlcnRCZWZvcmU6IGluc2VydEJlZm9yZSxcbiAgICBpbnNlcnRJbkNvbnRhaW5lckJlZm9yZTogaW5zZXJ0QmVmb3JlLFxuICAgIHJlbW92ZUNoaWxkOiByZW1vdmVDaGlsZCxcbiAgICByZW1vdmVDaGlsZEZyb21Db250YWluZXI6IHJlbW92ZUNoaWxkXG4gIH1cbn0pO1xuXG52YXIgZGVmYXVsdFRlc3RPcHRpb25zID0ge1xuICBjcmVhdGVOb2RlTW9jazogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59O1xuXG5mdW5jdGlvbiB0b0pTT04oaW5zdCkge1xuICBzd2l0Y2ggKGluc3QudGFnKSB7XG4gICAgY2FzZSAnVEVYVCc6XG4gICAgICByZXR1cm4gaW5zdC50ZXh0O1xuICAgIGNhc2UgJ0lOU1RBTkNFJzpcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG4gICAgICAvLyBXZSBkb24ndCBpbmNsdWRlIHRoZSBgY2hpbGRyZW5gIHByb3AgaW4gSlNPTi5cbiAgICAgIC8vIEluc3RlYWQsIHdlIHdpbGwgaW5jbHVkZSB0aGUgYWN0dWFsIHJlbmRlcmVkIGNoaWxkcmVuLlxuICAgICAgdmFyIF9pbnN0JHByb3BzID0gaW5zdC5wcm9wcyxcbiAgICAgICAgICBfY2hpbGRyZW4gPSBfaW5zdCRwcm9wcy5jaGlsZHJlbixcbiAgICAgICAgICBfcHJvcHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX2luc3QkcHJvcHMsIFsnY2hpbGRyZW4nXSk7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlICovXG5cblxuICAgICAgdmFyIHJlbmRlcmVkQ2hpbGRyZW4gPSBudWxsO1xuICAgICAgaWYgKGluc3QuY2hpbGRyZW4gJiYgaW5zdC5jaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgcmVuZGVyZWRDaGlsZHJlbiA9IGluc3QuY2hpbGRyZW4ubWFwKHRvSlNPTik7XG4gICAgICB9XG4gICAgICB2YXIganNvbiA9IHtcbiAgICAgICAgdHlwZTogaW5zdC50eXBlLFxuICAgICAgICBwcm9wczogX3Byb3BzLFxuICAgICAgICBjaGlsZHJlbjogcmVuZGVyZWRDaGlsZHJlblxuICAgICAgfTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShqc29uLCAnJCR0eXBlb2YnLCB7XG4gICAgICAgIHZhbHVlOiBTeW1ib2xbJ2ZvciddKCdyZWFjdC50ZXN0Lmpzb24nKVxuICAgICAgfSk7XG4gICAgICByZXR1cm4ganNvbjtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmV4cGVjdGVkIG5vZGUgdHlwZSBpbiB0b0pTT046ICcgKyBpbnN0LnRhZyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbm9kZUFuZFNpYmxpbmdzVHJlZXMobm9kZVdpdGhTaWJsaW5nKSB7XG4gIHZhciBhcnJheSA9IFtdO1xuICB2YXIgbm9kZSA9IG5vZGVXaXRoU2libGluZztcbiAgd2hpbGUgKG5vZGUgIT0gbnVsbCkge1xuICAgIGFycmF5LnB1c2gobm9kZSk7XG4gICAgbm9kZSA9IG5vZGUuc2libGluZztcbiAgfVxuICB2YXIgdHJlZXMgPSBhcnJheS5tYXAodG9UcmVlKTtcbiAgcmV0dXJuIHRyZWVzLmxlbmd0aCA/IHRyZWVzIDogbnVsbDtcbn1cblxuZnVuY3Rpb24gaGFzU2libGluZ3Mobm9kZSkge1xuICByZXR1cm4gbm9kZSAmJiBub2RlLnNpYmxpbmc7XG59XG5cbmZ1bmN0aW9uIHRvVHJlZShub2RlKSB7XG4gIGlmIChub2RlID09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBzd2l0Y2ggKG5vZGUudGFnKSB7XG4gICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgIC8vIDNcbiAgICAgIHJldHVybiB0b1RyZWUobm9kZS5jaGlsZCk7XG4gICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5vZGVUeXBlOiAnY29tcG9uZW50JyxcbiAgICAgICAgdHlwZTogbm9kZS50eXBlLFxuICAgICAgICBwcm9wczogX2Fzc2lnbih7fSwgbm9kZS5tZW1vaXplZFByb3BzKSxcbiAgICAgICAgaW5zdGFuY2U6IG5vZGUuc3RhdGVOb2RlLFxuICAgICAgICByZW5kZXJlZDogaGFzU2libGluZ3Mobm9kZS5jaGlsZCkgPyBub2RlQW5kU2libGluZ3NUcmVlcyhub2RlLmNoaWxkKSA6IHRvVHJlZShub2RlLmNoaWxkKVxuICAgICAgfTtcbiAgICBjYXNlIEZ1bmN0aW9uYWxDb21wb25lbnQ6XG4gICAgICAvLyAxXG4gICAgICByZXR1cm4ge1xuICAgICAgICBub2RlVHlwZTogJ2NvbXBvbmVudCcsXG4gICAgICAgIHR5cGU6IG5vZGUudHlwZSxcbiAgICAgICAgcHJvcHM6IF9hc3NpZ24oe30sIG5vZGUubWVtb2l6ZWRQcm9wcyksXG4gICAgICAgIGluc3RhbmNlOiBudWxsLFxuICAgICAgICByZW5kZXJlZDogaGFzU2libGluZ3Mobm9kZS5jaGlsZCkgPyBub2RlQW5kU2libGluZ3NUcmVlcyhub2RlLmNoaWxkKSA6IHRvVHJlZShub2RlLmNoaWxkKVxuICAgICAgfTtcbiAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAvLyA1XG4gICAgICByZXR1cm4ge1xuICAgICAgICBub2RlVHlwZTogJ2hvc3QnLFxuICAgICAgICB0eXBlOiBub2RlLnR5cGUsXG4gICAgICAgIHByb3BzOiBfYXNzaWduKHt9LCBub2RlLm1lbW9pemVkUHJvcHMpLFxuICAgICAgICBpbnN0YW5jZTogbnVsbCwgLy8gVE9ETzogdXNlIGNyZWF0ZU5vZGVNb2NrIGhlcmUgc29tZWhvdz9cbiAgICAgICAgcmVuZGVyZWQ6IG5vZGVBbmRTaWJsaW5nc1RyZWVzKG5vZGUuY2hpbGQpXG4gICAgICB9O1xuICAgIGNhc2UgSG9zdFRleHQ6XG4gICAgICAvLyA2XG4gICAgICByZXR1cm4gbm9kZS5zdGF0ZU5vZGUudGV4dDtcbiAgICBkZWZhdWx0OlxuICAgICAgaW52YXJpYW50KGZhbHNlLCAndG9UcmVlKCkgZG9lcyBub3QgeWV0IGtub3cgaG93IHRvIGhhbmRsZSBub2RlcyB3aXRoIHRhZz0lcycsIG5vZGUudGFnKTtcbiAgfVxufVxuXG52YXIgZmliZXJUb1dyYXBwZXIgPSBuZXcgV2Vha01hcCgpO1xuZnVuY3Rpb24gd3JhcEZpYmVyKGZpYmVyKSB7XG4gIHZhciB3cmFwcGVyID0gZmliZXJUb1dyYXBwZXIuZ2V0KGZpYmVyKTtcbiAgaWYgKHdyYXBwZXIgPT09IHVuZGVmaW5lZCAmJiBmaWJlci5hbHRlcm5hdGUgIT09IG51bGwpIHtcbiAgICB3cmFwcGVyID0gZmliZXJUb1dyYXBwZXIuZ2V0KGZpYmVyLmFsdGVybmF0ZSk7XG4gIH1cbiAgaWYgKHdyYXBwZXIgPT09IHVuZGVmaW5lZCkge1xuICAgIHdyYXBwZXIgPSBuZXcgUmVhY3RUZXN0SW5zdGFuY2UoZmliZXIpO1xuICAgIGZpYmVyVG9XcmFwcGVyLnNldChmaWJlciwgd3JhcHBlcik7XG4gIH1cbiAgcmV0dXJuIHdyYXBwZXI7XG59XG5cbnZhciB2YWxpZFdyYXBwZXJUeXBlcyA9IG5ldyBTZXQoW0Z1bmN0aW9uYWxDb21wb25lbnQsIENsYXNzQ29tcG9uZW50LCBIb3N0Q29tcG9uZW50XSk7XG5cbnZhciBSZWFjdFRlc3RJbnN0YW5jZSA9IGZ1bmN0aW9uICgpIHtcbiAgUmVhY3RUZXN0SW5zdGFuY2UucHJvdG90eXBlLl9jdXJyZW50RmliZXIgPSBmdW5jdGlvbiBfY3VycmVudEZpYmVyKCkge1xuICAgIC8vIFRocm93cyBpZiB0aGlzIGNvbXBvbmVudCBoYXMgYmVlbiB1bm1vdW50ZWQuXG4gICAgdmFyIGZpYmVyID0gZmluZEN1cnJlbnRGaWJlclVzaW5nU2xvd1BhdGgodGhpcy5fZmliZXIpO1xuICAgICEoZmliZXIgIT09IG51bGwpID8gaW52YXJpYW50KGZhbHNlLCAnQ2FuXFwndCByZWFkIGZyb20gY3VycmVudGx5LW1vdW50aW5nIGNvbXBvbmVudC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcbiAgICByZXR1cm4gZmliZXI7XG4gIH07XG5cbiAgZnVuY3Rpb24gUmVhY3RUZXN0SW5zdGFuY2UoZmliZXIpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUmVhY3RUZXN0SW5zdGFuY2UpO1xuXG4gICAgIXZhbGlkV3JhcHBlclR5cGVzLmhhcyhmaWJlci50YWcpID8gaW52YXJpYW50KGZhbHNlLCAnVW5leHBlY3RlZCBvYmplY3QgcGFzc2VkIHRvIFJlYWN0VGVzdEluc3RhbmNlIGNvbnN0cnVjdG9yICh0YWc6ICVzKS4gVGhpcyBpcyBwcm9iYWJseSBhIGJ1ZyBpbiBSZWFjdC4nLCBmaWJlci50YWcpIDogdm9pZCAwO1xuICAgIHRoaXMuX2ZpYmVyID0gZmliZXI7XG4gIH1cblxuICAvLyBDdXN0b20gc2VhcmNoIGZ1bmN0aW9uc1xuICBSZWFjdFRlc3RJbnN0YW5jZS5wcm90b3R5cGUuZmluZCA9IGZ1bmN0aW9uIGZpbmQocHJlZGljYXRlKSB7XG4gICAgcmV0dXJuIGV4cGVjdE9uZSh0aGlzLmZpbmRBbGwocHJlZGljYXRlLCB7IGRlZXA6IGZhbHNlIH0pLCAnbWF0Y2hpbmcgY3VzdG9tIHByZWRpY2F0ZTogJyArIHByZWRpY2F0ZS50b1N0cmluZygpKTtcbiAgfTtcblxuICBSZWFjdFRlc3RJbnN0YW5jZS5wcm90b3R5cGUuZmluZEJ5VHlwZSA9IGZ1bmN0aW9uIGZpbmRCeVR5cGUodHlwZSkge1xuICAgIHJldHVybiBleHBlY3RPbmUodGhpcy5maW5kQWxsQnlUeXBlKHR5cGUsIHsgZGVlcDogZmFsc2UgfSksICd3aXRoIG5vZGUgdHlwZTogXCInICsgKHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lKSArICdcIicpO1xuICB9O1xuXG4gIFJlYWN0VGVzdEluc3RhbmNlLnByb3RvdHlwZS5maW5kQnlQcm9wcyA9IGZ1bmN0aW9uIGZpbmRCeVByb3BzKHByb3BzKSB7XG4gICAgcmV0dXJuIGV4cGVjdE9uZSh0aGlzLmZpbmRBbGxCeVByb3BzKHByb3BzLCB7IGRlZXA6IGZhbHNlIH0pLCAnd2l0aCBwcm9wczogJyArIEpTT04uc3RyaW5naWZ5KHByb3BzKSk7XG4gIH07XG5cbiAgUmVhY3RUZXN0SW5zdGFuY2UucHJvdG90eXBlLmZpbmRBbGwgPSBmdW5jdGlvbiBmaW5kQWxsKHByZWRpY2F0ZSkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBudWxsO1xuXG4gICAgcmV0dXJuIF9maW5kQWxsKHRoaXMsIHByZWRpY2F0ZSwgb3B0aW9ucyk7XG4gIH07XG5cbiAgUmVhY3RUZXN0SW5zdGFuY2UucHJvdG90eXBlLmZpbmRBbGxCeVR5cGUgPSBmdW5jdGlvbiBmaW5kQWxsQnlUeXBlKHR5cGUpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogbnVsbDtcblxuICAgIHJldHVybiBfZmluZEFsbCh0aGlzLCBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgcmV0dXJuIG5vZGUudHlwZSA9PT0gdHlwZTtcbiAgICB9LCBvcHRpb25zKTtcbiAgfTtcblxuICBSZWFjdFRlc3RJbnN0YW5jZS5wcm90b3R5cGUuZmluZEFsbEJ5UHJvcHMgPSBmdW5jdGlvbiBmaW5kQWxsQnlQcm9wcyhwcm9wcykge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBudWxsO1xuXG4gICAgcmV0dXJuIF9maW5kQWxsKHRoaXMsIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICByZXR1cm4gbm9kZS5wcm9wcyAmJiBwcm9wc01hdGNoKG5vZGUucHJvcHMsIHByb3BzKTtcbiAgICB9LCBvcHRpb25zKTtcbiAgfTtcblxuICBfY3JlYXRlQ2xhc3MoUmVhY3RUZXN0SW5zdGFuY2UsIFt7XG4gICAga2V5OiAnaW5zdGFuY2UnLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHRoaXMuX2ZpYmVyLnRhZyA9PT0gSG9zdENvbXBvbmVudCkge1xuICAgICAgICByZXR1cm4gZ2V0UHVibGljSW5zdGFuY2UodGhpcy5fZmliZXIuc3RhdGVOb2RlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9maWJlci5zdGF0ZU5vZGU7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndHlwZScsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZmliZXIudHlwZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdwcm9wcycsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fY3VycmVudEZpYmVyKCkubWVtb2l6ZWRQcm9wcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdwYXJlbnQnLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHBhcmVudCA9IHRoaXMuX2ZpYmVyWydyZXR1cm4nXTtcbiAgICAgIHJldHVybiBwYXJlbnQgPT09IG51bGwgfHwgcGFyZW50LnRhZyA9PT0gSG9zdFJvb3QgPyBudWxsIDogd3JhcEZpYmVyKHBhcmVudCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnY2hpbGRyZW4nLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGNoaWxkcmVuID0gW107XG4gICAgICB2YXIgc3RhcnRpbmdOb2RlID0gdGhpcy5fY3VycmVudEZpYmVyKCk7XG4gICAgICB2YXIgbm9kZSA9IHN0YXJ0aW5nTm9kZTtcbiAgICAgIGlmIChub2RlLmNoaWxkID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBjaGlsZHJlbjtcbiAgICAgIH1cbiAgICAgIG5vZGUuY2hpbGRbJ3JldHVybiddID0gbm9kZTtcbiAgICAgIG5vZGUgPSBub2RlLmNoaWxkO1xuICAgICAgb3V0ZXI6IHdoaWxlICh0cnVlKSB7XG4gICAgICAgIHZhciBkZXNjZW5kID0gZmFsc2U7XG4gICAgICAgIHN3aXRjaCAobm9kZS50YWcpIHtcbiAgICAgICAgICBjYXNlIEZ1bmN0aW9uYWxDb21wb25lbnQ6XG4gICAgICAgICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgICAgICBjaGlsZHJlbi5wdXNoKHdyYXBGaWJlcihub2RlKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIEhvc3RUZXh0OlxuICAgICAgICAgICAgY2hpbGRyZW4ucHVzaCgnJyArIG5vZGUubWVtb2l6ZWRQcm9wcyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIEZyYWdtZW50OlxuICAgICAgICAgICAgZGVzY2VuZCA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgaW52YXJpYW50KGZhbHNlLCAnVW5zdXBwb3J0ZWQgY29tcG9uZW50IHR5cGUgJXMgaW4gdGVzdCByZW5kZXJlci4gVGhpcyBpcyBwcm9iYWJseSBhIGJ1ZyBpbiBSZWFjdC4nLCBub2RlLnRhZyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlc2NlbmQgJiYgbm9kZS5jaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICAgIG5vZGUuY2hpbGRbJ3JldHVybiddID0gbm9kZTtcbiAgICAgICAgICBub2RlID0gbm9kZS5jaGlsZDtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAobm9kZS5zaWJsaW5nID09PSBudWxsKSB7XG4gICAgICAgICAgaWYgKG5vZGVbJ3JldHVybiddID09PSBzdGFydGluZ05vZGUpIHtcbiAgICAgICAgICAgIGJyZWFrIG91dGVyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBub2RlID0gbm9kZVsncmV0dXJuJ107XG4gICAgICAgIH1cbiAgICAgICAgbm9kZS5zaWJsaW5nWydyZXR1cm4nXSA9IG5vZGVbJ3JldHVybiddO1xuICAgICAgICBub2RlID0gbm9kZS5zaWJsaW5nO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNoaWxkcmVuO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBSZWFjdFRlc3RJbnN0YW5jZTtcbn0oKTtcblxuZnVuY3Rpb24gX2ZpbmRBbGwocm9vdCwgcHJlZGljYXRlLCBvcHRpb25zKSB7XG4gIHZhciBkZWVwID0gb3B0aW9ucyA/IG9wdGlvbnMuZGVlcCA6IHRydWU7XG4gIHZhciByZXN1bHRzID0gW107XG5cbiAgaWYgKHByZWRpY2F0ZShyb290KSkge1xuICAgIHJlc3VsdHMucHVzaChyb290KTtcbiAgICBpZiAoIWRlZXApIHtcbiAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH1cbiAgfVxuXG4gIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZTtcbiAgdmFyIF9kaWRJdGVyYXRvckVycm9yID0gZmFsc2U7XG4gIHZhciBfaXRlcmF0b3JFcnJvciA9IHVuZGVmaW5lZDtcblxuICB0cnkge1xuICAgIGZvciAodmFyIF9pdGVyYXRvciA9IHJvb3QuY2hpbGRyZW5bU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gKF9zdGVwID0gX2l0ZXJhdG9yLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlKSB7XG4gICAgICB2YXIgY2hpbGQgPSBfc3RlcC52YWx1ZTtcblxuICAgICAgaWYgKHR5cGVvZiBjaGlsZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICByZXN1bHRzLnB1c2guYXBwbHkocmVzdWx0cywgX2ZpbmRBbGwoY2hpbGQsIHByZWRpY2F0ZSwgb3B0aW9ucykpO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgX2RpZEl0ZXJhdG9yRXJyb3IgPSB0cnVlO1xuICAgIF9pdGVyYXRvckVycm9yID0gZXJyO1xuICB9IGZpbmFsbHkge1xuICAgIHRyeSB7XG4gICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gJiYgX2l0ZXJhdG9yWydyZXR1cm4nXSkge1xuICAgICAgICBfaXRlcmF0b3JbJ3JldHVybiddKCk7XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcikge1xuICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0cztcbn1cblxuZnVuY3Rpb24gZXhwZWN0T25lKGFsbCwgbWVzc2FnZSkge1xuICBpZiAoYWxsLmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiBhbGxbMF07XG4gIH1cblxuICB2YXIgcHJlZml4ID0gYWxsLmxlbmd0aCA9PT0gMCA/ICdObyBpbnN0YW5jZXMgZm91bmQgJyA6ICdFeHBlY3RlZCAxIGJ1dCBmb3VuZCAnICsgYWxsLmxlbmd0aCArICcgaW5zdGFuY2VzICc7XG5cbiAgdGhyb3cgbmV3IEVycm9yKHByZWZpeCArIG1lc3NhZ2UpO1xufVxuXG5mdW5jdGlvbiBwcm9wc01hdGNoKHByb3BzLCBmaWx0ZXIpIHtcbiAgZm9yICh2YXIga2V5IGluIGZpbHRlcikge1xuICAgIGlmIChwcm9wc1trZXldICE9PSBmaWx0ZXJba2V5XSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxudmFyIFJlYWN0VGVzdFJlbmRlcmVyRmliZXIgPSB7XG4gIGNyZWF0ZTogZnVuY3Rpb24gKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICB2YXIgY3JlYXRlTm9kZU1vY2sgPSBkZWZhdWx0VGVzdE9wdGlvbnMuY3JlYXRlTm9kZU1vY2s7XG4gICAgaWYgKG9wdGlvbnMgJiYgdHlwZW9mIG9wdGlvbnMuY3JlYXRlTm9kZU1vY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNyZWF0ZU5vZGVNb2NrID0gb3B0aW9ucy5jcmVhdGVOb2RlTW9jaztcbiAgICB9XG4gICAgdmFyIGNvbnRhaW5lciA9IHtcbiAgICAgIGNoaWxkcmVuOiBbXSxcbiAgICAgIGNyZWF0ZU5vZGVNb2NrOiBjcmVhdGVOb2RlTW9jayxcbiAgICAgIHRhZzogJ0NPTlRBSU5FUidcbiAgICB9O1xuICAgIHZhciByb290ID0gVGVzdFJlbmRlcmVyLmNyZWF0ZUNvbnRhaW5lcihjb250YWluZXIsIGZhbHNlKTtcbiAgICAhKHJvb3QgIT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdzb21ldGhpbmcgd2VudCB3cm9uZycpIDogdm9pZCAwO1xuICAgIFRlc3RSZW5kZXJlci51cGRhdGVDb250YWluZXIoZWxlbWVudCwgcm9vdCwgbnVsbCwgbnVsbCk7XG5cbiAgICB2YXIgZW50cnkgPSB7XG4gICAgICByb290OiB1bmRlZmluZWQsIC8vIG1ha2VzIGZsb3cgaGFwcHlcbiAgICAgIC8vIHdlIGRlZmluZSBhICdnZXR0ZXInIGZvciAncm9vdCcgYmVsb3cgdXNpbmcgJ09iamVjdC5kZWZpbmVQcm9wZXJ0eSdcbiAgICAgIHRvSlNPTjogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAocm9vdCA9PSBudWxsIHx8IHJvb3QuY3VycmVudCA9PSBudWxsIHx8IGNvbnRhaW5lciA9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbnRhaW5lci5jaGlsZHJlbi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29udGFpbmVyLmNoaWxkcmVuLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIHJldHVybiB0b0pTT04oY29udGFpbmVyLmNoaWxkcmVuWzBdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29udGFpbmVyLmNoaWxkcmVuLm1hcCh0b0pTT04pO1xuICAgICAgfSxcbiAgICAgIHRvVHJlZTogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAocm9vdCA9PSBudWxsIHx8IHJvb3QuY3VycmVudCA9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRvVHJlZShyb290LmN1cnJlbnQpO1xuICAgICAgfSxcbiAgICAgIHVwZGF0ZTogZnVuY3Rpb24gKG5ld0VsZW1lbnQpIHtcbiAgICAgICAgaWYgKHJvb3QgPT0gbnVsbCB8fCByb290LmN1cnJlbnQgPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBUZXN0UmVuZGVyZXIudXBkYXRlQ29udGFpbmVyKG5ld0VsZW1lbnQsIHJvb3QsIG51bGwsIG51bGwpO1xuICAgICAgfSxcbiAgICAgIHVubW91bnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHJvb3QgPT0gbnVsbCB8fCByb290LmN1cnJlbnQgPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBUZXN0UmVuZGVyZXIudXBkYXRlQ29udGFpbmVyKG51bGwsIHJvb3QsIG51bGwpO1xuICAgICAgICBjb250YWluZXIgPSBudWxsO1xuICAgICAgICByb290ID0gbnVsbDtcbiAgICAgIH0sXG4gICAgICBnZXRJbnN0YW5jZTogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAocm9vdCA9PSBudWxsIHx8IHJvb3QuY3VycmVudCA9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFRlc3RSZW5kZXJlci5nZXRQdWJsaWNSb290SW5zdGFuY2Uocm9vdCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbnRyeSwgJ3Jvb3QnLCB7XG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChyb290ID09PSBudWxsIHx8IHJvb3QuY3VycmVudC5jaGlsZCA9PT0gbnVsbCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbid0IGFjY2VzcyAucm9vdCBvbiB1bm1vdW50ZWQgdGVzdCByZW5kZXJlclwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JhcEZpYmVyKHJvb3QuY3VycmVudC5jaGlsZCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gZW50cnk7XG4gIH0sXG5cblxuICAvKiBlc2xpbnQtZGlzYWJsZSBjYW1lbGNhc2UgKi9cbiAgdW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXM6IGJhdGNoZWRVcGRhdGVzXG59O1xuXG5cblxudmFyIFJlYWN0VGVzdFJlbmRlcmVyID0gT2JqZWN0LmZyZWV6ZSh7XG5cdGRlZmF1bHQ6IFJlYWN0VGVzdFJlbmRlcmVyRmliZXJcbn0pO1xuXG52YXIgUmVhY3RUZXN0UmVuZGVyZXIkMSA9ICggUmVhY3RUZXN0UmVuZGVyZXIgJiYgUmVhY3RUZXN0UmVuZGVyZXJGaWJlciApIHx8IFJlYWN0VGVzdFJlbmRlcmVyO1xuXG4vLyBUT0RPOiBkZWNpZGUgb24gdGhlIHRvcC1sZXZlbCBleHBvcnQgZm9ybS5cbi8vIFRoaXMgaXMgaGFja3kgYnV0IG1ha2VzIGl0IHdvcmsgd2l0aCBib3RoIFJvbGx1cCBhbmQgSmVzdC5cbnZhciByZWFjdFRlc3RSZW5kZXJlciA9IFJlYWN0VGVzdFJlbmRlcmVyJDFbJ2RlZmF1bHQnXSA/IFJlYWN0VGVzdFJlbmRlcmVyJDFbJ2RlZmF1bHQnXSA6IFJlYWN0VGVzdFJlbmRlcmVyJDE7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVhY3RUZXN0UmVuZGVyZXI7XG4gIH0pKCk7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QtdGVzdC1yZW5kZXJlci9janMvcmVhY3QtdGVzdC1yZW5kZXJlci5kZXZlbG9wbWVudC5qcyIsIi8qKiBAbGljZW5zZSBSZWFjdCB2MTYuMi4wXG4gKiByZWFjdC10ZXN0LXJlbmRlcmVyLnByb2R1Y3Rpb24ubWluLmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO3ZhciBuPXJlcXVpcmUoXCJvYmplY3QtYXNzaWduXCIpLGRhPXJlcXVpcmUoXCJyZWFjdFwiKSxGPXJlcXVpcmUoXCJmYmpzL2xpYi9lbXB0eU9iamVjdFwiKSxoYT1yZXF1aXJlKFwiZmJqcy9saWIvc2hhbGxvd0VxdWFsXCIpO1xuZnVuY3Rpb24gSyhhKXtmb3IodmFyIGI9YXJndW1lbnRzLmxlbmd0aC0xLGQ9XCJNaW5pZmllZCBSZWFjdCBlcnJvciAjXCIrYStcIjsgdmlzaXQgaHR0cDovL2ZhY2Vib29rLmdpdGh1Yi5pby9yZWFjdC9kb2NzL2Vycm9yLWRlY29kZXIuaHRtbD9pbnZhcmlhbnRcXHgzZFwiK2EsYz0wO2M8YjtjKyspZCs9XCJcXHgyNmFyZ3NbXVxceDNkXCIrZW5jb2RlVVJJQ29tcG9uZW50KGFyZ3VtZW50c1tjKzFdKTtiPUVycm9yKGQrXCIgZm9yIHRoZSBmdWxsIG1lc3NhZ2Ugb3IgdXNlIHRoZSBub24tbWluaWZpZWQgZGV2IGVudmlyb25tZW50IGZvciBmdWxsIGVycm9ycyBhbmQgYWRkaXRpb25hbCBoZWxwZnVsIHdhcm5pbmdzLlwiKTtiLm5hbWU9XCJJbnZhcmlhbnQgVmlvbGF0aW9uXCI7Yi5mcmFtZXNUb1BvcD0xO3Rocm93IGI7fXZhciBpYT1kYS5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRC5SZWFjdEN1cnJlbnRPd25lcjtcbmZ1bmN0aW9uIGphKGEpe2E9YS50eXBlO3JldHVyblwic3RyaW5nXCI9PT10eXBlb2YgYT9hOlwiZnVuY3Rpb25cIj09PXR5cGVvZiBhP2EuZGlzcGxheU5hbWV8fGEubmFtZTpudWxsfWZ1bmN0aW9uIGthKGEpe3ZhciBiPWE7aWYoYS5hbHRlcm5hdGUpZm9yKDtiW1wicmV0dXJuXCJdOyliPWJbXCJyZXR1cm5cIl07ZWxzZXtpZigwIT09KGIuZWZmZWN0VGFnJjIpKXJldHVybiAxO2Zvcig7YltcInJldHVyblwiXTspaWYoYj1iW1wicmV0dXJuXCJdLDAhPT0oYi5lZmZlY3RUYWcmMikpcmV0dXJuIDF9cmV0dXJuIDM9PT1iLnRhZz8yOjN9ZnVuY3Rpb24gbGEoYSl7cmV0dXJuKGE9YS5fcmVhY3RJbnRlcm5hbEZpYmVyKT8yPT09a2EoYSk6ITF9ZnVuY3Rpb24gbWEoYSl7MiE9PWthKGEpP0soXCIxODhcIik6dm9pZCAwfVxuZnVuY3Rpb24gbmEoYSl7dmFyIGI9YS5hbHRlcm5hdGU7aWYoIWIpcmV0dXJuIGI9a2EoYSksMz09PWI/SyhcIjE4OFwiKTp2b2lkIDAsMT09PWI/bnVsbDphO2Zvcih2YXIgZD1hLGM9Yjs7KXt2YXIgZT1kW1wicmV0dXJuXCJdLHA9ZT9lLmFsdGVybmF0ZTpudWxsO2lmKCFlfHwhcClicmVhaztpZihlLmNoaWxkPT09cC5jaGlsZCl7Zm9yKHZhciBrPWUuY2hpbGQ7azspe2lmKGs9PT1kKXJldHVybiBtYShlKSxhO2lmKGs9PT1jKXJldHVybiBtYShlKSxiO2s9ay5zaWJsaW5nfUsoXCIxODhcIil9aWYoZFtcInJldHVyblwiXSE9PWNbXCJyZXR1cm5cIl0pZD1lLGM9cDtlbHNle2s9ITE7Zm9yKHZhciBnPWUuY2hpbGQ7Zzspe2lmKGc9PT1kKXtrPSEwO2Q9ZTtjPXA7YnJlYWt9aWYoZz09PWMpe2s9ITA7Yz1lO2Q9cDticmVha31nPWcuc2libGluZ31pZighayl7Zm9yKGc9cC5jaGlsZDtnOyl7aWYoZz09PWQpe2s9ITA7ZD1wO2M9ZTticmVha31pZihnPT09Yyl7az0hMDtjPXA7ZD1lO2JyZWFrfWc9Zy5zaWJsaW5nfWs/XG52b2lkIDA6SyhcIjE4OVwiKX19ZC5hbHRlcm5hdGUhPT1jP0soXCIxOTBcIik6dm9pZCAwfTMhPT1kLnRhZz9LKFwiMTg4XCIpOnZvaWQgMDtyZXR1cm4gZC5zdGF0ZU5vZGUuY3VycmVudD09PWQ/YTpifWZ1bmN0aW9uIG9hKGEpe2E9bmEoYSk7aWYoIWEpcmV0dXJuIG51bGw7Zm9yKHZhciBiPWE7Oyl7aWYoNT09PWIudGFnfHw2PT09Yi50YWcpcmV0dXJuIGI7aWYoYi5jaGlsZCliLmNoaWxkW1wicmV0dXJuXCJdPWIsYj1iLmNoaWxkO2Vsc2V7aWYoYj09PWEpYnJlYWs7Zm9yKDshYi5zaWJsaW5nOyl7aWYoIWJbXCJyZXR1cm5cIl18fGJbXCJyZXR1cm5cIl09PT1hKXJldHVybiBudWxsO2I9YltcInJldHVyblwiXX1iLnNpYmxpbmdbXCJyZXR1cm5cIl09YltcInJldHVyblwiXTtiPWIuc2libGluZ319cmV0dXJuIG51bGx9XG5mdW5jdGlvbiBwYShhKXthPW5hKGEpO2lmKCFhKXJldHVybiBudWxsO2Zvcih2YXIgYj1hOzspe2lmKDU9PT1iLnRhZ3x8Nj09PWIudGFnKXJldHVybiBiO2lmKGIuY2hpbGQmJjQhPT1iLnRhZyliLmNoaWxkW1wicmV0dXJuXCJdPWIsYj1iLmNoaWxkO2Vsc2V7aWYoYj09PWEpYnJlYWs7Zm9yKDshYi5zaWJsaW5nOyl7aWYoIWJbXCJyZXR1cm5cIl18fGJbXCJyZXR1cm5cIl09PT1hKXJldHVybiBudWxsO2I9YltcInJldHVyblwiXX1iLnNpYmxpbmdbXCJyZXR1cm5cIl09YltcInJldHVyblwiXTtiPWIuc2libGluZ319cmV0dXJuIG51bGx9dmFyIHNhPVtdLEw9LTE7ZnVuY3Rpb24gTShhKXswPkx8fChhLmN1cnJlbnQ9c2FbTF0sc2FbTF09bnVsbCxMLS0pfWZ1bmN0aW9uIE4oYSxiKXtMKys7c2FbTF09YS5jdXJyZW50O2EuY3VycmVudD1ifW5ldyBTZXQ7dmFyIE89e2N1cnJlbnQ6Rn0sUT17Y3VycmVudDohMX0sdGE9RjtmdW5jdGlvbiB1YShhKXtyZXR1cm4gdmEoYSk/dGE6Ty5jdXJyZW50fVxuZnVuY3Rpb24gd2EoYSxiKXt2YXIgZD1hLnR5cGUuY29udGV4dFR5cGVzO2lmKCFkKXJldHVybiBGO3ZhciBjPWEuc3RhdGVOb2RlO2lmKGMmJmMuX19yZWFjdEludGVybmFsTWVtb2l6ZWRVbm1hc2tlZENoaWxkQ29udGV4dD09PWIpcmV0dXJuIGMuX19yZWFjdEludGVybmFsTWVtb2l6ZWRNYXNrZWRDaGlsZENvbnRleHQ7dmFyIGU9e30scDtmb3IocCBpbiBkKWVbcF09YltwXTtjJiYoYT1hLnN0YXRlTm9kZSxhLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkVW5tYXNrZWRDaGlsZENvbnRleHQ9YixhLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkTWFza2VkQ2hpbGRDb250ZXh0PWUpO3JldHVybiBlfWZ1bmN0aW9uIHZhKGEpe3JldHVybiAyPT09YS50YWcmJm51bGwhPWEudHlwZS5jaGlsZENvbnRleHRUeXBlc31mdW5jdGlvbiB4YShhKXt2YShhKSYmKE0oUSxhKSxNKE8sYSkpfVxuZnVuY3Rpb24geWEoYSxiLGQpe251bGwhPU8uY3Vyc29yP0soXCIxNjhcIik6dm9pZCAwO04oTyxiLGEpO04oUSxkLGEpfWZ1bmN0aW9uIHphKGEsYil7dmFyIGQ9YS5zdGF0ZU5vZGUsYz1hLnR5cGUuY2hpbGRDb250ZXh0VHlwZXM7aWYoXCJmdW5jdGlvblwiIT09dHlwZW9mIGQuZ2V0Q2hpbGRDb250ZXh0KXJldHVybiBiO2Q9ZC5nZXRDaGlsZENvbnRleHQoKTtmb3IodmFyIGUgaW4gZCllIGluIGM/dm9pZCAwOksoXCIxMDhcIixqYShhKXx8XCJVbmtub3duXCIsZSk7cmV0dXJuIG4oe30sYixkKX1mdW5jdGlvbiBBYShhKXtpZighdmEoYSkpcmV0dXJuITE7dmFyIGI9YS5zdGF0ZU5vZGU7Yj1iJiZiLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkTWVyZ2VkQ2hpbGRDb250ZXh0fHxGO3RhPU8uY3VycmVudDtOKE8sYixhKTtOKFEsUS5jdXJyZW50LGEpO3JldHVybiEwfVxuZnVuY3Rpb24gQmEoYSxiKXt2YXIgZD1hLnN0YXRlTm9kZTtkP3ZvaWQgMDpLKFwiMTY5XCIpO2lmKGIpe3ZhciBjPXphKGEsdGEpO2QuX19yZWFjdEludGVybmFsTWVtb2l6ZWRNZXJnZWRDaGlsZENvbnRleHQ9YztNKFEsYSk7TShPLGEpO04oTyxjLGEpfWVsc2UgTShRLGEpO04oUSxiLGEpfVxuZnVuY3Rpb24gWChhLGIsZCl7dGhpcy50YWc9YTt0aGlzLmtleT1iO3RoaXMuc3RhdGVOb2RlPXRoaXMudHlwZT1udWxsO3RoaXMuc2libGluZz10aGlzLmNoaWxkPXRoaXNbXCJyZXR1cm5cIl09bnVsbDt0aGlzLmluZGV4PTA7dGhpcy5tZW1vaXplZFN0YXRlPXRoaXMudXBkYXRlUXVldWU9dGhpcy5tZW1vaXplZFByb3BzPXRoaXMucGVuZGluZ1Byb3BzPXRoaXMucmVmPW51bGw7dGhpcy5pbnRlcm5hbENvbnRleHRUYWc9ZDt0aGlzLmVmZmVjdFRhZz0wO3RoaXMubGFzdEVmZmVjdD10aGlzLmZpcnN0RWZmZWN0PXRoaXMubmV4dEVmZmVjdD1udWxsO3RoaXMuZXhwaXJhdGlvblRpbWU9MDt0aGlzLmFsdGVybmF0ZT1udWxsfVxuZnVuY3Rpb24gQ2EoYSxiLGQpe3ZhciBjPWEuYWx0ZXJuYXRlO251bGw9PT1jPyhjPW5ldyBYKGEudGFnLGEua2V5LGEuaW50ZXJuYWxDb250ZXh0VGFnKSxjLnR5cGU9YS50eXBlLGMuc3RhdGVOb2RlPWEuc3RhdGVOb2RlLGMuYWx0ZXJuYXRlPWEsYS5hbHRlcm5hdGU9Yyk6KGMuZWZmZWN0VGFnPTAsYy5uZXh0RWZmZWN0PW51bGwsYy5maXJzdEVmZmVjdD1udWxsLGMubGFzdEVmZmVjdD1udWxsKTtjLmV4cGlyYXRpb25UaW1lPWQ7Yy5wZW5kaW5nUHJvcHM9YjtjLmNoaWxkPWEuY2hpbGQ7Yy5tZW1vaXplZFByb3BzPWEubWVtb2l6ZWRQcm9wcztjLm1lbW9pemVkU3RhdGU9YS5tZW1vaXplZFN0YXRlO2MudXBkYXRlUXVldWU9YS51cGRhdGVRdWV1ZTtjLnNpYmxpbmc9YS5zaWJsaW5nO2MuaW5kZXg9YS5pbmRleDtjLnJlZj1hLnJlZjtyZXR1cm4gY31cbmZ1bmN0aW9uIERhKGEsYixkKXt2YXIgYz12b2lkIDAsZT1hLnR5cGUscD1hLmtleTtcImZ1bmN0aW9uXCI9PT10eXBlb2YgZT8oYz1lLnByb3RvdHlwZSYmZS5wcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudD9uZXcgWCgyLHAsYik6bmV3IFgoMCxwLGIpLGMudHlwZT1lLGMucGVuZGluZ1Byb3BzPWEucHJvcHMpOlwic3RyaW5nXCI9PT10eXBlb2YgZT8oYz1uZXcgWCg1LHAsYiksYy50eXBlPWUsYy5wZW5kaW5nUHJvcHM9YS5wcm9wcyk6XCJvYmplY3RcIj09PXR5cGVvZiBlJiZudWxsIT09ZSYmXCJudW1iZXJcIj09PXR5cGVvZiBlLnRhZz8oYz1lLGMucGVuZGluZ1Byb3BzPWEucHJvcHMpOksoXCIxMzBcIixudWxsPT1lP2U6dHlwZW9mIGUsXCJcIik7Yy5leHBpcmF0aW9uVGltZT1kO3JldHVybiBjfWZ1bmN0aW9uIEVhKGEsYixkLGMpe2I9bmV3IFgoMTAsYyxiKTtiLnBlbmRpbmdQcm9wcz1hO2IuZXhwaXJhdGlvblRpbWU9ZDtyZXR1cm4gYn1cbmZ1bmN0aW9uIEZhKGEsYixkKXtiPW5ldyBYKDYsbnVsbCxiKTtiLnBlbmRpbmdQcm9wcz1hO2IuZXhwaXJhdGlvblRpbWU9ZDtyZXR1cm4gYn1mdW5jdGlvbiBHYShhLGIsZCl7Yj1uZXcgWCg3LGEua2V5LGIpO2IudHlwZT1hLmhhbmRsZXI7Yi5wZW5kaW5nUHJvcHM9YTtiLmV4cGlyYXRpb25UaW1lPWQ7cmV0dXJuIGJ9ZnVuY3Rpb24gSGEoYSxiLGQpe2E9bmV3IFgoOSxudWxsLGIpO2EuZXhwaXJhdGlvblRpbWU9ZDtyZXR1cm4gYX1mdW5jdGlvbiBJYShhLGIsZCl7Yj1uZXcgWCg0LGEua2V5LGIpO2IucGVuZGluZ1Byb3BzPWEuY2hpbGRyZW58fFtdO2IuZXhwaXJhdGlvblRpbWU9ZDtiLnN0YXRlTm9kZT17Y29udGFpbmVySW5mbzphLmNvbnRhaW5lckluZm8scGVuZGluZ0NoaWxkcmVuOm51bGwsaW1wbGVtZW50YXRpb246YS5pbXBsZW1lbnRhdGlvbn07cmV0dXJuIGJ9dmFyIE9hPW51bGwsUGE9bnVsbDtcbmZ1bmN0aW9uIFFhKGEpe3JldHVybiBmdW5jdGlvbihiKXt0cnl7cmV0dXJuIGEoYil9Y2F0Y2goZCl7fX19ZnVuY3Rpb24gUmEoYSl7aWYoXCJ1bmRlZmluZWRcIj09PXR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18pcmV0dXJuITE7dmFyIGI9X19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fO2lmKGIuaXNEaXNhYmxlZHx8IWIuc3VwcG9ydHNGaWJlcilyZXR1cm4hMDt0cnl7dmFyIGQ9Yi5pbmplY3QoYSk7T2E9UWEoZnVuY3Rpb24oYSl7cmV0dXJuIGIub25Db21taXRGaWJlclJvb3QoZCxhKX0pO1BhPVFhKGZ1bmN0aW9uKGEpe3JldHVybiBiLm9uQ29tbWl0RmliZXJVbm1vdW50KGQsYSl9KX1jYXRjaChjKXt9cmV0dXJuITB9ZnVuY3Rpb24gU2EoYSl7XCJmdW5jdGlvblwiPT09dHlwZW9mIE9hJiZPYShhKX1mdW5jdGlvbiBUYShhKXtcImZ1bmN0aW9uXCI9PT10eXBlb2YgUGEmJlBhKGEpfVxuZnVuY3Rpb24gVWEoYSl7cmV0dXJue2Jhc2VTdGF0ZTphLGV4cGlyYXRpb25UaW1lOjAsZmlyc3Q6bnVsbCxsYXN0Om51bGwsY2FsbGJhY2tMaXN0Om51bGwsaGFzRm9yY2VVcGRhdGU6ITEsaXNJbml0aWFsaXplZDohMX19ZnVuY3Rpb24gVmEoYSxiKXtudWxsPT09YS5sYXN0P2EuZmlyc3Q9YS5sYXN0PWI6KGEubGFzdC5uZXh0PWIsYS5sYXN0PWIpO2lmKDA9PT1hLmV4cGlyYXRpb25UaW1lfHxhLmV4cGlyYXRpb25UaW1lPmIuZXhwaXJhdGlvblRpbWUpYS5leHBpcmF0aW9uVGltZT1iLmV4cGlyYXRpb25UaW1lfVxuZnVuY3Rpb24gV2EoYSxiKXt2YXIgZD1hLmFsdGVybmF0ZSxjPWEudXBkYXRlUXVldWU7bnVsbD09PWMmJihjPWEudXBkYXRlUXVldWU9VWEobnVsbCkpO251bGwhPT1kPyhhPWQudXBkYXRlUXVldWUsbnVsbD09PWEmJihhPWQudXBkYXRlUXVldWU9VWEobnVsbCkpKTphPW51bGw7YT1hIT09Yz9hOm51bGw7bnVsbD09PWE/VmEoYyxiKTpudWxsPT09Yy5sYXN0fHxudWxsPT09YS5sYXN0PyhWYShjLGIpLFZhKGEsYikpOihWYShjLGIpLGEubGFzdD1iKX1mdW5jdGlvbiBYYShhLGIsZCxjKXthPWEucGFydGlhbFN0YXRlO3JldHVyblwiZnVuY3Rpb25cIj09PXR5cGVvZiBhP2EuY2FsbChiLGQsYyk6YX1cbmZ1bmN0aW9uIGdiKGEsYixkLGMsZSxwKXtudWxsIT09YSYmYS51cGRhdGVRdWV1ZT09PWQmJihkPWIudXBkYXRlUXVldWU9e2Jhc2VTdGF0ZTpkLmJhc2VTdGF0ZSxleHBpcmF0aW9uVGltZTpkLmV4cGlyYXRpb25UaW1lLGZpcnN0OmQuZmlyc3QsbGFzdDpkLmxhc3QsaXNJbml0aWFsaXplZDpkLmlzSW5pdGlhbGl6ZWQsY2FsbGJhY2tMaXN0Om51bGwsaGFzRm9yY2VVcGRhdGU6ITF9KTtkLmV4cGlyYXRpb25UaW1lPTA7ZC5pc0luaXRpYWxpemVkP2E9ZC5iYXNlU3RhdGU6KGE9ZC5iYXNlU3RhdGU9Yi5tZW1vaXplZFN0YXRlLGQuaXNJbml0aWFsaXplZD0hMCk7Zm9yKHZhciBrPSEwLGc9ZC5maXJzdCxsPSExO251bGwhPT1nOyl7dmFyIHU9Zy5leHBpcmF0aW9uVGltZTtpZih1PnApe3ZhciBBPWQuZXhwaXJhdGlvblRpbWU7aWYoMD09PUF8fEE+dSlkLmV4cGlyYXRpb25UaW1lPXU7bHx8KGw9ITAsZC5iYXNlU3RhdGU9YSl9ZWxzZXtsfHwoZC5maXJzdD1nLm5leHQsbnVsbD09PVxuZC5maXJzdCYmKGQubGFzdD1udWxsKSk7aWYoZy5pc1JlcGxhY2UpYT1YYShnLGMsYSxlKSxrPSEwO2Vsc2UgaWYodT1YYShnLGMsYSxlKSlhPWs/bih7fSxhLHUpOm4oYSx1KSxrPSExO2cuaXNGb3JjZWQmJihkLmhhc0ZvcmNlVXBkYXRlPSEwKTtudWxsIT09Zy5jYWxsYmFjayYmKHU9ZC5jYWxsYmFja0xpc3QsbnVsbD09PXUmJih1PWQuY2FsbGJhY2tMaXN0PVtdKSx1LnB1c2goZykpfWc9Zy5uZXh0fW51bGwhPT1kLmNhbGxiYWNrTGlzdD9iLmVmZmVjdFRhZ3w9MzI6bnVsbCE9PWQuZmlyc3R8fGQuaGFzRm9yY2VVcGRhdGV8fChiLnVwZGF0ZVF1ZXVlPW51bGwpO2x8fChkLmJhc2VTdGF0ZT1hKTtyZXR1cm4gYX1cbmZ1bmN0aW9uIGhiKGEsYil7dmFyIGQ9YS5jYWxsYmFja0xpc3Q7aWYobnVsbCE9PWQpZm9yKGEuY2FsbGJhY2tMaXN0PW51bGwsYT0wO2E8ZC5sZW5ndGg7YSsrKXt2YXIgYz1kW2FdLGU9Yy5jYWxsYmFjaztjLmNhbGxiYWNrPW51bGw7XCJmdW5jdGlvblwiIT09dHlwZW9mIGU/SyhcIjE5MVwiLGUpOnZvaWQgMDtlLmNhbGwoYil9fVxuZnVuY3Rpb24gaWIoYSxiLGQsYyl7ZnVuY3Rpb24gZShhLGIpe2IudXBkYXRlcj1wO2Euc3RhdGVOb2RlPWI7Yi5fcmVhY3RJbnRlcm5hbEZpYmVyPWF9dmFyIHA9e2lzTW91bnRlZDpsYSxlbnF1ZXVlU2V0U3RhdGU6ZnVuY3Rpb24oZCxjLGUpe2Q9ZC5fcmVhY3RJbnRlcm5hbEZpYmVyO2U9dm9pZCAwPT09ZT9udWxsOmU7dmFyIGs9YihkKTtXYShkLHtleHBpcmF0aW9uVGltZTprLHBhcnRpYWxTdGF0ZTpjLGNhbGxiYWNrOmUsaXNSZXBsYWNlOiExLGlzRm9yY2VkOiExLG5leHRDYWxsYmFjazpudWxsLG5leHQ6bnVsbH0pO2EoZCxrKX0sZW5xdWV1ZVJlcGxhY2VTdGF0ZTpmdW5jdGlvbihkLGMsZSl7ZD1kLl9yZWFjdEludGVybmFsRmliZXI7ZT12b2lkIDA9PT1lP251bGw6ZTt2YXIgZz1iKGQpO1dhKGQse2V4cGlyYXRpb25UaW1lOmcscGFydGlhbFN0YXRlOmMsY2FsbGJhY2s6ZSxpc1JlcGxhY2U6ITAsaXNGb3JjZWQ6ITEsbmV4dENhbGxiYWNrOm51bGwsbmV4dDpudWxsfSk7XG5hKGQsZyl9LGVucXVldWVGb3JjZVVwZGF0ZTpmdW5jdGlvbihkLGMpe2Q9ZC5fcmVhY3RJbnRlcm5hbEZpYmVyO2M9dm9pZCAwPT09Yz9udWxsOmM7dmFyIGU9YihkKTtXYShkLHtleHBpcmF0aW9uVGltZTplLHBhcnRpYWxTdGF0ZTpudWxsLGNhbGxiYWNrOmMsaXNSZXBsYWNlOiExLGlzRm9yY2VkOiEwLG5leHRDYWxsYmFjazpudWxsLG5leHQ6bnVsbH0pO2EoZCxlKX19O3JldHVybnthZG9wdENsYXNzSW5zdGFuY2U6ZSxjb25zdHJ1Y3RDbGFzc0luc3RhbmNlOmZ1bmN0aW9uKGEsYil7dmFyIGQ9YS50eXBlLGM9dWEoYSksZz0yPT09YS50YWcmJm51bGwhPWEudHlwZS5jb250ZXh0VHlwZXMsaz1nP3dhKGEsYyk6RjtiPW5ldyBkKGIsayk7ZShhLGIpO2cmJihhPWEuc3RhdGVOb2RlLGEuX19yZWFjdEludGVybmFsTWVtb2l6ZWRVbm1hc2tlZENoaWxkQ29udGV4dD1jLGEuX19yZWFjdEludGVybmFsTWVtb2l6ZWRNYXNrZWRDaGlsZENvbnRleHQ9ayk7cmV0dXJuIGJ9LG1vdW50Q2xhc3NJbnN0YW5jZTpmdW5jdGlvbihhLFxuYil7dmFyIGQ9YS5hbHRlcm5hdGUsYz1hLnN0YXRlTm9kZSxlPWMuc3RhdGV8fG51bGwsZz1hLnBlbmRpbmdQcm9wcztnP3ZvaWQgMDpLKFwiMTU4XCIpO3ZhciBrPXVhKGEpO2MucHJvcHM9ZztjLnN0YXRlPWEubWVtb2l6ZWRTdGF0ZT1lO2MucmVmcz1GO2MuY29udGV4dD13YShhLGspO251bGwhPWEudHlwZSYmbnVsbCE9YS50eXBlLnByb3RvdHlwZSYmITA9PT1hLnR5cGUucHJvdG90eXBlLnVuc3RhYmxlX2lzQXN5bmNSZWFjdENvbXBvbmVudCYmKGEuaW50ZXJuYWxDb250ZXh0VGFnfD0xKTtcImZ1bmN0aW9uXCI9PT10eXBlb2YgYy5jb21wb25lbnRXaWxsTW91bnQmJihlPWMuc3RhdGUsYy5jb21wb25lbnRXaWxsTW91bnQoKSxlIT09Yy5zdGF0ZSYmcC5lbnF1ZXVlUmVwbGFjZVN0YXRlKGMsYy5zdGF0ZSxudWxsKSxlPWEudXBkYXRlUXVldWUsbnVsbCE9PWUmJihjLnN0YXRlPWdiKGQsYSxlLGMsZyxiKSkpO1wiZnVuY3Rpb25cIj09PXR5cGVvZiBjLmNvbXBvbmVudERpZE1vdW50JiYoYS5lZmZlY3RUYWd8PVxuNCl9LHVwZGF0ZUNsYXNzSW5zdGFuY2U6ZnVuY3Rpb24oYSxiLGUpe3ZhciBnPWIuc3RhdGVOb2RlO2cucHJvcHM9Yi5tZW1vaXplZFByb3BzO2cuc3RhdGU9Yi5tZW1vaXplZFN0YXRlO3ZhciBrPWIubWVtb2l6ZWRQcm9wcyxsPWIucGVuZGluZ1Byb3BzO2x8fChsPWssbnVsbD09bD9LKFwiMTU5XCIpOnZvaWQgMCk7dmFyIHc9Zy5jb250ZXh0LHg9dWEoYik7eD13YShiLHgpO1wiZnVuY3Rpb25cIiE9PXR5cGVvZiBnLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHN8fGs9PT1sJiZ3PT09eHx8KHc9Zy5zdGF0ZSxnLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobCx4KSxnLnN0YXRlIT09dyYmcC5lbnF1ZXVlUmVwbGFjZVN0YXRlKGcsZy5zdGF0ZSxudWxsKSk7dz1iLm1lbW9pemVkU3RhdGU7ZT1udWxsIT09Yi51cGRhdGVRdWV1ZT9nYihhLGIsYi51cGRhdGVRdWV1ZSxnLGwsZSk6dztpZighKGshPT1sfHx3IT09ZXx8US5jdXJyZW50fHxudWxsIT09Yi51cGRhdGVRdWV1ZSYmYi51cGRhdGVRdWV1ZS5oYXNGb3JjZVVwZGF0ZSkpcmV0dXJuXCJmdW5jdGlvblwiIT09XG50eXBlb2YgZy5jb21wb25lbnREaWRVcGRhdGV8fGs9PT1hLm1lbW9pemVkUHJvcHMmJnc9PT1hLm1lbW9pemVkU3RhdGV8fChiLmVmZmVjdFRhZ3w9NCksITE7dmFyIEI9bDtpZihudWxsPT09a3x8bnVsbCE9PWIudXBkYXRlUXVldWUmJmIudXBkYXRlUXVldWUuaGFzRm9yY2VVcGRhdGUpQj0hMDtlbHNle3ZhciBEPWIuc3RhdGVOb2RlLEc9Yi50eXBlO0I9XCJmdW5jdGlvblwiPT09dHlwZW9mIEQuc2hvdWxkQ29tcG9uZW50VXBkYXRlP0Quc2hvdWxkQ29tcG9uZW50VXBkYXRlKEIsZSx4KTpHLnByb3RvdHlwZSYmRy5wcm90b3R5cGUuaXNQdXJlUmVhY3RDb21wb25lbnQ/IWhhKGssQil8fCFoYSh3LGUpOiEwfUI/KFwiZnVuY3Rpb25cIj09PXR5cGVvZiBnLmNvbXBvbmVudFdpbGxVcGRhdGUmJmcuY29tcG9uZW50V2lsbFVwZGF0ZShsLGUseCksXCJmdW5jdGlvblwiPT09dHlwZW9mIGcuY29tcG9uZW50RGlkVXBkYXRlJiYoYi5lZmZlY3RUYWd8PTQpKTooXCJmdW5jdGlvblwiIT09dHlwZW9mIGcuY29tcG9uZW50RGlkVXBkYXRlfHxcbms9PT1hLm1lbW9pemVkUHJvcHMmJnc9PT1hLm1lbW9pemVkU3RhdGV8fChiLmVmZmVjdFRhZ3w9NCksZChiLGwpLGMoYixlKSk7Zy5wcm9wcz1sO2cuc3RhdGU9ZTtnLmNvbnRleHQ9eDtyZXR1cm4gQn19fXZhciBqYj1cImZ1bmN0aW9uXCI9PT10eXBlb2YgU3ltYm9sJiZTeW1ib2xbXCJmb3JcIl0sa2I9amI/U3ltYm9sW1wiZm9yXCJdKFwicmVhY3QuZWxlbWVudFwiKTo2MDEwMyxsYj1qYj9TeW1ib2xbXCJmb3JcIl0oXCJyZWFjdC5jYWxsXCIpOjYwMTA0LG1iPWpiP1N5bWJvbFtcImZvclwiXShcInJlYWN0LnJldHVyblwiKTo2MDEwNSxuYj1qYj9TeW1ib2xbXCJmb3JcIl0oXCJyZWFjdC5wb3J0YWxcIik6NjAxMDYsWT1qYj9TeW1ib2xbXCJmb3JcIl0oXCJyZWFjdC5mcmFnbWVudFwiKTo2MDEwNyxvYj1cImZ1bmN0aW9uXCI9PT10eXBlb2YgU3ltYm9sJiZTeW1ib2wuaXRlcmF0b3I7XG5mdW5jdGlvbiBwYihhKXtpZihudWxsPT09YXx8XCJ1bmRlZmluZWRcIj09PXR5cGVvZiBhKXJldHVybiBudWxsO2E9b2ImJmFbb2JdfHxhW1wiQEBpdGVyYXRvclwiXTtyZXR1cm5cImZ1bmN0aW9uXCI9PT10eXBlb2YgYT9hOm51bGx9dmFyIHFiPUFycmF5LmlzQXJyYXk7XG5mdW5jdGlvbiByYihhLGIpe3ZhciBkPWIucmVmO2lmKG51bGwhPT1kJiZcImZ1bmN0aW9uXCIhPT10eXBlb2YgZCl7aWYoYi5fb3duZXIpe2I9Yi5fb3duZXI7dmFyIGM9dm9pZCAwO2ImJigyIT09Yi50YWc/SyhcIjExMFwiKTp2b2lkIDAsYz1iLnN0YXRlTm9kZSk7Yz92b2lkIDA6SyhcIjE0N1wiLGQpO3ZhciBlPVwiXCIrZDtpZihudWxsIT09YSYmbnVsbCE9PWEucmVmJiZhLnJlZi5fc3RyaW5nUmVmPT09ZSlyZXR1cm4gYS5yZWY7YT1mdW5jdGlvbihhKXt2YXIgYj1jLnJlZnM9PT1GP2MucmVmcz17fTpjLnJlZnM7bnVsbD09PWE/ZGVsZXRlIGJbZV06YltlXT1hfTthLl9zdHJpbmdSZWY9ZTtyZXR1cm4gYX1cInN0cmluZ1wiIT09dHlwZW9mIGQ/SyhcIjE0OFwiKTp2b2lkIDA7Yi5fb3duZXI/dm9pZCAwOksoXCIxNDlcIixkKX1yZXR1cm4gZH1cbmZ1bmN0aW9uIHNiKGEsYil7XCJ0ZXh0YXJlYVwiIT09YS50eXBlJiZLKFwiMzFcIixcIltvYmplY3QgT2JqZWN0XVwiPT09T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGIpP1wib2JqZWN0IHdpdGgga2V5cyB7XCIrT2JqZWN0LmtleXMoYikuam9pbihcIiwgXCIpK1wifVwiOmIsXCJcIil9XG5mdW5jdGlvbiB0YihhKXtmdW5jdGlvbiBiKGIsdCl7aWYoYSl7dmFyIGY9Yi5sYXN0RWZmZWN0O251bGwhPT1mPyhmLm5leHRFZmZlY3Q9dCxiLmxhc3RFZmZlY3Q9dCk6Yi5maXJzdEVmZmVjdD1iLmxhc3RFZmZlY3Q9dDt0Lm5leHRFZmZlY3Q9bnVsbDt0LmVmZmVjdFRhZz04fX1mdW5jdGlvbiBkKGQsdCl7aWYoIWEpcmV0dXJuIG51bGw7Zm9yKDtudWxsIT09dDspYihkLHQpLHQ9dC5zaWJsaW5nO3JldHVybiBudWxsfWZ1bmN0aW9uIGMoYSxiKXtmb3IoYT1uZXcgTWFwO251bGwhPT1iOyludWxsIT09Yi5rZXk/YS5zZXQoYi5rZXksYik6YS5zZXQoYi5pbmRleCxiKSxiPWIuc2libGluZztyZXR1cm4gYX1mdW5jdGlvbiBlKGEsYixmKXthPUNhKGEsYixmKTthLmluZGV4PTA7YS5zaWJsaW5nPW51bGw7cmV0dXJuIGF9ZnVuY3Rpb24gcChiLHQsZil7Yi5pbmRleD1mO2lmKCFhKXJldHVybiB0O2Y9Yi5hbHRlcm5hdGU7aWYobnVsbCE9PWYpcmV0dXJuIGY9Zi5pbmRleCxmPHQ/KGIuZWZmZWN0VGFnPVxuMix0KTpmO2IuZWZmZWN0VGFnPTI7cmV0dXJuIHR9ZnVuY3Rpb24gayhiKXthJiZudWxsPT09Yi5hbHRlcm5hdGUmJihiLmVmZmVjdFRhZz0yKTtyZXR1cm4gYn1mdW5jdGlvbiBnKGEsYixmLGgpe2lmKG51bGw9PT1ifHw2IT09Yi50YWcpcmV0dXJuIGI9RmEoZixhLmludGVybmFsQ29udGV4dFRhZyxoKSxiW1wicmV0dXJuXCJdPWEsYjtiPWUoYixmLGgpO2JbXCJyZXR1cm5cIl09YTtyZXR1cm4gYn1mdW5jdGlvbiBsKGEsYixmLGgpe2lmKG51bGwhPT1iJiZiLnR5cGU9PT1mLnR5cGUpcmV0dXJuIGg9ZShiLGYucHJvcHMsaCksaC5yZWY9cmIoYixmKSxoW1wicmV0dXJuXCJdPWEsaDtoPURhKGYsYS5pbnRlcm5hbENvbnRleHRUYWcsaCk7aC5yZWY9cmIoYixmKTtoW1wicmV0dXJuXCJdPWE7cmV0dXJuIGh9ZnVuY3Rpb24gdShhLGIsZixoKXtpZihudWxsPT09Ynx8NyE9PWIudGFnKXJldHVybiBiPUdhKGYsYS5pbnRlcm5hbENvbnRleHRUYWcsaCksYltcInJldHVyblwiXT1hLGI7Yj1lKGIsZixoKTtcbmJbXCJyZXR1cm5cIl09YTtyZXR1cm4gYn1mdW5jdGlvbiBBKGEsYixmLGgpe2lmKG51bGw9PT1ifHw5IT09Yi50YWcpcmV0dXJuIGI9SGEoZixhLmludGVybmFsQ29udGV4dFRhZyxoKSxiLnR5cGU9Zi52YWx1ZSxiW1wicmV0dXJuXCJdPWEsYjtiPWUoYixudWxsLGgpO2IudHlwZT1mLnZhbHVlO2JbXCJyZXR1cm5cIl09YTtyZXR1cm4gYn1mdW5jdGlvbiB5KGEsYixmLGgpe2lmKG51bGw9PT1ifHw0IT09Yi50YWd8fGIuc3RhdGVOb2RlLmNvbnRhaW5lckluZm8hPT1mLmNvbnRhaW5lckluZm98fGIuc3RhdGVOb2RlLmltcGxlbWVudGF0aW9uIT09Zi5pbXBsZW1lbnRhdGlvbilyZXR1cm4gYj1JYShmLGEuaW50ZXJuYWxDb250ZXh0VGFnLGgpLGJbXCJyZXR1cm5cIl09YSxiO2I9ZShiLGYuY2hpbGRyZW58fFtdLGgpO2JbXCJyZXR1cm5cIl09YTtyZXR1cm4gYn1mdW5jdGlvbiB3KGEsYixmLGgsZCl7aWYobnVsbD09PWJ8fDEwIT09Yi50YWcpcmV0dXJuIGI9RWEoZixhLmludGVybmFsQ29udGV4dFRhZyxcbmgsZCksYltcInJldHVyblwiXT1hLGI7Yj1lKGIsZixoKTtiW1wicmV0dXJuXCJdPWE7cmV0dXJuIGJ9ZnVuY3Rpb24geChhLGIsZil7aWYoXCJzdHJpbmdcIj09PXR5cGVvZiBifHxcIm51bWJlclwiPT09dHlwZW9mIGIpcmV0dXJuIGI9RmEoXCJcIitiLGEuaW50ZXJuYWxDb250ZXh0VGFnLGYpLGJbXCJyZXR1cm5cIl09YSxiO2lmKFwib2JqZWN0XCI9PT10eXBlb2YgYiYmbnVsbCE9PWIpe3N3aXRjaChiLiQkdHlwZW9mKXtjYXNlIGtiOmlmKGIudHlwZT09PVkpcmV0dXJuIGI9RWEoYi5wcm9wcy5jaGlsZHJlbixhLmludGVybmFsQ29udGV4dFRhZyxmLGIua2V5KSxiW1wicmV0dXJuXCJdPWEsYjtmPURhKGIsYS5pbnRlcm5hbENvbnRleHRUYWcsZik7Zi5yZWY9cmIobnVsbCxiKTtmW1wicmV0dXJuXCJdPWE7cmV0dXJuIGY7Y2FzZSBsYjpyZXR1cm4gYj1HYShiLGEuaW50ZXJuYWxDb250ZXh0VGFnLGYpLGJbXCJyZXR1cm5cIl09YSxiO2Nhc2UgbWI6cmV0dXJuIGY9SGEoYixhLmludGVybmFsQ29udGV4dFRhZyxmKSxcbmYudHlwZT1iLnZhbHVlLGZbXCJyZXR1cm5cIl09YSxmO2Nhc2UgbmI6cmV0dXJuIGI9SWEoYixhLmludGVybmFsQ29udGV4dFRhZyxmKSxiW1wicmV0dXJuXCJdPWEsYn1pZihxYihiKXx8cGIoYikpcmV0dXJuIGI9RWEoYixhLmludGVybmFsQ29udGV4dFRhZyxmLG51bGwpLGJbXCJyZXR1cm5cIl09YSxiO3NiKGEsYil9cmV0dXJuIG51bGx9ZnVuY3Rpb24gQihhLGIsZixoKXt2YXIgZD1udWxsIT09Yj9iLmtleTpudWxsO2lmKFwic3RyaW5nXCI9PT10eXBlb2YgZnx8XCJudW1iZXJcIj09PXR5cGVvZiBmKXJldHVybiBudWxsIT09ZD9udWxsOmcoYSxiLFwiXCIrZixoKTtpZihcIm9iamVjdFwiPT09dHlwZW9mIGYmJm51bGwhPT1mKXtzd2l0Y2goZi4kJHR5cGVvZil7Y2FzZSBrYjpyZXR1cm4gZi5rZXk9PT1kP2YudHlwZT09PVk/dyhhLGIsZi5wcm9wcy5jaGlsZHJlbixoLGQpOmwoYSxiLGYsaCk6bnVsbDtjYXNlIGxiOnJldHVybiBmLmtleT09PWQ/dShhLGIsZixoKTpudWxsO2Nhc2UgbWI6cmV0dXJuIG51bGw9PT1cbmQ/QShhLGIsZixoKTpudWxsO2Nhc2UgbmI6cmV0dXJuIGYua2V5PT09ZD95KGEsYixmLGgpOm51bGx9aWYocWIoZil8fHBiKGYpKXJldHVybiBudWxsIT09ZD9udWxsOncoYSxiLGYsaCxudWxsKTtzYihhLGYpfXJldHVybiBudWxsfWZ1bmN0aW9uIEQoYSxiLGYsaCxkKXtpZihcInN0cmluZ1wiPT09dHlwZW9mIGh8fFwibnVtYmVyXCI9PT10eXBlb2YgaClyZXR1cm4gYT1hLmdldChmKXx8bnVsbCxnKGIsYSxcIlwiK2gsZCk7aWYoXCJvYmplY3RcIj09PXR5cGVvZiBoJiZudWxsIT09aCl7c3dpdGNoKGguJCR0eXBlb2Ype2Nhc2Uga2I6cmV0dXJuIGE9YS5nZXQobnVsbD09PWgua2V5P2Y6aC5rZXkpfHxudWxsLGgudHlwZT09PVk/dyhiLGEsaC5wcm9wcy5jaGlsZHJlbixkLGgua2V5KTpsKGIsYSxoLGQpO2Nhc2UgbGI6cmV0dXJuIGE9YS5nZXQobnVsbD09PWgua2V5P2Y6aC5rZXkpfHxudWxsLHUoYixhLGgsZCk7Y2FzZSBtYjpyZXR1cm4gYT1hLmdldChmKXx8bnVsbCxBKGIsYSxoLGQpO2Nhc2UgbmI6cmV0dXJuIGE9XG5hLmdldChudWxsPT09aC5rZXk/ZjpoLmtleSl8fG51bGwseShiLGEsaCxkKX1pZihxYihoKXx8cGIoaCkpcmV0dXJuIGE9YS5nZXQoZil8fG51bGwsdyhiLGEsaCxkLG51bGwpO3NiKGIsaCl9cmV0dXJuIG51bGx9ZnVuY3Rpb24gRyhlLHQsZixoKXtmb3IodmFyIGc9bnVsbCxyPW51bGwscT10LG09dD0wLGs9bnVsbDtudWxsIT09cSYmbTxmLmxlbmd0aDttKyspe3EuaW5kZXg+bT8oaz1xLHE9bnVsbCk6az1xLnNpYmxpbmc7dmFyIGw9QihlLHEsZlttXSxoKTtpZihudWxsPT09bCl7bnVsbD09PXEmJihxPWspO2JyZWFrfWEmJnEmJm51bGw9PT1sLmFsdGVybmF0ZSYmYihlLHEpO3Q9cChsLHQsbSk7bnVsbD09PXI/Zz1sOnIuc2libGluZz1sO3I9bDtxPWt9aWYobT09PWYubGVuZ3RoKXJldHVybiBkKGUscSksZztpZihudWxsPT09cSl7Zm9yKDttPGYubGVuZ3RoO20rKylpZihxPXgoZSxmW21dLGgpKXQ9cChxLHQsbSksbnVsbD09PXI/Zz1xOnIuc2libGluZz1xLHI9cTtyZXR1cm4gZ31mb3IocT1cbmMoZSxxKTttPGYubGVuZ3RoO20rKylpZihrPUQocSxlLG0sZlttXSxoKSl7aWYoYSYmbnVsbCE9PWsuYWx0ZXJuYXRlKXFbXCJkZWxldGVcIl0obnVsbD09PWsua2V5P206ay5rZXkpO3Q9cChrLHQsbSk7bnVsbD09PXI/Zz1rOnIuc2libGluZz1rO3I9a31hJiZxLmZvckVhY2goZnVuY3Rpb24oYSl7cmV0dXJuIGIoZSxhKX0pO3JldHVybiBnfWZ1bmN0aW9uIEgoZSx0LGYsaCl7dmFyIGc9cGIoZik7XCJmdW5jdGlvblwiIT09dHlwZW9mIGc/SyhcIjE1MFwiKTp2b2lkIDA7Zj1nLmNhbGwoZik7bnVsbD09Zj9LKFwiMTUxXCIpOnZvaWQgMDtmb3IodmFyIHI9Zz1udWxsLHE9dCxtPXQ9MCxrPW51bGwsbD1mLm5leHQoKTtudWxsIT09cSYmIWwuZG9uZTttKyssbD1mLm5leHQoKSl7cS5pbmRleD5tPyhrPXEscT1udWxsKTprPXEuc2libGluZzt2YXIgRT1CKGUscSxsLnZhbHVlLGgpO2lmKG51bGw9PT1FKXtxfHwocT1rKTticmVha31hJiZxJiZudWxsPT09RS5hbHRlcm5hdGUmJmIoZSxxKTt0PXAoRSxcbnQsbSk7bnVsbD09PXI/Zz1FOnIuc2libGluZz1FO3I9RTtxPWt9aWYobC5kb25lKXJldHVybiBkKGUscSksZztpZihudWxsPT09cSl7Zm9yKDshbC5kb25lO20rKyxsPWYubmV4dCgpKWw9eChlLGwudmFsdWUsaCksbnVsbCE9PWwmJih0PXAobCx0LG0pLG51bGw9PT1yP2c9bDpyLnNpYmxpbmc9bCxyPWwpO3JldHVybiBnfWZvcihxPWMoZSxxKTshbC5kb25lO20rKyxsPWYubmV4dCgpKWlmKGw9RChxLGUsbSxsLnZhbHVlLGgpLG51bGwhPT1sKXtpZihhJiZudWxsIT09bC5hbHRlcm5hdGUpcVtcImRlbGV0ZVwiXShudWxsPT09bC5rZXk/bTpsLmtleSk7dD1wKGwsdCxtKTtudWxsPT09cj9nPWw6ci5zaWJsaW5nPWw7cj1sfWEmJnEuZm9yRWFjaChmdW5jdGlvbihhKXtyZXR1cm4gYihlLGEpfSk7cmV0dXJuIGd9cmV0dXJuIGZ1bmN0aW9uKGEsYyxmLGgpe1wib2JqZWN0XCI9PT10eXBlb2YgZiYmbnVsbCE9PWYmJmYudHlwZT09PVkmJm51bGw9PT1mLmtleSYmKGY9Zi5wcm9wcy5jaGlsZHJlbik7XG52YXIgZz1cIm9iamVjdFwiPT09dHlwZW9mIGYmJm51bGwhPT1mO2lmKGcpc3dpdGNoKGYuJCR0eXBlb2Ype2Nhc2Uga2I6YTp7dmFyIHI9Zi5rZXk7Zm9yKGc9YztudWxsIT09Zzspe2lmKGcua2V5PT09cilpZigxMD09PWcudGFnP2YudHlwZT09PVk6Zy50eXBlPT09Zi50eXBlKXtkKGEsZy5zaWJsaW5nKTtjPWUoZyxmLnR5cGU9PT1ZP2YucHJvcHMuY2hpbGRyZW46Zi5wcm9wcyxoKTtjLnJlZj1yYihnLGYpO2NbXCJyZXR1cm5cIl09YTthPWM7YnJlYWsgYX1lbHNle2QoYSxnKTticmVha31lbHNlIGIoYSxnKTtnPWcuc2libGluZ31mLnR5cGU9PT1ZPyhjPUVhKGYucHJvcHMuY2hpbGRyZW4sYS5pbnRlcm5hbENvbnRleHRUYWcsaCxmLmtleSksY1tcInJldHVyblwiXT1hLGE9Yyk6KGg9RGEoZixhLmludGVybmFsQ29udGV4dFRhZyxoKSxoLnJlZj1yYihjLGYpLGhbXCJyZXR1cm5cIl09YSxhPWgpfXJldHVybiBrKGEpO2Nhc2UgbGI6YTp7Zm9yKGc9Zi5rZXk7bnVsbCE9PWM7KXtpZihjLmtleT09PVxuZylpZig3PT09Yy50YWcpe2QoYSxjLnNpYmxpbmcpO2M9ZShjLGYsaCk7Y1tcInJldHVyblwiXT1hO2E9YzticmVhayBhfWVsc2V7ZChhLGMpO2JyZWFrfWVsc2UgYihhLGMpO2M9Yy5zaWJsaW5nfWM9R2EoZixhLmludGVybmFsQ29udGV4dFRhZyxoKTtjW1wicmV0dXJuXCJdPWE7YT1jfXJldHVybiBrKGEpO2Nhc2UgbWI6YTp7aWYobnVsbCE9PWMpaWYoOT09PWMudGFnKXtkKGEsYy5zaWJsaW5nKTtjPWUoYyxudWxsLGgpO2MudHlwZT1mLnZhbHVlO2NbXCJyZXR1cm5cIl09YTthPWM7YnJlYWsgYX1lbHNlIGQoYSxjKTtjPUhhKGYsYS5pbnRlcm5hbENvbnRleHRUYWcsaCk7Yy50eXBlPWYudmFsdWU7Y1tcInJldHVyblwiXT1hO2E9Y31yZXR1cm4gayhhKTtjYXNlIG5iOmE6e2ZvcihnPWYua2V5O251bGwhPT1jOyl7aWYoYy5rZXk9PT1nKWlmKDQ9PT1jLnRhZyYmYy5zdGF0ZU5vZGUuY29udGFpbmVySW5mbz09PWYuY29udGFpbmVySW5mbyYmYy5zdGF0ZU5vZGUuaW1wbGVtZW50YXRpb249PT1cbmYuaW1wbGVtZW50YXRpb24pe2QoYSxjLnNpYmxpbmcpO2M9ZShjLGYuY2hpbGRyZW58fFtdLGgpO2NbXCJyZXR1cm5cIl09YTthPWM7YnJlYWsgYX1lbHNle2QoYSxjKTticmVha31lbHNlIGIoYSxjKTtjPWMuc2libGluZ31jPUlhKGYsYS5pbnRlcm5hbENvbnRleHRUYWcsaCk7Y1tcInJldHVyblwiXT1hO2E9Y31yZXR1cm4gayhhKX1pZihcInN0cmluZ1wiPT09dHlwZW9mIGZ8fFwibnVtYmVyXCI9PT10eXBlb2YgZilyZXR1cm4gZj1cIlwiK2YsbnVsbCE9PWMmJjY9PT1jLnRhZz8oZChhLGMuc2libGluZyksYz1lKGMsZixoKSk6KGQoYSxjKSxjPUZhKGYsYS5pbnRlcm5hbENvbnRleHRUYWcsaCkpLGNbXCJyZXR1cm5cIl09YSxhPWMsayhhKTtpZihxYihmKSlyZXR1cm4gRyhhLGMsZixoKTtpZihwYihmKSlyZXR1cm4gSChhLGMsZixoKTtnJiZzYihhLGYpO2lmKFwidW5kZWZpbmVkXCI9PT10eXBlb2YgZilzd2l0Y2goYS50YWcpe2Nhc2UgMjpjYXNlIDE6aD1hLnR5cGUsSyhcIjE1MlwiLGguZGlzcGxheU5hbWV8fFxuaC5uYW1lfHxcIkNvbXBvbmVudFwiKX1yZXR1cm4gZChhLGMpfX12YXIgdWI9dGIoITApLHZiPXRiKCExKTtcbmZ1bmN0aW9uIHdiKGEsYixkLGMsZSl7ZnVuY3Rpb24gcChhLGIsZil7dmFyIGM9Yi5leHBpcmF0aW9uVGltZTtiLmNoaWxkPW51bGw9PT1hP3ZiKGIsbnVsbCxmLGMpOnViKGIsYS5jaGlsZCxmLGMpfWZ1bmN0aW9uIGsoYSxiKXt2YXIgZj1iLnJlZjtudWxsPT09Znx8YSYmYS5yZWY9PT1mfHwoYi5lZmZlY3RUYWd8PTEyOCl9ZnVuY3Rpb24gZyhhLGIsZixjKXtrKGEsYik7aWYoIWYpcmV0dXJuIGMmJkJhKGIsITEpLHUoYSxiKTtmPWIuc3RhdGVOb2RlO2lhLmN1cnJlbnQ9Yjt2YXIgaD1mLnJlbmRlcigpO2IuZWZmZWN0VGFnfD0xO3AoYSxiLGgpO2IubWVtb2l6ZWRTdGF0ZT1mLnN0YXRlO2IubWVtb2l6ZWRQcm9wcz1mLnByb3BzO2MmJkJhKGIsITApO3JldHVybiBiLmNoaWxkfWZ1bmN0aW9uIGwoYSl7dmFyIGI9YS5zdGF0ZU5vZGU7Yi5wZW5kaW5nQ29udGV4dD95YShhLGIucGVuZGluZ0NvbnRleHQsYi5wZW5kaW5nQ29udGV4dCE9PWIuY29udGV4dCk6Yi5jb250ZXh0JiZ5YShhLFxuYi5jb250ZXh0LCExKTtEKGEsYi5jb250YWluZXJJbmZvKX1mdW5jdGlvbiB1KGEsYil7bnVsbCE9PWEmJmIuY2hpbGQhPT1hLmNoaWxkP0soXCIxNTNcIik6dm9pZCAwO2lmKG51bGwhPT1iLmNoaWxkKXthPWIuY2hpbGQ7dmFyIGY9Q2EoYSxhLnBlbmRpbmdQcm9wcyxhLmV4cGlyYXRpb25UaW1lKTtiLmNoaWxkPWY7Zm9yKGZbXCJyZXR1cm5cIl09YjtudWxsIT09YS5zaWJsaW5nOylhPWEuc2libGluZyxmPWYuc2libGluZz1DYShhLGEucGVuZGluZ1Byb3BzLGEuZXhwaXJhdGlvblRpbWUpLGZbXCJyZXR1cm5cIl09YjtmLnNpYmxpbmc9bnVsbH1yZXR1cm4gYi5jaGlsZH1mdW5jdGlvbiBBKGEsYil7c3dpdGNoKGIudGFnKXtjYXNlIDM6bChiKTticmVhaztjYXNlIDI6QWEoYik7YnJlYWs7Y2FzZSA0OkQoYixiLnN0YXRlTm9kZS5jb250YWluZXJJbmZvKX1yZXR1cm4gbnVsbH12YXIgeT1hLnNob3VsZFNldFRleHRDb250ZW50LHc9YS51c2VTeW5jU2NoZWR1bGluZyx4PWEuc2hvdWxkRGVwcmlvcml0aXplU3VidHJlZSxcbkI9Yi5wdXNoSG9zdENvbnRleHQsRD1iLnB1c2hIb3N0Q29udGFpbmVyLEc9ZC5lbnRlckh5ZHJhdGlvblN0YXRlLEg9ZC5yZXNldEh5ZHJhdGlvblN0YXRlLEU9ZC50cnlUb0NsYWltTmV4dEh5ZHJhdGFibGVJbnN0YW5jZTthPWliKGMsZSxmdW5jdGlvbihhLGIpe2EubWVtb2l6ZWRQcm9wcz1ifSxmdW5jdGlvbihhLGIpe2EubWVtb2l6ZWRTdGF0ZT1ifSk7dmFyIHQ9YS5hZG9wdENsYXNzSW5zdGFuY2UsZj1hLmNvbnN0cnVjdENsYXNzSW5zdGFuY2UsaD1hLm1vdW50Q2xhc3NJbnN0YW5jZSxjYT1hLnVwZGF0ZUNsYXNzSW5zdGFuY2U7cmV0dXJue2JlZ2luV29yazpmdW5jdGlvbihhLGIsYyl7aWYoMD09PWIuZXhwaXJhdGlvblRpbWV8fGIuZXhwaXJhdGlvblRpbWU+YylyZXR1cm4gQShhLGIpO3N3aXRjaChiLnRhZyl7Y2FzZSAwOm51bGwhPT1hP0soXCIxNTVcIik6dm9pZCAwO3ZhciBkPWIudHlwZSxlPWIucGVuZGluZ1Byb3BzLHI9dWEoYik7cj13YShiLHIpO2Q9ZChlLHIpO2IuZWZmZWN0VGFnfD1cbjE7XCJvYmplY3RcIj09PXR5cGVvZiBkJiZudWxsIT09ZCYmXCJmdW5jdGlvblwiPT09dHlwZW9mIGQucmVuZGVyPyhiLnRhZz0yLGU9QWEoYiksdChiLGQpLGgoYixjKSxiPWcoYSxiLCEwLGUpKTooYi50YWc9MSxwKGEsYixkKSxiLm1lbW9pemVkUHJvcHM9ZSxiPWIuY2hpbGQpO3JldHVybiBiO2Nhc2UgMTphOntlPWIudHlwZTtjPWIucGVuZGluZ1Byb3BzO2Q9Yi5tZW1vaXplZFByb3BzO2lmKFEuY3VycmVudCludWxsPT09YyYmKGM9ZCk7ZWxzZSBpZihudWxsPT09Y3x8ZD09PWMpe2I9dShhLGIpO2JyZWFrIGF9ZD11YShiKTtkPXdhKGIsZCk7ZT1lKGMsZCk7Yi5lZmZlY3RUYWd8PTE7cChhLGIsZSk7Yi5tZW1vaXplZFByb3BzPWM7Yj1iLmNoaWxkfXJldHVybiBiO2Nhc2UgMjpyZXR1cm4gZT1BYShiKSxkPXZvaWQgMCxudWxsPT09YT9iLnN0YXRlTm9kZT9LKFwiMTUzXCIpOihmKGIsYi5wZW5kaW5nUHJvcHMpLGgoYixjKSxkPSEwKTpkPWNhKGEsYixjKSxnKGEsYixkLGUpO2Nhc2UgMzpyZXR1cm4gbChiKSxcbmU9Yi51cGRhdGVRdWV1ZSxudWxsIT09ZT8oZD1iLm1lbW9pemVkU3RhdGUsZT1nYihhLGIsZSxudWxsLG51bGwsYyksZD09PWU/KEgoKSxiPXUoYSxiKSk6KGQ9ZS5lbGVtZW50LHI9Yi5zdGF0ZU5vZGUsKG51bGw9PT1hfHxudWxsPT09YS5jaGlsZCkmJnIuaHlkcmF0ZSYmRyhiKT8oYi5lZmZlY3RUYWd8PTIsYi5jaGlsZD12YihiLG51bGwsZCxjKSk6KEgoKSxwKGEsYixkKSksYi5tZW1vaXplZFN0YXRlPWUsYj1iLmNoaWxkKSk6KEgoKSxiPXUoYSxiKSksYjtjYXNlIDU6QihiKTtudWxsPT09YSYmRShiKTtlPWIudHlwZTt2YXIgbT1iLm1lbW9pemVkUHJvcHM7ZD1iLnBlbmRpbmdQcm9wcztudWxsPT09ZCYmKGQ9bSxudWxsPT09ZD9LKFwiMTU0XCIpOnZvaWQgMCk7cj1udWxsIT09YT9hLm1lbW9pemVkUHJvcHM6bnVsbDtRLmN1cnJlbnR8fG51bGwhPT1kJiZtIT09ZD8obT1kLmNoaWxkcmVuLHkoZSxkKT9tPW51bGw6ciYmeShlLHIpJiYoYi5lZmZlY3RUYWd8PTE2KSxrKGEsYiksXG4yMTQ3NDgzNjQ3IT09YyYmIXcmJngoZSxkKT8oYi5leHBpcmF0aW9uVGltZT0yMTQ3NDgzNjQ3LGI9bnVsbCk6KHAoYSxiLG0pLGIubWVtb2l6ZWRQcm9wcz1kLGI9Yi5jaGlsZCkpOmI9dShhLGIpO3JldHVybiBiO2Nhc2UgNjpyZXR1cm4gbnVsbD09PWEmJkUoYiksYT1iLnBlbmRpbmdQcm9wcyxudWxsPT09YSYmKGE9Yi5tZW1vaXplZFByb3BzKSxiLm1lbW9pemVkUHJvcHM9YSxudWxsO2Nhc2UgODpiLnRhZz03O2Nhc2UgNzplPWIucGVuZGluZ1Byb3BzO2lmKFEuY3VycmVudCludWxsPT09ZSYmKGU9YSYmYS5tZW1vaXplZFByb3BzLG51bGw9PT1lP0soXCIxNTRcIik6dm9pZCAwKTtlbHNlIGlmKG51bGw9PT1lfHxiLm1lbW9pemVkUHJvcHM9PT1lKWU9Yi5tZW1vaXplZFByb3BzO2Q9ZS5jaGlsZHJlbjtiLnN0YXRlTm9kZT1udWxsPT09YT92YihiLGIuc3RhdGVOb2RlLGQsYyk6dWIoYixiLnN0YXRlTm9kZSxkLGMpO2IubWVtb2l6ZWRQcm9wcz1lO3JldHVybiBiLnN0YXRlTm9kZTtcbmNhc2UgOTpyZXR1cm4gbnVsbDtjYXNlIDQ6YTp7RChiLGIuc3RhdGVOb2RlLmNvbnRhaW5lckluZm8pO2U9Yi5wZW5kaW5nUHJvcHM7aWYoUS5jdXJyZW50KW51bGw9PT1lJiYoZT1hJiZhLm1lbW9pemVkUHJvcHMsbnVsbD09ZT9LKFwiMTU0XCIpOnZvaWQgMCk7ZWxzZSBpZihudWxsPT09ZXx8Yi5tZW1vaXplZFByb3BzPT09ZSl7Yj11KGEsYik7YnJlYWsgYX1udWxsPT09YT9iLmNoaWxkPXViKGIsbnVsbCxlLGMpOnAoYSxiLGUpO2IubWVtb2l6ZWRQcm9wcz1lO2I9Yi5jaGlsZH1yZXR1cm4gYjtjYXNlIDEwOmE6e2M9Yi5wZW5kaW5nUHJvcHM7aWYoUS5jdXJyZW50KW51bGw9PT1jJiYoYz1iLm1lbW9pemVkUHJvcHMpO2Vsc2UgaWYobnVsbD09PWN8fGIubWVtb2l6ZWRQcm9wcz09PWMpe2I9dShhLGIpO2JyZWFrIGF9cChhLGIsYyk7Yi5tZW1vaXplZFByb3BzPWM7Yj1iLmNoaWxkfXJldHVybiBiO2RlZmF1bHQ6SyhcIjE1NlwiKX19LGJlZ2luRmFpbGVkV29yazpmdW5jdGlvbihiLGEsXG5jKXtzd2l0Y2goYS50YWcpe2Nhc2UgMjpBYShhKTticmVhaztjYXNlIDM6bChhKTticmVhaztkZWZhdWx0OksoXCIxNTdcIil9YS5lZmZlY3RUYWd8PTY0O251bGw9PT1iP2EuY2hpbGQ9bnVsbDphLmNoaWxkIT09Yi5jaGlsZCYmKGEuY2hpbGQ9Yi5jaGlsZCk7aWYoMD09PWEuZXhwaXJhdGlvblRpbWV8fGEuZXhwaXJhdGlvblRpbWU+YylyZXR1cm4gQShiLGEpO2EuZmlyc3RFZmZlY3Q9bnVsbDthLmxhc3RFZmZlY3Q9bnVsbDthLmNoaWxkPW51bGw9PT1iP3ZiKGEsbnVsbCxudWxsLGMpOnViKGEsYi5jaGlsZCxudWxsLGMpOzI9PT1hLnRhZyYmKGI9YS5zdGF0ZU5vZGUsYS5tZW1vaXplZFByb3BzPWIucHJvcHMsYS5tZW1vaXplZFN0YXRlPWIuc3RhdGUpO3JldHVybiBhLmNoaWxkfX19XG5mdW5jdGlvbiB4YihhLGIsZCl7ZnVuY3Rpb24gYyhhKXthLmVmZmVjdFRhZ3w9NH12YXIgZT1hLmNyZWF0ZUluc3RhbmNlLHA9YS5jcmVhdGVUZXh0SW5zdGFuY2Usaz1hLmFwcGVuZEluaXRpYWxDaGlsZCxnPWEuZmluYWxpemVJbml0aWFsQ2hpbGRyZW4sbD1hLnByZXBhcmVVcGRhdGUsdT1hLnBlcnNpc3RlbmNlLEE9Yi5nZXRSb290SG9zdENvbnRhaW5lcix5PWIucG9wSG9zdENvbnRleHQsdz1iLmdldEhvc3RDb250ZXh0LHg9Yi5wb3BIb3N0Q29udGFpbmVyLEI9ZC5wcmVwYXJlVG9IeWRyYXRlSG9zdEluc3RhbmNlLEQ9ZC5wcmVwYXJlVG9IeWRyYXRlSG9zdFRleHRJbnN0YW5jZSxHPWQucG9wSHlkcmF0aW9uU3RhdGUsSD12b2lkIDAsRT12b2lkIDAsdD12b2lkIDA7YS5tdXRhdGlvbj8oSD1mdW5jdGlvbigpe30sRT1mdW5jdGlvbihhLGIsZCl7KGIudXBkYXRlUXVldWU9ZCkmJmMoYil9LHQ9ZnVuY3Rpb24oYSxiLGQsZSl7ZCE9PWUmJmMoYil9KTp1P0soXCIyMzVcIik6SyhcIjIzNlwiKTtcbnJldHVybntjb21wbGV0ZVdvcms6ZnVuY3Rpb24oYSxiLGQpe3ZhciBmPWIucGVuZGluZ1Byb3BzO2lmKG51bGw9PT1mKWY9Yi5tZW1vaXplZFByb3BzO2Vsc2UgaWYoMjE0NzQ4MzY0NyE9PWIuZXhwaXJhdGlvblRpbWV8fDIxNDc0ODM2NDc9PT1kKWIucGVuZGluZ1Byb3BzPW51bGw7c3dpdGNoKGIudGFnKXtjYXNlIDE6cmV0dXJuIG51bGw7Y2FzZSAyOnJldHVybiB4YShiKSxudWxsO2Nhc2UgMzp4KGIpO00oUSxiKTtNKE8sYik7Zj1iLnN0YXRlTm9kZTtmLnBlbmRpbmdDb250ZXh0JiYoZi5jb250ZXh0PWYucGVuZGluZ0NvbnRleHQsZi5wZW5kaW5nQ29udGV4dD1udWxsKTtpZihudWxsPT09YXx8bnVsbD09PWEuY2hpbGQpRyhiKSxiLmVmZmVjdFRhZyY9LTM7SChiKTtyZXR1cm4gbnVsbDtjYXNlIDU6eShiKTtkPUEoKTt2YXIgaD1iLnR5cGU7aWYobnVsbCE9PWEmJm51bGwhPWIuc3RhdGVOb2RlKXt2YXIgbT1hLm1lbW9pemVkUHJvcHMsdT1iLnN0YXRlTm9kZSxjYT13KCk7dT1cbmwodSxoLG0sZixkLGNhKTtFKGEsYix1LGgsbSxmLGQpO2EucmVmIT09Yi5yZWYmJihiLmVmZmVjdFRhZ3w9MTI4KX1lbHNle2lmKCFmKXJldHVybiBudWxsPT09Yi5zdGF0ZU5vZGU/SyhcIjE2NlwiKTp2b2lkIDAsbnVsbDthPXcoKTtpZihHKGIpKUIoYixkLGEpJiZjKGIpO2Vsc2V7YT1lKGgsZixkLGEsYik7YTpmb3IobT1iLmNoaWxkO251bGwhPT1tOyl7aWYoNT09PW0udGFnfHw2PT09bS50YWcpayhhLG0uc3RhdGVOb2RlKTtlbHNlIGlmKDQhPT1tLnRhZyYmbnVsbCE9PW0uY2hpbGQpe20uY2hpbGRbXCJyZXR1cm5cIl09bTttPW0uY2hpbGQ7Y29udGludWV9aWYobT09PWIpYnJlYWs7Zm9yKDtudWxsPT09bS5zaWJsaW5nOyl7aWYobnVsbD09PW1bXCJyZXR1cm5cIl18fG1bXCJyZXR1cm5cIl09PT1iKWJyZWFrIGE7bT1tW1wicmV0dXJuXCJdfW0uc2libGluZ1tcInJldHVyblwiXT1tW1wicmV0dXJuXCJdO209bS5zaWJsaW5nfWcoYSxoLGYsZCkmJmMoYik7Yi5zdGF0ZU5vZGU9YX1udWxsIT09Yi5yZWYmJlxuKGIuZWZmZWN0VGFnfD0xMjgpfXJldHVybiBudWxsO2Nhc2UgNjppZihhJiZudWxsIT1iLnN0YXRlTm9kZSl0KGEsYixhLm1lbW9pemVkUHJvcHMsZik7ZWxzZXtpZihcInN0cmluZ1wiIT09dHlwZW9mIGYpcmV0dXJuIG51bGw9PT1iLnN0YXRlTm9kZT9LKFwiMTY2XCIpOnZvaWQgMCxudWxsO2E9QSgpO2Q9dygpO0coYik/RChiKSYmYyhiKTpiLnN0YXRlTm9kZT1wKGYsYSxkLGIpfXJldHVybiBudWxsO2Nhc2UgNzooZj1iLm1lbW9pemVkUHJvcHMpP3ZvaWQgMDpLKFwiMTY1XCIpO2IudGFnPTg7aD1bXTthOmZvcigobT1iLnN0YXRlTm9kZSkmJihtW1wicmV0dXJuXCJdPWIpO251bGwhPT1tOyl7aWYoNT09PW0udGFnfHw2PT09bS50YWd8fDQ9PT1tLnRhZylLKFwiMjQ3XCIpO2Vsc2UgaWYoOT09PW0udGFnKWgucHVzaChtLnR5cGUpO2Vsc2UgaWYobnVsbCE9PW0uY2hpbGQpe20uY2hpbGRbXCJyZXR1cm5cIl09bTttPW0uY2hpbGQ7Y29udGludWV9Zm9yKDtudWxsPT09bS5zaWJsaW5nOyl7aWYobnVsbD09PVxubVtcInJldHVyblwiXXx8bVtcInJldHVyblwiXT09PWIpYnJlYWsgYTttPW1bXCJyZXR1cm5cIl19bS5zaWJsaW5nW1wicmV0dXJuXCJdPW1bXCJyZXR1cm5cIl07bT1tLnNpYmxpbmd9bT1mLmhhbmRsZXI7Zj1tKGYucHJvcHMsaCk7Yi5jaGlsZD11YihiLG51bGwhPT1hP2EuY2hpbGQ6bnVsbCxmLGQpO3JldHVybiBiLmNoaWxkO2Nhc2UgODpyZXR1cm4gYi50YWc9NyxudWxsO2Nhc2UgOTpyZXR1cm4gbnVsbDtjYXNlIDEwOnJldHVybiBudWxsO2Nhc2UgNDpyZXR1cm4geChiKSxIKGIpLG51bGw7Y2FzZSAwOksoXCIxNjdcIik7ZGVmYXVsdDpLKFwiMTU2XCIpfX19fVxuZnVuY3Rpb24geWIoYSxiKXtmdW5jdGlvbiBkKGEpe3ZhciBjPWEucmVmO2lmKG51bGwhPT1jKXRyeXtjKG51bGwpfWNhdGNoKGgpe2IoYSxoKX19ZnVuY3Rpb24gYyhhKXtcImZ1bmN0aW9uXCI9PT10eXBlb2YgVGEmJlRhKGEpO3N3aXRjaChhLnRhZyl7Y2FzZSAyOmQoYSk7dmFyIGM9YS5zdGF0ZU5vZGU7aWYoXCJmdW5jdGlvblwiPT09dHlwZW9mIGMuY29tcG9uZW50V2lsbFVubW91bnQpdHJ5e2MucHJvcHM9YS5tZW1vaXplZFByb3BzLGMuc3RhdGU9YS5tZW1vaXplZFN0YXRlLGMuY29tcG9uZW50V2lsbFVubW91bnQoKX1jYXRjaChoKXtiKGEsaCl9YnJlYWs7Y2FzZSA1OmQoYSk7YnJlYWs7Y2FzZSA3OmUoYS5zdGF0ZU5vZGUpO2JyZWFrO2Nhc2UgNDpsJiZrKGEpfX1mdW5jdGlvbiBlKGIpe2Zvcih2YXIgYT1iOzspaWYoYyhhKSxudWxsPT09YS5jaGlsZHx8bCYmND09PWEudGFnKXtpZihhPT09YilicmVhaztmb3IoO251bGw9PT1hLnNpYmxpbmc7KXtpZihudWxsPT09YVtcInJldHVyblwiXXx8XG5hW1wicmV0dXJuXCJdPT09YilyZXR1cm47YT1hW1wicmV0dXJuXCJdfWEuc2libGluZ1tcInJldHVyblwiXT1hW1wicmV0dXJuXCJdO2E9YS5zaWJsaW5nfWVsc2UgYS5jaGlsZFtcInJldHVyblwiXT1hLGE9YS5jaGlsZH1mdW5jdGlvbiBwKGEpe3JldHVybiA1PT09YS50YWd8fDM9PT1hLnRhZ3x8ND09PWEudGFnfWZ1bmN0aW9uIGsoYSl7Zm9yKHZhciBiPWEsZD0hMSxnPXZvaWQgMCxsPXZvaWQgMDs7KXtpZighZCl7ZD1iW1wicmV0dXJuXCJdO2E6Zm9yKDs7KXtudWxsPT09ZD9LKFwiMTYwXCIpOnZvaWQgMDtzd2l0Y2goZC50YWcpe2Nhc2UgNTpnPWQuc3RhdGVOb2RlO2w9ITE7YnJlYWsgYTtjYXNlIDM6Zz1kLnN0YXRlTm9kZS5jb250YWluZXJJbmZvO2w9ITA7YnJlYWsgYTtjYXNlIDQ6Zz1kLnN0YXRlTm9kZS5jb250YWluZXJJbmZvO2w9ITA7YnJlYWsgYX1kPWRbXCJyZXR1cm5cIl19ZD0hMH1pZig1PT09Yi50YWd8fDY9PT1iLnRhZyllKGIpLGw/RShnLGIuc3RhdGVOb2RlKTpIKGcsYi5zdGF0ZU5vZGUpO1xuZWxzZSBpZig0PT09Yi50YWc/Zz1iLnN0YXRlTm9kZS5jb250YWluZXJJbmZvOmMoYiksbnVsbCE9PWIuY2hpbGQpe2IuY2hpbGRbXCJyZXR1cm5cIl09YjtiPWIuY2hpbGQ7Y29udGludWV9aWYoYj09PWEpYnJlYWs7Zm9yKDtudWxsPT09Yi5zaWJsaW5nOyl7aWYobnVsbD09PWJbXCJyZXR1cm5cIl18fGJbXCJyZXR1cm5cIl09PT1hKXJldHVybjtiPWJbXCJyZXR1cm5cIl07ND09PWIudGFnJiYoZD0hMSl9Yi5zaWJsaW5nW1wicmV0dXJuXCJdPWJbXCJyZXR1cm5cIl07Yj1iLnNpYmxpbmd9fXZhciBnPWEuZ2V0UHVibGljSW5zdGFuY2UsbD1hLm11dGF0aW9uO2E9YS5wZXJzaXN0ZW5jZTtsfHwoYT9LKFwiMjM1XCIpOksoXCIyMzZcIikpO3ZhciB1PWwuY29tbWl0TW91bnQsQT1sLmNvbW1pdFVwZGF0ZSx5PWwucmVzZXRUZXh0Q29udGVudCx3PWwuY29tbWl0VGV4dFVwZGF0ZSx4PWwuYXBwZW5kQ2hpbGQsQj1sLmFwcGVuZENoaWxkVG9Db250YWluZXIsRD1sLmluc2VydEJlZm9yZSxHPWwuaW5zZXJ0SW5Db250YWluZXJCZWZvcmUsXG5IPWwucmVtb3ZlQ2hpbGQsRT1sLnJlbW92ZUNoaWxkRnJvbUNvbnRhaW5lcjtyZXR1cm57Y29tbWl0UmVzZXRUZXh0Q29udGVudDpmdW5jdGlvbihiKXt5KGIuc3RhdGVOb2RlKX0sY29tbWl0UGxhY2VtZW50OmZ1bmN0aW9uKGIpe2E6e2Zvcih2YXIgYT1iW1wicmV0dXJuXCJdO251bGwhPT1hOyl7aWYocChhKSl7dmFyIGM9YTticmVhayBhfWE9YVtcInJldHVyblwiXX1LKFwiMTYwXCIpO2M9dm9pZCAwfXZhciBkPWE9dm9pZCAwO3N3aXRjaChjLnRhZyl7Y2FzZSA1OmE9Yy5zdGF0ZU5vZGU7ZD0hMTticmVhaztjYXNlIDM6YT1jLnN0YXRlTm9kZS5jb250YWluZXJJbmZvO2Q9ITA7YnJlYWs7Y2FzZSA0OmE9Yy5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztkPSEwO2JyZWFrO2RlZmF1bHQ6SyhcIjE2MVwiKX1jLmVmZmVjdFRhZyYxNiYmKHkoYSksYy5lZmZlY3RUYWcmPS0xNyk7YTpiOmZvcihjPWI7Oyl7Zm9yKDtudWxsPT09Yy5zaWJsaW5nOyl7aWYobnVsbD09PWNbXCJyZXR1cm5cIl18fHAoY1tcInJldHVyblwiXSkpe2M9XG5udWxsO2JyZWFrIGF9Yz1jW1wicmV0dXJuXCJdfWMuc2libGluZ1tcInJldHVyblwiXT1jW1wicmV0dXJuXCJdO2ZvcihjPWMuc2libGluZzs1IT09Yy50YWcmJjYhPT1jLnRhZzspe2lmKGMuZWZmZWN0VGFnJjIpY29udGludWUgYjtpZihudWxsPT09Yy5jaGlsZHx8ND09PWMudGFnKWNvbnRpbnVlIGI7ZWxzZSBjLmNoaWxkW1wicmV0dXJuXCJdPWMsYz1jLmNoaWxkfWlmKCEoYy5lZmZlY3RUYWcmMikpe2M9Yy5zdGF0ZU5vZGU7YnJlYWsgYX19Zm9yKHZhciBlPWI7Oyl7aWYoNT09PWUudGFnfHw2PT09ZS50YWcpYz9kP0coYSxlLnN0YXRlTm9kZSxjKTpEKGEsZS5zdGF0ZU5vZGUsYyk6ZD9CKGEsZS5zdGF0ZU5vZGUpOngoYSxlLnN0YXRlTm9kZSk7ZWxzZSBpZig0IT09ZS50YWcmJm51bGwhPT1lLmNoaWxkKXtlLmNoaWxkW1wicmV0dXJuXCJdPWU7ZT1lLmNoaWxkO2NvbnRpbnVlfWlmKGU9PT1iKWJyZWFrO2Zvcig7bnVsbD09PWUuc2libGluZzspe2lmKG51bGw9PT1lW1wicmV0dXJuXCJdfHxlW1wicmV0dXJuXCJdPT09XG5iKXJldHVybjtlPWVbXCJyZXR1cm5cIl19ZS5zaWJsaW5nW1wicmV0dXJuXCJdPWVbXCJyZXR1cm5cIl07ZT1lLnNpYmxpbmd9fSxjb21taXREZWxldGlvbjpmdW5jdGlvbihiKXtrKGIpO2JbXCJyZXR1cm5cIl09bnVsbDtiLmNoaWxkPW51bGw7Yi5hbHRlcm5hdGUmJihiLmFsdGVybmF0ZS5jaGlsZD1udWxsLGIuYWx0ZXJuYXRlW1wicmV0dXJuXCJdPW51bGwpfSxjb21taXRXb3JrOmZ1bmN0aW9uKGIsYSl7c3dpdGNoKGEudGFnKXtjYXNlIDI6YnJlYWs7Y2FzZSA1OnZhciBjPWEuc3RhdGVOb2RlO2lmKG51bGwhPWMpe3ZhciBkPWEubWVtb2l6ZWRQcm9wcztiPW51bGwhPT1iP2IubWVtb2l6ZWRQcm9wczpkO3ZhciBlPWEudHlwZSxmPWEudXBkYXRlUXVldWU7YS51cGRhdGVRdWV1ZT1udWxsO251bGwhPT1mJiZBKGMsZixlLGIsZCxhKX1icmVhaztjYXNlIDY6bnVsbD09PWEuc3RhdGVOb2RlP0soXCIxNjJcIik6dm9pZCAwO2M9YS5tZW1vaXplZFByb3BzO3coYS5zdGF0ZU5vZGUsbnVsbCE9PWI/Yi5tZW1vaXplZFByb3BzOlxuYyxjKTticmVhaztjYXNlIDM6YnJlYWs7ZGVmYXVsdDpLKFwiMTYzXCIpfX0sY29tbWl0TGlmZUN5Y2xlczpmdW5jdGlvbihiLGEpe3N3aXRjaChhLnRhZyl7Y2FzZSAyOnZhciBjPWEuc3RhdGVOb2RlO2lmKGEuZWZmZWN0VGFnJjQpaWYobnVsbD09PWIpYy5wcm9wcz1hLm1lbW9pemVkUHJvcHMsYy5zdGF0ZT1hLm1lbW9pemVkU3RhdGUsYy5jb21wb25lbnREaWRNb3VudCgpO2Vsc2V7dmFyIGQ9Yi5tZW1vaXplZFByb3BzO2I9Yi5tZW1vaXplZFN0YXRlO2MucHJvcHM9YS5tZW1vaXplZFByb3BzO2Muc3RhdGU9YS5tZW1vaXplZFN0YXRlO2MuY29tcG9uZW50RGlkVXBkYXRlKGQsYil9YT1hLnVwZGF0ZVF1ZXVlO251bGwhPT1hJiZoYihhLGMpO2JyZWFrO2Nhc2UgMzpjPWEudXBkYXRlUXVldWU7bnVsbCE9PWMmJmhiKGMsbnVsbCE9PWEuY2hpbGQ/YS5jaGlsZC5zdGF0ZU5vZGU6bnVsbCk7YnJlYWs7Y2FzZSA1OmM9YS5zdGF0ZU5vZGU7bnVsbD09PWImJmEuZWZmZWN0VGFnJjQmJnUoYyxcbmEudHlwZSxhLm1lbW9pemVkUHJvcHMsYSk7YnJlYWs7Y2FzZSA2OmJyZWFrO2Nhc2UgNDpicmVhaztkZWZhdWx0OksoXCIxNjNcIil9fSxjb21taXRBdHRhY2hSZWY6ZnVuY3Rpb24oYSl7dmFyIGI9YS5yZWY7aWYobnVsbCE9PWIpe3ZhciBjPWEuc3RhdGVOb2RlO3N3aXRjaChhLnRhZyl7Y2FzZSA1OmIoZyhjKSk7YnJlYWs7ZGVmYXVsdDpiKGMpfX19LGNvbW1pdERldGFjaFJlZjpmdW5jdGlvbihhKXthPWEucmVmO251bGwhPT1hJiZhKG51bGwpfX19dmFyIHpiPXt9O1xuZnVuY3Rpb24gQWIoYSl7ZnVuY3Rpb24gYihhKXthPT09emI/SyhcIjE3NFwiKTp2b2lkIDA7cmV0dXJuIGF9dmFyIGQ9YS5nZXRDaGlsZEhvc3RDb250ZXh0LGM9YS5nZXRSb290SG9zdENvbnRleHQsZT17Y3VycmVudDp6Yn0scD17Y3VycmVudDp6Yn0saz17Y3VycmVudDp6Yn07cmV0dXJue2dldEhvc3RDb250ZXh0OmZ1bmN0aW9uKCl7cmV0dXJuIGIoZS5jdXJyZW50KX0sZ2V0Um9vdEhvc3RDb250YWluZXI6ZnVuY3Rpb24oKXtyZXR1cm4gYihrLmN1cnJlbnQpfSxwb3BIb3N0Q29udGFpbmVyOmZ1bmN0aW9uKGEpe00oZSxhKTtNKHAsYSk7TShrLGEpfSxwb3BIb3N0Q29udGV4dDpmdW5jdGlvbihhKXtwLmN1cnJlbnQ9PT1hJiYoTShlLGEpLE0ocCxhKSl9LHB1c2hIb3N0Q29udGFpbmVyOmZ1bmN0aW9uKGEsYil7TihrLGIsYSk7Yj1jKGIpO04ocCxhLGEpO04oZSxiLGEpfSxwdXNoSG9zdENvbnRleHQ6ZnVuY3Rpb24oYSl7dmFyIGM9YihrLmN1cnJlbnQpLGc9YihlLmN1cnJlbnQpO1xuYz1kKGcsYS50eXBlLGMpO2chPT1jJiYoTihwLGEsYSksTihlLGMsYSkpfSxyZXNldEhvc3RDb250YWluZXI6ZnVuY3Rpb24oKXtlLmN1cnJlbnQ9emI7ay5jdXJyZW50PXpifX19XG5mdW5jdGlvbiBCYihhKXtmdW5jdGlvbiBiKGEsYil7dmFyIGM9bmV3IFgoNSxudWxsLDApO2MudHlwZT1cIkRFTEVURURcIjtjLnN0YXRlTm9kZT1iO2NbXCJyZXR1cm5cIl09YTtjLmVmZmVjdFRhZz04O251bGwhPT1hLmxhc3RFZmZlY3Q/KGEubGFzdEVmZmVjdC5uZXh0RWZmZWN0PWMsYS5sYXN0RWZmZWN0PWMpOmEuZmlyc3RFZmZlY3Q9YS5sYXN0RWZmZWN0PWN9ZnVuY3Rpb24gZChhLGIpe3N3aXRjaChhLnRhZyl7Y2FzZSA1OnJldHVybiBiPXAoYixhLnR5cGUsYS5wZW5kaW5nUHJvcHMpLG51bGwhPT1iPyhhLnN0YXRlTm9kZT1iLCEwKTohMTtjYXNlIDY6cmV0dXJuIGI9ayhiLGEucGVuZGluZ1Byb3BzKSxudWxsIT09Yj8oYS5zdGF0ZU5vZGU9YiwhMCk6ITE7ZGVmYXVsdDpyZXR1cm4hMX19ZnVuY3Rpb24gYyhhKXtmb3IoYT1hW1wicmV0dXJuXCJdO251bGwhPT1hJiY1IT09YS50YWcmJjMhPT1hLnRhZzspYT1hW1wicmV0dXJuXCJdO3k9YX12YXIgZT1hLnNob3VsZFNldFRleHRDb250ZW50O1xuYT1hLmh5ZHJhdGlvbjtpZighYSlyZXR1cm57ZW50ZXJIeWRyYXRpb25TdGF0ZTpmdW5jdGlvbigpe3JldHVybiExfSxyZXNldEh5ZHJhdGlvblN0YXRlOmZ1bmN0aW9uKCl7fSx0cnlUb0NsYWltTmV4dEh5ZHJhdGFibGVJbnN0YW5jZTpmdW5jdGlvbigpe30scHJlcGFyZVRvSHlkcmF0ZUhvc3RJbnN0YW5jZTpmdW5jdGlvbigpe0soXCIxNzVcIil9LHByZXBhcmVUb0h5ZHJhdGVIb3N0VGV4dEluc3RhbmNlOmZ1bmN0aW9uKCl7SyhcIjE3NlwiKX0scG9wSHlkcmF0aW9uU3RhdGU6ZnVuY3Rpb24oKXtyZXR1cm4hMX19O3ZhciBwPWEuY2FuSHlkcmF0ZUluc3RhbmNlLGs9YS5jYW5IeWRyYXRlVGV4dEluc3RhbmNlLGc9YS5nZXROZXh0SHlkcmF0YWJsZVNpYmxpbmcsbD1hLmdldEZpcnN0SHlkcmF0YWJsZUNoaWxkLHU9YS5oeWRyYXRlSW5zdGFuY2UsQT1hLmh5ZHJhdGVUZXh0SW5zdGFuY2UseT1udWxsLHc9bnVsbCx4PSExO3JldHVybntlbnRlckh5ZHJhdGlvblN0YXRlOmZ1bmN0aW9uKGEpe3c9XG5sKGEuc3RhdGVOb2RlLmNvbnRhaW5lckluZm8pO3k9YTtyZXR1cm4geD0hMH0scmVzZXRIeWRyYXRpb25TdGF0ZTpmdW5jdGlvbigpe3c9eT1udWxsO3g9ITF9LHRyeVRvQ2xhaW1OZXh0SHlkcmF0YWJsZUluc3RhbmNlOmZ1bmN0aW9uKGEpe2lmKHgpe3ZhciBjPXc7aWYoYyl7aWYoIWQoYSxjKSl7Yz1nKGMpO2lmKCFjfHwhZChhLGMpKXthLmVmZmVjdFRhZ3w9Mjt4PSExO3k9YTtyZXR1cm59Yih5LHcpfXk9YTt3PWwoYyl9ZWxzZSBhLmVmZmVjdFRhZ3w9Mix4PSExLHk9YX19LHByZXBhcmVUb0h5ZHJhdGVIb3N0SW5zdGFuY2U6ZnVuY3Rpb24oYSxiLGMpe2I9dShhLnN0YXRlTm9kZSxhLnR5cGUsYS5tZW1vaXplZFByb3BzLGIsYyxhKTthLnVwZGF0ZVF1ZXVlPWI7cmV0dXJuIG51bGwhPT1iPyEwOiExfSxwcmVwYXJlVG9IeWRyYXRlSG9zdFRleHRJbnN0YW5jZTpmdW5jdGlvbihhKXtyZXR1cm4gQShhLnN0YXRlTm9kZSxhLm1lbW9pemVkUHJvcHMsYSl9LHBvcEh5ZHJhdGlvblN0YXRlOmZ1bmN0aW9uKGEpe2lmKGEhPT1cbnkpcmV0dXJuITE7aWYoIXgpcmV0dXJuIGMoYSkseD0hMCwhMTt2YXIgZD1hLnR5cGU7aWYoNSE9PWEudGFnfHxcImhlYWRcIiE9PWQmJlwiYm9keVwiIT09ZCYmIWUoZCxhLm1lbW9pemVkUHJvcHMpKWZvcihkPXc7ZDspYihhLGQpLGQ9ZyhkKTtjKGEpO3c9eT9nKGEuc3RhdGVOb2RlKTpudWxsO3JldHVybiEwfX19XG5mdW5jdGlvbiBDYihhKXtmdW5jdGlvbiBiKGEpe0phPVM9ITA7dmFyIGI9YS5zdGF0ZU5vZGU7Yi5jdXJyZW50PT09YT9LKFwiMTc3XCIpOnZvaWQgMDtiLmlzUmVhZHlGb3JDb21taXQ9ITE7aWEuY3VycmVudD1udWxsO2lmKDE8YS5lZmZlY3RUYWcpaWYobnVsbCE9PWEubGFzdEVmZmVjdCl7YS5sYXN0RWZmZWN0Lm5leHRFZmZlY3Q9YTt2YXIgYz1hLmZpcnN0RWZmZWN0fWVsc2UgYz1hO2Vsc2UgYz1hLmZpcnN0RWZmZWN0O2ZjKCk7Zm9yKHY9YztudWxsIT09djspe3ZhciBkPSExLGU9dm9pZCAwO3RyeXtmb3IoO251bGwhPT12Oyl7dmFyIGY9di5lZmZlY3RUYWc7ZiYxNiYmZ2Modik7aWYoZiYxMjgpe3ZhciBlYT12LmFsdGVybmF0ZTtudWxsIT09ZWEmJmhjKGVhKX1zd2l0Y2goZiYtMjQyKXtjYXNlIDI6RWIodik7di5lZmZlY3RUYWcmPS0zO2JyZWFrO2Nhc2UgNjpFYih2KTt2LmVmZmVjdFRhZyY9LTM7RmIodi5hbHRlcm5hdGUsdik7YnJlYWs7Y2FzZSA0OkZiKHYuYWx0ZXJuYXRlLFxudik7YnJlYWs7Y2FzZSA4OlphPSEwLGljKHYpLFphPSExfXY9di5uZXh0RWZmZWN0fX1jYXRjaCgkYSl7ZD0hMCxlPSRhfWQmJihudWxsPT09dj9LKFwiMTc4XCIpOnZvaWQgMCxnKHYsZSksbnVsbCE9PXYmJih2PXYubmV4dEVmZmVjdCkpfWpjKCk7Yi5jdXJyZW50PWE7Zm9yKHY9YztudWxsIT09djspe2M9ITE7ZD12b2lkIDA7dHJ5e2Zvcig7bnVsbCE9PXY7KXt2YXIgaz12LmVmZmVjdFRhZztrJjM2JiZrYyh2LmFsdGVybmF0ZSx2KTtrJjEyOCYmbGModik7aWYoayY2NClzd2l0Y2goZT12LGY9dm9pZCAwLG51bGwhPT1KJiYoZj1KLmdldChlKSxKW1wiZGVsZXRlXCJdKGUpLG51bGw9PWYmJm51bGwhPT1lLmFsdGVybmF0ZSYmKGU9ZS5hbHRlcm5hdGUsZj1KLmdldChlKSxKW1wiZGVsZXRlXCJdKGUpKSksbnVsbD09Zj9LKFwiMTg0XCIpOnZvaWQgMCxlLnRhZyl7Y2FzZSAyOmUuc3RhdGVOb2RlLmNvbXBvbmVudERpZENhdGNoKGYuZXJyb3Ise2NvbXBvbmVudFN0YWNrOmYuY29tcG9uZW50U3RhY2t9KTtcbmJyZWFrO2Nhc2UgMzpudWxsPT09UCYmKFA9Zi5lcnJvcik7YnJlYWs7ZGVmYXVsdDpLKFwiMTU3XCIpfXZhciBoPXYubmV4dEVmZmVjdDt2Lm5leHRFZmZlY3Q9bnVsbDt2PWh9fWNhdGNoKCRhKXtjPSEwLGQ9JGF9YyYmKG51bGw9PT12P0soXCIxNzhcIik6dm9pZCAwLGcodixkKSxudWxsIT09diYmKHY9di5uZXh0RWZmZWN0KSl9Uz1KYT0hMTtcImZ1bmN0aW9uXCI9PT10eXBlb2YgU2EmJlNhKGEuc3RhdGVOb2RlKTtSJiYoUi5mb3JFYWNoKEIpLFI9bnVsbCk7bnVsbCE9PVAmJihhPVAsUD1udWxsLGNhKGEpKTtiPWIuY3VycmVudC5leHBpcmF0aW9uVGltZTswPT09YiYmKFo9Sj1udWxsKTtyZXR1cm4gYn1mdW5jdGlvbiBkKGEpe2Zvcig7Oyl7dmFyIGI9bWMoYS5hbHRlcm5hdGUsYSxDKSxjPWFbXCJyZXR1cm5cIl0sZD1hLnNpYmxpbmc7dmFyIGU9YTtpZigyMTQ3NDgzNjQ3PT09Q3x8MjE0NzQ4MzY0NyE9PWUuZXhwaXJhdGlvblRpbWUpe2lmKDIhPT1lLnRhZyYmMyE9PWUudGFnKXZhciBmPVxuMDtlbHNlIGY9ZS51cGRhdGVRdWV1ZSxmPW51bGw9PT1mPzA6Zi5leHBpcmF0aW9uVGltZTtmb3IodmFyIGc9ZS5jaGlsZDtudWxsIT09ZzspMCE9PWcuZXhwaXJhdGlvblRpbWUmJigwPT09Znx8Zj5nLmV4cGlyYXRpb25UaW1lKSYmKGY9Zy5leHBpcmF0aW9uVGltZSksZz1nLnNpYmxpbmc7ZS5leHBpcmF0aW9uVGltZT1mfWlmKG51bGwhPT1iKXJldHVybiBiO251bGwhPT1jJiYobnVsbD09PWMuZmlyc3RFZmZlY3QmJihjLmZpcnN0RWZmZWN0PWEuZmlyc3RFZmZlY3QpLG51bGwhPT1hLmxhc3RFZmZlY3QmJihudWxsIT09Yy5sYXN0RWZmZWN0JiYoYy5sYXN0RWZmZWN0Lm5leHRFZmZlY3Q9YS5maXJzdEVmZmVjdCksYy5sYXN0RWZmZWN0PWEubGFzdEVmZmVjdCksMTxhLmVmZmVjdFRhZyYmKG51bGwhPT1jLmxhc3RFZmZlY3Q/Yy5sYXN0RWZmZWN0Lm5leHRFZmZlY3Q9YTpjLmZpcnN0RWZmZWN0PWEsYy5sYXN0RWZmZWN0PWEpKTtpZihudWxsIT09ZClyZXR1cm4gZDtpZihudWxsIT09XG5jKWE9YztlbHNle2Euc3RhdGVOb2RlLmlzUmVhZHlGb3JDb21taXQ9ITA7YnJlYWt9fXJldHVybiBudWxsfWZ1bmN0aW9uIGMoYSl7dmFyIGI9WmIoYS5hbHRlcm5hdGUsYSxDKTtudWxsPT09YiYmKGI9ZChhKSk7aWEuY3VycmVudD1udWxsO3JldHVybiBifWZ1bmN0aW9uIGUoYSl7dmFyIGI9bmMoYS5hbHRlcm5hdGUsYSxDKTtudWxsPT09YiYmKGI9ZChhKSk7aWEuY3VycmVudD1udWxsO3JldHVybiBifWZ1bmN0aW9uIHAoYSl7aWYobnVsbCE9PUope2lmKCEoMD09PUN8fEM+YSkpaWYoQzw9YWIpZm9yKDtudWxsIT09ejspej1sKHopP2Uoeik6Yyh6KTtlbHNlIGZvcig7bnVsbCE9PXomJiFoKCk7KXo9bCh6KT9lKHopOmMoeil9ZWxzZSBpZighKDA9PT1DfHxDPmEpKWlmKEM8PWFiKWZvcig7bnVsbCE9PXo7KXo9Yyh6KTtlbHNlIGZvcig7bnVsbCE9PXomJiFoKCk7KXo9Yyh6KX1mdW5jdGlvbiBrKGEsYil7Uz9LKFwiMjQzXCIpOnZvaWQgMDtTPSEwO2EuaXNSZWFkeUZvckNvbW1pdD1cbiExO2lmKGEhPT1hYXx8YiE9PUN8fG51bGw9PT16KXtmb3IoOy0xPEw7KXNhW0xdPW51bGwsTC0tO3RhPUY7Ty5jdXJyZW50PUY7US5jdXJyZW50PSExO1liKCk7YWE9YTtDPWI7ej1DYShhYS5jdXJyZW50LG51bGwsYil9dmFyIGM9ITEsZD1udWxsO3RyeXtwKGIpfWNhdGNoKFlhKXtjPSEwLGQ9WWF9Zm9yKDtjOyl7aWYocWEpe1A9ZDticmVha312YXIgZj16O2lmKG51bGw9PT1mKXFhPSEwO2Vsc2V7dmFyIGs9ZyhmLGQpO251bGw9PT1rP0soXCIxODNcIik6dm9pZCAwO2lmKCFxYSl7dHJ5e2M9aztkPWI7Zm9yKGs9YztudWxsIT09Zjspe3N3aXRjaChmLnRhZyl7Y2FzZSAyOnhhKGYpO2JyZWFrO2Nhc2UgNTpYYihmKTticmVhaztjYXNlIDM6bShmKTticmVhaztjYXNlIDQ6bShmKX1pZihmPT09a3x8Zi5hbHRlcm5hdGU9PT1rKWJyZWFrO2Y9ZltcInJldHVyblwiXX16PWUoYyk7cChkKX1jYXRjaChZYSl7Yz0hMDtkPVlhO2NvbnRpbnVlfWJyZWFrfX19Yj1QO3FhPVM9ITE7UD1udWxsO251bGwhPT1cbmImJmNhKGIpO3JldHVybiBhLmlzUmVhZHlGb3JDb21taXQ/YS5jdXJyZW50LmFsdGVybmF0ZTpudWxsfWZ1bmN0aW9uIGcoYSxiKXt2YXIgYz1pYS5jdXJyZW50PW51bGwsZD0hMSxlPSExLGY9bnVsbDtpZigzPT09YS50YWcpYz1hLHUoYSkmJihxYT0hMCk7ZWxzZSBmb3IodmFyIGc9YVtcInJldHVyblwiXTtudWxsIT09ZyYmbnVsbD09PWM7KXsyPT09Zy50YWc/XCJmdW5jdGlvblwiPT09dHlwZW9mIGcuc3RhdGVOb2RlLmNvbXBvbmVudERpZENhdGNoJiYoZD0hMCxmPWphKGcpLGM9ZyxlPSEwKTozPT09Zy50YWcmJihjPWcpO2lmKHUoZykpe2lmKFphfHxudWxsIT09UiYmKFIuaGFzKGcpfHxudWxsIT09Zy5hbHRlcm5hdGUmJlIuaGFzKGcuYWx0ZXJuYXRlKSkpcmV0dXJuIG51bGw7Yz1udWxsO2U9ITF9Zz1nW1wicmV0dXJuXCJdfWlmKG51bGwhPT1jKXtudWxsPT09WiYmKFo9bmV3IFNldCk7Wi5hZGQoYyk7dmFyIGs9XCJcIjtnPWE7ZG97YTpzd2l0Y2goZy50YWcpe2Nhc2UgMDpjYXNlIDE6Y2FzZSAyOmNhc2UgNTp2YXIgaD1cbmcuX2RlYnVnT3duZXIsbD1nLl9kZWJ1Z1NvdXJjZTt2YXIgbT1qYShnKTt2YXIgZWE9bnVsbDtoJiYoZWE9amEoaCkpO2g9bDttPVwiXFxuICAgIGluIFwiKyhtfHxcIlVua25vd25cIikrKGg/XCIgKGF0IFwiK2guZmlsZU5hbWUucmVwbGFjZSgvXi4qW1xcXFxcXC9dLyxcIlwiKStcIjpcIitoLmxpbmVOdW1iZXIrXCIpXCI6ZWE/XCIgKGNyZWF0ZWQgYnkgXCIrZWErXCIpXCI6XCJcIik7YnJlYWsgYTtkZWZhdWx0Om09XCJcIn1rKz1tO2c9Z1tcInJldHVyblwiXX13aGlsZShnKTtnPWs7YT1qYShhKTtudWxsPT09SiYmKEo9bmV3IE1hcCk7Yj17Y29tcG9uZW50TmFtZTphLGNvbXBvbmVudFN0YWNrOmcsZXJyb3I6YixlcnJvckJvdW5kYXJ5OmQ/Yy5zdGF0ZU5vZGU6bnVsbCxlcnJvckJvdW5kYXJ5Rm91bmQ6ZCxlcnJvckJvdW5kYXJ5TmFtZTpmLHdpbGxSZXRyeTplfTtKLnNldChjLGIpO3RyeXt2YXIgcD1iLmVycm9yO3AmJnAuc3VwcHJlc3NSZWFjdEVycm9yTG9nZ2luZ3x8Y29uc29sZS5lcnJvcihwKX1jYXRjaChiYil7YmImJlxuYmIuc3VwcHJlc3NSZWFjdEVycm9yTG9nZ2luZ3x8Y29uc29sZS5lcnJvcihiYil9SmE/KG51bGw9PT1SJiYoUj1uZXcgU2V0KSxSLmFkZChjKSk6QihjKTtyZXR1cm4gY31udWxsPT09UCYmKFA9Yik7cmV0dXJuIG51bGx9ZnVuY3Rpb24gbChhKXtyZXR1cm4gbnVsbCE9PUomJihKLmhhcyhhKXx8bnVsbCE9PWEuYWx0ZXJuYXRlJiZKLmhhcyhhLmFsdGVybmF0ZSkpfWZ1bmN0aW9uIHUoYSl7cmV0dXJuIG51bGwhPT1aJiYoWi5oYXMoYSl8fG51bGwhPT1hLmFsdGVybmF0ZSYmWi5oYXMoYS5hbHRlcm5hdGUpKX1mdW5jdGlvbiBBKCl7cmV0dXJuIDIwKigoKEQoKSsxMDApLzIwfDApKzEpfWZ1bmN0aW9uIHkoYSl7cmV0dXJuIDAhPT1UP1Q6Uz9KYT8xOkM6IW9jfHxhLmludGVybmFsQ29udGV4dFRhZyYxP0EoKToxfWZ1bmN0aW9uIHcoYSxiKXtyZXR1cm4geChhLGIsITEpfWZ1bmN0aW9uIHgoYSxiKXtmb3IoO251bGwhPT1hOyl7aWYoMD09PWEuZXhwaXJhdGlvblRpbWV8fGEuZXhwaXJhdGlvblRpbWU+XG5iKWEuZXhwaXJhdGlvblRpbWU9YjtudWxsIT09YS5hbHRlcm5hdGUmJigwPT09YS5hbHRlcm5hdGUuZXhwaXJhdGlvblRpbWV8fGEuYWx0ZXJuYXRlLmV4cGlyYXRpb25UaW1lPmIpJiYoYS5hbHRlcm5hdGUuZXhwaXJhdGlvblRpbWU9Yik7aWYobnVsbD09PWFbXCJyZXR1cm5cIl0paWYoMz09PWEudGFnKXt2YXIgYz1hLnN0YXRlTm9kZTshUyYmYz09PWFhJiZiPEMmJih6PWFhPW51bGwsQz0wKTt2YXIgZD1jLGU9YjtLYT5wYyYmSyhcIjE4NVwiKTtpZihudWxsPT09ZC5uZXh0U2NoZWR1bGVkUm9vdClkLnJlbWFpbmluZ0V4cGlyYXRpb25UaW1lPWUsbnVsbD09PUk/KGJhPUk9ZCxkLm5leHRTY2hlZHVsZWRSb290PWQpOihJPUkubmV4dFNjaGVkdWxlZFJvb3Q9ZCxJLm5leHRTY2hlZHVsZWRSb290PWJhKTtlbHNle3ZhciBnPWQucmVtYWluaW5nRXhwaXJhdGlvblRpbWU7aWYoMD09PWd8fGU8ZylkLnJlbWFpbmluZ0V4cGlyYXRpb25UaW1lPWV9ZmF8fChVP0xhJiYoVj1kLFc9MSxmKFYsXG5XKSk6MT09PWU/dCgxLG51bGwpOkcoZSkpOyFTJiZjPT09YWEmJmI8QyYmKHo9YWE9bnVsbCxDPTApfWVsc2UgYnJlYWs7YT1hW1wicmV0dXJuXCJdfX1mdW5jdGlvbiBCKGEpe3goYSwxLCEwKX1mdW5jdGlvbiBEKCl7cmV0dXJuIGFiPSgoY2IoKS1HYikvMTB8MCkrMn1mdW5jdGlvbiBHKGEpe2lmKDAhPT1NYSl7aWYoYT5NYSlyZXR1cm47cWMoZGIpfXZhciBiPWNiKCktR2I7TWE9YTtkYj1yYyhFLHt0aW1lb3V0OjEwKihhLTIpLWJ9KX1mdW5jdGlvbiBIKCl7dmFyIGE9MCxiPW51bGw7aWYobnVsbCE9PUkpZm9yKHZhciBjPUksZD1iYTtudWxsIT09ZDspe3ZhciBlPWQucmVtYWluaW5nRXhwaXJhdGlvblRpbWU7aWYoMD09PWUpe251bGw9PT1jfHxudWxsPT09ST9LKFwiMjQ0XCIpOnZvaWQgMDtpZihkPT09ZC5uZXh0U2NoZWR1bGVkUm9vdCl7YmE9ST1kLm5leHRTY2hlZHVsZWRSb290PW51bGw7YnJlYWt9ZWxzZSBpZihkPT09YmEpYmE9ZT1kLm5leHRTY2hlZHVsZWRSb290LEkubmV4dFNjaGVkdWxlZFJvb3Q9XG5lLGQubmV4dFNjaGVkdWxlZFJvb3Q9bnVsbDtlbHNlIGlmKGQ9PT1JKXtJPWM7SS5uZXh0U2NoZWR1bGVkUm9vdD1iYTtkLm5leHRTY2hlZHVsZWRSb290PW51bGw7YnJlYWt9ZWxzZSBjLm5leHRTY2hlZHVsZWRSb290PWQubmV4dFNjaGVkdWxlZFJvb3QsZC5uZXh0U2NoZWR1bGVkUm9vdD1udWxsO2Q9Yy5uZXh0U2NoZWR1bGVkUm9vdH1lbHNle2lmKDA9PT1hfHxlPGEpYT1lLGI9ZDtpZihkPT09SSlicmVhaztjPWQ7ZD1kLm5leHRTY2hlZHVsZWRSb290fX1jPVY7bnVsbCE9PWMmJmM9PT1iP0thKys6S2E9MDtWPWI7Vz1hfWZ1bmN0aW9uIEUoYSl7dCgwLGEpfWZ1bmN0aW9uIHQoYSxiKXtyYT1iO2ZvcihIKCk7bnVsbCE9PVYmJjAhPT1XJiYoMD09PWF8fFc8PWEpJiYhZWI7KWYoVixXKSxIKCk7bnVsbCE9PXJhJiYoTWE9MCxkYj0tMSk7MCE9PVcmJkcoVyk7cmE9bnVsbDtlYj0hMTtLYT0wO2lmKE5hKXRocm93IGE9ZmIsZmI9bnVsbCxOYT0hMSxhO31mdW5jdGlvbiBmKGEsYyl7ZmE/XG5LKFwiMjQ1XCIpOnZvaWQgMDtmYT0hMDtpZihjPD1EKCkpe3ZhciBkPWEuZmluaXNoZWRXb3JrO251bGwhPT1kPyhhLmZpbmlzaGVkV29yaz1udWxsLGEucmVtYWluaW5nRXhwaXJhdGlvblRpbWU9YihkKSk6KGEuZmluaXNoZWRXb3JrPW51bGwsZD1rKGEsYyksbnVsbCE9PWQmJihhLnJlbWFpbmluZ0V4cGlyYXRpb25UaW1lPWIoZCkpKX1lbHNlIGQ9YS5maW5pc2hlZFdvcmssbnVsbCE9PWQ/KGEuZmluaXNoZWRXb3JrPW51bGwsYS5yZW1haW5pbmdFeHBpcmF0aW9uVGltZT1iKGQpKTooYS5maW5pc2hlZFdvcms9bnVsbCxkPWsoYSxjKSxudWxsIT09ZCYmKGgoKT9hLmZpbmlzaGVkV29yaz1kOmEucmVtYWluaW5nRXhwaXJhdGlvblRpbWU9YihkKSkpO2ZhPSExfWZ1bmN0aW9uIGgoKXtyZXR1cm4gbnVsbD09PXJhfHxyYS50aW1lUmVtYWluaW5nKCk+c2M/ITE6ZWI9ITB9ZnVuY3Rpb24gY2EoYSl7bnVsbD09PVY/SyhcIjI0NlwiKTp2b2lkIDA7Vi5yZW1haW5pbmdFeHBpcmF0aW9uVGltZT1cbjA7TmF8fChOYT0hMCxmYj1hKX12YXIgcj1BYihhKSxxPUJiKGEpLG09ci5wb3BIb3N0Q29udGFpbmVyLFhiPXIucG9wSG9zdENvbnRleHQsWWI9ci5yZXNldEhvc3RDb250YWluZXIsRGI9d2IoYSxyLHEsdyx5KSxaYj1EYi5iZWdpbldvcmssbmM9RGIuYmVnaW5GYWlsZWRXb3JrLG1jPXhiKGEscixxKS5jb21wbGV0ZVdvcms7cj15YihhLGcpO3ZhciBnYz1yLmNvbW1pdFJlc2V0VGV4dENvbnRlbnQsRWI9ci5jb21taXRQbGFjZW1lbnQsaWM9ci5jb21taXREZWxldGlvbixGYj1yLmNvbW1pdFdvcmssa2M9ci5jb21taXRMaWZlQ3ljbGVzLGxjPXIuY29tbWl0QXR0YWNoUmVmLGhjPXIuY29tbWl0RGV0YWNoUmVmLGNiPWEubm93LHJjPWEuc2NoZWR1bGVEZWZlcnJlZENhbGxiYWNrLHFjPWEuY2FuY2VsRGVmZXJyZWRDYWxsYmFjayxvYz1hLnVzZVN5bmNTY2hlZHVsaW5nLGZjPWEucHJlcGFyZUZvckNvbW1pdCxqYz1hLnJlc2V0QWZ0ZXJDb21taXQsR2I9Y2IoKSxhYj0yLFQ9MCxTPVxuITEsej1udWxsLGFhPW51bGwsQz0wLHY9bnVsbCxKPW51bGwsWj1udWxsLFI9bnVsbCxQPW51bGwscWE9ITEsSmE9ITEsWmE9ITEsYmE9bnVsbCxJPW51bGwsTWE9MCxkYj0tMSxmYT0hMSxWPW51bGwsVz0wLGViPSExLE5hPSExLGZiPW51bGwscmE9bnVsbCxVPSExLExhPSExLHBjPTFFMyxLYT0wLHNjPTE7cmV0dXJue2NvbXB1dGVBc3luY0V4cGlyYXRpb246QSxjb21wdXRlRXhwaXJhdGlvbkZvckZpYmVyOnksc2NoZWR1bGVXb3JrOncsYmF0Y2hlZFVwZGF0ZXM6ZnVuY3Rpb24oYSxiKXt2YXIgYz1VO1U9ITA7dHJ5e3JldHVybiBhKGIpfWZpbmFsbHl7KFU9Yyl8fGZhfHx0KDEsbnVsbCl9fSx1bmJhdGNoZWRVcGRhdGVzOmZ1bmN0aW9uKGEpe2lmKFUmJiFMYSl7TGE9ITA7dHJ5e3JldHVybiBhKCl9ZmluYWxseXtMYT0hMX19cmV0dXJuIGEoKX0sZmx1c2hTeW5jOmZ1bmN0aW9uKGEpe3ZhciBiPVU7VT0hMDt0cnl7YTp7dmFyIGM9VDtUPTE7dHJ5e3ZhciBkPWEoKTticmVhayBhfWZpbmFsbHl7VD1cbmN9ZD12b2lkIDB9cmV0dXJuIGR9ZmluYWxseXtVPWIsZmE/SyhcIjE4N1wiKTp2b2lkIDAsdCgxLG51bGwpfX0sZGVmZXJyZWRVcGRhdGVzOmZ1bmN0aW9uKGEpe3ZhciBiPVQ7VD1BKCk7dHJ5e3JldHVybiBhKCl9ZmluYWxseXtUPWJ9fX19XG5mdW5jdGlvbiBIYihhKXtmdW5jdGlvbiBiKGEpe2E9b2EoYSk7cmV0dXJuIG51bGw9PT1hP251bGw6YS5zdGF0ZU5vZGV9dmFyIGQ9YS5nZXRQdWJsaWNJbnN0YW5jZTthPUNiKGEpO3ZhciBjPWEuY29tcHV0ZUFzeW5jRXhwaXJhdGlvbixlPWEuY29tcHV0ZUV4cGlyYXRpb25Gb3JGaWJlcixwPWEuc2NoZWR1bGVXb3JrO3JldHVybntjcmVhdGVDb250YWluZXI6ZnVuY3Rpb24oYSxiKXt2YXIgYz1uZXcgWCgzLG51bGwsMCk7YT17Y3VycmVudDpjLGNvbnRhaW5lckluZm86YSxwZW5kaW5nQ2hpbGRyZW46bnVsbCxyZW1haW5pbmdFeHBpcmF0aW9uVGltZTowLGlzUmVhZHlGb3JDb21taXQ6ITEsZmluaXNoZWRXb3JrOm51bGwsY29udGV4dDpudWxsLHBlbmRpbmdDb250ZXh0Om51bGwsaHlkcmF0ZTpiLG5leHRTY2hlZHVsZWRSb290Om51bGx9O3JldHVybiBjLnN0YXRlTm9kZT1hfSx1cGRhdGVDb250YWluZXI6ZnVuY3Rpb24oYSxiLGQsdSl7dmFyIGc9Yi5jdXJyZW50O2lmKGQpe2Q9XG5kLl9yZWFjdEludGVybmFsRmliZXI7dmFyIGs7Yjp7Mj09PWthKGQpJiYyPT09ZC50YWc/dm9pZCAwOksoXCIxNzBcIik7Zm9yKGs9ZDszIT09ay50YWc7KXtpZih2YShrKSl7az1rLnN0YXRlTm9kZS5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZE1lcmdlZENoaWxkQ29udGV4dDticmVhayBifShrPWtbXCJyZXR1cm5cIl0pP3ZvaWQgMDpLKFwiMTcxXCIpfWs9ay5zdGF0ZU5vZGUuY29udGV4dH1kPXZhKGQpP3phKGQsayk6a31lbHNlIGQ9RjtudWxsPT09Yi5jb250ZXh0P2IuY29udGV4dD1kOmIucGVuZGluZ0NvbnRleHQ9ZDtiPXU7Yj12b2lkIDA9PT1iP251bGw6Yjt1PW51bGwhPWEmJm51bGwhPWEudHlwZSYmbnVsbCE9YS50eXBlLnByb3RvdHlwZSYmITA9PT1hLnR5cGUucHJvdG90eXBlLnVuc3RhYmxlX2lzQXN5bmNSZWFjdENvbXBvbmVudD9jKCk6ZShnKTtXYShnLHtleHBpcmF0aW9uVGltZTp1LHBhcnRpYWxTdGF0ZTp7ZWxlbWVudDphfSxjYWxsYmFjazpiLGlzUmVwbGFjZTohMSxpc0ZvcmNlZDohMSxcbm5leHRDYWxsYmFjazpudWxsLG5leHQ6bnVsbH0pO3AoZyx1KX0sYmF0Y2hlZFVwZGF0ZXM6YS5iYXRjaGVkVXBkYXRlcyx1bmJhdGNoZWRVcGRhdGVzOmEudW5iYXRjaGVkVXBkYXRlcyxkZWZlcnJlZFVwZGF0ZXM6YS5kZWZlcnJlZFVwZGF0ZXMsZmx1c2hTeW5jOmEuZmx1c2hTeW5jLGdldFB1YmxpY1Jvb3RJbnN0YW5jZTpmdW5jdGlvbihhKXthPWEuY3VycmVudDtpZighYS5jaGlsZClyZXR1cm4gbnVsbDtzd2l0Y2goYS5jaGlsZC50YWcpe2Nhc2UgNTpyZXR1cm4gZChhLmNoaWxkLnN0YXRlTm9kZSk7ZGVmYXVsdDpyZXR1cm4gYS5jaGlsZC5zdGF0ZU5vZGV9fSxmaW5kSG9zdEluc3RhbmNlOmIsZmluZEhvc3RJbnN0YW5jZVdpdGhOb1BvcnRhbHM6ZnVuY3Rpb24oYSl7YT1wYShhKTtyZXR1cm4gbnVsbD09PWE/bnVsbDphLnN0YXRlTm9kZX0saW5qZWN0SW50b0RldlRvb2xzOmZ1bmN0aW9uKGEpe3ZhciBjPWEuZmluZEZpYmVyQnlIb3N0SW5zdGFuY2U7cmV0dXJuIFJhKG4oe30sXG5hLHtmaW5kSG9zdEluc3RhbmNlQnlGaWJlcjpmdW5jdGlvbihhKXtyZXR1cm4gYihhKX0sZmluZEZpYmVyQnlIb3N0SW5zdGFuY2U6ZnVuY3Rpb24oYSl7cmV0dXJuIGM/YyhhKTpudWxsfX0pKX19fXZhciBJYj1PYmplY3QuZnJlZXplKHtkZWZhdWx0OkhifSksSmI9SWImJkhifHxJYixLYj1KYltcImRlZmF1bHRcIl0/SmJbXCJkZWZhdWx0XCJdOkpiLExiPW51bGwsTWI9bnVsbDtmdW5jdGlvbiBOYihhKXtpZihhPW51bGwoYSkpe0soXCIxOTRcIik7dmFyIGI9bnVsbChhLnN0YXRlTm9kZSk7bnVsbC5yZXN0b3JlQ29udHJvbGxlZFN0YXRlKGEuc3RhdGVOb2RlLGEudHlwZSxiKX19XG52YXIgT2I9ITEsUGI9ZnVuY3Rpb24oKXtmdW5jdGlvbiBhKGEsZCl7Zm9yKHZhciBiPTA7YjxkLmxlbmd0aDtiKyspe3ZhciBlPWRbYl07ZS5lbnVtZXJhYmxlPWUuZW51bWVyYWJsZXx8ITE7ZS5jb25maWd1cmFibGU9ITA7XCJ2YWx1ZVwiaW4gZSYmKGUud3JpdGFibGU9ITApO09iamVjdC5kZWZpbmVQcm9wZXJ0eShhLGUua2V5LGUpfX1yZXR1cm4gZnVuY3Rpb24oYixkLGMpe2QmJmEoYi5wcm90b3R5cGUsZCk7YyYmYShiLGMpO3JldHVybiBifX0oKSxRYj17fTtmdW5jdGlvbiBSYihhKXtzd2l0Y2goYS50YWcpe2Nhc2UgXCJJTlNUQU5DRVwiOnZhciBiPWEucm9vdENvbnRhaW5lckluc3RhbmNlLmNyZWF0ZU5vZGVNb2NrO3JldHVybiBiKHt0eXBlOmEudHlwZSxwcm9wczphLnByb3BzfSk7ZGVmYXVsdDpyZXR1cm4gYX19XG5mdW5jdGlvbiBTYihhLGIpe3ZhciBkPWEuY2hpbGRyZW4uaW5kZXhPZihiKTstMSE9PWQmJmEuY2hpbGRyZW4uc3BsaWNlKGQsMSk7YS5jaGlsZHJlbi5wdXNoKGIpfWZ1bmN0aW9uIFRiKGEsYixkKXt2YXIgYz1hLmNoaWxkcmVuLmluZGV4T2YoYik7LTEhPT1jJiZhLmNoaWxkcmVuLnNwbGljZShjLDEpO2Q9YS5jaGlsZHJlbi5pbmRleE9mKGQpO2EuY2hpbGRyZW4uc3BsaWNlKGQsMCxiKX1mdW5jdGlvbiBVYihhLGIpe2I9YS5jaGlsZHJlbi5pbmRleE9mKGIpO2EuY2hpbGRyZW4uc3BsaWNlKGIsMSl9XG52YXIgVmI9S2Ioe2dldFJvb3RIb3N0Q29udGV4dDpmdW5jdGlvbigpe3JldHVybiBGfSxnZXRDaGlsZEhvc3RDb250ZXh0OmZ1bmN0aW9uKCl7cmV0dXJuIEZ9LHByZXBhcmVGb3JDb21taXQ6ZnVuY3Rpb24oKXt9LHJlc2V0QWZ0ZXJDb21taXQ6ZnVuY3Rpb24oKXt9LGNyZWF0ZUluc3RhbmNlOmZ1bmN0aW9uKGEsYixkKXtyZXR1cm57dHlwZTphLHByb3BzOmIsY2hpbGRyZW46W10scm9vdENvbnRhaW5lckluc3RhbmNlOmQsdGFnOlwiSU5TVEFOQ0VcIn19LGFwcGVuZEluaXRpYWxDaGlsZDpmdW5jdGlvbihhLGIpe3ZhciBkPWEuY2hpbGRyZW4uaW5kZXhPZihiKTstMSE9PWQmJmEuY2hpbGRyZW4uc3BsaWNlKGQsMSk7YS5jaGlsZHJlbi5wdXNoKGIpfSxmaW5hbGl6ZUluaXRpYWxDaGlsZHJlbjpmdW5jdGlvbigpe3JldHVybiExfSxwcmVwYXJlVXBkYXRlOmZ1bmN0aW9uKCl7cmV0dXJuIFFifSxzaG91bGRTZXRUZXh0Q29udGVudDpmdW5jdGlvbigpe3JldHVybiExfSxzaG91bGREZXByaW9yaXRpemVTdWJ0cmVlOmZ1bmN0aW9uKCl7cmV0dXJuITF9LFxuY3JlYXRlVGV4dEluc3RhbmNlOmZ1bmN0aW9uKGEpe3JldHVybnt0ZXh0OmEsdGFnOlwiVEVYVFwifX0sc2NoZWR1bGVEZWZlcnJlZENhbGxiYWNrOmZ1bmN0aW9uKGEpe3JldHVybiBzZXRUaW1lb3V0KGEsMCx7dGltZVJlbWFpbmluZzpJbmZpbml0eX0pfSxjYW5jZWxEZWZlcnJlZENhbGxiYWNrOmZ1bmN0aW9uKGEpe2NsZWFyVGltZW91dChhKX0sdXNlU3luY1NjaGVkdWxpbmc6ITAsZ2V0UHVibGljSW5zdGFuY2U6UmIsbm93OmZ1bmN0aW9uKCl7cmV0dXJuIDB9LG11dGF0aW9uOntjb21taXRVcGRhdGU6ZnVuY3Rpb24oYSxiLGQsYyxlKXthLnR5cGU9ZDthLnByb3BzPWV9LGNvbW1pdE1vdW50OmZ1bmN0aW9uKCl7fSxjb21taXRUZXh0VXBkYXRlOmZ1bmN0aW9uKGEsYixkKXthLnRleHQ9ZH0scmVzZXRUZXh0Q29udGVudDpmdW5jdGlvbigpe30sYXBwZW5kQ2hpbGQ6U2IsYXBwZW5kQ2hpbGRUb0NvbnRhaW5lcjpTYixpbnNlcnRCZWZvcmU6VGIsaW5zZXJ0SW5Db250YWluZXJCZWZvcmU6VGIsXG5yZW1vdmVDaGlsZDpVYixyZW1vdmVDaGlsZEZyb21Db250YWluZXI6VWJ9fSksV2I9e2NyZWF0ZU5vZGVNb2NrOmZ1bmN0aW9uKCl7cmV0dXJuIG51bGx9fTtcbmZ1bmN0aW9uICRiKGEpe3N3aXRjaChhLnRhZyl7Y2FzZSBcIlRFWFRcIjpyZXR1cm4gYS50ZXh0O2Nhc2UgXCJJTlNUQU5DRVwiOnZhciBiPWEucHJvcHMsZD1bXCJjaGlsZHJlblwiXSxjPXt9LGU7Zm9yKGUgaW4gYikwPD1kLmluZGV4T2YoZSl8fE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLGUpJiYoY1tlXT1iW2VdKTtiPW51bGw7YS5jaGlsZHJlbiYmYS5jaGlsZHJlbi5sZW5ndGgmJihiPWEuY2hpbGRyZW4ubWFwKCRiKSk7YT17dHlwZTphLnR5cGUscHJvcHM6YyxjaGlsZHJlbjpifTtPYmplY3QuZGVmaW5lUHJvcGVydHkoYSxcIiQkdHlwZW9mXCIse3ZhbHVlOlN5bWJvbFtcImZvclwiXShcInJlYWN0LnRlc3QuanNvblwiKX0pO3JldHVybiBhO2RlZmF1bHQ6dGhyb3cgRXJyb3IoXCJVbmV4cGVjdGVkIG5vZGUgdHlwZSBpbiB0b0pTT046IFwiK2EudGFnKTt9fVxuZnVuY3Rpb24gYWMoYSl7Zm9yKHZhciBiPVtdO251bGwhPWE7KWIucHVzaChhKSxhPWEuc2libGluZztiPWIubWFwKGJjKTtyZXR1cm4gYi5sZW5ndGg/YjpudWxsfVxuZnVuY3Rpb24gYmMoYSl7aWYobnVsbD09YSlyZXR1cm4gbnVsbDtzd2l0Y2goYS50YWcpe2Nhc2UgMzpyZXR1cm4gYmMoYS5jaGlsZCk7Y2FzZSAyOnZhciBiPWEudHlwZSxkPW4oe30sYS5tZW1vaXplZFByb3BzKSxjPWEuY2hpbGQ7cmV0dXJue25vZGVUeXBlOlwiY29tcG9uZW50XCIsdHlwZTpiLHByb3BzOmQsaW5zdGFuY2U6YS5zdGF0ZU5vZGUscmVuZGVyZWQ6YyYmYy5zaWJsaW5nP2FjKGEuY2hpbGQpOmJjKGEuY2hpbGQpfTtjYXNlIDE6cmV0dXJuIGI9YS50eXBlLGQ9bih7fSxhLm1lbW9pemVkUHJvcHMpLGM9YS5jaGlsZCx7bm9kZVR5cGU6XCJjb21wb25lbnRcIix0eXBlOmIscHJvcHM6ZCxpbnN0YW5jZTpudWxsLHJlbmRlcmVkOmMmJmMuc2libGluZz9hYyhhLmNoaWxkKTpiYyhhLmNoaWxkKX07Y2FzZSA1OnJldHVybntub2RlVHlwZTpcImhvc3RcIix0eXBlOmEudHlwZSxwcm9wczpuKHt9LGEubWVtb2l6ZWRQcm9wcyksaW5zdGFuY2U6bnVsbCxyZW5kZXJlZDphYyhhLmNoaWxkKX07XG5jYXNlIDY6cmV0dXJuIGEuc3RhdGVOb2RlLnRleHQ7ZGVmYXVsdDpLKFwiMjE0XCIsYS50YWcpfX12YXIgY2M9bmV3IFdlYWtNYXA7ZnVuY3Rpb24gZGMoYSl7dmFyIGI9Y2MuZ2V0KGEpO3ZvaWQgMD09PWImJm51bGwhPT1hLmFsdGVybmF0ZSYmKGI9Y2MuZ2V0KGEuYWx0ZXJuYXRlKSk7dm9pZCAwPT09YiYmKGI9bmV3IGVjKGEpLGNjLnNldChhLGIpKTtyZXR1cm4gYn1cbnZhciB0Yz1uZXcgU2V0KFsxLDIsNV0pLGVjPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gYShiKXtpZighKHRoaXMgaW5zdGFuY2VvZiBhKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO3RjLmhhcyhiLnRhZyk/dm9pZCAwOksoXCIyMjVcIixiLnRhZyk7dGhpcy5fZmliZXI9Yn1hLnByb3RvdHlwZS5fY3VycmVudEZpYmVyPWZ1bmN0aW9uKCl7dmFyIGE9bmEodGhpcy5fZmliZXIpO251bGw9PT1hP0soXCIyMjRcIik6dm9pZCAwO3JldHVybiBhfTthLnByb3RvdHlwZS5maW5kPWZ1bmN0aW9uKGEpe3JldHVybiB1Yyh0aGlzLmZpbmRBbGwoYSx7ZGVlcDohMX0pLFwibWF0Y2hpbmcgY3VzdG9tIHByZWRpY2F0ZTogXCIrYS50b1N0cmluZygpKX07YS5wcm90b3R5cGUuZmluZEJ5VHlwZT1mdW5jdGlvbihhKXtyZXR1cm4gdWModGhpcy5maW5kQWxsQnlUeXBlKGEse2RlZXA6ITF9KSwnd2l0aCBub2RlIHR5cGU6IFwiJysoYS5kaXNwbGF5TmFtZXx8YS5uYW1lKStcbidcIicpfTthLnByb3RvdHlwZS5maW5kQnlQcm9wcz1mdW5jdGlvbihhKXtyZXR1cm4gdWModGhpcy5maW5kQWxsQnlQcm9wcyhhLHtkZWVwOiExfSksXCJ3aXRoIHByb3BzOiBcIitKU09OLnN0cmluZ2lmeShhKSl9O2EucHJvdG90eXBlLmZpbmRBbGw9ZnVuY3Rpb24oYSl7cmV0dXJuIHZjKHRoaXMsYSwxPGFyZ3VtZW50cy5sZW5ndGgmJnZvaWQgMCE9PWFyZ3VtZW50c1sxXT9hcmd1bWVudHNbMV06bnVsbCl9O2EucHJvdG90eXBlLmZpbmRBbGxCeVR5cGU9ZnVuY3Rpb24oYSl7cmV0dXJuIHZjKHRoaXMsZnVuY3Rpb24oYil7cmV0dXJuIGIudHlwZT09PWF9LDE8YXJndW1lbnRzLmxlbmd0aCYmdm9pZCAwIT09YXJndW1lbnRzWzFdP2FyZ3VtZW50c1sxXTpudWxsKX07YS5wcm90b3R5cGUuZmluZEFsbEJ5UHJvcHM9ZnVuY3Rpb24oYSl7cmV0dXJuIHZjKHRoaXMsZnVuY3Rpb24oYil7dmFyIGM7aWYoYz1iLnByb3BzKWE6e2Zvcih2YXIgZCBpbiBhKWlmKGIucHJvcHNbZF0hPT1hW2RdKXtjPVxuITE7YnJlYWsgYX1jPSEwfXJldHVybiBjfSwxPGFyZ3VtZW50cy5sZW5ndGgmJnZvaWQgMCE9PWFyZ3VtZW50c1sxXT9hcmd1bWVudHNbMV06bnVsbCl9O1BiKGEsW3trZXk6XCJpbnN0YW5jZVwiLGdldDpmdW5jdGlvbigpe3JldHVybiA1PT09dGhpcy5fZmliZXIudGFnP1JiKHRoaXMuX2ZpYmVyLnN0YXRlTm9kZSk6dGhpcy5fZmliZXIuc3RhdGVOb2RlfX0se2tleTpcInR5cGVcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fZmliZXIudHlwZX19LHtrZXk6XCJwcm9wc1wiLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9jdXJyZW50RmliZXIoKS5tZW1vaXplZFByb3BzfX0se2tleTpcInBhcmVudFwiLGdldDpmdW5jdGlvbigpe3ZhciBhPXRoaXMuX2ZpYmVyW1wicmV0dXJuXCJdO3JldHVybiBudWxsPT09YXx8Mz09PWEudGFnP251bGw6ZGMoYSl9fSx7a2V5OlwiY2hpbGRyZW5cIixnZXQ6ZnVuY3Rpb24oKXt2YXIgYT1bXSxkPXRoaXMuX2N1cnJlbnRGaWJlcigpLGM9ZDtpZihudWxsPT09XG5jLmNoaWxkKXJldHVybiBhO2MuY2hpbGRbXCJyZXR1cm5cIl09YztjPWMuY2hpbGQ7YTpmb3IoOzspe3ZhciBlPSExO3N3aXRjaChjLnRhZyl7Y2FzZSAxOmNhc2UgMjpjYXNlIDU6YS5wdXNoKGRjKGMpKTticmVhaztjYXNlIDY6YS5wdXNoKFwiXCIrYy5tZW1vaXplZFByb3BzKTticmVhaztjYXNlIDEwOmU9ITA7YnJlYWs7ZGVmYXVsdDpLKFwiMjI2XCIsYy50YWcpfWlmKGUmJm51bGwhPT1jLmNoaWxkKWMuY2hpbGRbXCJyZXR1cm5cIl09YyxjPWMuY2hpbGQ7ZWxzZXtmb3IoO251bGw9PT1jLnNpYmxpbmc7KXtpZihjW1wicmV0dXJuXCJdPT09ZClicmVhayBhO2M9Y1tcInJldHVyblwiXX1jLnNpYmxpbmdbXCJyZXR1cm5cIl09Y1tcInJldHVyblwiXTtjPWMuc2libGluZ319cmV0dXJuIGF9fV0pO3JldHVybiBhfSgpO1xuZnVuY3Rpb24gdmMoYSxiLGQpe3ZhciBjPWQ/ZC5kZWVwOiEwLGU9W107aWYoYihhKSYmKGUucHVzaChhKSwhYykpcmV0dXJuIGU7Yz0hMDt2YXIgcD0hMSxrPXZvaWQgMDt0cnl7Zm9yKHZhciBnPWEuY2hpbGRyZW5bU3ltYm9sLml0ZXJhdG9yXSgpLGw7IShjPShsPWcubmV4dCgpKS5kb25lKTtjPSEwKXt2YXIgdT1sLnZhbHVlO1wic3RyaW5nXCIhPT10eXBlb2YgdSYmZS5wdXNoLmFwcGx5KGUsdmModSxiLGQpKX19Y2F0Y2goQSl7cD0hMCxrPUF9ZmluYWxseXt0cnl7aWYoIWMmJmdbXCJyZXR1cm5cIl0pZ1tcInJldHVyblwiXSgpfWZpbmFsbHl7aWYocCl0aHJvdyBrO319cmV0dXJuIGV9ZnVuY3Rpb24gdWMoYSxiKXtpZigxPT09YS5sZW5ndGgpcmV0dXJuIGFbMF07dGhyb3cgRXJyb3IoKDA9PT1hLmxlbmd0aD9cIk5vIGluc3RhbmNlcyBmb3VuZCBcIjpcIkV4cGVjdGVkIDEgYnV0IGZvdW5kIFwiK2EubGVuZ3RoK1wiIGluc3RhbmNlcyBcIikrYik7fVxudmFyIHdjPXtjcmVhdGU6ZnVuY3Rpb24oYSxiKXt2YXIgZD1XYi5jcmVhdGVOb2RlTW9jaztiJiZcImZ1bmN0aW9uXCI9PT10eXBlb2YgYi5jcmVhdGVOb2RlTW9jayYmKGQ9Yi5jcmVhdGVOb2RlTW9jayk7dmFyIGM9e2NoaWxkcmVuOltdLGNyZWF0ZU5vZGVNb2NrOmQsdGFnOlwiQ09OVEFJTkVSXCJ9LGU9VmIuY3JlYXRlQ29udGFpbmVyKGMsITEpO251bGw9PWU/SyhcIjIxNVwiKTp2b2lkIDA7VmIudXBkYXRlQ29udGFpbmVyKGEsZSxudWxsLG51bGwpO2E9e3Jvb3Q6dm9pZCAwLHRvSlNPTjpmdW5jdGlvbigpe3JldHVybiBudWxsPT1lfHxudWxsPT1lLmN1cnJlbnR8fG51bGw9PWN8fDA9PT1jLmNoaWxkcmVuLmxlbmd0aD9udWxsOjE9PT1jLmNoaWxkcmVuLmxlbmd0aD8kYihjLmNoaWxkcmVuWzBdKTpjLmNoaWxkcmVuLm1hcCgkYil9LHRvVHJlZTpmdW5jdGlvbigpe3JldHVybiBudWxsPT1lfHxudWxsPT1lLmN1cnJlbnQ/bnVsbDpiYyhlLmN1cnJlbnQpfSx1cGRhdGU6ZnVuY3Rpb24oYSl7bnVsbCE9XG5lJiZudWxsIT1lLmN1cnJlbnQmJlZiLnVwZGF0ZUNvbnRhaW5lcihhLGUsbnVsbCxudWxsKX0sdW5tb3VudDpmdW5jdGlvbigpe251bGwhPWUmJm51bGwhPWUuY3VycmVudCYmKFZiLnVwZGF0ZUNvbnRhaW5lcihudWxsLGUsbnVsbCksZT1jPW51bGwpfSxnZXRJbnN0YW5jZTpmdW5jdGlvbigpe3JldHVybiBudWxsPT1lfHxudWxsPT1lLmN1cnJlbnQ/bnVsbDpWYi5nZXRQdWJsaWNSb290SW5zdGFuY2UoZSl9fTtPYmplY3QuZGVmaW5lUHJvcGVydHkoYSxcInJvb3RcIix7Y29uZmlndXJhYmxlOiEwLGVudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7aWYobnVsbD09PWV8fG51bGw9PT1lLmN1cnJlbnQuY2hpbGQpdGhyb3cgRXJyb3IoXCJDYW4ndCBhY2Nlc3MgLnJvb3Qgb24gdW5tb3VudGVkIHRlc3QgcmVuZGVyZXJcIik7cmV0dXJuIGRjKGUuY3VycmVudC5jaGlsZCl9fSk7cmV0dXJuIGF9LHVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzOmZ1bmN0aW9uKGEsYil7aWYoT2IpcmV0dXJuIGEoYik7XG5PYj0hMDt0cnl7cmV0dXJuIGEoYil9ZmluYWxseXtpZihPYj0hMSxMYiYmKGI9TGIsYT1NYixNYj1MYj1udWxsLE5iKGIpLGEpKWZvcihiPTA7YjxhLmxlbmd0aDtiKyspTmIoYVtiXSl9fX0seGM9T2JqZWN0LmZyZWV6ZSh7ZGVmYXVsdDp3Y30pLHljPXhjJiZ3Y3x8eGM7bW9kdWxlLmV4cG9ydHM9eWNbXCJkZWZhdWx0XCJdP3ljW1wiZGVmYXVsdFwiXTp5YztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC10ZXN0LXJlbmRlcmVyL2Nqcy9yZWFjdC10ZXN0LXJlbmRlcmVyLnByb2R1Y3Rpb24ubWluLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LXRlc3QtcmVuZGVyZXIucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtdGVzdC1yZW5kZXJlci5kZXZlbG9wbWVudC5qcycpO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LXRlc3QtcmVuZGVyZXIvaW5kZXguanMiLCIvKiogQGxpY2Vuc2UgUmVhY3QgdjE2LjIuMFxuICogcmVhY3QuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cblxuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIChmdW5jdGlvbigpIHtcbid1c2Ugc3RyaWN0JztcblxudmFyIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG52YXIgZW1wdHlPYmplY3QgPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eU9iamVjdCcpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG52YXIgZW1wdHlGdW5jdGlvbiA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5RnVuY3Rpb24nKTtcbnZhciBjaGVja1Byb3BUeXBlcyA9IHJlcXVpcmUoJ3Byb3AtdHlwZXMvY2hlY2tQcm9wVHlwZXMnKTtcblxuLy8gVE9ETzogdGhpcyBpcyBzcGVjaWFsIGJlY2F1c2UgaXQgZ2V0cyBpbXBvcnRlZCBkdXJpbmcgYnVpbGQuXG5cbnZhciBSZWFjdFZlcnNpb24gPSAnMTYuMi4wJztcblxuLy8gVGhlIFN5bWJvbCB1c2VkIHRvIHRhZyB0aGUgUmVhY3RFbGVtZW50LWxpa2UgdHlwZXMuIElmIHRoZXJlIGlzIG5vIG5hdGl2ZSBTeW1ib2xcbi8vIG5vciBwb2x5ZmlsbCwgdGhlbiBhIHBsYWluIG51bWJlciBpcyB1c2VkIGZvciBwZXJmb3JtYW5jZS5cbnZhciBoYXNTeW1ib2wgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbFsnZm9yJ107XG5cbnZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2xbJ2ZvciddKCdyZWFjdC5lbGVtZW50JykgOiAweGVhYzc7XG52YXIgUkVBQ1RfQ0FMTF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sWydmb3InXSgncmVhY3QuY2FsbCcpIDogMHhlYWM4O1xudmFyIFJFQUNUX1JFVFVSTl9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sWydmb3InXSgncmVhY3QucmV0dXJuJykgOiAweGVhYzk7XG52YXIgUkVBQ1RfUE9SVEFMX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2xbJ2ZvciddKCdyZWFjdC5wb3J0YWwnKSA6IDB4ZWFjYTtcbnZhciBSRUFDVF9GUkFHTUVOVF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sWydmb3InXSgncmVhY3QuZnJhZ21lbnQnKSA6IDB4ZWFjYjtcblxudmFyIE1BWUJFX0lURVJBVE9SX1NZTUJPTCA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLml0ZXJhdG9yO1xudmFyIEZBVVhfSVRFUkFUT1JfU1lNQk9MID0gJ0BAaXRlcmF0b3InO1xuXG5mdW5jdGlvbiBnZXRJdGVyYXRvckZuKG1heWJlSXRlcmFibGUpIHtcbiAgaWYgKG1heWJlSXRlcmFibGUgPT09IG51bGwgfHwgdHlwZW9mIG1heWJlSXRlcmFibGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdmFyIG1heWJlSXRlcmF0b3IgPSBNQVlCRV9JVEVSQVRPUl9TWU1CT0wgJiYgbWF5YmVJdGVyYWJsZVtNQVlCRV9JVEVSQVRPUl9TWU1CT0xdIHx8IG1heWJlSXRlcmFibGVbRkFVWF9JVEVSQVRPUl9TWU1CT0xdO1xuICBpZiAodHlwZW9mIG1heWJlSXRlcmF0b3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gbWF5YmVJdGVyYXRvcjtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBXQVJOSU5HOiBETyBOT1QgbWFudWFsbHkgcmVxdWlyZSB0aGlzIG1vZHVsZS5cbiAqIFRoaXMgaXMgYSByZXBsYWNlbWVudCBmb3IgYGludmFyaWFudCguLi4pYCB1c2VkIGJ5IHRoZSBlcnJvciBjb2RlIHN5c3RlbVxuICogYW5kIHdpbGwgX29ubHlfIGJlIHJlcXVpcmVkIGJ5IHRoZSBjb3JyZXNwb25kaW5nIGJhYmVsIHBhc3MuXG4gKiBJdCBhbHdheXMgdGhyb3dzLlxuICovXG5cbi8qKlxuICogRm9ya2VkIGZyb20gZmJqcy93YXJuaW5nOlxuICogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL2ZianMvYmxvYi9lNjZiYTIwYWQ1YmU0MzNlYjU0NDIzZjJiMDk3ZDgyOTMyNGQ5ZGU2L3BhY2thZ2VzL2ZianMvc3JjL19fZm9ya3NfXy93YXJuaW5nLmpzXG4gKlxuICogT25seSBjaGFuZ2UgaXMgd2UgdXNlIGNvbnNvbGUud2FybiBpbnN0ZWFkIG9mIGNvbnNvbGUuZXJyb3IsXG4gKiBhbmQgZG8gbm90aGluZyB3aGVuICdjb25zb2xlJyBpcyBub3Qgc3VwcG9ydGVkLlxuICogVGhpcyByZWFsbHkgc2ltcGxpZmllcyB0aGUgY29kZS5cbiAqIC0tLVxuICogU2ltaWxhciB0byBpbnZhcmlhbnQgYnV0IG9ubHkgbG9ncyBhIHdhcm5pbmcgaWYgdGhlIGNvbmRpdGlvbiBpcyBub3QgbWV0LlxuICogVGhpcyBjYW4gYmUgdXNlZCB0byBsb2cgaXNzdWVzIGluIGRldmVsb3BtZW50IGVudmlyb25tZW50cyBpbiBjcml0aWNhbFxuICogcGF0aHMuIFJlbW92aW5nIHRoZSBsb2dnaW5nIGNvZGUgZm9yIHByb2R1Y3Rpb24gZW52aXJvbm1lbnRzIHdpbGwga2VlcCB0aGVcbiAqIHNhbWUgbG9naWMgYW5kIGZvbGxvdyB0aGUgc2FtZSBjb2RlIHBhdGhzLlxuICovXG5cbnZhciBsb3dQcmlvcml0eVdhcm5pbmcgPSBmdW5jdGlvbiAoKSB7fTtcblxue1xuICB2YXIgcHJpbnRXYXJuaW5nID0gZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgdmFyIGFyZ0luZGV4ID0gMDtcbiAgICB2YXIgbWVzc2FnZSA9ICdXYXJuaW5nOiAnICsgZm9ybWF0LnJlcGxhY2UoLyVzL2csIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBhcmdzW2FyZ0luZGV4KytdO1xuICAgIH0pO1xuICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbnNvbGUud2FybihtZXNzYWdlKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIC8vIC0tLSBXZWxjb21lIHRvIGRlYnVnZ2luZyBSZWFjdCAtLS1cbiAgICAgIC8vIFRoaXMgZXJyb3Igd2FzIHRocm93biBhcyBhIGNvbnZlbmllbmNlIHNvIHRoYXQgeW91IGNhbiB1c2UgdGhpcyBzdGFja1xuICAgICAgLy8gdG8gZmluZCB0aGUgY2FsbHNpdGUgdGhhdCBjYXVzZWQgdGhpcyB3YXJuaW5nIHRvIGZpcmUuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgfSBjYXRjaCAoeCkge31cbiAgfTtcblxuICBsb3dQcmlvcml0eVdhcm5pbmcgPSBmdW5jdGlvbiAoY29uZGl0aW9uLCBmb3JtYXQpIHtcbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignYHdhcm5pbmcoY29uZGl0aW9uLCBmb3JtYXQsIC4uLmFyZ3MpYCByZXF1aXJlcyBhIHdhcm5pbmcgJyArICdtZXNzYWdlIGFyZ3VtZW50Jyk7XG4gICAgfVxuICAgIGlmICghY29uZGl0aW9uKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuMiA+IDIgPyBfbGVuMiAtIDIgOiAwKSwgX2tleTIgPSAyOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgIGFyZ3NbX2tleTIgLSAyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICB9XG5cbiAgICAgIHByaW50V2FybmluZy5hcHBseSh1bmRlZmluZWQsIFtmb3JtYXRdLmNvbmNhdChhcmdzKSk7XG4gICAgfVxuICB9O1xufVxuXG52YXIgbG93UHJpb3JpdHlXYXJuaW5nJDEgPSBsb3dQcmlvcml0eVdhcm5pbmc7XG5cbnZhciBkaWRXYXJuU3RhdGVVcGRhdGVGb3JVbm1vdW50ZWRDb21wb25lbnQgPSB7fTtcblxuZnVuY3Rpb24gd2Fybk5vb3AocHVibGljSW5zdGFuY2UsIGNhbGxlck5hbWUpIHtcbiAge1xuICAgIHZhciBjb25zdHJ1Y3RvciA9IHB1YmxpY0luc3RhbmNlLmNvbnN0cnVjdG9yO1xuICAgIHZhciBjb21wb25lbnROYW1lID0gY29uc3RydWN0b3IgJiYgKGNvbnN0cnVjdG9yLmRpc3BsYXlOYW1lIHx8IGNvbnN0cnVjdG9yLm5hbWUpIHx8ICdSZWFjdENsYXNzJztcbiAgICB2YXIgd2FybmluZ0tleSA9IGNvbXBvbmVudE5hbWUgKyAnLicgKyBjYWxsZXJOYW1lO1xuICAgIGlmIChkaWRXYXJuU3RhdGVVcGRhdGVGb3JVbm1vdW50ZWRDb21wb25lbnRbd2FybmluZ0tleV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgd2FybmluZyhmYWxzZSwgJyVzKC4uLik6IENhbiBvbmx5IHVwZGF0ZSBhIG1vdW50ZWQgb3IgbW91bnRpbmcgY29tcG9uZW50LiAnICsgJ1RoaXMgdXN1YWxseSBtZWFucyB5b3UgY2FsbGVkICVzKCkgb24gYW4gdW5tb3VudGVkIGNvbXBvbmVudC4gJyArICdUaGlzIGlzIGEgbm8tb3AuXFxuXFxuUGxlYXNlIGNoZWNrIHRoZSBjb2RlIGZvciB0aGUgJXMgY29tcG9uZW50LicsIGNhbGxlck5hbWUsIGNhbGxlck5hbWUsIGNvbXBvbmVudE5hbWUpO1xuICAgIGRpZFdhcm5TdGF0ZVVwZGF0ZUZvclVubW91bnRlZENvbXBvbmVudFt3YXJuaW5nS2V5XSA9IHRydWU7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGlzIGlzIHRoZSBhYnN0cmFjdCBBUEkgZm9yIGFuIHVwZGF0ZSBxdWV1ZS5cbiAqL1xudmFyIFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlID0ge1xuICAvKipcbiAgICogQ2hlY2tzIHdoZXRoZXIgb3Igbm90IHRoaXMgY29tcG9zaXRlIGNvbXBvbmVudCBpcyBtb3VudGVkLlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB3ZSB3YW50IHRvIHRlc3QuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgbW91bnRlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEBmaW5hbFxuICAgKi9cbiAgaXNNb3VudGVkOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEZvcmNlcyBhbiB1cGRhdGUuIFRoaXMgc2hvdWxkIG9ubHkgYmUgaW52b2tlZCB3aGVuIGl0IGlzIGtub3duIHdpdGhcbiAgICogY2VydGFpbnR5IHRoYXQgd2UgYXJlICoqbm90KiogaW4gYSBET00gdHJhbnNhY3Rpb24uXG4gICAqXG4gICAqIFlvdSBtYXkgd2FudCB0byBjYWxsIHRoaXMgd2hlbiB5b3Uga25vdyB0aGF0IHNvbWUgZGVlcGVyIGFzcGVjdCBvZiB0aGVcbiAgICogY29tcG9uZW50J3Mgc3RhdGUgaGFzIGNoYW5nZWQgYnV0IGBzZXRTdGF0ZWAgd2FzIG5vdCBjYWxsZWQuXG4gICAqXG4gICAqIFRoaXMgd2lsbCBub3QgaW52b2tlIGBzaG91bGRDb21wb25lbnRVcGRhdGVgLCBidXQgaXQgd2lsbCBpbnZva2VcbiAgICogYGNvbXBvbmVudFdpbGxVcGRhdGVgIGFuZCBgY29tcG9uZW50RGlkVXBkYXRlYC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdGhhdCBzaG91bGQgcmVyZW5kZXIuXG4gICAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgY29tcG9uZW50IGlzIHVwZGF0ZWQuXG4gICAqIEBwYXJhbSB7P3N0cmluZ30gY2FsbGVyTmFtZSBuYW1lIG9mIHRoZSBjYWxsaW5nIGZ1bmN0aW9uIGluIHRoZSBwdWJsaWMgQVBJLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGVucXVldWVGb3JjZVVwZGF0ZTogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlLCBjYWxsYmFjaywgY2FsbGVyTmFtZSkge1xuICAgIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCAnZm9yY2VVcGRhdGUnKTtcbiAgfSxcblxuICAvKipcbiAgICogUmVwbGFjZXMgYWxsIG9mIHRoZSBzdGF0ZS4gQWx3YXlzIHVzZSB0aGlzIG9yIGBzZXRTdGF0ZWAgdG8gbXV0YXRlIHN0YXRlLlxuICAgKiBZb3Ugc2hvdWxkIHRyZWF0IGB0aGlzLnN0YXRlYCBhcyBpbW11dGFibGUuXG4gICAqXG4gICAqIFRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IGB0aGlzLnN0YXRlYCB3aWxsIGJlIGltbWVkaWF0ZWx5IHVwZGF0ZWQsIHNvXG4gICAqIGFjY2Vzc2luZyBgdGhpcy5zdGF0ZWAgYWZ0ZXIgY2FsbGluZyB0aGlzIG1ldGhvZCBtYXkgcmV0dXJuIHRoZSBvbGQgdmFsdWUuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRoYXQgc2hvdWxkIHJlcmVuZGVyLlxuICAgKiBAcGFyYW0ge29iamVjdH0gY29tcGxldGVTdGF0ZSBOZXh0IHN0YXRlLlxuICAgKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIGNvbXBvbmVudCBpcyB1cGRhdGVkLlxuICAgKiBAcGFyYW0gez9zdHJpbmd9IGNhbGxlck5hbWUgbmFtZSBvZiB0aGUgY2FsbGluZyBmdW5jdGlvbiBpbiB0aGUgcHVibGljIEFQSS5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnF1ZXVlUmVwbGFjZVN0YXRlOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UsIGNvbXBsZXRlU3RhdGUsIGNhbGxiYWNrLCBjYWxsZXJOYW1lKSB7XG4gICAgd2Fybk5vb3AocHVibGljSW5zdGFuY2UsICdyZXBsYWNlU3RhdGUnKTtcbiAgfSxcblxuICAvKipcbiAgICogU2V0cyBhIHN1YnNldCBvZiB0aGUgc3RhdGUuIFRoaXMgb25seSBleGlzdHMgYmVjYXVzZSBfcGVuZGluZ1N0YXRlIGlzXG4gICAqIGludGVybmFsLiBUaGlzIHByb3ZpZGVzIGEgbWVyZ2luZyBzdHJhdGVneSB0aGF0IGlzIG5vdCBhdmFpbGFibGUgdG8gZGVlcFxuICAgKiBwcm9wZXJ0aWVzIHdoaWNoIGlzIGNvbmZ1c2luZy4gVE9ETzogRXhwb3NlIHBlbmRpbmdTdGF0ZSBvciBkb24ndCB1c2UgaXRcbiAgICogZHVyaW5nIHRoZSBtZXJnZS5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdGhhdCBzaG91bGQgcmVyZW5kZXIuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJ0aWFsU3RhdGUgTmV4dCBwYXJ0aWFsIHN0YXRlIHRvIGJlIG1lcmdlZCB3aXRoIHN0YXRlLlxuICAgKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIGNvbXBvbmVudCBpcyB1cGRhdGVkLlxuICAgKiBAcGFyYW0gez9zdHJpbmd9IE5hbWUgb2YgdGhlIGNhbGxpbmcgZnVuY3Rpb24gaW4gdGhlIHB1YmxpYyBBUEkuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5xdWV1ZVNldFN0YXRlOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UsIHBhcnRpYWxTdGF0ZSwgY2FsbGJhY2ssIGNhbGxlck5hbWUpIHtcbiAgICB3YXJuTm9vcChwdWJsaWNJbnN0YW5jZSwgJ3NldFN0YXRlJyk7XG4gIH1cbn07XG5cbi8qKlxuICogQmFzZSBjbGFzcyBoZWxwZXJzIGZvciB0aGUgdXBkYXRpbmcgc3RhdGUgb2YgYSBjb21wb25lbnQuXG4gKi9cbmZ1bmN0aW9uIENvbXBvbmVudChwcm9wcywgY29udGV4dCwgdXBkYXRlcikge1xuICB0aGlzLnByb3BzID0gcHJvcHM7XG4gIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gIHRoaXMucmVmcyA9IGVtcHR5T2JqZWN0O1xuICAvLyBXZSBpbml0aWFsaXplIHRoZSBkZWZhdWx0IHVwZGF0ZXIgYnV0IHRoZSByZWFsIG9uZSBnZXRzIGluamVjdGVkIGJ5IHRoZVxuICAvLyByZW5kZXJlci5cbiAgdGhpcy51cGRhdGVyID0gdXBkYXRlciB8fCBSZWFjdE5vb3BVcGRhdGVRdWV1ZTtcbn1cblxuQ29tcG9uZW50LnByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50ID0ge307XG5cbi8qKlxuICogU2V0cyBhIHN1YnNldCBvZiB0aGUgc3RhdGUuIEFsd2F5cyB1c2UgdGhpcyB0byBtdXRhdGVcbiAqIHN0YXRlLiBZb3Ugc2hvdWxkIHRyZWF0IGB0aGlzLnN0YXRlYCBhcyBpbW11dGFibGUuXG4gKlxuICogVGhlcmUgaXMgbm8gZ3VhcmFudGVlIHRoYXQgYHRoaXMuc3RhdGVgIHdpbGwgYmUgaW1tZWRpYXRlbHkgdXBkYXRlZCwgc29cbiAqIGFjY2Vzc2luZyBgdGhpcy5zdGF0ZWAgYWZ0ZXIgY2FsbGluZyB0aGlzIG1ldGhvZCBtYXkgcmV0dXJuIHRoZSBvbGQgdmFsdWUuXG4gKlxuICogVGhlcmUgaXMgbm8gZ3VhcmFudGVlIHRoYXQgY2FsbHMgdG8gYHNldFN0YXRlYCB3aWxsIHJ1biBzeW5jaHJvbm91c2x5LFxuICogYXMgdGhleSBtYXkgZXZlbnR1YWxseSBiZSBiYXRjaGVkIHRvZ2V0aGVyLiAgWW91IGNhbiBwcm92aWRlIGFuIG9wdGlvbmFsXG4gKiBjYWxsYmFjayB0aGF0IHdpbGwgYmUgZXhlY3V0ZWQgd2hlbiB0aGUgY2FsbCB0byBzZXRTdGF0ZSBpcyBhY3R1YWxseVxuICogY29tcGxldGVkLlxuICpcbiAqIFdoZW4gYSBmdW5jdGlvbiBpcyBwcm92aWRlZCB0byBzZXRTdGF0ZSwgaXQgd2lsbCBiZSBjYWxsZWQgYXQgc29tZSBwb2ludCBpblxuICogdGhlIGZ1dHVyZSAobm90IHN5bmNocm9ub3VzbHkpLiBJdCB3aWxsIGJlIGNhbGxlZCB3aXRoIHRoZSB1cCB0byBkYXRlXG4gKiBjb21wb25lbnQgYXJndW1lbnRzIChzdGF0ZSwgcHJvcHMsIGNvbnRleHQpLiBUaGVzZSB2YWx1ZXMgY2FuIGJlIGRpZmZlcmVudFxuICogZnJvbSB0aGlzLiogYmVjYXVzZSB5b3VyIGZ1bmN0aW9uIG1heSBiZSBjYWxsZWQgYWZ0ZXIgcmVjZWl2ZVByb3BzIGJ1dCBiZWZvcmVcbiAqIHNob3VsZENvbXBvbmVudFVwZGF0ZSwgYW5kIHRoaXMgbmV3IHN0YXRlLCBwcm9wcywgYW5kIGNvbnRleHQgd2lsbCBub3QgeWV0IGJlXG4gKiBhc3NpZ25lZCB0byB0aGlzLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fGZ1bmN0aW9ufSBwYXJ0aWFsU3RhdGUgTmV4dCBwYXJ0aWFsIHN0YXRlIG9yIGZ1bmN0aW9uIHRvXG4gKiAgICAgICAgcHJvZHVjZSBuZXh0IHBhcnRpYWwgc3RhdGUgdG8gYmUgbWVyZ2VkIHdpdGggY3VycmVudCBzdGF0ZS5cbiAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgc3RhdGUgaXMgdXBkYXRlZC5cbiAqIEBmaW5hbFxuICogQHByb3RlY3RlZFxuICovXG5Db21wb25lbnQucHJvdG90eXBlLnNldFN0YXRlID0gZnVuY3Rpb24gKHBhcnRpYWxTdGF0ZSwgY2FsbGJhY2spIHtcbiAgISh0eXBlb2YgcGFydGlhbFN0YXRlID09PSAnb2JqZWN0JyB8fCB0eXBlb2YgcGFydGlhbFN0YXRlID09PSAnZnVuY3Rpb24nIHx8IHBhcnRpYWxTdGF0ZSA9PSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJ3NldFN0YXRlKC4uLik6IHRha2VzIGFuIG9iamVjdCBvZiBzdGF0ZSB2YXJpYWJsZXMgdG8gdXBkYXRlIG9yIGEgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBhbiBvYmplY3Qgb2Ygc3RhdGUgdmFyaWFibGVzLicpIDogdm9pZCAwO1xuICB0aGlzLnVwZGF0ZXIuZW5xdWV1ZVNldFN0YXRlKHRoaXMsIHBhcnRpYWxTdGF0ZSwgY2FsbGJhY2ssICdzZXRTdGF0ZScpO1xufTtcblxuLyoqXG4gKiBGb3JjZXMgYW4gdXBkYXRlLiBUaGlzIHNob3VsZCBvbmx5IGJlIGludm9rZWQgd2hlbiBpdCBpcyBrbm93biB3aXRoXG4gKiBjZXJ0YWludHkgdGhhdCB3ZSBhcmUgKipub3QqKiBpbiBhIERPTSB0cmFuc2FjdGlvbi5cbiAqXG4gKiBZb3UgbWF5IHdhbnQgdG8gY2FsbCB0aGlzIHdoZW4geW91IGtub3cgdGhhdCBzb21lIGRlZXBlciBhc3BlY3Qgb2YgdGhlXG4gKiBjb21wb25lbnQncyBzdGF0ZSBoYXMgY2hhbmdlZCBidXQgYHNldFN0YXRlYCB3YXMgbm90IGNhbGxlZC5cbiAqXG4gKiBUaGlzIHdpbGwgbm90IGludm9rZSBgc2hvdWxkQ29tcG9uZW50VXBkYXRlYCwgYnV0IGl0IHdpbGwgaW52b2tlXG4gKiBgY29tcG9uZW50V2lsbFVwZGF0ZWAgYW5kIGBjb21wb25lbnREaWRVcGRhdGVgLlxuICpcbiAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgdXBkYXRlIGlzIGNvbXBsZXRlLlxuICogQGZpbmFsXG4gKiBAcHJvdGVjdGVkXG4gKi9cbkNvbXBvbmVudC5wcm90b3R5cGUuZm9yY2VVcGRhdGUgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgdGhpcy51cGRhdGVyLmVucXVldWVGb3JjZVVwZGF0ZSh0aGlzLCBjYWxsYmFjaywgJ2ZvcmNlVXBkYXRlJyk7XG59O1xuXG4vKipcbiAqIERlcHJlY2F0ZWQgQVBJcy4gVGhlc2UgQVBJcyB1c2VkIHRvIGV4aXN0IG9uIGNsYXNzaWMgUmVhY3QgY2xhc3NlcyBidXQgc2luY2VcbiAqIHdlIHdvdWxkIGxpa2UgdG8gZGVwcmVjYXRlIHRoZW0sIHdlJ3JlIG5vdCBnb2luZyB0byBtb3ZlIHRoZW0gb3ZlciB0byB0aGlzXG4gKiBtb2Rlcm4gYmFzZSBjbGFzcy4gSW5zdGVhZCwgd2UgZGVmaW5lIGEgZ2V0dGVyIHRoYXQgd2FybnMgaWYgaXQncyBhY2Nlc3NlZC5cbiAqL1xue1xuICB2YXIgZGVwcmVjYXRlZEFQSXMgPSB7XG4gICAgaXNNb3VudGVkOiBbJ2lzTW91bnRlZCcsICdJbnN0ZWFkLCBtYWtlIHN1cmUgdG8gY2xlYW4gdXAgc3Vic2NyaXB0aW9ucyBhbmQgcGVuZGluZyByZXF1ZXN0cyBpbiAnICsgJ2NvbXBvbmVudFdpbGxVbm1vdW50IHRvIHByZXZlbnQgbWVtb3J5IGxlYWtzLiddLFxuICAgIHJlcGxhY2VTdGF0ZTogWydyZXBsYWNlU3RhdGUnLCAnUmVmYWN0b3IgeW91ciBjb2RlIHRvIHVzZSBzZXRTdGF0ZSBpbnN0ZWFkIChzZWUgJyArICdodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzMyMzYpLiddXG4gIH07XG4gIHZhciBkZWZpbmVEZXByZWNhdGlvbldhcm5pbmcgPSBmdW5jdGlvbiAobWV0aG9kTmFtZSwgaW5mbykge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb21wb25lbnQucHJvdG90eXBlLCBtZXRob2ROYW1lLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbG93UHJpb3JpdHlXYXJuaW5nJDEoZmFsc2UsICclcyguLi4pIGlzIGRlcHJlY2F0ZWQgaW4gcGxhaW4gSmF2YVNjcmlwdCBSZWFjdCBjbGFzc2VzLiAlcycsIGluZm9bMF0sIGluZm9bMV0pO1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuICBmb3IgKHZhciBmbk5hbWUgaW4gZGVwcmVjYXRlZEFQSXMpIHtcbiAgICBpZiAoZGVwcmVjYXRlZEFQSXMuaGFzT3duUHJvcGVydHkoZm5OYW1lKSkge1xuICAgICAgZGVmaW5lRGVwcmVjYXRpb25XYXJuaW5nKGZuTmFtZSwgZGVwcmVjYXRlZEFQSXNbZm5OYW1lXSk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQmFzZSBjbGFzcyBoZWxwZXJzIGZvciB0aGUgdXBkYXRpbmcgc3RhdGUgb2YgYSBjb21wb25lbnQuXG4gKi9cbmZ1bmN0aW9uIFB1cmVDb21wb25lbnQocHJvcHMsIGNvbnRleHQsIHVwZGF0ZXIpIHtcbiAgLy8gRHVwbGljYXRlZCBmcm9tIENvbXBvbmVudC5cbiAgdGhpcy5wcm9wcyA9IHByb3BzO1xuICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICB0aGlzLnJlZnMgPSBlbXB0eU9iamVjdDtcbiAgLy8gV2UgaW5pdGlhbGl6ZSB0aGUgZGVmYXVsdCB1cGRhdGVyIGJ1dCB0aGUgcmVhbCBvbmUgZ2V0cyBpbmplY3RlZCBieSB0aGVcbiAgLy8gcmVuZGVyZXIuXG4gIHRoaXMudXBkYXRlciA9IHVwZGF0ZXIgfHwgUmVhY3ROb29wVXBkYXRlUXVldWU7XG59XG5cbmZ1bmN0aW9uIENvbXBvbmVudER1bW15KCkge31cbkNvbXBvbmVudER1bW15LnByb3RvdHlwZSA9IENvbXBvbmVudC5wcm90b3R5cGU7XG52YXIgcHVyZUNvbXBvbmVudFByb3RvdHlwZSA9IFB1cmVDb21wb25lbnQucHJvdG90eXBlID0gbmV3IENvbXBvbmVudER1bW15KCk7XG5wdXJlQ29tcG9uZW50UHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUHVyZUNvbXBvbmVudDtcbi8vIEF2b2lkIGFuIGV4dHJhIHByb3RvdHlwZSBqdW1wIGZvciB0aGVzZSBtZXRob2RzLlxuX2Fzc2lnbihwdXJlQ29tcG9uZW50UHJvdG90eXBlLCBDb21wb25lbnQucHJvdG90eXBlKTtcbnB1cmVDb21wb25lbnRQcm90b3R5cGUuaXNQdXJlUmVhY3RDb21wb25lbnQgPSB0cnVlO1xuXG5mdW5jdGlvbiBBc3luY0NvbXBvbmVudChwcm9wcywgY29udGV4dCwgdXBkYXRlcikge1xuICAvLyBEdXBsaWNhdGVkIGZyb20gQ29tcG9uZW50LlxuICB0aGlzLnByb3BzID0gcHJvcHM7XG4gIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gIHRoaXMucmVmcyA9IGVtcHR5T2JqZWN0O1xuICAvLyBXZSBpbml0aWFsaXplIHRoZSBkZWZhdWx0IHVwZGF0ZXIgYnV0IHRoZSByZWFsIG9uZSBnZXRzIGluamVjdGVkIGJ5IHRoZVxuICAvLyByZW5kZXJlci5cbiAgdGhpcy51cGRhdGVyID0gdXBkYXRlciB8fCBSZWFjdE5vb3BVcGRhdGVRdWV1ZTtcbn1cblxudmFyIGFzeW5jQ29tcG9uZW50UHJvdG90eXBlID0gQXN5bmNDb21wb25lbnQucHJvdG90eXBlID0gbmV3IENvbXBvbmVudER1bW15KCk7XG5hc3luY0NvbXBvbmVudFByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEFzeW5jQ29tcG9uZW50O1xuLy8gQXZvaWQgYW4gZXh0cmEgcHJvdG90eXBlIGp1bXAgZm9yIHRoZXNlIG1ldGhvZHMuXG5fYXNzaWduKGFzeW5jQ29tcG9uZW50UHJvdG90eXBlLCBDb21wb25lbnQucHJvdG90eXBlKTtcbmFzeW5jQ29tcG9uZW50UHJvdG90eXBlLnVuc3RhYmxlX2lzQXN5bmNSZWFjdENvbXBvbmVudCA9IHRydWU7XG5hc3luY0NvbXBvbmVudFByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnByb3BzLmNoaWxkcmVuO1xufTtcblxuLyoqXG4gKiBLZWVwcyB0cmFjayBvZiB0aGUgY3VycmVudCBvd25lci5cbiAqXG4gKiBUaGUgY3VycmVudCBvd25lciBpcyB0aGUgY29tcG9uZW50IHdobyBzaG91bGQgb3duIGFueSBjb21wb25lbnRzIHRoYXQgYXJlXG4gKiBjdXJyZW50bHkgYmVpbmcgY29uc3RydWN0ZWQuXG4gKi9cbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IHtcbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBAdHlwZSB7UmVhY3RDb21wb25lbnR9XG4gICAqL1xuICBjdXJyZW50OiBudWxsXG59O1xuXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG52YXIgUkVTRVJWRURfUFJPUFMgPSB7XG4gIGtleTogdHJ1ZSxcbiAgcmVmOiB0cnVlLFxuICBfX3NlbGY6IHRydWUsXG4gIF9fc291cmNlOiB0cnVlXG59O1xuXG52YXIgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd247XG52YXIgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd247XG5cbmZ1bmN0aW9uIGhhc1ZhbGlkUmVmKGNvbmZpZykge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAncmVmJykpIHtcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ3JlZicpLmdldDtcbiAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNvbmZpZy5yZWYgIT09IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gaGFzVmFsaWRLZXkoY29uZmlnKSB7XG4gIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsICdrZXknKSkge1xuICAgICAgdmFyIGdldHRlciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY29uZmlnLCAna2V5JykuZ2V0O1xuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gY29uZmlnLmtleSAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpIHtcbiAgdmFyIHdhcm5BYm91dEFjY2Vzc2luZ0tleSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duKSB7XG4gICAgICBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93biA9IHRydWU7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnJXM6IGBrZXlgIGlzIG5vdCBhIHByb3AuIFRyeWluZyB0byBhY2Nlc3MgaXQgd2lsbCByZXN1bHQgJyArICdpbiBgdW5kZWZpbmVkYCBiZWluZyByZXR1cm5lZC4gSWYgeW91IG5lZWQgdG8gYWNjZXNzIHRoZSBzYW1lICcgKyAndmFsdWUgd2l0aGluIHRoZSBjaGlsZCBjb21wb25lbnQsIHlvdSBzaG91bGQgcGFzcyBpdCBhcyBhIGRpZmZlcmVudCAnICsgJ3Byb3AuIChodHRwczovL2ZiLm1lL3JlYWN0LXNwZWNpYWwtcHJvcHMpJywgZGlzcGxheU5hbWUpO1xuICAgIH1cbiAgfTtcbiAgd2FybkFib3V0QWNjZXNzaW5nS2V5LmlzUmVhY3RXYXJuaW5nID0gdHJ1ZTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCAna2V5Jywge1xuICAgIGdldDogd2FybkFib3V0QWNjZXNzaW5nS2V5LFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbn1cblxuZnVuY3Rpb24gZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKSB7XG4gIHZhciB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93bikge1xuICAgICAgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24gPSB0cnVlO1xuICAgICAgd2FybmluZyhmYWxzZSwgJyVzOiBgcmVmYCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0ICcgKyAnaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSAnICsgJ3ZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgJyArICdwcm9wLiAoaHR0cHM6Ly9mYi5tZS9yZWFjdC1zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKTtcbiAgICB9XG4gIH07XG4gIHdhcm5BYm91dEFjY2Vzc2luZ1JlZi5pc1JlYWN0V2FybmluZyA9IHRydWU7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9wcywgJ3JlZicsIHtcbiAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ1JlZixcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG59XG5cbi8qKlxuICogRmFjdG9yeSBtZXRob2QgdG8gY3JlYXRlIGEgbmV3IFJlYWN0IGVsZW1lbnQuIFRoaXMgbm8gbG9uZ2VyIGFkaGVyZXMgdG9cbiAqIHRoZSBjbGFzcyBwYXR0ZXJuLCBzbyBkbyBub3QgdXNlIG5ldyB0byBjYWxsIGl0LiBBbHNvLCBubyBpbnN0YW5jZW9mIGNoZWNrXG4gKiB3aWxsIHdvcmsuIEluc3RlYWQgdGVzdCAkJHR5cGVvZiBmaWVsZCBhZ2FpbnN0IFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKSB0byBjaGVja1xuICogaWYgc29tZXRoaW5nIGlzIGEgUmVhY3QgRWxlbWVudC5cbiAqXG4gKiBAcGFyYW0geyp9IHR5cGVcbiAqIEBwYXJhbSB7Kn0ga2V5XG4gKiBAcGFyYW0ge3N0cmluZ3xvYmplY3R9IHJlZlxuICogQHBhcmFtIHsqfSBzZWxmIEEgKnRlbXBvcmFyeSogaGVscGVyIHRvIGRldGVjdCBwbGFjZXMgd2hlcmUgYHRoaXNgIGlzXG4gKiBkaWZmZXJlbnQgZnJvbSB0aGUgYG93bmVyYCB3aGVuIFJlYWN0LmNyZWF0ZUVsZW1lbnQgaXMgY2FsbGVkLCBzbyB0aGF0IHdlXG4gKiBjYW4gd2Fybi4gV2Ugd2FudCB0byBnZXQgcmlkIG9mIG93bmVyIGFuZCByZXBsYWNlIHN0cmluZyBgcmVmYHMgd2l0aCBhcnJvd1xuICogZnVuY3Rpb25zLCBhbmQgYXMgbG9uZyBhcyBgdGhpc2AgYW5kIG93bmVyIGFyZSB0aGUgc2FtZSwgdGhlcmUgd2lsbCBiZSBub1xuICogY2hhbmdlIGluIGJlaGF2aW9yLlxuICogQHBhcmFtIHsqfSBzb3VyY2UgQW4gYW5ub3RhdGlvbiBvYmplY3QgKGFkZGVkIGJ5IGEgdHJhbnNwaWxlciBvciBvdGhlcndpc2UpXG4gKiBpbmRpY2F0aW5nIGZpbGVuYW1lLCBsaW5lIG51bWJlciwgYW5kL29yIG90aGVyIGluZm9ybWF0aW9uLlxuICogQHBhcmFtIHsqfSBvd25lclxuICogQHBhcmFtIHsqfSBwcm9wc1xuICogQGludGVybmFsXG4gKi9cbnZhciBSZWFjdEVsZW1lbnQgPSBmdW5jdGlvbiAodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgb3duZXIsIHByb3BzKSB7XG4gIHZhciBlbGVtZW50ID0ge1xuICAgIC8vIFRoaXMgdGFnIGFsbG93IHVzIHRvIHVuaXF1ZWx5IGlkZW50aWZ5IHRoaXMgYXMgYSBSZWFjdCBFbGVtZW50XG4gICAgJCR0eXBlb2Y6IFJFQUNUX0VMRU1FTlRfVFlQRSxcblxuICAgIC8vIEJ1aWx0LWluIHByb3BlcnRpZXMgdGhhdCBiZWxvbmcgb24gdGhlIGVsZW1lbnRcbiAgICB0eXBlOiB0eXBlLFxuICAgIGtleToga2V5LFxuICAgIHJlZjogcmVmLFxuICAgIHByb3BzOiBwcm9wcyxcblxuICAgIC8vIFJlY29yZCB0aGUgY29tcG9uZW50IHJlc3BvbnNpYmxlIGZvciBjcmVhdGluZyB0aGlzIGVsZW1lbnQuXG4gICAgX293bmVyOiBvd25lclxuICB9O1xuXG4gIHtcbiAgICAvLyBUaGUgdmFsaWRhdGlvbiBmbGFnIGlzIGN1cnJlbnRseSBtdXRhdGl2ZS4gV2UgcHV0IGl0IG9uXG4gICAgLy8gYW4gZXh0ZXJuYWwgYmFja2luZyBzdG9yZSBzbyB0aGF0IHdlIGNhbiBmcmVlemUgdGhlIHdob2xlIG9iamVjdC5cbiAgICAvLyBUaGlzIGNhbiBiZSByZXBsYWNlZCB3aXRoIGEgV2Vha01hcCBvbmNlIHRoZXkgYXJlIGltcGxlbWVudGVkIGluXG4gICAgLy8gY29tbW9ubHkgdXNlZCBkZXZlbG9wbWVudCBlbnZpcm9ubWVudHMuXG4gICAgZWxlbWVudC5fc3RvcmUgPSB7fTtcblxuICAgIC8vIFRvIG1ha2UgY29tcGFyaW5nIFJlYWN0RWxlbWVudHMgZWFzaWVyIGZvciB0ZXN0aW5nIHB1cnBvc2VzLCB3ZSBtYWtlXG4gICAgLy8gdGhlIHZhbGlkYXRpb24gZmxhZyBub24tZW51bWVyYWJsZSAod2hlcmUgcG9zc2libGUsIHdoaWNoIHNob3VsZFxuICAgIC8vIGluY2x1ZGUgZXZlcnkgZW52aXJvbm1lbnQgd2UgcnVuIHRlc3RzIGluKSwgc28gdGhlIHRlc3QgZnJhbWV3b3JrXG4gICAgLy8gaWdub3JlcyBpdC5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudC5fc3RvcmUsICd2YWxpZGF0ZWQnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBmYWxzZVxuICAgIH0pO1xuICAgIC8vIHNlbGYgYW5kIHNvdXJjZSBhcmUgREVWIG9ubHkgcHJvcGVydGllcy5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudCwgJ19zZWxmJywge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgdmFsdWU6IHNlbGZcbiAgICB9KTtcbiAgICAvLyBUd28gZWxlbWVudHMgY3JlYXRlZCBpbiB0d28gZGlmZmVyZW50IHBsYWNlcyBzaG91bGQgYmUgY29uc2lkZXJlZFxuICAgIC8vIGVxdWFsIGZvciB0ZXN0aW5nIHB1cnBvc2VzIGFuZCB0aGVyZWZvcmUgd2UgaGlkZSBpdCBmcm9tIGVudW1lcmF0aW9uLlxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX3NvdXJjZScsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgIHZhbHVlOiBzb3VyY2VcbiAgICB9KTtcbiAgICBpZiAoT2JqZWN0LmZyZWV6ZSkge1xuICAgICAgT2JqZWN0LmZyZWV6ZShlbGVtZW50LnByb3BzKTtcbiAgICAgIE9iamVjdC5mcmVlemUoZWxlbWVudCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnQ7XG59O1xuXG4vKipcbiAqIENyZWF0ZSBhbmQgcmV0dXJuIGEgbmV3IFJlYWN0RWxlbWVudCBvZiB0aGUgZ2l2ZW4gdHlwZS5cbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjY3JlYXRlZWxlbWVudFxuICovXG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50KHR5cGUsIGNvbmZpZywgY2hpbGRyZW4pIHtcbiAgdmFyIHByb3BOYW1lO1xuXG4gIC8vIFJlc2VydmVkIG5hbWVzIGFyZSBleHRyYWN0ZWRcbiAgdmFyIHByb3BzID0ge307XG5cbiAgdmFyIGtleSA9IG51bGw7XG4gIHZhciByZWYgPSBudWxsO1xuICB2YXIgc2VsZiA9IG51bGw7XG4gIHZhciBzb3VyY2UgPSBudWxsO1xuXG4gIGlmIChjb25maWcgIT0gbnVsbCkge1xuICAgIGlmIChoYXNWYWxpZFJlZihjb25maWcpKSB7XG4gICAgICByZWYgPSBjb25maWcucmVmO1xuICAgIH1cbiAgICBpZiAoaGFzVmFsaWRLZXkoY29uZmlnKSkge1xuICAgICAga2V5ID0gJycgKyBjb25maWcua2V5O1xuICAgIH1cblxuICAgIHNlbGYgPSBjb25maWcuX19zZWxmID09PSB1bmRlZmluZWQgPyBudWxsIDogY29uZmlnLl9fc2VsZjtcbiAgICBzb3VyY2UgPSBjb25maWcuX19zb3VyY2UgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBjb25maWcuX19zb3VyY2U7XG4gICAgLy8gUmVtYWluaW5nIHByb3BlcnRpZXMgYXJlIGFkZGVkIHRvIGEgbmV3IHByb3BzIG9iamVjdFxuICAgIGZvciAocHJvcE5hbWUgaW4gY29uZmlnKSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsIHByb3BOYW1lKSAmJiAhUkVTRVJWRURfUFJPUFMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGNvbmZpZ1twcm9wTmFtZV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gQ2hpbGRyZW4gY2FuIGJlIG1vcmUgdGhhbiBvbmUgYXJndW1lbnQsIGFuZCB0aG9zZSBhcmUgdHJhbnNmZXJyZWQgb250b1xuICAvLyB0aGUgbmV3bHkgYWxsb2NhdGVkIHByb3BzIG9iamVjdC5cbiAgdmFyIGNoaWxkcmVuTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCAtIDI7XG4gIGlmIChjaGlsZHJlbkxlbmd0aCA9PT0gMSkge1xuICAgIHByb3BzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gIH0gZWxzZSBpZiAoY2hpbGRyZW5MZW5ndGggPiAxKSB7XG4gICAgdmFyIGNoaWxkQXJyYXkgPSBBcnJheShjaGlsZHJlbkxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbkxlbmd0aDsgaSsrKSB7XG4gICAgICBjaGlsZEFycmF5W2ldID0gYXJndW1lbnRzW2kgKyAyXTtcbiAgICB9XG4gICAge1xuICAgICAgaWYgKE9iamVjdC5mcmVlemUpIHtcbiAgICAgICAgT2JqZWN0LmZyZWV6ZShjaGlsZEFycmF5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcHJvcHMuY2hpbGRyZW4gPSBjaGlsZEFycmF5O1xuICB9XG5cbiAgLy8gUmVzb2x2ZSBkZWZhdWx0IHByb3BzXG4gIGlmICh0eXBlICYmIHR5cGUuZGVmYXVsdFByb3BzKSB7XG4gICAgdmFyIGRlZmF1bHRQcm9wcyA9IHR5cGUuZGVmYXVsdFByb3BzO1xuICAgIGZvciAocHJvcE5hbWUgaW4gZGVmYXVsdFByb3BzKSB7XG4gICAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gZGVmYXVsdFByb3BzW3Byb3BOYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAge1xuICAgIGlmIChrZXkgfHwgcmVmKSB7XG4gICAgICBpZiAodHlwZW9mIHByb3BzLiQkdHlwZW9mID09PSAndW5kZWZpbmVkJyB8fCBwcm9wcy4kJHR5cGVvZiAhPT0gUkVBQ1RfRUxFTUVOVF9UWVBFKSB7XG4gICAgICAgIHZhciBkaXNwbGF5TmFtZSA9IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nID8gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgJ1Vua25vd24nIDogdHlwZTtcbiAgICAgICAgaWYgKGtleSkge1xuICAgICAgICAgIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlZikge1xuICAgICAgICAgIGRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIFJlYWN0RWxlbWVudCh0eXBlLCBrZXksIHJlZiwgc2VsZiwgc291cmNlLCBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LCBwcm9wcyk7XG59XG5cbi8qKlxuICogUmV0dXJuIGEgZnVuY3Rpb24gdGhhdCBwcm9kdWNlcyBSZWFjdEVsZW1lbnRzIG9mIGEgZ2l2ZW4gdHlwZS5cbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjY3JlYXRlZmFjdG9yeVxuICovXG5cblxuZnVuY3Rpb24gY2xvbmVBbmRSZXBsYWNlS2V5KG9sZEVsZW1lbnQsIG5ld0tleSkge1xuICB2YXIgbmV3RWxlbWVudCA9IFJlYWN0RWxlbWVudChvbGRFbGVtZW50LnR5cGUsIG5ld0tleSwgb2xkRWxlbWVudC5yZWYsIG9sZEVsZW1lbnQuX3NlbGYsIG9sZEVsZW1lbnQuX3NvdXJjZSwgb2xkRWxlbWVudC5fb3duZXIsIG9sZEVsZW1lbnQucHJvcHMpO1xuXG4gIHJldHVybiBuZXdFbGVtZW50O1xufVxuXG4vKipcbiAqIENsb25lIGFuZCByZXR1cm4gYSBuZXcgUmVhY3RFbGVtZW50IHVzaW5nIGVsZW1lbnQgYXMgdGhlIHN0YXJ0aW5nIHBvaW50LlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNjbG9uZWVsZW1lbnRcbiAqL1xuZnVuY3Rpb24gY2xvbmVFbGVtZW50KGVsZW1lbnQsIGNvbmZpZywgY2hpbGRyZW4pIHtcbiAgdmFyIHByb3BOYW1lO1xuXG4gIC8vIE9yaWdpbmFsIHByb3BzIGFyZSBjb3BpZWRcbiAgdmFyIHByb3BzID0gX2Fzc2lnbih7fSwgZWxlbWVudC5wcm9wcyk7XG5cbiAgLy8gUmVzZXJ2ZWQgbmFtZXMgYXJlIGV4dHJhY3RlZFxuICB2YXIga2V5ID0gZWxlbWVudC5rZXk7XG4gIHZhciByZWYgPSBlbGVtZW50LnJlZjtcbiAgLy8gU2VsZiBpcyBwcmVzZXJ2ZWQgc2luY2UgdGhlIG93bmVyIGlzIHByZXNlcnZlZC5cbiAgdmFyIHNlbGYgPSBlbGVtZW50Ll9zZWxmO1xuICAvLyBTb3VyY2UgaXMgcHJlc2VydmVkIHNpbmNlIGNsb25lRWxlbWVudCBpcyB1bmxpa2VseSB0byBiZSB0YXJnZXRlZCBieSBhXG4gIC8vIHRyYW5zcGlsZXIsIGFuZCB0aGUgb3JpZ2luYWwgc291cmNlIGlzIHByb2JhYmx5IGEgYmV0dGVyIGluZGljYXRvciBvZiB0aGVcbiAgLy8gdHJ1ZSBvd25lci5cbiAgdmFyIHNvdXJjZSA9IGVsZW1lbnQuX3NvdXJjZTtcblxuICAvLyBPd25lciB3aWxsIGJlIHByZXNlcnZlZCwgdW5sZXNzIHJlZiBpcyBvdmVycmlkZGVuXG4gIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuXG4gIGlmIChjb25maWcgIT0gbnVsbCkge1xuICAgIGlmIChoYXNWYWxpZFJlZihjb25maWcpKSB7XG4gICAgICAvLyBTaWxlbnRseSBzdGVhbCB0aGUgcmVmIGZyb20gdGhlIHBhcmVudC5cbiAgICAgIHJlZiA9IGNvbmZpZy5yZWY7XG4gICAgICBvd25lciA9IFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQ7XG4gICAgfVxuICAgIGlmIChoYXNWYWxpZEtleShjb25maWcpKSB7XG4gICAgICBrZXkgPSAnJyArIGNvbmZpZy5rZXk7XG4gICAgfVxuXG4gICAgLy8gUmVtYWluaW5nIHByb3BlcnRpZXMgb3ZlcnJpZGUgZXhpc3RpbmcgcHJvcHNcbiAgICB2YXIgZGVmYXVsdFByb3BzO1xuICAgIGlmIChlbGVtZW50LnR5cGUgJiYgZWxlbWVudC50eXBlLmRlZmF1bHRQcm9wcykge1xuICAgICAgZGVmYXVsdFByb3BzID0gZWxlbWVudC50eXBlLmRlZmF1bHRQcm9wcztcbiAgICB9XG4gICAgZm9yIChwcm9wTmFtZSBpbiBjb25maWcpIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgcHJvcE5hbWUpICYmICFSRVNFUlZFRF9QUk9QUy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgaWYgKGNvbmZpZ1twcm9wTmFtZV0gPT09IHVuZGVmaW5lZCAmJiBkZWZhdWx0UHJvcHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIC8vIFJlc29sdmUgZGVmYXVsdCBwcm9wc1xuICAgICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGRlZmF1bHRQcm9wc1twcm9wTmFtZV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gY29uZmlnW3Byb3BOYW1lXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIENoaWxkcmVuIGNhbiBiZSBtb3JlIHRoYW4gb25lIGFyZ3VtZW50LCBhbmQgdGhvc2UgYXJlIHRyYW5zZmVycmVkIG9udG9cbiAgLy8gdGhlIG5ld2x5IGFsbG9jYXRlZCBwcm9wcyBvYmplY3QuXG4gIHZhciBjaGlsZHJlbkxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGggLSAyO1xuICBpZiAoY2hpbGRyZW5MZW5ndGggPT09IDEpIHtcbiAgICBwcm9wcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICB9IGVsc2UgaWYgKGNoaWxkcmVuTGVuZ3RoID4gMSkge1xuICAgIHZhciBjaGlsZEFycmF5ID0gQXJyYXkoY2hpbGRyZW5MZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW5MZW5ndGg7IGkrKykge1xuICAgICAgY2hpbGRBcnJheVtpXSA9IGFyZ3VtZW50c1tpICsgMl07XG4gICAgfVxuICAgIHByb3BzLmNoaWxkcmVuID0gY2hpbGRBcnJheTtcbiAgfVxuXG4gIHJldHVybiBSZWFjdEVsZW1lbnQoZWxlbWVudC50eXBlLCBrZXksIHJlZiwgc2VsZiwgc291cmNlLCBvd25lciwgcHJvcHMpO1xufVxuXG4vKipcbiAqIFZlcmlmaWVzIHRoZSBvYmplY3QgaXMgYSBSZWFjdEVsZW1lbnQuXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI2lzdmFsaWRlbGVtZW50XG4gKiBAcGFyYW0gez9vYmplY3R9IG9iamVjdFxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBgb2JqZWN0YCBpcyBhIHZhbGlkIGNvbXBvbmVudC5cbiAqIEBmaW5hbFxuICovXG5mdW5jdGlvbiBpc1ZhbGlkRWxlbWVudChvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIG9iamVjdCAhPT0gbnVsbCAmJiBvYmplY3QuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRTtcbn1cblxudmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSB7fTtcblxue1xuICAvLyBDb21wb25lbnQgdGhhdCBpcyBiZWluZyB3b3JrZWQgb25cbiAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRDdXJyZW50U3RhY2sgPSBudWxsO1xuXG4gIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0U3RhY2tBZGRlbmR1bSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaW1wbCA9IFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0Q3VycmVudFN0YWNrO1xuICAgIGlmIChpbXBsKSB7XG4gICAgICByZXR1cm4gaW1wbCgpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcbn1cblxudmFyIFNFUEFSQVRPUiA9ICcuJztcbnZhciBTVUJTRVBBUkFUT1IgPSAnOic7XG5cbi8qKlxuICogRXNjYXBlIGFuZCB3cmFwIGtleSBzbyBpdCBpcyBzYWZlIHRvIHVzZSBhcyBhIHJlYWN0aWRcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IHRvIGJlIGVzY2FwZWQuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IHRoZSBlc2NhcGVkIGtleS5cbiAqL1xuZnVuY3Rpb24gZXNjYXBlKGtleSkge1xuICB2YXIgZXNjYXBlUmVnZXggPSAvWz06XS9nO1xuICB2YXIgZXNjYXBlckxvb2t1cCA9IHtcbiAgICAnPSc6ICc9MCcsXG4gICAgJzonOiAnPTInXG4gIH07XG4gIHZhciBlc2NhcGVkU3RyaW5nID0gKCcnICsga2V5KS5yZXBsYWNlKGVzY2FwZVJlZ2V4LCBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICByZXR1cm4gZXNjYXBlckxvb2t1cFttYXRjaF07XG4gIH0pO1xuXG4gIHJldHVybiAnJCcgKyBlc2NhcGVkU3RyaW5nO1xufVxuXG4vKipcbiAqIFRPRE86IFRlc3QgdGhhdCBhIHNpbmdsZSBjaGlsZCBhbmQgYW4gYXJyYXkgd2l0aCBvbmUgaXRlbSBoYXZlIHRoZSBzYW1lIGtleVxuICogcGF0dGVybi5cbiAqL1xuXG52YXIgZGlkV2FybkFib3V0TWFwcyA9IGZhbHNlO1xuXG52YXIgdXNlclByb3ZpZGVkS2V5RXNjYXBlUmVnZXggPSAvXFwvKy9nO1xuZnVuY3Rpb24gZXNjYXBlVXNlclByb3ZpZGVkS2V5KHRleHQpIHtcbiAgcmV0dXJuICgnJyArIHRleHQpLnJlcGxhY2UodXNlclByb3ZpZGVkS2V5RXNjYXBlUmVnZXgsICckJi8nKTtcbn1cblxudmFyIFBPT0xfU0laRSA9IDEwO1xudmFyIHRyYXZlcnNlQ29udGV4dFBvb2wgPSBbXTtcbmZ1bmN0aW9uIGdldFBvb2xlZFRyYXZlcnNlQ29udGV4dChtYXBSZXN1bHQsIGtleVByZWZpeCwgbWFwRnVuY3Rpb24sIG1hcENvbnRleHQpIHtcbiAgaWYgKHRyYXZlcnNlQ29udGV4dFBvb2wubGVuZ3RoKSB7XG4gICAgdmFyIHRyYXZlcnNlQ29udGV4dCA9IHRyYXZlcnNlQ29udGV4dFBvb2wucG9wKCk7XG4gICAgdHJhdmVyc2VDb250ZXh0LnJlc3VsdCA9IG1hcFJlc3VsdDtcbiAgICB0cmF2ZXJzZUNvbnRleHQua2V5UHJlZml4ID0ga2V5UHJlZml4O1xuICAgIHRyYXZlcnNlQ29udGV4dC5mdW5jID0gbWFwRnVuY3Rpb247XG4gICAgdHJhdmVyc2VDb250ZXh0LmNvbnRleHQgPSBtYXBDb250ZXh0O1xuICAgIHRyYXZlcnNlQ29udGV4dC5jb3VudCA9IDA7XG4gICAgcmV0dXJuIHRyYXZlcnNlQ29udGV4dDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4ge1xuICAgICAgcmVzdWx0OiBtYXBSZXN1bHQsXG4gICAgICBrZXlQcmVmaXg6IGtleVByZWZpeCxcbiAgICAgIGZ1bmM6IG1hcEZ1bmN0aW9uLFxuICAgICAgY29udGV4dDogbWFwQ29udGV4dCxcbiAgICAgIGNvdW50OiAwXG4gICAgfTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZWxlYXNlVHJhdmVyc2VDb250ZXh0KHRyYXZlcnNlQ29udGV4dCkge1xuICB0cmF2ZXJzZUNvbnRleHQucmVzdWx0ID0gbnVsbDtcbiAgdHJhdmVyc2VDb250ZXh0LmtleVByZWZpeCA9IG51bGw7XG4gIHRyYXZlcnNlQ29udGV4dC5mdW5jID0gbnVsbDtcbiAgdHJhdmVyc2VDb250ZXh0LmNvbnRleHQgPSBudWxsO1xuICB0cmF2ZXJzZUNvbnRleHQuY291bnQgPSAwO1xuICBpZiAodHJhdmVyc2VDb250ZXh0UG9vbC5sZW5ndGggPCBQT09MX1NJWkUpIHtcbiAgICB0cmF2ZXJzZUNvbnRleHRQb29sLnB1c2godHJhdmVyc2VDb250ZXh0KTtcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7Pyp9IGNoaWxkcmVuIENoaWxkcmVuIHRyZWUgY29udGFpbmVyLlxuICogQHBhcmFtIHshc3RyaW5nfSBuYW1lU29GYXIgTmFtZSBvZiB0aGUga2V5IHBhdGggc28gZmFyLlxuICogQHBhcmFtIHshZnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrIHRvIGludm9rZSB3aXRoIGVhY2ggY2hpbGQgZm91bmQuXG4gKiBAcGFyYW0gez8qfSB0cmF2ZXJzZUNvbnRleHQgVXNlZCB0byBwYXNzIGluZm9ybWF0aW9uIHRocm91Z2hvdXQgdGhlIHRyYXZlcnNhbFxuICogcHJvY2Vzcy5cbiAqIEByZXR1cm4geyFudW1iZXJ9IFRoZSBudW1iZXIgb2YgY2hpbGRyZW4gaW4gdGhpcyBzdWJ0cmVlLlxuICovXG5mdW5jdGlvbiB0cmF2ZXJzZUFsbENoaWxkcmVuSW1wbChjaGlsZHJlbiwgbmFtZVNvRmFyLCBjYWxsYmFjaywgdHJhdmVyc2VDb250ZXh0KSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIGNoaWxkcmVuO1xuXG4gIGlmICh0eXBlID09PSAndW5kZWZpbmVkJyB8fCB0eXBlID09PSAnYm9vbGVhbicpIHtcbiAgICAvLyBBbGwgb2YgdGhlIGFib3ZlIGFyZSBwZXJjZWl2ZWQgYXMgbnVsbC5cbiAgICBjaGlsZHJlbiA9IG51bGw7XG4gIH1cblxuICB2YXIgaW52b2tlQ2FsbGJhY2sgPSBmYWxzZTtcblxuICBpZiAoY2hpbGRyZW4gPT09IG51bGwpIHtcbiAgICBpbnZva2VDYWxsYmFjayA9IHRydWU7XG4gIH0gZWxzZSB7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgaW52b2tlQ2FsbGJhY2sgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgIHN3aXRjaCAoY2hpbGRyZW4uJCR0eXBlb2YpIHtcbiAgICAgICAgICBjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX0NBTExfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX1JFVFVSTl9UWVBFOlxuICAgICAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICAgICAgICBpbnZva2VDYWxsYmFjayA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoaW52b2tlQ2FsbGJhY2spIHtcbiAgICBjYWxsYmFjayh0cmF2ZXJzZUNvbnRleHQsIGNoaWxkcmVuLFxuICAgIC8vIElmIGl0J3MgdGhlIG9ubHkgY2hpbGQsIHRyZWF0IHRoZSBuYW1lIGFzIGlmIGl0IHdhcyB3cmFwcGVkIGluIGFuIGFycmF5XG4gICAgLy8gc28gdGhhdCBpdCdzIGNvbnNpc3RlbnQgaWYgdGhlIG51bWJlciBvZiBjaGlsZHJlbiBncm93cy5cbiAgICBuYW1lU29GYXIgPT09ICcnID8gU0VQQVJBVE9SICsgZ2V0Q29tcG9uZW50S2V5KGNoaWxkcmVuLCAwKSA6IG5hbWVTb0Zhcik7XG4gICAgcmV0dXJuIDE7XG4gIH1cblxuICB2YXIgY2hpbGQ7XG4gIHZhciBuZXh0TmFtZTtcbiAgdmFyIHN1YnRyZWVDb3VudCA9IDA7IC8vIENvdW50IG9mIGNoaWxkcmVuIGZvdW5kIGluIHRoZSBjdXJyZW50IHN1YnRyZWUuXG4gIHZhciBuZXh0TmFtZVByZWZpeCA9IG5hbWVTb0ZhciA9PT0gJycgPyBTRVBBUkFUT1IgOiBuYW1lU29GYXIgKyBTVUJTRVBBUkFUT1I7XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgIG5leHROYW1lID0gbmV4dE5hbWVQcmVmaXggKyBnZXRDb21wb25lbnRLZXkoY2hpbGQsIGkpO1xuICAgICAgc3VidHJlZUNvdW50ICs9IHRyYXZlcnNlQWxsQ2hpbGRyZW5JbXBsKGNoaWxkLCBuZXh0TmFtZSwgY2FsbGJhY2ssIHRyYXZlcnNlQ29udGV4dCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihjaGlsZHJlbik7XG4gICAgaWYgKHR5cGVvZiBpdGVyYXRvckZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB7XG4gICAgICAgIC8vIFdhcm4gYWJvdXQgdXNpbmcgTWFwcyBhcyBjaGlsZHJlblxuICAgICAgICBpZiAoaXRlcmF0b3JGbiA9PT0gY2hpbGRyZW4uZW50cmllcykge1xuICAgICAgICAgIHdhcm5pbmcoZGlkV2FybkFib3V0TWFwcywgJ1VzaW5nIE1hcHMgYXMgY2hpbGRyZW4gaXMgdW5zdXBwb3J0ZWQgYW5kIHdpbGwgbGlrZWx5IHlpZWxkICcgKyAndW5leHBlY3RlZCByZXN1bHRzLiBDb252ZXJ0IGl0IHRvIGEgc2VxdWVuY2UvaXRlcmFibGUgb2Yga2V5ZWQgJyArICdSZWFjdEVsZW1lbnRzIGluc3RlYWQuJXMnLCBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldFN0YWNrQWRkZW5kdW0oKSk7XG4gICAgICAgICAgZGlkV2FybkFib3V0TWFwcyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKGNoaWxkcmVuKTtcbiAgICAgIHZhciBzdGVwO1xuICAgICAgdmFyIGlpID0gMDtcbiAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgY2hpbGQgPSBzdGVwLnZhbHVlO1xuICAgICAgICBuZXh0TmFtZSA9IG5leHROYW1lUHJlZml4ICsgZ2V0Q29tcG9uZW50S2V5KGNoaWxkLCBpaSsrKTtcbiAgICAgICAgc3VidHJlZUNvdW50ICs9IHRyYXZlcnNlQWxsQ2hpbGRyZW5JbXBsKGNoaWxkLCBuZXh0TmFtZSwgY2FsbGJhY2ssIHRyYXZlcnNlQ29udGV4dCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgdmFyIGFkZGVuZHVtID0gJyc7XG4gICAgICB7XG4gICAgICAgIGFkZGVuZHVtID0gJyBJZiB5b3UgbWVhbnQgdG8gcmVuZGVyIGEgY29sbGVjdGlvbiBvZiBjaGlsZHJlbiwgdXNlIGFuIGFycmF5ICcgKyAnaW5zdGVhZC4nICsgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRTdGFja0FkZGVuZHVtKCk7XG4gICAgICB9XG4gICAgICB2YXIgY2hpbGRyZW5TdHJpbmcgPSAnJyArIGNoaWxkcmVuO1xuICAgICAgaW52YXJpYW50KGZhbHNlLCAnT2JqZWN0cyBhcmUgbm90IHZhbGlkIGFzIGEgUmVhY3QgY2hpbGQgKGZvdW5kOiAlcykuJXMnLCBjaGlsZHJlblN0cmluZyA9PT0gJ1tvYmplY3QgT2JqZWN0XScgPyAnb2JqZWN0IHdpdGgga2V5cyB7JyArIE9iamVjdC5rZXlzKGNoaWxkcmVuKS5qb2luKCcsICcpICsgJ30nIDogY2hpbGRyZW5TdHJpbmcsIGFkZGVuZHVtKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3VidHJlZUNvdW50O1xufVxuXG4vKipcbiAqIFRyYXZlcnNlcyBjaGlsZHJlbiB0aGF0IGFyZSB0eXBpY2FsbHkgc3BlY2lmaWVkIGFzIGBwcm9wcy5jaGlsZHJlbmAsIGJ1dFxuICogbWlnaHQgYWxzbyBiZSBzcGVjaWZpZWQgdGhyb3VnaCBhdHRyaWJ1dGVzOlxuICpcbiAqIC0gYHRyYXZlcnNlQWxsQ2hpbGRyZW4odGhpcy5wcm9wcy5jaGlsZHJlbiwgLi4uKWBcbiAqIC0gYHRyYXZlcnNlQWxsQ2hpbGRyZW4odGhpcy5wcm9wcy5sZWZ0UGFuZWxDaGlsZHJlbiwgLi4uKWBcbiAqXG4gKiBUaGUgYHRyYXZlcnNlQ29udGV4dGAgaXMgYW4gb3B0aW9uYWwgYXJndW1lbnQgdGhhdCBpcyBwYXNzZWQgdGhyb3VnaCB0aGVcbiAqIGVudGlyZSB0cmF2ZXJzYWwuIEl0IGNhbiBiZSB1c2VkIHRvIHN0b3JlIGFjY3VtdWxhdGlvbnMgb3IgYW55dGhpbmcgZWxzZSB0aGF0XG4gKiB0aGUgY2FsbGJhY2sgbWlnaHQgZmluZCByZWxldmFudC5cbiAqXG4gKiBAcGFyYW0gez8qfSBjaGlsZHJlbiBDaGlsZHJlbiB0cmVlIG9iamVjdC5cbiAqIEBwYXJhbSB7IWZ1bmN0aW9ufSBjYWxsYmFjayBUbyBpbnZva2UgdXBvbiB0cmF2ZXJzaW5nIGVhY2ggY2hpbGQuXG4gKiBAcGFyYW0gez8qfSB0cmF2ZXJzZUNvbnRleHQgQ29udGV4dCBmb3IgdHJhdmVyc2FsLlxuICogQHJldHVybiB7IW51bWJlcn0gVGhlIG51bWJlciBvZiBjaGlsZHJlbiBpbiB0aGlzIHN1YnRyZWUuXG4gKi9cbmZ1bmN0aW9uIHRyYXZlcnNlQWxsQ2hpbGRyZW4oY2hpbGRyZW4sIGNhbGxiYWNrLCB0cmF2ZXJzZUNvbnRleHQpIHtcbiAgaWYgKGNoaWxkcmVuID09IG51bGwpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIHJldHVybiB0cmF2ZXJzZUFsbENoaWxkcmVuSW1wbChjaGlsZHJlbiwgJycsIGNhbGxiYWNrLCB0cmF2ZXJzZUNvbnRleHQpO1xufVxuXG4vKipcbiAqIEdlbmVyYXRlIGEga2V5IHN0cmluZyB0aGF0IGlkZW50aWZpZXMgYSBjb21wb25lbnQgd2l0aGluIGEgc2V0LlxuICpcbiAqIEBwYXJhbSB7Kn0gY29tcG9uZW50IEEgY29tcG9uZW50IHRoYXQgY291bGQgY29udGFpbiBhIG1hbnVhbCBrZXkuXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXggSW5kZXggdGhhdCBpcyB1c2VkIGlmIGEgbWFudWFsIGtleSBpcyBub3QgcHJvdmlkZWQuXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGdldENvbXBvbmVudEtleShjb21wb25lbnQsIGluZGV4KSB7XG4gIC8vIERvIHNvbWUgdHlwZWNoZWNraW5nIGhlcmUgc2luY2Ugd2UgY2FsbCB0aGlzIGJsaW5kbHkuIFdlIHdhbnQgdG8gZW5zdXJlXG4gIC8vIHRoYXQgd2UgZG9uJ3QgYmxvY2sgcG90ZW50aWFsIGZ1dHVyZSBFUyBBUElzLlxuICBpZiAodHlwZW9mIGNvbXBvbmVudCA9PT0gJ29iamVjdCcgJiYgY29tcG9uZW50ICE9PSBudWxsICYmIGNvbXBvbmVudC5rZXkgIT0gbnVsbCkge1xuICAgIC8vIEV4cGxpY2l0IGtleVxuICAgIHJldHVybiBlc2NhcGUoY29tcG9uZW50LmtleSk7XG4gIH1cbiAgLy8gSW1wbGljaXQga2V5IGRldGVybWluZWQgYnkgdGhlIGluZGV4IGluIHRoZSBzZXRcbiAgcmV0dXJuIGluZGV4LnRvU3RyaW5nKDM2KTtcbn1cblxuZnVuY3Rpb24gZm9yRWFjaFNpbmdsZUNoaWxkKGJvb2tLZWVwaW5nLCBjaGlsZCwgbmFtZSkge1xuICB2YXIgZnVuYyA9IGJvb2tLZWVwaW5nLmZ1bmMsXG4gICAgICBjb250ZXh0ID0gYm9va0tlZXBpbmcuY29udGV4dDtcblxuICBmdW5jLmNhbGwoY29udGV4dCwgY2hpbGQsIGJvb2tLZWVwaW5nLmNvdW50KyspO1xufVxuXG4vKipcbiAqIEl0ZXJhdGVzIHRocm91Z2ggY2hpbGRyZW4gdGhhdCBhcmUgdHlwaWNhbGx5IHNwZWNpZmllZCBhcyBgcHJvcHMuY2hpbGRyZW5gLlxuICpcbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjcmVhY3QuY2hpbGRyZW4uZm9yZWFjaFxuICpcbiAqIFRoZSBwcm92aWRlZCBmb3JFYWNoRnVuYyhjaGlsZCwgaW5kZXgpIHdpbGwgYmUgY2FsbGVkIGZvciBlYWNoXG4gKiBsZWFmIGNoaWxkLlxuICpcbiAqIEBwYXJhbSB7Pyp9IGNoaWxkcmVuIENoaWxkcmVuIHRyZWUgY29udGFpbmVyLlxuICogQHBhcmFtIHtmdW5jdGlvbigqLCBpbnQpfSBmb3JFYWNoRnVuY1xuICogQHBhcmFtIHsqfSBmb3JFYWNoQ29udGV4dCBDb250ZXh0IGZvciBmb3JFYWNoQ29udGV4dC5cbiAqL1xuZnVuY3Rpb24gZm9yRWFjaENoaWxkcmVuKGNoaWxkcmVuLCBmb3JFYWNoRnVuYywgZm9yRWFjaENvbnRleHQpIHtcbiAgaWYgKGNoaWxkcmVuID09IG51bGwpIHtcbiAgICByZXR1cm4gY2hpbGRyZW47XG4gIH1cbiAgdmFyIHRyYXZlcnNlQ29udGV4dCA9IGdldFBvb2xlZFRyYXZlcnNlQ29udGV4dChudWxsLCBudWxsLCBmb3JFYWNoRnVuYywgZm9yRWFjaENvbnRleHQpO1xuICB0cmF2ZXJzZUFsbENoaWxkcmVuKGNoaWxkcmVuLCBmb3JFYWNoU2luZ2xlQ2hpbGQsIHRyYXZlcnNlQ29udGV4dCk7XG4gIHJlbGVhc2VUcmF2ZXJzZUNvbnRleHQodHJhdmVyc2VDb250ZXh0KTtcbn1cblxuZnVuY3Rpb24gbWFwU2luZ2xlQ2hpbGRJbnRvQ29udGV4dChib29rS2VlcGluZywgY2hpbGQsIGNoaWxkS2V5KSB7XG4gIHZhciByZXN1bHQgPSBib29rS2VlcGluZy5yZXN1bHQsXG4gICAgICBrZXlQcmVmaXggPSBib29rS2VlcGluZy5rZXlQcmVmaXgsXG4gICAgICBmdW5jID0gYm9va0tlZXBpbmcuZnVuYyxcbiAgICAgIGNvbnRleHQgPSBib29rS2VlcGluZy5jb250ZXh0O1xuXG5cbiAgdmFyIG1hcHBlZENoaWxkID0gZnVuYy5jYWxsKGNvbnRleHQsIGNoaWxkLCBib29rS2VlcGluZy5jb3VudCsrKTtcbiAgaWYgKEFycmF5LmlzQXJyYXkobWFwcGVkQ2hpbGQpKSB7XG4gICAgbWFwSW50b1dpdGhLZXlQcmVmaXhJbnRlcm5hbChtYXBwZWRDaGlsZCwgcmVzdWx0LCBjaGlsZEtleSwgZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc0FyZ3VtZW50KTtcbiAgfSBlbHNlIGlmIChtYXBwZWRDaGlsZCAhPSBudWxsKSB7XG4gICAgaWYgKGlzVmFsaWRFbGVtZW50KG1hcHBlZENoaWxkKSkge1xuICAgICAgbWFwcGVkQ2hpbGQgPSBjbG9uZUFuZFJlcGxhY2VLZXkobWFwcGVkQ2hpbGQsXG4gICAgICAvLyBLZWVwIGJvdGggdGhlIChtYXBwZWQpIGFuZCBvbGQga2V5cyBpZiB0aGV5IGRpZmZlciwganVzdCBhc1xuICAgICAgLy8gdHJhdmVyc2VBbGxDaGlsZHJlbiB1c2VkIHRvIGRvIGZvciBvYmplY3RzIGFzIGNoaWxkcmVuXG4gICAgICBrZXlQcmVmaXggKyAobWFwcGVkQ2hpbGQua2V5ICYmICghY2hpbGQgfHwgY2hpbGQua2V5ICE9PSBtYXBwZWRDaGlsZC5rZXkpID8gZXNjYXBlVXNlclByb3ZpZGVkS2V5KG1hcHBlZENoaWxkLmtleSkgKyAnLycgOiAnJykgKyBjaGlsZEtleSk7XG4gICAgfVxuICAgIHJlc3VsdC5wdXNoKG1hcHBlZENoaWxkKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXBJbnRvV2l0aEtleVByZWZpeEludGVybmFsKGNoaWxkcmVuLCBhcnJheSwgcHJlZml4LCBmdW5jLCBjb250ZXh0KSB7XG4gIHZhciBlc2NhcGVkUHJlZml4ID0gJyc7XG4gIGlmIChwcmVmaXggIT0gbnVsbCkge1xuICAgIGVzY2FwZWRQcmVmaXggPSBlc2NhcGVVc2VyUHJvdmlkZWRLZXkocHJlZml4KSArICcvJztcbiAgfVxuICB2YXIgdHJhdmVyc2VDb250ZXh0ID0gZ2V0UG9vbGVkVHJhdmVyc2VDb250ZXh0KGFycmF5LCBlc2NhcGVkUHJlZml4LCBmdW5jLCBjb250ZXh0KTtcbiAgdHJhdmVyc2VBbGxDaGlsZHJlbihjaGlsZHJlbiwgbWFwU2luZ2xlQ2hpbGRJbnRvQ29udGV4dCwgdHJhdmVyc2VDb250ZXh0KTtcbiAgcmVsZWFzZVRyYXZlcnNlQ29udGV4dCh0cmF2ZXJzZUNvbnRleHQpO1xufVxuXG4vKipcbiAqIE1hcHMgY2hpbGRyZW4gdGhhdCBhcmUgdHlwaWNhbGx5IHNwZWNpZmllZCBhcyBgcHJvcHMuY2hpbGRyZW5gLlxuICpcbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjcmVhY3QuY2hpbGRyZW4ubWFwXG4gKlxuICogVGhlIHByb3ZpZGVkIG1hcEZ1bmN0aW9uKGNoaWxkLCBrZXksIGluZGV4KSB3aWxsIGJlIGNhbGxlZCBmb3IgZWFjaFxuICogbGVhZiBjaGlsZC5cbiAqXG4gKiBAcGFyYW0gez8qfSBjaGlsZHJlbiBDaGlsZHJlbiB0cmVlIGNvbnRhaW5lci5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKiwgaW50KX0gZnVuYyBUaGUgbWFwIGZ1bmN0aW9uLlxuICogQHBhcmFtIHsqfSBjb250ZXh0IENvbnRleHQgZm9yIG1hcEZ1bmN0aW9uLlxuICogQHJldHVybiB7b2JqZWN0fSBPYmplY3QgY29udGFpbmluZyB0aGUgb3JkZXJlZCBtYXAgb2YgcmVzdWx0cy5cbiAqL1xuZnVuY3Rpb24gbWFwQ2hpbGRyZW4oY2hpbGRyZW4sIGZ1bmMsIGNvbnRleHQpIHtcbiAgaWYgKGNoaWxkcmVuID09IG51bGwpIHtcbiAgICByZXR1cm4gY2hpbGRyZW47XG4gIH1cbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBtYXBJbnRvV2l0aEtleVByZWZpeEludGVybmFsKGNoaWxkcmVuLCByZXN1bHQsIG51bGwsIGZ1bmMsIGNvbnRleHQpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIENvdW50IHRoZSBudW1iZXIgb2YgY2hpbGRyZW4gdGhhdCBhcmUgdHlwaWNhbGx5IHNwZWNpZmllZCBhc1xuICogYHByb3BzLmNoaWxkcmVuYC5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI3JlYWN0LmNoaWxkcmVuLmNvdW50XG4gKlxuICogQHBhcmFtIHs/Kn0gY2hpbGRyZW4gQ2hpbGRyZW4gdHJlZSBjb250YWluZXIuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBudW1iZXIgb2YgY2hpbGRyZW4uXG4gKi9cbmZ1bmN0aW9uIGNvdW50Q2hpbGRyZW4oY2hpbGRyZW4sIGNvbnRleHQpIHtcbiAgcmV0dXJuIHRyYXZlcnNlQWxsQ2hpbGRyZW4oY2hpbGRyZW4sIGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNOdWxsLCBudWxsKTtcbn1cblxuLyoqXG4gKiBGbGF0dGVuIGEgY2hpbGRyZW4gb2JqZWN0ICh0eXBpY2FsbHkgc3BlY2lmaWVkIGFzIGBwcm9wcy5jaGlsZHJlbmApIGFuZFxuICogcmV0dXJuIGFuIGFycmF5IHdpdGggYXBwcm9wcmlhdGVseSByZS1rZXllZCBjaGlsZHJlbi5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI3JlYWN0LmNoaWxkcmVuLnRvYXJyYXlcbiAqL1xuZnVuY3Rpb24gdG9BcnJheShjaGlsZHJlbikge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIG1hcEludG9XaXRoS2V5UHJlZml4SW50ZXJuYWwoY2hpbGRyZW4sIHJlc3VsdCwgbnVsbCwgZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc0FyZ3VtZW50KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBmaXJzdCBjaGlsZCBpbiBhIGNvbGxlY3Rpb24gb2YgY2hpbGRyZW4gYW5kIHZlcmlmaWVzIHRoYXQgdGhlcmVcbiAqIGlzIG9ubHkgb25lIGNoaWxkIGluIHRoZSBjb2xsZWN0aW9uLlxuICpcbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjcmVhY3QuY2hpbGRyZW4ub25seVxuICpcbiAqIFRoZSBjdXJyZW50IGltcGxlbWVudGF0aW9uIG9mIHRoaXMgZnVuY3Rpb24gYXNzdW1lcyB0aGF0IGEgc2luZ2xlIGNoaWxkIGdldHNcbiAqIHBhc3NlZCB3aXRob3V0IGEgd3JhcHBlciwgYnV0IHRoZSBwdXJwb3NlIG9mIHRoaXMgaGVscGVyIGZ1bmN0aW9uIGlzIHRvXG4gKiBhYnN0cmFjdCBhd2F5IHRoZSBwYXJ0aWN1bGFyIHN0cnVjdHVyZSBvZiBjaGlsZHJlbi5cbiAqXG4gKiBAcGFyYW0gez9vYmplY3R9IGNoaWxkcmVuIENoaWxkIGNvbGxlY3Rpb24gc3RydWN0dXJlLlxuICogQHJldHVybiB7UmVhY3RFbGVtZW50fSBUaGUgZmlyc3QgYW5kIG9ubHkgYFJlYWN0RWxlbWVudGAgY29udGFpbmVkIGluIHRoZVxuICogc3RydWN0dXJlLlxuICovXG5mdW5jdGlvbiBvbmx5Q2hpbGQoY2hpbGRyZW4pIHtcbiAgIWlzVmFsaWRFbGVtZW50KGNoaWxkcmVuKSA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0LkNoaWxkcmVuLm9ubHkgZXhwZWN0ZWQgdG8gcmVjZWl2ZSBhIHNpbmdsZSBSZWFjdCBlbGVtZW50IGNoaWxkLicpIDogdm9pZCAwO1xuICByZXR1cm4gY2hpbGRyZW47XG59XG5cbnZhciBkZXNjcmliZUNvbXBvbmVudEZyYW1lID0gZnVuY3Rpb24gKG5hbWUsIHNvdXJjZSwgb3duZXJOYW1lKSB7XG4gIHJldHVybiAnXFxuICAgIGluICcgKyAobmFtZSB8fCAnVW5rbm93bicpICsgKHNvdXJjZSA/ICcgKGF0ICcgKyBzb3VyY2UuZmlsZU5hbWUucmVwbGFjZSgvXi4qW1xcXFxcXC9dLywgJycpICsgJzonICsgc291cmNlLmxpbmVOdW1iZXIgKyAnKScgOiBvd25lck5hbWUgPyAnIChjcmVhdGVkIGJ5ICcgKyBvd25lck5hbWUgKyAnKScgOiAnJyk7XG59O1xuXG5mdW5jdGlvbiBnZXRDb21wb25lbnROYW1lKGZpYmVyKSB7XG4gIHZhciB0eXBlID0gZmliZXIudHlwZTtcblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIFJlYWN0RWxlbWVudFZhbGlkYXRvciBwcm92aWRlcyBhIHdyYXBwZXIgYXJvdW5kIGEgZWxlbWVudCBmYWN0b3J5XG4gKiB3aGljaCB2YWxpZGF0ZXMgdGhlIHByb3BzIHBhc3NlZCB0byB0aGUgZWxlbWVudC4gVGhpcyBpcyBpbnRlbmRlZCB0byBiZVxuICogdXNlZCBvbmx5IGluIERFViBhbmQgY291bGQgYmUgcmVwbGFjZWQgYnkgYSBzdGF0aWMgdHlwZSBjaGVja2VyIGZvciBsYW5ndWFnZXNcbiAqIHRoYXQgc3VwcG9ydCBpdC5cbiAqL1xuXG57XG4gIHZhciBjdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCA9IG51bGw7XG5cbiAgdmFyIHByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duID0gZmFsc2U7XG5cbiAgdmFyIGdldERpc3BsYXlOYW1lID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICBpZiAoZWxlbWVudCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gJyNlbXB0eSc7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZWxlbWVudCA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIGVsZW1lbnQgPT09ICdudW1iZXInKSB7XG4gICAgICByZXR1cm4gJyN0ZXh0JztcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBlbGVtZW50LnR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gZWxlbWVudC50eXBlO1xuICAgIH0gZWxzZSBpZiAoZWxlbWVudC50eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFKSB7XG4gICAgICByZXR1cm4gJ1JlYWN0LkZyYWdtZW50JztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGVsZW1lbnQudHlwZS5kaXNwbGF5TmFtZSB8fCBlbGVtZW50LnR5cGUubmFtZSB8fCAnVW5rbm93bic7XG4gICAgfVxuICB9O1xuXG4gIHZhciBnZXRTdGFja0FkZGVuZHVtID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzdGFjayA9ICcnO1xuICAgIGlmIChjdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCkge1xuICAgICAgdmFyIG5hbWUgPSBnZXREaXNwbGF5TmFtZShjdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCk7XG4gICAgICB2YXIgb3duZXIgPSBjdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudC5fb3duZXI7XG4gICAgICBzdGFjayArPSBkZXNjcmliZUNvbXBvbmVudEZyYW1lKG5hbWUsIGN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50Ll9zb3VyY2UsIG93bmVyICYmIGdldENvbXBvbmVudE5hbWUob3duZXIpKTtcbiAgICB9XG4gICAgc3RhY2sgKz0gUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRTdGFja0FkZGVuZHVtKCkgfHwgJyc7XG4gICAgcmV0dXJuIHN0YWNrO1xuICB9O1xuXG4gIHZhciBWQUxJRF9GUkFHTUVOVF9QUk9QUyA9IG5ldyBNYXAoW1snY2hpbGRyZW4nLCB0cnVlXSwgWydrZXknLCB0cnVlXV0pO1xufVxuXG5mdW5jdGlvbiBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKSB7XG4gIGlmIChSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50KSB7XG4gICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lKFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQpO1xuICAgIGlmIChuYW1lKSB7XG4gICAgICByZXR1cm4gJ1xcblxcbkNoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGAnICsgbmFtZSArICdgLic7XG4gICAgfVxuICB9XG4gIHJldHVybiAnJztcbn1cblxuZnVuY3Rpb24gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0oZWxlbWVudFByb3BzKSB7XG4gIGlmIChlbGVtZW50UHJvcHMgIT09IG51bGwgJiYgZWxlbWVudFByb3BzICE9PSB1bmRlZmluZWQgJiYgZWxlbWVudFByb3BzLl9fc291cmNlICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgc291cmNlID0gZWxlbWVudFByb3BzLl9fc291cmNlO1xuICAgIHZhciBmaWxlTmFtZSA9IHNvdXJjZS5maWxlTmFtZS5yZXBsYWNlKC9eLipbXFxcXFxcL10vLCAnJyk7XG4gICAgdmFyIGxpbmVOdW1iZXIgPSBzb3VyY2UubGluZU51bWJlcjtcbiAgICByZXR1cm4gJ1xcblxcbkNoZWNrIHlvdXIgY29kZSBhdCAnICsgZmlsZU5hbWUgKyAnOicgKyBsaW5lTnVtYmVyICsgJy4nO1xuICB9XG4gIHJldHVybiAnJztcbn1cblxuLyoqXG4gKiBXYXJuIGlmIHRoZXJlJ3Mgbm8ga2V5IGV4cGxpY2l0bHkgc2V0IG9uIGR5bmFtaWMgYXJyYXlzIG9mIGNoaWxkcmVuIG9yXG4gKiBvYmplY3Qga2V5cyBhcmUgbm90IHZhbGlkLiBUaGlzIGFsbG93cyB1cyB0byBrZWVwIHRyYWNrIG9mIGNoaWxkcmVuIGJldHdlZW5cbiAqIHVwZGF0ZXMuXG4gKi9cbnZhciBvd25lckhhc0tleVVzZVdhcm5pbmcgPSB7fTtcblxuZnVuY3Rpb24gZ2V0Q3VycmVudENvbXBvbmVudEVycm9ySW5mbyhwYXJlbnRUeXBlKSB7XG4gIHZhciBpbmZvID0gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCk7XG5cbiAgaWYgKCFpbmZvKSB7XG4gICAgdmFyIHBhcmVudE5hbWUgPSB0eXBlb2YgcGFyZW50VHlwZSA9PT0gJ3N0cmluZycgPyBwYXJlbnRUeXBlIDogcGFyZW50VHlwZS5kaXNwbGF5TmFtZSB8fCBwYXJlbnRUeXBlLm5hbWU7XG4gICAgaWYgKHBhcmVudE5hbWUpIHtcbiAgICAgIGluZm8gPSAnXFxuXFxuQ2hlY2sgdGhlIHRvcC1sZXZlbCByZW5kZXIgY2FsbCB1c2luZyA8JyArIHBhcmVudE5hbWUgKyAnPi4nO1xuICAgIH1cbiAgfVxuICByZXR1cm4gaW5mbztcbn1cblxuLyoqXG4gKiBXYXJuIGlmIHRoZSBlbGVtZW50IGRvZXNuJ3QgaGF2ZSBhbiBleHBsaWNpdCBrZXkgYXNzaWduZWQgdG8gaXQuXG4gKiBUaGlzIGVsZW1lbnQgaXMgaW4gYW4gYXJyYXkuIFRoZSBhcnJheSBjb3VsZCBncm93IGFuZCBzaHJpbmsgb3IgYmVcbiAqIHJlb3JkZXJlZC4gQWxsIGNoaWxkcmVuIHRoYXQgaGF2ZW4ndCBhbHJlYWR5IGJlZW4gdmFsaWRhdGVkIGFyZSByZXF1aXJlZCB0b1xuICogaGF2ZSBhIFwia2V5XCIgcHJvcGVydHkgYXNzaWduZWQgdG8gaXQuIEVycm9yIHN0YXR1c2VzIGFyZSBjYWNoZWQgc28gYSB3YXJuaW5nXG4gKiB3aWxsIG9ubHkgYmUgc2hvd24gb25jZS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdGhhdCByZXF1aXJlcyBhIGtleS5cbiAqIEBwYXJhbSB7Kn0gcGFyZW50VHlwZSBlbGVtZW50J3MgcGFyZW50J3MgdHlwZS5cbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVFeHBsaWNpdEtleShlbGVtZW50LCBwYXJlbnRUeXBlKSB7XG4gIGlmICghZWxlbWVudC5fc3RvcmUgfHwgZWxlbWVudC5fc3RvcmUudmFsaWRhdGVkIHx8IGVsZW1lbnQua2V5ICE9IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgZWxlbWVudC5fc3RvcmUudmFsaWRhdGVkID0gdHJ1ZTtcblxuICB2YXIgY3VycmVudENvbXBvbmVudEVycm9ySW5mbyA9IGdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8ocGFyZW50VHlwZSk7XG4gIGlmIChvd25lckhhc0tleVVzZVdhcm5pbmdbY3VycmVudENvbXBvbmVudEVycm9ySW5mb10pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgb3duZXJIYXNLZXlVc2VXYXJuaW5nW2N1cnJlbnRDb21wb25lbnRFcnJvckluZm9dID0gdHJ1ZTtcblxuICAvLyBVc3VhbGx5IHRoZSBjdXJyZW50IG93bmVyIGlzIHRoZSBvZmZlbmRlciwgYnV0IGlmIGl0IGFjY2VwdHMgY2hpbGRyZW4gYXMgYVxuICAvLyBwcm9wZXJ0eSwgaXQgbWF5IGJlIHRoZSBjcmVhdG9yIG9mIHRoZSBjaGlsZCB0aGF0J3MgcmVzcG9uc2libGUgZm9yXG4gIC8vIGFzc2lnbmluZyBpdCBhIGtleS5cbiAgdmFyIGNoaWxkT3duZXIgPSAnJztcbiAgaWYgKGVsZW1lbnQgJiYgZWxlbWVudC5fb3duZXIgJiYgZWxlbWVudC5fb3duZXIgIT09IFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQpIHtcbiAgICAvLyBHaXZlIHRoZSBjb21wb25lbnQgdGhhdCBvcmlnaW5hbGx5IGNyZWF0ZWQgdGhpcyBjaGlsZC5cbiAgICBjaGlsZE93bmVyID0gJyBJdCB3YXMgcGFzc2VkIGEgY2hpbGQgZnJvbSAnICsgZ2V0Q29tcG9uZW50TmFtZShlbGVtZW50Ll9vd25lcikgKyAnLic7XG4gIH1cblxuICBjdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCA9IGVsZW1lbnQ7XG4gIHtcbiAgICB3YXJuaW5nKGZhbHNlLCAnRWFjaCBjaGlsZCBpbiBhbiBhcnJheSBvciBpdGVyYXRvciBzaG91bGQgaGF2ZSBhIHVuaXF1ZSBcImtleVwiIHByb3AuJyArICclcyVzIFNlZSBodHRwczovL2ZiLm1lL3JlYWN0LXdhcm5pbmcta2V5cyBmb3IgbW9yZSBpbmZvcm1hdGlvbi4lcycsIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8sIGNoaWxkT3duZXIsIGdldFN0YWNrQWRkZW5kdW0oKSk7XG4gIH1cbiAgY3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQgPSBudWxsO1xufVxuXG4vKipcbiAqIEVuc3VyZSB0aGF0IGV2ZXJ5IGVsZW1lbnQgZWl0aGVyIGlzIHBhc3NlZCBpbiBhIHN0YXRpYyBsb2NhdGlvbiwgaW4gYW5cbiAqIGFycmF5IHdpdGggYW4gZXhwbGljaXQga2V5cyBwcm9wZXJ0eSBkZWZpbmVkLCBvciBpbiBhbiBvYmplY3QgbGl0ZXJhbFxuICogd2l0aCB2YWxpZCBrZXkgcHJvcGVydHkuXG4gKlxuICogQGludGVybmFsXG4gKiBAcGFyYW0ge1JlYWN0Tm9kZX0gbm9kZSBTdGF0aWNhbGx5IHBhc3NlZCBjaGlsZCBvZiBhbnkgdHlwZS5cbiAqIEBwYXJhbSB7Kn0gcGFyZW50VHlwZSBub2RlJ3MgcGFyZW50J3MgdHlwZS5cbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVDaGlsZEtleXMobm9kZSwgcGFyZW50VHlwZSkge1xuICBpZiAodHlwZW9mIG5vZGUgIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KG5vZGUpKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY2hpbGQgPSBub2RlW2ldO1xuICAgICAgaWYgKGlzVmFsaWRFbGVtZW50KGNoaWxkKSkge1xuICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KGNoaWxkLCBwYXJlbnRUeXBlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNWYWxpZEVsZW1lbnQobm9kZSkpIHtcbiAgICAvLyBUaGlzIGVsZW1lbnQgd2FzIHBhc3NlZCBpbiBhIHZhbGlkIGxvY2F0aW9uLlxuICAgIGlmIChub2RlLl9zdG9yZSkge1xuICAgICAgbm9kZS5fc3RvcmUudmFsaWRhdGVkID0gdHJ1ZTtcbiAgICB9XG4gIH0gZWxzZSBpZiAobm9kZSkge1xuICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihub2RlKTtcbiAgICBpZiAodHlwZW9mIGl0ZXJhdG9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIEVudHJ5IGl0ZXJhdG9ycyB1c2VkIHRvIHByb3ZpZGUgaW1wbGljaXQga2V5cyxcbiAgICAgIC8vIGJ1dCBub3cgd2UgcHJpbnQgYSBzZXBhcmF0ZSB3YXJuaW5nIGZvciB0aGVtIGxhdGVyLlxuICAgICAgaWYgKGl0ZXJhdG9yRm4gIT09IG5vZGUuZW50cmllcykge1xuICAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwobm9kZSk7XG4gICAgICAgIHZhciBzdGVwO1xuICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgaWYgKGlzVmFsaWRFbGVtZW50KHN0ZXAudmFsdWUpKSB7XG4gICAgICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KHN0ZXAudmFsdWUsIHBhcmVudFR5cGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEdpdmVuIGFuIGVsZW1lbnQsIHZhbGlkYXRlIHRoYXQgaXRzIHByb3BzIGZvbGxvdyB0aGUgcHJvcFR5cGVzIGRlZmluaXRpb24sXG4gKiBwcm92aWRlZCBieSB0aGUgdHlwZS5cbiAqXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZWxlbWVudFxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BUeXBlcyhlbGVtZW50KSB7XG4gIHZhciBjb21wb25lbnRDbGFzcyA9IGVsZW1lbnQudHlwZTtcbiAgaWYgKHR5cGVvZiBjb21wb25lbnRDbGFzcyAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbmFtZSA9IGNvbXBvbmVudENsYXNzLmRpc3BsYXlOYW1lIHx8IGNvbXBvbmVudENsYXNzLm5hbWU7XG4gIHZhciBwcm9wVHlwZXMgPSBjb21wb25lbnRDbGFzcy5wcm9wVHlwZXM7XG4gIGlmIChwcm9wVHlwZXMpIHtcbiAgICBjdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgY2hlY2tQcm9wVHlwZXMocHJvcFR5cGVzLCBlbGVtZW50LnByb3BzLCAncHJvcCcsIG5hbWUsIGdldFN0YWNrQWRkZW5kdW0pO1xuICAgIGN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50ID0gbnVsbDtcbiAgfSBlbHNlIGlmIChjb21wb25lbnRDbGFzcy5Qcm9wVHlwZXMgIT09IHVuZGVmaW5lZCAmJiAhcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24pIHtcbiAgICBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93biA9IHRydWU7XG4gICAgd2FybmluZyhmYWxzZSwgJ0NvbXBvbmVudCAlcyBkZWNsYXJlZCBgUHJvcFR5cGVzYCBpbnN0ZWFkIG9mIGBwcm9wVHlwZXNgLiBEaWQgeW91IG1pc3NwZWxsIHRoZSBwcm9wZXJ0eSBhc3NpZ25tZW50PycsIG5hbWUgfHwgJ1Vua25vd24nKTtcbiAgfVxuICBpZiAodHlwZW9mIGNvbXBvbmVudENsYXNzLmdldERlZmF1bHRQcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHdhcm5pbmcoY29tcG9uZW50Q2xhc3MuZ2V0RGVmYXVsdFByb3BzLmlzUmVhY3RDbGFzc0FwcHJvdmVkLCAnZ2V0RGVmYXVsdFByb3BzIGlzIG9ubHkgdXNlZCBvbiBjbGFzc2ljIFJlYWN0LmNyZWF0ZUNsYXNzICcgKyAnZGVmaW5pdGlvbnMuIFVzZSBhIHN0YXRpYyBwcm9wZXJ0eSBuYW1lZCBgZGVmYXVsdFByb3BzYCBpbnN0ZWFkLicpO1xuICB9XG59XG5cbi8qKlxuICogR2l2ZW4gYSBmcmFnbWVudCwgdmFsaWRhdGUgdGhhdCBpdCBjYW4gb25seSBiZSBwcm92aWRlZCB3aXRoIGZyYWdtZW50IHByb3BzXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZnJhZ21lbnRcbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVGcmFnbWVudFByb3BzKGZyYWdtZW50KSB7XG4gIGN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50ID0gZnJhZ21lbnQ7XG5cbiAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlO1xuICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3IgPSBmYWxzZTtcbiAgdmFyIF9pdGVyYXRvckVycm9yID0gdW5kZWZpbmVkO1xuXG4gIHRyeSB7XG4gICAgZm9yICh2YXIgX2l0ZXJhdG9yID0gT2JqZWN0LmtleXMoZnJhZ21lbnQucHJvcHMpW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXA7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IChfc3RlcCA9IF9pdGVyYXRvci5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZSkge1xuICAgICAgdmFyIGtleSA9IF9zdGVwLnZhbHVlO1xuXG4gICAgICBpZiAoIVZBTElEX0ZSQUdNRU5UX1BST1BTLmhhcyhrZXkpKSB7XG4gICAgICAgIHdhcm5pbmcoZmFsc2UsICdJbnZhbGlkIHByb3AgYCVzYCBzdXBwbGllZCB0byBgUmVhY3QuRnJhZ21lbnRgLiAnICsgJ1JlYWN0LkZyYWdtZW50IGNhbiBvbmx5IGhhdmUgYGtleWAgYW5kIGBjaGlsZHJlbmAgcHJvcHMuJXMnLCBrZXksIGdldFN0YWNrQWRkZW5kdW0oKSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgX2RpZEl0ZXJhdG9yRXJyb3IgPSB0cnVlO1xuICAgIF9pdGVyYXRvckVycm9yID0gZXJyO1xuICB9IGZpbmFsbHkge1xuICAgIHRyeSB7XG4gICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gJiYgX2l0ZXJhdG9yWydyZXR1cm4nXSkge1xuICAgICAgICBfaXRlcmF0b3JbJ3JldHVybiddKCk7XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcikge1xuICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoZnJhZ21lbnQucmVmICE9PSBudWxsKSB7XG4gICAgd2FybmluZyhmYWxzZSwgJ0ludmFsaWQgYXR0cmlidXRlIGByZWZgIHN1cHBsaWVkIHRvIGBSZWFjdC5GcmFnbWVudGAuJXMnLCBnZXRTdGFja0FkZGVuZHVtKCkpO1xuICB9XG5cbiAgY3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQgPSBudWxsO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50V2l0aFZhbGlkYXRpb24odHlwZSwgcHJvcHMsIGNoaWxkcmVuKSB7XG4gIHZhciB2YWxpZFR5cGUgPSB0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIHR5cGUgPT09ICdzeW1ib2wnIHx8IHR5cGVvZiB0eXBlID09PSAnbnVtYmVyJztcbiAgLy8gV2Ugd2FybiBpbiB0aGlzIGNhc2UgYnV0IGRvbid0IHRocm93LiBXZSBleHBlY3QgdGhlIGVsZW1lbnQgY3JlYXRpb24gdG9cbiAgLy8gc3VjY2VlZCBhbmQgdGhlcmUgd2lsbCBsaWtlbHkgYmUgZXJyb3JzIGluIHJlbmRlci5cbiAgaWYgKCF2YWxpZFR5cGUpIHtcbiAgICB2YXIgaW5mbyA9ICcnO1xuICAgIGlmICh0eXBlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwgJiYgT2JqZWN0LmtleXModHlwZSkubGVuZ3RoID09PSAwKSB7XG4gICAgICBpbmZvICs9ICcgWW91IGxpa2VseSBmb3Jnb3QgdG8gZXhwb3J0IHlvdXIgY29tcG9uZW50IGZyb20gdGhlIGZpbGUgJyArIFwiaXQncyBkZWZpbmVkIGluLCBvciB5b3UgbWlnaHQgaGF2ZSBtaXhlZCB1cCBkZWZhdWx0IGFuZCBuYW1lZCBpbXBvcnRzLlwiO1xuICAgIH1cblxuICAgIHZhciBzb3VyY2VJbmZvID0gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0ocHJvcHMpO1xuICAgIGlmIChzb3VyY2VJbmZvKSB7XG4gICAgICBpbmZvICs9IHNvdXJjZUluZm87XG4gICAgfSBlbHNlIHtcbiAgICAgIGluZm8gKz0gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCk7XG4gICAgfVxuXG4gICAgaW5mbyArPSBnZXRTdGFja0FkZGVuZHVtKCkgfHwgJyc7XG5cbiAgICB3YXJuaW5nKGZhbHNlLCAnUmVhY3QuY3JlYXRlRWxlbWVudDogdHlwZSBpcyBpbnZhbGlkIC0tIGV4cGVjdGVkIGEgc3RyaW5nIChmb3IgJyArICdidWlsdC1pbiBjb21wb25lbnRzKSBvciBhIGNsYXNzL2Z1bmN0aW9uIChmb3IgY29tcG9zaXRlICcgKyAnY29tcG9uZW50cykgYnV0IGdvdDogJXMuJXMnLCB0eXBlID09IG51bGwgPyB0eXBlIDogdHlwZW9mIHR5cGUsIGluZm8pO1xuICB9XG5cbiAgdmFyIGVsZW1lbnQgPSBjcmVhdGVFbGVtZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgLy8gVGhlIHJlc3VsdCBjYW4gYmUgbnVsbGlzaCBpZiBhIG1vY2sgb3IgYSBjdXN0b20gZnVuY3Rpb24gaXMgdXNlZC5cbiAgLy8gVE9ETzogRHJvcCB0aGlzIHdoZW4gdGhlc2UgYXJlIG5vIGxvbmdlciBhbGxvd2VkIGFzIHRoZSB0eXBlIGFyZ3VtZW50LlxuICBpZiAoZWxlbWVudCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cblxuICAvLyBTa2lwIGtleSB3YXJuaW5nIGlmIHRoZSB0eXBlIGlzbid0IHZhbGlkIHNpbmNlIG91ciBrZXkgdmFsaWRhdGlvbiBsb2dpY1xuICAvLyBkb2Vzbid0IGV4cGVjdCBhIG5vbi1zdHJpbmcvZnVuY3Rpb24gdHlwZSBhbmQgY2FuIHRocm93IGNvbmZ1c2luZyBlcnJvcnMuXG4gIC8vIFdlIGRvbid0IHdhbnQgZXhjZXB0aW9uIGJlaGF2aW9yIHRvIGRpZmZlciBiZXR3ZWVuIGRldiBhbmQgcHJvZC5cbiAgLy8gKFJlbmRlcmluZyB3aWxsIHRocm93IHdpdGggYSBoZWxwZnVsIG1lc3NhZ2UgYW5kIGFzIHNvb24gYXMgdGhlIHR5cGUgaXNcbiAgLy8gZml4ZWQsIHRoZSBrZXkgd2FybmluZ3Mgd2lsbCBhcHBlYXIuKVxuICBpZiAodmFsaWRUeXBlKSB7XG4gICAgZm9yICh2YXIgaSA9IDI7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGFyZ3VtZW50c1tpXSwgdHlwZSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3ltYm9sJyAmJiB0eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFKSB7XG4gICAgdmFsaWRhdGVGcmFnbWVudFByb3BzKGVsZW1lbnQpO1xuICB9IGVsc2Uge1xuICAgIHZhbGlkYXRlUHJvcFR5cGVzKGVsZW1lbnQpO1xuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnQ7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUZhY3RvcnlXaXRoVmFsaWRhdGlvbih0eXBlKSB7XG4gIHZhciB2YWxpZGF0ZWRGYWN0b3J5ID0gY3JlYXRlRWxlbWVudFdpdGhWYWxpZGF0aW9uLmJpbmQobnVsbCwgdHlwZSk7XG4gIC8vIExlZ2FjeSBob29rIFRPRE86IFdhcm4gaWYgdGhpcyBpcyBhY2Nlc3NlZFxuICB2YWxpZGF0ZWRGYWN0b3J5LnR5cGUgPSB0eXBlO1xuXG4gIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodmFsaWRhdGVkRmFjdG9yeSwgJ3R5cGUnLCB7XG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICBsb3dQcmlvcml0eVdhcm5pbmckMShmYWxzZSwgJ0ZhY3RvcnkudHlwZSBpcyBkZXByZWNhdGVkLiBBY2Nlc3MgdGhlIGNsYXNzIGRpcmVjdGx5ICcgKyAnYmVmb3JlIHBhc3NpbmcgaXQgdG8gY3JlYXRlRmFjdG9yeS4nKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICd0eXBlJywge1xuICAgICAgICAgIHZhbHVlOiB0eXBlXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdHlwZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiB2YWxpZGF0ZWRGYWN0b3J5O1xufVxuXG5mdW5jdGlvbiBjbG9uZUVsZW1lbnRXaXRoVmFsaWRhdGlvbihlbGVtZW50LCBwcm9wcywgY2hpbGRyZW4pIHtcbiAgdmFyIG5ld0VsZW1lbnQgPSBjbG9uZUVsZW1lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgZm9yICh2YXIgaSA9IDI7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YWxpZGF0ZUNoaWxkS2V5cyhhcmd1bWVudHNbaV0sIG5ld0VsZW1lbnQudHlwZSk7XG4gIH1cbiAgdmFsaWRhdGVQcm9wVHlwZXMobmV3RWxlbWVudCk7XG4gIHJldHVybiBuZXdFbGVtZW50O1xufVxuXG52YXIgUmVhY3QgPSB7XG4gIENoaWxkcmVuOiB7XG4gICAgbWFwOiBtYXBDaGlsZHJlbixcbiAgICBmb3JFYWNoOiBmb3JFYWNoQ2hpbGRyZW4sXG4gICAgY291bnQ6IGNvdW50Q2hpbGRyZW4sXG4gICAgdG9BcnJheTogdG9BcnJheSxcbiAgICBvbmx5OiBvbmx5Q2hpbGRcbiAgfSxcblxuICBDb21wb25lbnQ6IENvbXBvbmVudCxcbiAgUHVyZUNvbXBvbmVudDogUHVyZUNvbXBvbmVudCxcbiAgdW5zdGFibGVfQXN5bmNDb21wb25lbnQ6IEFzeW5jQ29tcG9uZW50LFxuXG4gIEZyYWdtZW50OiBSRUFDVF9GUkFHTUVOVF9UWVBFLFxuXG4gIGNyZWF0ZUVsZW1lbnQ6IGNyZWF0ZUVsZW1lbnRXaXRoVmFsaWRhdGlvbixcbiAgY2xvbmVFbGVtZW50OiBjbG9uZUVsZW1lbnRXaXRoVmFsaWRhdGlvbixcbiAgY3JlYXRlRmFjdG9yeTogY3JlYXRlRmFjdG9yeVdpdGhWYWxpZGF0aW9uLFxuICBpc1ZhbGlkRWxlbWVudDogaXNWYWxpZEVsZW1lbnQsXG5cbiAgdmVyc2lvbjogUmVhY3RWZXJzaW9uLFxuXG4gIF9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEOiB7XG4gICAgUmVhY3RDdXJyZW50T3duZXI6IFJlYWN0Q3VycmVudE93bmVyLFxuICAgIC8vIFVzZWQgYnkgcmVuZGVyZXJzIHRvIGF2b2lkIGJ1bmRsaW5nIG9iamVjdC1hc3NpZ24gdHdpY2UgaW4gVU1EIGJ1bmRsZXM6XG4gICAgYXNzaWduOiBfYXNzaWduXG4gIH1cbn07XG5cbntcbiAgX2Fzc2lnbihSZWFjdC5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRCwge1xuICAgIC8vIFRoZXNlIHNob3VsZCBub3QgYmUgaW5jbHVkZWQgaW4gcHJvZHVjdGlvbi5cbiAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lOiBSZWFjdERlYnVnQ3VycmVudEZyYW1lLFxuICAgIC8vIFNoaW0gZm9yIFJlYWN0IERPTSAxNi4wLjAgd2hpY2ggc3RpbGwgZGVzdHJ1Y3R1cmVkIChidXQgbm90IHVzZWQpIHRoaXMuXG4gICAgLy8gVE9ETzogcmVtb3ZlIGluIFJlYWN0IDE3LjAuXG4gICAgUmVhY3RDb21wb25lbnRUcmVlSG9vazoge31cbiAgfSk7XG59XG5cblxuXG52YXIgUmVhY3QkMiA9IE9iamVjdC5mcmVlemUoe1xuXHRkZWZhdWx0OiBSZWFjdFxufSk7XG5cbnZhciBSZWFjdCQzID0gKCBSZWFjdCQyICYmIFJlYWN0ICkgfHwgUmVhY3QkMjtcblxuLy8gVE9ETzogZGVjaWRlIG9uIHRoZSB0b3AtbGV2ZWwgZXhwb3J0IGZvcm0uXG4vLyBUaGlzIGlzIGhhY2t5IGJ1dCBtYWtlcyBpdCB3b3JrIHdpdGggYm90aCBSb2xsdXAgYW5kIEplc3QuXG52YXIgcmVhY3QgPSBSZWFjdCQzWydkZWZhdWx0J10gPyBSZWFjdCQzWydkZWZhdWx0J10gOiBSZWFjdCQzO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlYWN0O1xuICB9KSgpO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0L2Nqcy9yZWFjdC5kZXZlbG9wbWVudC5qcyIsIi8qKiBAbGljZW5zZSBSZWFjdCB2MTYuMi4wXG4gKiByZWFjdC5wcm9kdWN0aW9uLm1pbi5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0Jzt2YXIgbT1yZXF1aXJlKFwib2JqZWN0LWFzc2lnblwiKSxuPXJlcXVpcmUoXCJmYmpzL2xpYi9lbXB0eU9iamVjdFwiKSxwPXJlcXVpcmUoXCJmYmpzL2xpYi9lbXB0eUZ1bmN0aW9uXCIpLHE9XCJmdW5jdGlvblwiPT09dHlwZW9mIFN5bWJvbCYmU3ltYm9sW1wiZm9yXCJdLHI9cT9TeW1ib2xbXCJmb3JcIl0oXCJyZWFjdC5lbGVtZW50XCIpOjYwMTAzLHQ9cT9TeW1ib2xbXCJmb3JcIl0oXCJyZWFjdC5jYWxsXCIpOjYwMTA0LHU9cT9TeW1ib2xbXCJmb3JcIl0oXCJyZWFjdC5yZXR1cm5cIik6NjAxMDUsdj1xP1N5bWJvbFtcImZvclwiXShcInJlYWN0LnBvcnRhbFwiKTo2MDEwNix3PXE/U3ltYm9sW1wiZm9yXCJdKFwicmVhY3QuZnJhZ21lbnRcIik6NjAxMDcseD1cImZ1bmN0aW9uXCI9PT10eXBlb2YgU3ltYm9sJiZTeW1ib2wuaXRlcmF0b3I7XG5mdW5jdGlvbiB5KGEpe2Zvcih2YXIgYj1hcmd1bWVudHMubGVuZ3RoLTEsZT1cIk1pbmlmaWVkIFJlYWN0IGVycm9yICNcIithK1wiOyB2aXNpdCBodHRwOi8vZmFjZWJvb2suZ2l0aHViLmlvL3JlYWN0L2RvY3MvZXJyb3ItZGVjb2Rlci5odG1sP2ludmFyaWFudFxceDNkXCIrYSxjPTA7YzxiO2MrKyllKz1cIlxceDI2YXJnc1tdXFx4M2RcIitlbmNvZGVVUklDb21wb25lbnQoYXJndW1lbnRzW2MrMV0pO2I9RXJyb3IoZStcIiBmb3IgdGhlIGZ1bGwgbWVzc2FnZSBvciB1c2UgdGhlIG5vbi1taW5pZmllZCBkZXYgZW52aXJvbm1lbnQgZm9yIGZ1bGwgZXJyb3JzIGFuZCBhZGRpdGlvbmFsIGhlbHBmdWwgd2FybmluZ3MuXCIpO2IubmFtZT1cIkludmFyaWFudCBWaW9sYXRpb25cIjtiLmZyYW1lc1RvUG9wPTE7dGhyb3cgYjt9XG52YXIgej17aXNNb3VudGVkOmZ1bmN0aW9uKCl7cmV0dXJuITF9LGVucXVldWVGb3JjZVVwZGF0ZTpmdW5jdGlvbigpe30sZW5xdWV1ZVJlcGxhY2VTdGF0ZTpmdW5jdGlvbigpe30sZW5xdWV1ZVNldFN0YXRlOmZ1bmN0aW9uKCl7fX07ZnVuY3Rpb24gQShhLGIsZSl7dGhpcy5wcm9wcz1hO3RoaXMuY29udGV4dD1iO3RoaXMucmVmcz1uO3RoaXMudXBkYXRlcj1lfHx6fUEucHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQ9e307QS5wcm90b3R5cGUuc2V0U3RhdGU9ZnVuY3Rpb24oYSxiKXtcIm9iamVjdFwiIT09dHlwZW9mIGEmJlwiZnVuY3Rpb25cIiE9PXR5cGVvZiBhJiZudWxsIT1hP3koXCI4NVwiKTp2b2lkIDA7dGhpcy51cGRhdGVyLmVucXVldWVTZXRTdGF0ZSh0aGlzLGEsYixcInNldFN0YXRlXCIpfTtBLnByb3RvdHlwZS5mb3JjZVVwZGF0ZT1mdW5jdGlvbihhKXt0aGlzLnVwZGF0ZXIuZW5xdWV1ZUZvcmNlVXBkYXRlKHRoaXMsYSxcImZvcmNlVXBkYXRlXCIpfTtcbmZ1bmN0aW9uIEIoYSxiLGUpe3RoaXMucHJvcHM9YTt0aGlzLmNvbnRleHQ9Yjt0aGlzLnJlZnM9bjt0aGlzLnVwZGF0ZXI9ZXx8en1mdW5jdGlvbiBDKCl7fUMucHJvdG90eXBlPUEucHJvdG90eXBlO3ZhciBEPUIucHJvdG90eXBlPW5ldyBDO0QuY29uc3RydWN0b3I9QjttKEQsQS5wcm90b3R5cGUpO0QuaXNQdXJlUmVhY3RDb21wb25lbnQ9ITA7ZnVuY3Rpb24gRShhLGIsZSl7dGhpcy5wcm9wcz1hO3RoaXMuY29udGV4dD1iO3RoaXMucmVmcz1uO3RoaXMudXBkYXRlcj1lfHx6fXZhciBGPUUucHJvdG90eXBlPW5ldyBDO0YuY29uc3RydWN0b3I9RTttKEYsQS5wcm90b3R5cGUpO0YudW5zdGFibGVfaXNBc3luY1JlYWN0Q29tcG9uZW50PSEwO0YucmVuZGVyPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucHJvcHMuY2hpbGRyZW59O3ZhciBHPXtjdXJyZW50Om51bGx9LEg9T2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSxJPXtrZXk6ITAscmVmOiEwLF9fc2VsZjohMCxfX3NvdXJjZTohMH07XG5mdW5jdGlvbiBKKGEsYixlKXt2YXIgYyxkPXt9LGc9bnVsbCxrPW51bGw7aWYobnVsbCE9Yilmb3IoYyBpbiB2b2lkIDAhPT1iLnJlZiYmKGs9Yi5yZWYpLHZvaWQgMCE9PWIua2V5JiYoZz1cIlwiK2Iua2V5KSxiKUguY2FsbChiLGMpJiYhSS5oYXNPd25Qcm9wZXJ0eShjKSYmKGRbY109YltjXSk7dmFyIGY9YXJndW1lbnRzLmxlbmd0aC0yO2lmKDE9PT1mKWQuY2hpbGRyZW49ZTtlbHNlIGlmKDE8Zil7Zm9yKHZhciBoPUFycmF5KGYpLGw9MDtsPGY7bCsrKWhbbF09YXJndW1lbnRzW2wrMl07ZC5jaGlsZHJlbj1ofWlmKGEmJmEuZGVmYXVsdFByb3BzKWZvcihjIGluIGY9YS5kZWZhdWx0UHJvcHMsZil2b2lkIDA9PT1kW2NdJiYoZFtjXT1mW2NdKTtyZXR1cm57JCR0eXBlb2Y6cix0eXBlOmEsa2V5OmcscmVmOmsscHJvcHM6ZCxfb3duZXI6Ry5jdXJyZW50fX1mdW5jdGlvbiBLKGEpe3JldHVyblwib2JqZWN0XCI9PT10eXBlb2YgYSYmbnVsbCE9PWEmJmEuJCR0eXBlb2Y9PT1yfVxuZnVuY3Rpb24gZXNjYXBlKGEpe3ZhciBiPXtcIlxceDNkXCI6XCJcXHgzZDBcIixcIjpcIjpcIlxceDNkMlwifTtyZXR1cm5cIiRcIisoXCJcIithKS5yZXBsYWNlKC9bPTpdL2csZnVuY3Rpb24oYSl7cmV0dXJuIGJbYV19KX12YXIgTD0vXFwvKy9nLE09W107ZnVuY3Rpb24gTihhLGIsZSxjKXtpZihNLmxlbmd0aCl7dmFyIGQ9TS5wb3AoKTtkLnJlc3VsdD1hO2Qua2V5UHJlZml4PWI7ZC5mdW5jPWU7ZC5jb250ZXh0PWM7ZC5jb3VudD0wO3JldHVybiBkfXJldHVybntyZXN1bHQ6YSxrZXlQcmVmaXg6YixmdW5jOmUsY29udGV4dDpjLGNvdW50OjB9fWZ1bmN0aW9uIE8oYSl7YS5yZXN1bHQ9bnVsbDthLmtleVByZWZpeD1udWxsO2EuZnVuYz1udWxsO2EuY29udGV4dD1udWxsO2EuY291bnQ9MDsxMD5NLmxlbmd0aCYmTS5wdXNoKGEpfVxuZnVuY3Rpb24gUChhLGIsZSxjKXt2YXIgZD10eXBlb2YgYTtpZihcInVuZGVmaW5lZFwiPT09ZHx8XCJib29sZWFuXCI9PT1kKWE9bnVsbDt2YXIgZz0hMTtpZihudWxsPT09YSlnPSEwO2Vsc2Ugc3dpdGNoKGQpe2Nhc2UgXCJzdHJpbmdcIjpjYXNlIFwibnVtYmVyXCI6Zz0hMDticmVhaztjYXNlIFwib2JqZWN0XCI6c3dpdGNoKGEuJCR0eXBlb2Ype2Nhc2UgcjpjYXNlIHQ6Y2FzZSB1OmNhc2UgdjpnPSEwfX1pZihnKXJldHVybiBlKGMsYSxcIlwiPT09Yj9cIi5cIitRKGEsMCk6YiksMTtnPTA7Yj1cIlwiPT09Yj9cIi5cIjpiK1wiOlwiO2lmKEFycmF5LmlzQXJyYXkoYSkpZm9yKHZhciBrPTA7azxhLmxlbmd0aDtrKyspe2Q9YVtrXTt2YXIgZj1iK1EoZCxrKTtnKz1QKGQsZixlLGMpfWVsc2UgaWYobnVsbD09PWF8fFwidW5kZWZpbmVkXCI9PT10eXBlb2YgYT9mPW51bGw6KGY9eCYmYVt4XXx8YVtcIkBAaXRlcmF0b3JcIl0sZj1cImZ1bmN0aW9uXCI9PT10eXBlb2YgZj9mOm51bGwpLFwiZnVuY3Rpb25cIj09PXR5cGVvZiBmKWZvcihhPVxuZi5jYWxsKGEpLGs9MDshKGQ9YS5uZXh0KCkpLmRvbmU7KWQ9ZC52YWx1ZSxmPWIrUShkLGsrKyksZys9UChkLGYsZSxjKTtlbHNlXCJvYmplY3RcIj09PWQmJihlPVwiXCIrYSx5KFwiMzFcIixcIltvYmplY3QgT2JqZWN0XVwiPT09ZT9cIm9iamVjdCB3aXRoIGtleXMge1wiK09iamVjdC5rZXlzKGEpLmpvaW4oXCIsIFwiKStcIn1cIjplLFwiXCIpKTtyZXR1cm4gZ31mdW5jdGlvbiBRKGEsYil7cmV0dXJuXCJvYmplY3RcIj09PXR5cGVvZiBhJiZudWxsIT09YSYmbnVsbCE9YS5rZXk/ZXNjYXBlKGEua2V5KTpiLnRvU3RyaW5nKDM2KX1mdW5jdGlvbiBSKGEsYil7YS5mdW5jLmNhbGwoYS5jb250ZXh0LGIsYS5jb3VudCsrKX1cbmZ1bmN0aW9uIFMoYSxiLGUpe3ZhciBjPWEucmVzdWx0LGQ9YS5rZXlQcmVmaXg7YT1hLmZ1bmMuY2FsbChhLmNvbnRleHQsYixhLmNvdW50KyspO0FycmF5LmlzQXJyYXkoYSk/VChhLGMsZSxwLnRoYXRSZXR1cm5zQXJndW1lbnQpOm51bGwhPWEmJihLKGEpJiYoYj1kKyghYS5rZXl8fGImJmIua2V5PT09YS5rZXk/XCJcIjooXCJcIithLmtleSkucmVwbGFjZShMLFwiJFxceDI2L1wiKStcIi9cIikrZSxhPXskJHR5cGVvZjpyLHR5cGU6YS50eXBlLGtleTpiLHJlZjphLnJlZixwcm9wczphLnByb3BzLF9vd25lcjphLl9vd25lcn0pLGMucHVzaChhKSl9ZnVuY3Rpb24gVChhLGIsZSxjLGQpe3ZhciBnPVwiXCI7bnVsbCE9ZSYmKGc9KFwiXCIrZSkucmVwbGFjZShMLFwiJFxceDI2L1wiKStcIi9cIik7Yj1OKGIsZyxjLGQpO251bGw9PWF8fFAoYSxcIlwiLFMsYik7TyhiKX1cbnZhciBVPXtDaGlsZHJlbjp7bWFwOmZ1bmN0aW9uKGEsYixlKXtpZihudWxsPT1hKXJldHVybiBhO3ZhciBjPVtdO1QoYSxjLG51bGwsYixlKTtyZXR1cm4gY30sZm9yRWFjaDpmdW5jdGlvbihhLGIsZSl7aWYobnVsbD09YSlyZXR1cm4gYTtiPU4obnVsbCxudWxsLGIsZSk7bnVsbD09YXx8UChhLFwiXCIsUixiKTtPKGIpfSxjb3VudDpmdW5jdGlvbihhKXtyZXR1cm4gbnVsbD09YT8wOlAoYSxcIlwiLHAudGhhdFJldHVybnNOdWxsLG51bGwpfSx0b0FycmF5OmZ1bmN0aW9uKGEpe3ZhciBiPVtdO1QoYSxiLG51bGwscC50aGF0UmV0dXJuc0FyZ3VtZW50KTtyZXR1cm4gYn0sb25seTpmdW5jdGlvbihhKXtLKGEpP3ZvaWQgMDp5KFwiMTQzXCIpO3JldHVybiBhfX0sQ29tcG9uZW50OkEsUHVyZUNvbXBvbmVudDpCLHVuc3RhYmxlX0FzeW5jQ29tcG9uZW50OkUsRnJhZ21lbnQ6dyxjcmVhdGVFbGVtZW50OkosY2xvbmVFbGVtZW50OmZ1bmN0aW9uKGEsYixlKXt2YXIgYz1tKHt9LGEucHJvcHMpLFxuZD1hLmtleSxnPWEucmVmLGs9YS5fb3duZXI7aWYobnVsbCE9Yil7dm9pZCAwIT09Yi5yZWYmJihnPWIucmVmLGs9Ry5jdXJyZW50KTt2b2lkIDAhPT1iLmtleSYmKGQ9XCJcIitiLmtleSk7aWYoYS50eXBlJiZhLnR5cGUuZGVmYXVsdFByb3BzKXZhciBmPWEudHlwZS5kZWZhdWx0UHJvcHM7Zm9yKGggaW4gYilILmNhbGwoYixoKSYmIUkuaGFzT3duUHJvcGVydHkoaCkmJihjW2hdPXZvaWQgMD09PWJbaF0mJnZvaWQgMCE9PWY/ZltoXTpiW2hdKX12YXIgaD1hcmd1bWVudHMubGVuZ3RoLTI7aWYoMT09PWgpYy5jaGlsZHJlbj1lO2Vsc2UgaWYoMTxoKXtmPUFycmF5KGgpO2Zvcih2YXIgbD0wO2w8aDtsKyspZltsXT1hcmd1bWVudHNbbCsyXTtjLmNoaWxkcmVuPWZ9cmV0dXJueyQkdHlwZW9mOnIsdHlwZTphLnR5cGUsa2V5OmQscmVmOmcscHJvcHM6Yyxfb3duZXI6a319LGNyZWF0ZUZhY3Rvcnk6ZnVuY3Rpb24oYSl7dmFyIGI9Si5iaW5kKG51bGwsYSk7Yi50eXBlPWE7cmV0dXJuIGJ9LFxuaXNWYWxpZEVsZW1lbnQ6Syx2ZXJzaW9uOlwiMTYuMi4wXCIsX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQ6e1JlYWN0Q3VycmVudE93bmVyOkcsYXNzaWduOm19fSxWPU9iamVjdC5mcmVlemUoe2RlZmF1bHQ6VX0pLFc9ViYmVXx8Vjttb2R1bGUuZXhwb3J0cz1XW1wiZGVmYXVsdFwiXT9XW1wiZGVmYXVsdFwiXTpXO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0L2Nqcy9yZWFjdC5wcm9kdWN0aW9uLm1pbi5qcyIsIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC5wcm9kdWN0aW9uLm1pbi5qcycpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC5kZXZlbG9wbWVudC5qcycpO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0L2luZGV4LmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4hKGZ1bmN0aW9uKGdsb2JhbCkge1xuICBcInVzZSBzdHJpY3RcIjtcblxuICB2YXIgT3AgPSBPYmplY3QucHJvdG90eXBlO1xuICB2YXIgaGFzT3duID0gT3AuaGFzT3duUHJvcGVydHk7XG4gIHZhciB1bmRlZmluZWQ7IC8vIE1vcmUgY29tcHJlc3NpYmxlIHRoYW4gdm9pZCAwLlxuICB2YXIgJFN5bWJvbCA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiA/IFN5bWJvbCA6IHt9O1xuICB2YXIgaXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLml0ZXJhdG9yIHx8IFwiQEBpdGVyYXRvclwiO1xuICB2YXIgYXN5bmNJdGVyYXRvclN5bWJvbCA9ICRTeW1ib2wuYXN5bmNJdGVyYXRvciB8fCBcIkBAYXN5bmNJdGVyYXRvclwiO1xuICB2YXIgdG9TdHJpbmdUYWdTeW1ib2wgPSAkU3ltYm9sLnRvU3RyaW5nVGFnIHx8IFwiQEB0b1N0cmluZ1RhZ1wiO1xuXG4gIHZhciBpbk1vZHVsZSA9IHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCI7XG4gIHZhciBydW50aW1lID0gZ2xvYmFsLnJlZ2VuZXJhdG9yUnVudGltZTtcbiAgaWYgKHJ1bnRpbWUpIHtcbiAgICBpZiAoaW5Nb2R1bGUpIHtcbiAgICAgIC8vIElmIHJlZ2VuZXJhdG9yUnVudGltZSBpcyBkZWZpbmVkIGdsb2JhbGx5IGFuZCB3ZSdyZSBpbiBhIG1vZHVsZSxcbiAgICAgIC8vIG1ha2UgdGhlIGV4cG9ydHMgb2JqZWN0IGlkZW50aWNhbCB0byByZWdlbmVyYXRvclJ1bnRpbWUuXG4gICAgICBtb2R1bGUuZXhwb3J0cyA9IHJ1bnRpbWU7XG4gICAgfVxuICAgIC8vIERvbid0IGJvdGhlciBldmFsdWF0aW5nIHRoZSByZXN0IG9mIHRoaXMgZmlsZSBpZiB0aGUgcnVudGltZSB3YXNcbiAgICAvLyBhbHJlYWR5IGRlZmluZWQgZ2xvYmFsbHkuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gRGVmaW5lIHRoZSBydW50aW1lIGdsb2JhbGx5IChhcyBleHBlY3RlZCBieSBnZW5lcmF0ZWQgY29kZSkgYXMgZWl0aGVyXG4gIC8vIG1vZHVsZS5leHBvcnRzIChpZiB3ZSdyZSBpbiBhIG1vZHVsZSkgb3IgYSBuZXcsIGVtcHR5IG9iamVjdC5cbiAgcnVudGltZSA9IGdsb2JhbC5yZWdlbmVyYXRvclJ1bnRpbWUgPSBpbk1vZHVsZSA/IG1vZHVsZS5leHBvcnRzIDoge307XG5cbiAgZnVuY3Rpb24gd3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCkge1xuICAgIC8vIElmIG91dGVyRm4gcHJvdmlkZWQgYW5kIG91dGVyRm4ucHJvdG90eXBlIGlzIGEgR2VuZXJhdG9yLCB0aGVuIG91dGVyRm4ucHJvdG90eXBlIGluc3RhbmNlb2YgR2VuZXJhdG9yLlxuICAgIHZhciBwcm90b0dlbmVyYXRvciA9IG91dGVyRm4gJiYgb3V0ZXJGbi5wcm90b3R5cGUgaW5zdGFuY2VvZiBHZW5lcmF0b3IgPyBvdXRlckZuIDogR2VuZXJhdG9yO1xuICAgIHZhciBnZW5lcmF0b3IgPSBPYmplY3QuY3JlYXRlKHByb3RvR2VuZXJhdG9yLnByb3RvdHlwZSk7XG4gICAgdmFyIGNvbnRleHQgPSBuZXcgQ29udGV4dCh0cnlMb2NzTGlzdCB8fCBbXSk7XG5cbiAgICAvLyBUaGUgLl9pbnZva2UgbWV0aG9kIHVuaWZpZXMgdGhlIGltcGxlbWVudGF0aW9ucyBvZiB0aGUgLm5leHQsXG4gICAgLy8gLnRocm93LCBhbmQgLnJldHVybiBtZXRob2RzLlxuICAgIGdlbmVyYXRvci5faW52b2tlID0gbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTtcblxuICAgIHJldHVybiBnZW5lcmF0b3I7XG4gIH1cbiAgcnVudGltZS53cmFwID0gd3JhcDtcblxuICAvLyBUcnkvY2F0Y2ggaGVscGVyIHRvIG1pbmltaXplIGRlb3B0aW1pemF0aW9ucy4gUmV0dXJucyBhIGNvbXBsZXRpb25cbiAgLy8gcmVjb3JkIGxpa2UgY29udGV4dC50cnlFbnRyaWVzW2ldLmNvbXBsZXRpb24uIFRoaXMgaW50ZXJmYWNlIGNvdWxkXG4gIC8vIGhhdmUgYmVlbiAoYW5kIHdhcyBwcmV2aW91c2x5KSBkZXNpZ25lZCB0byB0YWtlIGEgY2xvc3VyZSB0byBiZVxuICAvLyBpbnZva2VkIHdpdGhvdXQgYXJndW1lbnRzLCBidXQgaW4gYWxsIHRoZSBjYXNlcyB3ZSBjYXJlIGFib3V0IHdlXG4gIC8vIGFscmVhZHkgaGF2ZSBhbiBleGlzdGluZyBtZXRob2Qgd2Ugd2FudCB0byBjYWxsLCBzbyB0aGVyZSdzIG5vIG5lZWRcbiAgLy8gdG8gY3JlYXRlIGEgbmV3IGZ1bmN0aW9uIG9iamVjdC4gV2UgY2FuIGV2ZW4gZ2V0IGF3YXkgd2l0aCBhc3N1bWluZ1xuICAvLyB0aGUgbWV0aG9kIHRha2VzIGV4YWN0bHkgb25lIGFyZ3VtZW50LCBzaW5jZSB0aGF0IGhhcHBlbnMgdG8gYmUgdHJ1ZVxuICAvLyBpbiBldmVyeSBjYXNlLCBzbyB3ZSBkb24ndCBoYXZlIHRvIHRvdWNoIHRoZSBhcmd1bWVudHMgb2JqZWN0LiBUaGVcbiAgLy8gb25seSBhZGRpdGlvbmFsIGFsbG9jYXRpb24gcmVxdWlyZWQgaXMgdGhlIGNvbXBsZXRpb24gcmVjb3JkLCB3aGljaFxuICAvLyBoYXMgYSBzdGFibGUgc2hhcGUgYW5kIHNvIGhvcGVmdWxseSBzaG91bGQgYmUgY2hlYXAgdG8gYWxsb2NhdGUuXG4gIGZ1bmN0aW9uIHRyeUNhdGNoKGZuLCBvYmosIGFyZykge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBcIm5vcm1hbFwiLCBhcmc6IGZuLmNhbGwob2JqLCBhcmcpIH07XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBcInRocm93XCIsIGFyZzogZXJyIH07XG4gICAgfVxuICB9XG5cbiAgdmFyIEdlblN0YXRlU3VzcGVuZGVkU3RhcnQgPSBcInN1c3BlbmRlZFN0YXJ0XCI7XG4gIHZhciBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkID0gXCJzdXNwZW5kZWRZaWVsZFwiO1xuICB2YXIgR2VuU3RhdGVFeGVjdXRpbmcgPSBcImV4ZWN1dGluZ1wiO1xuICB2YXIgR2VuU3RhdGVDb21wbGV0ZWQgPSBcImNvbXBsZXRlZFwiO1xuXG4gIC8vIFJldHVybmluZyB0aGlzIG9iamVjdCBmcm9tIHRoZSBpbm5lckZuIGhhcyB0aGUgc2FtZSBlZmZlY3QgYXNcbiAgLy8gYnJlYWtpbmcgb3V0IG9mIHRoZSBkaXNwYXRjaCBzd2l0Y2ggc3RhdGVtZW50LlxuICB2YXIgQ29udGludWVTZW50aW5lbCA9IHt9O1xuXG4gIC8vIER1bW15IGNvbnN0cnVjdG9yIGZ1bmN0aW9ucyB0aGF0IHdlIHVzZSBhcyB0aGUgLmNvbnN0cnVjdG9yIGFuZFxuICAvLyAuY29uc3RydWN0b3IucHJvdG90eXBlIHByb3BlcnRpZXMgZm9yIGZ1bmN0aW9ucyB0aGF0IHJldHVybiBHZW5lcmF0b3JcbiAgLy8gb2JqZWN0cy4gRm9yIGZ1bGwgc3BlYyBjb21wbGlhbmNlLCB5b3UgbWF5IHdpc2ggdG8gY29uZmlndXJlIHlvdXJcbiAgLy8gbWluaWZpZXIgbm90IHRvIG1hbmdsZSB0aGUgbmFtZXMgb2YgdGhlc2UgdHdvIGZ1bmN0aW9ucy5cbiAgZnVuY3Rpb24gR2VuZXJhdG9yKCkge31cbiAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb24oKSB7fVxuICBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSgpIHt9XG5cbiAgLy8gVGhpcyBpcyBhIHBvbHlmaWxsIGZvciAlSXRlcmF0b3JQcm90b3R5cGUlIGZvciBlbnZpcm9ubWVudHMgdGhhdFxuICAvLyBkb24ndCBuYXRpdmVseSBzdXBwb3J0IGl0LlxuICB2YXIgSXRlcmF0b3JQcm90b3R5cGUgPSB7fTtcbiAgSXRlcmF0b3JQcm90b3R5cGVbaXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIHZhciBnZXRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbiAgdmFyIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG8gJiYgZ2V0UHJvdG8oZ2V0UHJvdG8odmFsdWVzKFtdKSkpO1xuICBpZiAoTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgJiZcbiAgICAgIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlICE9PSBPcCAmJlxuICAgICAgaGFzT3duLmNhbGwoTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUsIGl0ZXJhdG9yU3ltYm9sKSkge1xuICAgIC8vIFRoaXMgZW52aXJvbm1lbnQgaGFzIGEgbmF0aXZlICVJdGVyYXRvclByb3RvdHlwZSU7IHVzZSBpdCBpbnN0ZWFkXG4gICAgLy8gb2YgdGhlIHBvbHlmaWxsLlxuICAgIEl0ZXJhdG9yUHJvdG90eXBlID0gTmF0aXZlSXRlcmF0b3JQcm90b3R5cGU7XG4gIH1cblxuICB2YXIgR3AgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5wcm90b3R5cGUgPVxuICAgIEdlbmVyYXRvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEl0ZXJhdG9yUHJvdG90eXBlKTtcbiAgR2VuZXJhdG9yRnVuY3Rpb24ucHJvdG90eXBlID0gR3AuY29uc3RydWN0b3IgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZTtcbiAgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUuY29uc3RydWN0b3IgPSBHZW5lcmF0b3JGdW5jdGlvbjtcbiAgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGVbdG9TdHJpbmdUYWdTeW1ib2xdID1cbiAgICBHZW5lcmF0b3JGdW5jdGlvbi5kaXNwbGF5TmFtZSA9IFwiR2VuZXJhdG9yRnVuY3Rpb25cIjtcblxuICAvLyBIZWxwZXIgZm9yIGRlZmluaW5nIHRoZSAubmV4dCwgLnRocm93LCBhbmQgLnJldHVybiBtZXRob2RzIG9mIHRoZVxuICAvLyBJdGVyYXRvciBpbnRlcmZhY2UgaW4gdGVybXMgb2YgYSBzaW5nbGUgLl9pbnZva2UgbWV0aG9kLlxuICBmdW5jdGlvbiBkZWZpbmVJdGVyYXRvck1ldGhvZHMocHJvdG90eXBlKSB7XG4gICAgW1wibmV4dFwiLCBcInRocm93XCIsIFwicmV0dXJuXCJdLmZvckVhY2goZnVuY3Rpb24obWV0aG9kKSB7XG4gICAgICBwcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uKGFyZykge1xuICAgICAgICByZXR1cm4gdGhpcy5faW52b2tlKG1ldGhvZCwgYXJnKTtcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cblxuICBydW50aW1lLmlzR2VuZXJhdG9yRnVuY3Rpb24gPSBmdW5jdGlvbihnZW5GdW4pIHtcbiAgICB2YXIgY3RvciA9IHR5cGVvZiBnZW5GdW4gPT09IFwiZnVuY3Rpb25cIiAmJiBnZW5GdW4uY29uc3RydWN0b3I7XG4gICAgcmV0dXJuIGN0b3JcbiAgICAgID8gY3RvciA9PT0gR2VuZXJhdG9yRnVuY3Rpb24gfHxcbiAgICAgICAgLy8gRm9yIHRoZSBuYXRpdmUgR2VuZXJhdG9yRnVuY3Rpb24gY29uc3RydWN0b3IsIHRoZSBiZXN0IHdlIGNhblxuICAgICAgICAvLyBkbyBpcyB0byBjaGVjayBpdHMgLm5hbWUgcHJvcGVydHkuXG4gICAgICAgIChjdG9yLmRpc3BsYXlOYW1lIHx8IGN0b3IubmFtZSkgPT09IFwiR2VuZXJhdG9yRnVuY3Rpb25cIlxuICAgICAgOiBmYWxzZTtcbiAgfTtcblxuICBydW50aW1lLm1hcmsgPSBmdW5jdGlvbihnZW5GdW4pIHtcbiAgICBpZiAoT2JqZWN0LnNldFByb3RvdHlwZU9mKSB7XG4gICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoZ2VuRnVuLCBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdlbkZ1bi5fX3Byb3RvX18gPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZTtcbiAgICAgIGlmICghKHRvU3RyaW5nVGFnU3ltYm9sIGluIGdlbkZ1bikpIHtcbiAgICAgICAgZ2VuRnVuW3RvU3RyaW5nVGFnU3ltYm9sXSA9IFwiR2VuZXJhdG9yRnVuY3Rpb25cIjtcbiAgICAgIH1cbiAgICB9XG4gICAgZ2VuRnVuLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoR3ApO1xuICAgIHJldHVybiBnZW5GdW47XG4gIH07XG5cbiAgLy8gV2l0aGluIHRoZSBib2R5IG9mIGFueSBhc3luYyBmdW5jdGlvbiwgYGF3YWl0IHhgIGlzIHRyYW5zZm9ybWVkIHRvXG4gIC8vIGB5aWVsZCByZWdlbmVyYXRvclJ1bnRpbWUuYXdyYXAoeClgLCBzbyB0aGF0IHRoZSBydW50aW1lIGNhbiB0ZXN0XG4gIC8vIGBoYXNPd24uY2FsbCh2YWx1ZSwgXCJfX2F3YWl0XCIpYCB0byBkZXRlcm1pbmUgaWYgdGhlIHlpZWxkZWQgdmFsdWUgaXNcbiAgLy8gbWVhbnQgdG8gYmUgYXdhaXRlZC5cbiAgcnVudGltZS5hd3JhcCA9IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiB7IF9fYXdhaXQ6IGFyZyB9O1xuICB9O1xuXG4gIGZ1bmN0aW9uIEFzeW5jSXRlcmF0b3IoZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChnZW5lcmF0b3JbbWV0aG9kXSwgZ2VuZXJhdG9yLCBhcmcpO1xuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgcmVqZWN0KHJlY29yZC5hcmcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHJlY29yZC5hcmc7XG4gICAgICAgIHZhciB2YWx1ZSA9IHJlc3VsdC52YWx1ZTtcbiAgICAgICAgaWYgKHZhbHVlICYmXG4gICAgICAgICAgICB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgICAgIGhhc093bi5jYWxsKHZhbHVlLCBcIl9fYXdhaXRcIikpIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZhbHVlLl9fYXdhaXQpLnRoZW4oZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIGludm9rZShcIm5leHRcIiwgdmFsdWUsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSwgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICBpbnZva2UoXCJ0aHJvd1wiLCBlcnIsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZhbHVlKS50aGVuKGZ1bmN0aW9uKHVud3JhcHBlZCkge1xuICAgICAgICAgIC8vIFdoZW4gYSB5aWVsZGVkIFByb21pc2UgaXMgcmVzb2x2ZWQsIGl0cyBmaW5hbCB2YWx1ZSBiZWNvbWVzXG4gICAgICAgICAgLy8gdGhlIC52YWx1ZSBvZiB0aGUgUHJvbWlzZTx7dmFsdWUsZG9uZX0+IHJlc3VsdCBmb3IgdGhlXG4gICAgICAgICAgLy8gY3VycmVudCBpdGVyYXRpb24uIElmIHRoZSBQcm9taXNlIGlzIHJlamVjdGVkLCBob3dldmVyLCB0aGVcbiAgICAgICAgICAvLyByZXN1bHQgZm9yIHRoaXMgaXRlcmF0aW9uIHdpbGwgYmUgcmVqZWN0ZWQgd2l0aCB0aGUgc2FtZVxuICAgICAgICAgIC8vIHJlYXNvbi4gTm90ZSB0aGF0IHJlamVjdGlvbnMgb2YgeWllbGRlZCBQcm9taXNlcyBhcmUgbm90XG4gICAgICAgICAgLy8gdGhyb3duIGJhY2sgaW50byB0aGUgZ2VuZXJhdG9yIGZ1bmN0aW9uLCBhcyBpcyB0aGUgY2FzZVxuICAgICAgICAgIC8vIHdoZW4gYW4gYXdhaXRlZCBQcm9taXNlIGlzIHJlamVjdGVkLiBUaGlzIGRpZmZlcmVuY2UgaW5cbiAgICAgICAgICAvLyBiZWhhdmlvciBiZXR3ZWVuIHlpZWxkIGFuZCBhd2FpdCBpcyBpbXBvcnRhbnQsIGJlY2F1c2UgaXRcbiAgICAgICAgICAvLyBhbGxvd3MgdGhlIGNvbnN1bWVyIHRvIGRlY2lkZSB3aGF0IHRvIGRvIHdpdGggdGhlIHlpZWxkZWRcbiAgICAgICAgICAvLyByZWplY3Rpb24gKHN3YWxsb3cgaXQgYW5kIGNvbnRpbnVlLCBtYW51YWxseSAudGhyb3cgaXQgYmFja1xuICAgICAgICAgIC8vIGludG8gdGhlIGdlbmVyYXRvciwgYWJhbmRvbiBpdGVyYXRpb24sIHdoYXRldmVyKS4gV2l0aFxuICAgICAgICAgIC8vIGF3YWl0LCBieSBjb250cmFzdCwgdGhlcmUgaXMgbm8gb3Bwb3J0dW5pdHkgdG8gZXhhbWluZSB0aGVcbiAgICAgICAgICAvLyByZWplY3Rpb24gcmVhc29uIG91dHNpZGUgdGhlIGdlbmVyYXRvciBmdW5jdGlvbiwgc28gdGhlXG4gICAgICAgICAgLy8gb25seSBvcHRpb24gaXMgdG8gdGhyb3cgaXQgZnJvbSB0aGUgYXdhaXQgZXhwcmVzc2lvbiwgYW5kXG4gICAgICAgICAgLy8gbGV0IHRoZSBnZW5lcmF0b3IgZnVuY3Rpb24gaGFuZGxlIHRoZSBleGNlcHRpb24uXG4gICAgICAgICAgcmVzdWx0LnZhbHVlID0gdW53cmFwcGVkO1xuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfSwgcmVqZWN0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcHJldmlvdXNQcm9taXNlO1xuXG4gICAgZnVuY3Rpb24gZW5xdWV1ZShtZXRob2QsIGFyZykge1xuICAgICAgZnVuY3Rpb24gY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcHJldmlvdXNQcm9taXNlID1cbiAgICAgICAgLy8gSWYgZW5xdWV1ZSBoYXMgYmVlbiBjYWxsZWQgYmVmb3JlLCB0aGVuIHdlIHdhbnQgdG8gd2FpdCB1bnRpbFxuICAgICAgICAvLyBhbGwgcHJldmlvdXMgUHJvbWlzZXMgaGF2ZSBiZWVuIHJlc29sdmVkIGJlZm9yZSBjYWxsaW5nIGludm9rZSxcbiAgICAgICAgLy8gc28gdGhhdCByZXN1bHRzIGFyZSBhbHdheXMgZGVsaXZlcmVkIGluIHRoZSBjb3JyZWN0IG9yZGVyLiBJZlxuICAgICAgICAvLyBlbnF1ZXVlIGhhcyBub3QgYmVlbiBjYWxsZWQgYmVmb3JlLCB0aGVuIGl0IGlzIGltcG9ydGFudCB0b1xuICAgICAgICAvLyBjYWxsIGludm9rZSBpbW1lZGlhdGVseSwgd2l0aG91dCB3YWl0aW5nIG9uIGEgY2FsbGJhY2sgdG8gZmlyZSxcbiAgICAgICAgLy8gc28gdGhhdCB0aGUgYXN5bmMgZ2VuZXJhdG9yIGZ1bmN0aW9uIGhhcyB0aGUgb3Bwb3J0dW5pdHkgdG8gZG9cbiAgICAgICAgLy8gYW55IG5lY2Vzc2FyeSBzZXR1cCBpbiBhIHByZWRpY3RhYmxlIHdheS4gVGhpcyBwcmVkaWN0YWJpbGl0eVxuICAgICAgICAvLyBpcyB3aHkgdGhlIFByb21pc2UgY29uc3RydWN0b3Igc3luY2hyb25vdXNseSBpbnZva2VzIGl0c1xuICAgICAgICAvLyBleGVjdXRvciBjYWxsYmFjaywgYW5kIHdoeSBhc3luYyBmdW5jdGlvbnMgc3luY2hyb25vdXNseVxuICAgICAgICAvLyBleGVjdXRlIGNvZGUgYmVmb3JlIHRoZSBmaXJzdCBhd2FpdC4gU2luY2Ugd2UgaW1wbGVtZW50IHNpbXBsZVxuICAgICAgICAvLyBhc3luYyBmdW5jdGlvbnMgaW4gdGVybXMgb2YgYXN5bmMgZ2VuZXJhdG9ycywgaXQgaXMgZXNwZWNpYWxseVxuICAgICAgICAvLyBpbXBvcnRhbnQgdG8gZ2V0IHRoaXMgcmlnaHQsIGV2ZW4gdGhvdWdoIGl0IHJlcXVpcmVzIGNhcmUuXG4gICAgICAgIHByZXZpb3VzUHJvbWlzZSA/IHByZXZpb3VzUHJvbWlzZS50aGVuKFxuICAgICAgICAgIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnLFxuICAgICAgICAgIC8vIEF2b2lkIHByb3BhZ2F0aW5nIGZhaWx1cmVzIHRvIFByb21pc2VzIHJldHVybmVkIGJ5IGxhdGVyXG4gICAgICAgICAgLy8gaW52b2NhdGlvbnMgb2YgdGhlIGl0ZXJhdG9yLlxuICAgICAgICAgIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnXG4gICAgICAgICkgOiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpO1xuICAgIH1cblxuICAgIC8vIERlZmluZSB0aGUgdW5pZmllZCBoZWxwZXIgbWV0aG9kIHRoYXQgaXMgdXNlZCB0byBpbXBsZW1lbnQgLm5leHQsXG4gICAgLy8gLnRocm93LCBhbmQgLnJldHVybiAoc2VlIGRlZmluZUl0ZXJhdG9yTWV0aG9kcykuXG4gICAgdGhpcy5faW52b2tlID0gZW5xdWV1ZTtcbiAgfVxuXG4gIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhBc3luY0l0ZXJhdG9yLnByb3RvdHlwZSk7XG4gIEFzeW5jSXRlcmF0b3IucHJvdG90eXBlW2FzeW5jSXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICBydW50aW1lLkFzeW5jSXRlcmF0b3IgPSBBc3luY0l0ZXJhdG9yO1xuXG4gIC8vIE5vdGUgdGhhdCBzaW1wbGUgYXN5bmMgZnVuY3Rpb25zIGFyZSBpbXBsZW1lbnRlZCBvbiB0b3Agb2ZcbiAgLy8gQXN5bmNJdGVyYXRvciBvYmplY3RzOyB0aGV5IGp1c3QgcmV0dXJuIGEgUHJvbWlzZSBmb3IgdGhlIHZhbHVlIG9mXG4gIC8vIHRoZSBmaW5hbCByZXN1bHQgcHJvZHVjZWQgYnkgdGhlIGl0ZXJhdG9yLlxuICBydW50aW1lLmFzeW5jID0gZnVuY3Rpb24oaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpIHtcbiAgICB2YXIgaXRlciA9IG5ldyBBc3luY0l0ZXJhdG9yKFxuICAgICAgd3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdClcbiAgICApO1xuXG4gICAgcmV0dXJuIHJ1bnRpbWUuaXNHZW5lcmF0b3JGdW5jdGlvbihvdXRlckZuKVxuICAgICAgPyBpdGVyIC8vIElmIG91dGVyRm4gaXMgYSBnZW5lcmF0b3IsIHJldHVybiB0aGUgZnVsbCBpdGVyYXRvci5cbiAgICAgIDogaXRlci5uZXh0KCkudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0LmRvbmUgPyByZXN1bHQudmFsdWUgOiBpdGVyLm5leHQoKTtcbiAgICAgICAgfSk7XG4gIH07XG5cbiAgZnVuY3Rpb24gbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KSB7XG4gICAgdmFyIHN0YXRlID0gR2VuU3RhdGVTdXNwZW5kZWRTdGFydDtcblxuICAgIHJldHVybiBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcpIHtcbiAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVFeGVjdXRpbmcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgcnVubmluZ1wiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZUNvbXBsZXRlZCkge1xuICAgICAgICBpZiAobWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICB0aHJvdyBhcmc7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBCZSBmb3JnaXZpbmcsIHBlciAyNS4zLjMuMy4zIG9mIHRoZSBzcGVjOlxuICAgICAgICAvLyBodHRwczovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtZ2VuZXJhdG9ycmVzdW1lXG4gICAgICAgIHJldHVybiBkb25lUmVzdWx0KCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnRleHQubWV0aG9kID0gbWV0aG9kO1xuICAgICAgY29udGV4dC5hcmcgPSBhcmc7XG5cbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIHZhciBkZWxlZ2F0ZSA9IGNvbnRleHQuZGVsZWdhdGU7XG4gICAgICAgIGlmIChkZWxlZ2F0ZSkge1xuICAgICAgICAgIHZhciBkZWxlZ2F0ZVJlc3VsdCA9IG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpO1xuICAgICAgICAgIGlmIChkZWxlZ2F0ZVJlc3VsdCkge1xuICAgICAgICAgICAgaWYgKGRlbGVnYXRlUmVzdWx0ID09PSBDb250aW51ZVNlbnRpbmVsKSBjb250aW51ZTtcbiAgICAgICAgICAgIHJldHVybiBkZWxlZ2F0ZVJlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwibmV4dFwiKSB7XG4gICAgICAgICAgLy8gU2V0dGluZyBjb250ZXh0Ll9zZW50IGZvciBsZWdhY3kgc3VwcG9ydCBvZiBCYWJlbCdzXG4gICAgICAgICAgLy8gZnVuY3Rpb24uc2VudCBpbXBsZW1lbnRhdGlvbi5cbiAgICAgICAgICBjb250ZXh0LnNlbnQgPSBjb250ZXh0Ll9zZW50ID0gY29udGV4dC5hcmc7XG5cbiAgICAgICAgfSBlbHNlIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0KSB7XG4gICAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlQ29tcGxldGVkO1xuICAgICAgICAgICAgdGhyb3cgY29udGV4dC5hcmc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihjb250ZXh0LmFyZyk7XG5cbiAgICAgICAgfSBlbHNlIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJyZXR1cm5cIikge1xuICAgICAgICAgIGNvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIGNvbnRleHQuYXJnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRlID0gR2VuU3RhdGVFeGVjdXRpbmc7XG5cbiAgICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpO1xuICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwibm9ybWFsXCIpIHtcbiAgICAgICAgICAvLyBJZiBhbiBleGNlcHRpb24gaXMgdGhyb3duIGZyb20gaW5uZXJGbiwgd2UgbGVhdmUgc3RhdGUgPT09XG4gICAgICAgICAgLy8gR2VuU3RhdGVFeGVjdXRpbmcgYW5kIGxvb3AgYmFjayBmb3IgYW5vdGhlciBpbnZvY2F0aW9uLlxuICAgICAgICAgIHN0YXRlID0gY29udGV4dC5kb25lXG4gICAgICAgICAgICA/IEdlblN0YXRlQ29tcGxldGVkXG4gICAgICAgICAgICA6IEdlblN0YXRlU3VzcGVuZGVkWWllbGQ7XG5cbiAgICAgICAgICBpZiAocmVjb3JkLmFyZyA9PT0gQ29udGludWVTZW50aW5lbCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZhbHVlOiByZWNvcmQuYXJnLFxuICAgICAgICAgICAgZG9uZTogY29udGV4dC5kb25lXG4gICAgICAgICAgfTtcblxuICAgICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlQ29tcGxldGVkO1xuICAgICAgICAgIC8vIERpc3BhdGNoIHRoZSBleGNlcHRpb24gYnkgbG9vcGluZyBiYWNrIGFyb3VuZCB0byB0aGVcbiAgICAgICAgICAvLyBjb250ZXh0LmRpc3BhdGNoRXhjZXB0aW9uKGNvbnRleHQuYXJnKSBjYWxsIGFib3ZlLlxuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgICAgIGNvbnRleHQuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH1cblxuICAvLyBDYWxsIGRlbGVnYXRlLml0ZXJhdG9yW2NvbnRleHQubWV0aG9kXShjb250ZXh0LmFyZykgYW5kIGhhbmRsZSB0aGVcbiAgLy8gcmVzdWx0LCBlaXRoZXIgYnkgcmV0dXJuaW5nIGEgeyB2YWx1ZSwgZG9uZSB9IHJlc3VsdCBmcm9tIHRoZVxuICAvLyBkZWxlZ2F0ZSBpdGVyYXRvciwgb3IgYnkgbW9kaWZ5aW5nIGNvbnRleHQubWV0aG9kIGFuZCBjb250ZXh0LmFyZyxcbiAgLy8gc2V0dGluZyBjb250ZXh0LmRlbGVnYXRlIHRvIG51bGwsIGFuZCByZXR1cm5pbmcgdGhlIENvbnRpbnVlU2VudGluZWwuXG4gIGZ1bmN0aW9uIG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpIHtcbiAgICB2YXIgbWV0aG9kID0gZGVsZWdhdGUuaXRlcmF0b3JbY29udGV4dC5tZXRob2RdO1xuICAgIGlmIChtZXRob2QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gQSAudGhyb3cgb3IgLnJldHVybiB3aGVuIHRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBoYXMgbm8gLnRocm93XG4gICAgICAvLyBtZXRob2QgYWx3YXlzIHRlcm1pbmF0ZXMgdGhlIHlpZWxkKiBsb29wLlxuICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG5cbiAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIGlmIChkZWxlZ2F0ZS5pdGVyYXRvci5yZXR1cm4pIHtcbiAgICAgICAgICAvLyBJZiB0aGUgZGVsZWdhdGUgaXRlcmF0b3IgaGFzIGEgcmV0dXJuIG1ldGhvZCwgZ2l2ZSBpdCBhXG4gICAgICAgICAgLy8gY2hhbmNlIHRvIGNsZWFuIHVwLlxuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJyZXR1cm5cIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KTtcblxuICAgICAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgICAvLyBJZiBtYXliZUludm9rZURlbGVnYXRlKGNvbnRleHQpIGNoYW5nZWQgY29udGV4dC5tZXRob2QgZnJvbVxuICAgICAgICAgICAgLy8gXCJyZXR1cm5cIiB0byBcInRocm93XCIsIGxldCB0aGF0IG92ZXJyaWRlIHRoZSBUeXBlRXJyb3IgYmVsb3cuXG4gICAgICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgICAgY29udGV4dC5hcmcgPSBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgIFwiVGhlIGl0ZXJhdG9yIGRvZXMgbm90IHByb3ZpZGUgYSAndGhyb3cnIG1ldGhvZFwiKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuXG4gICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKG1ldGhvZCwgZGVsZWdhdGUuaXRlcmF0b3IsIGNvbnRleHQuYXJnKTtcblxuICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgIGNvbnRleHQuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuXG4gICAgdmFyIGluZm8gPSByZWNvcmQuYXJnO1xuXG4gICAgaWYgKCEgaW5mbykge1xuICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICBjb250ZXh0LmFyZyA9IG5ldyBUeXBlRXJyb3IoXCJpdGVyYXRvciByZXN1bHQgaXMgbm90IGFuIG9iamVjdFwiKTtcbiAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuXG4gICAgaWYgKGluZm8uZG9uZSkge1xuICAgICAgLy8gQXNzaWduIHRoZSByZXN1bHQgb2YgdGhlIGZpbmlzaGVkIGRlbGVnYXRlIHRvIHRoZSB0ZW1wb3JhcnlcbiAgICAgIC8vIHZhcmlhYmxlIHNwZWNpZmllZCBieSBkZWxlZ2F0ZS5yZXN1bHROYW1lIChzZWUgZGVsZWdhdGVZaWVsZCkuXG4gICAgICBjb250ZXh0W2RlbGVnYXRlLnJlc3VsdE5hbWVdID0gaW5mby52YWx1ZTtcblxuICAgICAgLy8gUmVzdW1lIGV4ZWN1dGlvbiBhdCB0aGUgZGVzaXJlZCBsb2NhdGlvbiAoc2VlIGRlbGVnYXRlWWllbGQpLlxuICAgICAgY29udGV4dC5uZXh0ID0gZGVsZWdhdGUubmV4dExvYztcblxuICAgICAgLy8gSWYgY29udGV4dC5tZXRob2Qgd2FzIFwidGhyb3dcIiBidXQgdGhlIGRlbGVnYXRlIGhhbmRsZWQgdGhlXG4gICAgICAvLyBleGNlcHRpb24sIGxldCB0aGUgb3V0ZXIgZ2VuZXJhdG9yIHByb2NlZWQgbm9ybWFsbHkuIElmXG4gICAgICAvLyBjb250ZXh0Lm1ldGhvZCB3YXMgXCJuZXh0XCIsIGZvcmdldCBjb250ZXh0LmFyZyBzaW5jZSBpdCBoYXMgYmVlblxuICAgICAgLy8gXCJjb25zdW1lZFwiIGJ5IHRoZSBkZWxlZ2F0ZSBpdGVyYXRvci4gSWYgY29udGV4dC5tZXRob2Qgd2FzXG4gICAgICAvLyBcInJldHVyblwiLCBhbGxvdyB0aGUgb3JpZ2luYWwgLnJldHVybiBjYWxsIHRvIGNvbnRpbnVlIGluIHRoZVxuICAgICAgLy8gb3V0ZXIgZ2VuZXJhdG9yLlxuICAgICAgaWYgKGNvbnRleHQubWV0aG9kICE9PSBcInJldHVyblwiKSB7XG4gICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJlLXlpZWxkIHRoZSByZXN1bHQgcmV0dXJuZWQgYnkgdGhlIGRlbGVnYXRlIG1ldGhvZC5cbiAgICAgIHJldHVybiBpbmZvO1xuICAgIH1cblxuICAgIC8vIFRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBpcyBmaW5pc2hlZCwgc28gZm9yZ2V0IGl0IGFuZCBjb250aW51ZSB3aXRoXG4gICAgLy8gdGhlIG91dGVyIGdlbmVyYXRvci5cbiAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgfVxuXG4gIC8vIERlZmluZSBHZW5lcmF0b3IucHJvdG90eXBlLntuZXh0LHRocm93LHJldHVybn0gaW4gdGVybXMgb2YgdGhlXG4gIC8vIHVuaWZpZWQgLl9pbnZva2UgaGVscGVyIG1ldGhvZC5cbiAgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEdwKTtcblxuICBHcFt0b1N0cmluZ1RhZ1N5bWJvbF0gPSBcIkdlbmVyYXRvclwiO1xuXG4gIC8vIEEgR2VuZXJhdG9yIHNob3VsZCBhbHdheXMgcmV0dXJuIGl0c2VsZiBhcyB0aGUgaXRlcmF0b3Igb2JqZWN0IHdoZW4gdGhlXG4gIC8vIEBAaXRlcmF0b3IgZnVuY3Rpb24gaXMgY2FsbGVkIG9uIGl0LiBTb21lIGJyb3dzZXJzJyBpbXBsZW1lbnRhdGlvbnMgb2YgdGhlXG4gIC8vIGl0ZXJhdG9yIHByb3RvdHlwZSBjaGFpbiBpbmNvcnJlY3RseSBpbXBsZW1lbnQgdGhpcywgY2F1c2luZyB0aGUgR2VuZXJhdG9yXG4gIC8vIG9iamVjdCB0byBub3QgYmUgcmV0dXJuZWQgZnJvbSB0aGlzIGNhbGwuIFRoaXMgZW5zdXJlcyB0aGF0IGRvZXNuJ3QgaGFwcGVuLlxuICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlZ2VuZXJhdG9yL2lzc3Vlcy8yNzQgZm9yIG1vcmUgZGV0YWlscy5cbiAgR3BbaXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgR3AudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gXCJbb2JqZWN0IEdlbmVyYXRvcl1cIjtcbiAgfTtcblxuICBmdW5jdGlvbiBwdXNoVHJ5RW50cnkobG9jcykge1xuICAgIHZhciBlbnRyeSA9IHsgdHJ5TG9jOiBsb2NzWzBdIH07XG5cbiAgICBpZiAoMSBpbiBsb2NzKSB7XG4gICAgICBlbnRyeS5jYXRjaExvYyA9IGxvY3NbMV07XG4gICAgfVxuXG4gICAgaWYgKDIgaW4gbG9jcykge1xuICAgICAgZW50cnkuZmluYWxseUxvYyA9IGxvY3NbMl07XG4gICAgICBlbnRyeS5hZnRlckxvYyA9IGxvY3NbM107XG4gICAgfVxuXG4gICAgdGhpcy50cnlFbnRyaWVzLnB1c2goZW50cnkpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVzZXRUcnlFbnRyeShlbnRyeSkge1xuICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uIHx8IHt9O1xuICAgIHJlY29yZC50eXBlID0gXCJub3JtYWxcIjtcbiAgICBkZWxldGUgcmVjb3JkLmFyZztcbiAgICBlbnRyeS5jb21wbGV0aW9uID0gcmVjb3JkO1xuICB9XG5cbiAgZnVuY3Rpb24gQ29udGV4dCh0cnlMb2NzTGlzdCkge1xuICAgIC8vIFRoZSByb290IGVudHJ5IG9iamVjdCAoZWZmZWN0aXZlbHkgYSB0cnkgc3RhdGVtZW50IHdpdGhvdXQgYSBjYXRjaFxuICAgIC8vIG9yIGEgZmluYWxseSBibG9jaykgZ2l2ZXMgdXMgYSBwbGFjZSB0byBzdG9yZSB2YWx1ZXMgdGhyb3duIGZyb21cbiAgICAvLyBsb2NhdGlvbnMgd2hlcmUgdGhlcmUgaXMgbm8gZW5jbG9zaW5nIHRyeSBzdGF0ZW1lbnQuXG4gICAgdGhpcy50cnlFbnRyaWVzID0gW3sgdHJ5TG9jOiBcInJvb3RcIiB9XTtcbiAgICB0cnlMb2NzTGlzdC5mb3JFYWNoKHB1c2hUcnlFbnRyeSwgdGhpcyk7XG4gICAgdGhpcy5yZXNldCh0cnVlKTtcbiAgfVxuXG4gIHJ1bnRpbWUua2V5cyA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHZhciBrZXlzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgfVxuICAgIGtleXMucmV2ZXJzZSgpO1xuXG4gICAgLy8gUmF0aGVyIHRoYW4gcmV0dXJuaW5nIGFuIG9iamVjdCB3aXRoIGEgbmV4dCBtZXRob2QsIHdlIGtlZXBcbiAgICAvLyB0aGluZ3Mgc2ltcGxlIGFuZCByZXR1cm4gdGhlIG5leHQgZnVuY3Rpb24gaXRzZWxmLlxuICAgIHJldHVybiBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgd2hpbGUgKGtleXMubGVuZ3RoKSB7XG4gICAgICAgIHZhciBrZXkgPSBrZXlzLnBvcCgpO1xuICAgICAgICBpZiAoa2V5IGluIG9iamVjdCkge1xuICAgICAgICAgIG5leHQudmFsdWUgPSBrZXk7XG4gICAgICAgICAgbmV4dC5kb25lID0gZmFsc2U7XG4gICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVG8gYXZvaWQgY3JlYXRpbmcgYW4gYWRkaXRpb25hbCBvYmplY3QsIHdlIGp1c3QgaGFuZyB0aGUgLnZhbHVlXG4gICAgICAvLyBhbmQgLmRvbmUgcHJvcGVydGllcyBvZmYgdGhlIG5leHQgZnVuY3Rpb24gb2JqZWN0IGl0c2VsZi4gVGhpc1xuICAgICAgLy8gYWxzbyBlbnN1cmVzIHRoYXQgdGhlIG1pbmlmaWVyIHdpbGwgbm90IGFub255bWl6ZSB0aGUgZnVuY3Rpb24uXG4gICAgICBuZXh0LmRvbmUgPSB0cnVlO1xuICAgICAgcmV0dXJuIG5leHQ7XG4gICAgfTtcbiAgfTtcblxuICBmdW5jdGlvbiB2YWx1ZXMoaXRlcmFibGUpIHtcbiAgICBpZiAoaXRlcmFibGUpIHtcbiAgICAgIHZhciBpdGVyYXRvck1ldGhvZCA9IGl0ZXJhYmxlW2l0ZXJhdG9yU3ltYm9sXTtcbiAgICAgIGlmIChpdGVyYXRvck1ldGhvZCkge1xuICAgICAgICByZXR1cm4gaXRlcmF0b3JNZXRob2QuY2FsbChpdGVyYWJsZSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgaXRlcmFibGUubmV4dCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiBpdGVyYWJsZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpc05hTihpdGVyYWJsZS5sZW5ndGgpKSB7XG4gICAgICAgIHZhciBpID0gLTEsIG5leHQgPSBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICAgIHdoaWxlICgrK2kgPCBpdGVyYWJsZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChoYXNPd24uY2FsbChpdGVyYWJsZSwgaSkpIHtcbiAgICAgICAgICAgICAgbmV4dC52YWx1ZSA9IGl0ZXJhYmxlW2ldO1xuICAgICAgICAgICAgICBuZXh0LmRvbmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbmV4dC52YWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBuZXh0LmRvbmUgPSB0cnVlO1xuXG4gICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIG5leHQubmV4dCA9IG5leHQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUmV0dXJuIGFuIGl0ZXJhdG9yIHdpdGggbm8gdmFsdWVzLlxuICAgIHJldHVybiB7IG5leHQ6IGRvbmVSZXN1bHQgfTtcbiAgfVxuICBydW50aW1lLnZhbHVlcyA9IHZhbHVlcztcblxuICBmdW5jdGlvbiBkb25lUmVzdWx0KCkge1xuICAgIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcbiAgfVxuXG4gIENvbnRleHQucHJvdG90eXBlID0ge1xuICAgIGNvbnN0cnVjdG9yOiBDb250ZXh0LFxuXG4gICAgcmVzZXQ6IGZ1bmN0aW9uKHNraXBUZW1wUmVzZXQpIHtcbiAgICAgIHRoaXMucHJldiA9IDA7XG4gICAgICB0aGlzLm5leHQgPSAwO1xuICAgICAgLy8gUmVzZXR0aW5nIGNvbnRleHQuX3NlbnQgZm9yIGxlZ2FjeSBzdXBwb3J0IG9mIEJhYmVsJ3NcbiAgICAgIC8vIGZ1bmN0aW9uLnNlbnQgaW1wbGVtZW50YXRpb24uXG4gICAgICB0aGlzLnNlbnQgPSB0aGlzLl9zZW50ID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5kb25lID0gZmFsc2U7XG4gICAgICB0aGlzLmRlbGVnYXRlID0gbnVsbDtcblxuICAgICAgdGhpcy5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgIHRoaXMuYXJnID0gdW5kZWZpbmVkO1xuXG4gICAgICB0aGlzLnRyeUVudHJpZXMuZm9yRWFjaChyZXNldFRyeUVudHJ5KTtcblxuICAgICAgaWYgKCFza2lwVGVtcFJlc2V0KSB7XG4gICAgICAgIGZvciAodmFyIG5hbWUgaW4gdGhpcykge1xuICAgICAgICAgIC8vIE5vdCBzdXJlIGFib3V0IHRoZSBvcHRpbWFsIG9yZGVyIG9mIHRoZXNlIGNvbmRpdGlvbnM6XG4gICAgICAgICAgaWYgKG5hbWUuY2hhckF0KDApID09PSBcInRcIiAmJlxuICAgICAgICAgICAgICBoYXNPd24uY2FsbCh0aGlzLCBuYW1lKSAmJlxuICAgICAgICAgICAgICAhaXNOYU4oK25hbWUuc2xpY2UoMSkpKSB7XG4gICAgICAgICAgICB0aGlzW25hbWVdID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBzdG9wOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuZG9uZSA9IHRydWU7XG5cbiAgICAgIHZhciByb290RW50cnkgPSB0aGlzLnRyeUVudHJpZXNbMF07XG4gICAgICB2YXIgcm9vdFJlY29yZCA9IHJvb3RFbnRyeS5jb21wbGV0aW9uO1xuICAgICAgaWYgKHJvb3RSZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHRocm93IHJvb3RSZWNvcmQuYXJnO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5ydmFsO1xuICAgIH0sXG5cbiAgICBkaXNwYXRjaEV4Y2VwdGlvbjogZnVuY3Rpb24oZXhjZXB0aW9uKSB7XG4gICAgICBpZiAodGhpcy5kb25lKSB7XG4gICAgICAgIHRocm93IGV4Y2VwdGlvbjtcbiAgICAgIH1cblxuICAgICAgdmFyIGNvbnRleHQgPSB0aGlzO1xuICAgICAgZnVuY3Rpb24gaGFuZGxlKGxvYywgY2F1Z2h0KSB7XG4gICAgICAgIHJlY29yZC50eXBlID0gXCJ0aHJvd1wiO1xuICAgICAgICByZWNvcmQuYXJnID0gZXhjZXB0aW9uO1xuICAgICAgICBjb250ZXh0Lm5leHQgPSBsb2M7XG5cbiAgICAgICAgaWYgKGNhdWdodCkge1xuICAgICAgICAgIC8vIElmIHRoZSBkaXNwYXRjaGVkIGV4Y2VwdGlvbiB3YXMgY2F1Z2h0IGJ5IGEgY2F0Y2ggYmxvY2ssXG4gICAgICAgICAgLy8gdGhlbiBsZXQgdGhhdCBjYXRjaCBibG9jayBoYW5kbGUgdGhlIGV4Y2VwdGlvbiBub3JtYWxseS5cbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICEhIGNhdWdodDtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uO1xuXG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPT09IFwicm9vdFwiKSB7XG4gICAgICAgICAgLy8gRXhjZXB0aW9uIHRocm93biBvdXRzaWRlIG9mIGFueSB0cnkgYmxvY2sgdGhhdCBjb3VsZCBoYW5kbGVcbiAgICAgICAgICAvLyBpdCwgc28gc2V0IHRoZSBjb21wbGV0aW9uIHZhbHVlIG9mIHRoZSBlbnRpcmUgZnVuY3Rpb24gdG9cbiAgICAgICAgICAvLyB0aHJvdyB0aGUgZXhjZXB0aW9uLlxuICAgICAgICAgIHJldHVybiBoYW5kbGUoXCJlbmRcIik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldikge1xuICAgICAgICAgIHZhciBoYXNDYXRjaCA9IGhhc093bi5jYWxsKGVudHJ5LCBcImNhdGNoTG9jXCIpO1xuICAgICAgICAgIHZhciBoYXNGaW5hbGx5ID0gaGFzT3duLmNhbGwoZW50cnksIFwiZmluYWxseUxvY1wiKTtcblxuICAgICAgICAgIGlmIChoYXNDYXRjaCAmJiBoYXNGaW5hbGx5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgdHJ1ZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSBpZiAoaGFzQ2F0Y2gpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCB0cnVlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSBpZiAoaGFzRmluYWxseSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0cnkgc3RhdGVtZW50IHdpdGhvdXQgY2F0Y2ggb3IgZmluYWxseVwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgYWJydXB0OiBmdW5jdGlvbih0eXBlLCBhcmcpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldiAmJlxuICAgICAgICAgICAgaGFzT3duLmNhbGwoZW50cnksIFwiZmluYWxseUxvY1wiKSAmJlxuICAgICAgICAgICAgdGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgIHZhciBmaW5hbGx5RW50cnkgPSBlbnRyeTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZmluYWxseUVudHJ5ICYmXG4gICAgICAgICAgKHR5cGUgPT09IFwiYnJlYWtcIiB8fFxuICAgICAgICAgICB0eXBlID09PSBcImNvbnRpbnVlXCIpICYmXG4gICAgICAgICAgZmluYWxseUVudHJ5LnRyeUxvYyA8PSBhcmcgJiZcbiAgICAgICAgICBhcmcgPD0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgLy8gSWdub3JlIHRoZSBmaW5hbGx5IGVudHJ5IGlmIGNvbnRyb2wgaXMgbm90IGp1bXBpbmcgdG8gYVxuICAgICAgICAvLyBsb2NhdGlvbiBvdXRzaWRlIHRoZSB0cnkvY2F0Y2ggYmxvY2suXG4gICAgICAgIGZpbmFsbHlFbnRyeSA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciByZWNvcmQgPSBmaW5hbGx5RW50cnkgPyBmaW5hbGx5RW50cnkuY29tcGxldGlvbiA6IHt9O1xuICAgICAgcmVjb3JkLnR5cGUgPSB0eXBlO1xuICAgICAgcmVjb3JkLmFyZyA9IGFyZztcblxuICAgICAgaWYgKGZpbmFsbHlFbnRyeSkge1xuICAgICAgICB0aGlzLm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICB0aGlzLm5leHQgPSBmaW5hbGx5RW50cnkuZmluYWxseUxvYztcbiAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmNvbXBsZXRlKHJlY29yZCk7XG4gICAgfSxcblxuICAgIGNvbXBsZXRlOiBmdW5jdGlvbihyZWNvcmQsIGFmdGVyTG9jKSB7XG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICB0aHJvdyByZWNvcmQuYXJnO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwiYnJlYWtcIiB8fFxuICAgICAgICAgIHJlY29yZC50eXBlID09PSBcImNvbnRpbnVlXCIpIHtcbiAgICAgICAgdGhpcy5uZXh0ID0gcmVjb3JkLmFyZztcbiAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgdGhpcy5ydmFsID0gdGhpcy5hcmcgPSByZWNvcmQuYXJnO1xuICAgICAgICB0aGlzLm1ldGhvZCA9IFwicmV0dXJuXCI7XG4gICAgICAgIHRoaXMubmV4dCA9IFwiZW5kXCI7XG4gICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcIm5vcm1hbFwiICYmIGFmdGVyTG9jKSB7XG4gICAgICAgIHRoaXMubmV4dCA9IGFmdGVyTG9jO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9LFxuXG4gICAgZmluaXNoOiBmdW5jdGlvbihmaW5hbGx5TG9jKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LmZpbmFsbHlMb2MgPT09IGZpbmFsbHlMb2MpIHtcbiAgICAgICAgICB0aGlzLmNvbXBsZXRlKGVudHJ5LmNvbXBsZXRpb24sIGVudHJ5LmFmdGVyTG9jKTtcbiAgICAgICAgICByZXNldFRyeUVudHJ5KGVudHJ5KTtcbiAgICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBcImNhdGNoXCI6IGZ1bmN0aW9uKHRyeUxvYykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPT09IHRyeUxvYykge1xuICAgICAgICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uO1xuICAgICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgICB2YXIgdGhyb3duID0gcmVjb3JkLmFyZztcbiAgICAgICAgICAgIHJlc2V0VHJ5RW50cnkoZW50cnkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGhyb3duO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRoZSBjb250ZXh0LmNhdGNoIG1ldGhvZCBtdXN0IG9ubHkgYmUgY2FsbGVkIHdpdGggYSBsb2NhdGlvblxuICAgICAgLy8gYXJndW1lbnQgdGhhdCBjb3JyZXNwb25kcyB0byBhIGtub3duIGNhdGNoIGJsb2NrLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaWxsZWdhbCBjYXRjaCBhdHRlbXB0XCIpO1xuICAgIH0sXG5cbiAgICBkZWxlZ2F0ZVlpZWxkOiBmdW5jdGlvbihpdGVyYWJsZSwgcmVzdWx0TmFtZSwgbmV4dExvYykge1xuICAgICAgdGhpcy5kZWxlZ2F0ZSA9IHtcbiAgICAgICAgaXRlcmF0b3I6IHZhbHVlcyhpdGVyYWJsZSksXG4gICAgICAgIHJlc3VsdE5hbWU6IHJlc3VsdE5hbWUsXG4gICAgICAgIG5leHRMb2M6IG5leHRMb2NcbiAgICAgIH07XG5cbiAgICAgIGlmICh0aGlzLm1ldGhvZCA9PT0gXCJuZXh0XCIpIHtcbiAgICAgICAgLy8gRGVsaWJlcmF0ZWx5IGZvcmdldCB0aGUgbGFzdCBzZW50IHZhbHVlIHNvIHRoYXQgd2UgZG9uJ3RcbiAgICAgICAgLy8gYWNjaWRlbnRhbGx5IHBhc3MgaXQgb24gdG8gdGhlIGRlbGVnYXRlLlxuICAgICAgICB0aGlzLmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuICB9O1xufSkoXG4gIC8vIEluIHNsb3BweSBtb2RlLCB1bmJvdW5kIGB0aGlzYCByZWZlcnMgdG8gdGhlIGdsb2JhbCBvYmplY3QsIGZhbGxiYWNrIHRvXG4gIC8vIEZ1bmN0aW9uIGNvbnN0cnVjdG9yIGlmIHdlJ3JlIGluIGdsb2JhbCBzdHJpY3QgbW9kZS4gVGhhdCBpcyBzYWRseSBhIGZvcm1cbiAgLy8gb2YgaW5kaXJlY3QgZXZhbCB3aGljaCB2aW9sYXRlcyBDb250ZW50IFNlY3VyaXR5IFBvbGljeS5cbiAgKGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcyB9KSgpIHx8IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKVxuKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWUuanMiLCJ2YXIgZztcclxuXHJcbi8vIFRoaXMgd29ya3MgaW4gbm9uLXN0cmljdCBtb2RlXHJcbmcgPSAoZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIHRoaXM7XHJcbn0pKCk7XHJcblxyXG50cnkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgZXZhbCBpcyBhbGxvd2VkIChzZWUgQ1NQKVxyXG5cdGcgPSBnIHx8IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKSB8fCAoMSxldmFsKShcInRoaXNcIik7XHJcbn0gY2F0Y2goZSkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXHJcblx0aWYodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIilcclxuXHRcdGcgPSB3aW5kb3c7XHJcbn1cclxuXHJcbi8vIGcgY2FuIHN0aWxsIGJlIHVuZGVmaW5lZCwgYnV0IG5vdGhpbmcgdG8gZG8gYWJvdXQgaXQuLi5cclxuLy8gV2UgcmV0dXJuIHVuZGVmaW5lZCwgaW5zdGVhZCBvZiBub3RoaW5nIGhlcmUsIHNvIGl0J3NcclxuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBnO1xyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzIiwiaW1wb3J0IFwiQGJhYmVsL3BvbHlmaWxsXCI7XHJcblxyXG5pbXBvcnQgKiAgYXMgUmVhY3QgZnJvbSBcInJlYWN0XCI7XHJcblxyXG5pbXBvcnQgeyBGcmFtZSwgRnJhbWVDb2xsZWN0aW9uIH0gZnJvbSBcIkBtb3JsZXlkZXYvcGF1cGVyL3JlbmRlci9yZW5kZXItZnJhbWUubW9kZWxcIjtcclxuXHJcbmltcG9ydCB7IEdhbWUgfSBmcm9tIFwiLi4vLi4vbWFpbi9nYW1lLXJlbmRlclwiO1xyXG5pbXBvcnQgeyBSZWFjdFJlbmRlcmVyIH0gZnJvbSBcIkBtb3JsZXlkZXYvcGF1cGVyL3JlbmRlci9qc3gvcmVuZGVyXCI7XHJcbmltcG9ydCB7IFdlYkFzc2V0TG9hZGVyIH0gZnJvbSBcIkBtb3JsZXlkZXYvcGF1cGVyL2Fzc2V0cy93ZWItYXNzZXQtbG9hZGVyLnNlcnZpY2VcIjtcclxuaW1wb3J0IHsgcmVuZGVyVG9DYW52YXMgfSBmcm9tIFwiQG1vcmxleWRldi9wYXVwZXIvcmVuZGVyL3JlbmRlci10by1jYW52YXMuZnVuY1wiO1xyXG5cclxuY29uc3QgY2FudmFzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJyZW5kZXItdGFyZ2V0XCIpIGFzIEhUTUxDYW52YXNFbGVtZW50IHwgbnVsbDtcclxuaWYgKGNhbnZhcyA9PSBudWxsKSB7XHJcblx0dGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IGZpbmQgI3JlbmRlci10YXJnZXRcIik7XHJcblxyXG59XHJcbmNvbnN0IGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xyXG5pZiAoY29udGV4dCA9PSBudWxsKSB7XHJcblx0dGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IGFjcXVpcmUgMmQgcmVuZGVyaW5nIGNvbnRleHRcIik7XHJcbn1cclxuY29uc3QgZWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiY2FudmFzLWNvbnRhaW5lclwiKTtcclxuaWYgKGVsZW1lbnQgPT0gbnVsbCkge1xyXG5cdHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBmaW5kICNjYW52YXMtY29udGFpbmVyXCIpO1xyXG59XHJcblxyXG5jb25zdCBhc3NldHMgPSBuZXcgV2ViQXNzZXRMb2FkZXIoKTtcclxuXHJcbmNvbnN0IHJlbmRlcmVyID0gbmV3IFJlYWN0UmVuZGVyZXIoPEdhbWUgLz4pO1xyXG5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gZHJhdygpIHtcclxuXHRjb25zdCBmcmFtZTogRnJhbWVDb2xsZWN0aW9uID0gcmVuZGVyZXIuZnJhbWUoKSBhcyBGcmFtZUNvbGxlY3Rpb247XHJcblx0cmVuZGVyVG9DYW52YXMoeyBjYW52YXMsIGNvbnRleHQsIGFzc2V0cyB9LCBmcmFtZSk7XHJcblx0cmVxdWVzdEFuaW1hdGlvbkZyYW1lKGRyYXcpO1xyXG59KTtcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2VuZ2luZS9icm93c2VyL2hvdC1yZWxvYWQudHN4IiwiaW1wb3J0IFwiQGJhYmVsL3BvbHlmaWxsXCI7XHJcblxyXG5pbXBvcnQgKiAgYXMgUmVhY3QgZnJvbSBcInJlYWN0XCI7XHJcblxyXG5pbXBvcnQgeyBGcmFtZSwgRnJhbWVDb2xsZWN0aW9uIH0gZnJvbSBcIkBtb3JsZXlkZXYvcGF1cGVyL3JlbmRlci9yZW5kZXItZnJhbWUubW9kZWxcIjtcclxuXHJcbmltcG9ydCB7IEdhbWUgfSBmcm9tIFwiLi4vLi4vbWFpbi9nYW1lLXJlbmRlclwiO1xyXG5pbXBvcnQgeyBSZWFjdFJlbmRlcmVyIH0gZnJvbSBcIkBtb3JsZXlkZXYvcGF1cGVyL3JlbmRlci9qc3gvcmVuZGVyXCI7XHJcbmltcG9ydCB7IFdlYkFzc2V0TG9hZGVyIH0gZnJvbSBcIkBtb3JsZXlkZXYvcGF1cGVyL2Fzc2V0cy93ZWItYXNzZXQtbG9hZGVyLnNlcnZpY2VcIjtcclxuaW1wb3J0IHsgcmVuZGVyVG9DYW52YXMgfSBmcm9tIFwiQG1vcmxleWRldi9wYXVwZXIvcmVuZGVyL3JlbmRlci10by1jYW52YXMuZnVuY1wiO1xyXG5cclxuY29uc3QgY2FudmFzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJyZW5kZXItdGFyZ2V0XCIpIGFzIEhUTUxDYW52YXNFbGVtZW50IHwgbnVsbDtcclxuaWYgKGNhbnZhcyA9PSBudWxsKSB7XHJcblx0dGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IGZpbmQgI3JlbmRlci10YXJnZXRcIik7XHJcblxyXG59XHJcbmNvbnN0IGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xyXG5pZiAoY29udGV4dCA9PSBudWxsKSB7XHJcblx0dGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IGFjcXVpcmUgMmQgcmVuZGVyaW5nIGNvbnRleHRcIik7XHJcbn1cclxuY29uc3QgZWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiY2FudmFzLWNvbnRhaW5lclwiKTtcclxuaWYgKGVsZW1lbnQgPT0gbnVsbCkge1xyXG5cdHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBmaW5kICNjYW52YXMtY29udGFpbmVyXCIpO1xyXG59XHJcblxyXG5jb25zdCBhc3NldHMgPSBuZXcgV2ViQXNzZXRMb2FkZXIoKTtcclxuXHJcbmNvbnN0IHJlbmRlcmVyID0gbmV3IFJlYWN0UmVuZGVyZXIoPEdhbWUgLz4pO1xyXG5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gZHJhdygpIHtcclxuXHRjb25zdCBmcmFtZTogRnJhbWVDb2xsZWN0aW9uID0gcmVuZGVyZXIuZnJhbWUoKSBhcyBGcmFtZUNvbGxlY3Rpb247XHJcblx0cmVuZGVyVG9DYW52YXMoeyBjYW52YXMsIGNvbnRleHQsIGFzc2V0cyB9LCBmcmFtZSk7XHJcblx0cmVxdWVzdEFuaW1hdGlvbkZyYW1lKGRyYXcpO1xyXG59KTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvZW5naW5lL2Jyb3dzZXIvcHJvZHVjdGlvbi50c3giLCJpbXBvcnQgXCJAYmFiZWwvcG9seWZpbGxcIjtcclxuXHJcbmltcG9ydCB7IGlzQnJvd3NlciB9IGZyb20gXCJAbW9ybGV5ZGV2L3BhdXBlci91dGlsaXR5L2lzLWJyb3dzZXJcIjtcclxuaW1wb3J0IHsgaXNQcm9kdWN0aW9uIH0gZnJvbSBcIkBtb3JsZXlkZXYvcGF1cGVyL3V0aWxpdHkvaXMtcHJvZHVjdGlvblwiO1xyXG5cclxuaWYgKGlzQnJvd3Nlcikge1xyXG5cdGlmICghaXNQcm9kdWN0aW9uICYmIChtb2R1bGUgYXMgYW55KS5ob3QpIHtcclxuXHRcdHJlcXVpcmUoXCIuL2VuZ2luZS9icm93c2VyL2hvdC1yZWxvYWRcIik7XHJcblx0fSBlbHNlIHtcclxuXHRcdHJlcXVpcmUoXCIuL2VuZ2luZS9icm93c2VyL3Byb2R1Y3Rpb25cIik7XHJcblx0fVxyXG59IGVsc2Uge1xyXG59XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9pbmRleC50cyIsImltcG9ydCBcIkBtb3JsZXlkZXYvcGF1cGVyL3JlbmRlci9qc3gvcmVuZGVyXCI7XHJcblxyXG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tIFwicmVhY3RcIjtcclxuXHJcbmltcG9ydCB7IENpcmNsZSwgUG9pbnQyIH0gZnJvbSBcIkBtb3JsZXlkZXYvcGF1cGVyL21vZGVscy9zaGFwZXMubW9kZWxcIjtcclxuaW1wb3J0IHsgQ2xlYXIsIEZpbGwsIEZyYW1lQ29sbGVjdGlvbiwgT3JpZ2luLCBSb3RhdGUgfSBmcm9tIFwiQG1vcmxleWRldi9wYXVwZXIvcmVuZGVyL3JlbmRlci1mcmFtZS5tb2RlbFwiO1xyXG5pbXBvcnQgeyBSR0IsIFJHQkEgfSBmcm9tIFwiQG1vcmxleWRldi9wYXVwZXIvbW9kZWxzL2NvbG91ci5tb2RlbFwiO1xyXG5pbXBvcnQgeyBjb25jYXQsIHJhbmdlIH0gZnJvbSBcIkBtb3JsZXlkZXYvZnVuY3Rpb25hbC1waXBlL2l0ZXJhYmxlL2dlbmVyYXRvcnNcIjtcclxuXHJcbmltcG9ydCB7ICQkIH0gZnJvbSBcIkBtb3JsZXlkZXYvZnVuY3Rpb25hbC1waXBlXCI7XHJcbmltcG9ydCB7IEVudGl0eUlkIH0gZnJvbSBcIkBtb3JsZXlkZXYvcGF1cGVyL2Vjcy9lbnRpdHktYmFzZS50eXBlXCI7XHJcbmltcG9ydCB7IGZsYXRNYXAgfSBmcm9tIFwiQG1vcmxleWRldi9mdW5jdGlvbmFsLXBpcGUvaXRlcmFibGUvb3BlcmF0b3JzXCI7XHJcblxyXG5leHBvcnQgY29uc3QgR2FtZSA9IChwcm9wczoge30pOiBKU1guRWxlbWVudCA9PiAoXHJcblx0PGNsZWFyIGNvbG91cj17UkdCKDAsIDAsIDApfT5cclxuXHRcdDxvcmlnaW4gY29vcmRzPXtQb2ludDIoMjU2LCAyNTYpfT5cclxuXHRcdFx0PEJhbGxDb2xvdXJGYWRlciAvPlxyXG5cdFx0PC9vcmlnaW4+XHJcblx0PC9jbGVhcj5cclxuKTtcclxuXHJcbmNsYXNzIEJhbGxDb2xvdXJGYWRlciBleHRlbmRzIFJlYWN0LkNvbXBvbmVudDx7fSwgeyBjb2xvdXI6IFJHQkEgfT4ge1xyXG5cdHByaXZhdGUgY29sb3VyV2hlZWw6IFJHQkFbXSA9IFtdO1xyXG5cdHByaXZhdGUgdGltZXI6IGFueSA9IG51bGw7XHJcblxyXG5cdGNvbnN0cnVjdG9yKHByb3BzOiB7IGNvbG91cnM6IFJlYWRvbmx5QXJyYXk8UkdCQT4gfSkge1xyXG5cdFx0c3VwZXIocHJvcHMpO1xyXG5cdFx0dGhpcy5zdGF0ZSA9IHtcclxuXHRcdFx0Y29sb3VyOiBSR0JBKDAsIDAsIDAsIDEpXHJcblx0XHR9O1xyXG5cdH1cclxuXHJcblx0cHVibGljIGNvbXBvbmVudFdpbGxNb3VudCgpIHtcclxuXHRcdHRoaXMudGltZXIgPSBzZXRJbnRlcnZhbCgoKSA9PiB0aGlzLnNldFN0YXRlKHN0YXRlID0+ICh7IGNvbG91cjogUkdCQShNYXRoLnJhbmRvbSgpICogMjU1LCBNYXRoLnJhbmRvbSgpICogMjU1LCBNYXRoLnJhbmRvbSgpICogMjU1LCAxKSB9KSksIDUwKTtcclxuXHR9XHJcblxyXG5cdHB1YmxpYyBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcclxuXHRcdGNsZWFySW50ZXJ2YWwodGhpcy50aW1lcik7XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgcmVuZGVyKCkge1xyXG5cdFx0Y29uc29sZS5sb2codGhpcy5zdGF0ZS5jb2xvdXIpXHJcblx0XHRyZXR1cm4gPGZpbGwgc2hhcGU9e0NpcmNsZSgwLCAwLCAyNSl9IGNvbG91cj17dGhpcy5zdGF0ZS5jb2xvdXJ9IC8+O1xyXG5cdH1cclxufVxyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvbWFpbi9nYW1lLXJlbmRlci50c3giXSwic291cmNlUm9vdCI6IiJ9